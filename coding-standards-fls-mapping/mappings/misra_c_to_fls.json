{
  "standard": "MISRA-C",
  "standard_version": "2025",
  "fls_version": "1.0 (2024)",
  "mapping_date": "2025-12-31",
  "methodology": "Semantic embedding similarity + manual verification. High confidence mappings verified against MISRA rationale and FLS content.",
  "statistics": {
    "total_guidelines": 223,
    "mapped": 196,
    "unmapped": 27,
    "not_applicable": 95,
    "rust_prevents": 2,
    "preserved_high_confidence": 14,
    "avg_matches_per_guideline": 8.9,
    "matches_by_category": {
      "section": 699,
      "general": 18,
      "legality_rules": 1044,
      "implementation_requirements": 5,
      "dynamic_semantics": 137,
      "undefined_behavior": 31
    },
    "thresholds": {
      "section": 0.5,
      "paragraph": 0.55
    }
  },
  "mappings": [
    {
      "guideline_id": "Dir 1.1",
      "guideline_title": "Any implementation-defined behaviour on which the output of the program depends shall be documented and understood C90",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_usgd0xlijoxv",
          "fls_title": "ABI",
          "category": 0,
          "score": 0.64,
          "reason": "FLS defines ABI conventions including extern C, Rust, and system ABIs. Per FLS 'Application Binary Interface or ABI is a set of conventions that dictate how data and computation cross language boundaries.' This directly addresses MISRA's concern about ABI documentation."
        },
        {
          "fls_id": "fls_99b7xi1bkgih",
          "fls_title": "Conformity",
          "category": 0,
          "score": 0.61,
          "reason": "FLS Conformity section specifies tool requirements including 'A tool that conforms to this document shall produce for the execution of a given Rust program a set of interactions with the external environment whose order and timing are consistent with the definitions.' Addresses implementation conformance."
        },
        {
          "fls_id": "fls_10yukmkhl0ng",
          "fls_title": "Extent",
          "category": 0,
          "score": 0.61,
          "reason": "FLS Extent explicitly lists what is and is not specified, including 'The effect of undefined behavior' as not specified. Addresses documentation of implementation-defined scope."
        },
        {
          "fls_id": "fls_j6pqchx27ast",
          "fls_title": "ABI",
          "category": -6,
          "score": 0.57,
          "reason": "FLS implementation_permissions for ABI states 'A tool is allowed to specify additional ABIs' listing platform-specific options like aapcs, cdecl, stdcall, win64. Documents allowed implementation extensions."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "FLS addresses implementation-defined behavior through explicit ABI specifications, conformity requirements, and clear documentation of what is/isn't specified. Rust's approach differs from C by having a formal specification (FLS) that defines most behavior explicitly, reducing the scope of implementation-defined behavior compared to C.",
      "rejected_matches": [
        {
          "fls_id": "fls_jep7p27kaqlp",
          "fls_title": "Unsafety",
          "category": 0,
          "score": 0.63,
          "reason": "General unsafe operations section - not specifically about implementation-defined behavior documentation."
        },
        {
          "fls_id": "fls_dv1qish8svc",
          "fls_title": "Scope",
          "category": -1,
          "score": 0.62,
          "reason": "About FLS document scope and contribution process, not implementation-defined behavior."
        }
      ]
    },
    {
      "guideline_id": "Dir 1.2",
      "guideline_title": "The use of language extensions should be minimized",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_fo1c7pg2mw1",
          "fls_title": "Scope",
          "category": 0,
          "score": 0.5,
          "reason": "FLS Scope explicitly documents the 2021 Edition of Rust as implemented by rustc. This defines the standard language - anything outside is an extension."
        },
        {
          "fls_id": "fls_9cd746qe40ag",
          "fls_title": "Versioning",
          "category": 0,
          "score": 0.59,
          "reason": "FLS Versioning states this is the specification for a qualified compiler version. Extensions (unstable features) are not documented in FLS."
        },
        {
          "fls_id": "fls_99b7xi1bkgih",
          "fls_title": "Conformity",
          "category": 0,
          "score": 0.51,
          "reason": "FLS Conformity defines tool conformance requirements. Per fls_d07x1mbhgpsd, tools may provide additional attributes but names must not conflict with built-in ones."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "misra_rust_comment": "previously Rule 1.2",
      "confidence": "high",
      "notes": "Rust handles extensions via feature gates requiring #![feature(...)]. FLS documents only stable Rust 2021 Edition, so unstable features are inherently excluded. The edition system and qualified compiler versioning address MISRA portability concern.",
      "rejected_matches": [
        {
          "fls_id": "fls_dv1qish8svc",
          "fls_title": "Scope",
          "category": -1,
          "score": 0.71,
          "reason": "High similarity score but paragraph discusses FLS purpose, not language extensions directly."
        },
        {
          "fls_id": "fls_xscgklvg1wd2",
          "fls_title": "Structure",
          "category": 0,
          "score": 0.58,
          "reason": "Discusses FLS document structure, not language extensions."
        },
        {
          "fls_id": "fls_usgd0xlijoxv",
          "fls_title": "ABI",
          "category": 0,
          "score": 0.57,
          "reason": "ABI section is about calling conventions, not language extensions."
        }
      ]
    },
    {
      "guideline_id": "Dir 2.1",
      "guideline_title": "All source files shall compile without any compilation errors",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_99b7xi1bkgih",
          "fls_title": "Conformity",
          "category": 0,
          "score": 0.51,
          "reason": "FLS Conformity directly addresses this. Per fls_GZmxrO61eiJ1: A conforming tool shall reject programs that contain errors whose detection is required. Per fls_dBKu9jgx3OyH: Correctly translate legal programs."
        },
        {
          "fls_id": "fls_10yukmkhl0ng",
          "fls_title": "Extent",
          "category": 0,
          "score": 0.5,
          "reason": "FLS Extent (fls_7tm19jxtffc8): Specifies violations that a conforming tool is required to detect, and the effect of attempting to translate programs containing such violations."
        }
      ],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "Rust enforces this more strictly than C. rustc will not produce an executable when compilation errors exist - the build fails completely. FLS Conformity explicitly requires rejecting erroneous programs.",
      "rejected_matches": [
        {
          "fls_id": "fls_u1afezy1ye99",
          "fls_title": "Conditional Compilation",
          "category": 0,
          "score": 0.54,
          "reason": "Conditional compilation is about cfg attributes, not about compilation error handling."
        },
        {
          "fls_id": "fls_9cd746qe40ag",
          "fls_title": "Versioning",
          "category": 0,
          "score": 0.55,
          "reason": "Versioning discusses qualified compiler versions, not error rejection."
        }
      ]
    },
    {
      "guideline_id": "Dir 3.1",
      "guideline_title": "All code shall be traceable to documented requirements",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "Dir 3.1 is a process/methodology guideline about code traceability to requirements. The FLS does not prescribe project management or requirements traceability processes. However, Rust provides #[doc] attribute and doc comments as language-level infrastructure to associate documentation with code constructs, which supports traceability implementation at the code level.",
      "accepted_matches": [
        {
          "fls_id": "fls_63v1fqedzwfd",
          "fls_title": "Attribute doc",
          "category": 0,
          "score": 0.47,
          "reason": "FLS doc attribute provides infrastructure for associating documentation with constructs, supporting traceability at the code level"
        },
        {
          "fls_id": "fls_7n6d3jx61ose",
          "fls_title": "Doc Comments",
          "category": -2,
          "score": 0.58,
          "reason": "FLS doc comments (/// and //!) are semantically equivalent to #[doc] attributes, enabling documentation directly in source code"
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "no_equivalent"
    },
    {
      "guideline_id": "Dir 4.1",
      "guideline_title": "Run-time failures shall be minimized C90",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_ZfIBiJMf8qE1",
          "fls_title": "Arithmetic Overflow",
          "category": 0,
          "score": 0.6,
          "reason": "FLS explicitly documents arithmetic overflow behavior. In debug mode, overflow causes panic. In release, behavior is configurable. Per fls_R48VKcEIbfXC: Evaluation may result in a panic."
        },
        {
          "fls_id": "fls_1k9mkv7rbezi",
          "fls_title": "Arithmetic Expressions",
          "category": 0,
          "score": 0.5,
          "reason": "FLS documents runtime behavior for division by zero. Per fls_Q9dhNiICGIfr: If unsigned division operand is 0, operation results in panic."
        },
        {
          "fls_id": "fls_k02nt1m5fq1z",
          "fls_title": "Panic",
          "category": 0,
          "score": 0.42,
          "reason": "FLS Panic section (fls_a554v4n0khye): A panic is an abnormal program state. Rust uses panic for runtime error signaling rather than undefined behavior."
        },
        {
          "fls_id": "fls_dzq9cdz4ibsz",
          "fls_title": "Exceptions and Errors",
          "category": 0,
          "score": 0.4,
          "reason": "FLS Ch.16 documents Rust error handling: Option for absent values, Result for erroneous computations, panic for unrecoverable errors. This is the Rust mechanism for addressing MISRA runtime failure concerns."
        },
        {
          "fls_id": "fls_sxcr4aa098i6",
          "fls_title": "Indexing Expressions",
          "category": 0,
          "score": 0.4,
          "reason": "FLS documents index expressions. Rust performs bounds checking at runtime for array/slice indexing."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "often in the form of panics",
      "confidence": "high",
      "notes": "Rust provides extensive built-in runtime checking: overflow detection, bounds checking, null pointer prevention. Panics are the primary mechanism for handling runtime failures. Unlike C where runtime errors lead to UB, Rust explicitly defines panic behavior.",
      "rejected_matches": [
        {
          "fls_id": "fls_jep7p27kaqlp",
          "fls_title": "Unsafety",
          "category": 0,
          "score": 0.57,
          "reason": "Unsafety is about unsafe operations, not specifically about runtime failure minimization."
        }
      ]
    },
    {
      "guideline_id": "Dir 4.2",
      "guideline_title": "All usage of assembly language should be documented",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_z1il3w9nulzy",
          "fls_title": "Inline Assembly",
          "category": 0,
          "score": 0.5,
          "reason": "FLS Chapter 22 Inline Assembly section documents all aspects of assembly in Rust. Per fls_leamdp1r3hez: Inline assembly is hand-written assembly code integrated into Rust."
        },
        {
          "fls_id": "fls_e0896uk0mdyl",
          "fls_title": "Assembly Instructions",
          "category": 0,
          "score": 0.61,
          "reason": "FLS documents assembly instruction syntax and semantics. Per fls_4jr7eg6e0g4w: An assembly instruction is a string literal representing a low-level assembly operation."
        },
        {
          "fls_id": "fls_qezwyridmjob",
          "fls_title": "Macros asm global_asm naked_asm",
          "category": 0,
          "score": 0.45,
          "reason": "FLS documents the macros core::arch::asm, global_asm, and naked_asm for embedding assembly. Assembly blocks are explicit and require unsafe context."
        },
        {
          "fls_id": "fls_ylli0ortyegk",
          "fls_title": "Assembly Options",
          "category": 0,
          "score": 0.57,
          "reason": "FLS documents assembly options (nomem, noreturn, nostack, preserves_flags, pure, readonly, etc.) that constrain assembly behavior."
        },
        {
          "fls_id": "fls_6momhvgx4w21",
          "fls_title": "Directive Support",
          "category": 0,
          "score": 0.56,
          "reason": "FLS documents supported assembly directives per architecture (.text, .data, .align, etc.)."
        },
        {
          "fls_id": "fls_j9l8wn6wgm06",
          "fls_title": "Registers",
          "category": 0,
          "score": 0.45,
          "reason": "FLS documents register names, aliases, and restrictions per architecture (AArch64, ARM, RISC-V, x86)."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "FLS Chapter 22 comprehensively documents Rust inline assembly. All assembly requires unsafe blocks making it explicit and auditable. The asm! macro syntax ensures assembly is clearly marked in source code.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Dir 4.3",
      "guideline_title": "Assembly language shall be encapsulated and isolated",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_z1il3w9nulzy",
          "category": 0,
          "fls_section": "22.1",
          "fls_title": "Inline Assembly",
          "score": 0.588,
          "reason": "Parent section covering Rust's structured inline assembly approach. All assembly in Rust must go through the macro-based system defined here."
        },
        {
          "fls_id": "fls_ecteot716j8j",
          "category": -2,
          "fls_section": "22.8",
          "fls_title": "Macros: asm, global_asm, and naked_asm",
          "score": null,
          "reason": "Per FLS: 'Assembly code blocks are embedded within Rust source code using macros core::arch::asm, core::arch::global_asm, and core::arch::naked_asm.' This directly addresses MISRA's encapsulation requirement - Rust mandates macro encapsulation."
        },
        {
          "fls_id": "fls_4lb6yh12w1cv",
          "category": -2,
          "fls_section": "22.8",
          "fls_title": "Macros: asm, global_asm, and naked_asm",
          "score": 0.62,
          "reason": "Per FLS: 'Invoking macro core::arch::asm causes the related assembly code block to be integrated into the generated assembly of the function where the macro invocation took place.' Assembly is isolated to specific macro invocations."
        },
        {
          "fls_id": "fls_qezwyridmjob",
          "category": 0,
          "fls_section": "22.8",
          "fls_title": "Macros: asm, global_asm, and naked_asm",
          "score": 0.533,
          "reason": "Section describing the macro-based encapsulation mechanism for inline assembly."
        }
      ],
      "rejected_matches": [
        {
          "fls_id": "fls_e0896uk0mdyl",
          "category": 0,
          "fls_section": "22.5",
          "score": 0.691,
          "reason": "High similarity due to 'assembly' keyword but covers instruction syntax details, not encapsulation requirements."
        },
        {
          "fls_id": "fls_ylli0ortyegk",
          "category": 0,
          "fls_section": "22.6",
          "score": 0.662,
          "reason": "About assembly options like att_syntax, not encapsulation."
        },
        {
          "fls_id": "fls_6momhvgx4w21",
          "category": 0,
          "fls_section": "22.7",
          "score": 0.656,
          "reason": "About assembler directives (.byte, .align), not Rust encapsulation requirements."
        },
        {
          "fls_id": "fls_hejgghwzblf",
          "category": 0,
          "fls_section": "22.4",
          "score": 0.58,
          "reason": "Register handling implementation details, not encapsulation."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "confidence": "high",
      "notes": "Rust enforces MISRA Dir 4.3 by design: all inline assembly must use the core::arch::{asm, global_asm, naked_asm} macros. There is no way to write raw assembly without macro encapsulation. This satisfies MISRA's goal of encapsulation and isolation."
    },
    {
      "guideline_id": "Dir 4.4",
      "guideline_title": "Sections of code should not be \u201ccommented out\u201d",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_q8l2jza7d9xa",
          "fls_title": "Comments",
          "category": 0,
          "score": 0.64,
          "reason": "FLS Comments section defines block comments that can legally nest (unlike C), reducing the primary risk MISRA identifies"
        },
        {
          "fls_id": "fls_fymvsy6ig99a",
          "fls_title": "Attribute cfg",
          "category": 0,
          "score": 0.67,
          "reason": "FLS cfg attribute provides proper conditional compilation mechanism, the recommended alternative to commenting out code"
        },
        {
          "fls_id": "fls_dd9xh3wdjudo",
          "fls_title": "Attribute cfg_attr",
          "category": 0,
          "score": 0.87,
          "reason": "FLS cfg_attr enables conditional attribute application, another mechanism for conditional compilation"
        },
        {
          "fls_id": "fls_u1afezy1ye99",
          "fls_title": "Conditional Compilation",
          "category": 0,
          "score": 0.61,
          "reason": "FLS defines how cfg attributes control conditional compilation, providing safe code exclusion"
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "advisory",
      "confidence": "high",
      "notes": "MISRA concern is that C comments cannot nest, causing unexpected behavior when commenting out code. Rust block comments CAN nest safely. Additionally, Rust provides #[cfg(...)] and #[cfg_attr(...)] attributes as the proper mechanism for conditional compilation, which is the recommended approach instead of commenting out code.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Dir 4.5",
      "guideline_title": "Identifiers in the same name space with overlapping visibility should be typographically unambiguous",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_21vnag69kbwe",
          "fls_title": "Identifiers",
          "category": 0,
          "score": 0.63,
          "reason": "FLS Identifiers section documents identifier syntax and normalization rules."
        },
        {
          "fls_id": "fls_vde7gev5rz4q",
          "fls_title": "Identifiers",
          "category": -2,
          "score": 0.6,
          "reason": "FLS requires NFC normalization: Identifiers are normalized using Normalization Form C per Unicode Standard Annex #15."
        },
        {
          "fls_id": "fls_j9yh8j8jgdeu",
          "fls_title": "Identifiers",
          "category": -2,
          "score": 0.67,
          "reason": "FLS defines identifier equivalence: Two identifiers are the same if they consist of the same sequence of characters after normalization."
        },
        {
          "fls_id": "fls_cs6cbw625np1",
          "fls_title": "Identifiers",
          "category": -2,
          "score": 0.5,
          "reason": "FLS prohibits zero-width characters: Characters 0x200C (ZWNJ) and 0x200D (ZWJ) shall not appear in a pure identifier."
        },
        {
          "fls_id": "fls_irwcldiotei2",
          "fls_title": "Identifiers",
          "category": -2,
          "score": 0.65,
          "reason": "FLS restricts to ASCII in key contexts: external blocks, no_mangle items, crate imports - reducing confusable character risks."
        }
      ],
      "fls_rationale_type": "partial_mapping",
      "misra_rust_category": "recommended",
      "misra_rust_comment": "\u201cambiguity\u201d is determined by the project",
      "confidence": "high",
      "notes": "FLS addresses identifier normalization and prohibits problematic zero-width characters. ASCII-only is enforced in FFI contexts. However, full typographic ambiguity detection (e.g., Cyrillic '\u0430' vs Latin 'a') is project/tooling responsibility per MISRA ADD-6 note.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Dir 4.6",
      "guideline_title": "typedefs that indicate size and signedness should be used in place of the basic integer types",
      "guideline_type": "directive",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "misra_rust_comment": "all primitive types already fulfil this",
      "confidence": "high",
      "notes": "Rust primitive types (i8, u16, i32, etc.) already encode size and signedness in the type name. No typedefs needed for this purpose. Per ADD-6: 'all primitive types already fulfil this'.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Dir 4.7",
      "guideline_title": "If a function returns error information, then that error information shall be tested",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_dzq9cdz4ibsz",
          "fls_title": "Exceptions and Errors",
          "category": 0,
          "score": 0.5,
          "reason": "FLS Chapter 16 defines Rust's error handling: 'The result of a possibly erroneous computation is usually represented using enum core::result::Result.' Result and Option types force callers to explicitly handle success/error cases, directly addressing MISRA's concern about testing error information."
        },
        {
          "fls_id": "fls_pocsh1neugpc",
          "fls_title": "Error Propagation Expression",
          "category": 0,
          "score": 0.51,
          "reason": "FLS defines the ? operator for error propagation. Per FLS: 'An error propagation expression either evaluates to a value of its operand or returns a value to the enclosing control flow boundary.' This enforces explicit error handling."
        },
        {
          "fls_id": "fls_rgjf5ibhurda",
          "fls_title": "Attribute must_use",
          "category": -2,
          "score": 0.45,
          "reason": "FLS lists must_use as a diagnostics attribute. Result and Option are marked #[must_use], causing compiler warnings when return values are ignored - directly enforcing MISRA's requirement to test error information."
        },
        {
          "fls_id": "fls_ckeitwiv326r",
          "fls_title": "Exceptions and Errors",
          "category": -2,
          "score": 0.5,
          "reason": "Per FLS: 'The result of a possibly erroneous computation is usually represented using enum core::result::Result.' This establishes the pattern for error representation."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "advisory",
      "misra_rust_comment": "prefer Option, Result, etc.",
      "confidence": "high",
      "notes": "Rust's type system enforces error handling through Result<T,E> and Option<T>. Unlike C where error codes can be silently ignored, Rust requires explicit handling via pattern matching, unwrap(), expect(), or the ? operator. The #[must_use] attribute on Result/Option generates compiler warnings if values are discarded. This provides stronger guarantees than MISRA's requirement.",
      "rejected_matches": [
        {
          "fls_id": "fls_dv2j1fvvnk1t",
          "fls_title": "Attribute test",
          "category": 0,
          "score": 0.53,
          "reason": "About #[test] attribute for unit testing, not about testing/checking error return values."
        }
      ]
    },
    {
      "guideline_id": "Dir 4.8",
      "guideline_title": "If a pointer to a structure or union is never dereferenced within a translation unit, then the implementation of the object should be hidden",
      "guideline_type": "directive",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust's module system and visibility controls replace C's incomplete type pattern for information hiding. Use `pub(crate)` or private modules instead.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Dir 4.9",
      "guideline_title": "A function should be used in preference to a function-like macro where they are interchangeable",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_qcb1n9c0e5hz",
          "fls_title": "Functions",
          "category": 0,
          "score": 0.68,
          "reason": "FLS Chapter 9 defines functions with strong type checking. Per FLS: 'A function parameter is a construct that yields a set of bindings that bind matched input values to names.' Function parameters have explicit types that are checked at compile time, addressing MISRA's concern about type-checking benefits."
        },
        {
          "fls_id": "fls_2d6bqnpy6tvs",
          "fls_title": "Function-like Macros",
          "category": 0,
          "score": 0.64,
          "reason": "FLS defines function-like macros as 'a procedural macro that consumes a stream of tokens and produces a stream of tokens.' Unlike C macros, Rust's procedural macros are type-aware and hygienic, reducing but not eliminating the preference for functions."
        },
        {
          "fls_id": "fls_ypio6boj3pwf",
          "fls_title": "Attribute inline",
          "category": 0,
          "score": 0.59,
          "reason": "FLS defines the inline attribute for functions, providing the performance benefits of macros without sacrificing type safety. This addresses MISRA's note about inline functions as an alternative."
        },
        {
          "fls_id": "fls_AAYJDCNMJgTq",
          "fls_title": "Functions",
          "category": -2,
          "score": 0.68,
          "reason": "Per FLS: 'The type of a function parameter is determined as follows...' This establishes compile-time type checking for function parameters."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "recommended",
      "confidence": "high",
      "notes": "Rust's macro system is hygienic and type-aware, making macros safer than C macros. However, the principle of preferring functions remains valid: functions provide explicit type checking, clearer debugging, and argument evaluation semantics. Rust's const fn and inline attributes provide alternatives when compile-time evaluation or performance is needed.",
      "rejected_matches": [
        {
          "fls_id": "fls_Sd6rUmpEb355",
          "fls_title": "Attribute naked",
          "category": 0,
          "score": 0.52,
          "reason": "About naked functions for low-level assembly, not relevant to macro vs function choice."
        }
      ]
    },
    {
      "guideline_id": "Dir 4.10",
      "guideline_title": "Precautions shall be taken in order to prevent the contents of a header file being included more than once",
      "guideline_type": "directive",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust's module system prevents duplicate inclusion inherently. No header guards needed - each module is compiled once. `mod` declarations handle inclusion.",
      "accepted_matches": [],
      "rejected_matches": []
    },
    {
      "guideline_id": "Dir 4.11",
      "guideline_title": "The validity of values passed to library functions shall be checked C90",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_dzq9cdz4ibsz",
          "fls_title": "Exceptions and Errors",
          "category": 0,
          "score": 0.5,
          "reason": "FLS Chapter 16 establishes Rust's error handling model. Per FLS: 'A possibly absent value is usually represented using enum core::option::Option' and 'The result of a possibly erroneous computation is usually represented using enum core::result::Result.' Rust library functions return Option/Result rather than using restricted domains with undefined behavior."
        },
        {
          "fls_id": "fls_lv7w7aalpwm5",
          "fls_title": "Type Inference",
          "category": 0,
          "score": 0.54,
          "reason": "FLS defines Rust's type inference system which catches type mismatches at compile time. This provides stronger static checking than runtime validation of input domains."
        },
        {
          "fls_id": "fls_juysxea25owj",
          "fls_title": "Char Type",
          "category": -4,
          "score": 0.58,
          "reason": "FLS defines validity invariants: 'It is a validity invariant for a value of type char to be inside the 0x000 - 0xD7FF or the 0xE000 - 0x10FFFF inclusive ranges.' This demonstrates how Rust defines valid value ranges at the type level."
        },
        {
          "fls_id": "fls_2sd39mj05mb9",
          "fls_title": "Bool Type",
          "category": -4,
          "score": 0.57,
          "reason": "Per FLS: 'It is a validity invariant for a value of type bool to have a bit pattern of 0x00 and 0x01.' Rust enforces value validity through type invariants rather than runtime checks."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "advisory",
      "confidence": "high",
      "notes": "Rust addresses this differently than C. Instead of requiring runtime validation of restricted domains, Rust: (1) uses Option<T> for possibly-absent values, (2) uses Result<T,E> for fallible operations, (3) defines validity invariants at the type level, (4) uses the type system to prevent invalid values. For example, Rust's sqrt returns Option<f64> rather than having undefined behavior for negative inputs. The MISRA concern is addressed through Rust's type-driven design rather than manual precondition checking.",
      "rejected_matches": [
        {
          "fls_id": "fls_B0SMXRqQMS1E",
          "fls_title": "Function Pointer Types",
          "category": -2,
          "score": 0.61,
          "reason": "About C-like variadic parameters, not about validating function inputs."
        }
      ]
    },
    {
      "guideline_id": "Dir 4.12",
      "guideline_title": "Dynamic memory allocation shall not be used",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "misra_rust_category": "advisory",
      "confidence": "high",
      "notes": "MISRA concern is about unpredictable malloc/free behavior. Rust provides: (1) #[no_std] for bare-metal development without heap, (2) #[global_allocator] for custom allocator control, (3) explicit opt-in to alloc crate for heap types. Unlike C where malloc/free are always available, Rust requires explicit crate inclusion for heap allocation, making allocation policy more controllable and auditable.",
      "accepted_matches": [
        {
          "fls_id": "fls_fs0lcfllamj",
          "fls_title": "Attribute global_allocator",
          "category": 0,
          "score": 0.62,
          "reason": "FLS global_allocator attribute controls memory allocation, allowing custom allocators that can enforce allocation policies"
        },
        {
          "fls_id": "fls_9xnaxd7qbakp",
          "fls_title": "Attribute no_std",
          "category": 0,
          "score": 0.6,
          "reason": "FLS no_std attribute removes std library, enabling embedded/bare-metal development without heap allocation"
        },
        {
          "fls_id": "fls_94a8v54bufn8",
          "fls_title": "Values",
          "category": 0,
          "score": 0.46,
          "reason": "FLS Values section defines allocated objects and their memory layout, providing foundation for understanding allocation"
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "direct_mapping"
    },
    {
      "guideline_id": "Dir 4.13",
      "guideline_title": "Functions which are designed to provide operations on a resource should be called in an appropriate sequence",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_svkx6szhr472",
          "fls_title": "Ownership",
          "category": 0,
          "score": 0.6,
          "reason": "FLS defines ownership as 'central to the resource management model of Rust.' Per FLS: 'A value shall have only one owner.' This ensures resources have clear ownership and lifecycle."
        },
        {
          "fls_id": "fls_u2mzjgiwbkz0",
          "fls_title": "Destructors",
          "category": 0,
          "score": 0.55,
          "reason": "FLS defines destructors: 'A destructor is a function that is invoked immediately before the destruction of a value of a drop type.' Drop ensures cleanup happens automatically when values go out of scope - enforcing proper sequencing."
        },
        {
          "fls_id": "fls_4jiw35pan7vn",
          "fls_title": "Destruction",
          "category": 0,
          "score": 0.55,
          "reason": "Per FLS: 'Destruction is the process of recovering resources associated with a value as it goes out of scope.' This guarantees deallocation functions are called in the correct sequence."
        },
        {
          "fls_id": "fls_e7ucq87s806d",
          "fls_title": "Destruction",
          "category": -2,
          "score": 0.55,
          "reason": "FLS explicitly states destruction 'is the process of recovering resources associated with a value as it goes out of scope' - directly addressing MISRA's concern about resource deallocation."
        }
      ],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "Rust's ownership system and Drop trait provide compile-time enforcement of proper resource sequencing. Resources are automatically cleaned up when they go out of scope via destructors. RAII pattern is built into the language - the compiler ensures deallocation happens, and in the correct order (reverse order of acquisition). This is stronger than MISRA's requirement for static analysis checks.",
      "rejected_matches": [
        {
          "fls_id": "fls_xdvdl2ssnhlo",
          "fls_title": "Statics",
          "category": 0,
          "score": 0.62,
          "reason": "About static variables, not resource sequencing."
        },
        {
          "fls_id": "fls_zJOAmSr3Dbqk",
          "fls_title": "Diverging Expressions",
          "category": 0,
          "score": 0.61,
          "reason": "About diverging expressions (never type), not resource management."
        }
      ]
    },
    {
      "guideline_id": "Dir 4.14",
      "guideline_title": "The validity of values received from external sources shall be checked C90",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_osd6c4utyjb3",
          "fls_title": "FFI",
          "category": 0,
          "score": 0.57,
          "reason": "FLS Chapter 21 defines FFI for interfacing with foreign code. Per FLS: 'Foreign Function Interface or FFI employs ABI, attributes, external blocks, external functions, linkage, and type layout to interface a Rust program with foreign code.' External data comes through FFI boundaries."
        },
        {
          "fls_id": "fls_yztwtek0y34v",
          "fls_title": "External Functions",
          "category": 0,
          "score": 0.59,
          "reason": "FLS defines external functions which are the interface point for external data. Per FLS: 'An external function shall be invoked from an unsafe context' - requiring explicit unsafe blocks acknowledges the trust boundary."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "fls_title": "Unsafety",
          "category": 0,
          "score": 0.53,
          "reason": "FLS Chapter 19 defines unsafe contexts. External data handling typically requires unsafe code in Rust, making the boundary explicit and requiring programmer attestation of safety invariants."
        },
        {
          "fls_id": "fls_dzq9cdz4ibsz",
          "fls_title": "Exceptions and Errors",
          "category": 0,
          "score": 0.5,
          "reason": "Rust's Result/Option types provide mechanisms for representing validation outcomes. External data can be validated and wrapped in Result<T,E> to propagate validation failures."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "Rust addresses external data validation through: (1) FFI boundaries require unsafe, making external interfaces explicit, (2) Type system enforces that raw external data must be converted to Rust types, providing natural validation points, (3) Result/Option types encode validation success/failure. While Rust doesn't automatically validate external data, it makes the boundaries explicit and provides idioms (FromStr, TryFrom, etc.) for safe parsing with error handling.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Dir 4.15",
      "guideline_title": "Evaluation of floating-point expressions shall not lead to the undetected generation of infinities and NaNs C90",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_b4xporvr64s",
          "fls_title": "Floating Point Types",
          "category": 0,
          "score": 0.54,
          "reason": "FLS defines f32/f64 as IEEE 754-2008 binary32/binary64 types. Per FLS: 'Type f32 is equivalent to the IEEE 754-2008 binary32 type.' This establishes the foundation for NaN/infinity semantics."
        },
        {
          "fls_id": "fls_nuFAwLHOdQBx",
          "fls_title": "Floating Point Types",
          "category": 0,
          "score": 0.64,
          "reason": "FLS documents NaN behavior explicitly: 'Operations on values of floating point types may not preserve the sign bit in case of the value being a IEEE floating-point NaN.' Directly addresses MISRA's concern about NaN handling."
        },
        {
          "fls_id": "fls_JP8YSbxSN0Ym",
          "fls_title": "Literal Patterns",
          "category": -2,
          "score": 0.55,
          "reason": "FLS prohibits NaN in pattern matching: 'A numeric literal pattern's numeric literal value shall not be a IEEE floating-point NaN.' This forces explicit handling of NaN values."
        },
        {
          "fls_id": "fls_cx86k8yfjhht",
          "fls_title": "Type Cast Expressions",
          "category": -3,
          "score": 0.5,
          "reason": "FLS documents infinity generation: 'Produces f32::INFINITY or f64::INFINITY of the same sign as the value of the operand when the value of the operand causes arithmetic overflow.'"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "misra_rust_comment": "Rust implements IEEE-754",
      "confidence": "high",
      "notes": "Rust follows IEEE-754/IEC 60559 for floating-point types. The standard library provides is_nan(), is_infinite(), is_finite() methods on f32/f64 for detection. FLS explicitly documents NaN and infinity behavior. Projects should use these methods or checked arithmetic for detection.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Dir 5.1",
      "guideline_title": "There shall be no data races between threads C11 [Undefined 5]",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "accepted_matches": [
        {
          "fls_id": "fls_3v733mnewssy",
          "category": 0,
          "fls_section": "17.1",
          "fls_title": "Concurrency",
          "score": 0.734,
          "reason": "Parent section defining Rust's concurrency model, which is designed to prevent data races."
        },
        {
          "fls_id": "fls_tx4b8r6i93n4",
          "category": -2,
          "fls_section": "17.1",
          "fls_title": "Concurrency",
          "score": 0.684,
          "reason": "Per FLS: 'A data race is a scenario where two or more threads access a shared memory location concurrently without any synchronization...' This matches MISRA's definition."
        },
        {
          "fls_id": "fls_isypweqewe78",
          "category": -4,
          "fls_section": "17.1",
          "fls_title": "Concurrency",
          "score": 0.675,
          "reason": "Per FLS: 'It is undefined behavior if two or more threads engage in a data race.' Rust explicitly classifies data races as UB."
        },
        {
          "fls_id": "fls_eiw4by8z75di",
          "category": 0,
          "fls_section": "17.2",
          "fls_title": "Send and Sync",
          "score": 0.541,
          "reason": "Section describing Rust's compile-time mechanism for preventing data races via Send and Sync traits."
        },
        {
          "fls_id": "fls_n5l17mlglq11",
          "category": -2,
          "fls_section": "17.2",
          "fls_title": "Send and Sync",
          "score": null,
          "reason": "Per FLS: 'The Rust programming language provides the core::marker::Send and core::marker::Sync traits for preventing data races at the type level.' This is Rust's primary compile-time data race prevention mechanism."
        },
        {
          "fls_id": "fls_zgemofbs5q2x",
          "category": -2,
          "fls_section": "17.2",
          "fls_title": "Send and Sync",
          "score": null,
          "reason": "Per FLS: 'A sync type shall have values that are allowed to be shared across multiple threads at any given time without incurring data races.'"
        },
        {
          "fls_id": "fls_vyc9vcuamlph",
          "category": 0,
          "fls_section": "17.3",
          "fls_title": "Atomics",
          "score": 0.566,
          "reason": "Rust's atomic types provide safe concurrent access, addressing MISRA's recommendation for atomic synchronization."
        }
      ],
      "rejected_matches": [
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_section": "19.1",
          "score": 0.562,
          "reason": "General unsafety section. While unsafe code can cause data races, this section is not specifically about data race prevention."
        },
        {
          "fls_id": "fls_xdvdl2ssnhlo",
          "category": 0,
          "fls_section": "7.3",
          "score": 0.501,
          "reason": "About static storage duration, not data race prevention mechanisms."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "confidence": "high",
      "notes": "Rust provides strong data race prevention via the Send/Sync trait system, but per MISRA ADD-6: 'not all safe Rust types are race-free'. Safe Rust prevents memory-level data races but logical races (e.g., with atomics) are still possible. In unsafe Rust, the programmer must manually ensure data race freedom."
    },
    {
      "guideline_id": "Dir 5.2",
      "guideline_title": "There shall be no deadlocks between threads",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_3v733mnewssy",
          "fls_title": "Concurrency",
          "category": 0,
          "score": 0.55,
          "reason": "FLS Chapter 17 establishes Rust's concurrency model. Per FLS: 'The Rust programming language provides features for concurrent programming without data races.' Rust prevents data races at compile time, which addresses one class of concurrency bugs."
        },
        {
          "fls_id": "fls_eiw4by8z75di",
          "fls_title": "Send and Sync",
          "category": 0,
          "score": 0.55,
          "reason": "FLS defines Send and Sync traits: 'The Rust programming language provides the core::marker::Send and core::marker::Sync traits for preventing data races at the type level.' These provide compile-time guarantees about thread safety."
        },
        {
          "fls_id": "fls_zgemofbs5q2x",
          "fls_title": "Send and Sync",
          "category": -2,
          "score": 0.63,
          "reason": "Per FLS: 'A sync type shall have values that are allowed to be shared across multiple threads at any given time without incurring data races.' This establishes thread-sharing invariants."
        },
        {
          "fls_id": "fls_vyc9vcuamlph",
          "fls_title": "Atomics",
          "category": 0,
          "score": 0.45,
          "reason": "FLS defines atomic types for 'primitive shared-memory communication between threads.' Atomics are building blocks for synchronization primitives."
        }
      ],
      "fls_rationale_type": "partial_mapping",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "Rust's type system prevents data races at compile time through Send/Sync traits, but does NOT prevent deadlocks. Deadlock prevention requires runtime mechanisms (lock ordering, try_lock, timeouts) or design patterns. The FLS addresses data races but deadlocks remain a programmer responsibility. This is a partial mapping - Rust helps with concurrency safety but does not fully address MISRA's deadlock concern.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Dir 5.3",
      "guideline_title": "There shall be no dynamic thread creation C11",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_3v733mnewssy",
          "fls_title": "Concurrency",
          "category": 0,
          "score": 0.56,
          "reason": "FLS Concurrency chapter defines data races and thread safety at the language level"
        },
        {
          "fls_id": "fls_eiw4by8z75di",
          "fls_title": "Send and Sync",
          "category": 0,
          "score": 0.51,
          "reason": "FLS Send and Sync traits provide compile-time thread safety guarantees, preventing data races"
        },
        {
          "fls_id": "fls_9xnaxd7qbakp",
          "fls_title": "Attribute no_std",
          "category": 0,
          "score": 0.4,
          "reason": "FLS no_std enables bare-metal development without std library thread spawning capabilities"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "MISRA concern is about unpredictable thread creation overhead and analyzability. Thread creation in Rust is a library feature (std::thread::spawn), not a language primitive. The FLS defines: (1) Send/Sync traits for compile-time thread safety, (2) data race UB definition. With #[no_std], thread spawning is not available by default. Static thread pools would be implemented via library constructs, not language features. The FLS provides safety infrastructure but thread creation policy is a library/project concern.",
      "rejected_matches": [
        {
          "fls_id": "fls_k02nt1m5fq1z",
          "fls_title": "Panic",
          "category": -3,
          "score": 0.56,
          "reason": "Panic section mentions thread execution halting but is about panic handling, not thread creation"
        }
      ]
    },
    {
      "guideline_id": "Rule 1.1",
      "guideline_title": "The program shall contain no violations of the standard C syntax and constraints, and shall not exceed the implementation\u2019s translation limits",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "accepted_matches": [
        {
          "fls_id": "fls_99b7xi1bkgih",
          "fls_title": "Conformity",
          "category": 0,
          "score": 0.59,
          "reason": "FLS section 1.3 defines tool conformity. Lists explicit requirements for conforming tools including translation of legal programs and error detection."
        },
        {
          "fls_id": "fls_dBKu9jgx3OyH",
          "fls_title": "Conformity",
          "category": -5,
          "score": 0.56,
          "reason": "FLS implementation requirement: 'Correctly translate legal programs written in Rust.' Establishes baseline for correct compilation."
        },
        {
          "fls_id": "fls_GZmxrO61eiJ1",
          "fls_title": "Conformity",
          "category": -5,
          "score": 0.56,
          "reason": "FLS implementation requirement: 'Reject programs that contain errors whose detection is required by this document.' Rust compilers must reject syntactically invalid programs."
        },
        {
          "fls_id": "fls_lkdm0mdghppv",
          "fls_title": "Conformity",
          "category": -5,
          "score": 0.58,
          "reason": "FLS: 'A tool that conforms to this document shall support each capability required by the language as specified.' Establishes comprehensive conformity requirement."
        },
        {
          "fls_id": "fls_10yukmkhl0ng",
          "fls_title": "Extent",
          "category": 0,
          "score": 0.52,
          "reason": "FLS Extent section specifies 'The violations that a conforming tool is required to detect.' Defines scope of required error detection."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "Rust has a formal specification (FLS) that defines syntax and semantics. The rustc compiler strictly enforces the language grammar - any syntax errors or constraint violations result in compilation failure. Unlike C where some violations may go undetected, Rust's strong type system catches most issues at compile time.",
      "rejected_matches": [
        {
          "fls_id": "fls_dv1qish8svc",
          "fls_title": "Scope",
          "category": -1,
          "score": 0.59,
          "reason": "About FLS document scope and contribution process, not about language conformity requirements."
        }
      ]
    },
    {
      "guideline_id": "Rule 1.3",
      "guideline_title": "There shall be no occurrence of undefined or critical unspecified behaviour",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_jep7p27kaqlp",
          "fls_title": "Unsafety",
          "category": 0,
          "score": 0.65,
          "reason": "FLS Chapter 19 defines unsafety. Per FLS: 'Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.' Rust isolates UB-capable operations."
        },
        {
          "fls_id": "fls_ovn9czwnwxue",
          "fls_title": "Unsafety",
          "category": -2,
          "score": 0.63,
          "reason": "FLS defines unsafe operations: 'An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error.' Explicit enumeration of UB sources."
        },
        {
          "fls_id": "fls_ybnpe7ppq1vh",
          "fls_title": "Unsafety",
          "category": -2,
          "score": 0.6,
          "reason": "FLS legality rule: 'An unsafe operation shall be used only within an unsafe context.' Compiler enforces that UB-capable operations require explicit unsafe blocks."
        },
        {
          "fls_id": "fls_9wgldua1u8yt",
          "fls_title": "Dereference Expression",
          "category": -4,
          "score": 0.65,
          "reason": "FLS documents specific UB: 'It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.' UB scenarios are explicitly documented."
        },
        {
          "fls_id": "fls_70qjvaqoz007",
          "fls_title": "Structure",
          "category": -4,
          "score": 0.59,
          "reason": "FLS defines undefined behavior category as 'Situations that result in unbounded errors.' All UB is explicitly documented in FLS."
        }
      ],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "Rust's core design goal is memory safety without garbage collection. Safe Rust (code without 'unsafe' keyword) cannot exhibit undefined behavior - the compiler statically prevents it through the type system and borrow checker. UB is only possible in unsafe blocks, which must be explicitly marked. This is stronger than MISRA's requirement - Rust prevents UB by construction in safe code.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 1.4",
      "guideline_title": "Emergent language features shall not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "misra_rust_comment": "this is specific to C versioning",
      "confidence": "high",
      "notes": "Per ADD-6: 'this is specific to C versioning'. Rust editions (2015, 2018, 2021) provide a different, more structured approach to language evolution.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 1.5",
      "guideline_title": "Obsolescent language features shall not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_9cd746qe40ag",
          "fls_title": "Versioning",
          "category": 0,
          "score": 0.566,
          "reason": "Rust editions provide a mechanism for evolving the language while maintaining backward compatibility. Obsolescent features are migrated across editions with tooling support."
        },
        {
          "fls_id": "fls_s5z2q5pl14p4",
          "fls_title": "Built-in Attributes - deprecated",
          "category": -2,
          "score": 0.535,
          "reason": "The #[deprecated] attribute marks items as obsolescent, generating compiler warnings when used. This directly addresses MISRA's concern about obsolescent features."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "this applies to deprecated APIs",
      "confidence": "high",
      "notes": "Rust handles obsolescent features through editions and the deprecated attribute. MISRA ADD-6 notes this applies to deprecated APIs in Rust.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 2.1",
      "guideline_title": "A project shall not contain unreachable code",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "misra_rust_category": "advisory",
      "confidence": "high",
      "notes": "MISRA concern is about unreachable code indicating logic errors or wasted resources. Rust provides: (1) Language-level reachability via diverging expressions and never type (!), (2) Compiler lint unreachable_code that warns about code after diverging expressions, (3) Diagnostics attributes (#[allow], #[deny], #[warn], #[forbid]) for lint control. The FLS defines the language semantics of reachability; lint enforcement is a tooling concern controlled via diagnostics attributes.",
      "accepted_matches": [
        {
          "fls_id": "fls_zJOAmSr3Dbqk",
          "fls_title": "Diverging Expressions",
          "category": 0,
          "score": 0.62,
          "reason": "FLS defines diverging expressions (break, return, loop, panic, never type) which determine reachability at the language level"
        },
        {
          "fls_id": "fls_t2590yyvclgb",
          "fls_title": "Diagnostics Attributes",
          "category": 0,
          "score": 0.4,
          "reason": "FLS defines diagnostics attributes (allow, deny, warn, forbid) for controlling lint warnings including unreachable_code"
        },
        {
          "fls_id": "fls_jr4tpuyksr75",
          "fls_title": "Break Expressions",
          "category": 0,
          "score": 0.55,
          "reason": "FLS break expressions cause control flow to diverge, making subsequent code unreachable"
        },
        {
          "fls_id": "fls_sf4qnd43z2wc",
          "fls_title": "Infinite Loops",
          "category": 0,
          "score": 0.58,
          "reason": "FLS infinite loops without break have never type, indicating code after them is unreachable"
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "direct_mapping"
    },
    {
      "guideline_id": "Rule 2.2",
      "guideline_title": "A project shall not contain dead code",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "MISRA concern is about dead code (executes but has no effect) indicating logic errors. Rust provides: (1) Compiler lint dead_code that warns about unused functions, structs, etc., (2) unused_variables, unused_assignments lints for unused bindings, (3) Diagnostics attributes for lint control. The FLS defines language semantics; dead code detection is a tooling concern controlled via diagnostics attributes. Rust's ownership system also helps identify dead code through unused value warnings.",
      "accepted_matches": [
        {
          "fls_id": "fls_t2590yyvclgb",
          "fls_title": "Diagnostics Attributes",
          "category": 0,
          "score": 0.4,
          "reason": "FLS defines diagnostics attributes (allow, deny, warn, forbid) for controlling lint warnings including dead_code"
        },
        {
          "fls_id": "fls_3xvm61x0t251",
          "fls_title": "Initialization",
          "category": 0,
          "score": 0.55,
          "reason": "FLS Initialization section defines when values are initialized and used, foundational for dead code analysis"
        },
        {
          "fls_id": "fls_zJOAmSr3Dbqk",
          "fls_title": "Diverging Expressions",
          "category": 0,
          "score": 0.5,
          "reason": "FLS diverging expressions affect code reachability and dead code detection"
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "direct_mapping"
    },
    {
      "guideline_id": "Rule 2.3",
      "guideline_title": "A project should not contain unused type declarations",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_c5n4gzgs79vv",
          "fls_title": "Built-in Attributes - allow",
          "category": -2,
          "score": 0.533,
          "reason": "FLS defines the #[allow] attribute for controlling lint behavior. Combined with rustc's dead_code lint, unused types can be detected or suppressed."
        },
        {
          "fls_id": "fls_29y8icoou1gx",
          "fls_title": "Built-in Attributes - warn",
          "category": -2,
          "score": 0.544,
          "reason": "FLS defines #[warn] attribute. Rustc warns on dead_code by default, catching unused type declarations."
        },
        {
          "fls_id": "fls_jdknpu3kf865",
          "fls_title": "Visibility",
          "category": 0,
          "score": 0.544,
          "reason": "FLS defines visibility rules for items. Private items not used within their module scope are candidates for dead_code detection."
        }
      ],
      "fls_rationale_type": "partial_mapping",
      "misra_rust_category": "recommended",
      "confidence": "high",
      "notes": "FLS provides the lint mechanism but specific lints like dead_code are compiler implementation. Rustc's dead_code lint is enabled by default and warns on unused type declarations, addressing MISRA's concern through tooling rather than language specification.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 2.4",
      "guideline_title": "A project should not contain unused tag declarations",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "n_a",
      "misra_rust_comment": "no separate tag name space in Rust",
      "confidence": "high",
      "notes": "Per ADD-6: 'no separate tag name space in Rust'. Rust has no struct/enum/union tag namespace - type names are directly in the type namespace.",
      "accepted_matches": [],
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 2.5",
      "guideline_title": "A project should not contain unused macro definitions",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_qxjy0f758x5s",
          "fls_title": "Attribute macro_use",
          "category": 0,
          "score": 0.599,
          "reason": "FLS defines macro_use for importing macros. Unused macro detection relies on tooling analyzing which macros are actually invoked."
        },
        {
          "fls_id": "fls_e0a96eb6ux3y",
          "fls_title": "Attribute macro_export",
          "category": 0,
          "score": 0.487,
          "reason": "FLS defines macro_export for public macro visibility. Exported but unused macros may indicate dead code."
        },
        {
          "fls_id": "fls_c5n4gzgs79vv",
          "fls_title": "Built-in Attributes - allow",
          "category": -2,
          "score": 0.533,
          "reason": "FLS lint mechanism allows controlling unused_macros warnings via #[allow(unused_macros)]."
        }
      ],
      "fls_rationale_type": "partial_mapping",
      "misra_rust_category": "recommended",
      "confidence": "high",
      "notes": "FLS defines macro visibility and scoping, but unused macro detection is a compiler lint (unused_macros). Rustc warns on unused macros by default. The concern maps to Rust through tooling rather than language specification.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 2.6",
      "guideline_title": "A function should not contain unused label declarations",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_769b4p8v3cwu",
          "fls_title": "Label Scope",
          "category": 0,
          "score": 0.69,
          "reason": "FLS Label Scope defines that labels are in scope within the block expression of the related loop expression"
        },
        {
          "fls_id": "fls_uusi0zej55is",
          "fls_title": "Loop Labels",
          "category": 0,
          "score": 0.59,
          "reason": "FLS Loop Labels define named loops for break/continue targeting, not goto labels"
        },
        {
          "fls_id": "fls_7hc8yboeaho0",
          "fls_title": "Loop Labels legality",
          "category": -2,
          "score": 0.54,
          "reason": "FLS requires label indication to refer to an enclosing named block or loop expression"
        },
        {
          "fls_id": "fls_t2590yyvclgb",
          "fls_title": "Diagnostics Attributes",
          "category": 0,
          "score": 0.4,
          "reason": "FLS diagnostics attributes control lint warnings including unused_labels"
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "recommended",
      "confidence": "high",
      "notes": "MISRA concern is about C goto labels being declared but not used. Rust has NO goto statement. Rust labels are for naming loops/blocks to target with break/continue. The FLS defines: (1) Label Scope - labels are scoped to their loop/block, (2) Loop Labels - syntax and semantics for named loops. The compiler provides unused_labels lint for detecting labels not referenced by break/continue. This is a significant Rust alternative - structured loop control instead of arbitrary goto.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 2.7",
      "guideline_title": "A function should not contain unused parameters",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_qcb1n9c0e5hz",
          "fls_title": "Functions",
          "category": 0,
          "score": 0.44,
          "reason": "FLS Functions section defines function parameters and their binding semantics"
        },
        {
          "fls_id": "fls_uwuthzfgslif",
          "fls_title": "Function parameter binding",
          "category": -2,
          "score": 0.63,
          "reason": "FLS defines function parameters as constructs that yield bindings for matched input values"
        },
        {
          "fls_id": "fls_qfsfnql1t7m",
          "fls_title": "Underscore Patterns",
          "category": 0,
          "score": 0.6,
          "reason": "FLS underscore pattern matches any value without binding, providing mechanism for intentionally unused parameters"
        },
        {
          "fls_id": "fls_t2590yyvclgb",
          "fls_title": "Diagnostics Attributes",
          "category": 0,
          "score": 0.4,
          "reason": "FLS diagnostics attributes control lint warnings including unused_variables"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "recommended",
      "confidence": "high",
      "notes": "MISRA concern is about unused function parameters indicating spec/implementation mismatch. Rust provides: (1) Compiler lint unused_variables warns about unused parameters, (2) Underscore prefix (_param) or underscore pattern (_) explicitly marks intentionally unused parameters, (3) Trait implementations may require unused parameters for API conformance. The FLS defines function parameters and underscore patterns; lint enforcement is tooling.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 2.8",
      "guideline_title": "A project should not contain unused object definitions",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "misra_rust_category": "recommended",
      "confidence": "high",
      "notes": "MISRA concern is about unused object definitions indicating redundant code. Rust provides: (1) Compiler lint dead_code warns about unused structs, enums, functions, constants, (2) #[used] attribute explicitly marks items that should not be optimized away, (3) Visibility modifiers (pub) indicate intended external usage. The FLS defines items and their declaration; unused item detection is tooling.",
      "accepted_matches": [
        {
          "fls_id": "fls_151r19d7xbgz",
          "fls_title": "Entities",
          "category": 0,
          "score": 0.46,
          "reason": "FLS Entities section defines items (structs, enums, functions, etc.) that can be unused"
        },
        {
          "fls_id": "fls_7skf24auayqy",
          "fls_title": "Attribute used",
          "category": 0,
          "score": 0.44,
          "reason": "FLS #[used] attribute prevents the linker from removing a static, indicating intentional retention"
        },
        {
          "fls_id": "fls_t2590yyvclgb",
          "fls_title": "Diagnostics Attributes",
          "category": 0,
          "score": 0.4,
          "reason": "FLS diagnostics attributes control lint warnings including dead_code for unused items"
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "direct_mapping"
    },
    {
      "guideline_id": "Rule 3.1",
      "guideline_title": "The character sequences /* and // shall not be used within a comment",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_q8l2jza7d9xa",
          "fls_title": "Comments",
          "category": 0,
          "score": 0.6,
          "reason": "Per FLS syntax, BlockComment includes BlockCommentOrDoc recursively, allowing properly nested block comments. Rust's grammar explicitly supports /* within /* */ comments through nested BlockCommentOrDoc, unlike C. This addresses MISRA's concern about missing comment terminators."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "advisory",
      "misra_rust_comment": "nested comments are fully supported",
      "confidence": "high",
      "notes": "Rust supports nested block comments by design, addressing MISRA's concern about /* within comments indicating missing */. The note that 'nested comments are fully supported' in MISRA ADD-6 confirms this.",
      "rejected_matches": [
        {
          "fls_id": "fls_6fxcs17n4kw",
          "fls_title": "Comments",
          "category": -2,
          "score": 0.63,
          "reason": "About carriage return in comments, not nested comment sequences"
        }
      ]
    },
    {
      "guideline_id": "Rule 3.2",
      "guideline_title": "Line-splicing shall not be used in // comments",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust does not support line-splicing with backslash. Line continuation in strings uses string concatenation or raw strings. No equivalent concern.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 4.1",
      "guideline_title": "Octal and hexadecimal escape sequences shall be terminated C90",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust escape sequences are well-defined and don't have C's ambiguous octal parsing. Unicode escapes (\\u{...}) are delimited. No termination ambiguity.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 4.2",
      "guideline_title": "Trigraphs should not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no trigraphs. Raw string literals (r#\"...\"#) provide the functionality trigraphs were designed for in restricted character sets.",
      "accepted_matches": [],
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 5.1",
      "guideline_title": "External identifiers shall be distinct C90 [Undefined 7], C99 [Unspecified 7; Undefined 28], C11 [Unspecified 8; Undefined 31]",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_21vnag69kbwe",
          "category": 0,
          "fls_section": "2.2",
          "fls_title": "Identifiers",
          "score": 0.675,
          "reason": "Parent section defining Rust's identifier rules."
        },
        {
          "fls_id": "fls_j9yh8j8jgdeu",
          "category": -2,
          "fls_section": "2.2",
          "fls_title": "Identifiers",
          "score": 0.651,
          "reason": "Per FLS: 'Two identifiers are considered the same if they consist of the same sequence of characters after performing normalization.' Rust considers the full identifier sequence, not a truncated prefix as C may."
        },
        {
          "fls_id": "fls_vde7gev5rz4q",
          "category": -2,
          "fls_section": "2.2",
          "fls_title": "Identifiers",
          "score": 0.579,
          "reason": "Per FLS: 'Identifiers are normalized using Normalization Form C...' Unicode normalization ensures consistent identifier comparison."
        },
        {
          "fls_id": "fls_op0lp1i065di",
          "category": -2,
          "fls_section": "2.2",
          "fls_title": "Identifiers",
          "score": null,
          "reason": "Per FLS: 'Names of items within external blocks' shall be ASCII. This restricts external/FFI identifiers."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_section": "21.1",
          "fls_title": "External Blocks",
          "score": 0.496,
          "reason": "FFI context where C ABI applies. Per MISRA ADD-6: identifier distinctness matters in extern \"C\" contexts where the C linker may truncate."
        }
      ],
      "rejected_matches": [
        {
          "fls_id": "fls_p090c5oTnElW",
          "category": 0,
          "fls_section": "2.7",
          "score": 0.534,
          "reason": "About C string literals, not identifier distinctness."
        },
        {
          "fls_id": "fls_e0896uk0mdyl",
          "category": 0,
          "fls_section": "22.5",
          "score": 0.516,
          "reason": "About assembly instructions, not identifiers."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "confidence": "high",
      "notes": "Per MISRA ADD-6: 'no character limit, except in extern \"C\"'. In pure Rust, identifiers are always fully distinct with no truncation. In extern \"C\" contexts, the C linker's rules apply, which may have character limits. Safe Rust has no extern \"C\" items, hence not_applicable for safe Rust."
    },
    {
      "guideline_id": "Rule 5.2",
      "guideline_title": "Identifiers declared in the same scope and name space shall be distinct C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_21vnag69kbwe",
          "fls_title": "Identifiers",
          "category": 0,
          "score": 0.62,
          "reason": "Per FLS, Rust has no limit on significant identifier characters. fls_j9yh8j8jgdeu states: 'Two identifiers are considered the same if they consist of the same sequence of characters after performing normalization.' All characters are significant."
        },
        {
          "fls_id": "fls_j9yh8j8jgdeu",
          "fls_title": "Identifiers",
          "category": -2,
          "score": 0.66,
          "reason": "FLS enforces identifier comparison after Unicode NFC normalization. Unlike C which truncates identifiers, Rust treats all characters as significant."
        }
      ],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "required",
      "misra_rust_comment": "no character limit, but has name spaces",
      "confidence": "high",
      "notes": "MISRA's concern about identifier length limits causing undefined behavior does not apply to Rust. Rust enforces full identifier comparison with Unicode normalization. The compiler will reject duplicate definitions in the same scope as a static error.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 5.3",
      "guideline_title": "An identifier declared in an inner scope shall not hide an identifier declared in an outer scope",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_ydmnb7qnmzzq",
          "fls_title": "Shadowing",
          "category": 0,
          "score": 0.59,
          "reason": "Per FLS fls_ob0riinmitkl: 'Shadowing is a property of names. A name is said to be shadowed when another name with the same characters is introduced in the same scope within the same namespace, effectively hiding it.'"
        },
        {
          "fls_id": "fls_lnpyb285qdiy",
          "fls_title": "Scope Hierarchy",
          "category": 0,
          "score": 0.6,
          "reason": "FLS defines explicit scope hierarchy with binding scopes and generic parameter scopes. Inner scope declarations can shadow outer scope names only for variables, macros, and prelude names."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "advisory",
      "misra_rust_comment": "this also applies to macro names",
      "confidence": "high",
      "notes": "Rust explicitly defines and restricts shadowing. Per FLS: 'No name shall be shadowed except for Prelude names, macro names within textual macro scope, and variable names.' This makes shadowing intentional and controlled. Clippy lint 'shadow_unrelated' can detect unintentional shadowing.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 5.4",
      "guideline_title": "Macro identifiers shall be distinct C90",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Per ADD-6: C-specific macro identifier rules. Rust's procedural macros are proper functions. Declarative macros (macro_rules!) have hygiene and clear scoping.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 5.5",
      "guideline_title": "Identifiers shall be distinct from macro names C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "accepted_matches": [
        {
          "fls_id": "fls_dq403wq5yrs",
          "fls_title": "Namespaces",
          "category": 0,
          "score": 0.55,
          "reason": "FLS defines separate namespaces - macros are in a distinct 'macro namespace' from other identifiers. This prevents the naming collision that MISRA C is concerned about."
        },
        {
          "fls_id": "fls_crwfafrmydr7",
          "fls_title": "Namespaces - macro namespace",
          "category": -2,
          "score": 0.608,
          "reason": "Per FLS: 'A macro namespace contains the names of...Declarative macros, Function-like macros.' Macros cannot shadow variables/functions."
        },
        {
          "fls_id": "fls_xlfo7di0gsqz",
          "fls_title": "Hygiene",
          "category": 0,
          "score": 0.513,
          "reason": "FLS defines hygiene as 'a property of macros and identifiers...which aims to eliminate the syntactic interference between a macro and its environment.'"
        }
      ],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "advisory",
      "misra_rust_comment": "macros and functions use different syntax",
      "confidence": "high",
      "notes": "Rust's namespace separation and hygiene system directly address MISRA's concern. Macros are invoked with different syntax (name! vs name) and occupy a separate namespace. MISRA ADD-6 marks safe Rust as Partial because the concern is largely prevented by language design.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 5.6",
      "guideline_title": "A typedef name shall be a unique identifier",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_kgvleup5mdhq",
          "fls_title": "Type Aliases",
          "category": 0,
          "score": 0.732,
          "reason": "FLS defines type aliases as items. Unlike C typedefs, Rust type aliases are proper items subject to module scoping and namespace rules."
        },
        {
          "fls_id": "fls_ydmnb7qnmzzq",
          "fls_title": "Shadowing",
          "category": 0,
          "score": 0.637,
          "reason": "FLS states: 'No name shall be shadowed except for Prelude names, macro names within textual macro scope, and variable names.' Type aliases cannot shadow or be shadowed arbitrarily."
        },
        {
          "fls_id": "fls_dq403wq5yrs",
          "fls_title": "Namespaces",
          "category": 0,
          "score": 0.55,
          "reason": "Rust segregates names into five namespaces. Type aliases are in the type namespace, preventing conflicts with value-namespace identifiers."
        }
      ],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust's namespace system and shadowing rules prevent the C typedef uniqueness issue. MISRA ADD-6 marks this as n_a because Rust's module and namespace system provides stronger guarantees than C's flat namespace.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 5.7",
      "guideline_title": "A tag name shall be a unique identifier",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "misra_rust_comment": "no separate tag name space in Rust",
      "confidence": "high",
      "notes": "Per ADD-6: 'no separate tag name space in Rust'. Rust types are in a single type namespace. struct Foo and enum Foo would conflict - no tag vs type distinction.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 5.8",
      "guideline_title": "Identifiers that define objects or functions with external linkage shall be unique",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_mvd7nz8k3wcy",
          "fls_title": "Attribute no_mangle",
          "category": 0,
          "score": 0.529,
          "reason": "FLS defines #[no_mangle] which exposes a symbol with its Rust identifier name. When used, the programmer must ensure symbol uniqueness."
        },
        {
          "fls_id": "fls_olzilmy8n0nl",
          "fls_title": "Attribute export_name",
          "category": 0,
          "score": 0.496,
          "reason": "FLS defines #[export_name] to specify custom symbol names. Per FLS: 'Attribute export_name shall specify the exported symbol.'"
        },
        {
          "fls_id": "fls_p44fky7fifc",
          "fls_title": "Attribute link_name",
          "category": 0,
          "score": 0.646,
          "reason": "FLS defines #[link_name] for imported external functions. Per FLS: 'Attribute link_name shall specify the linking symbol.'"
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "fls_title": "External Blocks",
          "category": 0,
          "score": 0.61,
          "reason": "FLS defines external blocks for FFI. External functions and statics have C-level linkage, requiring unique symbol names."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "recommended",
      "confidence": "high",
      "notes": "Rust normally mangles symbols ensuring uniqueness. MISRA's concern applies when #[no_mangle] or #[export_name] is used for FFI. FLS defines these mechanisms; uniqueness enforcement is programmer/linker responsibility.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 5.9",
      "guideline_title": "Identifiers that define objects or functions with internal linkage should be unique",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_dq403wq5yrs",
          "category": 0,
          "fls_section": "14.3",
          "fls_title": "Namespaces",
          "score": 0.555,
          "reason": "Per FLS fls_1d4jm61qnt4l: 'A namespace is a logical grouping of names such that the occurrence of a name in one namespace does not conflict with an occurrence of the same name in another namespace.' Rust's 5 namespaces (label, lifetime, macro, type, value) prevent the identifier confusion that MISRA aims to avoid."
        },
        {
          "fls_id": "fls_21vnag69kbwe",
          "category": 0,
          "fls_section": "2.3",
          "fls_title": "Identifiers",
          "score": 0.674,
          "reason": "Per FLS fls_j9yh8j8jgdeu: 'Two identifiers are considered the same if they consist of the same sequence of characters after performing normalization.' Defines identifier equality/uniqueness."
        },
        {
          "fls_id": "fls_151r19d7xbgz",
          "category": 0,
          "fls_section": "14.1",
          "fls_title": "Entities",
          "score": 0.588,
          "reason": "Defines how entities (functions, objects, types) are named and resolved within Rust's module system, which provides isolation analogous to C's internal linkage."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA aims to prevent confusion from duplicate internal-linkage identifiers. Rust's module system and namespace segregation (FLS 14.3) structurally prevents this issue. Private items are module-scoped, not file-scoped like C's 'static', and the 5-namespace model ensures names in different categories never conflict.",
      "rejected_matches": [
        {
          "fls_id": "fls_p44fky7fifc",
          "category": 0,
          "fls_section": "13.19",
          "fls_title": "Attribute link_name",
          "score": 0.629,
          "reason": "About renaming symbols for FFI linking, not about identifier uniqueness."
        },
        {
          "fls_id": "fls_7bxv8lybxm18",
          "category": 0,
          "fls_section": "5.3",
          "fls_title": "Identifier Patterns",
          "score": 0.548,
          "reason": "Pattern matching syntax, not about identifier uniqueness or naming conflicts."
        }
      ]
    },
    {
      "guideline_id": "Rule 5.10",
      "guideline_title": "A reserved identifier or reserved macro name shall not be declared C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "accepted_matches": [
        {
          "fls_id": "fls_cbsgp6k0qa82",
          "fls_title": "Reserved Keywords",
          "category": 0,
          "score": 0.63,
          "reason": "FLS defines reserved keywords that cannot be used as identifiers (except via raw identifier syntax r#). This prevents accidental use of future language features."
        },
        {
          "fls_id": "fls_21vnag69kbwe",
          "fls_title": "Identifiers",
          "category": 0,
          "score": 0.619,
          "reason": "FLS defines identifier syntax including raw identifiers (r#keyword). Unlike C, Rust has no underscore-prefix reserved namespace convention."
        },
        {
          "fls_id": "fls_ld0ize96cm6m",
          "fls_title": "Preludes",
          "category": 0,
          "score": 0.55,
          "reason": "FLS defines preludes (core, std, extern). Prelude names are not reserved - they can be shadowed with defined precedence rules."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "advisory",
      "misra_rust_comment": "only possible in some cases. Previously Rule 21.2",
      "confidence": "high",
      "notes": "Rust handles reserved identifiers differently than C. Keywords are strictly reserved, but there is no underscore-prefix convention. MISRA ADD-6 notes this applies partially - mainly in macro contexts or FFI where C naming conventions may leak through.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 6.1",
      "guideline_title": "Bit-fields shall only be declared with an appropriate type C90",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "misra_rust_comment": "only provided as a library feature",
      "confidence": "high",
      "notes": "Per ADD-6: 'only provided as a library feature'. Rust has no native bit-field syntax. Use bitflags crate or manual bit manipulation with explicit types.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 6.2",
      "guideline_title": "Single-bit named bit-fields shall not be of a signed type",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no native bit-fields. Bit manipulation is done with explicit integer types. signedness is always explicit (i32 vs u32).",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 6.3",
      "guideline_title": "A bit-field shall not be declared as a member of a union C90",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no native bit-fields. Unions in Rust are for FFI compatibility and don't have bit-field members.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 7.1",
      "guideline_title": "Octal constants shall not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_2ed4axpsy9u0",
          "fls_title": "Integer Literals",
          "category": 0,
          "score": 0.631,
          "reason": "FLS defines integer literal syntax. Octal uses 0o prefix (OctalLiteral ::= 0o...), completely distinct from decimal literals."
        },
        {
          "fls_id": "fls_4v7awnutbpoe",
          "fls_title": "Integer Literals - octal",
          "category": -2,
          "score": 0.679,
          "reason": "Per FLS: 'An octal literal is an integer literal in base 8.' The 0o prefix eliminates C's ambiguous leading-zero syntax."
        }
      ],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "recommended",
      "misra_rust_comment": "Rust octals have a distinct prefix from decimals",
      "confidence": "high",
      "notes": "Rust prevents C's octal confusion by design. Octal requires explicit 0o prefix (0o777), not leading zero (0777 is invalid). MISRA ADD-6: 'Rust octals have a distinct prefix from decimals.'",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 7.2",
      "guideline_title": "A \u201cu\u201d or \u201cU\u201d suffix shall be applied to all integer constants that are represented in an unsigned type",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_f1e29aj0sqvl",
          "fls_title": "Integer Literals - suffix",
          "category": -2,
          "score": 0.537,
          "reason": "Per FLS: 'An integer suffix is a component of an integer literal that specifies an explicit integer type.'"
        },
        {
          "fls_id": "fls_xrv4q56lmoo3",
          "fls_title": "Integer Literals - u8",
          "category": -2,
          "score": 0.55,
          "reason": "FLS defines explicit unsigned suffixes: u8, u16, u32, u64, u128, usize. More specific than C's single U suffix."
        },
        {
          "fls_id": "fls_50qipwqi3arw",
          "fls_title": "Integer Literals - unsuffixed",
          "category": -2,
          "score": 0.5,
          "reason": "Per FLS: 'The type of an unsuffixed integer is determined by type inference.' Type inference ensures unsuffixed literals get a concrete type."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "recommended",
      "misra_rust_comment": "this is an error by default but can be enabled",
      "confidence": "high",
      "notes": "Rust has explicit type suffixes (u32, i64, etc.) more granular than C's U suffix. Type inference for unsuffixed literals is deterministic. Clippy lint default_numeric_fallback can enforce explicit suffixes.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 7.3",
      "guideline_title": "The lowercase character \u201cl\u201d shall not be used in a literal suffix",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust integer literal suffixes use full type names (i32, u64, etc.) not single letters. No 'l' suffix exists - uses i64 or u64 explicitly.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 7.4",
      "guideline_title": "A string literal shall not be assigned to an object unless the object\u2019s type is \u201cpointer to const-qualified char\u201d C90",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust string literals are &str (immutable by design). No implicit const-stripping. Mutable strings require String::from() or .to_string().",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 7.5",
      "guideline_title": "The argument of an integer constant macro shall have an appropriate form C99",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Per ADD-6: C-specific integer constant macro concern. Rust uses typed literals directly (123i32, 456u64) - no macros needed for type-specific constants.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 7.6",
      "guideline_title": "The small integer variants of the minimum-width integer constant macros shall not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Per ADD-6: C-specific macro concern. Rust uses explicit type suffixes on literals. No INT8_C or similar macros - just use 123i8 directly.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 8.1",
      "guideline_title": "Types shall be explicitly specified",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust requires explicit types in most contexts. Type inference exists but is local and explicit. Function signatures require types. No implicit int.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 8.2",
      "guideline_title": "Function types shall be in prototype form with named parameters C90",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust functions always have explicit parameter types and return types. No K&R style declarations. Parameters are always named in definitions.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 8.3",
      "guideline_title": "All declarations of an object or function shall use the same names and type qualifiers C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "fls_title": "External Functions",
          "category": 0,
          "score": 0.626,
          "reason": "Per FLS: 'An external function is an unchecked import of a foreign function.' Type compatibility with C is programmer's responsibility."
        },
        {
          "fls_id": "fls_v24ino4hix3m",
          "fls_title": "External Functions - unchecked",
          "category": -2,
          "score": 0.6,
          "reason": "FLS explicitly states external functions are 'unchecked imports' - the compiler cannot verify type compatibility with the actual C function."
        },
        {
          "fls_id": "fls_usgd0xlijoxv",
          "fls_title": "ABI",
          "category": 0,
          "score": 0.55,
          "reason": "FLS defines ABI specifications including extern C. Correct ABI is necessary but not sufficient for type compatibility."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "misra_rust_comment": "an extern declaration shall have a type compatible with the C declaration",
      "confidence": "high",
      "notes": "MISRA's concern directly applies to Rust FFI. FLS explicitly calls external functions 'unchecked' - type compatibility must be manually verified. This is why extern blocks are unsafe. Tools like bindgen can help generate correct declarations.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 8.4",
      "guideline_title": "A compatible declaration shall be visible when an object or function with external linkage is defined C90",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_section": "21.3",
          "score": 0.59,
          "reason": "External blocks declare FFI functions but Rust has no separate definition/declaration model requiring compatibility checks."
        },
        {
          "fls_id": "fls_p44fky7fifc",
          "category": 0,
          "fls_section": "13.x",
          "score": 0.525,
          "reason": "link_name is for symbol naming in FFI, not declaration/definition compatibility."
        },
        {
          "fls_id": "fls_mvd7nz8k3wcy",
          "category": 0,
          "fls_section": "13.x",
          "score": 0.511,
          "reason": "no_mangle is for symbol naming in FFI, not declaration/definition compatibility."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no separate declaration/definition model. Functions are defined in one place. For FFI (extern blocks), the extern declaration IS the declaration - there is no separate definition in Rust to check against. The C concept of \"compatible declaration\" checking between header and source file does not exist in Rust."
    },
    {
      "guideline_id": "Rule 8.5",
      "guideline_title": "An external object or function shall be declared once in one and only one file",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "fls_title": "External Blocks",
          "category": 0,
          "score": 0.643,
          "reason": "FLS defines external blocks for FFI declarations. Unlike C headers, Rust modules provide natural organization for external declarations."
        },
        {
          "fls_id": "fls_4dje9t5y2dia",
          "fls_title": "External Blocks - imports",
          "category": -2,
          "score": 0.711,
          "reason": "Per FLS: 'An external block is a construct that provides the declarations of external functions and external statics as unchecked imports.'"
        }
      ],
      "fls_rationale_type": "partial_mapping",
      "misra_rust_category": "advisory",
      "misra_rust_comment": "may affect extern \u201cC\u201d declarations",
      "confidence": "high",
      "notes": "Rust's module system naturally addresses this. External declarations are typically centralized in a single module (e.g., ffi.rs or sys.rs). Duplicate declarations are valid but poor practice. MISRA ADD-6 marks as advisory for extern C declarations.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 8.6",
      "guideline_title": "An identifier with external linkage shall have exactly one external definition C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_section": "21.1",
          "fls_title": "External Blocks",
          "score": 0.5,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of external functions and external statics as unchecked imports.' The 'unchecked' nature means Rust trusts the linker to enforce ODR for external symbols."
        },
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_section": "21.2",
          "fls_title": "External Functions",
          "score": 0.48,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per fls_rdu4723vp0oo: 'An external function shall not specify a FunctionBody.' These are declarations only - the single definition must exist in linked C code."
        },
        {
          "fls_id": "fls_s4yt19sptl7d",
          "category": 0,
          "fls_section": "21.3",
          "fls_title": "External Statics",
          "score": 0.48,
          "reason": "Per FLS fls_8ddsytjr4il6: 'An external static is an import of a foreign variable.' Per fls_tr7purzcldn0: 'An external static shall not specify a static initializer.' These are declarations only."
        },
        {
          "fls_id": "fls_mvd7nz8k3wcy",
          "category": 0,
          "fls_section": "13.24",
          "fls_title": "Attribute no_mangle",
          "score": 0.53,
          "reason": "The #[no_mangle] attribute exposes Rust symbols with external linkage, making ODR concerns relevant when Rust functions are called from C."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "misra_rust_comment": "may affect extern \u201cC\u201d declarations",
      "confidence": "high",
      "notes": "MISRA enforces C's ODR for external linkage. In Rust, extern blocks provide 'unchecked imports' - the compiler trusts that exactly one definition exists in linked code. For pure Rust items, the module system and crate boundaries enforce uniqueness. For FFI with #[no_mangle], the user must ensure ODR compliance in the linked C code. Per ADD-6: 'may affect extern \"C\" declarations'.",
      "rejected_matches": [
        {
          "fls_id": "fls_21vnag69kbwe",
          "category": 0,
          "fls_section": "2.3",
          "fls_title": "Identifiers",
          "score": 0.652,
          "reason": "About identifier syntax, not about external linkage or definition uniqueness."
        },
        {
          "fls_id": "fls_7bxv8lybxm18",
          "category": 0,
          "fls_section": "5.3",
          "fls_title": "Identifier Patterns",
          "score": 0.579,
          "reason": "Pattern matching syntax, not related to external linkage."
        }
      ]
    },
    {
      "guideline_id": "Rule 8.7",
      "guideline_title": "Functions and objects should not be defined with external linkage if they are referenced in only one translation unit",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_jdknpu3kf865",
          "fls_title": "Visibility",
          "category": 0,
          "score": 0.683,
          "reason": "FLS defines Rust's visibility system with granular control: private (default), pub(crate), pub(super), pub(in path), and pub."
        },
        {
          "fls_id": "fls_aa4f3rvir9lm",
          "fls_title": "Visibility - pub(crate)",
          "category": -2,
          "score": 0.701,
          "reason": "Per FLS: 'A crate public modifier...grants a name public visibility within the current crate only.' This directly addresses MISRA's concern."
        },
        {
          "fls_id": "fls_utgjx6l5zwfl",
          "fls_title": "Visibility - default private",
          "category": -2,
          "score": 0.571,
          "reason": "Per FLS: 'An external item, a field, or an item that appears without a visibility modifier has private visibility by default.'"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "advisory",
      "misra_rust_comment": "items should not be declared pub if referenced in only one crate",
      "confidence": "high",
      "notes": "Rust's visibility system directly addresses this. Items are private by default; pub(crate) provides crate-internal visibility. Clippy lint redundant_pub_crate can detect unnecessary pub exposure.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 8.8",
      "guideline_title": "The static storage class specifier shall be used in all declarations of objects and functions that have internal linkage",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_xdvdl2ssnhlo",
          "category": 0,
          "fls_section": "7.3",
          "score": 0.679,
          "reason": "Rust statics are about storage duration, not linkage. Visibility in Rust is controlled by pub/module system, not storage class specifiers."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_section": "21.3",
          "score": 0.603,
          "reason": "External blocks are for FFI declarations, not about internal vs external linkage control."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "C uses storage class specifiers (static/extern) for linkage control. Rust has no equivalent concept - visibility is controlled through the module system (pub, pub(crate), private by default). Rust's \"static\" keyword is for storage duration, not linkage."
    },
    {
      "guideline_id": "Rule 8.9",
      "guideline_title": "An object should be declared at block scope if its identifier only appears in a single function",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_6ozthochxz1i",
          "fls_title": "Binding Scopes",
          "category": 0,
          "score": 0.599,
          "reason": "FLS defines binding scopes. Variables are scoped to their containing block."
        },
        {
          "fls_id": "fls_74nk389rk075",
          "fls_title": "Binding Scopes - let statement",
          "category": -2,
          "score": 0.568,
          "reason": "Per FLS: 'The binding of a let statement is in scope after the related let statement, until the end of the block expression.' Enforces block-level scoping."
        },
        {
          "fls_id": "fls_rm4ncoopcdvj",
          "fls_title": "Drop Scopes",
          "category": 0,
          "score": 0.578,
          "reason": "FLS defines drop scopes. MISRA wants minimal scope for cleanup; Rust's drop scopes provide deterministic destruction at block boundaries."
        },
        {
          "fls_id": "fls_vrqgac634wpr",
          "fls_title": "Drop Scopes - binding drop",
          "category": -2,
          "score": 0.566,
          "reason": "Per FLS: 'A binding declared in a let statement is associated with the drop scope of the block expression that contains the let statement.'"
        },
        {
          "fls_id": "fls_m0z7omni9hp0",
          "fls_title": "Item Scope",
          "category": 0,
          "score": 0.611,
          "reason": "FLS defines item scope. Items declared in blocks are scoped to those blocks."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "recommended",
      "confidence": "high",
      "notes": "Rust naturally enforces block scoping. Variables are declared at point of use with let and scoped to their containing block. Drop scopes ensure deterministic cleanup at block exit, directly addressing MISRA's concern about minimal scope.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 8.10",
      "guideline_title": "An inline function shall be declared with the static storage class C99",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_ypio6boj3pwf",
          "category": 0,
          "fls_section": "13.-2.5",
          "fls_title": "Attribute ``inline``",
          "score": 0.672,
          "reason": "Rust's #[inline] attribute is a compiler optimization hint, not a linkage specifier. Per FLS fls_r3p4din7rjz8: 'A tool is not obliged to perform inlining.' Unlike C, Rust has no external/internal linkage distinction for inline functions."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_section": "21.-2.3",
          "fls_title": "External Blocks",
          "score": 0.669,
          "reason": "External blocks are for FFI declarations, unrelated to inline function linkage semantics."
        },
        {
          "fls_id": "fls_xdvdl2ssnhlo",
          "category": 0,
          "fls_section": "7.-2.3",
          "fls_title": "Statics",
          "score": 0.631,
          "reason": "Rust statics have different semantics than C static storage class; not related to inline function linkage."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA addresses C's UB when an inline function with external linkage lacks a definition in the translation unit, and timing ambiguity when both inline and external definitions exist. Rust has no equivalent issue: (1) functions have exactly one definition - no inline vs external definition distinction, (2) #[inline] is an optimization hint orthogonal to visibility (pub/pub(crate)), (3) Rust's module system and single-definition rule eliminate the linkage ambiguity that MISRA addresses."
    },
    {
      "guideline_id": "Rule 8.11",
      "guideline_title": "When an array with external linkage is declared, its size should be explicitly specified",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_uj0kpjwyld60",
          "category": 0,
          "fls_section": "4.-2.7",
          "fls_title": "Array Types",
          "score": 0.511,
          "reason": "Rust arrays always require explicit size - per FLS fls_imr2jx6cbuzq: 'The size operand shall be a constant expression or an inferred constant.' There is no incomplete array type in Rust."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA addresses C's ability to declare arrays with incomplete type (unspecified size) with external linkage. Rust prevents this entirely: per FLS fls_imr2jx6cbuzq, array types require 'a constant expression or an inferred constant' for size. Rust has no concept of incomplete array types - [T; N] always requires N to be known at compile time. The concern about cross-translation-unit consistency is also moot since Rust's module system and single-definition semantics prevent the ambiguity."
    },
    {
      "guideline_id": "Rule 8.12",
      "guideline_title": "Within an enumerator list, the value of an implicitly-specified enumeration constant shall be unique",
      "guideline_type": "rule",
      "applicability_all_rust": "rust_prevents",
      "applicability_safe_rust": "rust_prevents",
      "accepted_matches": [
        {
          "fls_id": "fls_w9xj26ej869w",
          "category": -2,
          "fls_section": "fls_szibmtfv117b",
          "fls_title": "Enum Types",
          "score": 0.6,
          "reason": "Per FLS fls_w9xj26ej869w: 'It is a static error if two enum variants have discriminants with the same value.' Rust enforces this at compile time - duplicate discriminant values are rejected by the compiler."
        },
        {
          "fls_id": "fls_szibmtfv117b",
          "category": 0,
          "fls_section": "4.-2.11",
          "fls_title": "Enum Types",
          "score": 0.588,
          "reason": "Parent section containing discriminant uniqueness rules and implicit discriminant value calculation rules (fls_t36rk3wikq28, fls_8ajw5trd23wi)."
        }
      ],
      "rejected_matches": [
        {
          "fls_id": "fls_66m2hwkju0vv",
          "category": -2,
          "fls_section": "fls_66m4rnbssgig",
          "fls_title": "Constant Expressions",
          "score": 0.673,
          "reason": "About constant expression contexts, not discriminant uniqueness."
        },
        {
          "fls_id": "fls_ixjc5jaamx84",
          "category": 0,
          "fls_section": "7.-2.2",
          "fls_title": "Constants",
          "score": 0.572,
          "reason": "About const items, not enum discriminants."
        }
      ],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA addresses C's ability to have duplicate enum constant values through mixing implicit and explicit specifications. Rust prevents this at compile time: per FLS fls_w9xj26ej869w, 'It is a static error if two enum variants have discriminants with the same value.' The discriminant calculation rules (fls_t36rk3wikq28: first variant is 0, fls_8ajw5trd23wi: subsequent are previous+1) combined with explicit initializers are checked for uniqueness by the compiler."
    },
    {
      "guideline_id": "Rule 8.13",
      "guideline_title": "A pointer should point to a const-qualified type whenever possible",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_v5x85lt5ulva",
          "fls_title": "References",
          "category": 0,
          "score": 0.578,
          "reason": "FLS defines references. Rust's default is immutable (&T); mutable requires explicit &mut."
        },
        {
          "fls_id": "fls_wcf5mxrzbujn",
          "fls_title": "References - immutable",
          "category": -2,
          "score": 0.552,
          "reason": "Per FLS: 'An immutable reference is a value of a shared reference type, and prevents the mutation of its referent.' Immutability is the default."
        },
        {
          "fls_id": "fls_fckoj1jh5mrc",
          "fls_title": "References - mutable",
          "category": -2,
          "score": 0.573,
          "reason": "Per FLS: 'A mutable reference is a value of a mutable reference type, and allows the mutation of its referent.' Mutation requires explicit opt-in."
        },
        {
          "fls_id": "fls_77scxuomlbgs",
          "fls_title": "Passing Conventions",
          "category": 0,
          "score": 0.601,
          "reason": "FLS defines how parameters are passed. By-reference passing uses immutable borrows by default."
        },
        {
          "fls_id": "fls_ppd1xwve3tr7",
          "fls_title": "Raw Pointer Types",
          "category": 0,
          "score": 0.616,
          "reason": "FLS defines raw pointer types for unsafe/FFI contexts. Immutable raw pointers use const keyword."
        },
        {
          "fls_id": "fls_8uWfFAsZeRCs",
          "fls_title": "Raw Pointer Types - immutable",
          "category": -2,
          "score": 0.598,
          "reason": "Per FLS: 'An immutable raw pointer type is a raw pointer type subject to keyword const.' Applies to unsafe FFI contexts."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "advisory",
      "confidence": "high",
      "notes": "Rust's reference system directly addresses MISRA's concern. Immutable references (&T) are the default, enforcing const-by-default. Mutable references (&mut T) require explicit declaration. For unsafe/FFI, *const T parallels C's const pointer.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 8.14",
      "guideline_title": "The restrict type qualifier shall not be used C99",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_xztr1kebz8bo",
          "category": 0,
          "fls_section": "4.-2.16",
          "fls_title": "Function Pointer Types",
          "score": 0.663,
          "reason": "Similarity based on pointer terminology; Rust function pointers have no restrict qualifier equivalent."
        },
        {
          "fls_id": "fls_ppd1xwve3tr7",
          "category": 0,
          "fls_title": "Raw Pointer Types",
          "score": 0.658,
          "reason": "Rust raw pointers do not support restrict-like qualifiers; aliasing is handled differently via references and borrow checking."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no 'restrict' type qualifier. The C 'restrict' keyword is a promise to the compiler about pointer aliasing that enables optimizations but causes UB if violated. Rust handles aliasing safety through the borrow checker for references (&T, &mut T) and provides no user-accessible aliasing hints for raw pointers. The compiler internally uses noalias annotations based on reference semantics, but this is not exposed to users. Since restrict cannot be written in Rust, this rule is not applicable."
    },
    {
      "guideline_id": "Rule 8.15",
      "guideline_title": "All declarations of an object with an explicit alignment specification shall specify the same alignment C11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_g1z6bpyjqxkz",
          "fls_title": "Type Layout",
          "category": 0,
          "score": 0.7,
          "reason": "FLS defines alignment as an intrinsic property of types. Rust types have a single definition where alignment is specified via #[repr(align(N))], eliminating the possibility of conflicting alignment specifications across declarations."
        },
        {
          "fls_id": "fls_aibb2quva4mn",
          "fls_title": "Attribute repr",
          "category": 0,
          "score": 0.56,
          "reason": "FLS: 'Attribute repr shall apply to abstract data types' and 'shall indicate the type representation of the related type.' Alignment is specified once at the type definition via repr(align(N)) or repr(packed)."
        },
        {
          "fls_id": "fls_muxfn9soi47l",
          "fls_title": "Type Layout",
          "category": -2,
          "score": 0.68,
          "reason": "FLS: 'The alignment of a value specifies which addresses are valid for storing the value.' This alignment is determined by the type definition, not separate declarations."
        },
        {
          "fls_id": "fls_s4yt19sptl7d",
          "fls_title": "External Statics",
          "category": 0,
          "score": 0.55,
          "reason": "For external statics (FFI), alignment is determined by the type used in the declaration. The type itself carries alignment specification, preventing declaration/definition mismatch."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "may affect extern \u201cC\u201d declarations",
      "confidence": "high",
      "notes": "Rust prevents this issue by design: types have single definitions where alignment is specified. No forward declarations or separate object declarations exist. For FFI, alignment is intrinsic to the type used.",
      "rejected_matches": [
        {
          "fls_id": "fls_jr9dykj6rydn",
          "fls_title": "Struct Type Representation",
          "category": -2,
          "score": 0.71,
          "reason": "While this discusses struct alignment calculation, it's about layout rules not declaration consistency."
        },
        {
          "fls_id": "fls_JBfZuFDQg3mU",
          "fls_title": "Place Expressions",
          "category": -2,
          "score": 0.62,
          "reason": "Not relevant - discusses struct expression initializers, not alignment."
        }
      ]
    },
    {
      "guideline_id": "Rule 8.16",
      "guideline_title": "The alignment specification of zero should not appear in an object declaration",
      "guideline_type": "rule",
      "applicability_all_rust": "rust_prevents",
      "applicability_safe_rust": "rust_prevents",
      "accepted_matches": [
        {
          "fls_id": "fls_muxfn9soi47l",
          "category": -2,
          "fls_section": "fls_g1z6bpyjqxkz",
          "fls_title": "Type Layout",
          "score": 0.675,
          "reason": "Per FLS fls_muxfn9soi47l: 'The alignment of a value... is at least one, and always a power of two.' This rule prevents align(0) - the compiler rejects it with error E0589 'not a power of two'."
        }
      ],
      "rejected_matches": [
        {
          "fls_id": "fls_rjxpof29a3nl",
          "category": 0,
          "fls_section": "4.-2.29",
          "fls_title": "Struct Type Representation",
          "score": 0.596,
          "reason": "Section about C representation layout, not alignment constraints."
        }
      ],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust prevents alignment of 0 at compile time. Per FLS fls_muxfn9soi47l: 'The alignment of a value... is at least one, and always a power of two.' Attempting #[repr(align(0))] results in compiler error E0589: 'invalid repr(align) attribute: not a power of two'. C's _Alignas(0) meaning 'use default alignment' has no equivalent in Rust - if you want default alignment, simply don't specify any alignment."
    },
    {
      "guideline_id": "Rule 8.17",
      "guideline_title": "At most one explicit alignment specifier should appear in an object declaration",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_aibb2quva4mn",
          "category": 0,
          "fls_section": "13.-2.25",
          "fls_title": "Attribute ``repr``",
          "score": 0.534,
          "reason": "While Rust allows multiple #[repr(align(N))] attributes (taking the maximum), this is applied to type definitions not object declarations. The C pattern of _Alignas on variable declarations has no Rust equivalent."
        },
        {
          "fls_id": "fls_rjxpof29a3nl",
          "category": 0,
          "fls_section": "4.-2.29",
          "fls_title": "Struct Type Representation",
          "score": 0.593,
          "reason": "Section about struct layout, not alignment specification syntax."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "In C, _Alignas can be applied directly to object declarations (variables), allowing confusing constructs like '_Alignas(4) _Alignas(8) int x;'. In Rust, alignment is specified via #[repr(align(N))] on type definitions only - you cannot specify alignment on individual variable declarations. While Rust technically allows multiple #[repr(align(N))] on a type (taking the maximum), this is uncommon and linted against by clippy. The MISRA concern about 'object declarations' doesn't translate directly since Rust's alignment model is type-centric rather than object-centric."
    },
    {
      "guideline_id": "Rule 8.18",
      "guideline_title": "There shall be no tentative definitions in a header file C90",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_xdvdl2ssnhlo",
          "category": 0,
          "fls_section": "7.-2.3",
          "fls_title": "Statics",
          "score": 0.507,
          "reason": "Rust statics have single-definition semantics; no tentative definitions exist."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "C 'tentative definitions' (e.g., 'int x;' without initializer in a header) create multiple object instances per translation unit. Rust has no equivalent concept. Rust's statics require explicit 'static' keyword and an initializer, enforcing single-definition semantics. Rust's module system and lack of textual header inclusion prevent the issue entirely - items are defined once and imported by path."
    },
    {
      "guideline_id": "Rule 8.19",
      "guideline_title": "There should be no external declarations in a source file",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_section": "21.-2.3",
          "fls_title": "External Blocks",
          "score": 0.698,
          "reason": "Rust's 'extern' blocks are for FFI declarations, not the C sense of 'external' meaning cross-translation-unit visibility. Rust's module system is fundamentally different from C's header/source model."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA addresses C's pattern where 'extern' declarations appear in source files rather than headers, breaking modularity. Rust's compilation model is fundamentally different: there are no header files, no textual inclusion, and no 'extern' declarations for Rust items (only for FFI). Items are defined once in a module and made visible via 'pub' and 'use'. Rust's 'extern' blocks (for FFI) typically go in dedicated modules/crates and don't have the modularity concerns MISRA addresses."
    },
    {
      "guideline_id": "Rule 9.1",
      "guideline_title": "The value of an object with automatic storage duration shall not be read before it has been set C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_3xvm61x0t251",
          "fls_title": "Initialization",
          "category": 0,
          "score": 0.75,
          "reason": "FLS directly addresses this. Contains legality rule: 'A variable shall be initialized before it is accessed.' This is a compiler-enforced rule in Rust."
        },
        {
          "fls_id": "fls_46910buiwvv9",
          "fls_title": "Initialization",
          "category": -2,
          "score": 0.64,
          "reason": "FLS legality rule: 'A variable shall be initialized before it is accessed.' Direct enforcement at compile time."
        },
        {
          "fls_id": "fls_r9km9f969bu8",
          "fls_title": "Variables",
          "category": -2,
          "score": 0.49,
          "reason": "FLS: 'A variable shall be used only after it has been initialized through all reachable control flow paths up to the point of its usage.' Rust's definite initialization analysis."
        },
        {
          "fls_id": "fls_6lg0oaaopc26",
          "fls_title": "Values",
          "category": -4,
          "score": 0.6,
          "reason": "FLS UB: 'It is undefined behavior to create a value from uninitialized memory unless the type of the value is a union type.' Backs up the legality rules."
        },
        {
          "fls_id": "fls_g8etd5lsgn9j",
          "fls_title": "Variables",
          "category": -3,
          "score": 0.67,
          "reason": "FLS: 'A variable is not initialized when allocated.' Establishes the default uninitialized state."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "misra_rust_comment": "enforced by rustc but can be bypassed by unsafe",
      "confidence": "high",
      "notes": "Rust directly enforces this via compile-time definite initialization analysis. The compiler tracks initialization state through all control flow paths and rejects programs that may use uninitialized variables.",
      "rejected_matches": [
        {
          "fls_id": "fls_hydq3pvm00bn",
          "fls_title": "Struct Type Representation",
          "category": -2,
          "score": 0.59,
          "reason": "Not relevant - discusses struct layout offset initialization, not variable initialization."
        },
        {
          "fls_id": "fls_e5b9n910z1cp",
          "fls_title": "Struct Expressions",
          "category": -2,
          "score": 0.59,
          "reason": "Not relevant - discusses struct expression initializer values, not variable initialization before use."
        }
      ]
    },
    {
      "guideline_id": "Rule 9.2",
      "guideline_title": "The initializer for an aggregate or union shall be enclosed in braces C90",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_8tsynkj2cufj",
          "category": 0,
          "fls_section": "6.-2.34",
          "fls_title": "Struct Expressions",
          "score": 0.606,
          "reason": "Rust struct syntax always requires braces - there's no ambiguous form to prohibit."
        },
        {
          "fls_id": "fls_xinykul167l",
          "category": 0,
          "fls_section": "6.-2.31",
          "fls_title": "Array Expressions",
          "score": 0.514,
          "reason": "Rust array syntax always requires brackets - there's no ambiguous form to prohibit."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA addresses C's ambiguous aggregate initialization where braces can be omitted (e.g., 'int arr[2][3] = {1,2,3,4,5,6}'). Rust's syntax is unambiguous by design: arrays use brackets [a, b, c], structs use braces Foo { field: value }, and nested structures require explicit nesting. The compiler enforces this - there's no optional brace syntax to misuse."
    },
    {
      "guideline_id": "Rule 9.3",
      "guideline_title": "Arrays shall not be partially initialized",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_xinykul167l",
          "category": 0,
          "fls_section": "6.-2.31",
          "fls_title": "Array Expressions",
          "score": 0.55,
          "reason": "Rust array expressions require all elements but this is a different model than C's partial initialization."
        },
        {
          "fls_id": "fls_3xvm61x0t251",
          "category": 0,
          "fls_section": "15.-2.2",
          "fls_title": "Initialization",
          "score": 0.595,
          "reason": "General initialization section, not specific to array partial initialization."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "C allows partial array initialization (e.g., 'int arr[5] = {1, 2}' where remaining elements are implicitly zeroed). Rust has no equivalent concept - arrays must be fully initialized via element list [a, b, c] or repetition [x; N]. Per MISRA ADD-6: n/a."
    },
    {
      "guideline_id": "Rule 9.4",
      "guideline_title": "An element of an object shall not be initialized more than once",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_8tsynkj2cufj",
          "category": 0,
          "fls_section": "6.4",
          "fls_title": "Struct Expressions",
          "score": 0.61,
          "reason": "Per FLS fls_bbmm5vir9xos: 'Contain at most one matched named initializer'. Per fls_j2kmp1fee0g4: 'Contain at most one matched indexed initializer'. These rules explicitly prevent duplicate field initialization in struct expressions."
        },
        {
          "fls_id": "fls_bbmm5vir9xos",
          "category": -2,
          "fls_section": "6.4",
          "fls_title": "Struct Expressions",
          "score": 0.62,
          "reason": "'Contain at most one matched named initializer' - Rust enforces this at compile time, directly addressing MISRA's concern about duplicate initialization."
        },
        {
          "fls_id": "fls_j2kmp1fee0g4",
          "category": -2,
          "fls_section": "6.4",
          "fls_title": "Struct Expressions",
          "score": 0.6,
          "reason": "'Contain at most one matched indexed initializer' - Prevents duplicate initialization of tuple struct fields."
        },
        {
          "fls_id": "fls_3xvm61x0t251",
          "category": 0,
          "fls_section": "15.2",
          "fls_title": "Initialization",
          "score": 0.651,
          "reason": "Defines initialization semantics. Per FLS: 'A variable shall be initialized before it is accessed.' Rust's initialization tracking ensures each field is initialized exactly once."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "misra_rust_comment": "enforced by rustc",
      "confidence": "high",
      "notes": "MISRA prevents duplicate designated initializers in C. Rust enforces this at compile time via FLS 6.4 (Struct Expressions): each field must have 'at most one matched named/indexed/shorthand initializer'. The compiler emits error E0062 for duplicate field specifications. Per ADD-6: 'enforced by rustc'.",
      "rejected_matches": [
        {
          "fls_id": "fls_94a8v54bufn8",
          "category": 0,
          "fls_section": "7.1",
          "fls_title": "Values",
          "score": 0.517,
          "reason": "General value semantics, not specifically about initialization uniqueness."
        }
      ]
    },
    {
      "guideline_id": "Rule 9.5",
      "guideline_title": "Where designated initializers are used to initialize an array object the size of the array shall be specified explicitly",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_xinykul167l",
          "category": 0,
          "fls_section": "6.-2.31",
          "fls_title": "Array Expressions",
          "score": 0.565,
          "reason": "Rust has no designated initializers - array initialization is either element list or repetition constructor."
        },
        {
          "fls_id": "fls_8tsynkj2cufj",
          "category": 0,
          "fls_section": "6.-2.34",
          "fls_title": "Struct Expressions",
          "score": 0.522,
          "reason": "Struct field initialization is named but this is different from C's designated initializers for arrays."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "C99 designated initializers (e.g., 'int arr[10] = {[5] = 1, [2] = 3}') allow sparse array initialization where size can be implicitly determined by highest index. Rust has no designated initializer syntax for arrays - arrays are initialized via element list [a, b, c] (size inferred from count) or repetition [x; N] (size explicit). The concept doesn't exist in Rust."
    },
    {
      "guideline_id": "Rule 9.6",
      "guideline_title": "An initializer using chained designators shall not contain initializers without designators",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_8tsynkj2cufj",
          "category": 0,
          "fls_section": "6.-2.34",
          "fls_title": "Struct Expressions",
          "score": 0.552,
          "reason": "Rust struct expressions use named fields, but this is different from C's chained designators."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "C99 chained designators (e.g., 'struct s arr[2] = {[0].x = 1, 2, 3}') allow mixing designated and positional initializers, which is confusing. Rust has no chained designator syntax. Struct fields use named initialization (Foo { x: 1, y: 2 }), and arrays use element lists or repetition. The mixing of designated/non-designated initializers that MISRA prohibits cannot occur in Rust."
    },
    {
      "guideline_id": "Rule 9.7",
      "guideline_title": "Atomic objects shall be appropriately initialized before being accessed C11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_vyc9vcuamlph",
          "category": 0,
          "fls_section": "17.1",
          "fls_title": "Atomics",
          "score": 0.697,
          "reason": "Per FLS fls_3pjla9s93mhd: 'An atomic type is a type defined in module core::sync::atomic. Atomic types provide primitive shared-memory communication between threads.' Rust's atomic types require const initialization (e.g., AtomicBool::new(false))."
        },
        {
          "fls_id": "fls_3xvm61x0t251",
          "category": 0,
          "fls_section": "15.2",
          "fls_title": "Initialization",
          "score": 0.501,
          "reason": "Per FLS fls_46910buiwvv9: 'A variable shall be initialized before it is accessed.' This fundamental rule applies to atomic types - the compiler enforces initialization before access."
        },
        {
          "fls_id": "fls_3v733mnewssy",
          "category": 0,
          "fls_section": "17.0",
          "fls_title": "Concurrency",
          "score": 0.529,
          "reason": "Per FLS fls_tx4b8r6i93n4: 'A data race is a scenario where two or more threads access a shared memory location concurrently without any synchronization, where one of the accesses is a modification.' Rust's atomic types prevent data races through memory ordering guarantees."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "MISRA requires atomic objects to be initialized before access to avoid data races. Rust's atomic types (core::sync::atomic) must be initialized with const constructors like AtomicBool::new(). The compiler enforces FLS fls_46910buiwvv9: 'A variable shall be initialized before it is accessed.' For safe Rust, the type system prevents uninitialized access entirely. For unsafe Rust with static atomics, the const initialization requirement applies.",
      "rejected_matches": [
        {
          "fls_id": "fls_xdvdl2ssnhlo",
          "category": 0,
          "fls_section": "3.10",
          "fls_title": "Statics",
          "score": 0.524,
          "reason": "About static variable declarations, not specifically about atomic initialization."
        }
      ]
    },
    {
      "guideline_id": "Rule 10.1",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust's type system prevents implicit type conversions entirely. MISRA's 'essential type model' exists because C has implicit conversions between bool/char/numeric - Rust has none.",
      "guideline_title": "Operands shall not be of an inappropriate essential type C90 [Unspecified 23; Implementation G.3.4(8), G.3.5(3,5), G.3.9(6)] C99 [Undefined 13, 48, 49; Implementation J.3.4(2,5), J.3.5(5), J.3.9(6)] C11 [Undefined 15, 51, 52; Implementation J.3.4(2,5), J.3.5(5), J.3.9(7)]",
      "rejected_matches": [
        {
          "fls_id": "fls_xc1hof4qbf6p",
          "fls_title": "Enum Type Representation",
          "score": 0.7,
          "reason": "About enum discriminant memory layout, not type conversion rules",
          "fls_section": "4.11.2.1",
          "category": -2
        },
        {
          "fls_id": "fls_abp6tjbz8tpn",
          "fls_title": "Bit Expressions",
          "score": 0.67,
          "reason": "About &, |, ^ operators, not essential type mixing",
          "fls_section": "6.5.6",
          "category": -2
        },
        {
          "fls_id": "fls_wrecura8u5ar",
          "fls_title": "Negation Expression",
          "score": 0.65,
          "reason": "About unary negation, not type conversion",
          "fls_section": "6.5.4",
          "category": -2
        },
        {
          "fls_id": "fls_ohhsmifo0urd",
          "fls_title": "Type Representation",
          "score": 0.64,
          "reason": "About memory layout, not conversion legality rules",
          "fls_section": "4.11.2",
          "category": -2
        }
      ],
      "accepted_matches": [
        {
          "fls_id": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "score": 0.65,
          "reason": "Per FLS: 'A cast is legal when it either performs type coercion or is a specialized cast.' All numeric conversions require explicit 'as' cast - no implicit type mixing possible.",
          "fls_section": "6.5.10",
          "category": -2
        },
        {
          "fls_id": "fls_dw33yt5g6m0k",
          "fls_title": "Type Coercion",
          "score": 0.53,
          "reason": "Per FLS: Numeric widening and narrowing are NOT allowed implicitly. Only reference/pointer coercions are implicit. This prevents C's 'usual arithmetic conversions'.",
          "fls_section": "4.12.3",
          "category": -2
        },
        {
          "fls_id": "fls_1k9mkv7rbezi",
          "fls_title": "Arithmetic Expressions",
          "score": 0.45,
          "reason": "Per FLS: Operands of arithmetic operators must be the SAME type. Compiler error if types don't match. MISRA's essential type mixing cannot occur.",
          "fls_section": "6.5.5",
          "category": -2
        }
      ]
    },
    {
      "guideline_id": "Rule 10.2",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust's char type cannot be used in arithmetic. Explicit cast to u32/i32 required for any numeric operations on character values.",
      "guideline_title": "Expressions of essentially character type shall not be used inappropriately in addition and subtraction operations",
      "rejected_matches": [
        {
          "fls_id": "fls_wrecura8u5ar",
          "fls_title": "Negation Expression",
          "score": 0.59,
          "reason": "About unary operators, not char arithmetic",
          "fls_section": "6.5.4",
          "category": -2
        },
        {
          "fls_id": "fls_290jmzfh7x4e",
          "fls_title": "Compound Assignment Expressions",
          "score": 0.57,
          "reason": "About +=/-= etc., not char type restrictions",
          "fls_section": "6.5.12",
          "category": -2
        }
      ],
      "accepted_matches": [
        {
          "fls_id": "fls_wrvjizrqf3po",
          "fls_title": "Char Type",
          "score": 0.59,
          "reason": "Per FLS: Rust's char is a 4-byte Unicode scalar value, NOT a numeric type. Cannot participate in arithmetic without explicit conversion.",
          "fls_section": "4.3.2",
          "category": -2
        },
        {
          "fls_id": "fls_1k9mkv7rbezi",
          "fls_title": "Arithmetic Expressions",
          "score": 0.61,
          "reason": "Per FLS: Arithmetic operands must be numeric types of the same type. char is not a numeric type, so arithmetic on char is a compile error.",
          "fls_section": "6.5.5",
          "category": -2
        },
        {
          "fls_id": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "score": 0.56,
          "reason": "Per FLS: Must use explicit 'as u32' or similar to convert char to numeric. Conversion is always explicit and intentional.",
          "fls_section": "6.5.10",
          "category": -2
        }
      ]
    },
    {
      "guideline_id": "Rule 10.3",
      "guideline_title": "The value of an expression shall not be assigned to an object with a narrower essential type or of a different essential type category C90 [Undefined 15; Implementation G.3.5(2)] C99 [Undefined 15, 16; Implementation J.3.5(4)] C11 [Undefined 17, 18; Implementation J.3.5(4)]",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust's type system prevents implicit narrowing conversions entirely. All numeric type conversions require explicit 'as' casts. The compiler rejects assignments between incompatible types.",
      "accepted_matches": [
        {
          "fls_id": "fls_1qhsun1vyarz",
          "fls_section": "6.5.10",
          "fls_title": "Type Cast Expressions",
          "score": 0.681,
          "reason": "Per FLS: 'A cast is legal when it either performs type coercion or is a specialized cast.' Numeric widening/narrowing requires explicit 'as' cast - not implicit.",
          "category": -2
        },
        {
          "fls_id": "fls_dw33yt5g6m0k",
          "fls_section": "4.12.3",
          "fls_title": "Type Coercion",
          "score": 0.604,
          "reason": "Per FLS: Type coercion list does NOT include numeric widening/narrowing. Only reference/pointer coercions are implicit. This prevents MISRA's narrowing concern.",
          "category": -2
        }
      ],
      "rejected_matches": [
        {
          "fls_id": "fls_lv7w7aalpwm5",
          "fls_section": "4.12.7",
          "fls_title": "Type Inference",
          "score": 0.64,
          "reason": "About how compiler infers types, not about conversion rules between types.",
          "category": -2
        },
        {
          "fls_id": "fls_ixjc5jaamx84",
          "fls_section": "7.1",
          "fls_title": "Constants",
          "score": 0.589,
          "reason": "About constant declarations, not type conversion.",
          "category": -2
        },
        {
          "fls_id": "fls_5cm4gkt55hjh",
          "fls_section": "6.5.2",
          "fls_title": "Dereference Expression",
          "score": 0.587,
          "reason": "About pointer dereferencing, not numeric type conversion.",
          "category": -2
        },
        {
          "fls_id": "fls_ohhsmifo0urd",
          "fls_section": "4.11.2",
          "fls_title": "Type Representation",
          "score": 0.576,
          "reason": "About memory layout, not conversion legality rules.",
          "category": -2
        }
      ]
    },
    {
      "guideline_id": "Rule 10.4",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "C's 'usual arithmetic conversions' don't exist in Rust. Operands must match exactly or code won't compile.",
      "guideline_title": "Both operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type category C90 [Implementation G.3.6(2)], C99 [Implementation J.3.6(4)], C11 [Implementation J.3.6(5)]",
      "rejected_matches": [
        {
          "fls_id": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "score": 0.69,
          "reason": "Shows Rust's explicit alternative but rule is about implicit conversions which don't exist",
          "fls_section": "6.5.10",
          "category": -2
        },
        {
          "fls_id": "fls_abp6tjbz8tpn",
          "fls_title": "Bit Expressions",
          "score": 0.63,
          "reason": "Operators have same-type requirement but not the focus of this rule",
          "fls_section": "6.5.6",
          "category": -2
        },
        {
          "fls_id": "fls_ZfIBiJMf8qE1",
          "fls_title": "Arithmetic Overflow",
          "score": 0.6,
          "reason": "About overflow behavior, not type conversion",
          "fls_section": "6.23",
          "category": -1
        }
      ],
      "accepted_matches": [
        {
          "fls_id": "fls_1k9mkv7rbezi",
          "fls_title": "Arithmetic Expressions",
          "score": 0.66,
          "reason": "Per FLS: Operands must be the SAME type. 'i32 + i64' is a compile error. No implicit 'usual arithmetic conversions' exist in Rust.",
          "fls_section": "6.5.5",
          "category": -2
        },
        {
          "fls_id": "fls_dw33yt5g6m0k",
          "fls_title": "Type Coercion",
          "score": 0.48,
          "reason": "Per FLS: No implicit numeric widening or narrowing. The 'usual arithmetic conversions' from C simply don't exist in Rust.",
          "fls_section": "4.12.3",
          "category": -2
        }
      ]
    },
    {
      "guideline_id": "Rule 10.5",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "recommended",
      "misra_rust_comment": "includes both safe `as` and unsafe `transmute` operations",
      "confidence": "high",
      "notes": "Rust's 'as' casts can perform potentially inappropriate conversions (truncation, sign loss). Clippy lints 'cast_possible_truncation', 'cast_sign_loss' provide additional enforcement.",
      "guideline_title": "The value of an expression should not be cast to an inappropriate essential type",
      "rejected_matches": [
        {
          "fls_id": "fls_xc1hof4qbf6p",
          "fls_title": "Enum Type Representation",
          "score": 0.61,
          "reason": "About enum layout, not cast appropriateness",
          "fls_section": "4.11.2.1",
          "category": -2
        },
        {
          "fls_id": "fls_wrecura8u5ar",
          "fls_title": "Negation Expression",
          "score": 0.57,
          "reason": "Unary operator, not type casting",
          "fls_section": "6.5.4",
          "category": -2
        }
      ],
      "accepted_matches": [
        {
          "fls_id": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "score": 0.7,
          "reason": "Per FLS: Rust's 'as' casts allow numeric conversions including truncation and sign changes. While more restricted than C (no arbitrary pointer casts in safe Rust), numeric casts can still silently truncate. Advisory rule applies.",
          "fls_section": "6.5.10",
          "category": -2
        }
      ]
    },
    {
      "guideline_id": "Rule 10.6",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no implicit widening. Assignment requires exact type match. If wider arithmetic is needed, explicit cast before the operation is required.",
      "guideline_title": "The value of a composite expression shall not be assigned to an object with wider essential type",
      "rejected_matches": [
        {
          "fls_id": "fls_8tsynkj2cufj",
          "fls_title": "Struct Expressions",
          "score": 0.56,
          "reason": "About struct initialization, not assignment widening",
          "fls_section": "6.11",
          "category": -2
        },
        {
          "fls_id": "fls_3ut3biyra4r9",
          "fls_title": "Assignee Expressions",
          "score": 0.55,
          "reason": "About what can be assigned to, not type widening",
          "fls_section": "6.1.1",
          "category": -2
        }
      ],
      "accepted_matches": [
        {
          "fls_id": "fls_y4by2i8dl05o",
          "fls_title": "Assignment Expressions",
          "score": 0.58,
          "reason": "Per FLS: Assignment requires types to match exactly. Cannot assign u16 result to u32 variable without explicit cast.",
          "fls_section": "6.5.11",
          "category": -2
        },
        {
          "fls_id": "fls_dw33yt5g6m0k",
          "fls_title": "Type Coercion",
          "score": 0.53,
          "reason": "Per FLS: No implicit widening coercions. The C pattern of 'u32 x = u16_a + u16_b' (implicit widening) doesn't compile in Rust.",
          "fls_section": "4.12.3",
          "category": -2
        },
        {
          "fls_id": "fls_ZfIBiJMf8qE1",
          "fls_title": "Arithmetic Overflow",
          "score": 0.45,
          "reason": "Per FLS: Overflow has defined behavior (panic or wrap), not UB. Even if narrow arithmetic overflows, behavior is deterministic.",
          "fls_section": "6.23",
          "category": -1
        }
      ]
    },
    {
      "guideline_id": "Rule 10.7",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Similar to 10.6 - Rust's same-type requirement for operators prevents mixing narrow composite expressions with wider operands.",
      "guideline_title": "If a composite expression is used as one operand of an operator in which the usual arithmetic conversions are performed then the other operand shall not have wider essential type",
      "rejected_matches": [
        {
          "fls_id": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "score": 0.6,
          "reason": "Shows explicit alternative, but rule about implicit conversions which don't exist",
          "fls_section": "6.5.10",
          "category": -2
        },
        {
          "fls_id": "fls_abp6tjbz8tpn",
          "fls_title": "Bit Expressions",
          "score": 0.59,
          "reason": "Same-type requirement but not the focus",
          "fls_section": "6.5.6",
          "category": -2
        },
        {
          "fls_id": "fls_ZfIBiJMf8qE1",
          "fls_title": "Arithmetic Overflow",
          "score": 0.54,
          "reason": "About overflow, not type widening",
          "fls_section": "6.23",
          "category": -1
        }
      ],
      "accepted_matches": [
        {
          "fls_id": "fls_1k9mkv7rbezi",
          "fls_title": "Arithmetic Expressions",
          "score": 0.61,
          "reason": "Per FLS: Both operands must be the SAME type. Mixing u16 composite with u32 operand is a compile error.",
          "fls_section": "6.5.5",
          "category": -2
        },
        {
          "fls_id": "fls_dw33yt5g6m0k",
          "fls_title": "Type Coercion",
          "score": 0.48,
          "reason": "Per FLS: No implicit widening. The scenario this rule prevents cannot occur because Rust rejects type mismatches.",
          "fls_section": "4.12.3",
          "category": -2
        }
      ]
    },
    {
      "guideline_id": "Rule 10.8",
      "guideline_type": "rule",
      "applicability_all_rust": "partial",
      "applicability_safe_rust": "partial",
      "fls_rationale_type": "partial_mapping",
      "misra_rust_category": "advisory",
      "misra_rust_comment": "includes both safe `as` and unsafe `transmute` operations",
      "confidence": "high",
      "notes": "Rust allows explicit widening casts after narrow arithmetic. The MISRA concern is partially mitigated by defined overflow behavior, but explicit casts can still mask programmer intent errors.",
      "guideline_title": "The value of a composite expression shall not be cast to a different essential type category or a wider essential type",
      "rejected_matches": [
        {
          "fls_id": "fls_abp6tjbz8tpn",
          "fls_title": "Bit Expressions",
          "score": 0.54,
          "reason": "About bitwise operators, not casting composite expressions",
          "fls_section": "6.5.6",
          "category": -2
        },
        {
          "fls_id": "fls_exe4zodlwfez",
          "fls_title": "Type Unification",
          "score": 0.5,
          "reason": "About type inference, not explicit casting",
          "fls_section": "4.12.2",
          "category": -2
        }
      ],
      "accepted_matches": [
        {
          "fls_id": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "score": 0.66,
          "reason": "Per FLS: Rust allows explicit widening casts after narrow arithmetic: '(a + b) as u32' is legal. The cast is explicit, making intent clear, but can still mask overflow issues.",
          "fls_section": "6.5.10",
          "category": -2
        },
        {
          "fls_id": "fls_ZfIBiJMf8qE1",
          "fls_title": "Arithmetic Overflow",
          "score": 0.48,
          "reason": "Per FLS: Overflow has DEFINED behavior (panic in debug, wrap in release) - not UB like C. Mitigates but doesn't eliminate the MISRA concern about implementation-dependent results.",
          "fls_section": "6.23",
          "category": -1
        }
      ]
    },
    {
      "guideline_id": "Rule 11.1",
      "guideline_title": "Conversions shall not be performed between a pointer to a function and any other type C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "accepted_matches": [
        {
          "fls_id": "fls_xztr1kebz8bo",
          "category": 0,
          "fls_section": "4.8",
          "fls_title": "Function Pointer Types",
          "score": 0.669,
          "reason": "Per FLS fls_v2wrytr3t04h: 'A function pointer type is an indirection type that refers to a function.' Defines function pointer as a distinct type."
        },
        {
          "fls_id": "fls_1qhsun1vyarz",
          "category": 0,
          "fls_section": "6.27",
          "fls_title": "Type Cast Expressions",
          "score": 0.548,
          "reason": "Per FLS fls_133j6xw8k4qe: 'An operand of a function pointer type and a target type *const V or *mut V... perform function-pointer-to-pointer cast.' Per fls_bhw2j9wjpf2x: function-pointer-to-address casts are explicitly defined. Rust allows these casts via 'as' but they require explicit syntax."
        },
        {
          "fls_id": "fls_wz2etmkpvxed",
          "category": -2,
          "fls_section": "4.19",
          "fls_title": "Type Unification",
          "score": 0.705,
          "reason": "'A function pointer type is unifiable only with another function pointer type when...' - Function pointers have strict type compatibility rules, preventing implicit conversions."
        }
      ],
      "fls_rationale_type": "partial_mapping",
      "misra_rust_category": "required",
      "misra_rust_comment": "includes both safe `as` and unsafe `transmute` operations",
      "confidence": "high",
      "notes": "MISRA prohibits conversions between function pointers and other types due to UB. Rust allows explicit casts via 'as' (fn ptr -> *const T, fn ptr -> usize) but these are explicit, not implicit. For safe Rust, function pointers have strict type unification rules (fls_wz2etmkpvxed). For unsafe transmute operations, the user takes responsibility. Per ADD-6: 'includes both safe `as` and unsafe `transmute` operations'.",
      "rejected_matches": [
        {
          "fls_id": "fls_5cm4gkt55hjh",
          "category": 0,
          "fls_section": "6.17",
          "fls_title": "Dereference Expression",
          "score": 0.528,
          "reason": "About dereferencing pointers, not about function pointer type conversions."
        }
      ]
    },
    {
      "guideline_id": "Rule 11.2",
      "guideline_title": "Conversions shall not be performed between a pointer to an incomplete type and any other type C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "category": 0,
          "score": 0.59,
          "reason": "FLS specifies pointer cast rules. Pointer-to-pointer, pointer-to-address, and address-to-pointer casts require target/source types to implement Sized. This prevents casts involving Rust's equivalent of incomplete types (!Sized/DST)."
        },
        {
          "fls_id": "fls_t16yzaxro5ew",
          "fls_title": "Type Cast Expressions",
          "category": -2,
          "score": 0.58,
          "reason": "FLS: 'An operand of type *const T or *mut T and a target type *const V or *mut V where V implements the core::marker::Sized trait performs pointer-to-pointer cast.' Target type must be Sized."
        },
        {
          "fls_id": "fls_i4zsbbmfa2fl",
          "fls_title": "Type Cast Expressions",
          "category": -2,
          "score": 0.62,
          "reason": "FLS: 'An operand of type *const T or *mut T where T implements the core::marker::Sized trait and a target integer type perform pointer-to-address cast.' Source type must be Sized."
        },
        {
          "fls_id": "fls_26Xgem831Nqg",
          "fls_title": "Type Layout",
          "category": -2,
          "score": 0.64,
          "reason": "FLS: 'A dynamically sized type is a type that does not implement the core::marker::Sized trait.' Defines Rust's equivalent of C incomplete types."
        },
        {
          "fls_id": "fls_hidfwkwr2r73",
          "fls_title": "Generic Parameters",
          "category": -2,
          "score": 0.63,
          "reason": "FLS: 'A type parameter has an implicit core::marker::Sized bound.' The Sized constraint is pervasive, preventing most operations on unsized types."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "Rust's Sized trait directly addresses this. Pointer casts explicitly require Sized types, preventing conversions involving dynamically sized (incomplete) types. This is compiler-enforced in safe Rust and well-defined in unsafe Rust.",
      "rejected_matches": [
        {
          "fls_id": "fls_ismr7wwvek4q",
          "fls_title": "Type Unification",
          "category": -2,
          "score": 0.67,
          "reason": "While relevant to type compatibility, this discusses type unification rules not cast restrictions."
        }
      ]
    },
    {
      "guideline_id": "Rule 11.3",
      "guideline_title": "A conversion shall not be performed between a pointer to object type and a pointer to a different object type C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "category": 0,
          "score": 0.59,
          "reason": "FLS defines pointer-to-pointer cast rules. While the cast *const T to *const V is allowed in unsafe Rust, dereferencing requires unsafe context and is subject to alignment/validity invariants."
        },
        {
          "fls_id": "fls_t16yzaxro5ew",
          "fls_title": "Type Cast Expressions",
          "category": -2,
          "score": 0.66,
          "reason": "FLS: 'An operand of type *const T or *mut T and a target type *const V or *mut V where V implements the core::marker::Sized trait performs pointer-to-pointer cast.' The cast itself is defined but dereference has strict requirements."
        },
        {
          "fls_id": "fls_8i4jzksxlrw0",
          "fls_title": "Dereference Expression",
          "category": -2,
          "score": 0.47,
          "reason": "FLS: 'Dereferencing a raw pointer shall require unsafe context unless the dereference expression is the operand of a raw borrow expression.' Ensures programmer acknowledges risks."
        },
        {
          "fls_id": "fls_a14slch83hzn",
          "fls_title": "Borrowing",
          "category": 0,
          "score": 0.67,
          "reason": "In safe Rust, references (&T, &mut T) cannot be cast between incompatible types. Rust's borrow system prevents type aliasing violations at compile time."
        },
        {
          "fls_id": "fls_9wgldua1u8yt",
          "fls_title": "Dereference Expression",
          "category": -4,
          "score": 0.67,
          "reason": "FLS UB: 'It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.' Addresses MISRA's alignment concern."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "Safe Rust prevents this entirely - references are strictly typed. In unsafe Rust, pointer casts are allowed but dereferencing requires unsafe context and is subject to alignment/validity requirements. MISRA concern about alignment is addressed by FLS UB rules.",
      "rejected_matches": [
        {
          "fls_id": "fls_k6ues2936pjq",
          "fls_title": "Raw Pointer Types",
          "category": -2,
          "score": 0.69,
          "reason": "While relevant, this is about comparing raw pointers not casting between types."
        }
      ]
    },
    {
      "guideline_id": "Rule 11.4",
      "guideline_title": "A conversion shall not be performed between a pointer to object and an arithmetic type C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_1qhsun1vyarz",
          "category": 0,
          "fls_section": "6.27",
          "fls_title": "Type Cast Expressions",
          "score": 0.709,
          "reason": "Defines pointer-to-integer and integer-to-pointer casts. Per fls_i4zsbbmfa2fl: 'pointer-to-address cast produces an integer that represents the machine address'. Per fls_59mpteeczzo: 'address-to-pointer cast produces a pointer that interprets the integer as a machine address.' These casts require explicit 'as' syntax."
        },
        {
          "fls_id": "fls_i4zsbbmfa2fl",
          "category": -2,
          "fls_section": "6.27",
          "fls_title": "Type Cast Expressions",
          "score": 0.68,
          "reason": "'An operand of type *const T or *mut T... and a target integer type perform pointer-to-address cast... If the integer type is smaller than the type of the operand, the address is truncated.' Addresses truncation concern from MISRA."
        },
        {
          "fls_id": "fls_59mpteeczzo",
          "category": -2,
          "fls_section": "6.27",
          "fls_title": "Type Cast Expressions",
          "score": 0.701,
          "reason": "'An operand of integer type and target type *const V or *mut V... perform address-to-pointer cast.' Explicitly requires 'as' cast - no implicit conversion."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "MISRA prohibits implicit pointer-integer conversions due to alignment and representation UB. Rust requires explicit 'as' casts for pointer<->integer conversions (fls_i4zsbbmfa2fl, fls_59mpteeczzo). The explicit syntax ensures developer awareness. Using raw pointer casts to dereference requires unsafe context. For usize/isize, the cast is well-defined; for smaller integers, truncation occurs (documented in FLS).",
      "rejected_matches": [
        {
          "fls_id": "fls_ZfIBiJMf8qE1",
          "category": 0,
          "fls_section": "7.3",
          "fls_title": "Arithmetic Overflow",
          "score": 0.586,
          "reason": "About integer overflow, not about pointer-integer conversions."
        }
      ]
    },
    {
      "guideline_id": "Rule 11.5",
      "guideline_title": "A conversion should not be performed from pointer to void into pointer to object C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "category": 0,
          "score": 0.64,
          "reason": "FLS defines pointer-to-pointer casts including from *const c_void/*mut c_void to typed pointers. Section states casts between raw pointers are allowed, directly addressing MISRA concern about void* to object* conversions."
        },
        {
          "fls_id": "fls_ppd1xwve3tr7",
          "fls_title": "Raw Pointer Types",
          "category": 0,
          "score": 0.62,
          "reason": "FLS defines raw pointer semantics. Rust has no void* but uses *const c_void/*mut c_void for FFI interop, which maps to this MISRA concern."
        },
        {
          "fls_id": "fls_9wgldua1u8yt",
          "fls_title": "Dereference Expression",
          "category": -4,
          "score": 0.58,
          "reason": "FLS Undefined Behavior section addresses alignment requirements when dereferencing pointers, which relates to MISRA's concern about alignment when converting void* to typed pointers."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "fls_title": "Unsafety",
          "category": 0,
          "score": 0.55,
          "reason": "Raw pointer casts and dereferences require unsafe blocks in Rust, providing compile-time enforcement that C lacks."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "Rust has no void* equivalent but uses *const c_void/*mut c_void for FFI. All raw pointer operations require unsafe, providing stronger safety than C. Current applicability (all_rust: direct, safe_rust: not_applicable) is correct.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 11.6",
      "guideline_title": "A cast shall not be performed between pointer to void and an arithmetic type C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_1qhsun1vyarz",
          "category": 0,
          "fls_section": "6.27",
          "fls_title": "Type Cast Expressions",
          "score": 0.658,
          "reason": "Defines all pointer-to-integer and integer-to-pointer casts. Rust's *const T/*mut T (including *const ()) can be cast to usize/isize via explicit 'as', but requires unsafe for dereferencing."
        },
        {
          "fls_id": "fls_i4zsbbmfa2fl",
          "category": -2,
          "fls_section": "6.27",
          "fls_title": "Type Cast Expressions",
          "score": 0.644,
          "reason": "Per FLS: 'An operand of type *const T or *mut T... and a target integer type perform pointer-to-address cast.' This covers void pointer (*const ()) to integer conversion."
        },
        {
          "fls_id": "fls_59mpteeczzo",
          "category": -2,
          "fls_section": "6.27",
          "fls_title": "Type Cast Expressions",
          "score": 0.664,
          "reason": "Per FLS: 'An operand of integer type and target type *const V or *mut V... perform address-to-pointer cast.' Covers integer to void pointer conversion."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "advisory",
      "confidence": "high",
      "notes": "MISRA prohibits void* <-> arithmetic conversions. Rust doesn't have void* but uses *const ()/*mut c_void. These can be cast to usize/isize via explicit 'as' (fls_i4zsbbmfa2fl, fls_59mpteeczzo). No implicit conversions exist. Floating-point to pointer is not directly supported in Rust - would require intermediate integer cast. Only applicable in unsafe Rust for dereferencing.",
      "rejected_matches": [
        {
          "fls_id": "fls_pcromhosmnf0",
          "category": -2,
          "fls_section": "6.27",
          "fls_title": "Type Cast Expressions",
          "score": 0.704,
          "reason": "About bool/char to integer casts, not about void pointer conversions."
        },
        {
          "fls_id": "fls_ZfIBiJMf8qE1",
          "category": 0,
          "fls_section": "7.3",
          "fls_title": "Arithmetic Overflow",
          "score": 0.506,
          "reason": "About integer overflow, not about pointer-integer conversions."
        }
      ]
    },
    {
      "guideline_id": "Rule 11.8",
      "guideline_title": "A conversion shall not remove any const, volatile or _Atomic qualification from the type pointed to by a pointer C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "accepted_matches": [
        {
          "fls_id": "fls_ppd1xwve3tr7",
          "fls_title": "Raw Pointer Types",
          "category": 0,
          "score": 0.59,
          "reason": "FLS defines *const T (immutable raw pointer) and *mut T (mutable raw pointer) types. The distinction between const and mut in raw pointers directly maps to C's const qualification concept."
        },
        {
          "fls_id": "fls_8uWfFAsZeRCs",
          "fls_title": "Raw Pointer Types",
          "category": -2,
          "score": 0.66,
          "reason": "FLS Legality Rule states 'An immutable raw pointer type is a raw pointer type subject to keyword const'. This defines const semantics for raw pointers."
        },
        {
          "fls_id": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "category": 0,
          "score": 0.62,
          "reason": "FLS covers pointer-to-pointer casts. While *const T to *mut T casts are syntactically allowed in unsafe Rust, this requires explicit unsafe block."
        },
        {
          "fls_id": "fls_t16yzaxro5ew",
          "fls_title": "Type Cast Expressions",
          "category": -2,
          "score": 0.67,
          "reason": "FLS Legality Rule for casts between raw pointer types. Covers *const T to *mut T cast legality."
        }
      ],
      "fls_rationale_type": "partial_mapping",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "Rust tracks const/mut distinction in raw pointer types (*const T vs *mut T). Safe Rust prevents removing const. Unsafe Rust allows *const to *mut casts but requires explicit unsafe block. Rust has no volatile or _Atomic equivalents - volatile operations use read_volatile/write_volatile intrinsics, atomics use std::sync::atomic types. Current applicability (all_rust: direct, safe_rust: partial) is correct.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 11.9",
      "guideline_title": "The macro NULL shall be the only permitted form of integer null pointer constant",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_52thmi9hnoks",
          "category": -4,
          "fls_section": "fls_xztr1kebz8bo",
          "fls_title": "Function Pointer Types",
          "score": 0.591,
          "reason": "About function pointer validity invariants, not null pointer constants."
        },
        {
          "fls_id": "fls_ixjc5jaamx84",
          "category": 0,
          "fls_section": "7.-2.2",
          "fls_title": "Constants",
          "score": 0.53,
          "reason": "About Rust constants in general, not null pointer representation."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "misra_rust_comment": "Rust does not have a null pointer constant",
      "confidence": "high",
      "notes": "Rust has no NULL macro or integer null pointer constant. For raw pointers, Rust uses std::ptr::null() and std::ptr::null_mut() functions. For safe code, Option<T> replaces nullable pointers entirely. The C pattern of using 0 or (void*)0 as null doesn't exist in Rust. Per MISRA ADD-6: n/a."
    },
    {
      "guideline_id": "Rule 11.10",
      "guideline_title": "The _Atomic qualifier shall not be applied to the incomplete type void",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_vyc9vcuamlph",
          "category": 0,
          "fls_section": "17.-2.3",
          "fls_title": "Atomics",
          "score": 0.613,
          "reason": "Rust atomics are types (AtomicU32, AtomicPtr<T>, etc.) not qualifiers. No _Atomic qualifier exists."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "C11's _Atomic is a type qualifier that can be applied to arbitrary types including void. Rust has no _Atomic qualifier - atomics are distinct types in core::sync::atomic (AtomicBool, AtomicU32, AtomicPtr<T>, etc.). You cannot create an 'atomic void' in Rust because atomics are concrete types, not qualifiers. Per MISRA ADD-6: n/a."
    },
    {
      "guideline_id": "Rule 11.11",
      "guideline_title": "Pointers shall not be implicitly compared to NULL",
      "guideline_type": "rule",
      "applicability_all_rust": "rust_prevents",
      "applicability_safe_rust": "rust_prevents",
      "accepted_matches": [
        {
          "fls_id": "fls_r7gzxo16esri",
          "fls_title": "If expression subject bool",
          "category": -2,
          "score": 0.46,
          "reason": "FLS requires if expression subject to be type bool - no implicit pointer-to-bool conversion"
        },
        {
          "fls_id": "fls_142vncdktbin",
          "fls_title": "Reference Types",
          "category": 0,
          "score": 0.6,
          "reason": "FLS references have validity invariant of being non-null, eliminating most null-pointer concerns"
        },
        {
          "fls_id": "fls_ppd1xwve3tr7",
          "fls_title": "Raw Pointer Types",
          "category": 0,
          "score": 0.6,
          "reason": "FLS raw pointer comparisons compare addresses explicitly, not implicit boolean conversion"
        },
        {
          "fls_id": "fls_52thmi9hnoks",
          "fls_title": "Function pointer null invariant",
          "category": -4,
          "score": 0.69,
          "reason": "FLS function pointers have validity invariant of being non-null"
        }
      ],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "implicit",
      "misra_rust_comment": "enforced by rustc",
      "confidence": "high",
      "notes": "MISRA concern is implicit pointer-to-boolean conversion in C (if(ptr)). Rust PREVENTS this: (1) if expression subject must be bool type - no implicit conversions, (2) References have non-null validity invariant, (3) Raw pointers require explicit .is_null() check or comparison. The type system enforces explicit boolean expressions in control flow.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 12.1",
      "guideline_title": "The precedence of operators within expressions should be made explicit",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_kw25194gpael",
          "category": 0,
          "fls_section": "6.21",
          "fls_title": "Expression Precedence",
          "score": 0.733,
          "reason": "FLS defines operator precedence and associativity rules. Rust has a well-defined precedence table. The MISRA concern about making precedence explicit applies - Rust allows parentheses for clarity."
        },
        {
          "fls_id": "fls_ckvjj4tt1hh2",
          "category": 0,
          "fls_section": "6.0",
          "fls_title": "Expressions",
          "score": 0.649,
          "reason": "Chapter-level context for expression semantics and evaluation order."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "recommended",
      "confidence": "high",
      "notes": "MISRA recommends explicit parentheses for precedence clarity. FLS 6.21 (Expression Precedence) defines Rust's operator precedence. Rust's precedence is well-defined but MISRA's stylistic recommendation to use parentheses for clarity applies equally. Clippy lint 'precedence' can warn about complex expressions.",
      "rejected_matches": [
        {
          "fls_id": "fls_290jmzfh7x4e",
          "category": 0,
          "fls_section": "6.3",
          "fls_title": "Compound Assignment Expressions",
          "score": 0.676,
          "reason": "About compound assignment operators specifically, not about general precedence."
        }
      ]
    },
    {
      "guideline_id": "Rule 12.2",
      "guideline_title": "The right hand operand of a shift operator shall lie in the range zero to one less than the width in bits of the essential type of the left hand operand C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "accepted_matches": [
        {
          "fls_id": "fls_abp6tjbz8tpn",
          "fls_title": "Bit Expressions",
          "category": 0,
          "score": 0.77,
          "reason": "FLS defines shift left and shift right expressions and their semantics. Shift operations in Rust have defined behavior based on the implementation."
        },
        {
          "fls_id": "fls_fbazfgd5m1ot",
          "fls_title": "Bit Expressions",
          "category": -2,
          "score": 0.78,
          "reason": "FLS Legality Rule defines shift right as core::ops::Shr::shr(). The standard library implementation panics on overflow in debug mode."
        },
        {
          "fls_id": "fls_kqntxbwnc58v",
          "fls_title": "Bit Expressions",
          "category": -2,
          "score": 0.77,
          "reason": "FLS Legality Rule defines shift left as core::ops::Shl::shl(). Standard library panics on shifts >= bit width in debug mode."
        },
        {
          "fls_id": "fls_f0p70y92k14f",
          "fls_title": "Bit Expressions",
          "category": -3,
          "score": 0.74,
          "reason": "FLS Dynamic Semantics for shift left - defines the runtime evaluation behavior."
        },
        {
          "fls_id": "fls_ZfIBiJMf8qE1",
          "fls_title": "Arithmetic Overflow",
          "category": 0,
          "score": 0.52,
          "reason": "FLS Arithmetic Overflow section covers overflow behavior including shifts. Debug builds panic, release builds wrap or use wrapping_shl/checked_shl."
        }
      ],
      "fls_rationale_type": "partial_mapping",
      "misra_rust_category": "advisory",
      "confidence": "high",
      "notes": "Rust handles shift overflow differently than C: debug builds panic on over-shift, release builds wrap. Safe APIs (checked_shl, overflowing_shl) allow explicit handling. Current applicability (all_rust: direct, safe_rust: partial) is appropriate - the concern exists but Rust provides runtime checks in debug mode.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 12.3",
      "guideline_title": "The comma operator should not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_1pg5ig740tg1",
          "category": 0,
          "fls_section": "8.-2.3",
          "fls_title": "Expression Statements",
          "score": 0.526,
          "reason": "Rust has no comma operator. Expression statements are separated by semicolons, not commas."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no comma operator. In C, the comma operator evaluates left operand, discards result, evaluates right operand (e.g., 'a = (b++, c)'). Rust uses semicolons to separate statements and has no equivalent construct. Tuple construction uses commas but that's syntactically distinct. Per MISRA ADD-6: n/a."
    },
    {
      "guideline_id": "Rule 12.4",
      "guideline_title": "Evaluation of constant expressions should not lead to unsigned integer wrap-around",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_66m4rnbssgig",
          "fls_title": "Constant Expressions",
          "category": 0,
          "score": 0.71,
          "reason": "FLS section on constant expressions defines compile-time evaluation rules including overflow handling."
        },
        {
          "fls_id": "fls_b46nyamfqxdu",
          "fls_title": "Constant Expressions",
          "category": -2,
          "score": 0.69,
          "reason": "FLS: 'The evaluation of a constant expression that results in arithmetic overflow panics.' For const contexts, overflow is a compile-time error - exactly what MISRA requires."
        },
        {
          "fls_id": "fls_ZfIBiJMf8qE1",
          "fls_title": "Arithmetic Overflow",
          "category": 0,
          "score": 0.63,
          "reason": "FLS: 'There are two allowed behaviors for arithmetic overflow: 1) panic 2) truncation.' But for const expressions, only panic (error) is allowed."
        },
        {
          "fls_id": "fls_oFIRXBPXu6Zv",
          "fls_title": "Arithmetic Overflow",
          "category": -1,
          "score": 0.66,
          "reason": "FLS: 'An arithmetic overflow occurs when an operator expression computes a value...that lies outside of the range of valid values.' Defines the overflow condition."
        }
      ],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "advisory",
      "misra_rust_comment": "this is either well-defined or will not occur",
      "confidence": "high",
      "notes": "Rust directly enforces this. Constant expression evaluation with arithmetic overflow is a compile-time error (panics during const eval). This is stricter than MISRA's 'should' - Rust makes it mandatory.",
      "rejected_matches": [
        {
          "fls_id": "fls_Et5gp1I7VqBX",
          "fls_title": "Arithmetic Expressions",
          "category": -3,
          "score": 0.7,
          "reason": "While related, this discusses runtime semantics not constant expression rules."
        }
      ]
    },
    {
      "guideline_id": "Rule 12.5",
      "guideline_title": "The sizeof operator shall not have an operand which is a function parameter declared as \"array of type\"",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_uj0kpjwyld60",
          "category": 0,
          "fls_section": "4.-2.7",
          "fls_title": "Array Types",
          "score": 0.501,
          "reason": "Rust arrays don't decay to pointers. Array parameters retain their type information."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "In C, arrays decay to pointers when passed as function parameters, so sizeof on such a parameter gives pointer size, not array size. Rust has no array-to-pointer decay: arrays are passed by reference (&[T; N]) or as slices (&[T]). std::mem::size_of::<[T; N]>() always gives the actual array size. The C pitfall doesn't exist in Rust. Per MISRA ADD-6: n/a."
    },
    {
      "guideline_id": "Rule 12.6",
      "guideline_title": "Structure and union members of atomic objects shall not be directly accessed C11",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_vyc9vcuamlph",
          "category": 0,
          "fls_section": "17.-2.3",
          "fls_title": "Atomics",
          "score": 0.759,
          "reason": "Rust atomics are opaque types, not structs with accessible members. You cannot directly access internal fields."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "In C11, _Atomic can be applied to struct types, and directly accessing members of such atomic structs is non-atomic and unsafe. Rust's atomic types (AtomicU32, AtomicBool, etc.) are opaque - they don't expose internal fields. You must use methods like load(), store(), compare_exchange() which guarantee atomic access. There's no way to directly access 'members' of an atomic in Rust. Per MISRA ADD-6: n/a."
    },
    {
      "guideline_id": "Rule 13.1",
      "guideline_title": "Initializer lists shall not contain persistent side effects C99",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_8tsynkj2cufj",
          "category": 0,
          "fls_section": "6.4",
          "fls_title": "Struct Expressions",
          "score": 0.682,
          "reason": "Struct expressions define field initialization order. Per ADD-6: 'order of evaluation is strict in Rust' - field initializers are evaluated left-to-right."
        },
        {
          "fls_id": "fls_ckvjj4tt1hh2",
          "category": 0,
          "fls_section": "6.0",
          "fls_title": "Expressions",
          "score": 0.6,
          "reason": "Rust expressions have defined evaluation order, unlike C's unspecified order in initializer lists."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "recommended",
      "misra_rust_comment": "order of evaluation is strict in Rust",
      "confidence": "high",
      "notes": "MISRA prohibits side effects in initializers due to C's unspecified evaluation order. Rust has strict left-to-right evaluation order (per ADD-6). Side effects in struct field initializers are well-defined, making the MISRA concern less critical but still relevant for readability.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 13.2",
      "guideline_title": "The value of an expression and its persistent side effects shall be the same under all permitted evaluation orders and shall be independent from thread interleaving C90",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_zJOAmSr3Dbqk",
          "category": 0,
          "fls_section": "6.-2.4",
          "fls_title": "Diverging Expressions",
          "score": 0.697,
          "reason": "Similarity due to 'evaluation order' term but FLS discusses control flow divergence (break/return/panic), not C-style unspecified operand evaluation order."
        },
        {
          "fls_id": "fls_5cm4gkt55hjh",
          "category": 0,
          "fls_section": "6.-2.16",
          "fls_title": "Dereference Expression",
          "score": 0.641,
          "reason": "Matched on 'expression' and 'evaluation' terms. This section defines dereference semantics, not evaluation order between operands."
        },
        {
          "fls_id": "fls_290jmzfh7x4e",
          "category": 0,
          "fls_section": "6.-2.28",
          "fls_title": "Compound Assignment Expressions",
          "score": 0.631,
          "reason": "Matched on 'evaluation' and 'operand' terms. Rust compound assignments have defined order (left then right), unlike C's unspecified order."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "misra_rust_comment": "order of evaluation is strict in Rust",
      "confidence": "high",
      "notes": "Rust has defined left-to-right evaluation order for all expressions (e.g., FLS Arithmetic Expressions: 'The left operand is evaluated. The right operand is evaluated.'). C allows unspecified evaluation order leading to undefined behavior. The MISRA concern does not apply to Rust."
    },
    {
      "guideline_id": "Rule 13.3",
      "guideline_title": "A full expression containing an increment (++) or decrement (--) operator should have no other potential side effects other than that caused by the increment or decrement operator C90",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_1k9mkv7rbezi",
          "category": 0,
          "fls_section": "6.11",
          "fls_title": "Arithmetic Expressions",
          "score": 0.682,
          "reason": "Matched on 'operator' and 'expression' terms. Rust arithmetic uses +, -, *, / operators but has no ++ or -- operators."
        },
        {
          "fls_id": "fls_290jmzfh7x4e",
          "category": 0,
          "fls_section": "6.-2.28",
          "fls_title": "Compound Assignment Expressions",
          "score": 0.545,
          "reason": "Rust uses += and -= for increment/decrement but these are statements, not expressions that return values like C's ++ and --."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust does not have ++ or -- operators. Increment/decrement is done via compound assignment (x += 1) which returns unit type, not the modified value. The MISRA concern about side effects from these operators does not apply."
    },
    {
      "guideline_id": "Rule 13.4",
      "guideline_title": "The result of an assignment operator should not be used C90",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_y4by2i8dl05o",
          "category": 0,
          "fls_section": "6.-2.25",
          "fls_title": "Assignment Expressions",
          "score": 0.643,
          "reason": "This section confirms rule is not applicable: per fls_qengy157fa4a 'The type of an assignment expression is the unit type' and fls_bwwtgqprbxrm 'The value of an assignment expression is the unit value.' Unlike C where a=5 returns 5, Rust assignment returns ()."
        },
        {
          "fls_id": "fls_290jmzfh7x4e",
          "category": 0,
          "fls_section": "6.-2.28",
          "fls_title": "Compound Assignment Expressions",
          "score": 0.671,
          "reason": "Matched on 'assignment operator' terms. Compound assignments (+=, -=) also return unit type in Rust, so their result cannot be used."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "In C, 'a = 5' returns 5, enabling problematic patterns like 'a = b = c = 0' or 'if (a = b)'. In Rust, assignment expressions return the unit type () per FLS fls_qengy157fa4a, so the result cannot be used. The MISRA concern is structurally prevented."
    },
    {
      "guideline_id": "Rule 13.5",
      "guideline_title": "The right hand operand of a logical && or || operator shall not contain persistent side effects",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_lstusiu2c8lu",
          "fls_title": "Lazy Boolean Expressions",
          "category": 0,
          "score": 0.63,
          "reason": "FLS section documenting short-circuit (lazy) boolean evaluation semantics. Directly addresses MISRA's concern by clearly specifying when right operand is/isn't evaluated."
        },
        {
          "fls_id": "fls_gpbvus89iy4c",
          "fls_title": "Lazy Boolean Expressions",
          "category": -2,
          "score": 0.75,
          "reason": "FLS: 'A lazy boolean expression is an expression that performs short circuit Boolean arithmetic.' Explicitly names the behavior."
        },
        {
          "fls_id": "fls_tmfmu3syxp2q",
          "fls_title": "Lazy Boolean Expressions",
          "category": -3,
          "score": 0.7,
          "reason": "FLS: 'If the left operand evaluated to true, then the right operand is evaluated...' (for && - documents conditional evaluation)."
        },
        {
          "fls_id": "fls_yg1348rlziw3",
          "fls_title": "Lazy Boolean Expressions",
          "category": -3,
          "score": 0.7,
          "reason": "FLS: 'If the left operand evaluated to false, then the right operand is evaluated...' (for || - documents conditional evaluation)."
        },
        {
          "fls_id": "fls_dltmd8e8c5ia",
          "fls_title": "Drop Scopes",
          "category": -2,
          "score": 0.61,
          "reason": "FLS: 'The drop scope of the right operand of a lazy boolean expression.' Side effects (drops) of right operand are scoped to conditional execution."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "recommended",
      "confidence": "high",
      "notes": "FLS explicitly documents short-circuit evaluation semantics. While Rust has the same behavior as C, the FLS makes it clear when right operands are evaluated. MISRA's concern about hidden side effects applies - this is a coding style guideline for Rust as well.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 13.6",
      "guideline_title": "The operand of the sizeof operator shall not contain any expression which has potential side effects C99",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_xinykul167l",
          "category": 0,
          "fls_section": "6.-2.31",
          "fls_title": "Array Expressions",
          "score": 0.75,
          "reason": "Matched on 'size operand' term but this refers to array size [T; N], not C's sizeof operator. Rust's std::mem::size_of::<T>() takes a type parameter, not an expression."
        },
        {
          "fls_id": "fls_g1z6bpyjqxkz",
          "category": 0,
          "fls_section": "4.-2.26",
          "fls_title": "Type Layout",
          "score": 0.593,
          "reason": "Describes type size/alignment concepts but Rust has no sizeof operator that takes expressions. size_of::<T>() is a generic function taking a type."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "misra_rust_comment": "this is not an expression operator in Rust",
      "confidence": "high",
      "notes": "Rust has no sizeof operator. Size is obtained via std::mem::size_of::<T>() which takes a type parameter, not an expression. You cannot write size_of(x + y) in Rust, eliminating the MISRA concern about unevaluated side effects in sizeof operands."
    },
    {
      "guideline_id": "Rule 14.1",
      "guideline_title": "A loop counter shall not have essentially floating type",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "accepted_matches": [
        {
          "fls_id": "fls_onfyolkcbeh3",
          "fls_title": "For Loops",
          "category": 0,
          "score": 0.57,
          "reason": "FLS: For loops use iterators (IntoIterator trait). Standard range iterators (0..n) produce integers, not floats. No floating-point counter by design."
        },
        {
          "fls_id": "fls_fkgbin6ydkm4",
          "fls_title": "For Loops",
          "category": -2,
          "score": 0.48,
          "reason": "FLS: 'The type of a subject expression shall implement the core::iter::IntoIterator trait.' Range<f32/f64> does not implement Iterator in std."
        },
        {
          "fls_id": "fls_5jjm1kt43axd",
          "fls_title": "While Loops",
          "category": 0,
          "score": 0.45,
          "reason": "FLS: While loops have iteration expressions of type bool. No inherent counter - any counter must be manually managed."
        },
        {
          "fls_id": "fls_d7ofrq3777kq",
          "fls_title": "While Loops",
          "category": -2,
          "score": 0.61,
          "reason": "FLS: 'The type of an iteration expression shall be type bool.' While loop condition is boolean, not a counter comparison."
        },
        {
          "fls_id": "fls_b4xporvr64s",
          "fls_title": "Floating Point Types",
          "category": 0,
          "score": 0.64,
          "reason": "FLS documents floating-point types and their properties. Understanding float behavior is relevant to why this guideline matters."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "applies to while loops only",
      "confidence": "high",
      "notes": "Rust's loop design differs from C. For loops use iterators (std Range types are integer-only). While loops have bool conditions. Floating-point counters require explicit manual management, making the problematic pattern less common and more visible when used.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 14.2",
      "guideline_title": "A for loop shall be well-formed",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [
        {
          "fls_id": "fls_onfyolkcbeh3",
          "category": 0,
          "fls_section": "6.-2.40",
          "fls_title": "For Loops",
          "score": 0.753,
          "reason": "Matched on 'for loop' term but Rust's for loop is fundamentally different from C's. Per FLS: 'A for loop expression is a loop expression that continues to evaluate its loop body as long as its subject expression yields a value.' Rust for is 'for pattern in iterator', not C's 'for(init; cond; update)'."
        },
        {
          "fls_id": "fls_rr908hgunja7",
          "category": 0,
          "fls_section": "6.-2.39",
          "fls_title": "Loop Expressions",
          "score": 0.651,
          "reason": "General loop semantics section. Rust loops are iterator-based or infinite (loop {}), not the 3-part C for loop that MISRA constrains."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "MISRA's 'well-formed for loop' constrains C's 3-part for(init; cond; update) construct to prevent misuse. Rust's for loop is 'for pattern in iterator' per FLS fls_onfyolkcbeh3, based on IntoIterator trait. There is no separate init/condition/update to misuse. The C-specific concern does not apply."
    },
    {
      "guideline_id": "Rule 14.3",
      "guideline_title": "Controlling expressions shall not be invariant",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_zJOAmSr3Dbqk",
          "fls_title": "Diverging Expressions",
          "category": 0,
          "score": 0.61,
          "reason": "FLS documents diverging expressions and the never type. Invariant controlling expressions that diverge are explicitly modeled."
        },
        {
          "fls_id": "fls_4u0v5uy95pyf",
          "fls_title": "Never Type",
          "category": -2,
          "score": 0.63,
          "reason": "FLS: 'The never type is a type that represents the result of a computation that never completes.' Used to model unreachable code paths."
        },
        {
          "fls_id": "fls_mkut7gut49gi",
          "fls_title": "If Expressions",
          "category": 0,
          "score": 0.62,
          "reason": "FLS documents if expression evaluation. While it doesn't forbid invariant conditions, the evaluation semantics are clear."
        },
        {
          "fls_id": "fls_5jjm1kt43axd",
          "fls_title": "While Loops",
          "category": 0,
          "score": 0.69,
          "reason": "FLS documents while loop semantics. While invariant conditions are allowed, they result in infinite loops (loop {}) or no iterations."
        },
        {
          "fls_id": "fls_66m4rnbssgig",
          "fls_title": "Constant Expressions",
          "category": 0,
          "score": 0.62,
          "reason": "FLS: Constant expressions are evaluated at compile time. If a controlling expression is a constant, the compiler knows its value."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "Rust does not prohibit invariant controlling expressions at the language level, but rustc provides warnings via lints (unreachable_code, clippy). The FLS documents how such expressions are evaluated. This MISRA rule remains relevant as a coding guideline for Rust.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 14.4",
      "guideline_title": "The controlling expression of an if statement and the controlling expression of an iteration-statement shall have essentially Boolean type",
      "guideline_type": "rule",
      "applicability_all_rust": "rust_prevents",
      "applicability_safe_rust": "rust_prevents",
      "accepted_matches": [
        {
          "fls_id": "fls_r7gzxo16esri",
          "fls_title": "If expression requires bool",
          "category": -2,
          "score": 0.59,
          "reason": "FLS: The type of the subject expression of an if expression shall be type bool"
        },
        {
          "fls_id": "fls_d7ofrq3777kq",
          "fls_title": "While loop requires bool",
          "category": -2,
          "score": 0.66,
          "reason": "FLS: The type of an iteration expression shall be type bool"
        },
        {
          "fls_id": "fls_tiqp1gxf116z",
          "fls_title": "Bool Type",
          "category": 0,
          "score": 0.61,
          "reason": "FLS Bool Type defines the boolean type with only true/false values"
        },
        {
          "fls_id": "fls_mkut7gut49gi",
          "fls_title": "If Expressions",
          "category": 0,
          "score": 0.56,
          "reason": "FLS If Expressions section defines control flow with boolean subject expression"
        }
      ],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "implicit",
      "misra_rust_comment": "enforced by rustc",
      "confidence": "high",
      "notes": "MISRA concern is about non-boolean expressions in control flow (e.g., if(1), if(ptr)). Rust ENFORCES this at the language level: (1) FLS requires if expression subject to be type bool, (2) FLS requires while loop iteration expression to be type bool. There are NO implicit conversions to bool in Rust. This rule is fully addressed by Rust's type system.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 15.1",
      "guideline_title": "The goto statement should not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no goto statement. Control flow is managed through structured constructs (loop, while, for, if, match) and labeled breaks/continues."
    },
    {
      "guideline_id": "Rule 15.2",
      "guideline_title": "The goto statement shall jump to a label declared later in the same function",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no goto statement. Labeled breaks/continues only jump to enclosing loops, never forward to arbitrary labels."
    },
    {
      "guideline_id": "Rule 15.3",
      "guideline_title": "Any label referenced by a goto statement shall be declared in the same block, or in any block enclosing the goto statement",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no goto statement. Loop labels for break/continue are scoped to the labeled loop expression.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 15.4",
      "guideline_title": "There should be no more than one break or goto statement used to terminate any iteration statement",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_jr4tpuyksr75",
          "category": 0,
          "fls_section": "6.15",
          "fls_title": "Break Expressions",
          "score": 0.665,
          "reason": "Defines break expression semantics. Rust allows labeled breaks for loop control, making multi-level breaks explicit and traceable."
        },
        {
          "fls_id": "fls_sjwrlwvpulp",
          "category": 0,
          "fls_section": "6.16",
          "fls_title": "Continue Expressions",
          "score": 0.55,
          "reason": "Defines continue expression semantics. Like break, supports labels for multi-level continues."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "recommended",
      "confidence": "high",
      "notes": "MISRA limits break/goto to improve control flow clarity. Rust has no goto statement. Break and continue support labels for multi-level control flow (break 'label), making intent explicit. This is a stylistic guideline - Rust's labeled breaks are more structured than C's goto.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 15.5",
      "guideline_title": "A function should have a single point of exit at the end",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_8l74abhlxzdl",
          "fls_title": "Return Expressions",
          "category": 0,
          "score": 0.59,
          "reason": "FLS documents return expressions and how they transfer control flow. Multiple return points are allowed."
        },
        {
          "fls_id": "fls_u7jk4j8gkho",
          "fls_title": "Return Expressions",
          "category": -2,
          "score": 0.73,
          "reason": "FLS: 'A return expression is an expression that optionally yields a value and causes control flow to return to the end of the enclosing control flow boundary.'"
        },
        {
          "fls_id": "fls_7Ck4LMQMeQCv",
          "fls_title": "Return Expressions",
          "category": -2,
          "score": 0.65,
          "reason": "FLS: 'The type of a return expression is the never type.' Return expressions diverge from normal control flow."
        },
        {
          "fls_id": "fls_5v3j5ghhw8j8",
          "fls_title": "Return Expressions",
          "category": -2,
          "score": 0.59,
          "reason": "FLS: 'A return expression shall appear within a control flow boundary.' Defines where returns can appear."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "disapplied",
      "misra_rust_comment": "no longer endorsed by MISRA",
      "confidence": "high",
      "notes": "Rust allows multiple return points via return expressions, early returns with ?, and implicit final expression returns. MISRA's single-exit guideline is a style recommendation that can be applied to Rust but is not enforced by the language. Many Rust idioms encourage early returns for error handling.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 15.6",
      "guideline_title": "The body of an iteration-statement or a selection-statement shall be a compound-statement",
      "guideline_type": "rule",
      "applicability_all_rust": "rust_prevents",
      "applicability_safe_rust": "rust_prevents",
      "accepted_matches": [],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust enforces this by design. All if/loop/while/for/match constructs require block expressions as their body - single statements are not allowed. The \"dangling else\" ambiguity is impossible.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 15.7",
      "guideline_title": "All if \u2026 else if constructs shall be terminated with an else statement",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_mkut7gut49gi",
          "category": 0,
          "fls_section": "6.7",
          "fls_title": "If Expressions",
          "score": 0.653,
          "reason": "Defines if/else expression semantics. Rust if is an expression, which naturally encourages exhaustive handling when used for values."
        },
        {
          "fls_id": "fls_e5td0fa92fay",
          "category": 0,
          "fls_section": "6.6",
          "fls_title": "Match Expressions",
          "score": 0.55,
          "reason": "Match expressions require exhaustive pattern coverage, providing a stronger alternative to if-else chains."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "advisory",
      "confidence": "high",
      "notes": "MISRA requires else clause for defensive programming. Rust's if is an expression - when used for its value, both branches must return compatible types (implicit exhaustiveness). For statement-style if, this is a stylistic recommendation. Match expressions provide compiler-enforced exhaustiveness as an alternative to if-else chains.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 16.1",
      "guideline_title": "All switch statements shall be well-formed",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no switch statement. Match expressions have stricter, well-defined semantics: exhaustive patterns required, no fall-through, each arm is an expression.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 16.2",
      "guideline_title": "A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no switch or case labels. Match arm patterns are syntactically bound to their match expression - they cannot appear elsewhere.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 16.3",
      "guideline_title": "Every switch-clause shall be appropriately terminated",
      "guideline_type": "rule",
      "applicability_all_rust": "rust_prevents",
      "applicability_safe_rust": "rust_prevents",
      "accepted_matches": [],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust match arms have no fall-through semantics. Each arm is an expression that evaluates to a value - there is no need for break statements and no accidental fall-through.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 16.4",
      "guideline_title": "Every switch statement shall have a default label",
      "guideline_type": "rule",
      "applicability_all_rust": "rust_prevents",
      "applicability_safe_rust": "rust_prevents",
      "misra_rust_category": "n_a",
      "misra_rust_comment": "a corresponding match expression must be complete",
      "confidence": "high",
      "notes": "Rust match expressions must be exhaustive - the compiler enforces that all possible values are covered. A wildcard pattern (_) serves as the equivalent of default when needed.",
      "accepted_matches": [],
      "rejected_matches": [],
      "fls_rationale_type": "rust_prevents"
    },
    {
      "guideline_id": "Rule 16.5",
      "guideline_title": "A default label shall appear as either the first or the last switch label of a switch statement",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "n_a",
      "misra_rust_comment": "irrefutable pattern causes a subsequent refutable one to be unreachable",
      "confidence": "high",
      "notes": "Rust has no default label. Wildcard patterns (_) in match expressions are ordered by specificity, not position, and the compiler checks for unreachable patterns.",
      "accepted_matches": [],
      "rejected_matches": [],
      "fls_rationale_type": "no_equivalent"
    },
    {
      "guideline_id": "Rule 16.6",
      "guideline_title": "Every switch statement shall have at least two switch-clauses",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust allows single-arm match expressions, though if-let or let-else are often more idiomatic for single-pattern matching.",
      "accepted_matches": [],
      "rejected_matches": [],
      "fls_rationale_type": "no_equivalent"
    },
    {
      "guideline_id": "Rule 16.7",
      "guideline_title": "A switch-expression shall not have essentially Boolean type",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no switch statement. Match expressions on bool are allowed but using if/else is more idiomatic for boolean conditions.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 17.1",
      "guideline_title": "The standard header file <stdarg.h> shall not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no stdarg.h equivalent. Variadic functions are only available in extern \"C\" FFI declarations. Safe Rust functions cannot be variadic.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 17.2",
      "guideline_title": "Functions shall not call themselves, either directly or indirectly",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "MISRA bans recursion for stack predictability. Rust has no special recursion restrictions - same as C. The FLS defines call expressions and recursion_limit (for macros). Rust idiomatically prefers iteration with iterators. Static analysis tools can detect recursion.",
      "accepted_matches": [
        {
          "fls_id": "fls_3gapgqys3ceb",
          "fls_title": "Recursive Types",
          "category": 0,
          "score": 0.57,
          "reason": "FLS defines recursive types and their constraints - related concept"
        },
        {
          "fls_id": "fls_u2hzlzpzh7yy",
          "fls_title": "Attribute recursion_limit",
          "category": 0,
          "score": 0.46,
          "reason": "FLS recursion_limit attribute controls macro/deref recursion depth"
        },
        {
          "fls_id": "fls_xa4nbfas01cj",
          "fls_title": "Call Expressions",
          "category": 0,
          "score": 0.49,
          "reason": "FLS defines function call semantics including self-referential calls"
        },
        {
          "fls_id": "fls_sf4qnd43z2wc",
          "fls_title": "Infinite Loops",
          "category": 0,
          "score": 0.51,
          "reason": "FLS defines iteration as alternative to recursion for repeated execution"
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "direct_mapping"
    },
    {
      "guideline_id": "Rule 17.3",
      "guideline_title": "A function shall not be declared implicitly",
      "guideline_type": "rule",
      "applicability_all_rust": "rust_prevents",
      "applicability_safe_rust": "rust_prevents",
      "accepted_matches": [],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no implicit function declarations. All functions must be explicitly declared before use - the compiler enforces this strictly.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 17.4",
      "guideline_title": "All exit paths from a function with non-void return type shall have an explicit return statement with an expression",
      "guideline_type": "rule",
      "applicability_all_rust": "rust_prevents",
      "applicability_safe_rust": "rust_prevents",
      "accepted_matches": [],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "misra_rust_comment": "the return keyword is not needed to return a value in Rust, only to exit",
      "confidence": "high",
      "notes": "Rust enforces this at compile time. All code paths in a non-unit-returning function must produce a value of the correct type. The last expression in a block is the return value.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 17.5",
      "guideline_title": "The function argument corresponding to a parameter declared to have an array type shall have an appropriate number of elements",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "C arrays decay to pointers, losing size info. Rust arrays [T; N] carry size in the type. Slices &[T] carry runtime length. This C problem does not exist in Rust.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 17.7",
      "guideline_title": "The value returned by a function having non-void return type shall be used",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_xa4nbfas01cj",
          "fls_title": "Call Expressions",
          "category": 0,
          "score": 0.46,
          "reason": "FLS documents call expressions and their result types. Return values are part of the expression's type."
        },
        {
          "fls_id": "fls_bu6i3mcvnbin",
          "fls_title": "Call Expressions",
          "category": -2,
          "score": 0.65,
          "reason": "FLS: 'The type of a call expression is the return type of the invoked function...' Establishes that functions produce typed values."
        },
        {
          "fls_id": "fls_8l74abhlxzdl",
          "fls_title": "Return Expressions",
          "category": 0,
          "score": 0.61,
          "reason": "FLS documents return expressions. Rust requires explicit handling of Result/Option types via ? or match."
        },
        {
          "fls_id": "fls_EqJb3Jl3vK8K",
          "fls_title": "Functions",
          "category": -2,
          "score": 0.77,
          "reason": "FLS defines function return types. Combined with #[must_use] attribute, Rust can enforce this at compile time."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "Rust's #[must_use] attribute (not in FLS core but part of std) directly addresses this. Result and Option types require explicit handling. The compiler warns on unused function results when #[must_use] is applied. This is a key Rust idiom for error handling.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 17.8",
      "guideline_title": "A function parameter should not be modified",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_uwuthzfgslif",
          "fls_title": "Functions",
          "category": -2,
          "score": 0.54,
          "reason": "FLS: 'A function parameter is a construct that yields a set of bindings that bind matched input values to names.' Parameters are bindings, mutable by default only if declared mut."
        },
        {
          "fls_id": "fls_t9mk8kasobea",
          "fls_title": "Binding Scopes",
          "category": -2,
          "score": 0.56,
          "reason": "FLS: 'The binding of a function parameter is in scope within the related function body.' Parameters are local bindings."
        },
        {
          "fls_id": "fls_qssijtofa9i8",
          "fls_title": "Binding Modes",
          "category": 0,
          "score": 0.5,
          "reason": "FLS documents binding modes. Parameters without mut are immutable bindings - modification is a compile error."
        },
        {
          "fls_id": "fls_77scxuomlbgs",
          "fls_title": "Passing Conventions",
          "category": 0,
          "score": 0.53,
          "reason": "FLS: Parameters are passed by move or reference. The original value's mutability is separate from parameter mutability."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "disapplied",
      "misra_rust_comment": "this cannot be done accidentally without declaring parameters `mut`",
      "confidence": "high",
      "notes": "In Rust, function parameters are immutable bindings by default. Explicit 'mut' is required to modify a parameter. This makes parameter modification visible in the signature (fn foo(mut x: i32)). MISRA's concern is partially addressed by this explicitness.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 17.9",
      "guideline_title": "A function declared with a _Noreturn function specifier shall not return to its caller C11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_98lnexk53ru4",
          "fls_title": "Never Type",
          "category": 0,
          "score": 0.56,
          "reason": "FLS: The never type (!) represents computations that never complete. Equivalent to C11's _Noreturn."
        },
        {
          "fls_id": "fls_4u0v5uy95pyf",
          "fls_title": "Never Type",
          "category": -2,
          "score": 0.54,
          "reason": "FLS: 'The never type is a type that represents the result of a computation that never completes.' Direct equivalent to _Noreturn semantics."
        },
        {
          "fls_id": "fls_zJOAmSr3Dbqk",
          "fls_title": "Diverging Expressions",
          "category": 0,
          "score": 0.51,
          "reason": "FLS documents diverging expressions. Functions returning ! must diverge."
        },
        {
          "fls_id": "fls_4wDpAHhnWZAB",
          "fls_title": "Diverging Expressions",
          "category": -2,
          "score": 0.6,
          "reason": "FLS: 'Call expressions and method call expressions if the return type of the call operand is the never type.' Establishes divergence requirements."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "misra_rust_comment": "this is expressed with the `!` (Never) type, and enforced by rustc",
      "confidence": "high",
      "notes": "Rust's never type (!) directly maps to C11's _Noreturn. A function declared as fn foo() -> ! must diverge (never return). The compiler enforces this - attempting to return from such a function is a compile error.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 17.10",
      "guideline_title": "A function declared with a _Noreturn function specifier shall have void return type",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust uses the never type (!) for diverging functions. A function returning ! can be assigned to any type variable since it never actually returns. Different design than C _Noreturn.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 17.11",
      "guideline_title": "A function that never returns should be declared with a _Noreturn function specifier",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "accepted_matches": [
        {
          "fls_id": "fls_98lnexk53ru4",
          "fls_title": "Never Type",
          "category": 0,
          "score": 0.56,
          "reason": "FLS: The never type (!) is Rust's equivalent to _Noreturn. Functions that never return should declare -> ! return type."
        },
        {
          "fls_id": "fls_4u0v5uy95pyf",
          "fls_title": "Never Type",
          "category": -2,
          "score": 0.54,
          "reason": "FLS: 'The never type is a type that represents the result of a computation that never completes.' Used to declare non-returning functions."
        },
        {
          "fls_id": "fls_zJOAmSr3Dbqk",
          "fls_title": "Diverging Expressions",
          "category": 0,
          "score": 0.51,
          "reason": "FLS: Diverging expressions have the never type. Functions like panic!() and loop {} diverge."
        },
        {
          "fls_id": "fls_rpedapxnv8w3",
          "fls_title": "Infinite Loops",
          "category": -2,
          "score": 0.52,
          "reason": "FLS: 'If the infinite loop expression does not contain a break expression, then the type is the never type.' Example of diverging construct."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "advisory",
      "misra_rust_comment": "a non-returning function can be declared to return a value type",
      "confidence": "high",
      "notes": "Rust's -> ! return type directly addresses this. Functions that never return (panic, abort, infinite loops) should be declared with -> ! to communicate intent and enable compiler optimizations. This is idiomatic Rust.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 17.12",
      "guideline_title": "A function identifier should only be used with either a preceding &, or with a parenthesized parameter list",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust function items have unique zero-sized types. They coerce to function pointers when needed. There is no ambiguity between function and function-pointer that this C rule addresses.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 17.13",
      "guideline_title": "A function type shall not be type qualified",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "C type qualifiers (const, volatile) on function types are undefined behavior. Rust has no type qualifiers on function types - this concept does not exist.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 18.1",
      "guideline_title": "A pointer resulting from arithmetic on a pointer operand shall address an element of the same array as that pointer operand C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_sxcr4aa098i6",
          "fls_title": "Indexing Expressions",
          "category": 0,
          "score": 0.46,
          "reason": "FLS: Indexing via [] is bounds-checked at runtime for slices and arrays. Panics on out-of-bounds access."
        },
        {
          "fls_id": "fls_9wgldua1u8yt",
          "fls_title": "Dereference Expression",
          "category": -4,
          "score": 0.64,
          "reason": "FLS UB: 'It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.' Raw pointer arithmetic is unsafe."
        },
        {
          "fls_id": "fls_ppd1xwve3tr7",
          "fls_title": "Raw Pointer Types",
          "category": 0,
          "score": 0.63,
          "reason": "FLS: Raw pointer types. Pointer arithmetic is not directly supported - requires unsafe offset() methods."
        },
        {
          "fls_id": "fls_vpbikb73dw4k",
          "fls_title": "Slice Types",
          "category": 0,
          "score": 0.48,
          "reason": "FLS: Slices carry length information. Safe Rust indexing is bounds-checked via the Index trait."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "by unsafe API",
      "confidence": "high",
      "notes": "In safe Rust, array/slice indexing is bounds-checked at runtime. Raw pointer arithmetic requires unsafe and is not a built-in operator. Rust's design strongly discourages pointer arithmetic in favor of slice iterators and indexing, which are safe by default.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 18.2",
      "guideline_title": "Subtraction between pointers shall only be applied to pointers that address elements of the same array C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_ppd1xwve3tr7",
          "fls_title": "Raw Pointer Types",
          "category": 0,
          "score": 0.63,
          "reason": "FLS: Raw pointers. Pointer subtraction requires unsafe code via offset_from() which has documented preconditions."
        },
        {
          "fls_id": "fls_9wgldua1u8yt",
          "fls_title": "Dereference Expression",
          "category": -4,
          "score": 0.64,
          "reason": "FLS UB: Dereferencing dangling/unaligned raw pointers is UB. Same underlying concerns apply to pointer subtraction."
        },
        {
          "fls_id": "fls_vpbikb73dw4k",
          "fls_title": "Slice Types",
          "category": 0,
          "score": 0.48,
          "reason": "FLS: Slices carry length. Subslice operations are bounds-checked in safe Rust."
        },
        {
          "fls_id": "fls_sxcr4aa098i6",
          "fls_title": "Indexing Expressions",
          "category": 0,
          "score": 0.46,
          "reason": "FLS: Safe indexing uses Index trait. Rust encourages iterators over pointer arithmetic."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "by unsafe API",
      "confidence": "high",
      "notes": "Rust does not have a built-in pointer subtraction operator. The offset_from() method on raw pointers requires unsafe and documents that pointers must be from the same allocation. Safe Rust uses slice iterators and lengths instead of pointer arithmetic.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 18.3",
      "guideline_title": "The relational operators >, >=, < and <= shall not be applied to expressions of pointer type except where they point into the same object C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_hrum767l6dte",
          "fls_title": "Raw Pointer Types",
          "category": -2,
          "score": 0.49,
          "reason": "FLS: 'Comparing two values of raw pointer types compares the addresses of the values.' Raw pointer comparison is allowed but semantics are limited."
        },
        {
          "fls_id": "fls_ppd1xwve3tr7",
          "fls_title": "Raw Pointer Types",
          "category": 0,
          "score": 0.63,
          "reason": "FLS: Raw pointer comparison. Relational comparisons (<, >) are defined but produce unspecified results for pointers to different objects."
        },
        {
          "fls_id": "fls_k6ues2936pjq",
          "fls_title": "Raw Pointer Types",
          "category": -2,
          "score": 0.45,
          "reason": "FLS: 'Comparing a value of a raw pointer type to a value of a dynamically sized type compares the data being pointed to.' DST comparison semantics."
        },
        {
          "fls_id": "fls_9wgldua1u8yt",
          "fls_title": "Dereference Expression",
          "category": -4,
          "score": 0.64,
          "reason": "FLS: UB rules for raw pointers. Comparing invalid pointers is problematic."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "Rust allows raw pointer comparison via <, >, etc., but the result is unspecified for pointers to different objects. Safe Rust references cannot be compared relationally across different allocations. MISRA's concern is partially addressed by Rust's preference for iterators over pointer arithmetic.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 18.4",
      "guideline_title": "The +, -, += and -= operators should not be applied to an expression of pointer type",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_sxcr4aa098i6",
          "fls_title": "Indexing Expressions",
          "category": 0,
          "score": 0.46,
          "reason": "FLS: Array indexing via [] is the preferred method over pointer arithmetic. Bounds-checked in safe Rust."
        },
        {
          "fls_id": "fls_ppd1xwve3tr7",
          "fls_title": "Raw Pointer Types",
          "category": 0,
          "score": 0.63,
          "reason": "FLS: Raw pointer types. +/- operators are not defined for raw pointers - must use offset() methods which require unsafe."
        },
        {
          "fls_id": "fls_xinykul167l",
          "fls_title": "Array Expressions",
          "category": 0,
          "score": 0.69,
          "reason": "FLS: Array expressions and iteration. Rust encourages iterators over index arithmetic."
        },
        {
          "fls_id": "fls_vpbikb73dw4k",
          "fls_title": "Slice Types",
          "category": 0,
          "score": 0.48,
          "reason": "FLS: Slices are the idiomatic way to work with contiguous sequences. Iteration is preferred over indexing."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "advisory",
      "misra_rust_comment": "applies to use of the unsafe API",
      "confidence": "high",
      "notes": "Rust does not have built-in +/- operators for raw pointers. Array subscript (arr[i]) is the standard way to access elements. For raw pointers, offset() requires unsafe. This aligns with MISRA's preference - Rust's design makes the safer pattern (indexing) the default.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 18.5",
      "guideline_title": "Declarations should contain no more than two levels of pointer nesting",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_3i4ou0dq64ny",
          "fls_title": "Indirection Types",
          "category": 0,
          "score": 0.53,
          "reason": "FLS: Documents indirection types (references and raw pointers). Multiple levels of indirection are allowed but not encouraged."
        },
        {
          "fls_id": "fls_ppd1xwve3tr7",
          "fls_title": "Raw Pointer Types",
          "category": 0,
          "score": 0.41,
          "reason": "FLS: Raw pointer types. *const *const T is valid syntax for nested pointer types."
        },
        {
          "fls_id": "fls_v5x85lt5ulva",
          "fls_title": "References",
          "category": 0,
          "score": 0.4,
          "reason": "FLS: Reference types. &&T is valid but unusual. Rust's ownership model often eliminates need for deep nesting."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "recommended",
      "confidence": "high",
      "notes": "Rust allows multiple levels of pointer/reference nesting but the ownership system often provides alternatives. Deep nesting is syntactically obvious and uncommon in idiomatic Rust. This MISRA guideline remains a valid style recommendation for Rust code.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 18.6",
      "guideline_title": "The address of an object with automatic or thread-local storage shall not be copied to another object that persists after the first object has ceased to exist C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_a14slch83hzn",
          "fls_title": "Borrowing",
          "category": 0,
          "score": 0.73,
          "reason": "FLS: Borrowing system prevents dangling references. Borrows have lifetimes that must not outlive the borrowed value."
        },
        {
          "fls_id": "fls_v5x85lt5ulva",
          "fls_title": "References",
          "category": 0,
          "score": 0.74,
          "reason": "FLS: References carry lifetime information. The compiler ensures references don't outlive their referents."
        },
        {
          "fls_id": "fls_w5bjgaov8w60",
          "fls_title": "Borrowing",
          "category": -2,
          "score": 0.62,
          "reason": "FLS: 'A mutable borrow of type &'a mut T is created, where lifetime 'a is replaced by a lifetime variable.' Lifetimes track validity."
        },
        {
          "fls_id": "fls_9wgldua1u8yt",
          "fls_title": "Dereference Expression",
          "category": -4,
          "score": 0.66,
          "reason": "FLS UB: 'It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.' For raw pointers, dangling is UB."
        },
        {
          "fls_id": "fls_eT1hnLOx6vxk",
          "fls_title": "References",
          "category": -4,
          "score": 0.57,
          "reason": "FLS UB: Aliasing mutable references is UB. The borrow checker prevents this in safe code."
        }
      ],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "Rust's borrow checker directly prevents this issue in safe code. References cannot outlive their referents - the compiler tracks lifetimes and rejects code that would create dangling references. This is one of Rust's core safety guarantees.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 18.7",
      "guideline_title": "Flexible array members shall not be declared",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "C99 flexible array members (struct { int n; char data[]; }) have no Rust equivalent. Rust uses Vec<T> or slices for variable-length data, with proper bounds checking.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 18.8",
      "guideline_title": "Variable-length arrays shall not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no VLAs. Array sizes must be compile-time constants. For runtime-sized collections, use Vec<T> which allocates on the heap with proper bounds checking.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 18.9",
      "guideline_title": "An object with temporary lifetime shall not undergo array-to-pointer conversion",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "C array-to-pointer decay does not exist in Rust. Rust arrays [T; N] do not implicitly convert to pointers. Taking a reference to a temporary is controlled by borrowing rules.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 18.10",
      "guideline_title": "Pointers to variably-modified array types shall not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no variably-modified array types (C99/C11 VLA feature). Array sizes are compile-time constants in Rust.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 19.1",
      "guideline_title": "An object shall not be assigned or copied to an overlapping object C90 [Undefined 34, 55], C99 [Undefined 51, 94], C11 [Undefined 54, 100]",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "Safe Rust's borrow checker prevents overlapping mutable references at compile time. FLS 15.3 explicitly states 'no other reference shall refer to a value that overlaps with the referent of the mutable reference'. In unsafe Rust, aliasing mutable references is explicitly UB.",
      "accepted_matches": [
        {
          "fls_id": "fls_v5x85lt5ulva",
          "fls_section": "15.3",
          "fls_title": "References",
          "score": 0.526,
          "reason": "PRIMARY: Per FLS fls_i1ny0k726a4a: 'While a mutable reference is active, no other reference shall refer to a value that overlaps with the referent of the mutable reference.' Also defines UB: 'It is undefined behavior to access a value through aliasing mutable references from unsafe context.'",
          "category": -2
        },
        {
          "fls_id": "fls_a14slch83hzn",
          "fls_section": "15.4",
          "fls_title": "Borrowing",
          "score": 0.492,
          "reason": "Per FLS fls_kxws4zmaahj6: 'Borrowing a field of a union type borrows all remaining fields using the same lifetime.' This treats union fields as overlapping memory.",
          "category": -2
        }
      ],
      "rejected_matches": [
        {
          "fls_id": "fls_94a8v54bufn8",
          "fls_section": "7",
          "fls_title": "Values",
          "score": 0.525,
          "reason": "Chapter-level section too broad. Contains value overlap definition but the enforceable rules are in 15.3 References.",
          "category": -2
        },
        {
          "fls_id": "fls_9beohh5475s2",
          "fls_section": "6.5.11.2",
          "fls_title": "Destructuring Assignment",
          "score": 0.519,
          "reason": "About tuple destructuring syntax, not memory overlap safety concerns.",
          "category": -2
        }
      ]
    },
    {
      "guideline_id": "Rule 19.2",
      "guideline_title": "The union keyword should not be used C90 [Undefined 39, 40; Implementation G.3.9(1)] C99 [Unspecified 10; Undefined 61, 62] C11 [Unspecified 11; Undefined 64, 65]",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "advisory",
      "confidence": "high",
      "notes": "Rust unions exist but have strict type restrictions (Copy/ManuallyDrop field types only). Reading any union field requires unsafe context. FLS defines implementation-defined and UB scenarios similar to MISRA's concerns.",
      "accepted_matches": [
        {
          "fls_id": "fls_fmdn7n7s413d",
          "fls_section": "4.5.3",
          "fls_title": "Union Types",
          "score": 0.69,
          "reason": "PRIMARY: Defines union type rules including field type restrictions per FLS fls_ZJG2Q6lJYXhY: 'The type of a union field shall be either: A copy type, or a mutable reference type, or core::mem::ManuallyDrop...'",
          "category": -2
        },
        {
          "fls_id": "fls_cmq8ogs84ivh",
          "fls_section": "4.11.2.3",
          "fls_title": "Union Type Representation",
          "score": 0.691,
          "reason": "Defines union memory layout - size is max of all fields, all fields share common storage. Addresses MISRA's padding/alignment/endianness concerns.",
          "category": -2
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "fls_section": "19",
          "fls_title": "Unsafety",
          "score": 0.0,
          "reason": "MANUAL: Per FLS fls_ucghxcnpaq2t: 'Accessing a field of a union, other than to assign to it' is listed as an unsafe operation requiring unsafe context.",
          "category": -2
        },
        {
          "fls_id": "fls_18k3uajrgq5f",
          "fls_section": "6.13",
          "fls_title": "Field Access Expressions",
          "score": 0.0,
          "reason": "MANUAL: Per FLS fls_kddnnz8uc15b: 'Reading the selected field of a union shall require unsafe context.' This is the enforcement mechanism for MISRA's concern.",
          "category": -2
        }
      ],
      "rejected_matches": [
        {
          "fls_id": "fls_rjxpof29a3nl",
          "fls_section": "4.11.2.2",
          "fls_title": "Struct Type Representation",
          "score": 0.591,
          "reason": "About struct layout, not union - high similarity due to shared 'representation' terminology.",
          "category": -2
        },
        {
          "fls_id": "fls_g1z6bpyjqxkz",
          "fls_section": "4.11.1",
          "fls_title": "Type Layout",
          "score": 0.561,
          "reason": "General layout section. Union-specific content is in child section 4.11.2.3 which is more specific.",
          "category": -2
        },
        {
          "fls_id": "fls_ohhsmifo0urd",
          "fls_section": "4.11.2",
          "fls_title": "Type Representation",
          "score": 0.554,
          "reason": "Parent section. Child 4.11.2.3 (Union Type Representation) is more specific and already accepted.",
          "category": -2
        },
        {
          "fls_id": "fls_wrvjizrqf3po",
          "fls_section": "4.3.2",
          "fls_title": "Char Type",
          "score": 0.509,
          "reason": "About char type, not unions. High score likely due to type representation terminology overlap.",
          "category": -2
        }
      ]
    },
    {
      "guideline_id": "Rule 19.3",
      "guideline_title": "A union member shall not be read unless it has been previously set C99 [Unspecified 10], C11 [Unspecified 11]",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "FLS explicitly defines UB for reading union fields with invalid data (fls_Vani4665hiJY). Reading any union field requires unsafe context. Rust treats union field read-after-different-write as transmute, matching MISRA's type punning concern.",
      "accepted_matches": [
        {
          "fls_id": "fls_fmdn7n7s413d",
          "fls_section": "4.5.3",
          "fls_title": "Union Types",
          "score": 0.662,
          "reason": "PRIMARY: Defines union field type restrictions (Copy/ManuallyDrop) which limit what can be stored and safely reinterpreted.",
          "category": -2
        },
        {
          "fls_id": "fls_18k3uajrgq5f",
          "fls_section": "6.13",
          "fls_title": "Field Access Expressions",
          "score": 0.0,
          "reason": "MANUAL: CRITICAL - Contains the explicit UB definition per FLS fls_Vani4665hiJY: 'It is undefined behavior reading the selected field of a union type when it contains data that is invalid for the selected field's type.' Also defines transmute equivalence for union field access (fls_t6xmsm2nk1bc).",
          "category": -2
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "fls_section": "19",
          "fls_title": "Unsafety",
          "score": 0.524,
          "reason": "Per FLS fls_ucghxcnpaq2t: Union field access (except assignment) is an unsafe operation. This forces explicit acknowledgment of the type punning risk.",
          "category": -2
        },
        {
          "fls_id": "fls_cmq8ogs84ivh",
          "fls_section": "4.11.2.3",
          "fls_title": "Union Type Representation",
          "score": 0.644,
          "reason": "Per FLS: 'All union fields share a common storage.' This is the memory model underlying MISRA's concern about reading unwritten members.",
          "category": -2
        }
      ],
      "rejected_matches": [
        {
          "fls_id": "fls_rjxpof29a3nl",
          "fls_section": "4.11.2.2",
          "fls_title": "Struct Type Representation",
          "score": 0.587,
          "reason": "About struct layout, not union. High score due to shared 'representation' terminology.",
          "category": -2
        },
        {
          "fls_id": "fls_8tsynkj2cufj",
          "fls_section": "6.11",
          "fls_title": "Struct Expressions",
          "score": 0.529,
          "reason": "About struct initialization syntax, not union field access.",
          "category": -2
        },
        {
          "fls_id": "fls_v5x85lt5ulva",
          "fls_section": "15.3",
          "fls_title": "References",
          "score": 0.524,
          "reason": "About reference aliasing rules, not union type punning. More relevant to Rule 19.1.",
          "category": -2
        },
        {
          "fls_id": "fls_77scxuomlbgs",
          "fls_section": "15.5",
          "fls_title": "Passing Conventions",
          "score": 0.524,
          "reason": "About move/copy semantics during value transfer, not union field access.",
          "category": -2
        },
        {
          "fls_id": "fls_g1z6bpyjqxkz",
          "fls_section": "4.11.1",
          "fls_title": "Type Layout",
          "score": 0.541,
          "reason": "General layout section. Child section 4.11.2.3 is more specific for unions.",
          "category": -2
        },
        {
          "fls_id": "fls_ohhsmifo0urd",
          "fls_section": "4.11.2",
          "fls_title": "Type Representation",
          "score": 0.52,
          "reason": "Parent section. Child 4.11.2.3 already accepted and is more specific.",
          "category": -2
        },
        {
          "fls_id": "fls_5cm4gkt55hjh",
          "fls_section": "6.5.2",
          "fls_title": "Dereference Expression",
          "score": 0.516,
          "reason": "About pointer dereferencing, not union field access. Different unsafe operation.",
          "category": -2
        }
      ]
    },
    {
      "guideline_id": "Rule 20.1",
      "guideline_title": "#include directives should only be preceded by preprocessor directives or comments",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "misra_rust_comment": "rules specific to the C preprocessor do not apply to Rust",
      "confidence": "high",
      "notes": "Rust has no #include. The mod/use system handles module imports with well-defined semantics independent of textual position.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 20.2",
      "guideline_title": "The ', \" or \\ characters and the /* or // character sequences shall not occur in a header file name",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no #include or header files. Module paths use :: separators and follow Rust identifier rules.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 20.3",
      "guideline_title": "The #include directive shall be followed by either a <filename> or \"filename\" sequence",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no #include directive. Module inclusion uses mod declarations with strict syntax.",
      "accepted_matches": [],
      "rejected_matches": [],
      "fls_rationale_type": "no_equivalent"
    },
    {
      "guideline_id": "Rule 20.4",
      "guideline_title": "A macro shall not be defined with the same name as a keyword C90",
      "guideline_type": "rule",
      "applicability_all_rust": "partial",
      "applicability_safe_rust": "partial",
      "accepted_matches": [
        {
          "fls_id": "fls_21vnag69kbwe",
          "fls_title": "Identifiers",
          "category": 0,
          "score": 0.67,
          "reason": "FLS identifiers cannot be keywords - macros cannot shadow keywords"
        },
        {
          "fls_id": "fls_xlfo7di0gsqz",
          "fls_title": "Hygiene",
          "category": 0,
          "score": 0.66,
          "reason": "FLS macro hygiene prevents name confusion with language constructs"
        },
        {
          "fls_id": "fls_9kjpxri0axvg",
          "fls_title": "Weak Keywords",
          "category": 0,
          "score": 0.6,
          "reason": "FLS distinguishes strict and weak keywords - strict cannot be used as identifiers"
        },
        {
          "fls_id": "fls_xa7lp0zg1ol2",
          "fls_title": "Declarative Macros",
          "category": 0,
          "score": 0.64,
          "reason": "FLS declarative macros have hygiene preventing keyword collisions"
        }
      ],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "required",
      "misra_rust_comment": "possible with raw identifiers but the compiler prevents visual conflicts",
      "confidence": "high",
      "notes": "MISRA concern is C preprocessor defining over keywords. Rust PREVENTS this: (1) Macro names are identifiers, (2) Keywords cannot be identifiers, (3) Macro hygiene isolates macro-introduced names. The FLS explicitly distinguishes strict keywords (cannot be identifiers) from weak keywords.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 20.5",
      "guideline_title": "#undef should not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no #undef. Rust macros use hygienic scoping and cannot be undefined after declaration.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 20.6",
      "guideline_title": "Tokens that look like a preprocessing directive shall not occur within a macro argument",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust macros operate on token trees, not text. There are no preprocessing directives within macro arguments - the concept does not apply.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 20.7",
      "guideline_title": "Expressions resulting from the expansion of macro parameters shall be appropriately delimited",
      "guideline_type": "rule",
      "applicability_all_rust": "partial",
      "applicability_safe_rust": "partial",
      "accepted_matches": [
        {
          "fls_id": "fls_8nzypdu9j3ge",
          "fls_title": "Metavariables",
          "category": 0,
          "score": 0.62,
          "reason": "FLS metavariables with expr specifier capture complete expressions as AST units"
        },
        {
          "fls_id": "fls_kw25194gpael",
          "fls_title": "Expression Precedence",
          "category": 0,
          "score": 0.65,
          "reason": "FLS defines expression precedence - captured expressions maintain integrity"
        },
        {
          "fls_id": "fls_ym00b6ewf4n3",
          "fls_title": "Macro Transcription",
          "category": 0,
          "score": 0.66,
          "reason": "FLS transcription substitutes matched tokens preserving structure"
        },
        {
          "fls_id": "fls_qpx6lgapce57",
          "fls_title": "Token Matching",
          "category": 0,
          "score": 0.59,
          "reason": "FLS fragment specifier expr captures expression as syntactic unit, not text"
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "advisory",
      "misra_rust_comment": "possible to express with procedural macros only, not macro_rules",
      "confidence": "high",
      "notes": "MISRA concern is C textual substitution causing precedence issues. Rust macros operate on AST tokens, not text. The expr fragment specifier captures a complete expression preserving precedence. No parenthesization needed since substitution is structural, not textual.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 20.8",
      "guideline_title": "The controlling expression of a #if or #elif preprocessing directive shall evaluate to 0 or 1",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust uses cfg attributes and cfg! macro for conditional compilation. These use predicate syntax (cfg(feature = \"x\")), not integer expressions.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 20.9",
      "guideline_title": "All identifiers used in the controlling expression of #if or #elif preprocessing directives shall be defined before evaluation",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust cfg attributes check for presence/absence of configuration options. There is no integer expression evaluation with potentially undefined identifiers.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 20.10",
      "guideline_title": "The # and ## preprocessor operators should not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no # or ## stringizing/token-pasting operators. Rust macros use different mechanisms (stringify!, concat!) that are type-safe.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 20.11",
      "guideline_title": "A macro parameter immediately following a # operator shall not immediately be followed by a ## operator",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no # or ## operators. Macro hygiene and token tree manipulation in Rust avoid these C preprocessor pitfalls.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 20.12",
      "guideline_title": "A macro parameter used as an operand to the # or ## operators, which is itself subject to further macro replacement, shall only be used as an operand to these operators",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no # or ## operators. Rust macro expansion has well-defined ordering without these C preprocessor complexities.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 20.13",
      "guideline_title": "A line whose first token is # shall be a valid preprocessing directive",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no C-style preprocessing directives. # in Rust is used for attributes (#[...]) which have strict syntax requirements enforced by the compiler.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 20.14",
      "guideline_title": "All #else, #elif and #endif preprocessor directives shall reside in the same file as the #if, #ifdef or #ifndef directive to which they are related",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no #if/#else/#endif. The cfg attribute system applies to complete syntactic items and cannot span files.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 20.15",
      "guideline_title": "#define and #undef shall not be used on a reserved identifier or reserved macro name",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "misra_rust_comment": "previously Rule 21.1",
      "confidence": "high",
      "notes": "Rust has no #define/#undef. Rust macros (macro_rules! and proc macros) operate in a hygienic namespace system with different reserved identifier rules."
    },
    {
      "guideline_id": "Rule 21.3",
      "guideline_title": "The memory allocation and deallocation functions of <stdlib.h> shall not be used C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_fs0lcfllamj",
          "category": 0,
          "fls_title": "Attribute global_allocator",
          "score": 0.58,
          "reason": "Per FLS fls_5b8aewlgeon8: 'Attribute global_allocator shall apply to [static]s whose [type]s implement the core::alloc::GlobalAlloc trait.' This is Rust's mechanism for custom memory allocation."
        },
        {
          "fls_id": "fls_9wgldua1u8yt",
          "category": -4,
          "fls_title": "Dereference Expression (UB)",
          "score": 0.63,
          "reason": "Per FLS: 'It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.' This directly addresses MISRA's concern about using freed memory."
        },
        {
          "fls_id": "fls_u2mzjgiwbkz0",
          "category": 0,
          "fls_title": "Destructors",
          "score": 0.72,
          "reason": "Per FLS fls_wzuwapjqtyyy: 'Dropping a value is the act of invoking the destructor of the related type.' Rust's RAII through Drop handles deallocation automatically for safe types."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "MISRA ADD-6 notes this is only accessible through unsafe extern 'C'. In Rust, memory allocation uses Box/Vec with RAII, or the global allocator interface. When calling C's malloc/free via FFI, these sections apply.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 21.4",
      "guideline_title": "The standard header file <setjmp.h> shall not be used C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "setjmp/longjmp have no Rust equivalent. Rust uses Result/Option for error handling and panic for unwinding. This rule applies only when calling C code via FFI that uses setjmp/longjmp.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 21.5",
      "guideline_title": "The standard header file <signal.h> shall not be used C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C signal handling has no Rust equivalent. Rust does not have a standard signal handling mechanism. This rule applies only when calling C code via FFI that uses signal.h.",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "no_equivalent"
    },
    {
      "guideline_id": "Rule 21.6",
      "guideline_title": "The Standard Library input/output functions shall not be used C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_usgd0xlijoxv",
          "category": 0,
          "fls_section": "21.4",
          "fls_title": "ABI",
          "score": 0.65,
          "reason": "C library functions require ABI specification. Standard Library input/output functions only accessible in Rust through unsafe extern 'C' blocks."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_section": "21.1",
          "fls_title": "External Blocks",
          "score": 0.55,
          "reason": "C library function declarations would appear in unsafe external blocks, requiring unsafe context to call."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "MISRA prohibits C stdio functions. In Rust, C stdio is only accessible via unsafe extern 'C'. Rust has std::io for safe I/O. Per ADD-6: 'only accessible through unsafe extern \"C\"'.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 21.7",
      "guideline_title": "The Standard Library functions atof, atoi, atol and atoll of <stdlib.h> shall not be used C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_usgd0xlijoxv",
          "category": 0,
          "fls_section": "21.4",
          "fls_title": "ABI",
          "score": 0.65,
          "reason": "C library functions require ABI specification. atof, atoi, atol, atoll functions only accessible in Rust through unsafe extern 'C' blocks."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_section": "21.1",
          "fls_title": "External Blocks",
          "score": 0.55,
          "reason": "C library function declarations would appear in unsafe external blocks, requiring unsafe context to call."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "MISRA prohibits these due to undefined behavior on invalid input. In Rust, use str::parse() which returns Result for safe error handling. C functions only via unsafe extern 'C'. Per ADD-6: 'only accessible through unsafe extern \"C\"'.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 21.8",
      "guideline_title": "The Standard Library termination functions of <stdlib.h> shall not be used C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_k02nt1m5fq1z",
          "category": 0,
          "fls_title": "Panic",
          "score": 0.55,
          "reason": "Rust's panic!() macro provides controlled abnormal termination with unwinding. Per FLS, a panic causes the current thread to unwind or abort."
        },
        {
          "fls_id": "fls_hi1iz0gbnksi",
          "category": 0,
          "fls_title": "Abort",
          "score": 0.72,
          "reason": "Per FLS fls_9a1izu3omkbn: 'Abort is the immediate termination of a program.' Per FLS fls_wd2q6ft9yzrg: 'Control flow halts the execution of all threads.' This directly corresponds to C's abort() function."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C termination functions (abort, exit, _Exit, quick_exit) map to Rust's abort/panic. Rust uses std::process::abort() and panic!() for abnormal termination.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 21.9",
      "guideline_title": "The Standard Library functions bsearch and qsort of <stdlib.h> shall not be used C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C's bsearch/qsort use function pointers which can be unsafe. Rust provides safe alternatives via slice::binary_search() and slice::sort() which are type-safe and don't require unsafe function pointers.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 21.10",
      "guideline_title": "The Standard Library time and date functions shall not be used C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C time/date functions have no standard Rust equivalent. Rust uses chrono or std::time for time handling which are type-safe. This applies only when using C time functions via FFI.",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "rust_alternative"
    },
    {
      "guideline_id": "Rule 21.11",
      "guideline_title": "The standard header file <tgmath.h> should not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "rejected_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "misra_rust_comment": "no external interface",
      "confidence": "high",
      "notes": "Rust has no <tgmath.h>. Type-generic math in Rust is achieved through traits (e.g., num-traits crate) and generic functions, with compile-time type safety."
    },
    {
      "guideline_id": "Rule 21.12",
      "guideline_title": "The standard header file <fenv.h> shall not be used C99",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C floating-point environment (fenv.h) has no Rust equivalent. Rust does not expose floating-point exception flags or rounding mode control. This applies only when calling C code via FFI.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 21.13",
      "guideline_title": "Any value passed to a function in <ctype.h> shall be representable as an unsigned char or be the value EOF C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C's ctype.h functions accept int but expect unsigned char range. Rust's char methods (is_alphabetic, is_digit, etc.) work on Unicode chars and are type-safe. This applies only when calling C ctype.h via FFI.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 21.14",
      "guideline_title": "The Standard Library function memcmp shall not be used to compare null terminated strings",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C's memcmp can expose padding bytes. Rust's PartialEq/Eq traits provide safe comparisons. For byte-level comparison, Rust slices can be compared directly. This applies only when calling C memcmp via FFI.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 21.15",
      "guideline_title": "The pointer arguments to the Standard Library functions memcpy, memmove and memcmp shall be pointers to qualified or unqualified versions of compatible types",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C's memcpy/memmove/memcmp use void* which loses type information. Rust's slice::copy_from_slice and Clone are type-safe. This applies only when calling C memory functions via FFI.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 21.16",
      "guideline_title": "The pointer arguments to the Standard Library function memcmp shall point to either a pointer type, an essentially signed type, an essentially unsigned type, an essentially Boolean type or an essentially enum type C99",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C's memcmp with pointers to different types is problematic. Rust's comparison traits are type-safe. This applies only when calling C memcmp via FFI.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 21.17",
      "guideline_title": "Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_usgd0xlijoxv",
          "category": 0,
          "fls_section": "21.4",
          "fls_title": "ABI",
          "score": 0.65,
          "reason": "C library functions require ABI specification. string.h buffer overflows only accessible in Rust through unsafe extern 'C' blocks."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_section": "21.1",
          "fls_title": "External Blocks",
          "score": 0.55,
          "reason": "C library function declarations would appear in unsafe external blocks, requiring unsafe context to call."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "MISRA prevents buffer overflows in string functions. Rust's String/&str are safe by design. C string functions only via unsafe extern 'C'. Use std::ffi::CStr/CString for FFI. Per ADD-6: 'only accessible through unsafe extern \"C\"'.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 21.18",
      "guideline_title": "The size_t argument passed to any function in <string.h> shall have an appropriate value C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C's string.h functions with size_t can have buffer overflow issues. Rust slices carry their length and prevent out-of-bounds access. This applies only when calling C string functions via FFI.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 21.19",
      "guideline_title": "The pointers returned by the Standard Library functions localeconv, getenv, setlocale or strerror shall only be used as if they have pointer to const-qualified type C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C's localeconv/getenv/setlocale return pointers that can be invalidated. Rust's std::env functions return owned Strings. This applies only when calling C locale functions via FFI.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 21.20",
      "guideline_title": "The pointer returned by the Standard Library functions asctime, ctime, gmtime, localtime, localeconv, getenv, setlocale or strerror shall not be used following a subsequent call to the same function",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C's strtok uses internal static state which is not thread-safe. Rust has no equivalent; String::split returns an iterator. This applies only when calling C strtok via FFI.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 21.21",
      "guideline_title": "The Standard Library function system of <stdlib.h> shall not be used C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C's system() spawns a shell which is a security risk. Rust's std::process::Command allows explicit command execution without shell. This applies only when calling C system() via FFI.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 21.22",
      "guideline_title": "All operand arguments to any type-generic macros declared in <tgmath.h> shall have an appropriate essential type",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "misra_rust_comment": "no external interface",
      "confidence": "high",
      "notes": "Rust has no <tgmath.h> type-generic macros. Rust generics and traits provide type-safe polymorphism with compile-time checking.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 21.23",
      "guideline_title": "All operand arguments to any multi-argument type-generic macros declared in <tgmath.h> shall have the same standard type",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "misra_rust_comment": "no external interface",
      "confidence": "high",
      "notes": "Rust has no <tgmath.h>. Generic functions in Rust have explicit type constraints that the compiler enforces.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 21.24",
      "guideline_title": "The random number generator functions of <stdlib.h> shall not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C's rand/srand are not cryptographically secure and use global state. Rust's rand crate provides thread-safe, seedable RNGs. This applies only when calling C random functions via FFI.",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "rust_alternative"
    },
    {
      "guideline_id": "Rule 21.25",
      "guideline_title": "All memory synchronization operations shall be executed in sequentially consistent order C11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_vyc9vcuamlph",
          "category": 0,
          "fls_title": "Atomics",
          "score": 0.61,
          "reason": "Per FLS fls_3pjla9s93mhd: 'An atomic type is a type defined in module core::sync::atomic. [Atomic type]s provide primitive shared-memory communication between threads.' This directly addresses MISRA's memory synchronization concerns."
        },
        {
          "fls_id": "fls_isypweqewe78",
          "category": -4,
          "fls_title": "Concurrency (UB)",
          "score": 0.45,
          "reason": "Per FLS: 'It is undefined behavior if two or more threads engage in a data race.' Rust's atomics prevent data races when used correctly."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "Memory synchronization operations in C11 map to Rust's atomics. Rust's core::sync::atomic provides atomic types with ordering guarantees.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 21.26",
      "guideline_title": "The Standard Library function mtx_timedlock() shall only be invoked on mutex objects of appropriate mutex type C11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C11's mtx_timedlock() has no standard Rust equivalent. Rust's std::sync::Mutex doesn't support timed locking. parking_lot crate provides timed locking. This applies only when calling C mtx_timedlock via FFI.",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "no_equivalent"
    },
    {
      "guideline_id": "Rule 22.1",
      "guideline_title": "All resources obtained dynamically by means of Standard Library functions shall be explicitly released",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "required",
      "misra_rust_comment": "applies to resources acquired through FFI only",
      "confidence": "high",
      "notes": "Resource release maps directly to Rust's RAII/Drop semantics. In safe Rust, resources are automatically released when values go out of scope. When using C resources via FFI, manual management in unsafe code is required.",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_4jiw35pan7vn",
          "category": 0,
          "fls_title": "Destruction",
          "score": 0.7,
          "reason": "Per FLS fls_e7ucq87s806d: 'Destruction is the process of recovering resources associated with a value as it goes out of scope.' This is Rust's RAII mechanism."
        },
        {
          "fls_id": "fls_u2mzjgiwbkz0",
          "category": 0,
          "fls_title": "Destructors",
          "score": 0.72,
          "reason": "Per FLS fls_wzuwapjqtyyy: 'Dropping a value is the act of invoking the destructor of the related type.' The Drop trait ensures resources are released."
        },
        {
          "fls_id": "fls_rm4ncoopcdvj",
          "category": 0,
          "fls_title": "Drop Scopes",
          "score": 0.65,
          "reason": "Per FLS fls_7uav7vkcv4pz: 'A drop scope is a region of program text that governs the dropping of [value]s.' Drop scopes ensure deterministic resource cleanup."
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "direct_mapping"
    },
    {
      "guideline_id": "Rule 22.2",
      "guideline_title": "A block of memory shall only be freed if it was allocated by means of a Standard Library function C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_svkx6szhr472",
          "category": 0,
          "fls_title": "Ownership",
          "score": 0.7,
          "reason": "Per FLS fls_ze0u9gfylmhn: 'A value shall have only one owner.' This prevents double-free by ensuring single ownership."
        },
        {
          "fls_id": "fls_9wgldua1u8yt",
          "category": -4,
          "fls_title": "Dereference Expression (UB)",
          "score": 0.63,
          "reason": "Per FLS: 'It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.' Dereferencing freed memory is UB."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "Double-free prevention maps to Rust's ownership model. In safe Rust, each value has exactly one owner and is dropped exactly once. When using C memory via FFI, this rule applies to raw pointer management.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 22.3",
      "guideline_title": "The same file shall not be open for read and write access at the same time on different streams C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C FILE* simultaneous read/write streams have no Rust equivalent. Rust's std::fs::File uses separate read/write handles. This applies only when calling C file functions via FFI.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 22.4",
      "guideline_title": "There shall be no attempt to write to a stream which has been opened as read-only",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C FILE* read-only stream handling has no Rust equivalent. Rust's type system enforces read vs write at compile time. This applies only when calling C file functions via FFI.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 22.5",
      "guideline_title": "A pointer to a FILE object shall not be dereferenced",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C FILE* is an opaque type that should not be dereferenced. Rust has no equivalent; File handles are opaque. This applies only when calling C file functions via FFI.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 22.6",
      "guideline_title": "The value of a pointer to a FILE shall not be used after the associated stream has been closed C99",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C FILE* pointer becomes invalid after fclose. Rust's ownership prevents use-after-close. This applies only when calling C file functions via FFI.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 22.7",
      "guideline_title": "The macro EOF shall only be compared with the unmodified return value from any Standard Library function capable of returning EOF",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C's EOF macro has no Rust equivalent. Rust uses Result/Option for error/end-of-file. This applies only when calling C file functions via FFI.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 22.8",
      "guideline_title": "The value of errno shall be set to zero prior to a call to an errno- setting-function",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "disapplied",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C's errno has no Rust equivalent. Rust uses Result for error handling. This applies only when calling C functions that set errno via FFI. Updated: Rust's Result/Option provide type-safe error handling as an alternative to errno.",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_dzq9cdz4ibsz",
          "category": 0,
          "fls_title": "Exceptions and Errors",
          "score": 0.55,
          "reason": "Per FLS fls_vsk4vhnuiyyz: 'The Rust programming language lacks exceptions and exception handlers. Instead, the language uses the following tiered error handling scheme.' Per FLS fls_ckeitwiv326r: 'The result of a possibly erroneous computation is usually represented using enum core::result::Result.' Result/Option are Rust's type-safe alternative to C's errno mechanism."
        },
        {
          "fls_id": "fls_pocsh1neugpc",
          "category": 0,
          "fls_title": "Error Propagation Expression",
          "score": 0.57,
          "reason": "Per FLS fls_8q59wbumrt5s: 'An error propagation expression is an expression that either evaluates to a value of its operand or returns a value to the enclosing control flow boundary.' The `?` operator provides structured error propagation, replacing ad-hoc errno checking."
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "rust_alternative"
    },
    {
      "guideline_id": "Rule 22.9",
      "guideline_title": "The value of errno shall be tested against zero after calling an errno- setting-function",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "disapplied",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C's errno checking has no Rust equivalent. Rust uses Result for error handling. This applies only when calling C functions that set errno via FFI. Updated: Rust's Result/Option provide type-safe error handling as an alternative to errno.",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_dzq9cdz4ibsz",
          "category": 0,
          "fls_title": "Exceptions and Errors",
          "score": 0.55,
          "reason": "Per FLS fls_vsk4vhnuiyyz: 'The Rust programming language lacks exceptions and exception handlers. Instead, the language uses the following tiered error handling scheme.' Per FLS fls_ckeitwiv326r: 'The result of a possibly erroneous computation is usually represented using enum core::result::Result.' Result/Option are Rust's type-safe alternative to C's errno mechanism."
        },
        {
          "fls_id": "fls_pocsh1neugpc",
          "category": 0,
          "fls_title": "Error Propagation Expression",
          "score": 0.57,
          "reason": "Per FLS fls_8q59wbumrt5s: 'An error propagation expression is an expression that either evaluates to a value of its operand or returns a value to the enclosing control flow boundary.' The `?` operator provides structured error propagation, replacing ad-hoc errno checking."
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "rust_alternative"
    },
    {
      "guideline_id": "Rule 22.10",
      "guideline_title": "The value of errno shall only be tested when the last function to be called was an errno-setting-function",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "disapplied",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C's errno value semantics have no Rust equivalent. Rust uses Result for error handling. This applies only when calling C functions that set errno via FFI. Updated: Rust's Result/Option provide type-safe error handling as an alternative to errno.",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_dzq9cdz4ibsz",
          "category": 0,
          "fls_title": "Exceptions and Errors",
          "score": 0.55,
          "reason": "Per FLS fls_vsk4vhnuiyyz: 'The Rust programming language lacks exceptions and exception handlers. Instead, the language uses the following tiered error handling scheme.' Per FLS fls_ckeitwiv326r: 'The result of a possibly erroneous computation is usually represented using enum core::result::Result.' Result/Option are Rust's type-safe alternative to C's errno mechanism."
        },
        {
          "fls_id": "fls_pocsh1neugpc",
          "category": 0,
          "fls_title": "Error Propagation Expression",
          "score": 0.57,
          "reason": "Per FLS fls_8q59wbumrt5s: 'An error propagation expression is an expression that either evaluates to a value of its operand or returns a value to the enclosing control flow boundary.' The `?` operator provides structured error propagation, replacing ad-hoc errno checking."
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "rust_alternative"
    },
    {
      "guideline_id": "Rule 22.11",
      "guideline_title": "A thread that was previously either joined or detached shall not be subsequently joined nor detached C11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "C11 thread join/detach semantics have no direct FLS equivalent. Rust's std::thread::JoinHandle ensures threads are joined. This applies only when calling C11 thread functions via FFI.",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_3v733mnewssy",
          "category": 0,
          "fls_title": "Concurrency",
          "score": 0.68,
          "reason": "Per FLS fls_opt7v0mopxc8: 'The Rust programming language provides features for concurrent programming without [data race]s.' Per FLS fls_isypweqewe78 (UB): 'It is undefined behavior if two or more threads engage in a data race.' This chapter defines Rust's concurrency model which replaces C11 threading primitives."
        },
        {
          "fls_id": "fls_eiw4by8z75di",
          "category": 0,
          "fls_title": "Send and Sync",
          "score": 0.67,
          "reason": "Per FLS fls_4ypqdehn7b0v: 'A send type shall have [value]s that are safe to transfer across thread boundaries.' Per FLS fls_zgemofbs5q2x: 'A sync type shall have [value]s that are allowed to be shared across multiple threads at any given time without incurring data races.' These traits enforce thread-safety at compile time, replacing runtime checks needed with C11 threading."
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "no_equivalent"
    },
    {
      "guideline_id": "Rule 22.12",
      "guideline_title": "Thread objects, thread synchronization objects, and thread-specific storage pointers shall only be accessed by the appropriate Standard Library functions C11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_eiw4by8z75di",
          "category": 0,
          "fls_title": "Send and Sync",
          "score": 0.55,
          "reason": "Per FLS fls_4ypqdehn7b0v: 'A send type shall have [value]s that are safe to transfer across thread boundaries.' This enforces safe cross-thread value transfer."
        },
        {
          "fls_id": "fls_3v733mnewssy",
          "category": 0,
          "fls_title": "Concurrency",
          "score": 0.68,
          "reason": "Per FLS fls_opt7v0mopxc8: 'The Rust programming language provides features for concurrent programming without [data race]s.' Per FLS fls_isypweqewe78 (UB): 'It is undefined behavior if two or more threads engage in a data race.' This chapter defines Rust's concurrency model which replaces C11 threading primitives."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C11 thread object copying maps to Rust's Send/Sync traits. Rust's type system enforces thread-safety at compile time.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 22.13",
      "guideline_title": "Thread objects, thread synchronization objects and thread-specific storage pointers shall have appropriate storage duration C11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_rm4ncoopcdvj",
          "category": 0,
          "fls_title": "Drop Scopes",
          "score": 0.65,
          "reason": "Per FLS fls_7uav7vkcv4pz: 'A drop scope is a region of program text that governs the dropping of [value]s.' This ensures deterministic cleanup of thread objects."
        },
        {
          "fls_id": "fls_3v733mnewssy",
          "category": 0,
          "fls_title": "Concurrency",
          "score": 0.68,
          "reason": "Per FLS fls_opt7v0mopxc8: 'The Rust programming language provides features for concurrent programming without [data race]s.' Per FLS fls_isypweqewe78 (UB): 'It is undefined behavior if two or more threads engage in a data race.' This chapter defines Rust's concurrency model which replaces C11 threading primitives."
        },
        {
          "fls_id": "fls_eiw4by8z75di",
          "category": 0,
          "fls_title": "Send and Sync",
          "score": 0.67,
          "reason": "Per FLS fls_4ypqdehn7b0v: 'A send type shall have [value]s that are safe to transfer across thread boundaries.' Per FLS fls_zgemofbs5q2x: 'A sync type shall have [value]s that are allowed to be shared across multiple threads at any given time without incurring data races.' These traits enforce thread-safety at compile time, replacing runtime checks needed with C11 threading."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "C11 thread object destruction maps to Rust's Drop semantics. Rust's RAII ensures thread handles are properly cleaned up.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 22.14",
      "guideline_title": "Thread synchronization objects shall be initialized before being accessed C11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_3v733mnewssy",
          "category": 0,
          "fls_title": "Concurrency",
          "score": 0.68,
          "reason": "Per FLS fls_opt7v0mopxc8: 'The Rust programming language provides features for concurrent programming without [data race]s.' Per FLS fls_isypweqewe78 (UB): 'It is undefined behavior if two or more threads engage in a data race.' This chapter defines Rust's concurrency model which replaces C11 threading primitives."
        },
        {
          "fls_id": "fls_eiw4by8z75di",
          "category": 0,
          "fls_title": "Send and Sync",
          "score": 0.67,
          "reason": "Per FLS fls_4ypqdehn7b0v: 'A send type shall have [value]s that are safe to transfer across thread boundaries.' Per FLS fls_zgemofbs5q2x: 'A sync type shall have [value]s that are allowed to be shared across multiple threads at any given time without incurring data races.' These traits enforce thread-safety at compile time, replacing runtime checks needed with C11 threading."
        },
        {
          "fls_id": "fls_vyc9vcuamlph",
          "category": 0,
          "fls_title": "Atomics",
          "score": 0.68,
          "reason": "Per FLS fls_3pjla9s93mhd: 'An atomic type is a type defined in module core::sync::atomic. [Atomic type]s provide primitive shared-memory communication between threads.' Rust's atomics provide the synchronization primitives that correspond to C11 mutex and condition variable operations."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "required",
      "misra_rust_comment": "applies to creating synchronization objects before threads that use them",
      "confidence": "high",
      "notes": "C11 thread synchronization object initialization has no direct FLS equivalent. Rust's Mutex/RwLock constructors ensure proper initialization. This applies only when using C11 sync primitives via FFI.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 22.15",
      "guideline_title": "Thread synchronization objects and thread-specific storage pointers shall not be destroyed until after all threads accessing them have terminated C11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_eiw4by8z75di",
          "category": 0,
          "fls_title": "Send and Sync",
          "score": 0.55,
          "reason": "Per FLS fls_zgemofbs5q2x: 'A sync type shall have [value]s that are allowed to be shared across multiple threads at any given time without incurring data races.'"
        },
        {
          "fls_id": "fls_3v733mnewssy",
          "category": 0,
          "fls_title": "Concurrency",
          "score": 0.68,
          "reason": "Per FLS fls_opt7v0mopxc8: 'The Rust programming language provides features for concurrent programming without [data race]s.' Per FLS fls_isypweqewe78 (UB): 'It is undefined behavior if two or more threads engage in a data race.' This chapter defines Rust's concurrency model which replaces C11 threading primitives."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "applies to releasing synchronization objects after threads that use them",
      "confidence": "high",
      "notes": "C11 thread-specific storage copying maps to Rust's Send/Sync traits. Rust enforces thread-safety at compile time.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 22.16",
      "guideline_title": "All mutex objects locked by a thread shall be explicitly unlocked by the same thread C11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_3v733mnewssy",
          "category": 0,
          "fls_title": "Concurrency",
          "score": 0.68,
          "reason": "Per FLS fls_opt7v0mopxc8: 'The Rust programming language provides features for concurrent programming without [data race]s.' Per FLS fls_isypweqewe78 (UB): 'It is undefined behavior if two or more threads engage in a data race.' This chapter defines Rust's concurrency model which replaces C11 threading primitives."
        },
        {
          "fls_id": "fls_eiw4by8z75di",
          "category": 0,
          "fls_title": "Send and Sync",
          "score": 0.67,
          "reason": "Per FLS fls_4ypqdehn7b0v: 'A send type shall have [value]s that are safe to transfer across thread boundaries.' Per FLS fls_zgemofbs5q2x: 'A sync type shall have [value]s that are allowed to be shared across multiple threads at any given time without incurring data races.' These traits enforce thread-safety at compile time, replacing runtime checks needed with C11 threading."
        },
        {
          "fls_id": "fls_vyc9vcuamlph",
          "category": 0,
          "fls_title": "Atomics",
          "score": 0.68,
          "reason": "Per FLS fls_3pjla9s93mhd: 'An atomic type is a type defined in module core::sync::atomic. [Atomic type]s provide primitive shared-memory communication between threads.' Rust's atomics provide the synchronization primitives that correspond to C11 mutex and condition variable operations."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C11 mutex unlock requirements have no direct FLS equivalent. Rust's MutexGuard uses RAII to ensure unlock on drop. This applies only when using C11 mutexes via FFI.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 22.17",
      "guideline_title": "No thread shall unlock a mutex or call cnd_wait() or cnd_timedwait() for a mutex it has not locked before C11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "high",
      "notes": "C11 mutex ownership for unlock/cnd_wait has no direct FLS equivalent. Rust's MutexGuard enforces ownership. This applies only when using C11 mutexes via FFI.",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_3v733mnewssy",
          "category": 0,
          "fls_title": "Concurrency",
          "score": 0.68,
          "reason": "Per FLS fls_opt7v0mopxc8: 'The Rust programming language provides features for concurrent programming without [data race]s.' Per FLS fls_isypweqewe78 (UB): 'It is undefined behavior if two or more threads engage in a data race.' This chapter defines Rust's concurrency model which replaces C11 threading primitives."
        },
        {
          "fls_id": "fls_eiw4by8z75di",
          "category": 0,
          "fls_title": "Send and Sync",
          "score": 0.67,
          "reason": "Per FLS fls_4ypqdehn7b0v: 'A send type shall have [value]s that are safe to transfer across thread boundaries.' Per FLS fls_zgemofbs5q2x: 'A sync type shall have [value]s that are allowed to be shared across multiple threads at any given time without incurring data races.' These traits enforce thread-safety at compile time, replacing runtime checks needed with C11 threading."
        },
        {
          "fls_id": "fls_vyc9vcuamlph",
          "category": 0,
          "fls_title": "Atomics",
          "score": 0.68,
          "reason": "Per FLS fls_3pjla9s93mhd: 'An atomic type is a type defined in module core::sync::atomic. [Atomic type]s provide primitive shared-memory communication between threads.' Rust's atomics provide the synchronization primitives that correspond to C11 mutex and condition variable operations."
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "no_equivalent"
    },
    {
      "guideline_id": "Rule 22.18",
      "guideline_title": "Non-recursive mutexes shall not be recursively locked C11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "C11 non-recursive mutex rules have no direct FLS equivalent. Rust's Mutex is non-recursive by default and panics on relock. This applies only when using C11 mutexes via FFI.",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_3v733mnewssy",
          "category": 0,
          "fls_title": "Concurrency",
          "score": 0.68,
          "reason": "Per FLS fls_opt7v0mopxc8: 'The Rust programming language provides features for concurrent programming without [data race]s.' Per FLS fls_isypweqewe78 (UB): 'It is undefined behavior if two or more threads engage in a data race.' This chapter defines Rust's concurrency model which replaces C11 threading primitives."
        },
        {
          "fls_id": "fls_eiw4by8z75di",
          "category": 0,
          "fls_title": "Send and Sync",
          "score": 0.67,
          "reason": "Per FLS fls_4ypqdehn7b0v: 'A send type shall have [value]s that are safe to transfer across thread boundaries.' Per FLS fls_zgemofbs5q2x: 'A sync type shall have [value]s that are allowed to be shared across multiple threads at any given time without incurring data races.' These traits enforce thread-safety at compile time, replacing runtime checks needed with C11 threading."
        },
        {
          "fls_id": "fls_vyc9vcuamlph",
          "category": 0,
          "fls_title": "Atomics",
          "score": 0.68,
          "reason": "Per FLS fls_3pjla9s93mhd: 'An atomic type is a type defined in module core::sync::atomic. [Atomic type]s provide primitive shared-memory communication between threads.' Rust's atomics provide the synchronization primitives that correspond to C11 mutex and condition variable operations."
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "no_equivalent"
    },
    {
      "guideline_id": "Rule 22.19",
      "guideline_title": "A condition variable shall be associated with at most one mutex object",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "C11 condition variable association rules have no direct FLS equivalent. Rust's Condvar doesn't have this restriction. This applies only when using C11 condition variables via FFI.",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_3v733mnewssy",
          "category": 0,
          "fls_title": "Concurrency",
          "score": 0.68,
          "reason": "Per FLS fls_opt7v0mopxc8: 'The Rust programming language provides features for concurrent programming without [data race]s.' Per FLS fls_isypweqewe78 (UB): 'It is undefined behavior if two or more threads engage in a data race.' This chapter defines Rust's concurrency model which replaces C11 threading primitives."
        },
        {
          "fls_id": "fls_eiw4by8z75di",
          "category": 0,
          "fls_title": "Send and Sync",
          "score": 0.67,
          "reason": "Per FLS fls_4ypqdehn7b0v: 'A send type shall have [value]s that are safe to transfer across thread boundaries.' Per FLS fls_zgemofbs5q2x: 'A sync type shall have [value]s that are allowed to be shared across multiple threads at any given time without incurring data races.' These traits enforce thread-safety at compile time, replacing runtime checks needed with C11 threading."
        },
        {
          "fls_id": "fls_vyc9vcuamlph",
          "category": 0,
          "fls_title": "Atomics",
          "score": 0.68,
          "reason": "Per FLS fls_3pjla9s93mhd: 'An atomic type is a type defined in module core::sync::atomic. [Atomic type]s provide primitive shared-memory communication between threads.' Rust's atomics provide the synchronization primitives that correspond to C11 mutex and condition variable operations."
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "no_equivalent"
    },
    {
      "guideline_id": "Rule 22.20",
      "guideline_title": "Thread-specific storage pointers shall be created before being accessed C11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_3v733mnewssy",
          "category": 0,
          "fls_title": "Concurrency",
          "score": 0.68,
          "reason": "Per FLS fls_opt7v0mopxc8: 'The Rust programming language provides features for concurrent programming without [data race]s.' Per FLS fls_isypweqewe78 (UB): 'It is undefined behavior if two or more threads engage in a data race.' This chapter defines Rust's concurrency model which replaces C11 threading primitives."
        },
        {
          "fls_id": "fls_eiw4by8z75di",
          "category": 0,
          "fls_title": "Send and Sync",
          "score": 0.67,
          "reason": "Per FLS fls_4ypqdehn7b0v: 'A send type shall have [value]s that are safe to transfer across thread boundaries.' Per FLS fls_zgemofbs5q2x: 'A sync type shall have [value]s that are allowed to be shared across multiple threads at any given time without incurring data races.' These traits enforce thread-safety at compile time, replacing runtime checks needed with C11 threading."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "required",
      "confidence": "high",
      "notes": "C11 thread-specific storage creation timing has no direct FLS equivalent. Rust's thread_local! macro handles this at compile time. This applies only when using C11 TLS via FFI.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 23.1",
      "guideline_title": "A generic selection should only be expanded from a macro",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no C11 _Generic selection. Compile-time type dispatch in Rust uses trait methods, which are always type-safe and work with generics naturally.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 23.2",
      "guideline_title": "A generic selection that is not expanded from a macro shall not contain potentially evaluated expressions in its association list",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no C11 _Generic selection. Rust trait-based dispatch does not have association lists with potentially unevaluated expressions.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 23.3",
      "guideline_title": "A generic selection should contain at least one non-default association",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no C11 _Generic selection with default associations. Rust match expressions require exhaustive patterns.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 23.4",
      "guideline_title": "A generic association shall list an appropriate type",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no C11 _Generic associations. Trait implementations specify concrete types that must be valid.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 23.5",
      "guideline_title": "A generic selection should not depend on implicit pointer type conversion",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no C11 _Generic. Rust does not have implicit pointer conversions - all conversions must be explicit (via as or From/Into).",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 23.6",
      "guideline_title": "The controlling expression of a generic selection shall have an essential type that matches one of the selections",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no C11 _Generic. Trait method dispatch in Rust is resolved at compile time with strict type matching.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 23.7",
      "guideline_title": "A generic selection that is expanded from a macro should evaluate its argument only once",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no C11 _Generic. Rust macro hygiene and the borrow checker prevent multiple evaluation issues naturally.",
      "rejected_matches": []
    },
    {
      "guideline_id": "Rule 23.8",
      "guideline_title": "A default association shall appear as either the first or the last association of a generic selection",
      "guideline_type": "rule",
      "applicability_all_rust": "not_applicable",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "n_a",
      "confidence": "high",
      "notes": "Rust has no C11 _Generic associations. Match arm ordering in Rust is handled by the compiler with unreachable pattern warnings.",
      "accepted_matches": [],
      "rejected_matches": [],
      "fls_rationale_type": "no_equivalent"
    }
  ]
}