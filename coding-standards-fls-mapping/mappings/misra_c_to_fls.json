{
  "standard": "MISRA-C",
  "standard_version": "2025",
  "fls_version": "1.0 (2024)",
  "mapping_date": "2025-12-31",
  "methodology": "Semantic embedding similarity + manual verification. High confidence mappings verified against MISRA rationale and FLS content.",
  "statistics": {
    "total_guidelines": 223,
    "mapped": 196,
    "unmapped": 27,
    "not_applicable": 95,
    "rust_prevents": 2,
    "preserved_high_confidence": 14,
    "avg_matches_per_guideline": 8.9,
    "matches_by_category": {
      "section": 699,
      "general": 18,
      "legality_rules": 1044,
      "implementation_requirements": 5,
      "dynamic_semantics": 137,
      "undefined_behavior": 31
    },
    "thresholds": {
      "section": 0.5,
      "paragraph": 0.55
    }
  },
  "mappings": [
    {
      "schema_version": "1.0",
      "guideline_id": "Dir 1.1",
      "guideline_title": "Any implementation-defined behaviour on which the output of the program depends shall be documented and understood C90",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_usgd0xlijoxv",
          "fls_title": "ABI",
          "category": 0,
          "score": 0.64,
          "reason": "FLS defines ABI conventions including extern C, Rust, and system ABIs. Per FLS 'Application Binary Interface or ABI is a set of conventions that dictate how data and computation cross language boundaries.' This directly addresses MISRA's concern about ABI documentation."
        },
        {
          "fls_id": "fls_99b7xi1bkgih",
          "fls_title": "Conformity",
          "category": 0,
          "score": 0.61,
          "reason": "FLS Conformity section specifies tool requirements including 'A tool that conforms to this document shall produce for the execution of a given Rust program a set of interactions with the external environment whose order and timing are consistent with the definitions.' Addresses implementation conformance."
        },
        {
          "fls_id": "fls_10yukmkhl0ng",
          "fls_title": "Extent",
          "category": 0,
          "score": 0.61,
          "reason": "FLS Extent explicitly lists what is and is not specified, including 'The effect of undefined behavior' as not specified. Addresses documentation of implementation-defined scope."
        },
        {
          "fls_id": "fls_j6pqchx27ast",
          "fls_title": "ABI",
          "category": -6,
          "score": 0.57,
          "reason": "FLS implementation_permissions for ABI states 'A tool is allowed to specify additional ABIs' listing platform-specific options like aapcs, cdecl, stdcall, win64. Documents allowed implementation extensions."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "FLS addresses implementation-defined behavior through explicit ABI specifications, conformity requirements, and clear documentation of what is/isn't specified. Rust's approach differs from C by having a formal specification (FLS) that defines most behavior explicitly, reducing the scope of implementation-defined behavior compared to C.",
      "rejected_matches": [
        {
          "fls_id": "fls_jep7p27kaqlp",
          "fls_title": "Unsafety",
          "category": 0,
          "score": 0.63,
          "reason": "General unsafe operations section - not specifically about implementation-defined behavior documentation."
        },
        {
          "fls_id": "fls_dv1qish8svc",
          "fls_title": "Scope",
          "category": -1,
          "score": 0.62,
          "reason": "About FLS document scope and contribution process, not implementation-defined behavior."
        }
      ]
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Dir 1.2",
      "guideline_title": "The use of language extensions should be minimized",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_fo1c7pg2mw1",
          "fls_title": "Scope",
          "category": 0,
          "score": 0.5,
          "reason": "FLS Scope explicitly documents the 2021 Edition of Rust as implemented by rustc. This defines the standard language - anything outside is an extension."
        },
        {
          "fls_id": "fls_9cd746qe40ag",
          "fls_title": "Versioning",
          "category": 0,
          "score": 0.59,
          "reason": "FLS Versioning states this is the specification for a qualified compiler version. Extensions (unstable features) are not documented in FLS."
        },
        {
          "fls_id": "fls_99b7xi1bkgih",
          "fls_title": "Conformity",
          "category": 0,
          "score": 0.51,
          "reason": "FLS Conformity defines tool conformance requirements. Per fls_d07x1mbhgpsd, tools may provide additional attributes but names must not conflict with built-in ones."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "misra_rust_comment": "previously Rule 1.2",
      "confidence": "medium",
      "notes": "Rust handles extensions via feature gates requiring #![feature(...)]. FLS documents only stable Rust 2021 Edition, so unstable features are inherently excluded. The edition system and qualified compiler versioning address MISRA portability concern.",
      "rejected_matches": [
        {
          "fls_id": "fls_dv1qish8svc",
          "fls_title": "Scope",
          "category": -1,
          "score": 0.71,
          "reason": "High similarity score but paragraph discusses FLS purpose, not language extensions directly."
        },
        {
          "fls_id": "fls_xscgklvg1wd2",
          "fls_title": "Structure",
          "category": 0,
          "score": 0.58,
          "reason": "Discusses FLS document structure, not language extensions."
        },
        {
          "fls_id": "fls_usgd0xlijoxv",
          "fls_title": "ABI",
          "category": 0,
          "score": 0.57,
          "reason": "ABI section is about calling conventions, not language extensions."
        }
      ]
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Dir 2.1",
      "guideline_title": "All source files shall compile without any compilation errors",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_99b7xi1bkgih",
          "fls_title": "Conformity",
          "category": 0,
          "score": 0.51,
          "reason": "FLS Conformity directly addresses this. Per fls_GZmxrO61eiJ1: A conforming tool shall reject programs that contain errors whose detection is required. Per fls_dBKu9jgx3OyH: Correctly translate legal programs."
        },
        {
          "fls_id": "fls_10yukmkhl0ng",
          "fls_title": "Extent",
          "category": 0,
          "score": 0.5,
          "reason": "FLS Extent (fls_7tm19jxtffc8): Specifies violations that a conforming tool is required to detect, and the effect of attempting to translate programs containing such violations."
        }
      ],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Rust enforces this more strictly than C. rustc will not produce an executable when compilation errors exist - the build fails completely. FLS Conformity explicitly requires rejecting erroneous programs.",
      "rejected_matches": [
        {
          "fls_id": "fls_u1afezy1ye99",
          "fls_title": "Conditional Compilation",
          "category": 0,
          "score": 0.54,
          "reason": "Conditional compilation is about cfg attributes, not about compilation error handling."
        },
        {
          "fls_id": "fls_9cd746qe40ag",
          "fls_title": "Versioning",
          "category": 0,
          "score": 0.55,
          "reason": "Versioning discusses qualified compiler versions, not error rejection."
        }
      ]
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Dir 3.1",
      "guideline_title": "All code shall be traceable to documented requirements",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Dir 3.1 is a process/methodology guideline about code traceability to requirements. The FLS does not prescribe project management or requirements traceability processes. However, Rust provides #[doc] attribute and doc comments as language-level infrastructure to associate documentation with code constructs, which supports traceability implementation at the code level.",
      "accepted_matches": [
        {
          "fls_id": "fls_63v1fqedzwfd",
          "fls_title": "Attribute doc",
          "category": 0,
          "score": 0.47,
          "reason": "FLS doc attribute provides infrastructure for associating documentation with constructs, supporting traceability at the code level"
        },
        {
          "fls_id": "fls_7n6d3jx61ose",
          "fls_title": "Doc Comments",
          "category": -2,
          "score": 0.58,
          "reason": "FLS doc comments (/// and //!) are semantically equivalent to #[doc] attributes, enabling documentation directly in source code"
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "no_equivalent"
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Dir 4.1",
      "guideline_title": "Run-time failures shall be minimized C90",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_ZfIBiJMf8qE1",
          "fls_title": "Arithmetic Overflow",
          "category": 0,
          "score": 0.6,
          "reason": "FLS explicitly documents arithmetic overflow behavior. In debug mode, overflow causes panic. In release, behavior is configurable. Per fls_R48VKcEIbfXC: Evaluation may result in a panic."
        },
        {
          "fls_id": "fls_1k9mkv7rbezi",
          "fls_title": "Arithmetic Expressions",
          "category": 0,
          "score": 0.5,
          "reason": "FLS documents runtime behavior for division by zero. Per fls_Q9dhNiICGIfr: If unsigned division operand is 0, operation results in panic."
        },
        {
          "fls_id": "fls_k02nt1m5fq1z",
          "fls_title": "Panic",
          "category": 0,
          "score": 0.42,
          "reason": "FLS Panic section (fls_a554v4n0khye): A panic is an abnormal program state. Rust uses panic for runtime error signaling rather than undefined behavior."
        },
        {
          "fls_id": "fls_dzq9cdz4ibsz",
          "fls_title": "Exceptions and Errors",
          "category": 0,
          "score": 0.4,
          "reason": "FLS Ch.16 documents Rust error handling: Option for absent values, Result for erroneous computations, panic for unrecoverable errors. This is the Rust mechanism for addressing MISRA runtime failure concerns."
        },
        {
          "fls_id": "fls_sxcr4aa098i6",
          "fls_title": "Indexing Expressions",
          "category": 0,
          "score": 0.4,
          "reason": "FLS documents index expressions. Rust performs bounds checking at runtime for array/slice indexing."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "often in the form of panics",
      "confidence": "medium",
      "notes": "Rust provides extensive built-in runtime checking: overflow detection, bounds checking, null pointer prevention. Panics are the primary mechanism for handling runtime failures. Unlike C where runtime errors lead to UB, Rust explicitly defines panic behavior.",
      "rejected_matches": [
        {
          "fls_id": "fls_jep7p27kaqlp",
          "fls_title": "Unsafety",
          "category": 0,
          "score": 0.57,
          "reason": "Unsafety is about unsafe operations, not specifically about runtime failure minimization."
        }
      ]
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Dir 4.2",
      "guideline_title": "All usage of assembly language should be documented",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_z1il3w9nulzy",
          "fls_title": "Inline Assembly",
          "category": 0,
          "score": 0.5,
          "reason": "FLS Chapter 22 Inline Assembly section documents all aspects of assembly in Rust. Per fls_leamdp1r3hez: Inline assembly is hand-written assembly code integrated into Rust."
        },
        {
          "fls_id": "fls_e0896uk0mdyl",
          "fls_title": "Assembly Instructions",
          "category": 0,
          "score": 0.61,
          "reason": "FLS documents assembly instruction syntax and semantics. Per fls_4jr7eg6e0g4w: An assembly instruction is a string literal representing a low-level assembly operation."
        },
        {
          "fls_id": "fls_qezwyridmjob",
          "fls_title": "Macros asm global_asm naked_asm",
          "category": 0,
          "score": 0.45,
          "reason": "FLS documents the macros core::arch::asm, global_asm, and naked_asm for embedding assembly. Assembly blocks are explicit and require unsafe context."
        },
        {
          "fls_id": "fls_ylli0ortyegk",
          "fls_title": "Assembly Options",
          "category": 0,
          "score": 0.57,
          "reason": "FLS documents assembly options (nomem, noreturn, nostack, preserves_flags, pure, readonly, etc.) that constrain assembly behavior."
        },
        {
          "fls_id": "fls_6momhvgx4w21",
          "fls_title": "Directive Support",
          "category": 0,
          "score": 0.56,
          "reason": "FLS documents supported assembly directives per architecture (.text, .data, .align, etc.)."
        },
        {
          "fls_id": "fls_j9l8wn6wgm06",
          "fls_title": "Registers",
          "category": 0,
          "score": 0.45,
          "reason": "FLS documents register names, aliases, and restrictions per architecture (AArch64, ARM, RISC-V, x86)."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "FLS Chapter 22 comprehensively documents Rust inline assembly. All assembly requires unsafe blocks making it explicit and auditable. The asm! macro syntax ensures assembly is clearly marked in source code.",
      "rejected_matches": []
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Dir 4.3",
      "guideline_title": "Assembly language shall be encapsulated and isolated",
      "guideline_type": "directive",
      "all_rust": {
        "applicability": "yes",
        "adjusted_category": "advisory",
        "rationale_type": "direct_mapping",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_qezwyridmjob",
            "fls_title": "Macros asm global_asm and naked_asm",
            "category": 0,
            "score": 0.66,
            "reason": "Per FLS, all Rust assembly must use core::arch::{asm, global_asm, naked_asm} macros - macro encapsulation is mandatory by language design"
          },
          {
            "fls_id": "fls_z1il3w9nulzy",
            "fls_title": "Inline Assembly",
            "category": 0,
            "score": 0.59,
            "reason": "Parent section defining Rust inline assembly. All assembly code blocks must go through structured macro system"
          },
          {
            "fls_id": "fls_3fg60jblx0xb",
            "fls_title": "Inline Assembly legality",
            "category": -2,
            "score": 0.71,
            "reason": "Per FLS: 'Inline assembly is written as an assembly code block that is wrapped inside a macro invocation' - directly enforces MISRA encapsulation"
          },
          {
            "fls_id": "fls_4lb6yh12w1cv",
            "fls_title": "asm macro invocation",
            "category": -2,
            "score": 0.8,
            "reason": "Per FLS: 'Invoking macro core::arch::asm causes the related assembly code block to be integrated into the generated assembly' - macro encapsulation enforced"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 1,
        "notes": "Rust enforces MISRA Dir 4.3 by design: all inline assembly must use core::arch macros. There is no way to write raw assembly without macro encapsulation. The language specification mandates the encapsulation pattern MISRA recommends."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "rust_prevents",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_s5nfhBFOk8Bu",
            "fls_title": "Unsafety legality",
            "category": -2,
            "score": 0.71,
            "reason": "Per FLS: 'Calling macro core::arch::asm' is listed as an unsafe operation. Safe Rust code cannot invoke asm! macro"
          },
          {
            "fls_id": "fls_ybnpe7ppq1vh",
            "fls_title": "Unsafety legality",
            "category": -2,
            "score": 0.7,
            "reason": "Per FLS: 'An unsafe operation shall be used only within an unsafe context.' Assembly requires unsafe context"
          },
          {
            "fls_id": "fls_jep7p27kaqlp",
            "fls_title": "Unsafety",
            "category": 0,
            "score": 0.6,
            "reason": "Chapter 19 defines unsafe operations. Inline assembly is categorically an unsafe operation in Rust"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 1,
        "notes": "In safe Rust (no unsafe blocks), inline assembly is impossible. The asm! macro is listed as an unsafe operation per FLS fls_s5nfhBFOk8Bu. This guideline is not applicable to safe Rust because the language prevents assembly entirely."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Dir 4.4",
      "guideline_title": "Sections of code should not be \u201ccommented out\u201d",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_q8l2jza7d9xa",
          "fls_title": "Comments",
          "category": 0,
          "score": 0.64,
          "reason": "FLS Comments section defines block comments that can legally nest (unlike C), reducing the primary risk MISRA identifies"
        },
        {
          "fls_id": "fls_fymvsy6ig99a",
          "fls_title": "Attribute cfg",
          "category": 0,
          "score": 0.67,
          "reason": "FLS cfg attribute provides proper conditional compilation mechanism, the recommended alternative to commenting out code"
        },
        {
          "fls_id": "fls_dd9xh3wdjudo",
          "fls_title": "Attribute cfg_attr",
          "category": 0,
          "score": 0.87,
          "reason": "FLS cfg_attr enables conditional attribute application, another mechanism for conditional compilation"
        },
        {
          "fls_id": "fls_u1afezy1ye99",
          "fls_title": "Conditional Compilation",
          "category": 0,
          "score": 0.61,
          "reason": "FLS defines how cfg attributes control conditional compilation, providing safe code exclusion"
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "advisory",
      "confidence": "medium",
      "notes": "MISRA concern is that C comments cannot nest, causing unexpected behavior when commenting out code. Rust block comments CAN nest safely. Additionally, Rust provides #[cfg(...)] and #[cfg_attr(...)] attributes as the proper mechanism for conditional compilation, which is the recommended approach instead of commenting out code.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Dir 4.5",
      "guideline_title": "Identifiers in the same name space with overlapping visibility should be typographically unambiguous",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_21vnag69kbwe",
          "fls_title": "Identifiers",
          "category": 0,
          "score": 0.63,
          "reason": "FLS Identifiers section documents identifier syntax and normalization rules."
        },
        {
          "fls_id": "fls_vde7gev5rz4q",
          "fls_title": "Identifiers",
          "category": -2,
          "score": 0.6,
          "reason": "FLS requires NFC normalization: Identifiers are normalized using Normalization Form C per Unicode Standard Annex #15."
        },
        {
          "fls_id": "fls_j9yh8j8jgdeu",
          "fls_title": "Identifiers",
          "category": -2,
          "score": 0.67,
          "reason": "FLS defines identifier equivalence: Two identifiers are the same if they consist of the same sequence of characters after normalization."
        },
        {
          "fls_id": "fls_cs6cbw625np1",
          "fls_title": "Identifiers",
          "category": -2,
          "score": 0.5,
          "reason": "FLS prohibits zero-width characters: Characters 0x200C (ZWNJ) and 0x200D (ZWJ) shall not appear in a pure identifier."
        },
        {
          "fls_id": "fls_irwcldiotei2",
          "fls_title": "Identifiers",
          "category": -2,
          "score": 0.65,
          "reason": "FLS restricts to ASCII in key contexts: external blocks, no_mangle items, crate imports - reducing confusable character risks."
        }
      ],
      "fls_rationale_type": "partial_mapping",
      "misra_rust_category": "recommended",
      "misra_rust_comment": "\u201cambiguity\u201d is determined by the project",
      "confidence": "medium",
      "notes": "FLS addresses identifier normalization and prohibits problematic zero-width characters. ASCII-only is enforced in FFI contexts. However, full typographic ambiguity detection (e.g., Cyrillic '\u0430' vs Latin 'a') is project/tooling responsibility per MISRA ADD-6 note.",
      "rejected_matches": []
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Dir 4.6",
      "guideline_title": "typedefs that indicate size and signedness should be used in place of the basic integer types",
      "guideline_type": "directive",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_3qnpv2z7yjil",
            "fls_title": "Integer Types",
            "category": 0,
            "score": 0.77,
            "reason": "Per FLS: Rust's integer types (i8, i16, i32, i64, i128, u8, u16, u32, u64, u128, isize, usize) encode size and signedness directly in the type name. No typedef abstraction needed."
          },
          {
            "fls_id": "fls_2ed4axpsy9u0",
            "fls_title": "Integer Literals",
            "category": 0,
            "score": 0.55,
            "reason": "Per FLS: Integer literals can have explicit suffixes (i32, u64, etc.) that specify the exact type. The type system enforces size/signedness at compile time."
          },
          {
            "fls_id": "fls_kgvleup5mdhq",
            "fls_title": "Type Aliases",
            "category": 0,
            "score": 0.68,
            "reason": "Per FLS: Rust has type aliases for semantic naming (e.g., 'type Kilogram = u32'), but these are optional - the underlying types already specify size."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "MISRA Dir 4.6 recommends using int32_t instead of int to make size explicit. In Rust, primitive integer types ARE specific-length: i32, u64, etc. The C problem (ambiguous 'int' size) doesn't exist. MISRA ADD-6 confirms: 'all primitive types already fulfil this'. Type aliases exist for semantic naming but are not required for size/signedness clarity."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_3qnpv2z7yjil",
            "fls_title": "Integer Types",
            "category": 0,
            "score": 0.57,
            "reason": "Per FLS: Safe Rust uses the same explicit-size integer types (i32, u64, etc.). No difference from all_rust context."
          },
          {
            "fls_id": "fls_2ed4axpsy9u0",
            "fls_title": "Integer Literals",
            "category": 0,
            "score": 0.55,
            "reason": "Per FLS: Integer literal suffixes work identically in safe Rust - suffixes like i32, u64 specify exact types."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Same as all_rust. Rust's primitive types encode size/signedness by design. No unsafe code is involved in this language design choice."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Dir 4.7",
      "guideline_title": "If a function returns error information, then that error information shall be tested",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_dzq9cdz4ibsz",
          "fls_title": "Exceptions and Errors",
          "category": 0,
          "score": 0.5,
          "reason": "FLS Chapter 16 defines Rust's error handling: 'The result of a possibly erroneous computation is usually represented using enum core::result::Result.' Result and Option types force callers to explicitly handle success/error cases, directly addressing MISRA's concern about testing error information."
        },
        {
          "fls_id": "fls_pocsh1neugpc",
          "fls_title": "Error Propagation Expression",
          "category": 0,
          "score": 0.51,
          "reason": "FLS defines the ? operator for error propagation. Per FLS: 'An error propagation expression either evaluates to a value of its operand or returns a value to the enclosing control flow boundary.' This enforces explicit error handling."
        },
        {
          "fls_id": "fls_rgjf5ibhurda",
          "fls_title": "Attribute must_use",
          "category": -2,
          "score": 0.45,
          "reason": "FLS lists must_use as a diagnostics attribute. Result and Option are marked #[must_use], causing compiler warnings when return values are ignored - directly enforcing MISRA's requirement to test error information."
        },
        {
          "fls_id": "fls_ckeitwiv326r",
          "fls_title": "Exceptions and Errors",
          "category": -2,
          "score": 0.5,
          "reason": "Per FLS: 'The result of a possibly erroneous computation is usually represented using enum core::result::Result.' This establishes the pattern for error representation."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "advisory",
      "misra_rust_comment": "prefer Option, Result, etc.",
      "confidence": "medium",
      "notes": "Rust's type system enforces error handling through Result<T,E> and Option<T>. Unlike C where error codes can be silently ignored, Rust requires explicit handling via pattern matching, unwrap(), expect(), or the ? operator. The #[must_use] attribute on Result/Option generates compiler warnings if values are discarded. This provides stronger guarantees than MISRA's requirement.",
      "rejected_matches": [
        {
          "fls_id": "fls_dv2j1fvvnk1t",
          "fls_title": "Attribute test",
          "category": 0,
          "score": 0.53,
          "reason": "About #[test] attribute for unit testing, not about testing/checking error return values."
        }
      ]
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Dir 4.8",
      "guideline_title": "If a pointer to a structure or union is never dereferenced within a translation unit, then the implementation of the object should be hidden",
      "guideline_type": "directive",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "rust_alternative",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_jdknpu3kf865",
            "fls_title": "Visibility",
            "category": 0,
            "score": 0.64,
            "reason": "Per FLS: Rust uses visibility modifiers (pub, pub(crate), private) instead of opaque pointers. Per fls_knjruq5wppv: 'Private visibility allows a name to be referred to only by the current module and its descendant modules.'"
          },
          {
            "fls_id": "fls_utgjx6l5zwfl",
            "fls_title": "Visibility legality",
            "category": 0,
            "score": 0.56,
            "reason": "Per FLS: 'An external item, a field, or an item that appears without a visibility modifier has private visibility by default.' Struct fields are private by default - implementation is hidden without explicit action."
          },
          {
            "fls_id": "fls_9ucqbbd0s2yo",
            "fls_title": "Struct Types",
            "category": 0,
            "score": 0.69,
            "reason": "Per FLS: Struct types with private fields achieve the same goal as C opaque pointers - external code cannot access implementation details."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "MISRA Dir 4.8 recommends opaque pointers for implementation hiding. Rust achieves this through its visibility system: struct fields are PRIVATE BY DEFAULT. External modules cannot access private fields even if they have a reference to the struct. This is rust_alternative, not no_equivalent - the goal (encapsulation) is achieved via a different mechanism (visibility vs. incomplete types)."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "rust_alternative",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_jdknpu3kf865",
            "fls_title": "Visibility",
            "category": 0,
            "score": 0.59,
            "reason": "Per FLS: Visibility system applies equally in safe Rust. Private fields cannot be accessed from outside the module."
          },
          {
            "fls_id": "fls_utgjx6l5zwfl",
            "fls_title": "Visibility legality",
            "category": 0,
            "score": 0.71,
            "reason": "Per FLS: 'A field...that appears without a visibility modifier has private visibility by default.' Safe Rust enforces this at compile time."
          },
          {
            "fls_id": "fls_knjruq5wppv",
            "fls_title": "Visibility legality",
            "category": 0,
            "score": 0.61,
            "reason": "Per FLS: 'Private visibility allows a name to be referred to only by the current module and its descendant modules.' Compiler enforces encapsulation."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Same as all_rust. Safe Rust's visibility system provides implementation hiding without unsafe code. The compiler enforces that private fields cannot be accessed from outside the defining module, achieving the same goal as C opaque pointers."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Dir 4.9",
      "guideline_title": "A function should be used in preference to a function-like macro where they are interchangeable",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_qcb1n9c0e5hz",
          "fls_title": "Functions",
          "category": 0,
          "score": 0.68,
          "reason": "FLS Chapter 9 defines functions with strong type checking. Per FLS: 'A function parameter is a construct that yields a set of bindings that bind matched input values to names.' Function parameters have explicit types that are checked at compile time, addressing MISRA's concern about type-checking benefits."
        },
        {
          "fls_id": "fls_2d6bqnpy6tvs",
          "fls_title": "Function-like Macros",
          "category": 0,
          "score": 0.64,
          "reason": "FLS defines function-like macros as 'a procedural macro that consumes a stream of tokens and produces a stream of tokens.' Unlike C macros, Rust's procedural macros are type-aware and hygienic, reducing but not eliminating the preference for functions."
        },
        {
          "fls_id": "fls_ypio6boj3pwf",
          "fls_title": "Attribute inline",
          "category": 0,
          "score": 0.59,
          "reason": "FLS defines the inline attribute for functions, providing the performance benefits of macros without sacrificing type safety. This addresses MISRA's note about inline functions as an alternative."
        },
        {
          "fls_id": "fls_AAYJDCNMJgTq",
          "fls_title": "Functions",
          "category": -2,
          "score": 0.68,
          "reason": "Per FLS: 'The type of a function parameter is determined as follows...' This establishes compile-time type checking for function parameters."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "recommended",
      "confidence": "medium",
      "notes": "Rust's macro system is hygienic and type-aware, making macros safer than C macros. However, the principle of preferring functions remains valid: functions provide explicit type checking, clearer debugging, and argument evaluation semantics. Rust's const fn and inline attributes provide alternatives when compile-time evaluation or performance is needed.",
      "rejected_matches": [
        {
          "fls_id": "fls_Sd6rUmpEb355",
          "fls_title": "Attribute naked",
          "category": 0,
          "score": 0.52,
          "reason": "About naked functions for low-level assembly, not relevant to macro vs function choice."
        }
      ]
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Dir 4.10",
      "guideline_title": "Precautions shall be taken in order to prevent the contents of a header file being included more than once",
      "guideline_type": "directive",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_maw4u1o8q37u",
            "fls_title": "Crates",
            "category": 0,
            "score": 0.66,
            "reason": "Per FLS: 'A crate is a unit of compilation and linking that contains a tree of nested modules.' Rust uses modules, not textual header inclusion."
          },
          {
            "fls_id": "fls_9gprp17h6t1q",
            "fls_title": "Use Imports",
            "category": 0,
            "score": 0.61,
            "reason": "Per FLS: Use imports bring names into scope without textual inclusion. A module is compiled once regardless of how many places import it."
          },
          {
            "fls_id": "fls_e9hwvqsib5d5",
            "fls_title": "Modules",
            "category": 0,
            "score": 0.45,
            "reason": "Per FLS: Modules define namespace boundaries. There is no concept of 'including' a file's text - each module is a distinct compilation unit."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "MISRA Dir 4.10 addresses C header guard issues. Rust has NO header files - it uses a module system where each module is compiled exactly once. The 'use' statement imports names, not text. Multiple 'use' statements for the same module don't cause redefinition - they just bring names into scope. The problem MISRA addresses (textual inclusion causing duplicate definitions) cannot occur in Rust."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_maw4u1o8q37u",
            "fls_title": "Crates",
            "category": 0,
            "score": 0.58,
            "reason": "Per FLS: Crates are compilation units with module trees. No textual inclusion mechanism exists."
          },
          {
            "fls_id": "fls_9gprp17h6t1q",
            "fls_title": "Use Imports",
            "category": 0,
            "score": 0.49,
            "reason": "Per FLS: Use imports bring names into scope without duplicating definitions."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Same as all_rust. Safe Rust has the same module system - no header files exist to be multiply included."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Dir 4.11",
      "guideline_title": "The validity of values passed to library functions shall be checked C90",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_dzq9cdz4ibsz",
          "fls_title": "Exceptions and Errors",
          "category": 0,
          "score": 0.5,
          "reason": "FLS Chapter 16 establishes Rust's error handling model. Per FLS: 'A possibly absent value is usually represented using enum core::option::Option' and 'The result of a possibly erroneous computation is usually represented using enum core::result::Result.' Rust library functions return Option/Result rather than using restricted domains with undefined behavior."
        },
        {
          "fls_id": "fls_lv7w7aalpwm5",
          "fls_title": "Type Inference",
          "category": 0,
          "score": 0.54,
          "reason": "FLS defines Rust's type inference system which catches type mismatches at compile time. This provides stronger static checking than runtime validation of input domains."
        },
        {
          "fls_id": "fls_juysxea25owj",
          "fls_title": "Char Type",
          "category": -4,
          "score": 0.58,
          "reason": "FLS defines validity invariants: 'It is a validity invariant for a value of type char to be inside the 0x000 - 0xD7FF or the 0xE000 - 0x10FFFF inclusive ranges.' This demonstrates how Rust defines valid value ranges at the type level."
        },
        {
          "fls_id": "fls_2sd39mj05mb9",
          "fls_title": "Bool Type",
          "category": -4,
          "score": 0.57,
          "reason": "Per FLS: 'It is a validity invariant for a value of type bool to have a bit pattern of 0x00 and 0x01.' Rust enforces value validity through type invariants rather than runtime checks."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "advisory",
      "confidence": "medium",
      "notes": "Rust addresses this differently than C. Instead of requiring runtime validation of restricted domains, Rust: (1) uses Option<T> for possibly-absent values, (2) uses Result<T,E> for fallible operations, (3) defines validity invariants at the type level, (4) uses the type system to prevent invalid values. For example, Rust's sqrt returns Option<f64> rather than having undefined behavior for negative inputs. The MISRA concern is addressed through Rust's type-driven design rather than manual precondition checking.",
      "rejected_matches": [
        {
          "fls_id": "fls_B0SMXRqQMS1E",
          "fls_title": "Function Pointer Types",
          "category": -2,
          "score": 0.61,
          "reason": "About C-like variadic parameters, not about validating function inputs."
        }
      ]
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Dir 4.12",
      "guideline_title": "Dynamic memory allocation shall not be used",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "misra_rust_category": "advisory",
      "confidence": "medium",
      "notes": "MISRA concern is about unpredictable malloc/free behavior. Rust provides: (1) #[no_std] for bare-metal development without heap, (2) #[global_allocator] for custom allocator control, (3) explicit opt-in to alloc crate for heap types. Unlike C where malloc/free are always available, Rust requires explicit crate inclusion for heap allocation, making allocation policy more controllable and auditable.",
      "accepted_matches": [
        {
          "fls_id": "fls_fs0lcfllamj",
          "fls_title": "Attribute global_allocator",
          "category": 0,
          "score": 0.62,
          "reason": "FLS global_allocator attribute controls memory allocation, allowing custom allocators that can enforce allocation policies"
        },
        {
          "fls_id": "fls_9xnaxd7qbakp",
          "fls_title": "Attribute no_std",
          "category": 0,
          "score": 0.6,
          "reason": "FLS no_std attribute removes std library, enabling embedded/bare-metal development without heap allocation"
        },
        {
          "fls_id": "fls_94a8v54bufn8",
          "fls_title": "Values",
          "category": 0,
          "score": 0.46,
          "reason": "FLS Values section defines allocated objects and their memory layout, providing foundation for understanding allocation"
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "direct_mapping"
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Dir 4.13",
      "guideline_title": "Functions which are designed to provide operations on a resource should be called in an appropriate sequence",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_svkx6szhr472",
          "fls_title": "Ownership",
          "category": 0,
          "score": 0.6,
          "reason": "FLS defines ownership as 'central to the resource management model of Rust.' Per FLS: 'A value shall have only one owner.' This ensures resources have clear ownership and lifecycle."
        },
        {
          "fls_id": "fls_u2mzjgiwbkz0",
          "fls_title": "Destructors",
          "category": 0,
          "score": 0.55,
          "reason": "FLS defines destructors: 'A destructor is a function that is invoked immediately before the destruction of a value of a drop type.' Drop ensures cleanup happens automatically when values go out of scope - enforcing proper sequencing."
        },
        {
          "fls_id": "fls_4jiw35pan7vn",
          "fls_title": "Destruction",
          "category": 0,
          "score": 0.55,
          "reason": "Per FLS: 'Destruction is the process of recovering resources associated with a value as it goes out of scope.' This guarantees deallocation functions are called in the correct sequence."
        },
        {
          "fls_id": "fls_e7ucq87s806d",
          "fls_title": "Destruction",
          "category": -2,
          "score": 0.55,
          "reason": "FLS explicitly states destruction 'is the process of recovering resources associated with a value as it goes out of scope' - directly addressing MISRA's concern about resource deallocation."
        }
      ],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Rust's ownership system and Drop trait provide compile-time enforcement of proper resource sequencing. Resources are automatically cleaned up when they go out of scope via destructors. RAII pattern is built into the language - the compiler ensures deallocation happens, and in the correct order (reverse order of acquisition). This is stronger than MISRA's requirement for static analysis checks.",
      "rejected_matches": [
        {
          "fls_id": "fls_xdvdl2ssnhlo",
          "fls_title": "Statics",
          "category": 0,
          "score": 0.62,
          "reason": "About static variables, not resource sequencing."
        },
        {
          "fls_id": "fls_zJOAmSr3Dbqk",
          "fls_title": "Diverging Expressions",
          "category": 0,
          "score": 0.61,
          "reason": "About diverging expressions (never type), not resource management."
        }
      ]
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Dir 4.14",
      "guideline_title": "The validity of values received from external sources shall be checked C90",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_osd6c4utyjb3",
          "fls_title": "FFI",
          "category": 0,
          "score": 0.57,
          "reason": "FLS Chapter 21 defines FFI for interfacing with foreign code. Per FLS: 'Foreign Function Interface or FFI employs ABI, attributes, external blocks, external functions, linkage, and type layout to interface a Rust program with foreign code.' External data comes through FFI boundaries."
        },
        {
          "fls_id": "fls_yztwtek0y34v",
          "fls_title": "External Functions",
          "category": 0,
          "score": 0.59,
          "reason": "FLS defines external functions which are the interface point for external data. Per FLS: 'An external function shall be invoked from an unsafe context' - requiring explicit unsafe blocks acknowledges the trust boundary."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "fls_title": "Unsafety",
          "category": 0,
          "score": 0.53,
          "reason": "FLS Chapter 19 defines unsafe contexts. External data handling typically requires unsafe code in Rust, making the boundary explicit and requiring programmer attestation of safety invariants."
        },
        {
          "fls_id": "fls_dzq9cdz4ibsz",
          "fls_title": "Exceptions and Errors",
          "category": 0,
          "score": 0.5,
          "reason": "Rust's Result/Option types provide mechanisms for representing validation outcomes. External data can be validated and wrapped in Result<T,E> to propagate validation failures."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Rust addresses external data validation through: (1) FFI boundaries require unsafe, making external interfaces explicit, (2) Type system enforces that raw external data must be converted to Rust types, providing natural validation points, (3) Result/Option types encode validation success/failure. While Rust doesn't automatically validate external data, it makes the boundaries explicit and provides idioms (FromStr, TryFrom, etc.) for safe parsing with error handling.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Dir 4.15",
      "guideline_title": "Evaluation of floating-point expressions shall not lead to the undetected generation of infinities and NaNs C90",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_b4xporvr64s",
          "fls_title": "Floating Point Types",
          "category": 0,
          "score": 0.54,
          "reason": "FLS defines f32/f64 as IEEE 754-2008 binary32/binary64 types. Per FLS: 'Type f32 is equivalent to the IEEE 754-2008 binary32 type.' This establishes the foundation for NaN/infinity semantics."
        },
        {
          "fls_id": "fls_nuFAwLHOdQBx",
          "fls_title": "Floating Point Types",
          "category": 0,
          "score": 0.64,
          "reason": "FLS documents NaN behavior explicitly: 'Operations on values of floating point types may not preserve the sign bit in case of the value being a IEEE floating-point NaN.' Directly addresses MISRA's concern about NaN handling."
        },
        {
          "fls_id": "fls_JP8YSbxSN0Ym",
          "fls_title": "Literal Patterns",
          "category": -2,
          "score": 0.55,
          "reason": "FLS prohibits NaN in pattern matching: 'A numeric literal pattern's numeric literal value shall not be a IEEE floating-point NaN.' This forces explicit handling of NaN values."
        },
        {
          "fls_id": "fls_cx86k8yfjhht",
          "fls_title": "Type Cast Expressions",
          "category": -3,
          "score": 0.5,
          "reason": "FLS documents infinity generation: 'Produces f32::INFINITY or f64::INFINITY of the same sign as the value of the operand when the value of the operand causes arithmetic overflow.'"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "misra_rust_comment": "Rust implements IEEE-754",
      "confidence": "medium",
      "notes": "Rust follows IEEE-754/IEC 60559 for floating-point types. The standard library provides is_nan(), is_infinite(), is_finite() methods on f32/f64 for detection. FLS explicitly documents NaN and infinity behavior. Projects should use these methods or checked arithmetic for detection.",
      "rejected_matches": []
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Dir 5.1",
      "guideline_title": "There shall be no data races between threads C11 [Undefined 5]",
      "guideline_type": "directive",
      "all_rust": {
        "applicability": "yes",
        "adjusted_category": "required",
        "rationale_type": "direct_mapping",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_3v733mnewssy",
            "fls_title": "Concurrency",
            "category": 0,
            "score": 0.86,
            "reason": "Parent chapter defining data races. Per FLS: 'A data race is a scenario where two or more threads access a shared memory location concurrently without any synchronization, where one of the accesses is a modification.' Directly matches MISRA Dir 5.1 definition."
          },
          {
            "fls_id": "fls_tx4b8r6i93n4",
            "fls_title": "Data race definition",
            "category": -2,
            "score": 0.74,
            "reason": "Per FLS legality rule: 'A data race is a scenario where two or more threads access a shared memory location concurrently without any synchronization, where one of the accesses is a modification.' This definition matches MISRA Dir 5.1's definition exactly and provides a citable paragraph."
          },
          {
            "fls_id": "fls_isypweqewe78",
            "fls_title": "Concurrency undefined_behavior",
            "category": -4,
            "score": 0.77,
            "reason": "Per FLS: 'It is undefined behavior if two or more threads engage in a data race.' This is the core rule MISRA Dir 5.1 addresses."
          },
          {
            "fls_id": "fls_eiw4by8z75di",
            "fls_title": "Send and Sync",
            "category": 0,
            "score": 0.67,
            "reason": "Per FLS: Send/Sync traits 'prevent data races at the type level'. These marker traits are Rust's primary mechanism for enforcing thread safety."
          },
          {
            "fls_id": "fls_n5l17mlglq11",
            "fls_title": "Send and Sync legality",
            "category": -2,
            "score": 0.58,
            "reason": "Per FLS: 'The Rust programming language provides the core::marker::Send and core::marker::Sync traits for preventing data races at the type level.'"
          },
          {
            "fls_id": "fls_vyc9vcuamlph",
            "fls_title": "Atomics",
            "category": 0,
            "score": 0.67,
            "reason": "Atomic types provide safe shared-memory communication between threads with proper synchronization."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 1,
        "notes": "MISRA Dir 5.1 maps directly to Rust's concurrency model. FLS Chapter 17 defines data races identically to MISRA and declares them UB. The Send/Sync traits provide compile-time enforcement. However, unsafe code can bypass these protections (unsafe impl Send/Sync, raw pointer sharing), so the guideline remains applicable to all Rust code."
      },
      "safe_rust": {
        "applicability": "partial",
        "adjusted_category": "required",
        "rationale_type": "partial_mapping",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_eiw4by8z75di",
            "fls_title": "Send and Sync",
            "category": 0,
            "score": 0.61,
            "reason": "Per FLS: Send/Sync traits auto-derive for types whose fields are Send/Sync. In safe Rust, types must implement these traits to cross thread boundaries, providing compile-time data race prevention."
          },
          {
            "fls_id": "fls_n5l17mlglq11",
            "fls_title": "Send and Sync legality",
            "category": -2,
            "score": 0.57,
            "reason": "Per FLS: 'The Rust programming language provides the core::marker::Send and core::marker::Sync traits for preventing data races at the type level.' This is enforced at compile time in safe Rust."
          },
          {
            "fls_id": "fls_cax6fe4em23k",
            "fls_title": "Send and Sync legality",
            "category": -2,
            "score": 0.52,
            "reason": "Per FLS: 'An abstract data type automatically implements the core::marker::Send trait if the types of all its fields are send types.' Auto-derivation ensures type safety."
          },
          {
            "fls_id": "fls_omaq7psg83n3",
            "fls_title": "Interior Mutability",
            "category": 0,
            "score": 0.63,
            "reason": "Per FLS: Interior mutability via UnsafeCell allows mutation through shared references. Types like Cell/RefCell are !Sync, preventing sharing across threads, but logic errors remain possible."
          },
          {
            "fls_id": "fls_a14slch83hzn",
            "fls_title": "Borrowing",
            "category": 0,
            "score": 0.64,
            "reason": "The borrow checker prevents aliasing mutable references at compile time, which prevents a class of data races in safe Rust."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 1,
        "notes": "Safe Rust provides strong compile-time data race prevention via Send/Sync traits and the borrow checker. However, MISRA ADD-6 marks this as 'Partial' because: (1) Interior mutability types can cause logic races even if not strict data races; (2) Incorrect use of synchronization primitives (e.g., forgetting to hold a lock guard) can still lead to race conditions; (3) The guideline's intent around thread safety discipline still applies. The compiler prevents most data races, but not all concurrency bugs."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Dir 5.2",
      "guideline_title": "There shall be no deadlocks between threads",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_3v733mnewssy",
          "fls_title": "Concurrency",
          "category": 0,
          "score": 0.55,
          "reason": "FLS Chapter 17 establishes Rust's concurrency model. Per FLS: 'The Rust programming language provides features for concurrent programming without data races.' Rust prevents data races at compile time, which addresses one class of concurrency bugs."
        },
        {
          "fls_id": "fls_eiw4by8z75di",
          "fls_title": "Send and Sync",
          "category": 0,
          "score": 0.55,
          "reason": "FLS defines Send and Sync traits: 'The Rust programming language provides the core::marker::Send and core::marker::Sync traits for preventing data races at the type level.' These provide compile-time guarantees about thread safety."
        },
        {
          "fls_id": "fls_zgemofbs5q2x",
          "fls_title": "Send and Sync",
          "category": -2,
          "score": 0.63,
          "reason": "Per FLS: 'A sync type shall have values that are allowed to be shared across multiple threads at any given time without incurring data races.' This establishes thread-sharing invariants."
        },
        {
          "fls_id": "fls_vyc9vcuamlph",
          "fls_title": "Atomics",
          "category": 0,
          "score": 0.45,
          "reason": "FLS defines atomic types for 'primitive shared-memory communication between threads.' Atomics are building blocks for synchronization primitives."
        }
      ],
      "fls_rationale_type": "partial_mapping",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Rust's type system prevents data races at compile time through Send/Sync traits, but does NOT prevent deadlocks. Deadlock prevention requires runtime mechanisms (lock ordering, try_lock, timeouts) or design patterns. The FLS addresses data races but deadlocks remain a programmer responsibility. This is a partial mapping - Rust helps with concurrency safety but does not fully address MISRA's deadlock concern.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Dir 5.3",
      "guideline_title": "There shall be no dynamic thread creation C11",
      "guideline_type": "directive",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_3v733mnewssy",
          "fls_title": "Concurrency",
          "category": 0,
          "score": 0.56,
          "reason": "FLS Concurrency chapter defines data races and thread safety at the language level"
        },
        {
          "fls_id": "fls_eiw4by8z75di",
          "fls_title": "Send and Sync",
          "category": 0,
          "score": 0.51,
          "reason": "FLS Send and Sync traits provide compile-time thread safety guarantees, preventing data races"
        },
        {
          "fls_id": "fls_9xnaxd7qbakp",
          "fls_title": "Attribute no_std",
          "category": 0,
          "score": 0.4,
          "reason": "FLS no_std enables bare-metal development without std library thread spawning capabilities"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "MISRA concern is about unpredictable thread creation overhead and analyzability. Thread creation in Rust is a library feature (std::thread::spawn), not a language primitive. The FLS defines: (1) Send/Sync traits for compile-time thread safety, (2) data race UB definition. With #[no_std], thread spawning is not available by default. Static thread pools would be implemented via library constructs, not language features. The FLS provides safety infrastructure but thread creation policy is a library/project concern.",
      "rejected_matches": [
        {
          "fls_id": "fls_k02nt1m5fq1z",
          "fls_title": "Panic",
          "category": -3,
          "score": 0.56,
          "reason": "Panic section mentions thread execution halting but is about panic handling, not thread creation"
        }
      ]
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 1.1",
      "guideline_title": "The program shall contain no violations of the standard C syntax and constraints, and shall not exceed the implementation\u2019s translation limits",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "accepted_matches": [
        {
          "fls_id": "fls_99b7xi1bkgih",
          "fls_title": "Conformity",
          "category": 0,
          "score": 0.59,
          "reason": "FLS section 1.3 defines tool conformity. Lists explicit requirements for conforming tools including translation of legal programs and error detection."
        },
        {
          "fls_id": "fls_dBKu9jgx3OyH",
          "fls_title": "Conformity",
          "category": -5,
          "score": 0.56,
          "reason": "FLS implementation requirement: 'Correctly translate legal programs written in Rust.' Establishes baseline for correct compilation."
        },
        {
          "fls_id": "fls_GZmxrO61eiJ1",
          "fls_title": "Conformity",
          "category": -5,
          "score": 0.56,
          "reason": "FLS implementation requirement: 'Reject programs that contain errors whose detection is required by this document.' Rust compilers must reject syntactically invalid programs."
        },
        {
          "fls_id": "fls_lkdm0mdghppv",
          "fls_title": "Conformity",
          "category": -5,
          "score": 0.58,
          "reason": "FLS: 'A tool that conforms to this document shall support each capability required by the language as specified.' Establishes comprehensive conformity requirement."
        },
        {
          "fls_id": "fls_10yukmkhl0ng",
          "fls_title": "Extent",
          "category": 0,
          "score": 0.52,
          "reason": "FLS Extent section specifies 'The violations that a conforming tool is required to detect.' Defines scope of required error detection."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Rust has a formal specification (FLS) that defines syntax and semantics. The rustc compiler strictly enforces the language grammar - any syntax errors or constraint violations result in compilation failure. Unlike C where some violations may go undetected, Rust's strong type system catches most issues at compile time.",
      "rejected_matches": [
        {
          "fls_id": "fls_dv1qish8svc",
          "fls_title": "Scope",
          "category": -1,
          "score": 0.59,
          "reason": "About FLS document scope and contribution process, not about language conformity requirements."
        }
      ]
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 1.3",
      "guideline_title": "There shall be no occurrence of undefined or critical unspecified behaviour",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_jep7p27kaqlp",
          "fls_title": "Unsafety",
          "category": 0,
          "score": 0.65,
          "reason": "FLS Chapter 19 defines unsafety. Per FLS: 'Unsafety is the presence of unsafe operations and unsafe trait implementations in program text.' Rust isolates UB-capable operations."
        },
        {
          "fls_id": "fls_ovn9czwnwxue",
          "fls_title": "Unsafety",
          "category": -2,
          "score": 0.63,
          "reason": "FLS defines unsafe operations: 'An unsafe operation is an operation that may result in undefined behavior that is not diagnosed as a static error.' Explicit enumeration of UB sources."
        },
        {
          "fls_id": "fls_ybnpe7ppq1vh",
          "fls_title": "Unsafety",
          "category": -2,
          "score": 0.6,
          "reason": "FLS legality rule: 'An unsafe operation shall be used only within an unsafe context.' Compiler enforces that UB-capable operations require explicit unsafe blocks."
        },
        {
          "fls_id": "fls_9wgldua1u8yt",
          "fls_title": "Dereference Expression",
          "category": -4,
          "score": 0.65,
          "reason": "FLS documents specific UB: 'It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.' UB scenarios are explicitly documented."
        },
        {
          "fls_id": "fls_70qjvaqoz007",
          "fls_title": "Structure",
          "category": -4,
          "score": 0.59,
          "reason": "FLS defines undefined behavior category as 'Situations that result in unbounded errors.' All UB is explicitly documented in FLS."
        }
      ],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Rust's core design goal is memory safety without garbage collection. Safe Rust (code without 'unsafe' keyword) cannot exhibit undefined behavior - the compiler statically prevents it through the type system and borrow checker. UB is only possible in unsafe blocks, which must be explicitly marked. This is stronger than MISRA's requirement - Rust prevents UB by construction in safe code.",
      "rejected_matches": []
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 1.4",
      "guideline_title": "Emergent language features shall not be used",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_9cd746qe40ag",
            "fls_title": "Versioning",
            "category": 0,
            "score": 0.572,
            "reason": "FLS documents specific compiler version behavior - Ferrocene provides qualified compiler with accompanying specification updated per qualification, unlike C where new standards introduce emergent features"
          },
          {
            "fls_id": "fls_fo1c7pg2mw1",
            "fls_title": "Scope",
            "category": 0,
            "score": 0.571,
            "reason": "FLS specifies 2021 Edition of Rust as implemented by rustc - Rust uses edition system and stable/nightly channels to control feature availability unlike C emergent features"
          },
          {
            "fls_id": "fls_99b7xi1bkgih",
            "fls_title": "Conformity",
            "category": 0,
            "score": 0.572,
            "reason": "FLS Conformity section defines tool requirements for conforming implementations - no concept of emergent features with unknown behavior"
          }
        ],
        "rejected_matches": [
          {
            "fls_id": "fls_jep7p27kaqlp",
            "fls_title": "Unsafety",
            "category": -1,
            "score": 0.738,
            "reason": "Unsafety is about unsafe blocks and operations, not emergent language features - high similarity score is misleading"
          }
        ],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust handles new features differently than C: (1) Edition system gates breaking changes to explicit opt-in, (2) Stable channel only allows well-tested features, (3) FLS/Ferrocene documents specific version behavior. The C problem of emergent features with undefined/unspecified behavior does not apply to Rust."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_9cd746qe40ag",
            "fls_title": "Versioning",
            "category": 0,
            "score": 0.572,
            "reason": "Rust editions and Ferrocene versioning ensure documented behavior - no emergent feature uncertainty"
          },
          {
            "fls_id": "fls_fo1c7pg2mw1",
            "fls_title": "Scope",
            "category": 0,
            "score": 0.571,
            "reason": "FLS specifies 2021 Edition behavior - edition system controls feature availability"
          },
          {
            "fls_id": "fls_99b7xi1bkgih",
            "fls_title": "Conformity",
            "category": 0,
            "score": 0.572,
            "reason": "Conformity requirements for tools ensure consistent behavior across qualified implementations"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust has even stronger guarantees than all Rust - all features in stable safe Rust are well-defined with no undefined behavior possible. The edition system and stable channel ensure no emergent features with unknown behavior."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 1.5",
      "guideline_title": "Obsolescent language features shall not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_9cd746qe40ag",
          "fls_title": "Versioning",
          "category": 0,
          "score": 0.566,
          "reason": "Rust editions provide a mechanism for evolving the language while maintaining backward compatibility. Obsolescent features are migrated across editions with tooling support."
        },
        {
          "fls_id": "fls_s5z2q5pl14p4",
          "fls_title": "Built-in Attributes - deprecated",
          "category": -2,
          "score": 0.535,
          "reason": "The #[deprecated] attribute marks items as obsolescent, generating compiler warnings when used. This directly addresses MISRA's concern about obsolescent features."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "this applies to deprecated APIs",
      "confidence": "medium",
      "notes": "Rust handles obsolescent features through editions and the deprecated attribute. MISRA ADD-6 notes this applies to deprecated APIs in Rust.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 2.1",
      "guideline_title": "A project shall not contain unreachable code",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "misra_rust_category": "advisory",
      "confidence": "medium",
      "notes": "MISRA concern is about unreachable code indicating logic errors or wasted resources. Rust provides: (1) Language-level reachability via diverging expressions and never type (!), (2) Compiler lint unreachable_code that warns about code after diverging expressions, (3) Diagnostics attributes (#[allow], #[deny], #[warn], #[forbid]) for lint control. The FLS defines the language semantics of reachability; lint enforcement is a tooling concern controlled via diagnostics attributes.",
      "accepted_matches": [
        {
          "fls_id": "fls_zJOAmSr3Dbqk",
          "fls_title": "Diverging Expressions",
          "category": 0,
          "score": 0.62,
          "reason": "FLS defines diverging expressions (break, return, loop, panic, never type) which determine reachability at the language level"
        },
        {
          "fls_id": "fls_t2590yyvclgb",
          "fls_title": "Diagnostics Attributes",
          "category": 0,
          "score": 0.4,
          "reason": "FLS defines diagnostics attributes (allow, deny, warn, forbid) for controlling lint warnings including unreachable_code"
        },
        {
          "fls_id": "fls_jr4tpuyksr75",
          "fls_title": "Break Expressions",
          "category": 0,
          "score": 0.55,
          "reason": "FLS break expressions cause control flow to diverge, making subsequent code unreachable"
        },
        {
          "fls_id": "fls_sf4qnd43z2wc",
          "fls_title": "Infinite Loops",
          "category": 0,
          "score": 0.58,
          "reason": "FLS infinite loops without break have never type, indicating code after them is unreachable"
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "direct_mapping"
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 2.2",
      "guideline_title": "A project shall not contain dead code",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "MISRA concern is about dead code (executes but has no effect) indicating logic errors. Rust provides: (1) Compiler lint dead_code that warns about unused functions, structs, etc., (2) unused_variables, unused_assignments lints for unused bindings, (3) Diagnostics attributes for lint control. The FLS defines language semantics; dead code detection is a tooling concern controlled via diagnostics attributes. Rust's ownership system also helps identify dead code through unused value warnings.",
      "accepted_matches": [
        {
          "fls_id": "fls_t2590yyvclgb",
          "fls_title": "Diagnostics Attributes",
          "category": 0,
          "score": 0.4,
          "reason": "FLS defines diagnostics attributes (allow, deny, warn, forbid) for controlling lint warnings including dead_code"
        },
        {
          "fls_id": "fls_3xvm61x0t251",
          "fls_title": "Initialization",
          "category": 0,
          "score": 0.55,
          "reason": "FLS Initialization section defines when values are initialized and used, foundational for dead code analysis"
        },
        {
          "fls_id": "fls_zJOAmSr3Dbqk",
          "fls_title": "Diverging Expressions",
          "category": 0,
          "score": 0.5,
          "reason": "FLS diverging expressions affect code reachability and dead code detection"
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "direct_mapping"
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 2.3",
      "guideline_title": "A project should not contain unused type declarations",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_c5n4gzgs79vv",
          "fls_title": "Built-in Attributes - allow",
          "category": -2,
          "score": 0.533,
          "reason": "FLS defines the #[allow] attribute for controlling lint behavior. Combined with rustc's dead_code lint, unused types can be detected or suppressed."
        },
        {
          "fls_id": "fls_29y8icoou1gx",
          "fls_title": "Built-in Attributes - warn",
          "category": -2,
          "score": 0.544,
          "reason": "FLS defines #[warn] attribute. Rustc warns on dead_code by default, catching unused type declarations."
        },
        {
          "fls_id": "fls_jdknpu3kf865",
          "fls_title": "Visibility",
          "category": 0,
          "score": 0.544,
          "reason": "FLS defines visibility rules for items. Private items not used within their module scope are candidates for dead_code detection."
        }
      ],
      "fls_rationale_type": "partial_mapping",
      "misra_rust_category": "recommended",
      "confidence": "medium",
      "notes": "FLS provides the lint mechanism but specific lints like dead_code are compiler implementation. Rustc's dead_code lint is enabled by default and warns on unused type declarations, addressing MISRA's concern through tooling rather than language specification.",
      "rejected_matches": []
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 2.4",
      "guideline_title": "A project should not contain unused tag declarations",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_9ucqbbd0s2yo",
            "fls_title": "Struct Types",
            "category": 0,
            "score": 0.604,
            "reason": "Rust has struct type definitions, not C-style tag declarations - structs must be fully defined where declared"
          },
          {
            "fls_id": "fls_t2590yyvclgb",
            "fls_title": "Diagnostics Attributes",
            "category": 0,
            "score": 0.405,
            "reason": "Diagnostic attributes relate to linting including dead_code warnings - Rust compiler warns on unused types by default"
          },
          {
            "fls_id": "fls_szibmtfv117b",
            "fls_title": "Enum Types",
            "category": 0,
            "score": 0.62,
            "reason": "Rust enum declarations are type definitions. The compiler warns about unused types by default (dead_code lint)."
          }
        ],
        "rejected_matches": [
          {
            "fls_id": "fls_kgvleup5mdhq",
            "fls_title": "Type Aliases",
            "category": 0,
            "score": 0.691,
            "reason": "Type aliases are not equivalent to C tag declarations - aliases must reference existing types"
          }
        ],
        "verified": true,
        "verified_by_session": 2,
        "notes": "C tag declarations (forward declarations like 'struct foo;') do not exist in Rust. Rust requires full type definitions at declaration. Unused type definitions trigger dead_code lint warnings by default. The concept of unused tag declarations is inapplicable."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_9ucqbbd0s2yo",
            "fls_title": "Struct Types",
            "category": 0,
            "score": 0.604,
            "reason": "Rust structs are definitions not declarations - no forward declaration concept"
          },
          {
            "fls_id": "fls_t2590yyvclgb",
            "fls_title": "Diagnostics Attributes",
            "category": 0,
            "score": 0.405,
            "reason": "Rust linting handles unused type warnings"
          },
          {
            "fls_id": "fls_szibmtfv117b",
            "fls_title": "Enum Types",
            "category": 0,
            "score": 0.62,
            "reason": "Rust enum declarations are type definitions. The compiler warns about unused types by default (dead_code lint)."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust has no tag declarations. Type definitions are required to be complete."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 2.5",
      "guideline_title": "A project should not contain unused macro definitions",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_qxjy0f758x5s",
          "fls_title": "Attribute macro_use",
          "category": 0,
          "score": 0.599,
          "reason": "FLS defines macro_use for importing macros. Unused macro detection relies on tooling analyzing which macros are actually invoked."
        },
        {
          "fls_id": "fls_e0a96eb6ux3y",
          "fls_title": "Attribute macro_export",
          "category": 0,
          "score": 0.487,
          "reason": "FLS defines macro_export for public macro visibility. Exported but unused macros may indicate dead code."
        },
        {
          "fls_id": "fls_c5n4gzgs79vv",
          "fls_title": "Built-in Attributes - allow",
          "category": -2,
          "score": 0.533,
          "reason": "FLS lint mechanism allows controlling unused_macros warnings via #[allow(unused_macros)]."
        }
      ],
      "fls_rationale_type": "partial_mapping",
      "misra_rust_category": "recommended",
      "confidence": "medium",
      "notes": "FLS defines macro visibility and scoping, but unused macro detection is a compiler lint (unused_macros). Rustc warns on unused macros by default. The concern maps to Rust through tooling rather than language specification.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 2.6",
      "guideline_title": "A function should not contain unused label declarations",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_769b4p8v3cwu",
          "fls_title": "Label Scope",
          "category": 0,
          "score": 0.69,
          "reason": "FLS Label Scope defines that labels are in scope within the block expression of the related loop expression"
        },
        {
          "fls_id": "fls_uusi0zej55is",
          "fls_title": "Loop Labels",
          "category": 0,
          "score": 0.59,
          "reason": "FLS Loop Labels define named loops for break/continue targeting, not goto labels"
        },
        {
          "fls_id": "fls_7hc8yboeaho0",
          "fls_title": "Loop Labels legality",
          "category": -2,
          "score": 0.54,
          "reason": "FLS requires label indication to refer to an enclosing named block or loop expression"
        },
        {
          "fls_id": "fls_t2590yyvclgb",
          "fls_title": "Diagnostics Attributes",
          "category": 0,
          "score": 0.4,
          "reason": "FLS diagnostics attributes control lint warnings including unused_labels"
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "recommended",
      "confidence": "medium",
      "notes": "MISRA concern is about C goto labels being declared but not used. Rust has NO goto statement. Rust labels are for naming loops/blocks to target with break/continue. The FLS defines: (1) Label Scope - labels are scoped to their loop/block, (2) Loop Labels - syntax and semantics for named loops. The compiler provides unused_labels lint for detecting labels not referenced by break/continue. This is a significant Rust alternative - structured loop control instead of arbitrary goto.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 2.7",
      "guideline_title": "A function should not contain unused parameters",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_qcb1n9c0e5hz",
          "fls_title": "Functions",
          "category": 0,
          "score": 0.44,
          "reason": "FLS Functions section defines function parameters and their binding semantics"
        },
        {
          "fls_id": "fls_uwuthzfgslif",
          "fls_title": "Function parameter binding",
          "category": -2,
          "score": 0.63,
          "reason": "FLS defines function parameters as constructs that yield bindings for matched input values"
        },
        {
          "fls_id": "fls_qfsfnql1t7m",
          "fls_title": "Underscore Patterns",
          "category": 0,
          "score": 0.6,
          "reason": "FLS underscore pattern matches any value without binding, providing mechanism for intentionally unused parameters"
        },
        {
          "fls_id": "fls_t2590yyvclgb",
          "fls_title": "Diagnostics Attributes",
          "category": 0,
          "score": 0.4,
          "reason": "FLS diagnostics attributes control lint warnings including unused_variables"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "recommended",
      "confidence": "medium",
      "notes": "MISRA concern is about unused function parameters indicating spec/implementation mismatch. Rust provides: (1) Compiler lint unused_variables warns about unused parameters, (2) Underscore prefix (_param) or underscore pattern (_) explicitly marks intentionally unused parameters, (3) Trait implementations may require unused parameters for API conformance. The FLS defines function parameters and underscore patterns; lint enforcement is tooling.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 2.8",
      "guideline_title": "A project should not contain unused object definitions",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "misra_rust_category": "recommended",
      "confidence": "medium",
      "notes": "MISRA concern is about unused object definitions indicating redundant code. Rust provides: (1) Compiler lint dead_code warns about unused structs, enums, functions, constants, (2) #[used] attribute explicitly marks items that should not be optimized away, (3) Visibility modifiers (pub) indicate intended external usage. The FLS defines items and their declaration; unused item detection is tooling.",
      "accepted_matches": [
        {
          "fls_id": "fls_151r19d7xbgz",
          "fls_title": "Entities",
          "category": 0,
          "score": 0.46,
          "reason": "FLS Entities section defines items (structs, enums, functions, etc.) that can be unused"
        },
        {
          "fls_id": "fls_7skf24auayqy",
          "fls_title": "Attribute used",
          "category": 0,
          "score": 0.44,
          "reason": "FLS #[used] attribute prevents the linker from removing a static, indicating intentional retention"
        },
        {
          "fls_id": "fls_t2590yyvclgb",
          "fls_title": "Diagnostics Attributes",
          "category": 0,
          "score": 0.4,
          "reason": "FLS diagnostics attributes control lint warnings including dead_code for unused items"
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "direct_mapping"
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 3.1",
      "guideline_title": "The character sequences /* and // shall not be used within a comment",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_q8l2jza7d9xa",
          "fls_title": "Comments",
          "category": 0,
          "score": 0.6,
          "reason": "Per FLS syntax, BlockComment includes BlockCommentOrDoc recursively, allowing properly nested block comments. Rust's grammar explicitly supports /* within /* */ comments through nested BlockCommentOrDoc, unlike C. This addresses MISRA's concern about missing comment terminators."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "advisory",
      "misra_rust_comment": "nested comments are fully supported",
      "confidence": "medium",
      "notes": "Rust supports nested block comments by design, addressing MISRA's concern about /* within comments indicating missing */. The note that 'nested comments are fully supported' in MISRA ADD-6 confirms this.",
      "rejected_matches": [
        {
          "fls_id": "fls_6fxcs17n4kw",
          "fls_title": "Comments",
          "category": -2,
          "score": 0.63,
          "reason": "About carriage return in comments, not nested comment sequences"
        }
      ]
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 3.2",
      "guideline_title": "Line-splicing shall not be used in // comments",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_q8l2jza7d9xa",
            "fls_title": "Comments",
            "category": 0,
            "score": 0.63,
            "reason": "Per FLS fls_gy23lwlqw2mc - Line comments extend exactly one line. No line-splicing mechanism exists in Rust."
          },
          {
            "fls_id": "fls_fgnllgz5k3e6",
            "fls_title": "Lexical Elements Separators and Punctuation",
            "category": 0,
            "score": 0.47,
            "reason": "FLS defines line as sequence of characters followed by end of line - no continuation mechanism"
          }
        ],
        "rejected_matches": [
          {
            "fls_id": "fls_boyhlu5srp6u",
            "fls_title": "Simple String Literals",
            "category": 0,
            "score": 0.588,
            "reason": "String literal escape sequences are unrelated to comment line-splicing"
          }
        ],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no C-style preprocessor and no line-splicing mechanism. Per FLS fls_gy23lwlqw2mc: 'Line comments, inner line docs, and outer line docs shall extend exactly one line.' A backslash at end of a line comment has no special meaning in Rust - it is just part of the comment text."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_q8l2jza7d9xa",
            "fls_title": "Comments",
            "category": 0,
            "score": 0.63,
            "reason": "Line comments extend exactly one line per FLS - no line-splicing"
          },
          {
            "fls_id": "fls_fgnllgz5k3e6",
            "fls_title": "Lexical Elements Separators and Punctuation",
            "category": 0,
            "score": 0.47,
            "reason": "No continuation mechanism in Rust lexical structure"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust has no line-splicing. Same as all_rust."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 4.1",
      "guideline_title": "Octal and hexadecimal escape sequences shall be terminated C90",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "rust_prevents",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_2ed4axpsy9u0",
            "fls_title": "Integer Literals",
            "category": 0,
            "score": 0.76,
            "reason": "Per fls_4v7awnutbpoe: 'An octal literal is an integer literal in base 8' using 0o prefix. Octal is only for integer literals, never in string escapes."
          },
          {
            "fls_id": "fls_2ifjqwnw03ms",
            "fls_title": "Byte Literals",
            "category": 0,
            "score": 0.681,
            "reason": "FLS ByteEscape syntax requires exactly OctalDigit HexadecimalDigit after \\x - no ambiguity possible"
          },
          {
            "fls_id": "fls_ypa86oqxhn9u",
            "fls_title": "Character Literals",
            "category": 0,
            "score": 0.647,
            "reason": "AsciiEscape syntax same as ByteEscape - exactly 2 hex digits required. UnicodeEscape uses \\u{...} with explicit brace delimiters"
          },
          {
            "fls_id": "fls_boyhlu5srp6u",
            "fls_title": "Simple String Literals",
            "category": 0,
            "score": 0.691,
            "reason": "String literals use same AsciiEscape and UnicodeEscape syntax - all escapes are unambiguous by design"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust prevents this issue by design. Unlike C where \\x consumes all following hex digits and octal escapes consume 1-3 digits, Rust requires: (1) \\xHH with exactly 2 hex digits for ASCII/byte escapes, (2) \\u{NNNN} with explicit braces for Unicode escapes, (3) No octal escapes exist. The C problem of ambiguous escape sequence termination cannot occur."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "rust_prevents",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_2ed4axpsy9u0",
            "fls_title": "Integer Literals",
            "category": 0,
            "score": 0.76,
            "reason": "Octal is only for integer literals (0o prefix), never in string escapes."
          },
          {
            "fls_id": "fls_2ifjqwnw03ms",
            "fls_title": "Byte Literals",
            "category": 0,
            "score": 0.681,
            "reason": "Fixed-width hex escapes prevent ambiguity"
          },
          {
            "fls_id": "fls_ypa86oqxhn9u",
            "fls_title": "Character Literals",
            "category": 0,
            "score": 0.647,
            "reason": "Brace-delimited Unicode escapes are unambiguous"
          },
          {
            "fls_id": "fls_boyhlu5srp6u",
            "fls_title": "Simple String Literals",
            "category": 0,
            "score": 0.691,
            "reason": "All string escape sequences have unambiguous syntax"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust has the same escape sequence syntax as all Rust - issue is prevented by language design."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 4.2",
      "guideline_title": "Trigraphs should not be used",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_fgnllgz5k3e6",
            "fls_title": "Lexical Elements Separators and Punctuation",
            "category": 0,
            "score": 0.44,
            "reason": "FLS defines all punctuators explicitly - no trigraph substitution mechanism. Question mark is just a simple punctuator (fls_8ywv8gftsfr1)"
          },
          {
            "fls_id": "fls_411up5z0b6n6",
            "fls_title": "Lexical Elements",
            "category": 0,
            "score": 0.584,
            "reason": "Rust source files are sequences of lexical elements with no preprocessing phase that would perform trigraph substitution"
          }
        ],
        "rejected_matches": [
          {
            "fls_id": "fls_wjldgtio5o75",
            "fls_title": "Macro Expansion",
            "category": -2,
            "score": 0.65,
            "reason": "Rust macros operate on tokens, not source characters - no trigraph-like substitution"
          }
        ],
        "verified": true,
        "verified_by_session": 2,
        "notes": "C trigraphs are preprocessor sequences (like ??- for ~) that are replaced before tokenization. Rust has no preprocessor and no trigraph substitution. The question mark in Rust is simply a punctuator with no special multi-character behavior."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_fgnllgz5k3e6",
            "fls_title": "Lexical Elements Separators and Punctuation",
            "category": 0,
            "score": 0.44,
            "reason": "No trigraph mechanism in Rust"
          },
          {
            "fls_id": "fls_411up5z0b6n6",
            "fls_title": "Lexical Elements",
            "category": 0,
            "score": 0.584,
            "reason": "No preprocessor trigraph substitution"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust has no trigraphs - same as all Rust."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 5.1",
      "guideline_title": "External identifiers shall be distinct C90 [Undefined 7], C99 [Unspecified 7; Undefined 28], C11 [Unspecified 8; Undefined 31]",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "yes",
        "adjusted_category": "required",
        "rationale_type": "partial_mapping",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_21vnag69kbwe",
            "fls_title": "Identifiers",
            "category": 0,
            "score": 0.8,
            "reason": "Per FLS: defines identifier syntax and normalization rules. Rust identifiers have no character limit internally."
          },
          {
            "fls_id": "fls_j9yh8j8jgdeu",
            "fls_title": "Identifiers legality",
            "category": -2,
            "score": 0.7,
            "reason": "Per FLS: 'Two identifiers are considered the same if they consist of the same sequence of characters after performing normalization.' Rust handles Unicode normalization."
          },
          {
            "fls_id": "fls_p44fky7fifc",
            "fls_title": "Attribute link_name",
            "category": 0,
            "score": 0.65,
            "reason": "Per FLS: 'Attribute link_name shall specify the linking symbol of the related external function or external static.' This is where external C symbol naming applies."
          },
          {
            "fls_id": "fls_mvd7nz8k3wcy",
            "fls_title": "Attribute no_mangle",
            "category": 0,
            "score": 0.59,
            "reason": "Per FLS: 'Attribute no_mangle causes the related function or static to be publicly exported.' Exported symbols must be distinct and may be subject to platform linker limits."
          },
          {
            "fls_id": "fls_yztwtek0y34v",
            "fls_title": "External Functions",
            "category": 0,
            "score": 0.55,
            "reason": "External functions (in extern blocks) use C linkage and must follow external identifier rules."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 1,
        "notes": "MISRA Rule 5.1 (distinct external identifiers) applies to Rust's FFI boundary. Per MISRA ADD-6: 'no character limit, except in extern C'. Rust's internal identifiers have no limit, but #[no_mangle], #[link_name], and extern 'C' functions must produce distinct linker symbols. The guideline applies to all Rust code that interfaces with C."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_21vnag69kbwe",
            "fls_title": "Identifiers",
            "category": 0,
            "score": 0.8,
            "reason": "Per FLS: Rust identifiers have no character length limit. The concept of 'external identifiers' with C linkage limits doesn't exist in safe Rust."
          },
          {
            "fls_id": "fls_maw4u1o8q37u",
            "fls_title": "Crates",
            "category": 0,
            "score": 0.58,
            "reason": "Per FLS: 'A crate is a unit of compilation and linking that contains a tree of nested modules.' Rust's module system uses fully qualified paths, not C-style external linkage."
          },
          {
            "fls_id": "fls_9i5msiuuyihf",
            "fls_title": "Paths",
            "category": 0,
            "score": 0.52,
            "reason": "Rust uses path-based name resolution (crate::module::item), eliminating the C concept of short external linker symbols."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 1,
        "notes": "MISRA Rule 5.1 addresses C's 31/63 character limit for external identifiers. Per MISRA ADD-6: 'no character limit, except in extern C'. Safe Rust has no external C linkage - all symbols are name-mangled with fully qualified paths. The #[no_mangle] and extern 'C' attributes that create external identifiers require unsafe blocks or are themselves unsafe operations. Therefore, this guideline is not applicable to safe Rust code."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 5.2",
      "guideline_title": "Identifiers declared in the same scope and name space shall be distinct C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_21vnag69kbwe",
          "fls_title": "Identifiers",
          "category": 0,
          "score": 0.62,
          "reason": "Per FLS, Rust has no limit on significant identifier characters. fls_j9yh8j8jgdeu states: 'Two identifiers are considered the same if they consist of the same sequence of characters after performing normalization.' All characters are significant."
        },
        {
          "fls_id": "fls_j9yh8j8jgdeu",
          "fls_title": "Identifiers",
          "category": -2,
          "score": 0.66,
          "reason": "FLS enforces identifier comparison after Unicode NFC normalization. Unlike C which truncates identifiers, Rust treats all characters as significant."
        }
      ],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "required",
      "misra_rust_comment": "no character limit, but has name spaces",
      "confidence": "medium",
      "notes": "MISRA's concern about identifier length limits causing undefined behavior does not apply to Rust. Rust enforces full identifier comparison with Unicode normalization. The compiler will reject duplicate definitions in the same scope as a static error.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 5.3",
      "guideline_title": "An identifier declared in an inner scope shall not hide an identifier declared in an outer scope",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_ydmnb7qnmzzq",
          "fls_title": "Shadowing",
          "category": 0,
          "score": 0.59,
          "reason": "Per FLS fls_ob0riinmitkl: 'Shadowing is a property of names. A name is said to be shadowed when another name with the same characters is introduced in the same scope within the same namespace, effectively hiding it.'"
        },
        {
          "fls_id": "fls_lnpyb285qdiy",
          "fls_title": "Scope Hierarchy",
          "category": 0,
          "score": 0.6,
          "reason": "FLS defines explicit scope hierarchy with binding scopes and generic parameter scopes. Inner scope declarations can shadow outer scope names only for variables, macros, and prelude names."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "advisory",
      "misra_rust_comment": "this also applies to macro names",
      "confidence": "medium",
      "notes": "Rust explicitly defines and restricts shadowing. Per FLS: 'No name shall be shadowed except for Prelude names, macro names within textual macro scope, and variable names.' This makes shadowing intentional and controlled. Clippy lint 'shadow_unrelated' can detect unintentional shadowing.",
      "rejected_matches": []
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 5.4",
      "guideline_title": "Macro identifiers shall be distinct C90",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_xlfo7di0gsqz",
            "fls_title": "Hygiene",
            "category": 0,
            "score": 0.76,
            "reason": "Rust's macro hygiene system prevents name collisions between macro-introduced identifiers and surrounding code. Per FLS: 'Hygiene is a property of macros and identifiers that appear within them, which aims to eliminate the syntactic interference between a macro and its expansion environment.'"
          },
          {
            "fls_id": "fls_dq403wq5yrs",
            "fls_title": "Namespaces",
            "category": -2,
            "score": 0.58,
            "reason": "Rust segregates macros into a separate macro namespace. Per FLS: 'A namespace is a logical grouping of names such that the occurrence of a name in one namespace does not conflict with an occurrence of the same name in another namespace.'"
          },
          {
            "fls_id": "fls_21vnag69kbwe",
            "fls_title": "Identifiers",
            "category": 0,
            "score": 0.677,
            "reason": "FLS fls_j9yh8j8jgdeu states 'Two identifiers are considered the same if they consist of the same sequence of characters after performing normalization' - all characters are significant, no truncation"
          },
          {
            "fls_id": "fls_xa7lp0zg1ol2",
            "fls_title": "Declarative Macros",
            "category": 0,
            "score": 0.552,
            "reason": "Rust declarative macros use full identifier comparison, not C preprocessor semantics"
          },
          {
            "fls_id": "fls_wn1i6hzg2ff7",
            "fls_title": "Procedural Macros",
            "category": 0,
            "score": 0.513,
            "reason": "Procedural macros also use full identifier comparison"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "C has implementation-defined limits on significant characters in macro identifiers (31 in C90, 63 in C99+). Rust has no such limitation - all identifier characters are significant per FLS. Rust macros are not C preprocessor macros; they operate on tokens with full identifier comparison. Additionally, Rust's macro hygiene prevents name collisions and macros exist in a separate namespace."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_xlfo7di0gsqz",
            "fls_title": "Hygiene",
            "category": 0,
            "score": 0.76,
            "reason": "Rust's macro hygiene system prevents name collisions between macro-introduced identifiers and surrounding code. Per FLS: 'Hygiene is a property of macros and identifiers that appear within them, which aims to eliminate the syntactic interference between a macro and its expansion environment.'"
          },
          {
            "fls_id": "fls_dq403wq5yrs",
            "fls_title": "Namespaces",
            "category": -2,
            "score": 0.58,
            "reason": "Rust segregates macros into a separate macro namespace. Per FLS: 'A namespace is a logical grouping of names such that the occurrence of a name in one namespace does not conflict with an occurrence of the same name in another namespace.'"
          },
          {
            "fls_id": "fls_21vnag69kbwe",
            "fls_title": "Identifiers",
            "category": 0,
            "score": 0.677,
            "reason": "All identifier characters are significant in Rust"
          },
          {
            "fls_id": "fls_xa7lp0zg1ol2",
            "fls_title": "Declarative Macros",
            "category": 0,
            "score": 0.552,
            "reason": "Full identifier comparison for macros"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust has full identifier significance - same as all Rust."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 5.5",
      "guideline_title": "Identifiers shall be distinct from macro names C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "accepted_matches": [
        {
          "fls_id": "fls_dq403wq5yrs",
          "fls_title": "Namespaces",
          "category": 0,
          "score": 0.55,
          "reason": "FLS defines separate namespaces - macros are in a distinct 'macro namespace' from other identifiers. This prevents the naming collision that MISRA C is concerned about."
        },
        {
          "fls_id": "fls_crwfafrmydr7",
          "fls_title": "Namespaces - macro namespace",
          "category": -2,
          "score": 0.608,
          "reason": "Per FLS: 'A macro namespace contains the names of...Declarative macros, Function-like macros.' Macros cannot shadow variables/functions."
        },
        {
          "fls_id": "fls_xlfo7di0gsqz",
          "fls_title": "Hygiene",
          "category": 0,
          "score": 0.513,
          "reason": "FLS defines hygiene as 'a property of macros and identifiers...which aims to eliminate the syntactic interference between a macro and its environment.'"
        }
      ],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "advisory",
      "misra_rust_comment": "macros and functions use different syntax",
      "confidence": "medium",
      "notes": "Rust's namespace separation and hygiene system directly address MISRA's concern. Macros are invoked with different syntax (name! vs name) and occupy a separate namespace. MISRA ADD-6 marks safe Rust as Partial because the concern is largely prevented by language design.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 5.6",
      "guideline_title": "A typedef name shall be a unique identifier",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_kgvleup5mdhq",
          "fls_title": "Type Aliases",
          "category": 0,
          "score": 0.732,
          "reason": "FLS defines type aliases as items. Unlike C typedefs, Rust type aliases are proper items subject to module scoping and namespace rules."
        },
        {
          "fls_id": "fls_ydmnb7qnmzzq",
          "fls_title": "Shadowing",
          "category": 0,
          "score": 0.637,
          "reason": "FLS states: 'No name shall be shadowed except for Prelude names, macro names within textual macro scope, and variable names.' Type aliases cannot shadow or be shadowed arbitrarily."
        },
        {
          "fls_id": "fls_dq403wq5yrs",
          "fls_title": "Namespaces",
          "category": 0,
          "score": 0.55,
          "reason": "Rust segregates names into five namespaces. Type aliases are in the type namespace, preventing conflicts with value-namespace identifiers."
        }
      ],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust's namespace system and shadowing rules prevent the C typedef uniqueness issue. MISRA ADD-6 marks this as n_a because Rust's module and namespace system provides stronger guarantees than C's flat namespace.",
      "rejected_matches": []
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 5.7",
      "guideline_title": "A tag name shall be a unique identifier",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_dq403wq5yrs",
            "fls_title": "Namespaces",
            "category": 0,
            "score": 0.484,
            "reason": "FLS fls_ckptn88o6lla defines type namespace containing struct/enum/union names - no separate tag namespace exists in Rust"
          },
          {
            "fls_id": "fls_21vnag69kbwe",
            "fls_title": "Identifiers",
            "category": 0,
            "score": 0.669,
            "reason": "Rust identifiers are unique within their scope - no C-style tag vs ordinary identifier confusion"
          },
          {
            "fls_id": "fls_lnpyb285qdiy",
            "fls_title": "Scope Hierarchy",
            "category": 0,
            "score": 0.513,
            "reason": "Rust scope hierarchy provides clear namespace resolution through modules"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "C has a separate tag namespace where struct/enum/union tags can conflict with or shadow ordinary identifiers. Rust has no tag namespace - struct/enum/union names are in the type namespace per FLS fls_ckptn88o6lla. No forward declarations exist. Type names are resolved through the module system with clear scoping rules."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_dq403wq5yrs",
            "fls_title": "Namespaces",
            "category": 0,
            "score": 0.484,
            "reason": "No separate tag namespace in Rust"
          },
          {
            "fls_id": "fls_21vnag69kbwe",
            "fls_title": "Identifiers",
            "category": 0,
            "score": 0.669,
            "reason": "Type names are in type namespace, not tag namespace"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust has no tag namespace - same as all Rust."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 5.8",
      "guideline_title": "Identifiers that define objects or functions with external linkage shall be unique",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_mvd7nz8k3wcy",
          "fls_title": "Attribute no_mangle",
          "category": 0,
          "score": 0.529,
          "reason": "FLS defines #[no_mangle] which exposes a symbol with its Rust identifier name. When used, the programmer must ensure symbol uniqueness."
        },
        {
          "fls_id": "fls_olzilmy8n0nl",
          "fls_title": "Attribute export_name",
          "category": 0,
          "score": 0.496,
          "reason": "FLS defines #[export_name] to specify custom symbol names. Per FLS: 'Attribute export_name shall specify the exported symbol.'"
        },
        {
          "fls_id": "fls_p44fky7fifc",
          "fls_title": "Attribute link_name",
          "category": 0,
          "score": 0.646,
          "reason": "FLS defines #[link_name] for imported external functions. Per FLS: 'Attribute link_name shall specify the linking symbol.'"
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "fls_title": "External Blocks",
          "category": 0,
          "score": 0.61,
          "reason": "FLS defines external blocks for FFI. External functions and statics have C-level linkage, requiring unique symbol names."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "recommended",
      "confidence": "medium",
      "notes": "Rust normally mangles symbols ensuring uniqueness. MISRA's concern applies when #[no_mangle] or #[export_name] is used for FFI. FLS defines these mechanisms; uniqueness enforcement is programmer/linker responsibility.",
      "rejected_matches": []
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 5.9",
      "guideline_title": "Identifiers that define objects or functions with internal linkage should be unique",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "yes",
        "adjusted_category": "n_a",
        "rationale_type": "rust_alternative",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_jdknpu3kf865",
            "fls_title": "Visibility",
            "category": 0,
            "score": 0.64,
            "reason": "Per FLS: Rust uses visibility modifiers (pub, pub(crate), private) instead of C's internal/external linkage. Each module defines its own namespace."
          },
          {
            "fls_id": "fls_knjruq5wppv",
            "fls_title": "Visibility legality",
            "category": -2,
            "score": 0.63,
            "reason": "Per FLS: 'Private visibility...allows a name to be referred to only by the current module of the entity, and its descendant modules.' This is Rust's alternative to internal linkage."
          },
          {
            "fls_id": "fls_ydmnb7qnmzzq",
            "fls_title": "Shadowing",
            "category": 0,
            "score": 0.59,
            "reason": "Per FLS: Shadowing rules are well-defined. Names in different modules don't conflict because they're in separate namespaces."
          },
          {
            "fls_id": "fls_dq403wq5yrs",
            "fls_title": "Namespaces",
            "category": 0,
            "score": 0.56,
            "reason": "Rust has distinct namespaces (type, value, macro, label, lifetime) preventing name collisions across different kinds of items."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 1,
        "notes": "MISRA Rule 5.9 concerns C's 'internal linkage' (static file-scope items) being unique. Rust has no internal linkage concept - it uses module-based visibility instead. Private items in different modules can have the same name without conflict because they're in separate namespaces. The concern MISRA addresses (confusion from duplicate static names) is eliminated by Rust's module system. Adjusted category is n_a per MISRA ADD-6."
      },
      "safe_rust": {
        "applicability": "yes",
        "adjusted_category": "n_a",
        "rationale_type": "rust_alternative",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_jdknpu3kf865",
            "fls_title": "Visibility",
            "category": 0,
            "score": 0.51,
            "reason": "Per FLS: Rust's visibility system (private by default, pub modifiers) replaces C's linkage concept. Private items are scoped to their module."
          },
          {
            "fls_id": "fls_dq403wq5yrs",
            "fls_title": "Namespaces",
            "category": 0,
            "score": 0.63,
            "reason": "Per FLS: Rust has multiple namespaces (type, value, macro, label, lifetime). Items in different namespaces or modules don't conflict."
          },
          {
            "fls_id": "fls_i6qzga6dyaee",
            "fls_title": "Path Resolution",
            "category": 0,
            "score": 0.66,
            "reason": "Per FLS: Name resolution uses fully qualified paths (crate::module::item), making each item's identity unambiguous."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 1,
        "notes": "Same as all_rust. Safe Rust uses the same module-based visibility and namespace system. There's no distinction in this rule between safe and unsafe Rust - the concern about internal linkage identifier uniqueness is addressed by Rust's module system in both contexts."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 5.10",
      "guideline_title": "A reserved identifier or reserved macro name shall not be declared C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "accepted_matches": [
        {
          "fls_id": "fls_cbsgp6k0qa82",
          "fls_title": "Reserved Keywords",
          "category": 0,
          "score": 0.63,
          "reason": "FLS defines reserved keywords that cannot be used as identifiers (except via raw identifier syntax r#). This prevents accidental use of future language features."
        },
        {
          "fls_id": "fls_21vnag69kbwe",
          "fls_title": "Identifiers",
          "category": 0,
          "score": 0.619,
          "reason": "FLS defines identifier syntax including raw identifiers (r#keyword). Unlike C, Rust has no underscore-prefix reserved namespace convention."
        },
        {
          "fls_id": "fls_ld0ize96cm6m",
          "fls_title": "Preludes",
          "category": 0,
          "score": 0.55,
          "reason": "FLS defines preludes (core, std, extern). Prelude names are not reserved - they can be shadowed with defined precedence rules."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "advisory",
      "misra_rust_comment": "only possible in some cases. Previously Rule 21.2",
      "confidence": "medium",
      "notes": "Rust handles reserved identifiers differently than C. Keywords are strictly reserved, but there is no underscore-prefix convention. MISRA ADD-6 notes this applies partially - mainly in macro contexts or FFI where C naming conventions may leak through.",
      "rejected_matches": []
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 6.1",
      "guideline_title": "Bit-fields shall only be declared with an appropriate type C90",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_rjxpof29a3nl",
            "fls_title": "Struct Type Representation",
            "category": 0,
            "score": 0.664,
            "reason": "Rust struct fields have complete types with explicit sizes - no bit-field width specifier syntax exists"
          },
          {
            "fls_id": "fls_3qnpv2z7yjil",
            "fls_title": "Integer Types",
            "category": 0,
            "score": 0.714,
            "reason": "Rust integer types have explicit signedness and size (i32, u8, etc.) - no implementation-defined behavior"
          }
        ],
        "rejected_matches": [
          {
            "fls_id": "fls_abp6tjbz8tpn",
            "fls_title": "Bit Expressions",
            "category": 0,
            "score": 0.782,
            "reason": "Bit expressions are bitwise operators, not C-style bit-field declarations - misleading match"
          }
        ],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no C-style bit-fields (struct { int x : 5; } syntax). Struct fields have complete types with explicit size and signedness. Bit manipulation uses bitwise operators or crates like bitflags. The implementation-defined behavior of C bit-fields does not apply."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_rjxpof29a3nl",
            "fls_title": "Struct Type Representation",
            "category": 0,
            "score": 0.664,
            "reason": "No bit-field syntax in Rust"
          },
          {
            "fls_id": "fls_3qnpv2z7yjil",
            "fls_title": "Integer Types",
            "category": 0,
            "score": 0.714,
            "reason": "Explicit integer types with known signedness"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust has no bit-fields - same as all Rust."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 6.2",
      "guideline_title": "Single-bit named bit-fields shall not be of a signed type",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_3qnpv2z7yjil",
            "fls_title": "Integer Types",
            "category": 0,
            "score": 0.723,
            "reason": "Rust has explicit signed/unsigned types (i8/u8, etc.) with defined ranges - no implementation-defined signedness"
          },
          {
            "fls_id": "fls_tiqp1gxf116z",
            "fls_title": "Bool Type",
            "category": 0,
            "score": 0.778,
            "reason": "For single-bit values, Rust uses bool with well-defined representation (0x00/0x01)"
          },
          {
            "fls_id": "fls_rjxpof29a3nl",
            "fls_title": "Struct Type Representation",
            "category": 0,
            "score": 0.61,
            "reason": "Rust struct fields have complete types - no bit-field width specifier syntax"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rule 6.2 concerns C single-bit signed bit-fields where value is implementation-defined. Rust has no bit-fields. For single-bit values, Rust uses bool. All integer types have explicit signedness."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_9ucqbbd0s2yo",
            "fls_title": "Struct Types",
            "category": 0,
            "score": 0.549,
            "reason": "Safe Rust struct fields have complete types with explicit signedness"
          },
          {
            "fls_id": "fls_tiqp1gxf116z",
            "fls_title": "Bool Type",
            "category": 0,
            "score": 0.588,
            "reason": "Safe Rust bool type for single-bit values with defined representation"
          },
          {
            "fls_id": "fls_3qnpv2z7yjil",
            "fls_title": "Integer Types",
            "category": 0,
            "score": 0.646,
            "reason": "Safe Rust integer types have explicit signed/unsigned variants"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust has no bit-fields. Struct fields have complete types with explicit signedness. Bool is used for single-bit values."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 6.3",
      "guideline_title": "A bit-field shall not be declared as a member of a union C90",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_fmdn7n7s413d",
            "fls_title": "Union Types",
            "category": 0,
            "score": 0.652,
            "reason": "Rust unions have complete-type fields per fls_ZJG2Q6lJYXhY - no bit-field syntax exists"
          },
          {
            "fls_id": "fls_cmq8ogs84ivh",
            "fls_title": "Union Type Representation",
            "category": 0,
            "score": 0.765,
            "reason": "Union field layout defined by type representation, not bit widths"
          },
          {
            "fls_id": "fls_jep7p27kaqlp",
            "fls_title": "Unsafety",
            "category": 0,
            "score": 0.735,
            "reason": "Union field access is unsafe in Rust but uses complete types, not bit-fields"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rule 6.3 prohibits C bit-fields in unions due to implementation-defined layout. Rust has no bit-fields - union fields have complete types. Union field access requires unsafe but doesn't involve bit-field semantics."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_fmdn7n7s413d",
            "fls_title": "Union Types",
            "category": 0,
            "score": 0.654,
            "reason": "Safe Rust cannot use unions directly - union field access requires unsafe"
          },
          {
            "fls_id": "fls_szibmtfv117b",
            "fls_title": "Enum Types",
            "category": 0,
            "score": 0.591,
            "reason": "Safe Rust uses enums as the type-safe alternative to unions for sum types"
          },
          {
            "fls_id": "fls_rjxpof29a3nl",
            "fls_title": "Struct Type Representation",
            "category": 0,
            "score": 0.637,
            "reason": "Fields have complete types, no bit-fields"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust cannot access union fields (requires unsafe). Enums provide the safe alternative for sum types. Regardless, Rust has no bit-fields so this rule is inapplicable."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 7.1",
      "guideline_title": "Octal constants shall not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_2ed4axpsy9u0",
          "fls_title": "Integer Literals",
          "category": 0,
          "score": 0.631,
          "reason": "FLS defines integer literal syntax. Octal uses 0o prefix (OctalLiteral ::= 0o...), completely distinct from decimal literals."
        },
        {
          "fls_id": "fls_4v7awnutbpoe",
          "fls_title": "Integer Literals - octal",
          "category": -2,
          "score": 0.679,
          "reason": "Per FLS: 'An octal literal is an integer literal in base 8.' The 0o prefix eliminates C's ambiguous leading-zero syntax."
        }
      ],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "recommended",
      "misra_rust_comment": "Rust octals have a distinct prefix from decimals",
      "confidence": "medium",
      "notes": "Rust prevents C's octal confusion by design. Octal requires explicit 0o prefix (0o777), not leading zero (0777 is invalid). MISRA ADD-6: 'Rust octals have a distinct prefix from decimals.'",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 7.2",
      "guideline_title": "A \u201cu\u201d or \u201cU\u201d suffix shall be applied to all integer constants that are represented in an unsigned type",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_f1e29aj0sqvl",
          "fls_title": "Integer Literals - suffix",
          "category": -2,
          "score": 0.537,
          "reason": "Per FLS: 'An integer suffix is a component of an integer literal that specifies an explicit integer type.'"
        },
        {
          "fls_id": "fls_xrv4q56lmoo3",
          "fls_title": "Integer Literals - u8",
          "category": -2,
          "score": 0.55,
          "reason": "FLS defines explicit unsigned suffixes: u8, u16, u32, u64, u128, usize. More specific than C's single U suffix."
        },
        {
          "fls_id": "fls_50qipwqi3arw",
          "fls_title": "Integer Literals - unsuffixed",
          "category": -2,
          "score": 0.5,
          "reason": "Per FLS: 'The type of an unsuffixed integer is determined by type inference.' Type inference ensures unsuffixed literals get a concrete type."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "recommended",
      "misra_rust_comment": "this is an error by default but can be enabled",
      "confidence": "medium",
      "notes": "Rust has explicit type suffixes (u32, i64, etc.) more granular than C's U suffix. Type inference for unsuffixed literals is deterministic. Clippy lint default_numeric_fallback can enforce explicit suffixes.",
      "rejected_matches": []
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 7.3",
      "guideline_title": "The lowercase character \u201cl\u201d shall not be used in a literal suffix",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_2ed4axpsy9u0",
            "fls_title": "Integer Literals",
            "category": 0,
            "score": 0.6,
            "reason": "Rust integer suffixes are lowercase type names (i8, u32, i64, etc.) not L/l"
          },
          {
            "fls_id": "fls_29tlg1vyqay2",
            "fls_title": "Float Literals",
            "category": 0,
            "score": 0.713,
            "reason": "Rust float suffixes are f32/f64, not F/f or L/l"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rule 7.3 concerns C's L/l suffix ambiguity (1 vs l). Rust uses type name suffixes (i32, u64, f32) which are always lowercase and unambiguous. The C problem doesn't exist in Rust's suffix design."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_2ed4axpsy9u0",
            "fls_title": "Integer Literals",
            "category": 0,
            "score": 0.66,
            "reason": "Rust literal suffixes are type names (i32, u64) - unambiguous design"
          },
          {
            "fls_id": "fls_hv9jtycp0o1y",
            "fls_title": "Numeric Literals",
            "category": 0,
            "score": 0.689,
            "reason": "All numeric literal suffixes are lowercase type names"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust uses same literal suffix design - lowercase type names (i32, f64) that cannot be confused with digits."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 7.4",
      "guideline_title": "A string literal shall not be assigned to an object unless the object\u2019s type is \u201cpointer to const-qualified char\u201d C90",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "rust_prevents",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_hucd52suu6it",
            "fls_title": "Simple String Literals",
            "category": 0,
            "score": 0.685,
            "reason": "String literals have type &'static str - immutable reference, cannot be modified"
          },
          {
            "fls_id": "fls_a14slch83hzn",
            "fls_title": "Borrowing",
            "category": 0,
            "score": 0.594,
            "reason": "Rust's borrowing system distinguishes mutable/immutable borrows - string literals are immutable"
          },
          {
            "fls_id": "fls_xdvdl2ssnhlo",
            "fls_title": "Statics",
            "category": -4,
            "score": 0.596,
            "reason": "FLS fls_b5wsmii7vz3v states mutating immutable static is UB - type system prevents this"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rule 7.4 concerns C's UB from modifying string literals via char*. Rust prevents this: string literals are &'static str (immutable reference). The type system enforces immutability - you cannot get &mut str from a literal."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "rust_prevents",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_hucd52suu6it",
            "fls_title": "Simple String Literals",
            "category": 0,
            "score": 0.588,
            "reason": "String literal type is &'static str - shared immutable reference"
          },
          {
            "fls_id": "fls_a14slch83hzn",
            "fls_title": "Borrowing",
            "category": 0,
            "score": 0.618,
            "reason": "Safe Rust enforces borrow rules - cannot get mutable reference to literal"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust completely prevents this issue through the type system. String literals are &str (immutable), and safe Rust cannot circumvent this."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 7.5",
      "guideline_title": "The argument of an integer constant macro shall have an appropriate form C99",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_2ed4axpsy9u0",
            "fls_title": "Integer Literals",
            "category": 0,
            "score": 0.649,
            "reason": "Rust uses type suffixes (42i8, 42u32) instead of C's INT8_C/UINT32_C macros"
          },
          {
            "fls_id": "fls_lv7w7aalpwm5",
            "fls_title": "Type Inference",
            "category": 0,
            "score": 0.547,
            "reason": "Rust type inference or explicit suffixes determine literal types"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rule 7.5 concerns C's <stdint.h> integer constant macros (INT8_C, UINT32_C, etc.). Rust has no such macros - integer types are specified via suffixes (42i8) or type inference. The C mechanism and its constraints don't exist."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_2ed4axpsy9u0",
            "fls_title": "Integer Literals",
            "category": 0,
            "score": 0.677,
            "reason": "Safe Rust uses type suffixes for integer literals"
          },
          {
            "fls_id": "fls_66m4rnbssgig",
            "fls_title": "Constant Expressions",
            "category": 0,
            "score": 0.722,
            "reason": "Rust constants evaluated at compile-time, no macro mechanism like C"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust has no INT8_C/UINT32_C macros - uses suffixes and type inference."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 7.6",
      "guideline_title": "The small integer variants of the minimum-width integer constant macros shall not be used",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_2ed4axpsy9u0",
            "fls_title": "Integer Literals",
            "category": -2,
            "score": 0.75,
            "reason": "Rust uses explicit type suffixes (i8, u16, i32, etc.) on integer literals instead of macros like INT8_C/UINT16_C. Per FLS: 'An integer suffix is a component of an integer literal that specifies an explicit integer type.'"
          },
          {
            "fls_id": "fls_3qnpv2z7yjil",
            "fls_title": "Integer Types",
            "category": 0,
            "score": 0.75,
            "reason": "Rust has fixed-width integer types (i8, u8, i16, u16, etc.) as primitives. The type is determined at compile time by suffix or inference - no macro expansion involved."
          }
        ],
        "rejected_matches": [
          {
            "fls_id": "fls_1qhsun1vyarz",
            "fls_title": "Type Cast Expressions",
            "category": 0,
            "score": 0.67,
            "reason": "Type cast expressions are explicit conversions using 'as' keyword - not related to integer constant macros or implicit promotion."
          }
        ],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no INT8_C/UINT16_C macros. Integer literals use direct type suffixes (42i8, 255u16) which are part of the language syntax, not preprocessor macros. The MISRA concern about macro expansion producing int type instead of expected small integer type does not apply."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_2ed4axpsy9u0",
            "fls_title": "Integer Literals",
            "category": -2,
            "score": 0.75,
            "reason": "Rust uses explicit type suffixes (i8, u16, i32) as part of language syntax. Per FLS: 'An integer suffix is a component of an integer literal that specifies an explicit integer type.'"
          },
          {
            "fls_id": "fls_lv7w7aalpwm5",
            "fls_title": "Type Inference",
            "category": -2,
            "score": 0.75,
            "reason": "When no suffix is provided, Rust's type inference determines the integer type. Per FLS: 'If there are any remaining integer type variables that have not been unified with a concrete integer type, perform integer type fallback by unifying the integer type variable with type i32.'"
          }
        ],
        "rejected_matches": [
          {
            "fls_id": "fls_wjldgtio5o75",
            "fls_title": "Macro Expansion",
            "category": 0,
            "score": 0.67,
            "reason": "Rust macros operate on token trees, not textual substitution like C preprocessor. Not related to integer constant macros."
          }
        ],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust has the same situation as all Rust - no INT8_C/UINT16_C macros exist. Integer types are specified via suffixes (42i8) or inferred from context with i32 fallback. Rust's macro system is fundamentally different from C preprocessor and doesn't have these width-specific constant macros."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 8.1",
      "guideline_title": "Types shall be explicitly specified",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_qcb1n9c0e5hz",
            "fls_title": "Functions",
            "category": -2,
            "score": 0.67,
            "reason": "Rust requires explicit return types. Per FLS: 'If the FunctionDeclaration specifies a ReturnType, then the return type is the specified ReturnType' - no implicit int fallback exists."
          },
          {
            "fls_id": "fls_lv7w7aalpwm5",
            "fls_title": "Type Inference",
            "category": -2,
            "score": 0.7,
            "reason": "Rust's type inference is deterministic and requires sufficient context. Per FLS: 'If there are any remaining global type variables that have not been unified with a concrete type, raise a static error.' No implicit int."
          },
          {
            "fls_id": "fls_yivm43r5wnp1",
            "fls_title": "Let Statements",
            "category": -2,
            "score": 0.64,
            "reason": "Let bindings require type to be determinable. Per FLS: 'The type of a binding introduced by a let statement is determined' via explicit annotation or inferred type - never implicit int."
          }
        ],
        "rejected_matches": [
          {
            "fls_id": "fls_s45k21yn4qur",
            "fls_title": "Inferred Types",
            "category": 0,
            "score": 0.6,
            "reason": "Inferred types are about placeholder _ syntax, not about defaulting to int type."
          }
        ],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no implicit int rule. All types must be either explicitly specified or deterministically inferred from context. If type cannot be determined, it's a compile error - there's no fallback to int like in C90."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_yivm43r5wnp1",
            "fls_title": "Let Statements",
            "category": -2,
            "score": 0.58,
            "reason": "Per FLS: 'If the let statement appears with a type ascription, then the type is the type specified by the type ascription' - types are explicit or inferred, never implicit int."
          },
          {
            "fls_id": "fls_s45k21yn4qur",
            "fls_title": "Inferred Types",
            "category": -2,
            "score": 0.66,
            "reason": "Per FLS: 'Within the TypeAscription of a ConstantDeclaration, a ConstantParameter, a FunctionParameterPattern, a RecordStructField, a StaticDeclaration...' - struct fields require explicit types."
          },
          {
            "fls_id": "fls_tjyexqrx0fx5",
            "fls_title": "Closure Expressions",
            "category": -2,
            "score": 0.71,
            "reason": "Closures allow type inference for parameters but this is deterministic inference, not defaulting to int. Per FLS: 'If the closure parameter lacks a TypeSpecification, the type is inferred from the usage.'"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust has the same behavior as all Rust regarding type specification. No implicit int exists. Function parameters and struct fields require explicit types. Let bindings and closures use deterministic type inference."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 8.2",
      "guideline_title": "Function types shall be in prototype form with named parameters C90",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_qcb1n9c0e5hz",
            "fls_title": "Functions",
            "category": -2,
            "score": 0.62,
            "reason": "Per FLS: 'A function signature is a unique identification of a function that encompasses its function qualifiers, name, generic parameters, function parameters...' All function declarations require full type specification."
          },
          {
            "fls_id": "fls_xztr1kebz8bo",
            "fls_title": "Function Pointer Types",
            "category": -2,
            "score": 0.7,
            "reason": "Rust function pointers always encode their full signature. Per FLS: 'A function pointer type is an indirection type that refers to a function.' No K&R-style untyped declarations exist."
          },
          {
            "fls_id": "fls_8gPCPVc99pXJ",
            "fls_title": "Call Conformance",
            "category": -1,
            "score": 0.68,
            "reason": "Per FLS: 'The type of a matched argument operand and the type of the corresponding function parameter or field shall be unifiable.' Argument checking is always enforced."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no K&R-style function declarations. All function parameters must have explicit types in the function signature. There is no 'old-style' declaration syntax. Argument counts and types are always checked at compile time."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_qcb1n9c0e5hz",
            "fls_title": "Functions",
            "category": -2,
            "score": 0.7,
            "reason": "Per FLS: 'A function parameter is a construct that yields a set of bindings that bind matched input values to names.' All parameters have explicit types in safe Rust."
          },
          {
            "fls_id": "fls_e1pgdlv81vul",
            "fls_title": "Implementation Conformance",
            "category": -2,
            "score": 0.7,
            "reason": "Per FLS: 'The function signature of the associated function of the implemented trait is a subtype of the function signature of the associated trait function.' Trait methods also require full signatures."
          },
          {
            "fls_id": "fls_exe4zodlwfez",
            "fls_title": "Type Unification",
            "category": -2,
            "score": 0.66,
            "reason": "Per FLS: 'The number of function parameters is the same, and the types of the corresponding function parameters are unifiable.' Function call checking is always enforced."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust has identical requirements to all Rust - no K&R-style declarations exist. All function parameters require explicit types. Trait methods also require full type signatures."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 8.3",
      "guideline_title": "All declarations of an object or function shall use the same names and type qualifiers C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "fls_title": "External Functions",
          "category": 0,
          "score": 0.626,
          "reason": "Per FLS: 'An external function is an unchecked import of a foreign function.' Type compatibility with C is programmer's responsibility."
        },
        {
          "fls_id": "fls_v24ino4hix3m",
          "fls_title": "External Functions - unchecked",
          "category": -2,
          "score": 0.6,
          "reason": "FLS explicitly states external functions are 'unchecked imports' - the compiler cannot verify type compatibility with the actual C function."
        },
        {
          "fls_id": "fls_usgd0xlijoxv",
          "fls_title": "ABI",
          "category": 0,
          "score": 0.55,
          "reason": "FLS defines ABI specifications including extern C. Correct ABI is necessary but not sufficient for type compatibility."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "misra_rust_comment": "an extern declaration shall have a type compatible with the C declaration",
      "confidence": "medium",
      "notes": "MISRA's concern directly applies to Rust FFI. FLS explicitly calls external functions 'unchecked' - type compatibility must be manually verified. This is why extern blocks are unsafe. Tools like bindgen can help generate correct declarations.",
      "rejected_matches": []
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 8.4",
      "guideline_title": "A compatible declaration shall be visible when an object or function with external linkage is defined C90",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_gklst7joeo33",
            "fls_title": "Crate Imports",
            "category": -2,
            "score": 0.64,
            "reason": "Rust uses the module system for importing external items. Per FLS: 'A crate import binds an external crate to its crate indication.' No separate header/definition compatibility issue."
          },
          {
            "fls_id": "fls_9gprp17h6t1q",
            "fls_title": "Use Imports",
            "category": -2,
            "score": 0.58,
            "reason": "Use imports bring items into scope from modules. Per FLS: 'If the import path prefix resolves to a module, bring all names in the module that are visible from the location.' Single source of truth."
          },
          {
            "fls_id": "fls_tmoh3y9oyqsy",
            "fls_title": "External Blocks",
            "category": -2,
            "score": 0.64,
            "reason": "For FFI, extern blocks declare external functions. Per FLS: 'An external block is a construct that provides the declarations of external functions and external statics as unchecked imports.' This is one-way import, not dual declaration/definition."
          },
          {
            "fls_id": "fls_lnpyb285qdiy",
            "fls_title": "Scope Hierarchy",
            "category": 0,
            "score": 0.623,
            "reason": "Rust requires names be in scope before use. fls_6ozthochxz1i (Binding Scopes) and fls_34usianesmf6 define scope rules for all declarations."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no separate header files or declaration/definition compatibility problem. The module system provides a single source of truth for each item. Extern blocks for FFI are one-way declarations of external items, not a dual declaration/definition situation."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_e9hwvqsib5d5",
            "fls_title": "Modules",
            "category": -2,
            "score": 0.6,
            "reason": "Per FLS: 'A module is a container for zero or more items.' Each item is defined once in its module - no separate declaration/definition."
          },
          {
            "fls_id": "fls_e1pgdlv81vul",
            "fls_title": "Implementation Conformance",
            "category": -2,
            "score": 0.75,
            "reason": "For traits, implementation conformance is enforced. Per FLS: 'The function signature of the associated function of the implemented trait is a subtype of the function signature of the associated trait function.' This is compile-time checked."
          },
          {
            "fls_id": "fls_i6qzga6dyaee",
            "fls_title": "Path Resolution",
            "category": -2,
            "score": 0.61,
            "reason": "Per FLS: 'A namespace context is a set of namespaces where the names of candidate selected entities reside.' Path resolution provides unambiguous name lookup."
          },
          {
            "fls_id": "fls_lnpyb285qdiy",
            "fls_title": "Scope Hierarchy",
            "category": 0,
            "score": 0.623,
            "reason": "Rust requires names be in scope before use. fls_6ozthochxz1i (Binding Scopes) and fls_34usianesmf6 define scope rules for all declarations."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust has identical behavior to all Rust - no header file model exists. Modules provide single-definition items. Trait implementations require signature conformance checked at compile time."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 8.5",
      "guideline_title": "An external object or function shall be declared once in one and only one file",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "fls_title": "External Blocks",
          "category": 0,
          "score": 0.643,
          "reason": "FLS defines external blocks for FFI declarations. Unlike C headers, Rust modules provide natural organization for external declarations."
        },
        {
          "fls_id": "fls_4dje9t5y2dia",
          "fls_title": "External Blocks - imports",
          "category": -2,
          "score": 0.711,
          "reason": "Per FLS: 'An external block is a construct that provides the declarations of external functions and external statics as unchecked imports.'"
        }
      ],
      "fls_rationale_type": "partial_mapping",
      "misra_rust_category": "advisory",
      "misra_rust_comment": "may affect extern \u201cC\u201d declarations",
      "confidence": "medium",
      "notes": "Rust's module system naturally addresses this. External declarations are typically centralized in a single module (e.g., ffi.rs or sys.rs). Duplicate declarations are valid but poor practice. MISRA ADD-6 marks as advisory for extern C declarations.",
      "rejected_matches": []
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 8.6",
      "guideline_title": "An identifier with external linkage shall have exactly one external definition C90",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "yes",
        "adjusted_category": "required",
        "rationale_type": "partial_mapping",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_tmoh3y9oyqsy",
            "fls_title": "External Blocks",
            "category": 0,
            "score": 0.64,
            "reason": "Per FLS: 'An external block is a construct that provides the declarations of external functions and external statics as unchecked imports.' Declarations in extern blocks must match actual definitions."
          },
          {
            "fls_id": "fls_yztwtek0y34v",
            "fls_title": "External Functions",
            "category": 0,
            "score": 0.58,
            "reason": "Per FLS: 'An external function is an unchecked import of a foreign function.' If multiple extern blocks declare the same symbol differently, it's UB."
          },
          {
            "fls_id": "fls_mvd7nz8k3wcy",
            "fls_title": "Attribute no_mangle",
            "category": 0,
            "score": 0.62,
            "reason": "Per FLS: 'Attribute no_mangle causes the related function or static to be publicly exported.' Multiple #[no_mangle] items with the same name violate ODR."
          },
          {
            "fls_id": "fls_p44fky7fifc",
            "fls_title": "Attribute link_name",
            "category": 0,
            "score": 0.63,
            "reason": "Attribute link_name specifies the linking symbol. Conflicting link_name attributes can cause ODR violations."
          },
          {
            "fls_id": "fls_s4yt19sptl7d",
            "fls_title": "External Statics",
            "category": 0,
            "score": 0.63,
            "reason": "Per FLS: 'An external static is an import of a foreign variable.' ODR applies to external statics just as it does to external functions - duplicate definitions cause UB."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 1,
        "notes": "MISRA Rule 8.6 (ODR for external linkage) applies to Rust's FFI boundary. Per MISRA ADD-6: 'may affect extern C declarations'. When using extern blocks, #[no_mangle], or #[link_name], Rust code must ensure exactly one definition exists. The linker enforces this at link time, but violations cause UB. Rust's internal items (with name mangling) are inherently ODR-compliant."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_maw4u1o8q37u",
            "fls_title": "Crates",
            "category": 0,
            "score": 0.58,
            "reason": "Per FLS: 'A crate is a unit of compilation and linking that contains a tree of nested modules.' In safe Rust, all symbols are name-mangled with full paths."
          },
          {
            "fls_id": "fls_xdvdl2ssnhlo",
            "fls_title": "Statics",
            "category": 0,
            "score": 0.56,
            "reason": "Per FLS: 'A static defined within a generic function exists once in the output executable or library.' Rust ensures unique instances."
          },
          {
            "fls_id": "fls_r2drzo3dixe4",
            "fls_title": "ABI legality",
            "category": -2,
            "score": 0.54,
            "reason": "Per FLS: 'A function without an explicit ABI has implicit Rust ABI.' Safe Rust functions use Rust ABI with name mangling, ensuring ODR compliance."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 1,
        "notes": "Safe Rust has no external linkage concept. All functions and statics are name-mangled using the Rust ABI unless explicitly marked with #[no_mangle] (which requires unsafe reasoning). The Rust compiler ensures each item has exactly one definition through the module/crate system. ODR violations are impossible in pure safe Rust code."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 8.7",
      "guideline_title": "Functions and objects should not be defined with external linkage if they are referenced in only one translation unit",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_jdknpu3kf865",
          "fls_title": "Visibility",
          "category": 0,
          "score": 0.683,
          "reason": "FLS defines Rust's visibility system with granular control: private (default), pub(crate), pub(super), pub(in path), and pub."
        },
        {
          "fls_id": "fls_aa4f3rvir9lm",
          "fls_title": "Visibility - pub(crate)",
          "category": -2,
          "score": 0.701,
          "reason": "Per FLS: 'A crate public modifier...grants a name public visibility within the current crate only.' This directly addresses MISRA's concern."
        },
        {
          "fls_id": "fls_utgjx6l5zwfl",
          "fls_title": "Visibility - default private",
          "category": -2,
          "score": 0.571,
          "reason": "Per FLS: 'An external item, a field, or an item that appears without a visibility modifier has private visibility by default.'"
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "advisory",
      "misra_rust_comment": "items should not be declared pub if referenced in only one crate",
      "confidence": "medium",
      "notes": "Rust's visibility system directly addresses this. Items are private by default; pub(crate) provides crate-internal visibility. Clippy lint redundant_pub_crate can detect unnecessary pub exposure.",
      "rejected_matches": []
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 8.8",
      "guideline_title": "The static storage class specifier shall be used in all declarations of objects and functions that have internal linkage",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_jdknpu3kf865",
            "fls_title": "Visibility",
            "category": -2,
            "score": 0.68,
            "reason": "Rust uses visibility modifiers instead of storage class specifiers. Per FLS: 'An external item, a field, or an item that appears without a visibility modifier has private visibility by default.'"
          },
          {
            "fls_id": "fls_xdvdl2ssnhlo",
            "fls_title": "Statics",
            "category": -2,
            "score": 0.56,
            "reason": "Rust statics are about memory location, not linkage. Per FLS: 'A static is a value that is associated with a specific memory location.' Visibility is orthogonal."
          }
        ],
        "rejected_matches": [
          {
            "fls_id": "fls_tmoh3y9oyqsy",
            "fls_title": "External Blocks",
            "category": 0,
            "score": 0.7,
            "reason": "External blocks are for FFI declarations, not for controlling internal vs external linkage of Rust items."
          }
        ],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no 'static' storage class specifier like C. Visibility (pub/private/pub(crate)) controls what can be accessed from where. Items are private by default (internal). The keyword 'static' in Rust means a global variable with static lifetime, not internal linkage."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_jdknpu3kf865",
            "fls_title": "Visibility",
            "category": -2,
            "score": 0.65,
            "reason": "Per FLS: 'Private visibility is a kind of visibility that allows a name to be referred to only by the current module of the entity, and its descendant modules.' Private by default provides consistent internal visibility."
          },
          {
            "fls_id": "fls_jdknpu3kf865",
            "fls_title": "Visibility",
            "category": -2,
            "score": 0.63,
            "reason": "Per FLS: 'A crate public modifier is a visibility modifier that grants a name public visibility within the current crate only.' pub(crate) provides crate-internal visibility."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust uses visibility modifiers (pub, pub(crate), private by default) instead of C's storage class specifiers. Items are private by default which is clearer and more consistent than C's extern/static duality."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 8.9",
      "guideline_title": "An object should be declared at block scope if its identifier only appears in a single function",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_6ozthochxz1i",
          "fls_title": "Binding Scopes",
          "category": 0,
          "score": 0.599,
          "reason": "FLS defines binding scopes. Variables are scoped to their containing block."
        },
        {
          "fls_id": "fls_74nk389rk075",
          "fls_title": "Binding Scopes - let statement",
          "category": -2,
          "score": 0.568,
          "reason": "Per FLS: 'The binding of a let statement is in scope after the related let statement, until the end of the block expression.' Enforces block-level scoping."
        },
        {
          "fls_id": "fls_rm4ncoopcdvj",
          "fls_title": "Drop Scopes",
          "category": 0,
          "score": 0.578,
          "reason": "FLS defines drop scopes. MISRA wants minimal scope for cleanup; Rust's drop scopes provide deterministic destruction at block boundaries."
        },
        {
          "fls_id": "fls_vrqgac634wpr",
          "fls_title": "Drop Scopes - binding drop",
          "category": -2,
          "score": 0.566,
          "reason": "Per FLS: 'A binding declared in a let statement is associated with the drop scope of the block expression that contains the let statement.'"
        },
        {
          "fls_id": "fls_m0z7omni9hp0",
          "fls_title": "Item Scope",
          "category": 0,
          "score": 0.611,
          "reason": "FLS defines item scope. Items declared in blocks are scoped to those blocks."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "recommended",
      "confidence": "medium",
      "notes": "Rust naturally enforces block scoping. Variables are declared at point of use with let and scoped to their containing block. Drop scopes ensure deterministic cleanup at block exit, directly addressing MISRA's concern about minimal scope.",
      "rejected_matches": []
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 8.10",
      "guideline_title": "An inline function shall be declared with the static storage class C99",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_ypio6boj3pwf",
            "fls_title": "Attribute inline",
            "category": -2,
            "score": 0.67,
            "reason": "Per FLS: 'Attribute inline marks its related function as inlined. The process of replacing a call expression to an inlined function with the function body is implementation-defined.' It's just a hint, not a linkage specifier."
          },
          {
            "fls_id": "fls_jdknpu3kf865",
            "fls_title": "Visibility",
            "category": 0,
            "score": 0.55,
            "reason": "Rust's inline attribute is orthogonal to visibility. Public inline functions work correctly - the compiler handles the details."
          }
        ],
        "rejected_matches": [
          {
            "fls_id": "fls_tmoh3y9oyqsy",
            "fls_title": "External Blocks",
            "category": 0,
            "score": 0.77,
            "reason": "External blocks are for FFI, not for controlling inline function linkage."
          }
        ],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust's #[inline] is a compiler hint, not a storage class specifier. It doesn't affect linkage semantics. The compiler handles whether to inline based on optimization settings. There's no undefined behavior from inline + external linkage like in C."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_ypio6boj3pwf",
            "fls_title": "Attribute inline",
            "category": -2,
            "score": 0.63,
            "reason": "Per FLS: 'Attribute inline with InlineHint always suggests to a tool that inlining should always be performed.' and 'A tool is not obliged to perform inlining.' It's advisory, not a linkage specifier."
          },
          {
            "fls_id": "fls_xa4nbfas01cj",
            "fls_title": "Call Expressions",
            "category": -2,
            "score": 0.73,
            "reason": "Per FLS: 'If the adjusted call operand is a function item type or function pointer type, then corresponding function is invoked.' Function invocation semantics are well-defined regardless of inline hints."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust has the same inline semantics as all Rust. #[inline] is a compiler hint that doesn't affect visibility or linkage. There's no C-style inline/extern linkage interaction to worry about."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 8.11",
      "guideline_title": "When an array with external linkage is declared, its size should be explicitly specified",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_uj0kpjwyld60",
            "fls_title": "Array Types",
            "category": -2,
            "score": 0.65,
            "reason": "Per FLS: 'The size operand shall be a constant expression or an inferred constant.' Rust arrays always require explicit size - no incomplete array types exist."
          },
          {
            "fls_id": "fls_xinykul167l",
            "fls_title": "Array Expressions",
            "category": -2,
            "score": 0.66,
            "reason": "Per FLS: 'The type of an array expression is [T; N], where T is the element type and N is the size of the array.' Size is always part of the type."
          },
          {
            "fls_id": "fls_vpbikb73dw4k",
            "fls_title": "Slice Types",
            "category": 0,
            "score": 0.541,
            "reason": "For dynamic sizes, use slices (fls_ftvua2hlvr08). Slices carry length at runtime. Type system distinguishes fixed [T;N] from dynamic [T]."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no incomplete array types. Arrays [T; N] always have compile-time known size. Slices [T] are a different type entirely, used for runtime-sized views into contiguous memory."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_uj0kpjwyld60",
            "fls_title": "Array Types",
            "category": -2,
            "score": 0.49,
            "reason": "Per FLS: 'The size operand shall be a constant expression or an inferred constant.' Arrays always have compile-time known size in safe Rust."
          },
          {
            "fls_id": "fls_vhpwge5123cm",
            "fls_title": "Generic Parameters",
            "category": -2,
            "score": 0.6,
            "reason": "Per FLS: 'A type parameter has an implicit core::marker::Sized bound.' Most types must be sized; arrays are always fixed-size."
          },
          {
            "fls_id": "fls_vpbikb73dw4k",
            "fls_title": "Slice Types",
            "category": 0,
            "score": 0.541,
            "reason": "For dynamic sizes, use slices (fls_ftvua2hlvr08). Slices carry length at runtime. Type system distinguishes fixed [T;N] from dynamic [T]."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust has identical array semantics - no incomplete array types. The Sized trait ensures types have known size at compile time. Arrays [T; N] are always Sized."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 8.12",
      "guideline_title": "Within an enumerator list, the value of an implicitly-specified enumeration constant shall be unique",
      "guideline_type": "rule",
      "applicability_all_rust": "rust_prevents",
      "applicability_safe_rust": "rust_prevents",
      "accepted_matches": [
        {
          "fls_id": "fls_w9xj26ej869w",
          "category": -2,
          "fls_section": "fls_szibmtfv117b",
          "fls_title": "Enum Types",
          "score": 0.6,
          "reason": "Per FLS fls_w9xj26ej869w: 'It is a static error if two enum variants have discriminants with the same value.' Rust enforces this at compile time - duplicate discriminant values are rejected by the compiler."
        },
        {
          "fls_id": "fls_szibmtfv117b",
          "category": 0,
          "fls_section": "4.-2.11",
          "fls_title": "Enum Types",
          "score": 0.588,
          "reason": "Parent section containing discriminant uniqueness rules and implicit discriminant value calculation rules (fls_t36rk3wikq28, fls_8ajw5trd23wi)."
        }
      ],
      "rejected_matches": [
        {
          "fls_id": "fls_66m2hwkju0vv",
          "category": -2,
          "fls_section": "fls_66m4rnbssgig",
          "fls_title": "Constant Expressions",
          "score": 0.673,
          "reason": "About constant expression contexts, not discriminant uniqueness."
        },
        {
          "fls_id": "fls_ixjc5jaamx84",
          "category": 0,
          "fls_section": "7.-2.2",
          "fls_title": "Constants",
          "score": 0.572,
          "reason": "About const items, not enum discriminants."
        }
      ],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "MISRA addresses C's ability to have duplicate enum constant values through mixing implicit and explicit specifications. Rust prevents this at compile time: per FLS fls_w9xj26ej869w, 'It is a static error if two enum variants have discriminants with the same value.' The discriminant calculation rules (fls_t36rk3wikq28: first variant is 0, fls_8ajw5trd23wi: subsequent are previous+1) combined with explicit initializers are checked for uniqueness by the compiler."
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 8.13",
      "guideline_title": "A pointer should point to a const-qualified type whenever possible",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_v5x85lt5ulva",
          "fls_title": "References",
          "category": 0,
          "score": 0.578,
          "reason": "FLS defines references. Rust's default is immutable (&T); mutable requires explicit &mut."
        },
        {
          "fls_id": "fls_wcf5mxrzbujn",
          "fls_title": "References - immutable",
          "category": -2,
          "score": 0.552,
          "reason": "Per FLS: 'An immutable reference is a value of a shared reference type, and prevents the mutation of its referent.' Immutability is the default."
        },
        {
          "fls_id": "fls_fckoj1jh5mrc",
          "fls_title": "References - mutable",
          "category": -2,
          "score": 0.573,
          "reason": "Per FLS: 'A mutable reference is a value of a mutable reference type, and allows the mutation of its referent.' Mutation requires explicit opt-in."
        },
        {
          "fls_id": "fls_77scxuomlbgs",
          "fls_title": "Passing Conventions",
          "category": 0,
          "score": 0.601,
          "reason": "FLS defines how parameters are passed. By-reference passing uses immutable borrows by default."
        },
        {
          "fls_id": "fls_ppd1xwve3tr7",
          "fls_title": "Raw Pointer Types",
          "category": 0,
          "score": 0.616,
          "reason": "FLS defines raw pointer types for unsafe/FFI contexts. Immutable raw pointers use const keyword."
        },
        {
          "fls_id": "fls_8uWfFAsZeRCs",
          "fls_title": "Raw Pointer Types - immutable",
          "category": -2,
          "score": 0.598,
          "reason": "Per FLS: 'An immutable raw pointer type is a raw pointer type subject to keyword const.' Applies to unsafe FFI contexts."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "advisory",
      "confidence": "medium",
      "notes": "Rust's reference system directly addresses MISRA's concern. Immutable references (&T) are the default, enforcing const-by-default. Mutable references (&mut T) require explicit declaration. For unsafe/FFI, *const T parallels C's const pointer.",
      "rejected_matches": []
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 8.14",
      "guideline_title": "The restrict type qualifier shall not be used C99",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_v5x85lt5ulva",
            "fls_title": "References",
            "category": -4,
            "score": 0.69,
            "reason": "Per FLS: 'It is undefined behavior to access a value through aliasing mutable references from unsafe context.' Rust's mutable references are inherently exclusive - the borrow checker enforces this."
          },
          {
            "fls_id": "fls_142vncdktbin",
            "fls_title": "Reference Types",
            "category": -2,
            "score": 0.62,
            "reason": "Per FLS: 'A shared reference type prevents the direct mutation of a referenced value.' Rust's reference types encode aliasing rules in the type system."
          }
        ],
        "rejected_matches": [
          {
            "fls_id": "fls_ppd1xwve3tr7",
            "fls_title": "Raw Pointer Types",
            "category": 0,
            "score": 0.72,
            "reason": "Raw pointers bypass the borrow checker but there's no restrict qualifier - aliasing rules for raw pointers are different from C's restrict."
          }
        ],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no restrict keyword. Aliasing rules are enforced by the borrow checker for references. Mutable references are exclusive by design, giving the compiler noalias guarantees automatically without programmer annotation."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_a14slch83hzn",
            "fls_title": "Borrowing",
            "category": -2,
            "score": 0.64,
            "reason": "Per FLS: 'The mutable borrow is checked against other borrows and by move passing within the enclosing item.' Borrow checker enforces exclusive access for mutable references."
          },
          {
            "fls_id": "fls_v5x85lt5ulva",
            "fls_title": "References",
            "category": -2,
            "score": 0.7,
            "reason": "Per FLS: 'The lifetime of a referent shall be at least as long as the lifetime of its reference.' Lifetime system ensures references are always valid."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "In safe Rust, the borrow checker enforces that mutable references are exclusive. This provides the same optimization benefits as C's restrict but with compile-time safety guarantees. No manual annotation needed."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 8.15",
      "guideline_title": "All declarations of an object with an explicit alignment specification shall specify the same alignment C11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_g1z6bpyjqxkz",
          "fls_title": "Type Layout",
          "category": 0,
          "score": 0.7,
          "reason": "FLS defines alignment as an intrinsic property of types. Rust types have a single definition where alignment is specified via #[repr(align(N))], eliminating the possibility of conflicting alignment specifications across declarations."
        },
        {
          "fls_id": "fls_aibb2quva4mn",
          "fls_title": "Attribute repr",
          "category": 0,
          "score": 0.56,
          "reason": "FLS: 'Attribute repr shall apply to abstract data types' and 'shall indicate the type representation of the related type.' Alignment is specified once at the type definition via repr(align(N)) or repr(packed)."
        },
        {
          "fls_id": "fls_muxfn9soi47l",
          "fls_title": "Type Layout",
          "category": -2,
          "score": 0.68,
          "reason": "FLS: 'The alignment of a value specifies which addresses are valid for storing the value.' This alignment is determined by the type definition, not separate declarations."
        },
        {
          "fls_id": "fls_s4yt19sptl7d",
          "fls_title": "External Statics",
          "category": 0,
          "score": 0.55,
          "reason": "For external statics (FFI), alignment is determined by the type used in the declaration. The type itself carries alignment specification, preventing declaration/definition mismatch."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "may affect extern \u201cC\u201d declarations",
      "confidence": "medium",
      "notes": "Rust prevents this issue by design: types have single definitions where alignment is specified. No forward declarations or separate object declarations exist. For FFI, alignment is intrinsic to the type used.",
      "rejected_matches": [
        {
          "fls_id": "fls_jr9dykj6rydn",
          "fls_title": "Struct Type Representation",
          "category": -2,
          "score": 0.71,
          "reason": "While this discusses struct alignment calculation, it's about layout rules not declaration consistency."
        },
        {
          "fls_id": "fls_JBfZuFDQg3mU",
          "fls_title": "Place Expressions",
          "category": -2,
          "score": 0.62,
          "reason": "Not relevant - discusses struct expression initializers, not alignment."
        }
      ]
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 8.16",
      "guideline_title": "The alignment specification of zero should not appear in an object declaration",
      "guideline_type": "rule",
      "applicability_all_rust": "rust_prevents",
      "applicability_safe_rust": "rust_prevents",
      "accepted_matches": [
        {
          "fls_id": "fls_muxfn9soi47l",
          "category": -2,
          "fls_section": "fls_g1z6bpyjqxkz",
          "fls_title": "Type Layout",
          "score": 0.675,
          "reason": "Per FLS fls_muxfn9soi47l: 'The alignment of a value... is at least one, and always a power of two.' This rule prevents align(0) - the compiler rejects it with error E0589 'not a power of two'."
        }
      ],
      "rejected_matches": [
        {
          "fls_id": "fls_rjxpof29a3nl",
          "category": 0,
          "fls_section": "4.-2.29",
          "fls_title": "Struct Type Representation",
          "score": 0.596,
          "reason": "Section about C representation layout, not alignment constraints."
        }
      ],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust prevents alignment of 0 at compile time. Per FLS fls_muxfn9soi47l: 'The alignment of a value... is at least one, and always a power of two.' Attempting #[repr(align(0))] results in compiler error E0589: 'invalid repr(align) attribute: not a power of two'. C's _Alignas(0) meaning 'use default alignment' has no equivalent in Rust - if you want default alignment, simply don't specify any alignment."
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 8.17",
      "guideline_title": "At most one explicit alignment specifier should appear in an object declaration",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_aibb2quva4mn",
            "fls_title": "Attribute repr",
            "category": 0,
            "score": 0.63,
            "reason": "Rust uses #[repr(align(N))] on type definitions, not on variable declarations. Alignment is a property of the type itself."
          },
          {
            "fls_id": "fls_g1z6bpyjqxkz",
            "fls_title": "Type Layout",
            "category": -2,
            "score": 0.72,
            "reason": "Per FLS: 'The alignment of a value specifies which addresses are valid for storing the value.' Alignment is determined by type, not by declaration annotations."
          }
        ],
        "rejected_matches": [
          {
            "fls_id": "fls_rjxpof29a3nl",
            "fls_title": "Struct Type Representation",
            "category": 0,
            "score": 0.71,
            "reason": "This describes how alignment is computed for struct types, not about multiple alignment specifiers."
          }
        ],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no _Alignas equivalent on variable declarations. Alignment is specified on type definitions via #[repr(align(N))]. The type carries its alignment - objects of that type inherit it. No possibility of conflicting alignment specifiers on declarations."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_ohhsmifo0urd",
            "fls_title": "Type Representation",
            "category": -2,
            "score": 0.52,
            "reason": "Per FLS: 'Type representation may be specified using attribute repr and modified further using attribute repr's Alignment representation modifiers.' Alignment is on type, not variable."
          },
          {
            "fls_id": "fls_yivm43r5wnp1",
            "fls_title": "Let Statements",
            "category": -2,
            "score": 0.74,
            "reason": "Per FLS: 'The type of a binding introduced by a let statement is determined...' Let statements specify type, not alignment - alignment comes from the type."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "In safe Rust, alignment is a property of types, not variables. Let bindings introduce variables with a type - the alignment is inherited from that type. No mechanism exists to add alignment specifiers to variable declarations."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 8.18",
      "guideline_title": "There shall be no tentative definitions in a header file C90",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_e9hwvqsib5d5",
            "fls_title": "Modules",
            "category": -2,
            "score": 0.6,
            "reason": "Per FLS: 'A module is a container for zero or more items.' Items are defined once per module, not textually included."
          },
          {
            "fls_id": "fls_xdvdl2ssnhlo",
            "fls_title": "Statics",
            "category": -2,
            "score": 0.6,
            "reason": "Per FLS: 'A static shall have a static initializer, unless it is an external static.' No tentative definitions - statics require initializers."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no header files, no textual inclusion, and no tentative definitions. Modules contain item definitions. Statics require explicit initialization. The one-definition-per-module model prevents duplication issues."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_maw4u1o8q37u",
            "fls_title": "Crates",
            "category": -2,
            "score": 0.66,
            "reason": "Per FLS: 'A crate is a unit of compilation and linking that contains a tree of nested modules.' Crates compile as units, not as separate translation units with textual inclusion."
          },
          {
            "fls_id": "fls_9gprp17h6t1q",
            "fls_title": "Use Imports",
            "category": -2,
            "score": 0.65,
            "reason": "Per FLS: 'An import path prefix shall resolve to a module or enum.' Use imports bring names into scope, they don't duplicate definitions."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust has the same module system as all Rust. No header files, no tentative definitions, no textual inclusion. The crate is the compilation unit with well-defined module structure."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 8.19",
      "guideline_title": "There should be no external declarations in a source file",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_e9hwvqsib5d5",
            "fls_title": "Modules",
            "category": -2,
            "score": 0.48,
            "reason": "Per FLS: 'A module is a container for zero or more items.' Rust uses modules for encapsulation, not header/source file separation."
          },
          {
            "fls_id": "fls_jdknpu3kf865",
            "fls_title": "Visibility",
            "category": -2,
            "score": 0.46,
            "reason": "Per FLS: 'Public visibility is a kind of visibility that allows for a name to be referred to from arbitrary module.' Visibility controls the public interface."
          }
        ],
        "rejected_matches": [
          {
            "fls_id": "fls_tmoh3y9oyqsy",
            "fls_title": "External Blocks",
            "category": 0,
            "score": 0.8,
            "reason": "Extern blocks for FFI are a different concept from C's extern declarations. They're module-level items, not scattered block-scope declarations."
          }
        ],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no header/source file distinction. The module system provides encapsulation. Extern blocks for FFI are module-level items with clear structure, not ad-hoc declarations breaking encapsulation."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_jdknpu3kf865",
            "fls_title": "Visibility",
            "category": -2,
            "score": 0.66,
            "reason": "Per FLS: 'A crate public modifier is a visibility modifier that grants a name public visibility within the current crate only.' Visibility controls encapsulation."
          },
          {
            "fls_id": "fls_m0z7omni9hp0",
            "fls_title": "Item Scope",
            "category": 0,
            "score": 0.6,
            "reason": "Per FLS: 'An item declared within a module is in scope within the related module.' Clear item scoping via modules."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust uses modules and visibility for encapsulation. No extern declarations at arbitrary scopes. The module system provides clear public interfaces via pub/pub(crate) visibility modifiers."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 9.1",
      "guideline_title": "The value of an object with automatic storage duration shall not be read before it has been set C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_3xvm61x0t251",
          "fls_title": "Initialization",
          "category": 0,
          "score": 0.75,
          "reason": "FLS directly addresses this. Contains legality rule: 'A variable shall be initialized before it is accessed.' This is a compiler-enforced rule in Rust."
        },
        {
          "fls_id": "fls_46910buiwvv9",
          "fls_title": "Initialization",
          "category": -2,
          "score": 0.64,
          "reason": "FLS legality rule: 'A variable shall be initialized before it is accessed.' Direct enforcement at compile time."
        },
        {
          "fls_id": "fls_r9km9f969bu8",
          "fls_title": "Variables",
          "category": -2,
          "score": 0.49,
          "reason": "FLS: 'A variable shall be used only after it has been initialized through all reachable control flow paths up to the point of its usage.' Rust's definite initialization analysis."
        },
        {
          "fls_id": "fls_6lg0oaaopc26",
          "fls_title": "Values",
          "category": -4,
          "score": 0.6,
          "reason": "FLS UB: 'It is undefined behavior to create a value from uninitialized memory unless the type of the value is a union type.' Backs up the legality rules."
        },
        {
          "fls_id": "fls_g8etd5lsgn9j",
          "fls_title": "Variables",
          "category": -3,
          "score": 0.67,
          "reason": "FLS: 'A variable is not initialized when allocated.' Establishes the default uninitialized state."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "misra_rust_comment": "enforced by rustc but can be bypassed by unsafe",
      "confidence": "medium",
      "notes": "Rust directly enforces this via compile-time definite initialization analysis. The compiler tracks initialization state through all control flow paths and rejects programs that may use uninitialized variables.",
      "rejected_matches": [
        {
          "fls_id": "fls_hydq3pvm00bn",
          "fls_title": "Struct Type Representation",
          "category": -2,
          "score": 0.59,
          "reason": "Not relevant - discusses struct layout offset initialization, not variable initialization."
        },
        {
          "fls_id": "fls_e5b9n910z1cp",
          "fls_title": "Struct Expressions",
          "category": -2,
          "score": 0.59,
          "reason": "Not relevant - discusses struct expression initializer values, not variable initialization before use."
        }
      ]
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 9.2",
      "guideline_title": "The initializer for an aggregate or union shall be enclosed in braces C90",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_8tsynkj2cufj",
            "fls_title": "Struct Expressions",
            "category": -2,
            "score": 0.81,
            "reason": "Per FLS: 'A named initializer is a construct that specifies the name and initial value of a field in a struct expression.' Struct initialization always uses braces with named fields."
          },
          {
            "fls_id": "fls_xinykul167l",
            "fls_title": "Array Expressions",
            "category": -2,
            "score": 0.8,
            "reason": "Per FLS: 'An array element constructor is an array expression that lists all elements of the array being constructed.' Arrays use clear [a, b, c] or [x; N] syntax."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust's initialization syntax is unambiguous by design. Structs use braces with named fields, arrays use brackets, tuples use parentheses. There's no C-style ambiguous brace elision for nested aggregates."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_k64tfywtn0g8",
            "fls_title": "Tuple Expressions",
            "category": -2,
            "score": 0.73,
            "reason": "Per FLS: 'A tuple expression is an expression that constructs a tuple.' Tuples use (a, b, c) syntax unambiguously."
          },
          {
            "fls_id": "fls_8tsynkj2cufj",
            "fls_title": "Struct Expressions",
            "category": -2,
            "score": 0.71,
            "reason": "Per FLS: 'A constructee indicates the enum variant, struct, or union whose value is being constructed.' All constructee types use clear distinct syntax."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust has the same initialization syntax as all Rust. Each compound type has its own unambiguous syntax: structs use {field: value}, tuples use (a, b), arrays use [a, b, c]."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 9.3",
      "guideline_title": "Arrays shall not be partially initialized",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_xinykul167l",
            "fls_title": "Array Expressions",
            "category": -2,
            "score": 0.71,
            "reason": "Per FLS: 'An array element constructor is an array expression that lists all elements of the array being constructed.' All elements must be provided."
          },
          {
            "fls_id": "fls_xinykul167l",
            "fls_title": "Array Expressions",
            "category": -2,
            "score": 0.71,
            "reason": "Per FLS: 'An array repetition constructor is an array expression that specifies how many times an element is repeated.' Alternative syntax [v; N] initializes all N elements with v."
          }
        ],
        "rejected_matches": [
          {
            "fls_id": "fls_94a8v54bufn8",
            "fls_title": "Values",
            "category": -4,
            "score": 0.48,
            "reason": "UB for uninitialized values, but this is about preventing UB, not about partial init syntax."
          }
        ],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust arrays cannot be partially initialized. Either list all elements [a, b, c, d] or use repetition [x; N]. There's no mechanism to leave some elements unspecified. MaybeUninit is unsafe and explicit, not implicit partial init."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_xinykul167l",
            "fls_title": "Array Expressions",
            "category": -2,
            "score": 0.61,
            "reason": "Per FLS: 'If the size operand is greater than one, then the type of the repeat operand shall implement the core::copy::Copy trait.' Repetition syntax requires Copy, ensuring all elements get values."
          },
          {
            "fls_id": "fls_3xvm61x0t251",
            "fls_title": "Initialization",
            "category": -2,
            "score": 0.5,
            "reason": "Per FLS: 'Initialization is the act of supplying an initial value to a variable.' Rust requires explicit initialization - no implicit partial init."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust has identical array initialization requirements. All elements must be explicitly initialized, either by listing them or using repetition [v; N] which requires v: Copy."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 9.4",
      "guideline_title": "An element of an object shall not be initialized more than once",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "yes",
        "adjusted_category": "required",
        "rationale_type": "direct_mapping",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_8tsynkj2cufj",
            "fls_title": "Struct Expressions",
            "category": 0,
            "score": 0.63,
            "reason": "Per FLS: Struct expressions define field initialization rules. The compiler enforces that each field is initialized exactly once."
          },
          {
            "fls_id": "fls_j2kmp1fee0g4",
            "fls_title": "Struct Expressions legality",
            "category": -2,
            "score": 0.58,
            "reason": "Per FLS: 'Contain at most one matched indexed initializer' - directly prevents duplicate field initialization."
          },
          {
            "fls_id": "fls_3xvm61x0t251",
            "fls_title": "Initialization",
            "category": 0,
            "score": 0.78,
            "reason": "Per FLS: 'Initialization is the act of supplying an initial value to a variable.' Defines the initialization semantics."
          },
          {
            "fls_id": "fls_xinykul167l",
            "fls_title": "Array Expressions",
            "category": 0,
            "score": 0.63,
            "reason": "Per FLS: Array expressions list elements in order; duplicate index initialization is not syntactically possible."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 1,
        "notes": "MISRA Rule 9.4 (no duplicate initialization) is enforced by rustc. Per MISRA ADD-6: 'enforced by rustc'. Struct expressions require each field to be initialized exactly once - duplicate field initializers are a compile error. Array expressions use positional initialization, making duplicate element initialization syntactically impossible."
      },
      "safe_rust": {
        "applicability": "yes",
        "adjusted_category": "required",
        "rationale_type": "direct_mapping",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_8tsynkj2cufj",
            "fls_title": "Struct Expressions",
            "category": 0,
            "score": 0.62,
            "reason": "Per FLS: Struct expressions have well-defined initialization semantics. The compiler enforces unique field initialization."
          },
          {
            "fls_id": "fls_57t368kema7h",
            "fls_title": "Struct Expressions legality",
            "category": -2,
            "score": 0.75,
            "reason": "Per FLS: Shorthand initializers specify field names. Duplicate field names are a compile error."
          },
          {
            "fls_id": "fls_lwyq3vyc91rn",
            "fls_title": "Struct Expressions legality",
            "category": -2,
            "score": 0.65,
            "reason": "Per FLS: 'A named initializer is a construct that specifies the name and initial value of a field.' Each field can only appear once."
          },
          {
            "fls_id": "fls_3xvm61x0t251",
            "fls_title": "Initialization",
            "category": 0,
            "score": 0.58,
            "reason": "Per FLS: Initialization semantics ensure values are initialized exactly once before use."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 1,
        "notes": "Same as all_rust - this is fully enforced by the compiler in both contexts. Struct field initialization requires each field to be specified exactly once. Array element initialization uses positional syntax that cannot duplicate indices. Per MISRA ADD-6: 'enforced by rustc'."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 9.5",
      "guideline_title": "Where designated initializers are used to initialize an array object the size of the array shall be specified explicitly",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_xinykul167l",
            "fls_title": "Array Expressions",
            "category": -2,
            "score": 0.69,
            "reason": "Per FLS: 'If the array expression appears with an array element constructor, then the size is the number of operands.' Array size is determined by element count, not indices."
          },
          {
            "fls_id": "fls_uj0kpjwyld60",
            "fls_title": "Array Types",
            "category": -2,
            "score": 0.72,
            "reason": "Per FLS: 'The size operand shall be a constant expression or an inferred constant.' Array types always have explicit size in the type [T; N]."
          }
        ],
        "rejected_matches": [
          {
            "fls_id": "fls_8tsynkj2cufj",
            "fls_title": "Struct Expressions",
            "category": -2,
            "score": 0.72,
            "reason": "Indexed initializers are for tuple struct fields by position, not array elements by index. Completely different concept."
          }
        ],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no designated initializers for arrays. Array size is either the count of listed elements [a, b, c] or explicit in repetition [v; N]. No index-based initialization exists that could implicitly determine size."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_xinykul167l",
            "fls_title": "Array Expressions",
            "category": 0,
            "score": 0.52,
            "reason": "Rust arrays use [expr; count] or [elem1, elem2, ...] syntax - no designated initializers"
          },
          {
            "fls_id": "fls_2gto5kp9bjw8",
            "fls_title": "Array Expressions",
            "category": -2,
            "score": 0.45,
            "reason": "Per FLS: 'If the array expression appears with an array element constructor, then the size is the number of operands.' Rust arrays derive size from element count, not from designated indices - no mechanism exists to implicitly size an array via index positions."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust: Same as all_rust - no designated initializers exist in Rust array syntax"
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 9.6",
      "guideline_title": "An initializer using chained designators shall not contain initializers without designators",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_8tsynkj2cufj",
            "fls_title": "Struct Expressions",
            "category": 0,
            "score": 0.55,
            "reason": "Rust struct expressions use named initializers (field: value) which MUST name each field - no chained designators exist"
          },
          {
            "fls_id": "fls_lwyq3vyc91rn",
            "fls_title": "Named Initializer",
            "category": -2,
            "score": 0.8,
            "reason": "A named initializer specifies name and initial value - no C-style chained designators (.a.b.c = value)"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no chained designator syntax. Nested structs must be initialized as complete struct expressions: Outer { inner: Inner { field: value } }. No positional initialization ambiguity possible."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_8tsynkj2cufj",
            "fls_title": "Struct Expressions",
            "category": 0,
            "score": 0.64,
            "reason": "Rust struct expressions require named initializers - no chained designator syntax exists"
          },
          {
            "fls_id": "fls_uib1ml41mfrn",
            "fls_title": "Base Initializer",
            "category": -2,
            "score": 0.74,
            "reason": "Base initializer (..expr) copies fields from same type - no positional ambiguity"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust: Same as all_rust - no chained designators exist. Nested structs require complete struct expressions."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 9.7",
      "guideline_title": "Atomic objects shall be appropriately initialized before being accessed C11",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "yes",
        "adjusted_category": "required",
        "rationale_type": "direct_mapping",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_vyc9vcuamlph",
            "fls_title": "Atomics",
            "category": 0,
            "score": 0.82,
            "reason": "Per FLS: 'Atomic types provide primitive shared-memory communication between threads.' Atomics must be properly initialized before use."
          },
          {
            "fls_id": "fls_3pjla9s93mhd",
            "fls_title": "Atomics legality",
            "category": -2,
            "score": 0.71,
            "reason": "Per FLS: Defines atomic types in core::sync::atomic. These types have const constructors (e.g., AtomicI32::new(0)) for initialization."
          },
          {
            "fls_id": "fls_xdvdl2ssnhlo",
            "fls_title": "Statics",
            "category": 0,
            "score": 0.54,
            "reason": "Per FLS: Static atomics require initialization. 'The expression of a static initializer shall be a constant expression.'"
          },
          {
            "fls_id": "fls_3xvm61x0t251",
            "fls_title": "Initialization",
            "category": 0,
            "score": 0.66,
            "reason": "Per FLS: 'A variable shall be initialized before it is accessed.' Applies to atomic variables."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 1,
        "notes": "MISRA Rule 9.7 (atomic initialization) maps to Rust's atomic types in core::sync::atomic. Rust's type system requires atomics to be initialized at construction (AtomicI32::new(value)). However, unsafe code can create uninitialized atomics via MaybeUninit or transmute, hence the guideline applies to all_rust."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "rust_prevents",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_3xvm61x0t251",
            "fls_title": "Initialization",
            "category": 0,
            "score": 0.63,
            "reason": "Per FLS: 'A variable shall be initialized before it is accessed.' The compiler enforces this for all types including atomics."
          },
          {
            "fls_id": "fls_46910buiwvv9",
            "fls_title": "Initialization legality",
            "category": -2,
            "score": 0.73,
            "reason": "Per FLS: 'A variable shall be initialized before it is accessed.' Compile-time enforcement."
          },
          {
            "fls_id": "fls_6lg0oaaopc26",
            "fls_title": "Values undefined_behavior",
            "category": -4,
            "score": 0.6,
            "reason": "Per FLS: 'It is undefined behavior to create a value from uninitialized memory unless the type of the value is a union type.' Safe Rust prevents this."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 1,
        "notes": "In safe Rust, the type system prevents accessing uninitialized atomics. AtomicI32::new(value) is the only way to create an atomic - there's no way to create an uninitialized atomic without unsafe code (MaybeUninit, transmute). The compiler enforces 'variable shall be initialized before accessed' at compile time."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 10.1",
      "guideline_title": "Operands shall not be of an inappropriate essential type C90 [Unspecified 23; Implementation G.3.4(8), G.3.5(3,5), G.3.9(6)] C99 [Undefined 13, 48, 49; Implementation J.3.4(2,5), J.3.5(5), J.3.9(6)] C11 [Undefined 15, 51, 52; Implementation J.3.4(2,5), J.3.5(5), J.3.9(7)]",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "rust_prevents",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_abp6tjbz8tpn",
            "fls_title": "Bit Expressions",
            "category": 0,
            "score": 0.766,
            "reason": "Bitwise operators require trait implementations. fls_onutb0b9p9zj, fls_1f4pc612f2a8: operands must implement BitAnd/Or/Xor/Not traits. Using inappropriate type (e.g., boolean in bitwise op) is compile error."
          },
          {
            "fls_id": "fls_lv7w7aalpwm5",
            "fls_title": "Type Inference",
            "category": 0,
            "score": 0.719,
            "reason": "fls_Tx4Sx4Qy8y2d: static error if types cannot be unified. Inappropriate types caught at compile time."
          },
          {
            "fls_id": "fls_dw33yt5g6m0k",
            "fls_title": "Type Coercion",
            "category": 0,
            "score": 0.79,
            "reason": "Type coercion is limited and does NOT include bool/char/int/enum conversions - no C-style implicit promotions"
          },
          {
            "fls_id": "fls_tiqp1gxf116z",
            "fls_title": "Bool Type",
            "category": 0,
            "score": 0.72,
            "reason": "Bool is a distinct type - cannot be used in arithmetic without explicit conversion"
          },
          {
            "fls_id": "fls_szibmtfv117b",
            "fls_title": "Enum Types",
            "category": 0,
            "score": 0.76,
            "reason": "Enum discriminants are opaque integers - no implicit conversion to int for arithmetic"
          },
          {
            "fls_id": "fls_1k9mkv7rbezi",
            "fls_title": "Arithmetic Expressions",
            "category": 0,
            "score": 0.712,
            "reason": "Arithmetic requires Add/Sub/Mul/Div/Rem traits. Type system enforces appropriate operand types. No implicit conversions."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust type system prevents inappropriate type mixing. Operators use traits (Add, Mul, BitAnd, etc.) only implemented for valid combinations. Bitwise and arithmetic operators require specific trait implementations, catching inappropriate operand types at compile time. No implicit bool-to-int, char-to-int, or enum-to-int."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "rust_prevents",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_abp6tjbz8tpn",
            "fls_title": "Bit Expressions",
            "category": 0,
            "score": 0.766,
            "reason": "Bitwise operators require trait implementations - inappropriate types cause compile error."
          },
          {
            "fls_id": "fls_lv7w7aalpwm5",
            "fls_title": "Type Inference",
            "category": 0,
            "score": 0.719,
            "reason": "Static error if types cannot be unified - inappropriate types caught at compile time."
          },
          {
            "fls_id": "fls_tiqp1gxf116z",
            "fls_title": "Bool Type",
            "category": 0,
            "score": 0.62,
            "reason": "Bool is distinct from integers - no implicit conversion in operators"
          },
          {
            "fls_id": "fls_wrvjizrqf3po",
            "fls_title": "Char Type",
            "category": 0,
            "score": 0.57,
            "reason": "Char is Unicode scalar value (u32 range) but distinct type - no implicit int conversion"
          },
          {
            "fls_id": "fls_1qhsun1vyarz",
            "fls_title": "Type Cast Expressions",
            "category": -2,
            "score": 0.66,
            "reason": "Explicit 'as' cast required for bool/char to int - no implicit conversion"
          },
          {
            "fls_id": "fls_1k9mkv7rbezi",
            "fls_title": "Arithmetic Expressions",
            "category": 0,
            "score": 0.712,
            "reason": "Arithmetic requires Add/Sub/Mul/Div/Rem traits. Type system enforces appropriate operand types. No implicit conversions."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust: Same as all_rust. Type system enforces operator trait bounds (BitAnd, Add, etc.). Cannot mix bool/char/int/enum in operations - inappropriate types caught at compile time."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 10.2",
      "guideline_title": "Expressions of essentially character type shall not be used inappropriately in addition and subtraction operations",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "rust_prevents",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_wrvjizrqf3po",
            "fls_title": "Char Type",
            "category": 0,
            "score": 0.6,
            "reason": "Char is a distinct Unicode scalar type - NOT an integer type like in C"
          },
          {
            "fls_id": "fls_1k9mkv7rbezi",
            "fls_title": "Arithmetic Expressions",
            "category": 0,
            "score": 0.71,
            "reason": "Addition/subtraction require Add/Sub traits - char does not implement these"
          },
          {
            "fls_id": "fls_eb00s8fxlvjb",
            "fls_title": "Type Cast Expressions",
            "category": -2,
            "score": 0.65,
            "reason": "Char to integer requires explicit 'as' cast - makes arithmetic intentional"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust char has no arithmetic operators. Must cast to u32 first: ('9' as u32) - ('0' as u32). All char arithmetic is explicit."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "rust_prevents",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_wrvjizrqf3po",
            "fls_title": "Char Type",
            "category": 0,
            "score": 0.48,
            "reason": "Char is Unicode scalar (0x0-0xD7FF, 0xE000-0x10FFFF) - distinct from integers"
          },
          {
            "fls_id": "fls_fjcv1nm8tlgf",
            "fls_title": "Arithmetic Expressions",
            "category": -2,
            "score": 0.59,
            "reason": "Subtraction requires Sub trait implementation - char does not implement Sub"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust: Same as all_rust. Char type does not implement Add/Sub. Arithmetic requires explicit cast to integer type."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 10.3",
      "guideline_title": "The value of an expression shall not be assigned to an object with a narrower essential type or of a different essential type category C90 [Undefined 15; Implementation G.3.5(2)] C99 [Undefined 15, 16; Implementation J.3.5(4)] C11 [Undefined 17, 18; Implementation J.3.5(4)]",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "rust_prevents",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_1qhsun1vyarz",
            "fls_title": "Type Cast Expressions",
            "category": 0,
            "score": 0.681,
            "reason": "Explicit 'as' cast required for type conversions. fls_76eq3bd6birr documents truncation behavior when narrowing - developer must explicitly choose."
          },
          {
            "fls_id": "fls_exe4zodlwfez",
            "fls_title": "Type Unification",
            "category": 0,
            "score": 0.68,
            "reason": "A scalar type is unifiable only with itself - no implicit narrowing"
          },
          {
            "fls_id": "fls_dw33yt5g6m0k",
            "fls_title": "Type Coercion",
            "category": 0,
            "score": 0.75,
            "reason": "Type coercion does not include numeric type conversions - only reference/pointer coercions"
          },
          {
            "fls_id": "fls_awJeqcAHn5O3",
            "fls_title": "Assignment Expressions",
            "category": -2,
            "score": 0.63,
            "reason": "Assignment requires value operand type is subtype of assignee - enforces type compatibility"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no implicit narrowing. Assigning i64 to i32 is compile error. All numeric conversions require explicit 'as' cast."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "rust_prevents",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_1qhsun1vyarz",
            "fls_title": "Type Cast Expressions",
            "category": 0,
            "score": 0.681,
            "reason": "Explicit 'as' cast required for type conversions - developer must explicitly choose narrowing."
          },
          {
            "fls_id": "fls_dhksyjrvx9a",
            "fls_title": "Type Unification",
            "category": -2,
            "score": 0.66,
            "reason": "A scalar type is unifiable only with itself - i32 != i64"
          },
          {
            "fls_id": "fls_1prqh1trybwz",
            "fls_title": "Let Statements",
            "category": -2,
            "score": 0.61,
            "reason": "Let statement type determined by annotation or inference - must match initializer"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust: Same as all_rust. Type system enforces exact type match for assignments. No implicit narrowing possible."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 10.4",
      "guideline_title": "Both operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type category C90 [Implementation G.3.6(2)], C99 [Implementation J.3.6(4)], C11 [Implementation J.3.6(5)]",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "rust_prevents",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_sLCBZ3vG1AWs",
            "fls_title": "Type Inference",
            "category": -2,
            "score": 0.56,
            "reason": "Unify types of both operands for numeric expressions - must be same type"
          },
          {
            "fls_id": "fls_hrml95g2txcj",
            "fls_title": "Arithmetic Expressions",
            "category": -2,
            "score": 0.7,
            "reason": "Left operand shall implement Mul trait where right operand is the trait impl type - enforces matching types"
          },
          {
            "fls_id": "fls_Et5gp1I7VqBX",
            "fls_title": "Arithmetic Expressions",
            "category": -3,
            "score": 0.73,
            "reason": "If type of both operands is same integer or float type, then evaluate - requires same type"
          },
          {
            "fls_id": "fls_dw33yt5g6m0k",
            "fls_title": "Type Coercion",
            "category": -2,
            "score": 0.48,
            "reason": "Per FLS: No implicit numeric widening or narrowing. The 'usual arithmetic conversions' from C simply don't exist in Rust."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no usual arithmetic conversions. i32 + i64 is compile error. Operands must have same type or explicit cast required."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "rust_prevents",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_qqrqyc6uhol",
            "fls_title": "Integer Literals",
            "category": -2,
            "score": 0.71,
            "reason": "Type inference defaults to i32 but never implicitly promotes between different integer types"
          },
          {
            "fls_id": "fls_4nnqz4etisgw",
            "fls_title": "Compound Assignment",
            "category": -3,
            "score": 0.63,
            "reason": "If types of both operands are integer or float types, then evaluate - same type required"
          },
          {
            "fls_id": "fls_dw33yt5g6m0k",
            "fls_title": "Type Coercion",
            "category": -2,
            "score": 0.48,
            "reason": "Per FLS: No implicit numeric widening or narrowing. The 'usual arithmetic conversions' from C simply don't exist in Rust."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust: Same as all_rust. No implicit type promotion between different numeric types. All conversions must be explicit."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 10.5",
      "guideline_title": "The value of an expression should not be cast to an inappropriate essential type",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "yes",
        "adjusted_category": "recommended",
        "rationale_type": "direct_mapping",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_1qhsun1vyarz",
            "fls_title": "Type Cast Expressions",
            "category": 0,
            "score": 0.88,
            "reason": "Per FLS: Defines all type cast semantics including numeric casts, enum casts, and primitive-to-integer casts."
          },
          {
            "fls_id": "fls_4s69s9pcvbn7",
            "fls_title": "Type Cast Expressions legality",
            "category": -2,
            "score": 0.81,
            "reason": "Per FLS: 'An operand of a numeric type and a target numeric type perform a numeric cast.' Defines legal numeric cast combinations."
          },
          {
            "fls_id": "fls_le6bchl25ewz",
            "fls_title": "Type Cast Expressions legality",
            "category": -2,
            "score": 0.76,
            "reason": "Per FLS: 'An operand of an enum type and a target integer type perform enum cast.' Enum-to-integer casting semantics."
          },
          {
            "fls_id": "fls_pcromhosmnf0",
            "fls_title": "Type Cast Expressions legality",
            "category": -2,
            "score": 0.74,
            "reason": "Per FLS: Defines bool/char to integer cast rules."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 1,
        "notes": "MISRA Rule 10.5 (inappropriate type casts) applies to Rust's 'as' operator and transmute. Per MISRA ADD-6: 'includes both safe as and unsafe transmute operations'. The FLS defines precise semantics for all cast combinations. Some casts (like bool-to-integer) may violate MISRA intent even though they're well-defined in Rust."
      },
      "safe_rust": {
        "applicability": "partial",
        "adjusted_category": "recommended",
        "rationale_type": "partial_mapping",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_1qhsun1vyarz",
            "fls_title": "Type Cast Expressions",
            "category": 0,
            "score": 0.88,
            "reason": "Per FLS: The 'as' operator is available in safe Rust for numeric, enum, and primitive casts."
          },
          {
            "fls_id": "fls_dw33yt5g6m0k",
            "fls_title": "Type Coercion",
            "category": 0,
            "score": 0.77,
            "reason": "Per FLS: 'Type coercion is an implicit operation that changes the type of a value.' Defines all implicit conversions."
          },
          {
            "fls_id": "fls_3ww5gbk9w4ys",
            "fls_title": "Type Cast Expressions legality",
            "category": -2,
            "score": 0.72,
            "reason": "Per FLS: 'A cast is legal when it either performs type coercion or is a specialized cast.' Defines what casts are legal."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 1,
        "notes": "Safe Rust has 'as' casts (no transmute). Per MISRA ADD-6: 'Partial' because 'as' casts are available but transmute is not. The guideline applies to inappropriate use of 'as' like casting bool to integer or truncating integer casts. Type coercion (implicit) is generally safer but can still cause issues (e.g., deref coercion)."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 10.6",
      "guideline_title": "The value of a composite expression shall not be assigned to an object with wider essential type",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "rust_prevents",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_vk17mfv47wk9",
            "fls_title": "Arithmetic Expressions",
            "category": -2,
            "score": 0.64,
            "reason": "Type of addition is Add::Output - for primitives, same as operand type, no implicit widening"
          },
          {
            "fls_id": "fls_awJeqcAHn5O3",
            "fls_title": "Subtyping and Variance",
            "category": -2,
            "score": 0.7,
            "reason": "Assignment requires value operand is subtype of assignee - prevents implicit widening"
          },
          {
            "fls_id": "fls_dw33yt5g6m0k",
            "fls_title": "Type Coercion",
            "category": -2,
            "score": 0.53,
            "reason": "Per FLS: No implicit widening coercions. The C pattern of 'u32 x = u16_a + u16_b' (implicit widening) doesn't compile in Rust."
          },
          {
            "fls_id": "fls_y4by2i8dl05o",
            "fls_title": "Assignment Expressions",
            "category": -2,
            "score": 0.58,
            "reason": "Per FLS: Assignment requires types to match exactly. Cannot assign u16 result to u32 variable without explicit cast."
          },
          {
            "fls_id": "fls_ZfIBiJMf8qE1",
            "fls_title": "Arithmetic Overflow",
            "category": -1,
            "score": 0.45,
            "reason": "Per FLS: Overflow has defined behavior (panic or wrap), not UB. Even if narrow arithmetic overflows, behavior is deterministic."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no integer promotion. i16 + i16 = i16 (not int). To widen, must cast operands first. No hidden overflow in narrower type."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "rust_prevents",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_ittf4yggk7do",
            "fls_title": "Arithmetic Expressions",
            "category": -2,
            "score": 0.63,
            "reason": "Multiplication result type is Mul::Output - same as operands for primitives"
          },
          {
            "fls_id": "fls_1prqh1trybwz",
            "fls_title": "Let Statements",
            "category": -2,
            "score": 0.74,
            "reason": "Binding type determined by ascription or inference - must match initializer"
          },
          {
            "fls_id": "fls_dw33yt5g6m0k",
            "fls_title": "Type Coercion",
            "category": -2,
            "score": 0.53,
            "reason": "Per FLS: No implicit widening coercions. The C pattern of 'u32 x = u16_a + u16_b' (implicit widening) doesn't compile in Rust."
          },
          {
            "fls_id": "fls_y4by2i8dl05o",
            "fls_title": "Assignment Expressions",
            "category": -2,
            "score": 0.58,
            "reason": "Per FLS: Assignment requires types to match exactly. Cannot assign u16 result to u32 variable without explicit cast."
          },
          {
            "fls_id": "fls_ZfIBiJMf8qE1",
            "fls_title": "Arithmetic Overflow",
            "category": -1,
            "score": 0.45,
            "reason": "Per FLS: Overflow has defined behavior (panic or wrap), not UB. Even if narrow arithmetic overflows, behavior is deterministic."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust: Same as all_rust. No implicit widening. Result type of arithmetic operations matches operand types."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 10.7",
      "guideline_title": "If a composite expression is used as one operand of an operator in which the usual arithmetic conversions are performed then the other operand shall not have wider essential type",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "rust_prevents",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_8imzo7agyx0k",
            "fls_title": "Arithmetic Expressions",
            "category": -2,
            "score": 0.68,
            "reason": "Left operand shall implement Add trait with right operand as type parameter - enforces same type"
          },
          {
            "fls_id": "fls_NcLf4o1dpniS",
            "fls_title": "Arithmetic Expressions",
            "category": -3,
            "score": 0.67,
            "reason": "If both operands are same type, evaluate to sum - requires same type"
          },
          {
            "fls_id": "fls_dw33yt5g6m0k",
            "fls_title": "Type Coercion",
            "category": -2,
            "score": 0.48,
            "reason": "Per FLS: No implicit widening. The scenario this rule prevents cannot occur because Rust rejects type mismatches."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no implicit widening. (i16 + i16) + i32 is compile error. Each operator requires same-type operands. No hidden promotions."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "rust_prevents",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_kc3gwj9x3jnr",
            "fls_title": "Type Cast Expressions",
            "category": -3,
            "score": 0.68,
            "reason": "Casting same-size integers has no effect - but cast is required, not implicit"
          },
          {
            "fls_id": "fls_ittf4yggk7do",
            "fls_title": "Arithmetic Expressions",
            "category": -2,
            "score": 0.63,
            "reason": "Result type is Mul::Output - matches operand type for primitives"
          },
          {
            "fls_id": "fls_dw33yt5g6m0k",
            "fls_title": "Type Coercion",
            "category": -2,
            "score": 0.48,
            "reason": "Per FLS: No implicit widening. The scenario this rule prevents cannot occur because Rust rejects type mismatches."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust: Same as all_rust. No implicit type widening in expression chains. All conversions require explicit casts."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 10.8",
      "guideline_type": "rule",
      "applicability_all_rust": "partial",
      "applicability_safe_rust": "partial",
      "fls_rationale_type": "partial_mapping",
      "misra_rust_category": "advisory",
      "misra_rust_comment": "includes both safe `as` and unsafe `transmute` operations",
      "confidence": "medium",
      "notes": "Rust allows explicit widening casts after narrow arithmetic. The MISRA concern is partially mitigated by defined overflow behavior, but explicit casts can still mask programmer intent errors.",
      "guideline_title": "The value of a composite expression shall not be cast to a different essential type category or a wider essential type",
      "rejected_matches": [
        {
          "fls_id": "fls_abp6tjbz8tpn",
          "fls_title": "Bit Expressions",
          "score": 0.54,
          "reason": "About bitwise operators, not casting composite expressions",
          "fls_section": "6.5.6",
          "category": -2
        },
        {
          "fls_id": "fls_exe4zodlwfez",
          "fls_title": "Type Unification",
          "score": 0.5,
          "reason": "About type inference, not explicit casting",
          "fls_section": "4.12.2",
          "category": -2
        }
      ],
      "accepted_matches": [
        {
          "fls_id": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "score": 0.66,
          "reason": "Per FLS: Rust allows explicit widening casts after narrow arithmetic: '(a + b) as u32' is legal. The cast is explicit, making intent clear, but can still mask overflow issues.",
          "fls_section": "6.5.10",
          "category": -2
        },
        {
          "fls_id": "fls_ZfIBiJMf8qE1",
          "fls_title": "Arithmetic Overflow",
          "score": 0.48,
          "reason": "Per FLS: Overflow has DEFINED behavior (panic in debug, wrap in release) - not UB like C. Mitigates but doesn't eliminate the MISRA concern about implementation-dependent results.",
          "fls_section": "6.23",
          "category": -1
        }
      ]
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 11.1",
      "guideline_title": "Conversions shall not be performed between a pointer to a function and any other type C90",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "yes",
        "adjusted_category": "required",
        "rationale_type": "direct_mapping",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_xztr1kebz8bo",
            "fls_title": "Function Pointer Types",
            "category": 0,
            "score": 0.77,
            "reason": "Per FLS: Defines function pointer type semantics. Function pointers have strict type requirements."
          },
          {
            "fls_id": "fls_bhw2j9wjpf2x",
            "fls_title": "Type Cast Expressions legality",
            "category": -2,
            "score": 0.74,
            "reason": "Per FLS: 'function-pointer-to-address cast' converts fn pointer to integer. This is the cast MISRA Rule 11.1 prohibits."
          },
          {
            "fls_id": "fls_133j6xw8k4qe",
            "fls_title": "Type Cast Expressions legality",
            "category": -2,
            "score": 0.62,
            "reason": "Per FLS: 'function-pointer-to-raw-pointer cast' also relevant - converting fn pointer to data pointer."
          },
          {
            "fls_id": "fls_ppd1xwve3tr7",
            "fls_title": "Raw Pointer Types",
            "category": 0,
            "score": 0.63,
            "reason": "Per FLS: Raw pointer types are involved in unsafe function pointer conversions."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 1,
        "notes": "MISRA Rule 11.1 (no fn pointer to non-fn pointer conversion) maps directly to Rust. Per FLS: function-pointer-to-address and function-pointer-to-raw-pointer casts exist but are generally unsafe patterns. The 'as' cast allows these conversions. transmute can bypass type checking entirely."
      },
      "safe_rust": {
        "applicability": "partial",
        "adjusted_category": "required",
        "rationale_type": "partial_mapping",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_xztr1kebz8bo",
            "fls_title": "Function Pointer Types",
            "category": 0,
            "score": 0.77,
            "reason": "Per FLS: Function pointer types have strict safety requirements. Converting fn to non-fn pointer is limited in safe Rust."
          },
          {
            "fls_id": "fls_airvr79xkcag",
            "fls_title": "Function Item Types",
            "category": 0,
            "score": 0.59,
            "reason": "Per FLS: 'A function item type is coercible to a function pointer type.' This safe coercion doesn't involve data pointers."
          },
          {
            "fls_id": "fls_ulcdetwp6x96",
            "fls_title": "Type Coercion legality",
            "category": -2,
            "score": 0.65,
            "reason": "Per FLS: Function item to function pointer coercion is the primary safe fn conversion path."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 1,
        "notes": "In safe Rust, function pointer casts are limited. You can coerce function items to fn pointers (safe), but cannot cast fn pointers to data pointers or integers without 'as'. Per MISRA ADD-6: 'Partial' - 'as' casts are available. The unsafe transmute is not available in safe Rust. Closures use Fn/FnMut/FnOnce traits, not raw pointers."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 11.2",
      "guideline_title": "Conversions shall not be performed between a pointer to an incomplete type and any other type C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "category": 0,
          "score": 0.59,
          "reason": "FLS specifies pointer cast rules. Pointer-to-pointer, pointer-to-address, and address-to-pointer casts require target/source types to implement Sized. This prevents casts involving Rust's equivalent of incomplete types (!Sized/DST)."
        },
        {
          "fls_id": "fls_t16yzaxro5ew",
          "fls_title": "Type Cast Expressions",
          "category": -2,
          "score": 0.58,
          "reason": "FLS: 'An operand of type *const T or *mut T and a target type *const V or *mut V where V implements the core::marker::Sized trait performs pointer-to-pointer cast.' Target type must be Sized."
        },
        {
          "fls_id": "fls_i4zsbbmfa2fl",
          "fls_title": "Type Cast Expressions",
          "category": -2,
          "score": 0.62,
          "reason": "FLS: 'An operand of type *const T or *mut T where T implements the core::marker::Sized trait and a target integer type perform pointer-to-address cast.' Source type must be Sized."
        },
        {
          "fls_id": "fls_26Xgem831Nqg",
          "fls_title": "Type Layout",
          "category": -2,
          "score": 0.64,
          "reason": "FLS: 'A dynamically sized type is a type that does not implement the core::marker::Sized trait.' Defines Rust's equivalent of C incomplete types."
        },
        {
          "fls_id": "fls_hidfwkwr2r73",
          "fls_title": "Generic Parameters",
          "category": -2,
          "score": 0.63,
          "reason": "FLS: 'A type parameter has an implicit core::marker::Sized bound.' The Sized constraint is pervasive, preventing most operations on unsized types."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Rust's Sized trait directly addresses this. Pointer casts explicitly require Sized types, preventing conversions involving dynamically sized (incomplete) types. This is compiler-enforced in safe Rust and well-defined in unsafe Rust.",
      "rejected_matches": [
        {
          "fls_id": "fls_ismr7wwvek4q",
          "fls_title": "Type Unification",
          "category": -2,
          "score": 0.67,
          "reason": "While relevant to type compatibility, this discusses type unification rules not cast restrictions."
        }
      ]
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 11.3",
      "guideline_title": "A conversion shall not be performed between a pointer to object type and a pointer to a different object type C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "category": 0,
          "score": 0.59,
          "reason": "FLS defines pointer-to-pointer cast rules. While the cast *const T to *const V is allowed in unsafe Rust, dereferencing requires unsafe context and is subject to alignment/validity invariants."
        },
        {
          "fls_id": "fls_t16yzaxro5ew",
          "fls_title": "Type Cast Expressions",
          "category": -2,
          "score": 0.66,
          "reason": "FLS: 'An operand of type *const T or *mut T and a target type *const V or *mut V where V implements the core::marker::Sized trait performs pointer-to-pointer cast.' The cast itself is defined but dereference has strict requirements."
        },
        {
          "fls_id": "fls_8i4jzksxlrw0",
          "fls_title": "Dereference Expression",
          "category": -2,
          "score": 0.47,
          "reason": "FLS: 'Dereferencing a raw pointer shall require unsafe context unless the dereference expression is the operand of a raw borrow expression.' Ensures programmer acknowledges risks."
        },
        {
          "fls_id": "fls_a14slch83hzn",
          "fls_title": "Borrowing",
          "category": 0,
          "score": 0.67,
          "reason": "In safe Rust, references (&T, &mut T) cannot be cast between incompatible types. Rust's borrow system prevents type aliasing violations at compile time."
        },
        {
          "fls_id": "fls_9wgldua1u8yt",
          "fls_title": "Dereference Expression",
          "category": -4,
          "score": 0.67,
          "reason": "FLS UB: 'It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.' Addresses MISRA's alignment concern."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Safe Rust prevents this entirely - references are strictly typed. In unsafe Rust, pointer casts are allowed but dereferencing requires unsafe context and is subject to alignment/validity requirements. MISRA concern about alignment is addressed by FLS UB rules.",
      "rejected_matches": [
        {
          "fls_id": "fls_k6ues2936pjq",
          "fls_title": "Raw Pointer Types",
          "category": -2,
          "score": 0.69,
          "reason": "While relevant, this is about comparing raw pointers not casting between types."
        }
      ]
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 11.4",
      "guideline_title": "A conversion shall not be performed between a pointer to object and an arithmetic type C90",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "yes",
        "adjusted_category": "required",
        "rationale_type": "direct_mapping",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_1qhsun1vyarz",
            "fls_title": "Type Cast Expressions",
            "category": 0,
            "score": 0.81,
            "reason": "Per FLS: Defines pointer-to-address and address-to-pointer casts. These are the conversions MISRA Rule 11.4 concerns."
          },
          {
            "fls_id": "fls_i4zsbbmfa2fl",
            "fls_title": "Type Cast Expressions legality",
            "category": -2,
            "score": 0.67,
            "reason": "Per FLS: 'pointer-to-address cast' - '*const T as usize' produces the memory address as an integer."
          },
          {
            "fls_id": "fls_59mpteeczzo",
            "fls_title": "Type Cast Expressions legality",
            "category": -2,
            "score": 0.69,
            "reason": "Per FLS: 'address-to-pointer cast' - 'usize as *const T' creates a pointer from an integer address."
          },
          {
            "fls_id": "fls_ppd1xwve3tr7",
            "fls_title": "Raw Pointer Types",
            "category": 0,
            "score": 0.64,
            "reason": "Per FLS: Raw pointer types involved in pointer-integer conversions."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 1,
        "notes": "MISRA Rule 11.4 (no pointer-to-integer conversion) maps to Rust's 'as' casts between raw pointers and usize/isize. Per FLS: pointer-to-address and address-to-pointer casts are explicitly defined. These casts are allowed in safe Rust but lose provenance information."
      },
      "safe_rust": {
        "applicability": "yes",
        "adjusted_category": "required",
        "rationale_type": "direct_mapping",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_1qhsun1vyarz",
            "fls_title": "Type Cast Expressions",
            "category": 0,
            "score": 0.81,
            "reason": "Per FLS: Safe Rust allows '&T as *const T as usize' - reference to raw pointer to integer chain is valid in safe code."
          },
          {
            "fls_id": "fls_qztk0bkju9u",
            "fls_title": "Borrow Expression",
            "category": 0,
            "score": 0.64,
            "reason": "Per FLS: 'The value of a borrow expression is the address of its operand.' References carry address information."
          },
          {
            "fls_id": "fls_ppd1xwve3tr7",
            "fls_title": "Raw Pointer Types",
            "category": 0,
            "score": 0.64,
            "reason": "Per FLS: References can be cast to raw pointers, then to integers in safe Rust."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 1,
        "notes": "In safe Rust, you CAN cast references to raw pointers and then to integers using 'as'. This is why MISRA ADD-6 marks it as Yes/Yes. The guideline remains applicable because such conversions may indicate design issues. Safe Rust allows these casts but loses provenance tracking."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 11.5",
      "guideline_title": "A conversion should not be performed from pointer to void into pointer to object C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "category": 0,
          "score": 0.64,
          "reason": "FLS defines pointer-to-pointer casts including from *const c_void/*mut c_void to typed pointers. Section states casts between raw pointers are allowed, directly addressing MISRA concern about void* to object* conversions."
        },
        {
          "fls_id": "fls_ppd1xwve3tr7",
          "fls_title": "Raw Pointer Types",
          "category": 0,
          "score": 0.62,
          "reason": "FLS defines raw pointer semantics. Rust has no void* but uses *const c_void/*mut c_void for FFI interop, which maps to this MISRA concern."
        },
        {
          "fls_id": "fls_9wgldua1u8yt",
          "fls_title": "Dereference Expression",
          "category": -4,
          "score": 0.58,
          "reason": "FLS Undefined Behavior section addresses alignment requirements when dereferencing pointers, which relates to MISRA's concern about alignment when converting void* to typed pointers."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "fls_title": "Unsafety",
          "category": 0,
          "score": 0.55,
          "reason": "Raw pointer casts and dereferences require unsafe blocks in Rust, providing compile-time enforcement that C lacks."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Rust has no void* equivalent but uses *const c_void/*mut c_void for FFI. All raw pointer operations require unsafe, providing stronger safety than C. Current applicability (all_rust: direct, safe_rust: not_applicable) is correct.",
      "rejected_matches": []
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 11.6",
      "guideline_title": "A cast shall not be performed between pointer to void and an arithmetic type C90",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "yes",
        "adjusted_category": "advisory",
        "rationale_type": "partial_mapping",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_1qhsun1vyarz",
            "fls_title": "Type Cast Expressions",
            "category": 0,
            "score": 0.76,
            "reason": "Per FLS: Defines pointer-to-address and address-to-pointer casts. Rust uses *const () or c_void instead of void*."
          },
          {
            "fls_id": "fls_ppd1xwve3tr7",
            "fls_title": "Raw Pointer Types",
            "category": 0,
            "score": 0.54,
            "reason": "Per FLS: 'A raw pointer type is an indirection type without validity guarantees.' Raw pointers are Rust's equivalent to C pointers."
          },
          {
            "fls_id": "fls_jep7p27kaqlp",
            "fls_title": "Unsafety",
            "category": 0,
            "score": 0.53,
            "reason": "Per FLS: Dereferencing raw pointers requires unsafe context. Working with void-like pointers involves unsafe operations."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 1,
        "notes": "MISRA Rule 11.6 (void* to integer) partially maps to Rust. Rust doesn't have void*, but uses *const () or core::ffi::c_void for FFI. Casting these to usize requires 'as' casts. The pattern of using opaque pointers and integers is similar to C."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_142vncdktbin",
            "fls_title": "Reference Types",
            "category": 0,
            "score": 0.5,
            "reason": "Per FLS: Safe Rust uses references (&T, &mut T) instead of raw pointers. There is no void* equivalent in safe Rust."
          },
          {
            "fls_id": "fls_a14slch83hzn",
            "fls_title": "Borrowing",
            "category": 0,
            "score": 0.63,
            "reason": "Per FLS: The borrow system replaces raw pointer manipulation. References have lifetime tracking that void* lacks."
          },
          {
            "fls_id": "fls_y2k5paj8m8ug",
            "fls_title": "Generics",
            "category": 0,
            "score": 0.73,
            "reason": "Per FLS: Generics provide type-safe abstraction over types, eliminating the need for void* patterns."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 1,
        "notes": "Safe Rust has no void* equivalent. The C pattern of 'void* for generic data' is replaced by generics and trait objects. References cannot be cast to integers. Raw pointers exist but require unsafe to dereference. Per MISRA ADD-6: safe_rust=No."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 11.8",
      "guideline_title": "A conversion shall not remove any const, volatile or _Atomic qualification from the type pointed to by a pointer C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "accepted_matches": [
        {
          "fls_id": "fls_ppd1xwve3tr7",
          "fls_title": "Raw Pointer Types",
          "category": 0,
          "score": 0.59,
          "reason": "FLS defines *const T (immutable raw pointer) and *mut T (mutable raw pointer) types. The distinction between const and mut in raw pointers directly maps to C's const qualification concept."
        },
        {
          "fls_id": "fls_8uWfFAsZeRCs",
          "fls_title": "Raw Pointer Types",
          "category": -2,
          "score": 0.66,
          "reason": "FLS Legality Rule states 'An immutable raw pointer type is a raw pointer type subject to keyword const'. This defines const semantics for raw pointers."
        },
        {
          "fls_id": "fls_1qhsun1vyarz",
          "fls_title": "Type Cast Expressions",
          "category": 0,
          "score": 0.62,
          "reason": "FLS covers pointer-to-pointer casts. While *const T to *mut T casts are syntactically allowed in unsafe Rust, this requires explicit unsafe block."
        },
        {
          "fls_id": "fls_t16yzaxro5ew",
          "fls_title": "Type Cast Expressions",
          "category": -2,
          "score": 0.67,
          "reason": "FLS Legality Rule for casts between raw pointer types. Covers *const T to *mut T cast legality."
        }
      ],
      "fls_rationale_type": "partial_mapping",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Rust tracks const/mut distinction in raw pointer types (*const T vs *mut T). Safe Rust prevents removing const. Unsafe Rust allows *const to *mut casts but requires explicit unsafe block. Rust has no volatile or _Atomic equivalents - volatile operations use read_volatile/write_volatile intrinsics, atomics use std::sync::atomic types. Current applicability (all_rust: direct, safe_rust: partial) is correct.",
      "rejected_matches": []
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 11.9",
      "guideline_title": "The macro NULL shall be the only permitted form of integer null pointer constant",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_59mpteeczzo",
            "fls_title": "Type Cast Expressions",
            "category": -2,
            "score": 0.51,
            "reason": "Address-to-pointer cast requires explicit integer-to-pointer cast - no NULL macro or implicit 0"
          },
          {
            "fls_id": "fls_ppd1xwve3tr7",
            "fls_title": "Raw Pointer Types",
            "category": 0,
            "score": 0.59,
            "reason": "Raw pointers created via ptr::null()/null_mut() functions, not integer constants"
          },
          {
            "fls_id": "fls_dzq9cdz4ibsz",
            "fls_title": "Exceptions and Errors",
            "category": -2,
            "score": 0.52,
            "reason": "Option::None represents absence - idiomatic replacement for null pointers"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no NULL macro or integer null pointer constant. Use ptr::null(), ptr::null_mut(), or Option::None. No implicit 0-to-pointer."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_ezh8aq6fmdvz",
            "fls_title": "Reference Types",
            "category": -4,
            "score": 0.7,
            "reason": "References cannot be null - validity invariant"
          },
          {
            "fls_id": "fls_ko1x0gp9e7y3",
            "fls_title": "Exceptions and Errors",
            "category": -2,
            "score": 0.45,
            "reason": "Option::Some/None represents presence/absence - no null references"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust: No raw pointers, no null. References guaranteed non-null. Option<&T> replaces nullable pointers."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 11.10",
      "guideline_title": "The _Atomic qualifier shall not be applied to the incomplete type void",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_vyc9vcuamlph",
            "fls_title": "Atomics",
            "category": 0,
            "score": 0.71,
            "reason": "Atomic types are concrete types in core::sync::atomic - not type qualifiers applied to other types"
          },
          {
            "fls_id": "fls_3pjla9s93mhd",
            "fls_title": "Atomics",
            "category": -2,
            "score": 0.8,
            "reason": "AtomicBool, AtomicI32, AtomicPtr<T> etc - all sized types, no incomplete types"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no _Atomic qualifier. Atomic types are distinct types in core::sync::atomic. AtomicPtr<T> requires sized T. No void type exists."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_hidfwkwr2r73",
            "fls_title": "Generic Parameters",
            "category": -2,
            "score": 0.54,
            "reason": "Type parameters have implicit Sized bound - no unsized/incomplete types in atomics"
          },
          {
            "fls_id": "fls_vyc9vcuamlph",
            "fls_title": "Atomics",
            "category": 0,
            "score": 0.63,
            "reason": "Atomic types are complete, sized types - AtomicPtr<T> requires sized T"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust: Same as all_rust. Unit type () is complete (zero-sized). No incomplete types. Atomics are concrete types."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 11.11",
      "guideline_title": "Pointers shall not be implicitly compared to NULL",
      "guideline_type": "rule",
      "applicability_all_rust": "rust_prevents",
      "applicability_safe_rust": "rust_prevents",
      "accepted_matches": [
        {
          "fls_id": "fls_r7gzxo16esri",
          "fls_title": "If expression subject bool",
          "category": -2,
          "score": 0.46,
          "reason": "FLS requires if expression subject to be type bool - no implicit pointer-to-bool conversion"
        },
        {
          "fls_id": "fls_142vncdktbin",
          "fls_title": "Reference Types",
          "category": 0,
          "score": 0.6,
          "reason": "FLS references have validity invariant of being non-null, eliminating most null-pointer concerns"
        },
        {
          "fls_id": "fls_ppd1xwve3tr7",
          "fls_title": "Raw Pointer Types",
          "category": 0,
          "score": 0.6,
          "reason": "FLS raw pointer comparisons compare addresses explicitly, not implicit boolean conversion"
        },
        {
          "fls_id": "fls_52thmi9hnoks",
          "fls_title": "Function pointer null invariant",
          "category": -4,
          "score": 0.69,
          "reason": "FLS function pointers have validity invariant of being non-null"
        }
      ],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "implicit",
      "misra_rust_comment": "enforced by rustc",
      "confidence": "medium",
      "notes": "MISRA concern is implicit pointer-to-boolean conversion in C (if(ptr)). Rust PREVENTS this: (1) if expression subject must be bool type - no implicit conversions, (2) References have non-null validity invariant, (3) Raw pointers require explicit .is_null() check or comparison. The type system enforces explicit boolean expressions in control flow.",
      "rejected_matches": []
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 12.1",
      "guideline_title": "The precedence of operators within expressions should be made explicit",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "yes",
        "adjusted_category": "recommended",
        "rationale_type": "direct_mapping",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_kw25194gpael",
            "fls_title": "Expression Precedence",
            "category": 0,
            "score": 0.752,
            "reason": "FLS defines complete precedence and associativity table for all Rust operators. Per fls_bezkcuwp5qol 'Associativity is the order by which operands are evaluated within a single expression.' This directly maps to MISRA's concern about making precedence explicit."
          },
          {
            "fls_id": "fls_abp6tjbz8tpn",
            "fls_title": "Bit Expressions",
            "category": 0,
            "score": 0.737,
            "reason": "FLS specifies evaluation order for bit expressions (AND, OR, XOR) with defined semantics. The evaluation rules in dynamic_semantics paragraphs ensure deterministic behavior."
          },
          {
            "fls_id": "fls_290jmzfh7x4e",
            "fls_title": "Compound Assignment Expressions",
            "category": 0,
            "score": 0.676,
            "reason": "FLS defines compound assignment evaluation order - assigned operand evaluated first, then modifying operand. Clear semantics address MISRA's operator clarity concern."
          },
          {
            "fls_id": "fls_nsvzzbldhq53",
            "fls_title": "Comparison Expressions",
            "category": 0,
            "score": 0.689,
            "reason": "FLS comparison expressions have defined precedence requiring parentheses for chaining. This aligns with MISRA's recommendation for explicit grouping."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 1,
        "notes": "Rule 12.1 recommends explicit parentheses for precedence clarity. Rust's FLS defines a complete precedence table (fls_kw25194gpael) and requires parentheses for certain expressions. The guideline applies equally to Rust - using parentheses improves readability regardless of language."
      },
      "safe_rust": {
        "applicability": "yes",
        "adjusted_category": "recommended",
        "rationale_type": "direct_mapping",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_kw25194gpael",
            "fls_title": "Expression Precedence",
            "category": 0,
            "score": 0.752,
            "reason": "FLS precedence table applies equally in safe Rust. Clear operator precedence documentation enables the recommended use of parentheses for clarity."
          },
          {
            "fls_id": "fls_lstusiu2c8lu",
            "fls_title": "Lazy Boolean Expressions",
            "category": 0,
            "score": 0.701,
            "reason": "FLS defines short-circuit evaluation for && and ||. Understanding this precedence behavior is essential for writing clear boolean expressions in safe Rust."
          },
          {
            "fls_id": "fls_dw33yt5g6m0k",
            "fls_title": "Type Coercion",
            "category": 0,
            "score": 0.821,
            "reason": "FLS type coercion rules interact with expression precedence. Per fls_w5pjcj9qmgbv 'Type coercion is an implicit operation' - understanding when coercion occurs requires awareness of expression structure."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 1,
        "notes": "Safe Rust has identical operator precedence rules. The MISRA recommendation for explicit parentheses to clarify precedence applies equally - this is a code readability guideline that transcends memory safety concerns."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 12.2",
      "guideline_title": "The right hand operand of a shift operator shall lie in the range zero to one less than the width in bits of the essential type of the left hand operand C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "accepted_matches": [
        {
          "fls_id": "fls_abp6tjbz8tpn",
          "fls_title": "Bit Expressions",
          "category": 0,
          "score": 0.77,
          "reason": "FLS defines shift left and shift right expressions and their semantics. Shift operations in Rust have defined behavior based on the implementation."
        },
        {
          "fls_id": "fls_fbazfgd5m1ot",
          "fls_title": "Bit Expressions",
          "category": -2,
          "score": 0.78,
          "reason": "FLS Legality Rule defines shift right as core::ops::Shr::shr(). The standard library implementation panics on overflow in debug mode."
        },
        {
          "fls_id": "fls_kqntxbwnc58v",
          "fls_title": "Bit Expressions",
          "category": -2,
          "score": 0.77,
          "reason": "FLS Legality Rule defines shift left as core::ops::Shl::shl(). Standard library panics on shifts >= bit width in debug mode."
        },
        {
          "fls_id": "fls_f0p70y92k14f",
          "fls_title": "Bit Expressions",
          "category": -3,
          "score": 0.74,
          "reason": "FLS Dynamic Semantics for shift left - defines the runtime evaluation behavior."
        },
        {
          "fls_id": "fls_ZfIBiJMf8qE1",
          "fls_title": "Arithmetic Overflow",
          "category": 0,
          "score": 0.52,
          "reason": "FLS Arithmetic Overflow section covers overflow behavior including shifts. Debug builds panic, release builds wrap or use wrapping_shl/checked_shl."
        }
      ],
      "fls_rationale_type": "partial_mapping",
      "misra_rust_category": "advisory",
      "confidence": "medium",
      "notes": "Rust handles shift overflow differently than C: debug builds panic on over-shift, release builds wrap. Safe APIs (checked_shl, overflowing_shl) allow explicit handling. Current applicability (all_rust: direct, safe_rust: partial) is appropriate - the concern exists but Rust provides runtime checks in debug mode.",
      "rejected_matches": []
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 12.3",
      "guideline_title": "The comma operator should not be used",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_hndm19t57wby",
            "fls_title": "Block Expressions",
            "category": 0,
            "score": 0.79,
            "reason": "Block expressions sequence statements with semicolons - no comma operator"
          },
          {
            "fls_id": "fls_k64tfywtn0g8",
            "fls_title": "Tuple Expressions",
            "category": 0,
            "score": 0.62,
            "reason": "Commas separate tuple elements - not a sequencing operator"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no comma operator. Commas are list separators. Use block expressions { stmt1; stmt2; expr } for sequencing."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_nf65p0l0v0gr",
            "fls_title": "Block Expressions",
            "category": -2,
            "score": 0.73,
            "reason": "Block expression sequences expressions and statements - semicolon separates"
          },
          {
            "fls_id": "fls_jvz5z3eqxb39",
            "fls_title": "Call Expressions",
            "category": -2,
            "score": 0.58,
            "reason": "Argument operands separated by commas - not sequenced, all evaluated"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust: Same as all_rust. No comma operator exists. Blocks for sequencing, commas for list separation."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 12.4",
      "guideline_title": "Evaluation of constant expressions should not lead to unsigned integer wrap-around",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_66m4rnbssgig",
          "fls_title": "Constant Expressions",
          "category": 0,
          "score": 0.71,
          "reason": "FLS section on constant expressions defines compile-time evaluation rules including overflow handling."
        },
        {
          "fls_id": "fls_b46nyamfqxdu",
          "fls_title": "Constant Expressions",
          "category": -2,
          "score": 0.69,
          "reason": "FLS: 'The evaluation of a constant expression that results in arithmetic overflow panics.' For const contexts, overflow is a compile-time error - exactly what MISRA requires."
        },
        {
          "fls_id": "fls_ZfIBiJMf8qE1",
          "fls_title": "Arithmetic Overflow",
          "category": 0,
          "score": 0.63,
          "reason": "FLS: 'There are two allowed behaviors for arithmetic overflow: 1) panic 2) truncation.' But for const expressions, only panic (error) is allowed."
        },
        {
          "fls_id": "fls_oFIRXBPXu6Zv",
          "fls_title": "Arithmetic Overflow",
          "category": -1,
          "score": 0.66,
          "reason": "FLS: 'An arithmetic overflow occurs when an operator expression computes a value...that lies outside of the range of valid values.' Defines the overflow condition."
        }
      ],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "advisory",
      "misra_rust_comment": "this is either well-defined or will not occur",
      "confidence": "medium",
      "notes": "Rust directly enforces this. Constant expression evaluation with arithmetic overflow is a compile-time error (panics during const eval). This is stricter than MISRA's 'should' - Rust makes it mandatory.",
      "rejected_matches": [
        {
          "fls_id": "fls_Et5gp1I7VqBX",
          "fls_title": "Arithmetic Expressions",
          "category": -3,
          "score": 0.7,
          "reason": "While related, this discusses runtime semantics not constant expression rules."
        }
      ]
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 12.5",
      "guideline_title": "The sizeof operator shall not have an operand which is a function parameter declared as \"array of type\"",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_uj0kpjwyld60",
            "fls_title": "Array Types",
            "category": 0,
            "score": 0.6,
            "reason": "Array types [T; N] have explicit size N - no decay to pointer"
          },
          {
            "fls_id": "fls_7cjbxleo998q",
            "fls_title": "Type Layout",
            "category": -2,
            "score": 0.56,
            "reason": "Array size calculated as size_of::<T>() * N - size is compile-time known"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no array-to-pointer decay. [T; N] remains an array. Slices &[T] carry length. size_of operates on types, not values."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_AAYJDCNMJgTq",
            "fls_title": "Functions",
            "category": -2,
            "score": 0.61,
            "reason": "Function parameter type explicitly determined - no implicit decay"
          },
          {
            "fls_id": "fls_vpbikb73dw4k",
            "fls_title": "Slice Types",
            "category": 0,
            "score": 0.51,
            "reason": "Slices provide view with length info - no size confusion"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust: Same as all_rust. No array decay. Function parameters have explicit types. Slices carry length."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 12.6",
      "guideline_title": "Structure and union members of atomic objects shall not be directly accessed C11",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_3pjla9s93mhd",
            "fls_title": "Atomics",
            "category": -2,
            "score": 0.74,
            "reason": "Atomic types are defined in core::sync::atomic - opaque types with method access only"
          },
          {
            "fls_id": "fls_isypweqewe78",
            "fls_title": "Concurrency",
            "category": -4,
            "score": 0.76,
            "reason": "Data races are UB - atomics prevent this via method interface"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust atomics are opaque types, not qualified structs. No field access possible. Must use load/store/fetch methods."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_vyc9vcuamlph",
            "fls_title": "Atomics",
            "category": 0,
            "score": 0.64,
            "reason": "Atomic types for primitives (bool, i32, usize, etc.) - no struct atomics with field access"
          },
          {
            "fls_id": "fls_tx4b8r6i93n4",
            "fls_title": "Concurrency",
            "category": -2,
            "score": 0.7,
            "reason": "Data race definition - atomics provide synchronization to prevent"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust: Same as all_rust. Atomic types are opaque. No way to access internal state directly."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 13.1",
      "guideline_title": "Initializer lists shall not contain persistent side effects C99",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "yes",
        "adjusted_category": "recommended",
        "rationale_type": "rust_alternative",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_8tsynkj2cufj",
            "fls_title": "Struct Expressions",
            "category": 0,
            "score": 0.684,
            "reason": "Per fls_vsxsbqps64o 'The evaluation of a struct expression evaluates its operands in a left-to-right order.' Unlike C, Rust defines evaluation order, addressing the root cause of MISRA's concern."
          },
          {
            "fls_id": "fls_xinykul167l",
            "fls_title": "Array Expressions",
            "category": 0,
            "score": 0.706,
            "reason": "Per fls_t52in1kkyli3 'The evaluation of an array expression with an array element constructor evaluates its operands in left-to-right order.' Deterministic order eliminates unspecified behavior."
          },
          {
            "fls_id": "fls_3xvm61x0t251",
            "fls_title": "Initialization",
            "category": 0,
            "score": 0.77,
            "reason": "FLS initialization rules ensure values are properly initialized before use. Combined with defined evaluation order, side effects in initializers have predictable behavior."
          },
          {
            "fls_id": "fls_xa4nbfas01cj",
            "fls_title": "Call Expressions",
            "category": 0,
            "score": 0.61,
            "reason": "Per fls_p52mfvpadu7w 'Argument operands are evaluated in left-to-right order.' All expression contexts have defined evaluation order in Rust."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 1,
        "notes": "Rust addresses MISRA's concern differently: instead of prohibiting side effects in initializers due to unspecified order, Rust defines evaluation order as left-to-right. The guideline is still valuable as a readability recommendation - side effects in initializers can be confusing even when order is defined."
      },
      "safe_rust": {
        "applicability": "yes",
        "adjusted_category": "recommended",
        "rationale_type": "rust_alternative",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_k64tfywtn0g8",
            "fls_title": "Tuple Expressions",
            "category": 0,
            "score": 0.728,
            "reason": "Per fls_waf55yd3mpsq 'The evaluation of a tuple expression evaluates its tuple initializers in left-to-right order.' Defined evaluation order in safe Rust."
          },
          {
            "fls_id": "fls_xdvdl2ssnhlo",
            "fls_title": "Statics",
            "category": 0,
            "score": 0.628,
            "reason": "Per fls_vgidvfwzm4ks 'The expression of a static initializer shall be a constant expression.' Const expressions have no runtime side effects."
          },
          {
            "fls_id": "fls_ixjc5jaamx84",
            "fls_title": "Constants",
            "category": 0,
            "score": 0.675,
            "reason": "Per fls_vnc3ttnid1qr 'The expression of a constant initializer shall be a constant expression.' Constants are evaluated at compile time, eliminating runtime side effect concerns."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 1,
        "notes": "Safe Rust has even stronger guarantees: const/static initializers must be constant expressions (no side effects), and all other initializers have defined left-to-right evaluation order. The MISRA concern about unspecified order is fully addressed by Rust's semantics."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 13.2",
      "guideline_title": "The value of an expression and its persistent side effects shall be the same under all permitted evaluation orders and shall be independent from thread interleaving C90",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "rust_prevents",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_izmfimd4yg27",
            "fls_title": "Arithmetic Expressions",
            "category": -3,
            "score": 0.7,
            "reason": "Left operand evaluated first, then right - deterministic left-to-right order"
          },
          {
            "fls_id": "fls_p52mfvpadu7w",
            "fls_title": "Call Expressions",
            "category": -3,
            "score": 0.71,
            "reason": "Argument operands evaluated in left-to-right order"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has defined evaluation order (left-to-right). Borrow checker prevents aliasing mutations. No sequence point issues like C."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "rust_prevents",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_vsxsbqps64o",
            "fls_title": "Struct Expressions",
            "category": -3,
            "score": 0.55,
            "reason": "Struct expression evaluates operands in left-to-right order"
          },
          {
            "fls_id": "fls_n5l17mlglq11",
            "fls_title": "Send and Sync",
            "category": -2,
            "score": 0.45,
            "reason": "Send/Sync traits prevent data races at type level"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust: Deterministic evaluation order + borrow checker prevents aliasing. Cannot create C-style order-dependent UB."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 13.3",
      "guideline_title": "A full expression containing an increment (++) or decrement (--) operator should have no other potential side effects other than that caused by the increment or decrement operator C90",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_290jmzfh7x4e",
            "fls_title": "Compound Assignment Expressions",
            "category": 0,
            "score": 0.7,
            "reason": "Rust uses += and -= which return unit - cannot embed in expressions"
          },
          {
            "fls_id": "fls_yeh6mvyvb4dp",
            "fls_title": "Compound Assignment Expressions",
            "category": -2,
            "score": 0.66,
            "reason": "Value of compound assignment is unit value - forces statement usage"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no ++ or --. Uses x += 1 which returns () and cannot be used as expression value. Forces separate statements."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_bwwtgqprbxrm",
            "fls_title": "Assignment Expressions",
            "category": -2,
            "score": 0.74,
            "reason": "Assignment expression value is unit value"
          },
          {
            "fls_id": "fls_xmgcdw9yhb55",
            "fls_title": "Compound Assignment Expressions",
            "category": -2,
            "score": 0.56,
            "reason": "Type of compound assignment is unit type - cannot use as value"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust: Same as all_rust. No ++/--. Compound assignment returns unit. Cannot mix increment with other expressions."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 13.4",
      "guideline_title": "The result of an assignment operator should not be used C90",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "rust_prevents",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_qengy157fa4a",
            "fls_title": "Assignment Expressions",
            "category": -2,
            "score": 0.748,
            "reason": "FLS states 'The type of an assignment expression is the unit type' - prevents using assignment result as value"
          },
          {
            "fls_id": "fls_bwwtgqprbxrm",
            "fls_title": "Assignment Expressions",
            "category": -2,
            "score": 0.745,
            "reason": "FLS states 'The value of an assignment expression is the unit value' - chained assignment impossible"
          },
          {
            "fls_id": "fls_yeh6mvyvb4dp",
            "fls_title": "Compound Assignment Expressions",
            "category": -2,
            "score": 0.661,
            "reason": "FLS states 'The value of a compound assignment is the unit value' - compound assignments also return unit"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust prevents this issue by design: assignment returns unit type () not the assigned value. Patterns like if (a = b) or a = b = c are compile errors."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "rust_prevents",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_qengy157fa4a",
            "fls_title": "Assignment Expressions",
            "category": -2,
            "score": 0.748,
            "reason": "FLS states 'The type of an assignment expression is the unit type' - prevents using result"
          },
          {
            "fls_id": "fls_r7gzxo16esri",
            "fls_title": "If Expressions",
            "category": -2,
            "score": 0.696,
            "reason": "FLS states 'The type of the subject expression of an if expression shall be type bool' - if(a=b) is type error since assignment returns unit not bool"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust fully prevents this issue: assignment returns unit, and if conditions require bool type. The pattern if(a=b) cannot compile."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 13.5",
      "guideline_title": "The right hand operand of a logical && or || operator shall not contain persistent side effects",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_lstusiu2c8lu",
          "fls_title": "Lazy Boolean Expressions",
          "category": 0,
          "score": 0.63,
          "reason": "FLS section documenting short-circuit (lazy) boolean evaluation semantics. Directly addresses MISRA's concern by clearly specifying when right operand is/isn't evaluated."
        },
        {
          "fls_id": "fls_gpbvus89iy4c",
          "fls_title": "Lazy Boolean Expressions",
          "category": -2,
          "score": 0.75,
          "reason": "FLS: 'A lazy boolean expression is an expression that performs short circuit Boolean arithmetic.' Explicitly names the behavior."
        },
        {
          "fls_id": "fls_tmfmu3syxp2q",
          "fls_title": "Lazy Boolean Expressions",
          "category": -3,
          "score": 0.7,
          "reason": "FLS: 'If the left operand evaluated to true, then the right operand is evaluated...' (for && - documents conditional evaluation)."
        },
        {
          "fls_id": "fls_yg1348rlziw3",
          "fls_title": "Lazy Boolean Expressions",
          "category": -3,
          "score": 0.7,
          "reason": "FLS: 'If the left operand evaluated to false, then the right operand is evaluated...' (for || - documents conditional evaluation)."
        },
        {
          "fls_id": "fls_dltmd8e8c5ia",
          "fls_title": "Drop Scopes",
          "category": -2,
          "score": 0.61,
          "reason": "FLS: 'The drop scope of the right operand of a lazy boolean expression.' Side effects (drops) of right operand are scoped to conditional execution."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "recommended",
      "confidence": "medium",
      "notes": "FLS explicitly documents short-circuit evaluation semantics. While Rust has the same behavior as C, the FLS makes it clear when right operands are evaluated. MISRA's concern about hidden side effects applies - this is a coding style guideline for Rust as well.",
      "rejected_matches": []
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 13.6",
      "guideline_title": "The operand of the sizeof operator shall not contain any expression which has potential side effects C99",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_g1z6bpyjqxkz",
            "fls_title": "Type Layout",
            "category": 0,
            "score": 0.693,
            "reason": "Size in Rust is a compile-time property of types obtained via size_of::<T>(), not an operator on expressions"
          },
          {
            "fls_id": "fls_1pbwigq6f3ha",
            "fls_title": "Type Layout",
            "category": -2,
            "score": 0.693,
            "reason": "FLS states 'The size of a type is the offset in bytes between successive elements' - purely type-based, no expression evaluation"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no sizeof operator. Size is obtained via std::mem::size_of::<T>() which takes a type, not an expression. No expression evaluation occurs, so side effects cannot happen."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_66m4rnbssgig",
            "fls_title": "Constant Expressions",
            "category": 0,
            "score": 0.771,
            "reason": "Size computations use constant expressions evaluated at compile time"
          },
          {
            "fls_id": "fls_g1z6bpyjqxkz",
            "fls_title": "Type Layout",
            "category": 0,
            "score": 0.693,
            "reason": "Type sizes are determined by type layout, a compile-time property"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust has no sizeof operator. std::mem::size_of::<T>() operates on types, not expressions, and is evaluated at compile time. No side effects possible."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 14.1",
      "guideline_title": "A loop counter shall not have essentially floating type",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "accepted_matches": [
        {
          "fls_id": "fls_onfyolkcbeh3",
          "fls_title": "For Loops",
          "category": 0,
          "score": 0.57,
          "reason": "FLS: For loops use iterators (IntoIterator trait). Standard range iterators (0..n) produce integers, not floats. No floating-point counter by design."
        },
        {
          "fls_id": "fls_fkgbin6ydkm4",
          "fls_title": "For Loops",
          "category": -2,
          "score": 0.48,
          "reason": "FLS: 'The type of a subject expression shall implement the core::iter::IntoIterator trait.' Range<f32/f64> does not implement Iterator in std."
        },
        {
          "fls_id": "fls_5jjm1kt43axd",
          "fls_title": "While Loops",
          "category": 0,
          "score": 0.45,
          "reason": "FLS: While loops have iteration expressions of type bool. No inherent counter - any counter must be manually managed."
        },
        {
          "fls_id": "fls_d7ofrq3777kq",
          "fls_title": "While Loops",
          "category": -2,
          "score": 0.61,
          "reason": "FLS: 'The type of an iteration expression shall be type bool.' While loop condition is boolean, not a counter comparison."
        },
        {
          "fls_id": "fls_b4xporvr64s",
          "fls_title": "Floating Point Types",
          "category": 0,
          "score": 0.64,
          "reason": "FLS documents floating-point types and their properties. Understanding float behavior is relevant to why this guideline matters."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "applies to while loops only",
      "confidence": "medium",
      "notes": "Rust's loop design differs from C. For loops use iterators (std Range types are integer-only). While loops have bool conditions. Floating-point counters require explicit manual management, making the problematic pattern less common and more visible when used.",
      "rejected_matches": []
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 14.2",
      "guideline_title": "A for loop shall be well-formed",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_onfyolkcbeh3",
            "fls_title": "For Loops",
            "category": 0,
            "score": 0.823,
            "reason": "Rust for loops use 'for pattern in iterator' syntax - iterator controls progression, not mutable counters"
          },
          {
            "fls_id": "fls_1bh2alh37frz",
            "fls_title": "For Loops",
            "category": -2,
            "score": 0.776,
            "reason": "FLS states for loop 'continues to evaluate its loop body as long as its subject expression yields a value' - no C-style counter manipulation"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no C-style for(init;cond;update) loop. The for-in loop binds pattern fresh each iteration from iterator. MISRA's well-formed concerns (counter modification, condition usage) don't apply."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_onfyolkcbeh3",
            "fls_title": "For Loops",
            "category": 0,
            "score": 0.823,
            "reason": "Rust for loops are iterator-based with fresh binding per iteration"
          },
          {
            "fls_id": "fls_fkgbin6ydkm4",
            "fls_title": "For Loops",
            "category": -2,
            "score": 0.66,
            "reason": "FLS states subject expression must implement IntoIterator - iterator controls flow, not counter"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust for loops bind pattern fresh each iteration from IntoIterator. No C-style counter that could be improperly modified."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 14.3",
      "guideline_title": "Controlling expressions shall not be invariant",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_zJOAmSr3Dbqk",
          "fls_title": "Diverging Expressions",
          "category": 0,
          "score": 0.61,
          "reason": "FLS documents diverging expressions and the never type. Invariant controlling expressions that diverge are explicitly modeled."
        },
        {
          "fls_id": "fls_4u0v5uy95pyf",
          "fls_title": "Never Type",
          "category": -2,
          "score": 0.63,
          "reason": "FLS: 'The never type is a type that represents the result of a computation that never completes.' Used to model unreachable code paths."
        },
        {
          "fls_id": "fls_mkut7gut49gi",
          "fls_title": "If Expressions",
          "category": 0,
          "score": 0.62,
          "reason": "FLS documents if expression evaluation. While it doesn't forbid invariant conditions, the evaluation semantics are clear."
        },
        {
          "fls_id": "fls_5jjm1kt43axd",
          "fls_title": "While Loops",
          "category": 0,
          "score": 0.69,
          "reason": "FLS documents while loop semantics. While invariant conditions are allowed, they result in infinite loops (loop {}) or no iterations."
        },
        {
          "fls_id": "fls_66m4rnbssgig",
          "fls_title": "Constant Expressions",
          "category": 0,
          "score": 0.62,
          "reason": "FLS: Constant expressions are evaluated at compile time. If a controlling expression is a constant, the compiler knows its value."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Rust does not prohibit invariant controlling expressions at the language level, but rustc provides warnings via lints (unreachable_code, clippy). The FLS documents how such expressions are evaluated. This MISRA rule remains relevant as a coding guideline for Rust.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 14.4",
      "guideline_title": "The controlling expression of an if statement and the controlling expression of an iteration-statement shall have essentially Boolean type",
      "guideline_type": "rule",
      "applicability_all_rust": "rust_prevents",
      "applicability_safe_rust": "rust_prevents",
      "accepted_matches": [
        {
          "fls_id": "fls_r7gzxo16esri",
          "fls_title": "If expression requires bool",
          "category": -2,
          "score": 0.59,
          "reason": "FLS: The type of the subject expression of an if expression shall be type bool"
        },
        {
          "fls_id": "fls_d7ofrq3777kq",
          "fls_title": "While loop requires bool",
          "category": -2,
          "score": 0.66,
          "reason": "FLS: The type of an iteration expression shall be type bool"
        },
        {
          "fls_id": "fls_tiqp1gxf116z",
          "fls_title": "Bool Type",
          "category": 0,
          "score": 0.61,
          "reason": "FLS Bool Type defines the boolean type with only true/false values"
        },
        {
          "fls_id": "fls_mkut7gut49gi",
          "fls_title": "If Expressions",
          "category": 0,
          "score": 0.56,
          "reason": "FLS If Expressions section defines control flow with boolean subject expression"
        }
      ],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "implicit",
      "misra_rust_comment": "enforced by rustc",
      "confidence": "medium",
      "notes": "MISRA concern is about non-boolean expressions in control flow (e.g., if(1), if(ptr)). Rust ENFORCES this at the language level: (1) FLS requires if expression subject to be type bool, (2) FLS requires while loop iteration expression to be type bool. There are NO implicit conversions to bool in Rust. This rule is fully addressed by Rust's type system.",
      "rejected_matches": []
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 15.1",
      "guideline_title": "The goto statement should not be used",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_jr4tpuyksr75",
            "fls_title": "Break Expressions",
            "category": 0,
            "score": 0.573,
            "reason": "Rust uses structured break/continue instead of goto - can only break to enclosing labeled constructs"
          },
          {
            "fls_id": "fls_sjwrlwvpulp",
            "fls_title": "Continue Expressions",
            "category": 0,
            "score": 0.559,
            "reason": "Continue restarts enclosing loop iteration - structured control flow"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no goto statement. Control flow uses structured constructs (if/match/loops) with break/continue for early exit. Labeled break can exit enclosing blocks but cannot jump arbitrarily."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_hndm19t57wby",
            "fls_title": "Block Expressions",
            "category": 0,
            "score": 0.638,
            "reason": "Rust uses block expressions for scoped structured control flow"
          },
          {
            "fls_id": "fls_0ybsR1hEo7wV",
            "fls_title": "Named Blocks",
            "category": 0,
            "score": 0.735,
            "reason": "Named blocks allow labeled break - structured alternative to some goto uses"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust has no goto. Control flow is entirely structured through blocks, if/match, and loops. Named blocks with labeled break cover use cases where goto might be used in C."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 15.2",
      "guideline_title": "The goto statement shall jump to a label declared later in the same function",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_uusi0zej55is",
            "fls_title": "Loop Labels",
            "category": 0,
            "score": 0.637,
            "reason": "Rust labels are for loops/blocks, not goto targets - no arbitrary jumps exist"
          },
          {
            "fls_id": "fls_769b4p8v3cwu",
            "fls_title": "Label Scope",
            "category": 0,
            "score": 0.732,
            "reason": "Labels have structured scope within loops/blocks, not arbitrary jump destinations"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no goto statement. The concept of forward-only goto jumps is moot. Rust's labels are purely for break/continue targeting of enclosing loops/blocks."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_sjwrlwvpulp",
            "fls_title": "Continue Expressions",
            "category": 0,
            "score": 0.655,
            "reason": "Continue restarts loop iteration - structured, not arbitrary jump"
          },
          {
            "fls_id": "fls_jr4tpuyksr75",
            "fls_title": "Break Expressions",
            "category": 0,
            "score": 0.562,
            "reason": "Break exits to enclosing loop/block - structured, not arbitrary jump"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust has no goto. Continue restarts iteration, break exits loops/blocks. These are structured and cannot jump arbitrarily forward or backward."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 15.3",
      "guideline_title": "Any label referenced by a goto statement shall be declared in the same block, or in any block enclosing the goto statement",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_769b4p8v3cwu",
            "fls_title": "Label Scope",
            "category": 0,
            "score": 0.641,
            "reason": "Labels must be in enclosing scope - compiler enforces this"
          },
          {
            "fls_id": "fls_7frvr2nm2mcj",
            "fls_title": "Break Expressions",
            "category": -2,
            "score": 0.533,
            "reason": "FLS states 'label indication of a break expression shall resolve to the label of an enclosing named block expression or named loop expression'"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no goto. Labels exist only for break/continue targeting enclosing loops/blocks. The compiler enforces that labels resolve to enclosing constructs - cannot jump into nested scopes."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_lnpyb285qdiy",
            "fls_title": "Scope Hierarchy",
            "category": 0,
            "score": 0.703,
            "reason": "Rust's scope hierarchy enforces structured scoping - no arbitrary jumps possible"
          },
          {
            "fls_id": "fls_6ozthochxz1i",
            "fls_title": "Binding Scopes",
            "category": 0,
            "score": 0.602,
            "reason": "Bindings have well-defined scope - cannot bypass initialization by jumping in"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust has no goto. The scope hierarchy and binding scopes ensure structured control flow. Variables cannot be accessed before initialization."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 15.4",
      "guideline_title": "There should be no more than one break or goto statement used to terminate any iteration statement",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "yes",
        "adjusted_category": "recommended",
        "rationale_type": "direct_mapping",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_jr4tpuyksr75",
            "fls_title": "Break Expressions",
            "category": 0,
            "score": 0.665,
            "reason": "FLS defines break expressions with optional labels. Per fls_ghxns2nggffj 'A break expression without a label indication is associated with the innermost enclosing loop expression.' Multiple breaks are syntactically valid but may reduce readability."
          },
          {
            "fls_id": "fls_sjwrlwvpulp",
            "fls_title": "Continue Expressions",
            "category": 0,
            "score": 0.713,
            "reason": "FLS continue expressions restart loop iteration. Per fls_wzs6kz9ffqzt 'A continue expression shall appear within a loop expression.' Continue provides an alternative exit mechanism."
          },
          {
            "fls_id": "fls_uusi0zej55is",
            "fls_title": "Loop Labels",
            "category": 0,
            "score": 0.597,
            "reason": "FLS loop labels enable breaking from nested loops. Per fls_7hc8yboeaho0 'A label indication shall indicate a label of an enclosing named block expression.' Labeled breaks are more explicit than C goto."
          },
          {
            "fls_id": "fls_sf4qnd43z2wc",
            "fls_title": "Infinite Loops",
            "category": 0,
            "score": 0.647,
            "reason": "Per fls_99imks9hj3kp 'If the infinite loop expression contains at least one break expression, then the value is the break value.' Rust loops can return values via break, adding clarity."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 1,
        "notes": "Rust has no goto, which eliminates the main MISRA concern. The guideline about limiting break statements still applies for code clarity. Rust's labeled breaks are more structured than C goto but multiple exit points can still reduce readability."
      },
      "safe_rust": {
        "applicability": "yes",
        "adjusted_category": "recommended",
        "rationale_type": "direct_mapping",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_onfyolkcbeh3",
            "fls_title": "For Loops",
            "category": 0,
            "score": 0.71,
            "reason": "FLS for loops iterate over IntoIterator implementations. Per fls_1bh2alh37frz 'A for loop expression continues to evaluate its loop body as long as its subject expression yields a value.' Structured iteration reduces need for break."
          },
          {
            "fls_id": "fls_m6kd5i9dy8dx",
            "fls_title": "While Let Loops",
            "category": 0,
            "score": 0.712,
            "reason": "Per fls_fmdlyp9r9zl7 'A while let loop expression continues to evaluate its loop body as long as its subject let expression yields a value that can be matched.' Pattern matching provides clean termination."
          },
          {
            "fls_id": "fls_0ybsR1hEo7wV",
            "fls_title": "Named Blocks",
            "category": 0,
            "score": 0.735,
            "reason": "FLS named blocks allow labeled breaks from non-loop blocks. This provides structured control flow without goto."
          },
          {
            "fls_id": "fls_769b4p8v3cwu",
            "fls_title": "Label Scope",
            "category": 0,
            "score": 0.757,
            "reason": "Per fls_8sevg1sa82h4 'A label is in scope within the block expression of the related loop expression.' Scoped labels prevent the cross-function jumps possible with C goto."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 1,
        "notes": "Safe Rust has identical loop control semantics. The MISRA guideline for single exit points remains valuable for code clarity. Rust's for/while-let patterns often eliminate the need for explicit break statements."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 15.5",
      "guideline_title": "A function should have a single point of exit at the end",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_8l74abhlxzdl",
          "fls_title": "Return Expressions",
          "category": 0,
          "score": 0.59,
          "reason": "FLS documents return expressions and how they transfer control flow. Multiple return points are allowed."
        },
        {
          "fls_id": "fls_u7jk4j8gkho",
          "fls_title": "Return Expressions",
          "category": -2,
          "score": 0.73,
          "reason": "FLS: 'A return expression is an expression that optionally yields a value and causes control flow to return to the end of the enclosing control flow boundary.'"
        },
        {
          "fls_id": "fls_7Ck4LMQMeQCv",
          "fls_title": "Return Expressions",
          "category": -2,
          "score": 0.65,
          "reason": "FLS: 'The type of a return expression is the never type.' Return expressions diverge from normal control flow."
        },
        {
          "fls_id": "fls_5v3j5ghhw8j8",
          "fls_title": "Return Expressions",
          "category": -2,
          "score": 0.59,
          "reason": "FLS: 'A return expression shall appear within a control flow boundary.' Defines where returns can appear."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "disapplied",
      "misra_rust_comment": "no longer endorsed by MISRA",
      "confidence": "medium",
      "notes": "Rust allows multiple return points via return expressions, early returns with ?, and implicit final expression returns. MISRA's single-exit guideline is a style recommendation that can be applied to Rust but is not enforced by the language. Many Rust idioms encourage early returns for error handling.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 15.6",
      "guideline_title": "The body of an iteration-statement or a selection-statement shall be a compound-statement",
      "guideline_type": "rule",
      "applicability_all_rust": "rust_prevents",
      "applicability_safe_rust": "rust_prevents",
      "accepted_matches": [],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust enforces this by design. All if/loop/while/for/match constructs require block expressions as their body - single statements are not allowed. The \"dangling else\" ambiguity is impossible.",
      "rejected_matches": []
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 15.7",
      "guideline_title": "All if \u2026 else if constructs shall be terminated with an else statement",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "yes",
        "adjusted_category": "advisory",
        "rationale_type": "direct_mapping",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_mkut7gut49gi",
            "fls_title": "If Expressions",
            "category": 0,
            "score": 0.654,
            "reason": "FLS if expressions allow optional else. Per fls_5azwlk7hav1k 'An else expression represents either a block expression, an if expression, or an if let expression.' The MISRA rule for explicit else in chains applies directly."
          },
          {
            "fls_id": "fls_e5td0fa92fay",
            "fls_title": "Match Expressions",
            "category": 0,
            "score": 0.717,
            "reason": "FLS match expressions require exhaustive patterns. Per fls_g6xyz0beps3o 'A match arm is selected when its pattern matches.' Match is often preferred over if-else chains in Rust."
          },
          {
            "fls_id": "fls_lv7w7aalpwm5",
            "fls_title": "Type Inference",
            "category": 0,
            "score": 0.663,
            "reason": "Per fls_0HHC1iOk5dwz 'An if expression is inferred by inferring its subject expression with an expected type of bool.' When if is used as expression, type inference encourages explicit else."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 1,
        "notes": "MISRA Rule 15.7 directly applies to Rust if-else-if chains. However, Rust's match expression with exhaustiveness checking is often a better alternative that inherently requires handling all cases."
      },
      "safe_rust": {
        "applicability": "yes",
        "adjusted_category": "advisory",
        "rationale_type": "direct_mapping",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_p0t1ch115tra",
            "fls_title": "If Let Expressions",
            "category": 0,
            "score": 0.667,
            "reason": "Per fls_dsrjup2umr9 'An if let expression evaluates either a block expression or an else expression depending on whether its pattern can be matched.' If let allows pattern-based branching with optional else."
          },
          {
            "fls_id": "fls_uh76pw6ykd57",
            "fls_title": "Refutability",
            "category": 0,
            "score": 0.717,
            "reason": "Per fls_9fjspnefoyvz 'An irrefutable pattern always matches any value of its type.' Understanding refutability helps determine when else is needed."
          },
          {
            "fls_id": "fls_yc4xm4hrfyw7",
            "fls_title": "Underscore Pattern Matching",
            "category": 0,
            "score": 0.578,
            "reason": "Underscore pattern matches any value. In match expressions, _ serves as the catch-all case, similar to MISRA's required else clause."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 1,
        "notes": "Safe Rust has identical if-else semantics. The MISRA guideline applies directly. Match expressions with exhaustiveness checking provide a Rust-idiomatic alternative that enforces handling all cases at compile time."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 16.1",
      "guideline_title": "All switch statements shall be well-formed",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_e5td0fa92fay",
            "fls_title": "Match Expressions",
            "category": 0,
            "score": 0.731,
            "reason": "Rust match expressions have independent arms - no fall-through possible"
          },
          {
            "fls_id": "fls_e02um1gb89d0",
            "fls_title": "Match Expressions",
            "category": -2,
            "score": 0.71,
            "reason": "FLS states patterns 'shall exhaustively match' - compiler enforces completeness"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no switch statement. Match expressions are structurally different: each arm is independent (no fall-through), patterns must be exhaustive. MISRA's well-formed concerns don't apply."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_e5td0fa92fay",
            "fls_title": "Match Expressions",
            "category": 0,
            "score": 0.731,
            "reason": "Match expressions are structurally well-formed by design"
          },
          {
            "fls_id": "fls_jm6l7b90h6wa",
            "fls_title": "Pattern Matching",
            "category": 0,
            "score": 0.685,
            "reason": "Pattern matching semantics ensure each arm is independent"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust match expressions are inherently well-formed: no fall-through, exhaustive patterns required, each arm is a single expression."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 16.2",
      "guideline_title": "A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_e5td0fa92fay",
            "fls_title": "Match Expressions",
            "category": 0,
            "score": 0.742,
            "reason": "Match arms are syntactically part of match expression - cannot appear elsewhere"
          },
          {
            "fls_id": "fls_hndm19t57wby",
            "fls_title": "Block Expressions",
            "category": 0,
            "score": 0.709,
            "reason": "Block expressions are separate from match - no Duff's Device possible"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no switch/case labels. Match arms are syntactically part of the match expression and cannot appear inside nested loops or other constructs."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_e5td0fa92fay",
            "fls_title": "Match Expressions",
            "category": 0,
            "score": 0.769,
            "reason": "Match arms are syntactically bound to match - cannot appear in nested constructs"
          },
          {
            "fls_id": "fls_wdicg3sqa98e",
            "fls_title": "Statements",
            "category": 0,
            "score": 0.614,
            "reason": "Statements and expressions have clear syntactic structure - no floating labels"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust match arms are syntactically part of match expressions. There are no case labels that could appear in wrong places."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 16.3",
      "guideline_title": "Every switch-clause shall be appropriately terminated",
      "guideline_type": "rule",
      "applicability_all_rust": "rust_prevents",
      "applicability_safe_rust": "rust_prevents",
      "accepted_matches": [],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust match arms have no fall-through semantics. Each arm is an expression that evaluates to a value - there is no need for break statements and no accidental fall-through.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 16.4",
      "guideline_title": "Every switch statement shall have a default label",
      "guideline_type": "rule",
      "applicability_all_rust": "rust_prevents",
      "applicability_safe_rust": "rust_prevents",
      "misra_rust_category": "n_a",
      "misra_rust_comment": "a corresponding match expression must be complete",
      "confidence": "medium",
      "notes": "Rust match expressions must be exhaustive - the compiler enforces that all possible values are covered. A wildcard pattern (_) serves as the equivalent of default when needed.",
      "accepted_matches": [],
      "rejected_matches": [],
      "fls_rationale_type": "rust_prevents"
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 16.5",
      "guideline_title": "A default label shall appear as either the first or the last switch label of a switch statement",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "rust_prevents",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_qfsfnql1t7m",
            "fls_title": "Underscore Patterns",
            "category": 0,
            "score": 0.709,
            "reason": "Underscore pattern matches any value - serves as catch-all"
          },
          {
            "fls_id": "fls_8dba4o5qg8js",
            "fls_title": "Match Expressions",
            "category": -2,
            "score": 0.611,
            "reason": "FLS states 'Match arm selection happens in declarative order' - catch-all must be last or unreachable code warning"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no default label. Underscore pattern _ serves as catch-all and must be LAST (compiler warns on unreachable patterns). Position is enforced by design."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "rust_prevents",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_oj8dg28xw5yp",
            "fls_title": "Match Expressions",
            "category": -2,
            "score": 0.638,
            "reason": "FLS defines 'final match arm is the last match arm' - catch-all naturally belongs here"
          },
          {
            "fls_id": "fls_9fjspnefoyvz",
            "fls_title": "Refutability",
            "category": -2,
            "score": 0.753,
            "reason": "FLS defines irrefutable patterns - underscore is irrefutable and must be last to avoid unreachable code"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust enforces catch-all position: irrefutable patterns (like _) must be last or subsequent arms are unreachable. Compiler enforces proper ordering."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 16.6",
      "guideline_title": "Every switch statement shall have at least two switch-clauses",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_e5td0fa92fay",
            "fls_title": "Match Expressions",
            "category": 0,
            "score": 0.528,
            "reason": "Match with single arm is valid in Rust for enum extraction"
          },
          {
            "fls_id": "fls_mkut7gut49gi",
            "fls_title": "If Expressions",
            "category": 0,
            "score": 0.602,
            "reason": "If/else is available for two-way branching when appropriate"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no switch. Match with single arm is idiomatic for extracting enum values. There's no minimum arm requirement."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_e5td0fa92fay",
            "fls_title": "Match Expressions",
            "category": 0,
            "score": 0.528,
            "reason": "Single-arm match is valid and idiomatic"
          },
          {
            "fls_id": "fls_mkut7gut49gi",
            "fls_title": "If Expressions",
            "category": 0,
            "score": 0.602,
            "reason": "If/else available when two-way branch needed"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust has no switch. Single-arm match is common for destructuring. No minimum arm count."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 16.7",
      "guideline_title": "A switch-expression shall not have essentially Boolean type",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_mkut7gut49gi",
            "fls_title": "If Expressions",
            "category": 0,
            "score": 0.635,
            "reason": "If expressions are preferred for boolean conditions in Rust idiom"
          },
          {
            "fls_id": "fls_tiqp1gxf116z",
            "fls_title": "Bool Type",
            "category": 0,
            "score": 0.668,
            "reason": "Bool type exists and can be matched but if/else is idiomatic"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no switch. Matching on bool is allowed but if/else is idiomatic. This is a style preference, not enforced by the language."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_mkut7gut49gi",
            "fls_title": "If Expressions",
            "category": 0,
            "score": 0.635,
            "reason": "If/else is idiomatic for boolean conditions"
          },
          {
            "fls_id": "fls_tiqp1gxf116z",
            "fls_title": "Bool Type",
            "category": 0,
            "score": 0.668,
            "reason": "Bool can be matched but if/else preferred"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust has no switch. If/else is the idiomatic way to handle boolean conditions."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 17.1",
      "guideline_title": "The standard header file <stdarg.h> shall not be used",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_o4uSLPo00KUg",
            "fls_title": "Functions",
            "category": -2,
            "score": 0.75,
            "reason": "FLS defines 'variadic function' as external function with ... - requires unsafe FFI"
          },
          {
            "fls_id": "fls_wjldgtio5o75",
            "fls_title": "Macro Expansion",
            "category": 0,
            "score": 0.698,
            "reason": "Rust macros provide type-safe variadic-like behavior instead of stdarg.h"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no stdarg.h. Variadic functions exist only for FFI (extern C with ...) and require unsafe. Rust macros provide type-safe alternatives."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_wjldgtio5o75",
            "fls_title": "Macro Expansion",
            "category": 0,
            "score": 0.698,
            "reason": "Safe Rust uses macros for variadic-like patterns - fully type-safe"
          },
          {
            "fls_id": "fls_qcb1n9c0e5hz",
            "fls_title": "Functions",
            "category": 0,
            "score": 0.55,
            "reason": "No variadic functions in safe Rust - only via unsafe FFI"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust has no variadic functions. Macros provide type-safe variadic patterns. C variadic FFI requires unsafe."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 17.2",
      "guideline_title": "Functions shall not call themselves, either directly or indirectly",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "MISRA bans recursion for stack predictability. Rust has no special recursion restrictions - same as C. The FLS defines call expressions and recursion_limit (for macros). Rust idiomatically prefers iteration with iterators. Static analysis tools can detect recursion.",
      "accepted_matches": [
        {
          "fls_id": "fls_3gapgqys3ceb",
          "fls_title": "Recursive Types",
          "category": 0,
          "score": 0.57,
          "reason": "FLS defines recursive types and their constraints - related concept"
        },
        {
          "fls_id": "fls_u2hzlzpzh7yy",
          "fls_title": "Attribute recursion_limit",
          "category": 0,
          "score": 0.46,
          "reason": "FLS recursion_limit attribute controls macro/deref recursion depth"
        },
        {
          "fls_id": "fls_xa4nbfas01cj",
          "fls_title": "Call Expressions",
          "category": 0,
          "score": 0.49,
          "reason": "FLS defines function call semantics including self-referential calls"
        },
        {
          "fls_id": "fls_sf4qnd43z2wc",
          "fls_title": "Infinite Loops",
          "category": 0,
          "score": 0.51,
          "reason": "FLS defines iteration as alternative to recursion for repeated execution"
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "direct_mapping"
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 17.3",
      "guideline_title": "A function shall not be declared implicitly",
      "guideline_type": "rule",
      "applicability_all_rust": "rust_prevents",
      "applicability_safe_rust": "rust_prevents",
      "accepted_matches": [],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "confidence": "medium",
      "notes": "Rust has no implicit function declarations. All functions must be explicitly declared before use - the compiler enforces this strictly.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 17.4",
      "guideline_title": "All exit paths from a function with non-void return type shall have an explicit return statement with an expression",
      "guideline_type": "rule",
      "applicability_all_rust": "rust_prevents",
      "applicability_safe_rust": "rust_prevents",
      "accepted_matches": [],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "n_a",
      "misra_rust_comment": "the return keyword is not needed to return a value in Rust, only to exit",
      "confidence": "medium",
      "notes": "Rust enforces this at compile time. All code paths in a non-unit-returning function must produce a value of the correct type. The last expression in a block is the return value.",
      "rejected_matches": []
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 17.5",
      "guideline_title": "The function argument corresponding to a parameter declared to have an array type shall have an appropriate number of elements",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "rust_prevents",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_uj0kpjwyld60",
            "fls_title": "Array Types",
            "category": 0,
            "score": 0.69,
            "reason": "Array size is part of the type [T; N] - cannot pass wrong-sized array"
          },
          {
            "fls_id": "fls_k9dag68qpe93",
            "fls_title": "Type Unification",
            "category": -2,
            "score": 0.513,
            "reason": "FLS states array types unify only when sizes match - compile-time enforcement"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust arrays include size in the type. [i32; 5] and [i32; 10] are different types. Type system prevents passing wrong-sized arrays."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "rust_prevents",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_uj0kpjwyld60",
            "fls_title": "Array Types",
            "category": 0,
            "score": 0.69,
            "reason": "Array size is compile-time known and part of the type"
          },
          {
            "fls_id": "fls_vpbikb73dw4k",
            "fls_title": "Slice Types",
            "category": 0,
            "score": 0.493,
            "reason": "Slices carry runtime length - bounds checked on access"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust arrays have compile-time size in type. Slices track length at runtime. Both prevent the C issue of wrong-sized arrays."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 17.7",
      "guideline_title": "The value returned by a function having non-void return type shall be used",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_xa4nbfas01cj",
          "fls_title": "Call Expressions",
          "category": 0,
          "score": 0.46,
          "reason": "FLS documents call expressions and their result types. Return values are part of the expression's type."
        },
        {
          "fls_id": "fls_bu6i3mcvnbin",
          "fls_title": "Call Expressions",
          "category": -2,
          "score": 0.65,
          "reason": "FLS: 'The type of a call expression is the return type of the invoked function...' Establishes that functions produce typed values."
        },
        {
          "fls_id": "fls_8l74abhlxzdl",
          "fls_title": "Return Expressions",
          "category": 0,
          "score": 0.61,
          "reason": "FLS documents return expressions. Rust requires explicit handling of Result/Option types via ? or match."
        },
        {
          "fls_id": "fls_EqJb3Jl3vK8K",
          "fls_title": "Functions",
          "category": -2,
          "score": 0.77,
          "reason": "FLS defines function return types. Combined with #[must_use] attribute, Rust can enforce this at compile time."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Rust's #[must_use] attribute (not in FLS core but part of std) directly addresses this. Result and Option types require explicit handling. The compiler warns on unused function results when #[must_use] is applied. This is a key Rust idiom for error handling.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 17.8",
      "guideline_title": "A function parameter should not be modified",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_uwuthzfgslif",
          "fls_title": "Functions",
          "category": -2,
          "score": 0.54,
          "reason": "FLS: 'A function parameter is a construct that yields a set of bindings that bind matched input values to names.' Parameters are bindings, mutable by default only if declared mut."
        },
        {
          "fls_id": "fls_t9mk8kasobea",
          "fls_title": "Binding Scopes",
          "category": -2,
          "score": 0.56,
          "reason": "FLS: 'The binding of a function parameter is in scope within the related function body.' Parameters are local bindings."
        },
        {
          "fls_id": "fls_qssijtofa9i8",
          "fls_title": "Binding Modes",
          "category": 0,
          "score": 0.5,
          "reason": "FLS documents binding modes. Parameters without mut are immutable bindings - modification is a compile error."
        },
        {
          "fls_id": "fls_77scxuomlbgs",
          "fls_title": "Passing Conventions",
          "category": 0,
          "score": 0.53,
          "reason": "FLS: Parameters are passed by move or reference. The original value's mutability is separate from parameter mutability."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "disapplied",
      "misra_rust_comment": "this cannot be done accidentally without declaring parameters `mut`",
      "confidence": "medium",
      "notes": "In Rust, function parameters are immutable bindings by default. Explicit 'mut' is required to modify a parameter. This makes parameter modification visible in the signature (fn foo(mut x: i32)). MISRA's concern is partially addressed by this explicitness.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 17.9",
      "guideline_title": "A function declared with a _Noreturn function specifier shall not return to its caller C11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_98lnexk53ru4",
          "fls_title": "Never Type",
          "category": 0,
          "score": 0.56,
          "reason": "FLS: The never type (!) represents computations that never complete. Equivalent to C11's _Noreturn."
        },
        {
          "fls_id": "fls_4u0v5uy95pyf",
          "fls_title": "Never Type",
          "category": -2,
          "score": 0.54,
          "reason": "FLS: 'The never type is a type that represents the result of a computation that never completes.' Direct equivalent to _Noreturn semantics."
        },
        {
          "fls_id": "fls_zJOAmSr3Dbqk",
          "fls_title": "Diverging Expressions",
          "category": 0,
          "score": 0.51,
          "reason": "FLS documents diverging expressions. Functions returning ! must diverge."
        },
        {
          "fls_id": "fls_4wDpAHhnWZAB",
          "fls_title": "Diverging Expressions",
          "category": -2,
          "score": 0.6,
          "reason": "FLS: 'Call expressions and method call expressions if the return type of the call operand is the never type.' Establishes divergence requirements."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "misra_rust_comment": "this is expressed with the `!` (Never) type, and enforced by rustc",
      "confidence": "medium",
      "notes": "Rust's never type (!) directly maps to C11's _Noreturn. A function declared as fn foo() -> ! must diverge (never return). The compiler enforces this - attempting to return from such a function is a compile error.",
      "rejected_matches": []
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 17.10",
      "guideline_title": "A function declared with a _Noreturn function specifier shall have void return type",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "rust_alternative",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_98lnexk53ru4",
            "fls_title": "Never Type",
            "category": 0,
            "score": 0.588,
            "reason": "Rust uses never type (!) for functions that don't return - no _Noreturn equivalent needed"
          },
          {
            "fls_id": "fls_7Ck4LMQMeQCv",
            "fls_title": "Return Expressions",
            "category": -2,
            "score": 0.708,
            "reason": "FLS states 'type of a return expression is the never type' - consistent design"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust uses never type (!) for non-returning functions. The return type IS !, not void. This is consistent - MISRA's concern about mismatched _Noreturn/return-type doesn't apply."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "rust_alternative",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_98lnexk53ru4",
            "fls_title": "Never Type",
            "category": 0,
            "score": 0.588,
            "reason": "Never type (!) is Rust's mechanism for non-returning functions"
          },
          {
            "fls_id": "fls_k02nt1m5fq1z",
            "fls_title": "Panic",
            "category": 0,
            "score": 0.596,
            "reason": "Panic is a common way to produce never type in safe Rust"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust uses never type (!) consistently. Functions like panic!() return ! and type system enforces this."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 17.11",
      "guideline_title": "A function that never returns should be declared with a _Noreturn function specifier",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "accepted_matches": [
        {
          "fls_id": "fls_98lnexk53ru4",
          "fls_title": "Never Type",
          "category": 0,
          "score": 0.56,
          "reason": "FLS: The never type (!) is Rust's equivalent to _Noreturn. Functions that never return should declare -> ! return type."
        },
        {
          "fls_id": "fls_4u0v5uy95pyf",
          "fls_title": "Never Type",
          "category": -2,
          "score": 0.54,
          "reason": "FLS: 'The never type is a type that represents the result of a computation that never completes.' Used to declare non-returning functions."
        },
        {
          "fls_id": "fls_zJOAmSr3Dbqk",
          "fls_title": "Diverging Expressions",
          "category": 0,
          "score": 0.51,
          "reason": "FLS: Diverging expressions have the never type. Functions like panic!() and loop {} diverge."
        },
        {
          "fls_id": "fls_rpedapxnv8w3",
          "fls_title": "Infinite Loops",
          "category": -2,
          "score": 0.52,
          "reason": "FLS: 'If the infinite loop expression does not contain a break expression, then the type is the never type.' Example of diverging construct."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "advisory",
      "misra_rust_comment": "a non-returning function can be declared to return a value type",
      "confidence": "medium",
      "notes": "Rust's -> ! return type directly addresses this. Functions that never return (panic, abort, infinite loops) should be declared with -> ! to communicate intent and enable compiler optimizations. This is idiomatic Rust.",
      "rejected_matches": []
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 17.12",
      "guideline_title": "A function identifier should only be used with either a preceding &, or with a parenthesized parameter list",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "rust_prevents",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_airvr79xkcag",
            "fls_title": "Function Item Types",
            "category": 0,
            "score": 0.705,
            "reason": "Function items are distinct zero-sized types, not pointers"
          },
          {
            "fls_id": "fls_e9x4f7qxvvjv",
            "fls_title": "Function Item Types",
            "category": -2,
            "score": 0.805,
            "reason": "FLS states function item type is coercible to function pointer - explicit conversion"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust function items are zero-sized types distinct from function pointers. Using fn name gives function item type, calling requires (). Type system prevents confusion."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "rust_prevents",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_airvr79xkcag",
            "fls_title": "Function Item Types",
            "category": 0,
            "score": 0.705,
            "reason": "Function items are distinct types in safe Rust"
          },
          {
            "fls_id": "fls_xa4nbfas01cj",
            "fls_title": "Call Expressions",
            "category": 0,
            "score": 0.584,
            "reason": "Calling requires explicit () - no accidental pointer conversion"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust type system distinguishes function items from pointers. Cannot accidentally convert to pointer."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 17.13",
      "guideline_title": "A function type shall not be type qualified",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_xztr1kebz8bo",
            "fls_title": "Function Pointer Types",
            "category": 0,
            "score": 0.813,
            "reason": "Function pointer types have no C-style const/volatile qualifiers"
          },
          {
            "fls_id": "fls_2049qu3ji5x7",
            "fls_title": "Functions",
            "category": -2,
            "score": 0.578,
            "reason": "const fn is about compile-time evaluation, not type qualification"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no const/volatile type qualifiers like C. Function types don't have such qualifiers. const fn is different - it enables compile-time evaluation."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_xztr1kebz8bo",
            "fls_title": "Function Pointer Types",
            "category": 0,
            "score": 0.813,
            "reason": "No C-style type qualifiers on function types"
          },
          {
            "fls_id": "fls_hbbek3z4wtcs",
            "fls_title": "Function Types",
            "category": 0,
            "score": 0.637,
            "reason": "Function types are defined without qualifiers"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust has no const/volatile qualifiers on types. The C concept doesn't exist."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 18.1",
      "guideline_title": "A pointer resulting from arithmetic on a pointer operand shall address an element of the same array as that pointer operand C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_sxcr4aa098i6",
          "fls_title": "Indexing Expressions",
          "category": 0,
          "score": 0.46,
          "reason": "FLS: Indexing via [] is bounds-checked at runtime for slices and arrays. Panics on out-of-bounds access."
        },
        {
          "fls_id": "fls_9wgldua1u8yt",
          "fls_title": "Dereference Expression",
          "category": -4,
          "score": 0.64,
          "reason": "FLS UB: 'It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.' Raw pointer arithmetic is unsafe."
        },
        {
          "fls_id": "fls_ppd1xwve3tr7",
          "fls_title": "Raw Pointer Types",
          "category": 0,
          "score": 0.63,
          "reason": "FLS: Raw pointer types. Pointer arithmetic is not directly supported - requires unsafe offset() methods."
        },
        {
          "fls_id": "fls_vpbikb73dw4k",
          "fls_title": "Slice Types",
          "category": 0,
          "score": 0.48,
          "reason": "FLS: Slices carry length information. Safe Rust indexing is bounds-checked via the Index trait."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "by unsafe API",
      "confidence": "medium",
      "notes": "In safe Rust, array/slice indexing is bounds-checked at runtime. Raw pointer arithmetic requires unsafe and is not a built-in operator. Rust's design strongly discourages pointer arithmetic in favor of slice iterators and indexing, which are safe by default.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 18.2",
      "guideline_title": "Subtraction between pointers shall only be applied to pointers that address elements of the same array C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_ppd1xwve3tr7",
          "fls_title": "Raw Pointer Types",
          "category": 0,
          "score": 0.63,
          "reason": "FLS: Raw pointers. Pointer subtraction requires unsafe code via offset_from() which has documented preconditions."
        },
        {
          "fls_id": "fls_9wgldua1u8yt",
          "fls_title": "Dereference Expression",
          "category": -4,
          "score": 0.64,
          "reason": "FLS UB: Dereferencing dangling/unaligned raw pointers is UB. Same underlying concerns apply to pointer subtraction."
        },
        {
          "fls_id": "fls_vpbikb73dw4k",
          "fls_title": "Slice Types",
          "category": 0,
          "score": 0.48,
          "reason": "FLS: Slices carry length. Subslice operations are bounds-checked in safe Rust."
        },
        {
          "fls_id": "fls_sxcr4aa098i6",
          "fls_title": "Indexing Expressions",
          "category": 0,
          "score": 0.46,
          "reason": "FLS: Safe indexing uses Index trait. Rust encourages iterators over pointer arithmetic."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "by unsafe API",
      "confidence": "medium",
      "notes": "Rust does not have a built-in pointer subtraction operator. The offset_from() method on raw pointers requires unsafe and documents that pointers must be from the same allocation. Safe Rust uses slice iterators and lengths instead of pointer arithmetic.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 18.3",
      "guideline_title": "The relational operators >, >=, < and <= shall not be applied to expressions of pointer type except where they point into the same object C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_hrum767l6dte",
          "fls_title": "Raw Pointer Types",
          "category": -2,
          "score": 0.49,
          "reason": "FLS: 'Comparing two values of raw pointer types compares the addresses of the values.' Raw pointer comparison is allowed but semantics are limited."
        },
        {
          "fls_id": "fls_ppd1xwve3tr7",
          "fls_title": "Raw Pointer Types",
          "category": 0,
          "score": 0.63,
          "reason": "FLS: Raw pointer comparison. Relational comparisons (<, >) are defined but produce unspecified results for pointers to different objects."
        },
        {
          "fls_id": "fls_k6ues2936pjq",
          "fls_title": "Raw Pointer Types",
          "category": -2,
          "score": 0.45,
          "reason": "FLS: 'Comparing a value of a raw pointer type to a value of a dynamically sized type compares the data being pointed to.' DST comparison semantics."
        },
        {
          "fls_id": "fls_9wgldua1u8yt",
          "fls_title": "Dereference Expression",
          "category": -4,
          "score": 0.64,
          "reason": "FLS: UB rules for raw pointers. Comparing invalid pointers is problematic."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Rust allows raw pointer comparison via <, >, etc., but the result is unspecified for pointers to different objects. Safe Rust references cannot be compared relationally across different allocations. MISRA's concern is partially addressed by Rust's preference for iterators over pointer arithmetic.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 18.4",
      "guideline_title": "The +, -, += and -= operators should not be applied to an expression of pointer type",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_sxcr4aa098i6",
          "fls_title": "Indexing Expressions",
          "category": 0,
          "score": 0.46,
          "reason": "FLS: Array indexing via [] is the preferred method over pointer arithmetic. Bounds-checked in safe Rust."
        },
        {
          "fls_id": "fls_ppd1xwve3tr7",
          "fls_title": "Raw Pointer Types",
          "category": 0,
          "score": 0.63,
          "reason": "FLS: Raw pointer types. +/- operators are not defined for raw pointers - must use offset() methods which require unsafe."
        },
        {
          "fls_id": "fls_xinykul167l",
          "fls_title": "Array Expressions",
          "category": 0,
          "score": 0.69,
          "reason": "FLS: Array expressions and iteration. Rust encourages iterators over index arithmetic."
        },
        {
          "fls_id": "fls_vpbikb73dw4k",
          "fls_title": "Slice Types",
          "category": 0,
          "score": 0.48,
          "reason": "FLS: Slices are the idiomatic way to work with contiguous sequences. Iteration is preferred over indexing."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "advisory",
      "misra_rust_comment": "applies to use of the unsafe API",
      "confidence": "medium",
      "notes": "Rust does not have built-in +/- operators for raw pointers. Array subscript (arr[i]) is the standard way to access elements. For raw pointers, offset() requires unsafe. This aligns with MISRA's preference - Rust's design makes the safer pattern (indexing) the default.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 18.5",
      "guideline_title": "Declarations should contain no more than two levels of pointer nesting",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_3i4ou0dq64ny",
          "fls_title": "Indirection Types",
          "category": 0,
          "score": 0.53,
          "reason": "FLS: Documents indirection types (references and raw pointers). Multiple levels of indirection are allowed but not encouraged."
        },
        {
          "fls_id": "fls_ppd1xwve3tr7",
          "fls_title": "Raw Pointer Types",
          "category": 0,
          "score": 0.41,
          "reason": "FLS: Raw pointer types. *const *const T is valid syntax for nested pointer types."
        },
        {
          "fls_id": "fls_v5x85lt5ulva",
          "fls_title": "References",
          "category": 0,
          "score": 0.4,
          "reason": "FLS: Reference types. &&T is valid but unusual. Rust's ownership model often eliminates need for deep nesting."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "recommended",
      "confidence": "medium",
      "notes": "Rust allows multiple levels of pointer/reference nesting but the ownership system often provides alternatives. Deep nesting is syntactically obvious and uncommon in idiomatic Rust. This MISRA guideline remains a valid style recommendation for Rust code.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 18.6",
      "guideline_title": "The address of an object with automatic or thread-local storage shall not be copied to another object that persists after the first object has ceased to exist C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_a14slch83hzn",
          "fls_title": "Borrowing",
          "category": 0,
          "score": 0.73,
          "reason": "FLS: Borrowing system prevents dangling references. Borrows have lifetimes that must not outlive the borrowed value."
        },
        {
          "fls_id": "fls_v5x85lt5ulva",
          "fls_title": "References",
          "category": 0,
          "score": 0.74,
          "reason": "FLS: References carry lifetime information. The compiler ensures references don't outlive their referents."
        },
        {
          "fls_id": "fls_w5bjgaov8w60",
          "fls_title": "Borrowing",
          "category": -2,
          "score": 0.62,
          "reason": "FLS: 'A mutable borrow of type &'a mut T is created, where lifetime 'a is replaced by a lifetime variable.' Lifetimes track validity."
        },
        {
          "fls_id": "fls_9wgldua1u8yt",
          "fls_title": "Dereference Expression",
          "category": -4,
          "score": 0.66,
          "reason": "FLS UB: 'It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.' For raw pointers, dangling is UB."
        },
        {
          "fls_id": "fls_eT1hnLOx6vxk",
          "fls_title": "References",
          "category": -4,
          "score": 0.57,
          "reason": "FLS UB: Aliasing mutable references is UB. The borrow checker prevents this in safe code."
        }
      ],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Rust's borrow checker directly prevents this issue in safe code. References cannot outlive their referents - the compiler tracks lifetimes and rejects code that would create dangling references. This is one of Rust's core safety guarantees.",
      "rejected_matches": []
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 18.7",
      "guideline_title": "Flexible array members shall not be declared",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_uj0kpjwyld60",
            "fls_title": "Array Types",
            "category": 0,
            "score": 0.584,
            "reason": "Array size must be constant expression - no flexible arrays"
          },
          {
            "fls_id": "fls_imr2jx6cbuzq",
            "fls_title": "Array Types",
            "category": -2,
            "score": 0.607,
            "reason": "FLS states size operand shall be constant expression or inferred constant"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no flexible array members. Arrays require compile-time constant size. Slices provide dynamic sizing with tracked length."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_uj0kpjwyld60",
            "fls_title": "Array Types",
            "category": 0,
            "score": 0.584,
            "reason": "No flexible array members - size must be compile-time known"
          },
          {
            "fls_id": "fls_vpbikb73dw4k",
            "fls_title": "Slice Types",
            "category": 0,
            "score": 0.71,
            "reason": "Slices are dynamically sized but carry length - safe alternative"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust has no flexible array members. Use Vec or slices for dynamic-sized collections."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 18.8",
      "guideline_title": "Variable-length arrays shall not be used",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "rust_prevents",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_3gapgqys3ceb",
            "fls_title": "Array Types",
            "category": 0,
            "score": 0.52,
            "reason": "Per FLS 'The size operand shall be a constant expression' - Rust arrays require compile-time constant size, preventing VLAs entirely"
          },
          {
            "fls_id": "fls_66m4rnbssgig",
            "fls_title": "Constant Expressions",
            "category": 0,
            "score": 0.48,
            "reason": "Per FLS: 'A constant expression is an expression that can be evaluated statically.' Array size operands are listed as constant contexts, preventing runtime-sized (variable-length) arrays."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust prevents VLAs by design - array sizes must be constant expressions. For dynamic sizing, Vec (heap) or slices are used instead."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "rust_prevents",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_imr2jx6cbuzq",
            "fls_title": "Array Types - Legality Rules",
            "category": -2,
            "score": 0.68,
            "reason": "Per FLS 'The size operand shall be a constant expression or an inferred constant' - prevents runtime-sized arrays"
          },
          {
            "fls_id": "fls_vpbikb73dw4k",
            "fls_title": "Slice Types",
            "category": 0,
            "score": 0.59,
            "reason": "Slices are Rust's safe alternative for dynamic-length sequences - they reference existing data rather than stack-allocating"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust prevents VLAs identically to all Rust - array sizes must be constant expressions. Slices provide safe dynamic-length views."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 18.9",
      "guideline_title": "An object with temporary lifetime shall not undergo array-to-pointer conversion",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "rust_prevents",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_a14slch83hzn",
            "fls_title": "Borrowing",
            "category": 0,
            "score": 0.69,
            "reason": "Per FLS 'Borrowing is the process of temporarily associating a reference with a value' - lifetime tracking prevents dangling references to temporaries"
          },
          {
            "fls_id": "fls_rm4ncoopcdvj",
            "fls_title": "Drop Scopes",
            "category": 0,
            "score": 0.59,
            "reason": "Defines when temporaries are destroyed - borrow checker ensures no references outlive their referent"
          },
          {
            "fls_id": "fls_9wgldua1u8yt",
            "fls_title": "Dereference Expression - UB",
            "category": -4,
            "score": 0.62,
            "reason": "Documents that dangling raw pointer dereference is UB, but safe Rust prevents creating such pointers"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust's lifetime system prevents dangling references to temporaries at compile time. The borrow checker ensures references cannot outlive their referents."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "rust_prevents",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_cckf6dtkgwb4",
            "fls_title": "References - Legality Rules",
            "category": -2,
            "score": 0.46,
            "reason": "Per FLS 'The lifetime of a referent shall be at least as long as the lifetime of its reference' - compile-time enforcement"
          },
          {
            "fls_id": "fls_8r39duatupxw",
            "fls_title": "Drop Scopes - Legality Rules",
            "category": -2,
            "score": 0.73,
            "reason": "Temporaries are associated with drop scopes - compiler tracks when they're destroyed"
          },
          {
            "fls_id": "fls_kflqez2mtbit",
            "fls_title": "Drop Scope Extension",
            "category": -2,
            "score": 0.66,
            "reason": "Drop scope extension prevents premature dropping when references are taken"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust completely prevents dangling references through compile-time lifetime checking. The borrow checker ensures references cannot outlive their referents."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 18.10",
      "guideline_title": "Pointers to variably-modified array types shall not be used",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_imr2jx6cbuzq",
            "fls_title": "Array Types - Legality Rules",
            "category": -2,
            "score": 0.69,
            "reason": "Per FLS 'The size operand shall be a constant expression or an inferred constant' - no variably-modified array types exist in Rust"
          },
          {
            "fls_id": "fls_vpbikb73dw4k",
            "fls_title": "Slice Types",
            "category": 0,
            "score": 0.7,
            "reason": "Slices are Rust's safe alternative for dynamic-length views - they are fat pointers carrying length safely"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no variably-modified array types. Array sizes are always compile-time constants. Slices provide safe dynamic-length views with embedded length."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_fx7b3qv3ghca",
            "fls_title": "Array Types - Legality Rules",
            "category": -2,
            "score": 0.56,
            "reason": "Per FLS 'An array type is a sequence type that represents a fixed sequence of elements' - size is fixed at compile time"
          },
          {
            "fls_id": "fls_e5hivr6m5s3h",
            "fls_title": "Type Layout - Fat Pointers",
            "category": -2,
            "score": 0.63,
            "reason": "Fat pointers carry metadata safely - Rust's approach to dynamic sizing is type-safe"
          },
          {
            "fls_id": "fls_26Xgem831Nqg",
            "fls_title": "Type Layout - DST",
            "category": -2,
            "score": 0.64,
            "reason": "Dynamically sized types are handled through Sized trait - different from C's variably-modified types"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust has no variably-modified array types. Arrays have fixed compile-time sizes. Slices and DSTs provide safe dynamic sizing through fat pointers."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 19.1",
      "guideline_title": "An object shall not be assigned or copied to an overlapping object C90 [Undefined 34, 55], C99 [Undefined 51, 94], C11 [Undefined 54, 100]",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Safe Rust's borrow checker prevents overlapping mutable references at compile time. FLS 15.3 explicitly states 'no other reference shall refer to a value that overlaps with the referent of the mutable reference'. In unsafe Rust, aliasing mutable references is explicitly UB.",
      "accepted_matches": [
        {
          "fls_id": "fls_v5x85lt5ulva",
          "fls_section": "15.3",
          "fls_title": "References",
          "score": 0.526,
          "reason": "PRIMARY: Per FLS fls_i1ny0k726a4a: 'While a mutable reference is active, no other reference shall refer to a value that overlaps with the referent of the mutable reference.' Also defines UB: 'It is undefined behavior to access a value through aliasing mutable references from unsafe context.'",
          "category": -2
        },
        {
          "fls_id": "fls_a14slch83hzn",
          "fls_section": "15.4",
          "fls_title": "Borrowing",
          "score": 0.492,
          "reason": "Per FLS fls_kxws4zmaahj6: 'Borrowing a field of a union type borrows all remaining fields using the same lifetime.' This treats union fields as overlapping memory.",
          "category": -2
        }
      ],
      "rejected_matches": [
        {
          "fls_id": "fls_94a8v54bufn8",
          "fls_section": "7",
          "fls_title": "Values",
          "score": 0.525,
          "reason": "Chapter-level section too broad. Contains value overlap definition but the enforceable rules are in 15.3 References.",
          "category": -2
        },
        {
          "fls_id": "fls_9beohh5475s2",
          "fls_section": "6.5.11.2",
          "fls_title": "Destructuring Assignment",
          "score": 0.519,
          "reason": "About tuple destructuring syntax, not memory overlap safety concerns.",
          "category": -2
        }
      ]
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 19.2",
      "guideline_title": "The union keyword should not be used C90 [Undefined 39, 40; Implementation G.3.9(1)] C99 [Unspecified 10; Undefined 61, 62] C11 [Unspecified 11; Undefined 64, 65]",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "yes",
        "adjusted_category": "advisory",
        "rationale_type": "direct_mapping",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_fmdn7n7s413d",
            "fls_title": "Union Types",
            "category": 0,
            "score": 0.692,
            "reason": "FLS defines union types. Per fls_I5fN5Fmo5CyK unions exist but reading fields is unsafe. The MISRA advisory against unions applies directly to Rust."
          },
          {
            "fls_id": "fls_jep7p27kaqlp",
            "fls_title": "Unsafety",
            "category": 0,
            "score": 0.56,
            "reason": "Per fls_ucghxcnpaq2t 'Accessing a field of a union, other than to assign to it' requires unsafe. Rust enforces this at compile time."
          },
          {
            "fls_id": "fls_18k3uajrgq5f",
            "fls_title": "Field Access Expressions",
            "category": 0,
            "score": 0.757,
            "reason": "Per fls_kddnnz8uc15b 'Reading the selected field of a union shall require unsafe context.' Per fls_Vani4665hiJY 'It is undefined behavior reading the selected field of a union type when it contains data that is invalid.'"
          },
          {
            "fls_id": "fls_szibmtfv117b",
            "fls_title": "Enum Types",
            "category": 0,
            "score": 0.733,
            "reason": "Per fls_t4yeovFm83Wo 'A discriminant is an opaque integer that identifies an enum variant.' Rust enums are the safe alternative to C unions for tagged data."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 1,
        "notes": "MISRA's concern about unions directly applies to Rust. While Rust unions exist and require unsafe for field reads, the recommendation to avoid them is sound. Rust enums with exhaustive matching provide a type-safe alternative for discriminated unions."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "rust_prevents",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_szibmtfv117b",
            "fls_title": "Enum Types",
            "category": 0,
            "score": 0.634,
            "reason": "Rust enums are safe tagged unions. Per fls_t4yeovFm83Wo the discriminant identifies which variant is active, preventing UB from accessing the wrong field."
          },
          {
            "fls_id": "fls_vlrto778v49m",
            "fls_title": "Tuple Struct Patterns",
            "category": 0,
            "score": 0.667,
            "reason": "Per fls_ks6y1syab2bp 'A tuple struct pattern matches a tuple enum variant value.' Pattern matching ensures type-safe access to enum data."
          },
          {
            "fls_id": "fls_jm6l7b90h6wa",
            "fls_title": "Pattern Matching",
            "category": 0,
            "score": 0.692,
            "reason": "Exhaustive pattern matching on enums ensures all variants are handled. The compiler enforces this, preventing missed cases."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 1,
        "notes": "Safe Rust cannot use unions - union field access requires unsafe. Safe Rust uses enums which are type-safe discriminated unions. The compiler tracks the active variant and enforces exhaustive matching, completely preventing the UB that MISRA's rule aims to avoid."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 19.3",
      "guideline_title": "A union member shall not be read unless it has been previously set C99 [Unspecified 10], C11 [Unspecified 11]",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "yes",
        "adjusted_category": "required",
        "rationale_type": "direct_mapping",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_18k3uajrgq5f",
            "fls_title": "Field Access Expressions",
            "category": 0,
            "score": 0.636,
            "reason": "Per fls_t6xmsm2nk1bc 'Writing to and then reading from the selected field of a union subject to attribute repr is equivalent to invoking function core::mem::transmute.' Per fls_Vani4665hiJY 'It is undefined behavior reading the selected field of a union type when it contains data that is invalid for the selected field type.'"
          },
          {
            "fls_id": "fls_jep7p27kaqlp",
            "fls_title": "Unsafety",
            "category": 0,
            "score": 0.624,
            "reason": "Per fls_ucghxcnpaq2t 'Accessing a field of a union, other than to assign to it' is an unsafe operation. The programmer must ensure the correct field is read."
          },
          {
            "fls_id": "fls_fmdn7n7s413d",
            "fls_title": "Union Types",
            "category": 0,
            "score": 0.672,
            "reason": "FLS defines union types where all fields share common storage. Reading a different field than was written interprets the bits as a different type."
          },
          {
            "fls_id": "fls_94a8v54bufn8",
            "fls_title": "Values",
            "category": 0,
            "score": 0.593,
            "reason": "Per fls_6lg0oaaopc26 'It is undefined behavior to create a value from uninitialized memory unless the type of the value is a union type.' Union semantics require careful tracking of the active field."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 1,
        "notes": "MISRA Rule 19.3 directly applies to Rust unions. Reading a union field that wasn't the last one written is UB in Rust just as in C. The unsafe requirement provides a reminder but doesn't prevent the UB - the programmer must track which field is active."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "rust_prevents",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_szibmtfv117b",
            "fls_title": "Enum Types",
            "category": 0,
            "score": 0.688,
            "reason": "Per fls_t4yeovFm83Wo 'A discriminant is an opaque integer that identifies an enum variant.' The compiler tracks which variant is active and prevents accessing data from a different variant."
          },
          {
            "fls_id": "fls_jep7p27kaqlp",
            "fls_title": "Unsafety",
            "category": 0,
            "score": 0.58,
            "reason": "Per fls_ucghxcnpaq2t 'Accessing a field of a union, other than to assign to it' requires unsafe. Safe Rust cannot read union fields at all."
          },
          {
            "fls_id": "fls_e5td0fa92fay",
            "fls_title": "Match Expressions",
            "category": 0,
            "score": 0.634,
            "reason": "Safe Rust uses match expressions to destructure enums. The compiler ensures only the matched variant's data is accessed."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 1,
        "notes": "Safe Rust cannot read union fields - this requires unsafe. Safe Rust uses enums where the compiler tracks which variant is active and pattern matching ensures you only access data from the correct variant. This completely prevents the UB that MISRA Rule 19.3 addresses."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 20.1",
      "guideline_title": "#include directives should only be preceded by preprocessor directives or comments",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_9gprp17h6t1q",
            "fls_title": "Use Imports",
            "category": 0,
            "score": 0.725,
            "reason": "Rust uses module imports not #include - no textual inclusion"
          },
          {
            "fls_id": "fls_e9hwvqsib5d5",
            "fls_title": "Modules",
            "category": 0,
            "score": 0.49,
            "reason": "Modules provide structured code organization without preprocessor"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no C preprocessor. No #include directive exists. Rust uses module system with 'use' for imports."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_9gprp17h6t1q",
            "fls_title": "Use Imports",
            "category": 0,
            "score": 0.725,
            "reason": "Use imports bring items into scope without textual inclusion"
          },
          {
            "fls_id": "fls_maw4u1o8q37u",
            "fls_title": "Crates",
            "category": 0,
            "score": 0.666,
            "reason": "Crate system provides compilation units without preprocessor"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust has no C preprocessor. Modules and use provide structured imports."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 20.2",
      "guideline_title": "The ', \" or \\ characters and the /* or // character sequences shall not occur in a header file name",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_1zbaajz5prpn",
            "fls_title": "Attribute path",
            "category": 0,
            "score": 0.659,
            "reason": "Module paths use #[path] attribute - different from C #include"
          },
          {
            "fls_id": "fls_9gprp17h6t1q",
            "fls_title": "Use Imports",
            "category": 0,
            "score": 0.436,
            "reason": "Use imports use Rust identifiers, not file paths with special characters"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no #include. Module paths are Rust identifiers or controlled via #[path] attribute. The C concern about characters in header names doesn't apply."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_1zbaajz5prpn",
            "fls_title": "Attribute path",
            "category": 0,
            "score": 0.659,
            "reason": "Module paths are controlled differently than C includes"
          },
          {
            "fls_id": "fls_21vnag69kbwe",
            "fls_title": "Identifiers",
            "category": 0,
            "score": 0.593,
            "reason": "Identifiers have defined rules - no special char issues"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust has no #include. Module system uses identifiers with defined lexical rules."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 20.3",
      "guideline_title": "The #include directive shall be followed by either a <filename> or \"filename\" sequence",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_e9hwvqsib5d5",
            "fls_title": "Modules",
            "category": 0,
            "score": 0.49,
            "reason": "Rust uses a module system instead of textual inclusion - modules are compiled once, not included"
          },
          {
            "fls_id": "fls_9gprp17h6t1q",
            "fls_title": "Use Imports",
            "category": 0,
            "score": 0.66,
            "reason": "Use imports bring names into scope through the module path system, not textual inclusion"
          },
          {
            "fls_id": "fls_s35hob3i7lr",
            "fls_title": "Source Files",
            "category": 0,
            "score": 0.66,
            "reason": "Source files are compilation units, not textually included headers"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no #include directive or C preprocessor. The module system and use imports replace header inclusion entirely."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_e9hwvqsib5d5",
            "fls_title": "Modules",
            "category": 0,
            "score": 0.58,
            "reason": "Modules are containers for items, compiled once - no textual inclusion"
          },
          {
            "fls_id": "fls_gklst7joeo33",
            "fls_title": "Crate Imports",
            "category": 0,
            "score": 0.63,
            "reason": "External crates are imported through crate imports, not preprocessor directives"
          },
          {
            "fls_id": "fls_bbso3c45kr9z",
            "fls_title": "Simple Path Resolution",
            "category": 0,
            "score": 0.55,
            "reason": "Path resolution is semantic, not textual - paths resolve through module hierarchy"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust has no preprocessor or #include. Module system with semantic path resolution replaces textual inclusion entirely."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 20.4",
      "guideline_title": "A macro shall not be defined with the same name as a keyword C90",
      "guideline_type": "rule",
      "applicability_all_rust": "partial",
      "applicability_safe_rust": "partial",
      "accepted_matches": [
        {
          "fls_id": "fls_21vnag69kbwe",
          "fls_title": "Identifiers",
          "category": 0,
          "score": 0.67,
          "reason": "FLS identifiers cannot be keywords - macros cannot shadow keywords"
        },
        {
          "fls_id": "fls_xlfo7di0gsqz",
          "fls_title": "Hygiene",
          "category": 0,
          "score": 0.66,
          "reason": "FLS macro hygiene prevents name confusion with language constructs"
        },
        {
          "fls_id": "fls_9kjpxri0axvg",
          "fls_title": "Weak Keywords",
          "category": 0,
          "score": 0.6,
          "reason": "FLS distinguishes strict and weak keywords - strict cannot be used as identifiers"
        },
        {
          "fls_id": "fls_xa7lp0zg1ol2",
          "fls_title": "Declarative Macros",
          "category": 0,
          "score": 0.64,
          "reason": "FLS declarative macros have hygiene preventing keyword collisions"
        }
      ],
      "fls_rationale_type": "rust_prevents",
      "misra_rust_category": "required",
      "misra_rust_comment": "possible with raw identifiers but the compiler prevents visual conflicts",
      "confidence": "medium",
      "notes": "MISRA concern is C preprocessor defining over keywords. Rust PREVENTS this: (1) Macro names are identifiers, (2) Keywords cannot be identifiers, (3) Macro hygiene isolates macro-introduced names. The FLS explicitly distinguishes strict keywords (cannot be identifiers) from weak keywords.",
      "rejected_matches": []
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 20.5",
      "guideline_title": "#undef should not be used",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_octf6sf7yso",
            "fls_title": "Textual Macro Scope",
            "category": 0,
            "score": 0.71,
            "reason": "Macros have lexical scope - no mechanism to undefine a macro"
          },
          {
            "fls_id": "fls_xa7lp0zg1ol2",
            "fls_title": "Declarative Macros",
            "category": 0,
            "score": 0.7,
            "reason": "Declarative macros are fixed definitions, not preprocessor text replacement"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no #undef. Macros are scoped constructs with fixed definitions - there's no mechanism to remove a macro definition."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_xlfo7di0gsqz",
            "fls_title": "Hygiene",
            "category": 0,
            "score": 0.67,
            "reason": "Macro hygiene prevents identifier conflicts - no need for undef"
          },
          {
            "fls_id": "fls_e0a96eb6ux3y",
            "fls_title": "Attribute macro_export",
            "category": 0,
            "score": 0.7,
            "reason": "Macro visibility is controlled by attributes, not undef"
          },
          {
            "fls_id": "fls_ydmnb7qnmzzq",
            "fls_title": "Shadowing",
            "category": 0,
            "score": 0.58,
            "reason": "Shadowing is the closest concept - names can shadow but definitions persist"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust has no #undef. Macros use hygiene and scoping rules. There's no mechanism to remove a macro definition."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 20.6",
      "guideline_title": "Tokens that look like a preprocessing directive shall not occur within a macro argument",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_qpx6lgapce57",
            "fls_title": "Token Matching",
            "category": 0,
            "score": 0.78,
            "reason": "Rust macros match token trees - no preprocessing directives exist"
          },
          {
            "fls_id": "fls_wjldgtio5o75",
            "fls_title": "Macro Expansion",
            "category": 0,
            "score": 0.62,
            "reason": "Macro expansion operates on TokenStream, not text - well-defined semantics"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no C preprocessor or preprocessing directives. Macros operate on structured token trees with well-defined matching."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_gvwd0kf72jt",
            "fls_title": "Attributes",
            "category": 0,
            "score": 0.67,
            "reason": "The # character in Rust is for attributes, not preprocessor directives"
          },
          {
            "fls_id": "fls_g1rml9tavh8v",
            "fls_title": "Token Matching - Delimiters",
            "category": -2,
            "score": 0.47,
            "reason": "Delimiters in macros are matched structurally, not textually"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust has no preprocessing directives. The # character introduces attributes. Macro token matching is structural and well-defined."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 20.7",
      "guideline_title": "Expressions resulting from the expansion of macro parameters shall be appropriately delimited",
      "guideline_type": "rule",
      "applicability_all_rust": "partial",
      "applicability_safe_rust": "partial",
      "accepted_matches": [
        {
          "fls_id": "fls_8nzypdu9j3ge",
          "fls_title": "Metavariables",
          "category": 0,
          "score": 0.62,
          "reason": "FLS metavariables with expr specifier capture complete expressions as AST units"
        },
        {
          "fls_id": "fls_kw25194gpael",
          "fls_title": "Expression Precedence",
          "category": 0,
          "score": 0.65,
          "reason": "FLS defines expression precedence - captured expressions maintain integrity"
        },
        {
          "fls_id": "fls_ym00b6ewf4n3",
          "fls_title": "Macro Transcription",
          "category": 0,
          "score": 0.66,
          "reason": "FLS transcription substitutes matched tokens preserving structure"
        },
        {
          "fls_id": "fls_qpx6lgapce57",
          "fls_title": "Token Matching",
          "category": 0,
          "score": 0.59,
          "reason": "FLS fragment specifier expr captures expression as syntactic unit, not text"
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "advisory",
      "misra_rust_comment": "possible to express with procedural macros only, not macro_rules",
      "confidence": "medium",
      "notes": "MISRA concern is C textual substitution causing precedence issues. Rust macros operate on AST tokens, not text. The expr fragment specifier captures a complete expression preserving precedence. No parenthesization needed since substitution is structural, not textual.",
      "rejected_matches": []
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 20.8",
      "guideline_title": "The controlling expression of a #if or #elif preprocessing directive shall evaluate to 0 or 1",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_u1afezy1ye99",
            "fls_title": "Conditional Compilation",
            "category": 0,
            "score": 0.7,
            "reason": "Rust uses cfg attributes for conditional compilation, not preprocessor directives"
          },
          {
            "fls_id": "fls_l96kyix5xsof",
            "fls_title": "Attribute cfg - Configuration Predicate",
            "category": -2,
            "score": 0.71,
            "reason": "Configuration predicates evaluate to true/false - no numeric expressions"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no #if/#elif. Conditional compilation uses cfg attributes with structured predicates that evaluate to boolean true/false."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_l96kyix5xsof",
            "fls_title": "Attribute cfg - Configuration Predicate",
            "category": -2,
            "score": 0.52,
            "reason": "Configuration predicates evaluate to true or false, not numeric values"
          },
          {
            "fls_id": "fls_tncxxsyutppf",
            "fls_title": "Attribute cfg - All Predicate",
            "category": -2,
            "score": 0.5,
            "reason": "Structured predicates (all, any, not) - no arbitrary expressions"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust conditional compilation uses structured cfg predicates that evaluate to boolean true/false, not numeric expressions."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 20.9",
      "guideline_title": "All identifiers used in the controlling expression of #if or #elif preprocessing directives shall be defined before evaluation",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_fymvsy6ig99a",
            "fls_title": "Attribute cfg",
            "category": 0,
            "score": 0.48,
            "reason": "cfg uses configuration options, not arbitrary identifiers that might be undefined"
          },
          {
            "fls_id": "fls_jbl9xyynjo0g",
            "fls_title": "Attribute cfg - Configuration Option",
            "category": -2,
            "score": 0.59,
            "reason": "Configuration option evaluation is tool-defined - no silent 0 replacement"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no #if/#elif. cfg predicates use configuration options whose evaluation is well-defined by the build system."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_spdmit5fy7el",
            "fls_title": "Attribute target_feature",
            "category": 0,
            "score": 0.45,
            "reason": "Target features are predefined by the compiler - not user-defined identifiers"
          },
          {
            "fls_id": "fls_lkdm0mdghppv",
            "fls_title": "Conformity - Implementation Requirements",
            "category": -5,
            "score": 0.55,
            "reason": "Tool conformance is defined - configuration options are well-specified"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust cfg uses predefined configuration options (features, targets) with well-defined semantics. No silent 0 replacement for undefined identifiers."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 20.10",
      "guideline_title": "The # and ## preprocessor operators should not be used",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_ym00b6ewf4n3",
            "fls_title": "Macro Transcription",
            "category": 0,
            "score": 0.7,
            "reason": "Metavariable substitution replaces textual token pasting - structured and well-defined"
          },
          {
            "fls_id": "fls_iw7322ycvhkc",
            "fls_title": "Macro Transcription - Legality Rules",
            "category": -2,
            "score": 0.7,
            "reason": "Metavariable indications are replaced by matched tokens - no undefined behavior"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no # or ## operators. Macro transcription uses structured metavariable substitution, not text-based pasting."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_8zypylq60zba",
            "fls_title": "Metavariables - Fragment Specifier",
            "category": -2,
            "score": 0.74,
            "reason": "Fragment specifiers define how tokens are matched - typed substitution, not text pasting"
          },
          {
            "fls_id": "fls_xlfo7di0gsqz",
            "fls_title": "Hygiene",
            "category": 0,
            "score": 0.72,
            "reason": "Macro hygiene ensures identifiers don't accidentally collide - structured approach"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust macros use fragment specifiers and hygiene. No text-based # or ## operators exist."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 20.11",
      "guideline_title": "A macro parameter immediately following a # operator shall not immediately be followed by a ## operator",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_k01lsksqtq1r",
            "fls_title": "Repetition",
            "category": 0,
            "score": 0.68,
            "reason": "Macro repetition is structured pattern matching - no # or ## text operators"
          },
          {
            "fls_id": "fls_ym00b6ewf4n3",
            "fls_title": "Macro Transcription",
            "category": 0,
            "score": 0.65,
            "reason": "Transcription uses metavariable substitution, not text concatenation"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no # or ## operators. Macro repetition and transcription are structured, not text-based."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_dw1nq4r9ghhd",
            "fls_title": "Declarative Macros - Macro Rule",
            "category": -2,
            "score": 0.63,
            "reason": "Macro rules have matcher and transcriber - structured, not text operators"
          },
          {
            "fls_id": "fls_vnvt40pa48n8",
            "fls_title": "Macro Invocation",
            "category": 0,
            "score": 0.64,
            "reason": "Token trees are structured - no text-based # or ## operators"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust macros use structured token matching and transcription. No # or ## text operators exist."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 20.12",
      "guideline_title": "A macro parameter used as an operand to the # or ## operators, which is itself subject to further macro replacement, shall only be used as an operand to these operators",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_wjldgtio5o75",
            "fls_title": "Macro Expansion",
            "category": 0,
            "score": 0.69,
            "reason": "Macro expansion is well-defined - no # or ## operators"
          },
          {
            "fls_id": "fls_xscdaxvs4wx4",
            "fls_title": "Macro Expansion - Legality Rules",
            "category": -2,
            "score": 0.61,
            "reason": "Macro expansion is static process with defined output"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no # or ## operators. Metavariables can be used multiple times with well-defined substitution."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_xscdaxvs4wx4",
            "fls_title": "Macro Expansion - Legality Rules",
            "category": -2,
            "score": 0.72,
            "reason": "Macro expansion is static execution with deterministic output"
          },
          {
            "fls_id": "fls_dqroklsaayzb",
            "fls_title": "Token Matching",
            "category": -2,
            "score": 0.51,
            "reason": "Matched tokens are bound to metavariables - deterministic binding"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust macro expansion is static and deterministic. No # or ## operators with undefined behavior."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 20.13",
      "guideline_title": "A line whose first token is # shall be a valid preprocessing directive",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_gvwd0kf72jt",
            "fls_title": "Attributes",
            "category": 0,
            "score": 0.59,
            "reason": "The # character introduces attributes in Rust, not preprocessing directives"
          },
          {
            "fls_id": "fls_411up5z0b6n6",
            "fls_title": "Lexical Elements",
            "category": 0,
            "score": 0.61,
            "reason": "Rust lexical analysis is well-defined - invalid # syntax is a compile error, not UB"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no C preprocessor. The # character introduces attributes. Invalid syntax is a compile error."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_yd0ehw5csaur",
            "fls_title": "Attributes - Inner Attribute",
            "category": -2,
            "score": 0.71,
            "reason": "Inner and outer attributes are well-defined - invalid syntax is a static error"
          },
          {
            "fls_id": "fls_dd9xh3wdjudo",
            "fls_title": "Attribute cfg_attr",
            "category": 0,
            "score": 0.72,
            "reason": "Built-in attributes like cfg are part of the language - no undefined preprocessing"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust has no preprocessing directives. The # character introduces well-defined attributes. Invalid syntax is a compile error."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 20.14",
      "guideline_title": "All #else, #elif and #endif preprocessor directives shall reside in the same file as the #if, #ifdef or #ifndef directive to which they are related",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_u1afezy1ye99",
            "fls_title": "Conditional Compilation",
            "category": 0,
            "score": 0.61,
            "reason": "Conditional compilation uses cfg attributes on individual items - no file-spanning blocks"
          },
          {
            "fls_id": "fls_dd9xh3wdjudo",
            "fls_title": "Attribute cfg_attr",
            "category": 0,
            "score": 0.69,
            "reason": "cfg_attr applies to items, not spanning files like #if/#endif"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no #if/#else/#endif. cfg attributes apply to single items and cannot span files."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_fhiqvgdamq5",
            "fls_title": "Compilation Roots",
            "category": -2,
            "score": 0.59,
            "reason": "Module tree is structured - no file-spanning conditional blocks"
          },
          {
            "fls_id": "fls_a0u9nnaf6drz",
            "fls_title": "Conditional Compilation",
            "category": -2,
            "score": 0.44,
            "reason": "Conditional compilation applies to items, not spanning constructs"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust cfg attributes apply to individual items within modules. No file-spanning conditional blocks exist."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 20.15",
      "guideline_title": "#define and #undef shall not be used on a reserved identifier or reserved macro name",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_cbsgp6k0qa82",
            "fls_title": "Reserved Keywords",
            "category": 0,
            "score": 0.76,
            "reason": "Reserved keywords cannot be used as identifiers - compile error, not UB"
          },
          {
            "fls_id": "fls_lish33a1naw5",
            "fls_title": "Keywords",
            "category": 0,
            "score": 0.58,
            "reason": "Keywords have special meaning and cannot be redefined via preprocessor"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no #define/#undef. Reserved keywords cannot be used as identifiers - it's a compile error."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_mec5cg5aptf8",
            "fls_title": "Strict Keywords",
            "category": 0,
            "score": 0.62,
            "reason": "Strict keywords always have special meaning - cannot be used as identifiers"
          },
          {
            "fls_id": "fls_9kjpxri0axvg",
            "fls_title": "Weak Keywords",
            "category": 0,
            "score": 0.71,
            "reason": "Weak keywords are context-dependent but still cannot be redefined via preprocessor"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust has no #define/#undef. Keywords are lexically protected - using them as identifiers is a compile error."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 21.3",
      "guideline_title": "The memory allocation and deallocation functions of <stdlib.h> shall not be used C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_fs0lcfllamj",
          "category": 0,
          "fls_title": "Attribute global_allocator",
          "score": 0.58,
          "reason": "Per FLS fls_5b8aewlgeon8: 'Attribute global_allocator shall apply to [static]s whose [type]s implement the core::alloc::GlobalAlloc trait.' This is Rust's mechanism for custom memory allocation."
        },
        {
          "fls_id": "fls_9wgldua1u8yt",
          "category": -4,
          "fls_title": "Dereference Expression (UB)",
          "score": 0.63,
          "reason": "Per FLS: 'It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.' This directly addresses MISRA's concern about using freed memory."
        },
        {
          "fls_id": "fls_u2mzjgiwbkz0",
          "category": 0,
          "fls_title": "Destructors",
          "score": 0.72,
          "reason": "Per FLS fls_wzuwapjqtyyy: 'Dropping a value is the act of invoking the destructor of the related type.' Rust's RAII through Drop handles deallocation automatically for safe types."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "MISRA ADD-6 notes this is only accessible through unsafe extern 'C'. In Rust, memory allocation uses Box/Vec with RAII, or the global allocator interface. When calling C's malloc/free via FFI, these sections apply.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 21.4",
      "guideline_title": "The standard header file <setjmp.h> shall not be used C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "setjmp/longjmp have no Rust equivalent. Rust uses Result/Option for error handling and panic for unwinding. This rule applies only when calling C code via FFI that uses setjmp/longjmp.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 21.5",
      "guideline_title": "The standard header file <signal.h> shall not be used C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "C signal handling has no Rust equivalent. Rust does not have a standard signal handling mechanism. This rule applies only when calling C code via FFI that uses signal.h.",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "no_equivalent"
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 21.6",
      "guideline_title": "The Standard Library input/output functions shall not be used C90",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "yes",
        "adjusted_category": "required",
        "rationale_type": "direct_mapping",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_osd6c4utyjb3",
            "fls_title": "FFI",
            "category": 0,
            "score": 0.614,
            "reason": "Per fls_djlglv2eaihl 'Foreign Function Interface or FFI employs ABI, attributes, external blocks, external functions, linkage, and type layout to interface a Rust program with code written in other programming languages.' C stdio functions accessed via FFI."
          },
          {
            "fls_id": "fls_tmoh3y9oyqsy",
            "fls_title": "External Blocks",
            "category": 0,
            "score": 0.728,
            "reason": "Per fls_4dje9t5y2dia 'An external block provides declarations of external functions and external statics as unchecked imports.' C stdio declarations would appear in external blocks."
          },
          {
            "fls_id": "fls_yztwtek0y34v",
            "fls_title": "External Functions",
            "category": 0,
            "score": 0.651,
            "reason": "Per fls_l88r9fj82650 'An external function shall be invoked from an unsafe context.' Calling C stdio functions requires unsafe."
          },
          {
            "fls_id": "fls_usgd0xlijoxv",
            "fls_title": "ABI",
            "category": 0,
            "score": 0.653,
            "reason": "Per fls_z2kzyin8dyr7 'A function with an ABI but without a specified ABI kind has implicit extern C ABI.' C library functions use the C ABI."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 1,
        "notes": "MISRA Rule 21.6 prohibits C stdio functions (printf, scanf, etc.) due to their undefined/implementation-defined behaviors. In Rust, these can only be called via FFI which requires unsafe. The guideline applies when using extern C to call C library I/O functions."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "rust_prevents",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_jep7p27kaqlp",
            "fls_title": "Unsafety",
            "category": 0,
            "score": 0.647,
            "reason": "Per fls_jb6krd90tjmc 'An unsafe context is either an unsafe block or an unsafe function.' Calling external C functions requires unsafe context."
          },
          {
            "fls_id": "fls_xa4nbfas01cj",
            "fls_title": "Call Expressions",
            "category": 0,
            "score": 0.633,
            "reason": "Per fls_8ljrgdept7s8 'A call expression whose callee type is either an external function item type, an unsafe function item type, or an unsafe function pointer type shall require unsafe context.'"
          },
          {
            "fls_id": "fls_yztwtek0y34v",
            "fls_title": "External Functions",
            "category": 0,
            "score": 0.528,
            "reason": "Per fls_l88r9fj82650 'An external function shall be invoked from an unsafe context.' Safe Rust cannot call C library functions directly."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 1,
        "notes": "Safe Rust cannot call C stdio functions - all FFI calls require unsafe context. Rust's std::io and println!/format! macros are type-safe alternatives that don't have the undefined behavior problems of C stdio."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 21.7",
      "guideline_title": "The Standard Library functions atof, atoi, atol and atoll of <stdlib.h> shall not be used C90",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "yes",
        "adjusted_category": "required",
        "rationale_type": "direct_mapping",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_yztwtek0y34v",
            "fls_title": "External Functions",
            "category": 0,
            "score": 0.569,
            "reason": "Per fls_v24ino4hix3m 'An external function is an unchecked import of a foreign function.' C atoi/atof would be imported this way. Per fls_l88r9fj82650 requires unsafe context."
          },
          {
            "fls_id": "fls_ZfIBiJMf8qE1",
            "fls_title": "Arithmetic Overflow",
            "category": 0,
            "score": 0.695,
            "reason": "Per fls_oFIRXBPXu6Zv 'An arithmetic overflow occurs when an operator expression computes a value that lies outside the range of valid values.' Rust handles overflow explicitly, unlike C atoi UB."
          },
          {
            "fls_id": "fls_usgd0xlijoxv",
            "fls_title": "ABI",
            "category": 0,
            "score": 0.66,
            "reason": "Per fls_x7ct9k82fpgn 'extern C - The default ABI of C code.' C library functions like atoi use this ABI."
          },
          {
            "fls_id": "fls_tmoh3y9oyqsy",
            "fls_title": "External Blocks",
            "category": 0,
            "score": 0.544,
            "reason": "Per fls_4dje9t5y2dia 'An external block provides declarations of external functions as unchecked imports.' C stdlib declarations would be in external blocks."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 1,
        "notes": "MISRA Rule 21.7 prohibits C atoi/atof due to their undefined behavior on conversion errors and overflow. In Rust, calling these functions requires FFI with unsafe. Rust's std::str::parse returns Result and handles errors safely."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "rust_prevents",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_dzq9cdz4ibsz",
            "fls_title": "Exceptions and Errors",
            "category": 0,
            "score": 0.591,
            "reason": "Per fls_ckeitwiv326r 'The result of a possibly erroneous computation is usually represented using enum core::result::Result.' Safe Rust uses Result for fallible operations like parsing."
          },
          {
            "fls_id": "fls_pocsh1neugpc",
            "fls_title": "Error Propagation Expression",
            "category": 0,
            "score": 0.587,
            "reason": "Per fls_ab4vhq4nwn7f 'The type of an error propagation expression is associated type core::ops::Try::Output.' The ? operator provides ergonomic error handling."
          },
          {
            "fls_id": "fls_yztwtek0y34v",
            "fls_title": "External Functions",
            "category": 0,
            "score": 0.569,
            "reason": "Per fls_l88r9fj82650 'An external function shall be invoked from an unsafe context.' Safe Rust cannot call C atoi/atof functions."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 1,
        "notes": "Safe Rust cannot call C atoi/atof - all FFI calls require unsafe. Rust's str::parse() method returns Result<T, E> forcing explicit error handling. There is no undefined behavior on invalid input or overflow."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 21.8",
      "guideline_title": "The Standard Library termination functions of <stdlib.h> shall not be used C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_k02nt1m5fq1z",
          "category": 0,
          "fls_title": "Panic",
          "score": 0.55,
          "reason": "Rust's panic!() macro provides controlled abnormal termination with unwinding. Per FLS, a panic causes the current thread to unwind or abort."
        },
        {
          "fls_id": "fls_hi1iz0gbnksi",
          "category": 0,
          "fls_title": "Abort",
          "score": 0.72,
          "reason": "Per FLS fls_9a1izu3omkbn: 'Abort is the immediate termination of a program.' Per FLS fls_wd2q6ft9yzrg: 'Control flow halts the execution of all threads.' This directly corresponds to C's abort() function."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "C termination functions (abort, exit, _Exit, quick_exit) map to Rust's abort/panic. Rust uses std::process::abort() and panic!() for abnormal termination.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 21.9",
      "guideline_title": "The Standard Library functions bsearch and qsort of <stdlib.h> shall not be used C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "C's bsearch/qsort use function pointers which can be unsafe. Rust provides safe alternatives via slice::binary_search() and slice::sort() which are type-safe and don't require unsafe function pointers.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 21.10",
      "guideline_title": "The Standard Library time and date functions shall not be used C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "C time/date functions have no standard Rust equivalent. Rust uses chrono or std::time for time handling which are type-safe. This applies only when using C time functions via FFI.",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "rust_alternative"
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 21.11",
      "guideline_title": "The standard header file <tgmath.h> should not be used",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_qwljwqr07slp",
            "fls_title": "Numeric Types",
            "category": 0,
            "score": 0.64,
            "reason": "Rust has f32/f64 with inherent methods - no tgmath header"
          },
          {
            "fls_id": "fls_1k9mkv7rbezi",
            "fls_title": "Arithmetic Expressions",
            "category": 0,
            "score": 0.67,
            "reason": "Arithmetic uses trait operations, not preprocessor macros"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no tgmath.h. Numeric types have inherent methods. Generic math uses traits, not preprocessor macros."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_b4xporvr64s",
            "fls_title": "Floating Point Types",
            "category": 0,
            "score": 0.62,
            "reason": "f32/f64 are primitive types with inherent methods, not C headers"
          },
          {
            "fls_id": "fls_v0n0bna40dqr",
            "fls_title": "Implementations - Inherent",
            "category": -2,
            "score": 0.78,
            "reason": "Inherent implementations provide methods directly on types"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust has no C headers. Floating-point types have inherent methods. Generic programming uses trait bounds, not macros."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 21.12",
      "guideline_title": "The standard header file <fenv.h> shall not be used C99",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "C floating-point environment (fenv.h) has no Rust equivalent. Rust does not expose floating-point exception flags or rounding mode control. This applies only when calling C code via FFI.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 21.13",
      "guideline_title": "Any value passed to a function in <ctype.h> shall be representable as an unsigned char or be the value EOF C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "C's ctype.h functions accept int but expect unsigned char range. Rust's char methods (is_alphabetic, is_digit, etc.) work on Unicode chars and are type-safe. This applies only when calling C ctype.h via FFI.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 21.14",
      "guideline_title": "The Standard Library function memcmp shall not be used to compare null terminated strings",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "C's memcmp can expose padding bytes. Rust's PartialEq/Eq traits provide safe comparisons. For byte-level comparison, Rust slices can be compared directly. This applies only when calling C memcmp via FFI.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 21.15",
      "guideline_title": "The pointer arguments to the Standard Library functions memcpy, memmove and memcmp shall be pointers to qualified or unqualified versions of compatible types",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "C's memcpy/memmove/memcmp use void* which loses type information. Rust's slice::copy_from_slice and Clone are type-safe. This applies only when calling C memory functions via FFI.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 21.16",
      "guideline_title": "The pointer arguments to the Standard Library function memcmp shall point to either a pointer type, an essentially signed type, an essentially unsigned type, an essentially Boolean type or an essentially enum type C99",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "C's memcmp with pointers to different types is problematic. Rust's comparison traits are type-safe. This applies only when calling C memcmp via FFI.",
      "rejected_matches": []
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 21.17",
      "guideline_title": "Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters C90",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "yes",
        "adjusted_category": "required",
        "rationale_type": "direct_mapping",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_jep7p27kaqlp",
            "fls_title": "Unsafety",
            "category": 0,
            "score": 0.614,
            "reason": "Per fls_jd1inwz7ulyw 'Dereferencing a value of a raw pointer type' is an unsafe operation. Calling C string functions via FFI requires unsafe."
          },
          {
            "fls_id": "fls_5cm4gkt55hjh",
            "fls_title": "Dereference Expression",
            "category": 0,
            "score": 0.605,
            "reason": "Per fls_9wgldua1u8yt 'It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.' C string overruns create dangling pointer access."
          },
          {
            "fls_id": "fls_p090c5oTnElW",
            "fls_title": "Simple C String Literals",
            "category": 0,
            "score": 0.653,
            "reason": "FLS defines C string literals with null termination. Understanding C string semantics is relevant when interfacing via FFI."
          },
          {
            "fls_id": "fls_ppd1xwve3tr7",
            "fls_title": "Raw Pointer Types",
            "category": 0,
            "score": 0.55,
            "reason": "Per fls_rpbhr0xukbx9 'A raw pointer type is an indirection type without validity guarantees.' Raw pointers are needed for C string interop."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 1,
        "notes": "MISRA Rule 21.17 prevents buffer overflows from C string functions (strcpy, strcat, etc.). In Rust, these functions are only accessible via unsafe FFI. The rule applies when using extern C to call C string handling functions."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "rust_prevents",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_4agmmu5al6gt",
            "fls_title": "Str Type",
            "category": 0,
            "score": 0.53,
            "reason": "Per fls_wlnoq1qoq2kr 'Str is a sequence type that represents a slice of 8-bit unsigned bytes.' Rust strings carry length information and are bounds-checked."
          },
          {
            "fls_id": "fls_a14slch83hzn",
            "fls_title": "Borrowing",
            "category": 0,
            "score": 0.486,
            "reason": "Rust's borrow checker ensures string references remain valid for their lifetime, preventing dangling pointer access."
          },
          {
            "fls_id": "fls_sxcr4aa098i6",
            "fls_title": "Indexing Expressions",
            "category": 0,
            "score": 0.624,
            "reason": "Per fls_sb2b8gszzaxq 'The type of the indexed operand shall implement the core::ops::Index trait.' Rust indexing is bounds-checked at runtime."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 1,
        "notes": "Safe Rust cannot call C string functions - all FFI requires unsafe. Rust's &str and String types carry length information and all access is bounds-checked. Buffer overflows like those possible with C strcpy/strcat are prevented by the type system and runtime checks."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 21.18",
      "guideline_title": "The size_t argument passed to any function in <string.h> shall have an appropriate value C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "C's string.h functions with size_t can have buffer overflow issues. Rust slices carry their length and prevent out-of-bounds access. This applies only when calling C string functions via FFI.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 21.19",
      "guideline_title": "The pointers returned by the Standard Library functions localeconv, getenv, setlocale or strerror shall only be used as if they have pointer to const-qualified type C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "C's localeconv/getenv/setlocale return pointers that can be invalidated. Rust's std::env functions return owned Strings. This applies only when calling C locale functions via FFI.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 21.20",
      "guideline_title": "The pointer returned by the Standard Library functions asctime, ctime, gmtime, localtime, localeconv, getenv, setlocale or strerror shall not be used following a subsequent call to the same function",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "C's strtok uses internal static state which is not thread-safe. Rust has no equivalent; String::split returns an iterator. This applies only when calling C strtok via FFI.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 21.21",
      "guideline_title": "The Standard Library function system of <stdlib.h> shall not be used C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "C's system() spawns a shell which is a security risk. Rust's std::process::Command allows explicit command execution without shell. This applies only when calling C system() via FFI.",
      "rejected_matches": []
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 21.22",
      "guideline_title": "All operand arguments to any type-generic macros declared in <tgmath.h> shall have an appropriate essential type",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_dw33yt5g6m0k",
            "fls_title": "Type Coercion",
            "category": 0,
            "score": 0.87,
            "reason": "Rust type coercion is limited and explicit - no implicit integer-to-float"
          },
          {
            "fls_id": "fls_1qhsun1vyarz",
            "fls_title": "Type Cast Expressions",
            "category": 0,
            "score": 0.66,
            "reason": "Type conversions require explicit as casts"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no tgmath.h. Type conversions are explicit. Arithmetic requires same-type operands."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_exe4zodlwfez",
            "fls_title": "Type Unification",
            "category": 0,
            "score": 0.66,
            "reason": "Type unification requires compatible types - no implicit integer-to-float"
          },
          {
            "fls_id": "fls_ltioqbhl14g0",
            "fls_title": "Type Cast Expressions",
            "category": -2,
            "score": 0.68,
            "reason": "Type casts are explicit and require as keyword"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust has no tgmath.h. Type unification requires same types. Conversions are explicit with as."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 21.23",
      "guideline_title": "All operand arguments to any multi-argument type-generic macros declared in <tgmath.h> shall have the same standard type",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_1k9mkv7rbezi",
            "fls_title": "Arithmetic Expressions",
            "category": 0,
            "score": 0.67,
            "reason": "Arithmetic uses trait bounds - no implicit common type conversion"
          },
          {
            "fls_id": "fls_hrml95g2txcj",
            "fls_title": "Arithmetic Expressions - Mul trait",
            "category": -2,
            "score": 0.59,
            "reason": "Mul trait requires explicit RHS type - mismatched types fail to compile"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Rust has no tgmath.h. Binary operators use traits with explicit type bounds. Mismatched types are compile errors."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_sLCBZ3vG1AWs",
            "fls_title": "Type Inference - Numeric",
            "category": -2,
            "score": 0.65,
            "reason": "Numeric expressions require same types for both operands - unification enforces this"
          },
          {
            "fls_id": "fls_x2cw7g8g56f8",
            "fls_title": "Float Literals - Static Error",
            "category": -2,
            "score": 0.66,
            "reason": "Type mismatches result in static (compile) errors, not runtime UB"
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust requires same types for binary operators. Mismatched types are compile errors, not undefined behavior."
      }
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 21.24",
      "guideline_title": "The random number generator functions of <stdlib.h> shall not be used",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "C's rand/srand are not cryptographically secure and use global state. Rust's rand crate provides thread-safe, seedable RNGs. This applies only when calling C random functions via FFI.",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "rust_alternative"
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 21.25",
      "guideline_title": "All memory synchronization operations shall be executed in sequentially consistent order C11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_vyc9vcuamlph",
          "category": 0,
          "fls_title": "Atomics",
          "score": 0.61,
          "reason": "Per FLS fls_3pjla9s93mhd: 'An atomic type is a type defined in module core::sync::atomic. [Atomic type]s provide primitive shared-memory communication between threads.' This directly addresses MISRA's memory synchronization concerns."
        },
        {
          "fls_id": "fls_isypweqewe78",
          "category": -4,
          "fls_title": "Concurrency (UB)",
          "score": 0.45,
          "reason": "Per FLS: 'It is undefined behavior if two or more threads engage in a data race.' Rust's atomics prevent data races when used correctly."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "Memory synchronization operations in C11 map to Rust's atomics. Rust's core::sync::atomic provides atomic types with ordering guarantees.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 21.26",
      "guideline_title": "The Standard Library function mtx_timedlock() shall only be invoked on mutex objects of appropriate mutex type C11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "C11's mtx_timedlock() has no standard Rust equivalent. Rust's std::sync::Mutex doesn't support timed locking. parking_lot crate provides timed locking. This applies only when calling C mtx_timedlock via FFI.",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "no_equivalent"
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 22.1",
      "guideline_title": "All resources obtained dynamically by means of Standard Library functions shall be explicitly released",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "required",
      "misra_rust_comment": "applies to resources acquired through FFI only",
      "confidence": "medium",
      "notes": "Resource release maps directly to Rust's RAII/Drop semantics. In safe Rust, resources are automatically released when values go out of scope. When using C resources via FFI, manual management in unsafe code is required.",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_4jiw35pan7vn",
          "category": 0,
          "fls_title": "Destruction",
          "score": 0.7,
          "reason": "Per FLS fls_e7ucq87s806d: 'Destruction is the process of recovering resources associated with a value as it goes out of scope.' This is Rust's RAII mechanism."
        },
        {
          "fls_id": "fls_u2mzjgiwbkz0",
          "category": 0,
          "fls_title": "Destructors",
          "score": 0.72,
          "reason": "Per FLS fls_wzuwapjqtyyy: 'Dropping a value is the act of invoking the destructor of the related type.' The Drop trait ensures resources are released."
        },
        {
          "fls_id": "fls_rm4ncoopcdvj",
          "category": 0,
          "fls_title": "Drop Scopes",
          "score": 0.65,
          "reason": "Per FLS fls_7uav7vkcv4pz: 'A drop scope is a region of program text that governs the dropping of [value]s.' Drop scopes ensure deterministic resource cleanup."
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "direct_mapping"
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 22.2",
      "guideline_title": "A block of memory shall only be freed if it was allocated by means of a Standard Library function C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_svkx6szhr472",
          "category": 0,
          "fls_title": "Ownership",
          "score": 0.7,
          "reason": "Per FLS fls_ze0u9gfylmhn: 'A value shall have only one owner.' This prevents double-free by ensuring single ownership."
        },
        {
          "fls_id": "fls_9wgldua1u8yt",
          "category": -4,
          "fls_title": "Dereference Expression (UB)",
          "score": 0.63,
          "reason": "Per FLS: 'It is undefined behavior to dereference a raw pointer that is either dangling or unaligned.' Dereferencing freed memory is UB."
        }
      ],
      "fls_rationale_type": "direct_mapping",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "Double-free prevention maps to Rust's ownership model. In safe Rust, each value has exactly one owner and is dropped exactly once. When using C memory via FFI, this rule applies to raw pointer management.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 22.3",
      "guideline_title": "The same file shall not be open for read and write access at the same time on different streams C90",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "C FILE* simultaneous read/write streams have no Rust equivalent. Rust's std::fs::File uses separate read/write handles. This applies only when calling C file functions via FFI.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 22.4",
      "guideline_title": "There shall be no attempt to write to a stream which has been opened as read-only",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "C FILE* read-only stream handling has no Rust equivalent. Rust's type system enforces read vs write at compile time. This applies only when calling C file functions via FFI.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 22.5",
      "guideline_title": "A pointer to a FILE object shall not be dereferenced",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "C FILE* is an opaque type that should not be dereferenced. Rust has no equivalent; File handles are opaque. This applies only when calling C file functions via FFI.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 22.6",
      "guideline_title": "The value of a pointer to a FILE shall not be used after the associated stream has been closed C99",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "C FILE* pointer becomes invalid after fclose. Rust's ownership prevents use-after-close. This applies only when calling C file functions via FFI.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 22.7",
      "guideline_title": "The macro EOF shall only be compared with the unmodified return value from any Standard Library function capable of returning EOF",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "C's EOF macro has no Rust equivalent. Rust uses Result/Option for error/end-of-file. This applies only when calling C file functions via FFI.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 22.8",
      "guideline_title": "The value of errno shall be set to zero prior to a call to an errno- setting-function",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "disapplied",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "C's errno has no Rust equivalent. Rust uses Result for error handling. This applies only when calling C functions that set errno via FFI. Updated: Rust's Result/Option provide type-safe error handling as an alternative to errno.",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_dzq9cdz4ibsz",
          "category": 0,
          "fls_title": "Exceptions and Errors",
          "score": 0.55,
          "reason": "Per FLS fls_vsk4vhnuiyyz: 'The Rust programming language lacks exceptions and exception handlers. Instead, the language uses the following tiered error handling scheme.' Per FLS fls_ckeitwiv326r: 'The result of a possibly erroneous computation is usually represented using enum core::result::Result.' Result/Option are Rust's type-safe alternative to C's errno mechanism."
        },
        {
          "fls_id": "fls_pocsh1neugpc",
          "category": 0,
          "fls_title": "Error Propagation Expression",
          "score": 0.57,
          "reason": "Per FLS fls_8q59wbumrt5s: 'An error propagation expression is an expression that either evaluates to a value of its operand or returns a value to the enclosing control flow boundary.' The `?` operator provides structured error propagation, replacing ad-hoc errno checking."
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "rust_alternative"
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 22.9",
      "guideline_title": "The value of errno shall be tested against zero after calling an errno- setting-function",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "disapplied",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "C's errno checking has no Rust equivalent. Rust uses Result for error handling. This applies only when calling C functions that set errno via FFI. Updated: Rust's Result/Option provide type-safe error handling as an alternative to errno.",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_dzq9cdz4ibsz",
          "category": 0,
          "fls_title": "Exceptions and Errors",
          "score": 0.55,
          "reason": "Per FLS fls_vsk4vhnuiyyz: 'The Rust programming language lacks exceptions and exception handlers. Instead, the language uses the following tiered error handling scheme.' Per FLS fls_ckeitwiv326r: 'The result of a possibly erroneous computation is usually represented using enum core::result::Result.' Result/Option are Rust's type-safe alternative to C's errno mechanism."
        },
        {
          "fls_id": "fls_pocsh1neugpc",
          "category": 0,
          "fls_title": "Error Propagation Expression",
          "score": 0.57,
          "reason": "Per FLS fls_8q59wbumrt5s: 'An error propagation expression is an expression that either evaluates to a value of its operand or returns a value to the enclosing control flow boundary.' The `?` operator provides structured error propagation, replacing ad-hoc errno checking."
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "rust_alternative"
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 22.10",
      "guideline_title": "The value of errno shall only be tested when the last function to be called was an errno-setting-function",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "disapplied",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "C's errno value semantics have no Rust equivalent. Rust uses Result for error handling. This applies only when calling C functions that set errno via FFI. Updated: Rust's Result/Option provide type-safe error handling as an alternative to errno.",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_dzq9cdz4ibsz",
          "category": 0,
          "fls_title": "Exceptions and Errors",
          "score": 0.55,
          "reason": "Per FLS fls_vsk4vhnuiyyz: 'The Rust programming language lacks exceptions and exception handlers. Instead, the language uses the following tiered error handling scheme.' Per FLS fls_ckeitwiv326r: 'The result of a possibly erroneous computation is usually represented using enum core::result::Result.' Result/Option are Rust's type-safe alternative to C's errno mechanism."
        },
        {
          "fls_id": "fls_pocsh1neugpc",
          "category": 0,
          "fls_title": "Error Propagation Expression",
          "score": 0.57,
          "reason": "Per FLS fls_8q59wbumrt5s: 'An error propagation expression is an expression that either evaluates to a value of its operand or returns a value to the enclosing control flow boundary.' The `?` operator provides structured error propagation, replacing ad-hoc errno checking."
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "rust_alternative"
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 22.11",
      "guideline_title": "A thread that was previously either joined or detached shall not be subsequently joined nor detached C11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "C11 thread join/detach semantics have no direct FLS equivalent. Rust's std::thread::JoinHandle ensures threads are joined. This applies only when calling C11 thread functions via FFI.",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_3v733mnewssy",
          "category": 0,
          "fls_title": "Concurrency",
          "score": 0.68,
          "reason": "Per FLS fls_opt7v0mopxc8: 'The Rust programming language provides features for concurrent programming without [data race]s.' Per FLS fls_isypweqewe78 (UB): 'It is undefined behavior if two or more threads engage in a data race.' This chapter defines Rust's concurrency model which replaces C11 threading primitives."
        },
        {
          "fls_id": "fls_eiw4by8z75di",
          "category": 0,
          "fls_title": "Send and Sync",
          "score": 0.67,
          "reason": "Per FLS fls_4ypqdehn7b0v: 'A send type shall have [value]s that are safe to transfer across thread boundaries.' Per FLS fls_zgemofbs5q2x: 'A sync type shall have [value]s that are allowed to be shared across multiple threads at any given time without incurring data races.' These traits enforce thread-safety at compile time, replacing runtime checks needed with C11 threading."
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "no_equivalent"
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 22.12",
      "guideline_title": "Thread objects, thread synchronization objects, and thread-specific storage pointers shall only be accessed by the appropriate Standard Library functions C11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_eiw4by8z75di",
          "category": 0,
          "fls_title": "Send and Sync",
          "score": 0.55,
          "reason": "Per FLS fls_4ypqdehn7b0v: 'A send type shall have [value]s that are safe to transfer across thread boundaries.' This enforces safe cross-thread value transfer."
        },
        {
          "fls_id": "fls_3v733mnewssy",
          "category": 0,
          "fls_title": "Concurrency",
          "score": 0.68,
          "reason": "Per FLS fls_opt7v0mopxc8: 'The Rust programming language provides features for concurrent programming without [data race]s.' Per FLS fls_isypweqewe78 (UB): 'It is undefined behavior if two or more threads engage in a data race.' This chapter defines Rust's concurrency model which replaces C11 threading primitives."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "C11 thread object copying maps to Rust's Send/Sync traits. Rust's type system enforces thread-safety at compile time.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 22.13",
      "guideline_title": "Thread objects, thread synchronization objects and thread-specific storage pointers shall have appropriate storage duration C11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_rm4ncoopcdvj",
          "category": 0,
          "fls_title": "Drop Scopes",
          "score": 0.65,
          "reason": "Per FLS fls_7uav7vkcv4pz: 'A drop scope is a region of program text that governs the dropping of [value]s.' This ensures deterministic cleanup of thread objects."
        },
        {
          "fls_id": "fls_3v733mnewssy",
          "category": 0,
          "fls_title": "Concurrency",
          "score": 0.68,
          "reason": "Per FLS fls_opt7v0mopxc8: 'The Rust programming language provides features for concurrent programming without [data race]s.' Per FLS fls_isypweqewe78 (UB): 'It is undefined behavior if two or more threads engage in a data race.' This chapter defines Rust's concurrency model which replaces C11 threading primitives."
        },
        {
          "fls_id": "fls_eiw4by8z75di",
          "category": 0,
          "fls_title": "Send and Sync",
          "score": 0.67,
          "reason": "Per FLS fls_4ypqdehn7b0v: 'A send type shall have [value]s that are safe to transfer across thread boundaries.' Per FLS fls_zgemofbs5q2x: 'A sync type shall have [value]s that are allowed to be shared across multiple threads at any given time without incurring data races.' These traits enforce thread-safety at compile time, replacing runtime checks needed with C11 threading."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "C11 thread object destruction maps to Rust's Drop semantics. Rust's RAII ensures thread handles are properly cleaned up.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 22.14",
      "guideline_title": "Thread synchronization objects shall be initialized before being accessed C11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_3v733mnewssy",
          "category": 0,
          "fls_title": "Concurrency",
          "score": 0.68,
          "reason": "Per FLS fls_opt7v0mopxc8: 'The Rust programming language provides features for concurrent programming without [data race]s.' Per FLS fls_isypweqewe78 (UB): 'It is undefined behavior if two or more threads engage in a data race.' This chapter defines Rust's concurrency model which replaces C11 threading primitives."
        },
        {
          "fls_id": "fls_eiw4by8z75di",
          "category": 0,
          "fls_title": "Send and Sync",
          "score": 0.67,
          "reason": "Per FLS fls_4ypqdehn7b0v: 'A send type shall have [value]s that are safe to transfer across thread boundaries.' Per FLS fls_zgemofbs5q2x: 'A sync type shall have [value]s that are allowed to be shared across multiple threads at any given time without incurring data races.' These traits enforce thread-safety at compile time, replacing runtime checks needed with C11 threading."
        },
        {
          "fls_id": "fls_vyc9vcuamlph",
          "category": 0,
          "fls_title": "Atomics",
          "score": 0.68,
          "reason": "Per FLS fls_3pjla9s93mhd: 'An atomic type is a type defined in module core::sync::atomic. [Atomic type]s provide primitive shared-memory communication between threads.' Rust's atomics provide the synchronization primitives that correspond to C11 mutex and condition variable operations."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "required",
      "misra_rust_comment": "applies to creating synchronization objects before threads that use them",
      "confidence": "medium",
      "notes": "C11 thread synchronization object initialization has no direct FLS equivalent. Rust's Mutex/RwLock constructors ensure proper initialization. This applies only when using C11 sync primitives via FFI.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 22.15",
      "guideline_title": "Thread synchronization objects and thread-specific storage pointers shall not be destroyed until after all threads accessing them have terminated C11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_eiw4by8z75di",
          "category": 0,
          "fls_title": "Send and Sync",
          "score": 0.55,
          "reason": "Per FLS fls_zgemofbs5q2x: 'A sync type shall have [value]s that are allowed to be shared across multiple threads at any given time without incurring data races.'"
        },
        {
          "fls_id": "fls_3v733mnewssy",
          "category": 0,
          "fls_title": "Concurrency",
          "score": 0.68,
          "reason": "Per FLS fls_opt7v0mopxc8: 'The Rust programming language provides features for concurrent programming without [data race]s.' Per FLS fls_isypweqewe78 (UB): 'It is undefined behavior if two or more threads engage in a data race.' This chapter defines Rust's concurrency model which replaces C11 threading primitives."
        }
      ],
      "fls_rationale_type": "rust_alternative",
      "misra_rust_category": "required",
      "misra_rust_comment": "applies to releasing synchronization objects after threads that use them",
      "confidence": "medium",
      "notes": "C11 thread-specific storage copying maps to Rust's Send/Sync traits. Rust enforces thread-safety at compile time.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 22.16",
      "guideline_title": "All mutex objects locked by a thread shall be explicitly unlocked by the same thread C11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_3v733mnewssy",
          "category": 0,
          "fls_title": "Concurrency",
          "score": 0.68,
          "reason": "Per FLS fls_opt7v0mopxc8: 'The Rust programming language provides features for concurrent programming without [data race]s.' Per FLS fls_isypweqewe78 (UB): 'It is undefined behavior if two or more threads engage in a data race.' This chapter defines Rust's concurrency model which replaces C11 threading primitives."
        },
        {
          "fls_id": "fls_eiw4by8z75di",
          "category": 0,
          "fls_title": "Send and Sync",
          "score": 0.67,
          "reason": "Per FLS fls_4ypqdehn7b0v: 'A send type shall have [value]s that are safe to transfer across thread boundaries.' Per FLS fls_zgemofbs5q2x: 'A sync type shall have [value]s that are allowed to be shared across multiple threads at any given time without incurring data races.' These traits enforce thread-safety at compile time, replacing runtime checks needed with C11 threading."
        },
        {
          "fls_id": "fls_vyc9vcuamlph",
          "category": 0,
          "fls_title": "Atomics",
          "score": 0.68,
          "reason": "Per FLS fls_3pjla9s93mhd: 'An atomic type is a type defined in module core::sync::atomic. [Atomic type]s provide primitive shared-memory communication between threads.' Rust's atomics provide the synchronization primitives that correspond to C11 mutex and condition variable operations."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "C11 mutex unlock requirements have no direct FLS equivalent. Rust's MutexGuard uses RAII to ensure unlock on drop. This applies only when using C11 mutexes via FFI.",
      "rejected_matches": []
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 22.17",
      "guideline_title": "No thread shall unlock a mutex or call cnd_wait() or cnd_timedwait() for a mutex it has not locked before C11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "not_applicable",
      "misra_rust_category": "required",
      "misra_rust_comment": "only accessible through unsafe extern \u201cC\u201d",
      "confidence": "medium",
      "notes": "C11 mutex ownership for unlock/cnd_wait has no direct FLS equivalent. Rust's MutexGuard enforces ownership. This applies only when using C11 mutexes via FFI.",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_3v733mnewssy",
          "category": 0,
          "fls_title": "Concurrency",
          "score": 0.68,
          "reason": "Per FLS fls_opt7v0mopxc8: 'The Rust programming language provides features for concurrent programming without [data race]s.' Per FLS fls_isypweqewe78 (UB): 'It is undefined behavior if two or more threads engage in a data race.' This chapter defines Rust's concurrency model which replaces C11 threading primitives."
        },
        {
          "fls_id": "fls_eiw4by8z75di",
          "category": 0,
          "fls_title": "Send and Sync",
          "score": 0.67,
          "reason": "Per FLS fls_4ypqdehn7b0v: 'A send type shall have [value]s that are safe to transfer across thread boundaries.' Per FLS fls_zgemofbs5q2x: 'A sync type shall have [value]s that are allowed to be shared across multiple threads at any given time without incurring data races.' These traits enforce thread-safety at compile time, replacing runtime checks needed with C11 threading."
        },
        {
          "fls_id": "fls_vyc9vcuamlph",
          "category": 0,
          "fls_title": "Atomics",
          "score": 0.68,
          "reason": "Per FLS fls_3pjla9s93mhd: 'An atomic type is a type defined in module core::sync::atomic. [Atomic type]s provide primitive shared-memory communication between threads.' Rust's atomics provide the synchronization primitives that correspond to C11 mutex and condition variable operations."
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "no_equivalent"
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 22.18",
      "guideline_title": "Non-recursive mutexes shall not be recursively locked C11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "C11 non-recursive mutex rules have no direct FLS equivalent. Rust's Mutex is non-recursive by default and panics on relock. This applies only when using C11 mutexes via FFI.",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_3v733mnewssy",
          "category": 0,
          "fls_title": "Concurrency",
          "score": 0.68,
          "reason": "Per FLS fls_opt7v0mopxc8: 'The Rust programming language provides features for concurrent programming without [data race]s.' Per FLS fls_isypweqewe78 (UB): 'It is undefined behavior if two or more threads engage in a data race.' This chapter defines Rust's concurrency model which replaces C11 threading primitives."
        },
        {
          "fls_id": "fls_eiw4by8z75di",
          "category": 0,
          "fls_title": "Send and Sync",
          "score": 0.67,
          "reason": "Per FLS fls_4ypqdehn7b0v: 'A send type shall have [value]s that are safe to transfer across thread boundaries.' Per FLS fls_zgemofbs5q2x: 'A sync type shall have [value]s that are allowed to be shared across multiple threads at any given time without incurring data races.' These traits enforce thread-safety at compile time, replacing runtime checks needed with C11 threading."
        },
        {
          "fls_id": "fls_vyc9vcuamlph",
          "category": 0,
          "fls_title": "Atomics",
          "score": 0.68,
          "reason": "Per FLS fls_3pjla9s93mhd: 'An atomic type is a type defined in module core::sync::atomic. [Atomic type]s provide primitive shared-memory communication between threads.' Rust's atomics provide the synchronization primitives that correspond to C11 mutex and condition variable operations."
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "no_equivalent"
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 22.19",
      "guideline_title": "A condition variable shall be associated with at most one mutex object",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "direct",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "C11 condition variable association rules have no direct FLS equivalent. Rust's Condvar doesn't have this restriction. This applies only when using C11 condition variables via FFI.",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_3v733mnewssy",
          "category": 0,
          "fls_title": "Concurrency",
          "score": 0.68,
          "reason": "Per FLS fls_opt7v0mopxc8: 'The Rust programming language provides features for concurrent programming without [data race]s.' Per FLS fls_isypweqewe78 (UB): 'It is undefined behavior if two or more threads engage in a data race.' This chapter defines Rust's concurrency model which replaces C11 threading primitives."
        },
        {
          "fls_id": "fls_eiw4by8z75di",
          "category": 0,
          "fls_title": "Send and Sync",
          "score": 0.67,
          "reason": "Per FLS fls_4ypqdehn7b0v: 'A send type shall have [value]s that are safe to transfer across thread boundaries.' Per FLS fls_zgemofbs5q2x: 'A sync type shall have [value]s that are allowed to be shared across multiple threads at any given time without incurring data races.' These traits enforce thread-safety at compile time, replacing runtime checks needed with C11 threading."
        },
        {
          "fls_id": "fls_vyc9vcuamlph",
          "category": 0,
          "fls_title": "Atomics",
          "score": 0.68,
          "reason": "Per FLS fls_3pjla9s93mhd: 'An atomic type is a type defined in module core::sync::atomic. [Atomic type]s provide primitive shared-memory communication between threads.' Rust's atomics provide the synchronization primitives that correspond to C11 mutex and condition variable operations."
        }
      ],
      "rejected_matches": [],
      "fls_rationale_type": "no_equivalent"
    },
    {
      "schema_version": "1.0",
      "guideline_id": "Rule 22.20",
      "guideline_title": "Thread-specific storage pointers shall be created before being accessed C11",
      "guideline_type": "rule",
      "applicability_all_rust": "direct",
      "applicability_safe_rust": "partial",
      "accepted_matches": [
        {
          "fls_id": "fls_yztwtek0y34v",
          "category": 0,
          "fls_title": "External Functions",
          "score": 1.0,
          "reason": "Per FLS fls_v24ino4hix3m: 'An external function is an unchecked import of a foreign function.' Per FLS fls_l88r9fj82650: 'An external function shall be invoked from an unsafe context.' When calling C library functions via FFI, they must be declared as external functions and called from unsafe context."
        },
        {
          "fls_id": "fls_tmoh3y9oyqsy",
          "category": 0,
          "fls_title": "External Blocks",
          "score": 1.0,
          "reason": "Per FLS fls_4dje9t5y2dia: 'An external block is a construct that provides the declarations of [external function]s and [external static]s as unchecked imports.' C library functions are declared in external blocks."
        },
        {
          "fls_id": "fls_jep7p27kaqlp",
          "category": 0,
          "fls_title": "Unsafety",
          "score": 1.0,
          "reason": "Per FLS fls_ljocmnaz2m49: 'Calling an unsafe function' is an unsafe operation. Per fls_ybnpe7ppq1vh: 'An unsafe operation shall be used only within an unsafe context.' All C library functions called via FFI require unsafe context."
        },
        {
          "fls_id": "fls_3v733mnewssy",
          "category": 0,
          "fls_title": "Concurrency",
          "score": 0.68,
          "reason": "Per FLS fls_opt7v0mopxc8: 'The Rust programming language provides features for concurrent programming without [data race]s.' Per FLS fls_isypweqewe78 (UB): 'It is undefined behavior if two or more threads engage in a data race.' This chapter defines Rust's concurrency model which replaces C11 threading primitives."
        },
        {
          "fls_id": "fls_eiw4by8z75di",
          "category": 0,
          "fls_title": "Send and Sync",
          "score": 0.67,
          "reason": "Per FLS fls_4ypqdehn7b0v: 'A send type shall have [value]s that are safe to transfer across thread boundaries.' Per FLS fls_zgemofbs5q2x: 'A sync type shall have [value]s that are allowed to be shared across multiple threads at any given time without incurring data races.' These traits enforce thread-safety at compile time, replacing runtime checks needed with C11 threading."
        }
      ],
      "fls_rationale_type": "no_equivalent",
      "misra_rust_category": "required",
      "confidence": "medium",
      "notes": "C11 thread-specific storage creation timing has no direct FLS equivalent. Rust's thread_local! macro handles this at compile time. This applies only when using C11 TLS via FFI.",
      "rejected_matches": []
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 23.1",
      "guideline_title": "A generic selection should only be expanded from a macro",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_vhpwge5123cm",
            "fls_title": "Generic Parameters",
            "category": 0,
            "score": 0.72,
            "reason": "Rust uses parametric polymorphism with generic parameters and trait bounds, not C11 _Generic type selection. Per FLS: 'A generic parameter is a placeholder for a constant, a lifetime, or a type whose value is supplied at compile time.'"
          },
          {
            "fls_id": "fls_y2k5paj8m8ug",
            "fls_title": "Generics",
            "category": 0,
            "score": 0.66,
            "reason": "Rust's generics chapter explains the fundamentally different approach - monomorphization and trait bounds rather than expression-level type dispatch."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "C11 _Generic provides expression-level type selection. Rust has no equivalent - it uses generics (compile-time monomorphization) and trait objects (runtime dispatch) instead. The concept of 'expanding from a macro for abstraction' has no parallel since the underlying mechanism doesn't exist."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_vhpwge5123cm",
            "fls_title": "Generic Parameters",
            "category": 0,
            "score": 0.72,
            "reason": "Safe Rust uses parametric polymorphism via generics and trait bounds. No _Generic equivalent exists."
          },
          {
            "fls_id": "fls_3xqobbu7wfsf",
            "fls_title": "Impl Trait Types",
            "category": 0,
            "score": 0.72,
            "reason": "Impl trait provides type abstraction in safe Rust without _Generic-style selection."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust achieves type-based polymorphism through generics, impl Trait, and trait objects - all fundamentally different from C11 _Generic."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 23.2",
      "guideline_title": "A generic selection that is not expanded from a macro shall not contain potentially evaluated expressions in its association list",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_utuu8mdbuyxm",
            "fls_title": "Generic Arguments",
            "category": 0,
            "score": 0.64,
            "reason": "Per FLS: 'A generic argument supplies a static input for an associated trait type or a generic parameter.' Generic arguments are types/lifetimes/const values, not evaluated expressions like in C11 _Generic associations."
          },
          {
            "fls_id": "fls_d4vdvpihoeb1",
            "fls_title": "Generic Arguments - Type Arguments",
            "category": 0,
            "score": 0.77,
            "reason": "Per FLS: 'A type argument is a generic argument that supplies the type of a type parameter.' This is purely a type, not an expression that gets evaluated."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "C11 _Generic has association lists with potentially evaluated expressions. Rust generic arguments are static type/lifetime/const inputs resolved at compile time without expression evaluation in type positions."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_utuu8mdbuyxm",
            "fls_title": "Generic Arguments",
            "category": 0,
            "score": 0.64,
            "reason": "Safe Rust generic arguments are compile-time type/const inputs, not evaluated expressions."
          },
          {
            "fls_id": "fls_lv7w7aalpwm5",
            "fls_title": "Type Inference",
            "category": 0,
            "score": 0.62,
            "reason": "Type inference in safe Rust operates on types, not on evaluating expressions in type positions."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust generics use type inference and monomorphization - type arguments are inferred or specified, never evaluated as expressions."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 23.3",
      "guideline_title": "A generic selection should contain at least one non-default association",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_jeoas4n6su4",
            "fls_title": "Trait and Lifetime Bounds",
            "category": 0,
            "score": 0.6,
            "reason": "Per FLS: 'A trait bound is a bound that imposes a constraint on the traits of generic parameters.' Rust uses explicit trait bounds - there is no 'default association' fallback mechanism like in C11 _Generic."
          },
          {
            "fls_id": "fls_vhpwge5123cm",
            "fls_title": "Generic Parameters",
            "category": 0,
            "score": 0.66,
            "reason": "Rust generic parameters require explicit type arguments or inference - no default type selection mechanism exists."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "C11 _Generic has 'default' associations as a fallback. Rust has no equivalent - trait bounds must be satisfied or compilation fails. Type parameter defaults exist but serve a different purpose (convenience, not fallback selection)."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_jeoas4n6su4",
            "fls_title": "Trait and Lifetime Bounds",
            "category": 0,
            "score": 0.6,
            "reason": "Safe Rust trait bounds are explicit constraints - no default fallback like C11 _Generic default association."
          },
          {
            "fls_id": "fls_5g508z6c7q5f",
            "fls_title": "Trait and Lifetime Bounds - bound constraint",
            "category": 0,
            "score": 0.64,
            "reason": "Per FLS: 'A bound imposes a constraint on a generic parameter by limiting the set of possible generic substitutions.' This is explicit constraint, not default-based selection."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust generics use explicit trait bounds that must be satisfied. No default association or fallback mechanism exists."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 23.4",
      "guideline_title": "A generic association shall list an appropriate type",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_i7g2n7hfg3ch",
            "fls_title": "Generic Conformance",
            "category": 0,
            "score": 0.6,
            "reason": "Per FLS: 'All constant arguments, lifetime arguments, and type arguments have a corresponding generic parameter.' Rust enforces type conformance at compile time - no _Generic association mechanism exists."
          },
          {
            "fls_id": "fls_ws1h57fk1mkh",
            "fls_title": "Generic Conformance - type argument conformant",
            "category": 0,
            "score": 0.66,
            "reason": "Per FLS: 'A type argument is conformant with a type parameter when the type of the type argument fulfills the required trait bounds.' Rust validates types statically, preventing invalid type usage."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "C11 _Generic has restrictions on incomplete types, function types, void, and variably modified types in associations. Rust has no _Generic - its type system enforces well-formedness through Sized bounds and compile-time type checking."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_i7g2n7hfg3ch",
            "fls_title": "Generic Conformance",
            "category": 0,
            "score": 0.6,
            "reason": "Safe Rust enforces type conformance for all generic arguments - no incomplete or inappropriate types can be used."
          },
          {
            "fls_id": "fls_hidfwkwr2r73",
            "fls_title": "Generic Parameters - Sized bound",
            "category": 0,
            "score": 0.6,
            "reason": "Per FLS: 'A type parameter has an implicit core::marker::Sized bound.' This prevents using unsized types where inappropriate."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust enforces type well-formedness through Sized bounds and compile-time validation. No _Generic or association mechanism exists."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 23.5",
      "guideline_title": "A generic selection should not depend on implicit pointer type conversion",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_dw33yt5g6m0k",
            "fls_title": "Type Coercion",
            "category": 0,
            "score": 0.65,
            "reason": "Per FLS: 'Type coercion is an implicit operation that changes the type of a value.' Rust's coercion rules are explicit and limited - no array-to-pointer decay. No _Generic mechanism exists."
          },
          {
            "fls_id": "fls_ulcdetwp6x96",
            "fls_title": "Type Coercion - function item to pointer",
            "category": 0,
            "score": 0.62,
            "reason": "Rust function items require explicit coercion to function pointers, unlike C's implicit function-to-pointer decay."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "C has implicit array-to-pointer and function-to-pointer decay that can affect _Generic type selection. Rust has no _Generic and no such implicit decay - arrays are arrays, slices are slices, function items are distinct from function pointers."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_dw33yt5g6m0k",
            "fls_title": "Type Coercion",
            "category": 0,
            "score": 0.54,
            "reason": "Safe Rust coercion rules are well-defined and do not include C-style pointer decay."
          },
          {
            "fls_id": "fls_jte6n2js32af",
            "fls_title": "Type Coercion - array to slice",
            "category": 0,
            "score": 0.61,
            "reason": "Per FLS: 'The source type is array type [T; N] and the target type is slice type [T].' This is array-to-slice coercion, not C-style decay to raw pointer."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust has no implicit pointer decay. Array-to-slice coercion exists but is distinct from C's array-to-pointer decay and occurs in specific coercion contexts."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 23.6",
      "guideline_title": "The controlling expression of a generic selection shall have an essential type that matches one of the selections",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_e5td0fa92fay",
            "fls_title": "Match Expressions",
            "category": 0,
            "score": 0.64,
            "reason": "Rust's match expressions require exhaustive pattern coverage for the subject expression's type. This is value-based pattern matching, not C11 _Generic's type-based selection."
          },
          {
            "fls_id": "fls_e02um1gb89d0",
            "fls_title": "Match Expressions - exhaustive",
            "category": 0,
            "score": 0.68,
            "reason": "Per FLS: 'The patterns of all match arms taken together shall exhaustively match the subject expression's type.' Rust enforces exhaustiveness, preventing the undefined behavior _Generic can cause."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "C11 _Generic has a controlling expression that selects among type associations. Rust has no such mechanism. Match expressions match values, not types. Generics require satisfying trait bounds at compile time."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_e5td0fa92fay",
            "fls_title": "Match Expressions",
            "category": 0,
            "score": 0.64,
            "reason": "Safe Rust match expressions are exhaustive - all patterns must cover the subject type."
          },
          {
            "fls_id": "fls_ws1h57fk1mkh",
            "fls_title": "Generic Conformance - type argument conformant",
            "category": 0,
            "score": 0.66,
            "reason": "Per FLS: 'A type argument is conformant with a type parameter when the type of the type argument fulfills the required trait bounds.' Type arguments must satisfy bounds at compile time."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust enforces exhaustive pattern matching and trait bound satisfaction. No _Generic-style type selection exists."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 23.7",
      "guideline_title": "A generic selection that is expanded from a macro should evaluate its argument only once",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_wjldgtio5o75",
            "fls_title": "Macro Expansion",
            "category": 0,
            "score": 0.63,
            "reason": "Per FLS: 'Macro expansion is the process of statically executing a macro invocation and replacing it with the produced output.' Rust macros are textual substitution with no _Generic-specific concerns."
          },
          {
            "fls_id": "fls_ym00b6ewf4n3",
            "fls_title": "Macro Transcription",
            "category": 0,
            "score": 0.56,
            "reason": "Rust macro transcription substitutes metavariables. Multiple-evaluation of macro arguments is a general hygiene concern, not _Generic-specific."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "C11's concern is _Generic controlling expressions evaluated multiple times when wrapped in macros. Rust has no _Generic. General macro multiple-evaluation is a separate concern not covered by this specific rule."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_wjldgtio5o75",
            "fls_title": "Macro Expansion",
            "category": 0,
            "score": 0.63,
            "reason": "Safe Rust macros undergo textual expansion without _Generic-style type selection."
          },
          {
            "fls_id": "fls_xlfo7di0gsqz",
            "fls_title": "Hygiene",
            "category": 0,
            "score": 0.53,
            "reason": "Per FLS: 'Hygiene is a property of macros and identifiers that appear within them.' Rust's hygiene system addresses name scoping, not multiple evaluation like _Generic concerns."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust has no _Generic mechanism. Macro hygiene addresses name scoping. Multiple-evaluation of macro arguments is a separate general concern."
      }
    },
    {
      "schema_version": "2.0",
      "guideline_id": "Rule 23.8",
      "guideline_title": "A default association shall appear as either the first or the last association of a generic selection",
      "guideline_type": "rule",
      "all_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_e5td0fa92fay",
            "fls_title": "Match Expressions",
            "category": 0,
            "score": 0.54,
            "reason": "Per FLS: 'Match arm selection happens in declarative order.' Rust match has ordered arms, but this is value pattern matching, not C11 _Generic type associations."
          },
          {
            "fls_id": "fls_8dba4o5qg8js",
            "fls_title": "Match Expressions - declarative order",
            "category": 0,
            "score": 0.54,
            "reason": "Match arm evaluation is declarative order. Wildcard _ patterns are idiomatically last but this is convention for value matching, not type selection."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "C11 _Generic has 'default' type associations with positioning requirements. Rust has no _Generic. Match expressions have wildcards but these are value pattern matches, not type associations. The rule's concern about association ordering has no equivalent."
      },
      "safe_rust": {
        "applicability": "no",
        "adjusted_category": "n_a",
        "rationale_type": "no_equivalent",
        "confidence": "high",
        "accepted_matches": [
          {
            "fls_id": "fls_e5td0fa92fay",
            "fls_title": "Match Expressions",
            "category": 0,
            "score": 0.54,
            "reason": "Safe Rust match expressions have declarative ordering for value patterns, not type association ordering."
          },
          {
            "fls_id": "fls_l21tjqjkkaa0",
            "fls_title": "Associated Items",
            "category": 0,
            "score": 0.53,
            "reason": "Rust's associated types are trait-related and have no 'default' positioning concept like C11 _Generic associations."
          }
        ],
        "rejected_matches": [],
        "verified": true,
        "verified_by_session": 2,
        "notes": "Safe Rust has no _Generic. Associated types exist but are not type associations with default positioning. Match wildcards are value pattern matching."
      }
    }
  ]
}
