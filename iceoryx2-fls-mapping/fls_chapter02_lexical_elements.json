{
  "chapter": 2,
  "title": "Lexical Elements",
  "fls_url": "https://rust-lang.github.io/fls/lexical-elements.html",
  "fls_id": "fls_411up5z0b6n6",
  "repository": "eclipse-iceoryx/iceoryx2",
  "version": "0.8.0",
  "analysis_date": "2025-12-30",
  "version_changes": {
    "from_version": "0.7.0",
    "to_version": "0.8.0",
    "summary": "Directory structure reorganized (iceoryx2-bb-* -> iceoryx2-bb/*), MSRV increased to 1.83, union types now supported in ZeroCopySend",
    "key_changes": [
      "Union keyword now used in FFI layer for C bindings",
      "C string literals usage expanded",
      "no_std support added - explicit core/alloc imports"
    ]
  },
  "summary": "Analysis of lexical elements used in iceoryx2 including character sets, identifiers, literals, punctuation, and keywords. The codebase uses ASCII-only identifiers and demonstrates extensive use of integer literals with type suffixes for safety-critical code.",
  "statistics": {},
  "sections": {
    "character_set": {
      "fls_section": "2.1",
      "fls_ids": [
        "fls_2i089jvv8j5g"
      ],
      "description": "Character Set",
      "status": "demonstrated",
      "findings": {
        "files_with_non_ascii": 0,
        "unicode_usage": "Production code uses ASCII-only identifiers and strings. Unicode characters appear only in examples and documentation."
      },
      "samples": [],
      "count": null,
      "count_methodology": "Conceptual - all Rust source uses UTF-8",
      "samples_waiver": {
        "reason": "conceptual_section",
        "explanation": "Character set is an inherent property of all Rust source files (UTF-8 encoded). Production code uses ASCII subset only.",
        "approved_by": "pete.levasseur",
        "date": "2025-12-30"
      }
    },
    "lexical_elements_separators_and_punctuation": {
      "fls_section": "2.2",
      "fls_ids": [
        "fls_fgnllgz5k3e6"
      ],
      "description": "Lexical Elements, Separators, and Punctuation",
      "status": "demonstrated",
      "findings": {
        "path_separator_colons": 37919,
        "fat_arrow": 5118,
        "thin_arrow_return": 7138,
        "question_mark_operator": 3443
      },
      "samples": [],
      "count": null,
      "count_methodology": "Conceptual - punctuation is pervasive",
      "samples_waiver": {
        "reason": "conceptual_section",
        "explanation": "This section describes an abstract concept not directly mappable to concrete code patterns",
        "approved_by": "automated",
        "date": "2025-12-30"
      }
    },
    "identifiers": {
      "fls_section": "2.3",
      "fls_ids": [
        "fls_21vnag69kbwe"
      ],
      "description": "Identifiers",
      "status": "demonstrated",
      "findings": {
        "screaming_snake_case_constants": 2833,
        "underscore_prefix_unused": 983,
        "phantom_data_markers": 256
      },
      "samples": [
        {
          "file": "iceoryx2-cal/src/static_storage/file.rs",
          "line": [66],
          "code": "const FINAL_PERMISSIONS: Permission = Permission::OWNER_READ;",
          "purpose": "SCREAMING_SNAKE_CASE constant identifier following Rust naming conventions for compile-time values"
        },
        {
          "file": "iceoryx2/src/sample.rs",
          "line": [49, 50, 51, 52, 53],
          "code": "pub struct Sample<\n    Service: crate::service::Service,\n    Payload: Debug + ?Sized + ZeroCopySend,\n    UserHeader: ZeroCopySend,\n> {",
          "purpose": "PascalCase struct identifier 'Sample' with generic type parameters following Rust naming conventions"
        },
        {
          "file": "iceoryx2/src/port/notifier.rs",
          "line": [71],
          "code": "pub enum NotifierCreateError {",
          "purpose": "PascalCase enum identifier for error types, with descriptive naming indicating creation failure scenarios"
        }
      ],
      "count": 6857
    },
    "literals": {
      "fls_section": "2.4",
      "fls_ids": [
        "fls_nrkd5wpi64oo"
      ],
      "description": "Literals",
      "status": "demonstrated",
      "findings": {
        "byte_string_literals": 739,
        "hex_literals": 48,
        "octal_literals": 58,
        "binary_literals": 4,
        "boolean_literals": 2485
      },
      "samples": [
        {
          "file": "iceoryx2-pal/posix/src/stub/constants.rs",
          "line": [
            169,
            170,
            171
          ],
          "code": "pub const S_IFMT: mode_t = 0o0170000;\npub const S_IFIFO: mode_t = 0o0010000;",
          "purpose": "Octal literals for POSIX file mode constants"
        }
      ],
      "subsections": {
        "byte_literals": {
          "fls_section": "2.4.1",
          "fls_ids": [
            "fls_2ifjqwnw03ms"
          ],
          "description": "Byte Literals",
          "status": "demonstrated",
          "findings": {
            "count": 110,
            "description": "Byte literals (b'x') represent ASCII characters as u8 values. Used extensively for character manipulation and string building.",
            "patterns": [
              "ASCII character constants",
              "String building operations",
              "Escape sequence handling"
            ]
          },
          "samples": [
            {
              "file": "iceoryx2-bb/container/src/string/utils.rs",
              "line": [40, 41, 42],
              "code": "b'\\t' => vec![b'\\\\', b't'].into_iter(),\nb'\\r' => vec![b'\\\\', b'r'].into_iter(),\nb'\\n' => vec![b'\\\\', b'n'].into_iter(),",
              "purpose": "Byte literals for escape sequence handling in string processing, converting control characters to escaped representations"
            },
            {
              "file": "iceoryx2-pal/configuration/src/lib.rs",
              "line": [37],
              "code": "pub const PATH_SEPARATOR: u8 = b'/';",
              "purpose": "Byte literal defining platform path separator constant as u8 for efficient path manipulation"
            },
            {
              "file": "iceoryx2-bb/container/src/semantic_string.rs",
              "line": [44],
              "code": "matches!(string[0], b'-' | b'0'..=b'9')",
              "purpose": "Byte literals in pattern matching for semantic string validation, checking if first character is digit or hyphen"
            }
          ],
          "count": 157
        },
        "byte_string_literals": {
          "fls_section": "2.4.2",
          "fls_ids": [
            "fls_fqaffyrjob7v"
          ],
          "description": "Byte String Literals",
          "status": "demonstrated",
          "findings": {
            "count": 743,
            "description": "Byte string literals (b\"...\") are heavily used for file names, paths, and ASCII string constants.",
            "patterns": [
              "File names",
              "Path components",
              "Test data",
              "POSIX string constants"
            ]
          },
          "samples": [
            {
              "file": "iceoryx2/src/node/mod.rs",
              "line": [343],
              "code": "const FALLBACK_EXEC: &[u8] = b\"undefined\";",
              "purpose": "Byte string literal for fallback executable name constant, used when process name cannot be determined"
            },
            {
              "file": "iceoryx2/src/config.rs",
              "line": [94, 95, 96],
              "code": "const DEFAULT_CONFIG_FILE_NAME: &[u8] = b\"iceoryx2.toml\";\nconst RELATIVE_LOCAL_CONFIG_PATH: &[u8] = b\"config\";\nconst RELATIVE_CONFIG_FILE_PATH: &[u8] = b\"iceoryx2\";",
              "purpose": "Byte string literals defining configuration file paths and names as static byte slices for file system operations"
            },
            {
              "file": "iceoryx2/src/config.rs",
              "line": [159, 160, 161],
              "code": "directory: Path::new(b\"services\").unwrap(),\ndata_segment_suffix: FileName::new(b\".data\").unwrap(),\nstatic_config_storage_suffix: FileName::new(b\".service\").unwrap(),",
              "purpose": "Byte string literals for default service directory and file suffix configuration values"
            }
          ],
          "subsections": {
            "simple_byte_string_literals": {
              "fls_section": "2.4.2.1",
              "fls_ids": [],
              "description": "Simple Byte String Literals",
              "status": "demonstrated",
              "findings": {
                "count": 743,
                "description": "Simple byte strings are the primary form used - no raw byte strings found."
              },
              "samples": [
                {
                  "file": "iceoryx2/src/config.rs",
                  "line": [94],
                  "code": "const DEFAULT_CONFIG_FILE_NAME: &[u8] = b\"iceoryx2.toml\";",
                  "purpose": "Simple byte string literal for default configuration filename constant"
                },
                {
                  "file": "iceoryx2/src/node/mod.rs",
                  "line": [343],
                  "code": "const FALLBACK_EXEC: &[u8] = b\"undefined\";",
                  "purpose": "Simple byte string literal for process executable fallback value"
                },
                {
                  "file": "iceoryx2/src/config.rs",
                  "line": [159],
                  "code": "directory: Path::new(b\"services\").unwrap(),",
                  "purpose": "Simple byte string literal for default service directory path initialization"
                }
              ],
              "count": 741
            },
            "raw_byte_string_literals": {
              "fls_section": "2.4.2.2",
              "fls_ids": [
                "fls_jps9102q0qfi"
              ],
              "description": "Raw Byte String Literals",
              "status": "not_used",
              "findings": {
                "description": "Raw byte string literals (br\"...\") are not used in iceoryx2."
              },
              "samples": [],
              "count": null,
              "count_methodology": "Pattern not defined for this section"
            }
          },
          "count": 741
        },
        "c_string_literals": {
          "fls_section": "2.4.3",
          "fls_ids": [],
          "description": "C String Literals",
          "status": "demonstrated",
          "findings": {
            "count": 34,
            "description": "C string literals (c\"...\") provide null-terminated strings for FFI. Used in platform-specific code.",
            "note": "Stabilized in Rust 1.77, used in QNX platform code"
          },
          "samples": [
            {
              "file": "iceoryx2-pal/posix/src/qnx/unistd.rs",
              "line": [23],
              "code": "c\"/proc/self/exefile\".to_owned()",
              "purpose": "C string literal for QNX-specific proc filesystem path to get current executable"
            },
            {
              "file": "iceoryx2-pal/posix/src/linux/unistd.rs",
              "line": [23],
              "code": "c\"/proc/self/exe\".to_owned()",
              "purpose": "C string literal for Linux proc filesystem path to current executable, null-terminated for libc compatibility"
            },
            {
              "file": "iceoryx2-pal/posix/src/windows/win32_udp_port_to_uds_name.rs",
              "line": [32],
              "code": "const SHM_SEGMENT_NAME: &CStr = c\"/port_to_uds_name_map\";",
              "purpose": "C string literal constant for shared memory segment name in Windows UDS emulation layer"
            }
          ],
          "subsections": {
            "simple_c_string_literals": {
              "fls_section": "2.4.3.1",
              "fls_ids": [],
              "description": "Simple C String Literals",
              "status": "demonstrated",
              "findings": {
                "count": 34,
                "description": "Simple C strings used for FFI path constants"
              },
              "samples": [
                {
                  "file": "iceoryx2-pal/posix/src/windows/win32_udp_port_to_uds_name.rs",
                  "line": [32],
                  "code": "const SHM_SEGMENT_NAME: &CStr = c\"/port_to_uds_name_map\";",
                  "purpose": "Simple C string literal for shared memory segment name, automatically null-terminated"
                },
                {
                  "file": "iceoryx2-pal/posix/src/linux/unistd.rs",
                  "line": [23],
                  "code": "c\"/proc/self/exe\".to_owned()",
                  "purpose": "Simple C string literal for Linux proc path, converted to owned CString for libc readlink call"
                },
                {
                  "file": "iceoryx2-pal/posix/src/qnx/unistd.rs",
                  "line": [23],
                  "code": "c\"/proc/self/exefile\".to_owned()",
                  "purpose": "Simple C string literal for QNX-specific executable path location"
                }
              ],
              "count": 18
            },
            "raw_c_string_literals": {
              "fls_section": "2.4.3.2",
              "fls_ids": [],
              "description": "Raw C String Literals",
              "status": "not_used",
              "findings": {
                "description": "Raw C string literals (cr\"...\") are not used in iceoryx2."
              },
              "samples": [],
              "count": null,
              "count_methodology": "Pattern not defined for this section"
            }
          },
          "count": 18
        },
        "numeric_literals": {
          "fls_section": "2.4.4",
          "fls_ids": [
            "fls_hv9jtycp0o1y"
          ],
          "description": "Numeric Literals",
          "status": "demonstrated",
          "findings": {
            "description": "Numeric literals are used extensively for configuration, sizing, and POSIX constants.",
            "hex_literals": 48,
            "octal_literals": 58,
            "binary_literals": 4
          },
          "samples": [
            {
              "file": "iceoryx2-pal/posix/src/windows/win32_security_attributes.rs",
              "line": [85, 86, 87],
              "code": "const FILE_READ_DATA_HEX: u32 = 0x1;\nconst FILE_WRITE_DATA_HEX: u32 = 0x2;\nconst FILE_EXECUTE_HEX: u32 = 0x20;",
              "purpose": "Hexadecimal literals for Windows file permission bit flags, matching Win32 API constants"
            },
            {
              "file": "iceoryx2-pal/posix/src/windows/win32_udp_port_to_uds_name.rs",
              "line": [30, 31],
              "code": "const IS_INITIALIZED: u64 = 0xaffedeadbeef;\nconst INITIALIZATION_IN_PROGRESS: u64 = 0xbebebebebebebebe;",
              "purpose": "Hexadecimal magic number constants for initialization state tracking in lock-free algorithms"
            },
            {
              "file": "iceoryx2-pal/posix/src/stub/constants.rs",
              "line": [169, 170],
              "code": "pub const S_IFMT: mode_t = 0o0170000;\npub const S_IFIFO: mode_t = 0o0010000;",
              "purpose": "Octal literals for POSIX file mode bitmasks, following traditional Unix conventions"
            }
          ],
          "subsections": {
            "integer_literals": {
              "fls_section": "2.4.4.1",
              "fls_ids": [
                "fls_2ed4axpsy9u0"
              ],
              "description": "Integer Literals",
              "status": "demonstrated",
              "findings": {
                "description": "Integer literals with type suffixes (u8, u16, u32, u64, usize, i8, etc.) are used extensively for type safety.",
                "patterns": [
                  "Array initialization with 0u8",
                  "POSIX constants with mode_t",
                  "Size constants with usize"
                ],
                "bases": [
                  "Decimal (most common)",
                  "Hexadecimal (0x - permissions)",
                  "Octal (0o - POSIX modes)",
                  "Binary (0b - bit patterns)"
                ]
              },
              "samples": [
                {
                  "file": "iceoryx2-pal/posix/src/stub/constants.rs",
                  "line": [169, 170],
                  "code": "pub const S_IFMT: mode_t = 0o0170000;\npub const S_IFIFO: mode_t = 0o0010000;",
                  "purpose": "Octal integer literals for POSIX file mode bitmasks used in file type detection"
                },
                {
                  "file": "iceoryx2/src/constants.rs",
                  "line": [14, 18, 21],
                  "code": "pub const MAX_SERVICE_NAME_LENGTH: usize = 255;\npub const MAX_ATTRIBUTES: usize = 8;\npub const MAX_ATTRIBUTE_KEY_LENGTH: usize = 64;",
                  "purpose": "Decimal integer literals with usize type suffix defining API size limits"
                },
                {
                  "file": "iceoryx2/src/service/service_id.rs",
                  "line": [26],
                  "code": "const SERVICE_ID_CAPACITY: usize = 64;",
                  "purpose": "Decimal integer literal for internal buffer capacity constant"
                }
              ],
              "count": 19819
            },
            "float_literals": {
              "fls_section": "2.4.4.2",
              "fls_ids": [
                "fls_29tlg1vyqay2"
              ],
              "description": "Float Literals",
              "status": "limited_use",
              "findings": {
                "description": "Float literals are minimally used - iceoryx2 primarily uses Duration for time and integer arithmetic for sizes.",
                "count": "~10",
                "note": "Limited use of floating point for safety-critical determinism"
              },
              "samples": [
                {
                  "file": "iceoryx2-pal/configuration/src/lib.rs",
                  "line": [46],
                  "code": "pub const AT_LEAST_TIMING_VARIANCE: f32 = 0.25;",
                  "purpose": "Float literal for timing variance threshold constant used in platform-specific test configuration"
                },
                {
                  "file": "iceoryx2-bb/posix/src/scheduler.rs",
                  "line": [95, 96],
                  "code": ".clamp(0.0, 1.0),\nfalse => (1.0",
                  "purpose": "Float literals 0.0 and 1.0 for priority normalization range bounds in scheduler configuration"
                },
                {
                  "file": "iceoryx2-bb/posix/src/scheduler.rs",
                  "line": [113],
                  "code": "let relative_prio: f32 = (priority as f32 / u8::MAX as f32).clamp(0.0, 1.0);",
                  "purpose": "Float literals for clamping normalized priority values to valid 0-1 range"
                }
              ],
              "count": 3264
            }
          },
          "count": 19544
        },
        "character_literals": {
          "fls_section": "2.4.5",
          "fls_ids": [
            "fls_ypa86oqxhn9u"
          ],
          "description": "Character Literals",
          "status": "demonstrated",
          "findings": {
            "count": 117,
            "description": "Character literals ('x') are used for char type values. Byte literals (b'x') are preferred for ASCII operations.",
            "patterns": [
              "Escape sequences in string processing",
              "Unicode box-drawing in panic handlers"
            ]
          },
          "samples": [
            {
              "file": "iceoryx2-bb/container/src/string/utils.rs",
              "line": [40, 41, 42],
              "code": "b'\\t' => vec![b'\\\\', b't'].into_iter(),\nb'\\r' => vec![b'\\\\', b'r'].into_iter(),\nb'\\n' => vec![b'\\\\', b'n'].into_iter(),",
              "purpose": "Byte character literals for escape sequence translation (tab, carriage return, newline)"
            },
            {
              "file": "iceoryx2-pal/posix/src/windows/win32_udp_port_to_uds_name.rs",
              "line": [130],
              "code": "if *c == b'\\\\' || *c == b'/' {",
              "purpose": "Byte character literals for path separator comparison on Windows (backslash and forward slash)"
            },
            {
              "file": "iceoryx2/src/service/naming_scheme.rs",
              "line": [31],
              "code": "file.push(b'_').unwrap();",
              "purpose": "Byte character literal for underscore separator in service file naming scheme"
            }
          ],
          "count": 178
        },
        "string_literals": {
          "fls_section": "2.4.6",
          "fls_ids": [
            "fls_boyhlu5srp6u"
          ],
          "description": "String Literals",
          "status": "demonstrated",
          "findings": {
            "description": "String literals (\"...\") are used extensively for error messages, documentation, and test data.",
            "patterns": [
              "Error messages",
              "Log format strings",
              "Test assertions",
              "Documentation strings"
            ]
          },
          "samples": [
            {
              "file": "iceoryx2/src/port/mod.rs",
              "line": [101],
              "code": "write!(f, \"LoanError::{self:?}\")",
              "purpose": "String literal in Display trait implementation for error type formatting"
            },
            {
              "file": "iceoryx2/src/node/mod.rs",
              "line": [246],
              "code": "write!(f, \"NodeCreationFailure::{self:?}\")",
              "purpose": "String literal format string for Display impl of node creation error enum"
            },
            {
              "file": "iceoryx2/src/service/service_name.rs",
              "line": [173],
              "code": "Err(v) => Err(E::custom(format!(\"invalid service name provided {v:?}.\"))),",
              "purpose": "String literal in format! macro for custom deserialization error message"
            }
          ],
          "subsections": {
            "simple_string_literals": {
              "fls_section": "2.4.6.1",
              "fls_ids": [
                "fls_hucd52suu6it"
              ],
              "description": "Simple String Literals",
              "status": "demonstrated",
              "findings": {
                "description": "Simple string literals are the primary form used throughout the codebase."
              },
              "samples": [
                {
                  "file": "iceoryx2/src/port/mod.rs",
                  "line": [134],
                  "code": "write!(f, \"SendError::{self:?}\")",
                  "purpose": "Simple string literal as format string in Display implementation for SendError"
                },
                {
                  "file": "iceoryx2/src/request_mut_uninit.rs",
                  "line": [83],
                  "code": "write!(f, \"RequestMutUninit {{  request: {:?} }}\", self.request)",
                  "purpose": "Simple string literal with escaped braces for Debug-style output formatting"
                },
                {
                  "file": "iceoryx2/src/service/builder/publish_subscribe.rs",
                  "line": [411],
                  "code": "let origin = format!(\"{self:?}\");",
                  "purpose": "Simple string literal in format! macro for converting builder to string for logging"
                }
              ],
              "count": 8828
            },
            "raw_string_literals": {
              "fls_section": "2.4.6.2",
              "fls_ids": [
                "fls_usr6iuwpwqqh"
              ],
              "description": "Raw String Literals",
              "status": "limited_use",
              "findings": {
                "count": 1,
                "description": "Raw string literals (r#\"...\"#) are used only in bare-metal startup assembly code."
              },
              "samples": [
                {
                  "file": "examples/nostd/bare-metal/rust/publish-subscribe/src/startup.rs",
                  "line": [
                    14
                  ],
                  "code": "r#\".section .text.startup...\"#",
                  "purpose": "Raw string for inline assembly directives"
                }
              ],
              "count": 1,
              "samples_waiver": {
                "reason": "insufficient_patterns",
                "explanation": "Only 1 instance(s) found in codebase, fewer than 3 required samples",
                "approved_by": "automated",
                "date": "2025-12-30"
              }
            }
          },
          "count": 8828
        },
        "boolean_literals": {
          "fls_section": "2.4.7",
          "fls_ids": [
            "fls_jkab8eevzbte"
          ],
          "description": "Boolean Literals",
          "status": "demonstrated",
          "findings": {
            "true_count": 1427,
            "false_count": 1184,
            "total": 2611,
            "description": "Boolean literals are used extensively for configuration flags, test assertions, and state tracking."
          },
          "samples": [
            {
              "file": "iceoryx2/src/config.rs",
              "line": [203, 204],
              "code": "cleanup_dead_nodes_on_creation: true,\ncleanup_dead_nodes_on_destruction: true,",
              "purpose": "Boolean literals for default node cleanup configuration flags"
            },
            {
              "file": "iceoryx2/src/config.rs",
              "line": [328],
              "code": "enable_safe_overflow: true,",
              "purpose": "Boolean literal enabling safe overflow behavior as default for publish-subscribe"
            },
            {
              "file": "iceoryx2/src/config.rs",
              "line": [696],
              "code": "let mut is_config_file_set = false;",
              "purpose": "Boolean literal initializing mutable state flag for config file parsing logic"
            }
          ],
          "count": 2618
        }
      },
      "count": null,
      "count_methodology": "Aggregate of literal subtypes",
      "samples_waiver": {
        "reason": "conceptual_section",
        "explanation": "This section describes an abstract concept not directly mappable to concrete code patterns",
        "approved_by": "automated",
        "date": "2025-12-30"
      }
    },
    "comments": {
      "fls_section": "2.5",
      "fls_ids": [
        "fls_q8l2jza7d9xa"
      ],
      "description": "Comments",
      "status": "demonstrated",
      "findings": {
        "doc_comment_lines": 16774,
        "safety_doc_sections": 708,
        "spdx_license_headers": 1071,
        "regular_comments": 24407
      },
      "samples": [
        {
          "file": "iceoryx2/src/service/service_id.rs",
          "line": [57],
          "code": "// SAFETY: a SemanticString is always a valid UTF-8 string",
          "purpose": "Line comment documenting safety invariant for unsafe code block"
        },
        {
          "file": "iceoryx2/src/request_mut_uninit.rs",
          "line": [290],
          "code": "// SAFETY: this is safe since the payload was initialized on the line above",
          "purpose": "SAFETY comment explaining why unsafe transmute is sound after initialization"
        },
        {
          "file": "iceoryx2/src/config.rs",
          "line": [1],
          "code": "// Copyright (c) 2023 Contributors to the Eclipse Foundation",
          "purpose": "Line comment for SPDX license header at file start"
        }
      ],
      "count": 36787
    },
    "keywords": {
      "fls_section": "2.6",
      "fls_ids": [
        "fls_lish33a1naw5"
      ],
      "description": "Keywords",
      "status": "demonstrated",
      "findings": {
        "unsafe": 4957,
        "pub": 12666,
        "const": 5427,
        "async_await": 0,
        "union": 42,
        "note": "No async/await - intentionally avoided for deterministic real-time behavior"
      },
      "samples": [],
      "subsections": {
        "strict_keywords": {
          "fls_section": "2.6.1",
          "fls_ids": [
            "fls_mec5cg5aptf8"
          ],
          "description": "Strict Keywords",
          "status": "demonstrated",
          "findings": {
            "description": "Strict keywords cannot be used as identifiers. iceoryx2 uses most strict keywords except async/await.",
            "heavily_used": [
              "fn",
              "let",
              "pub",
              "use",
              "impl",
              "struct",
              "enum",
              "trait",
              "unsafe",
              "const",
              "static",
              "mut",
              "where",
              "for",
              "if",
              "else",
              "match",
              "return",
              "self",
              "Self"
            ],
            "not_used": [
              "async",
              "await"
            ],
            "async_await_rationale": "Intentionally avoided for deterministic real-time behavior"
          },
          "samples": [],
          "count": null,
          "count_methodology": "Conceptual - strict keywords pervasive",
          "samples_waiver": {
            "reason": "conceptual_section",
            "explanation": "This section describes an abstract concept not directly mappable to concrete code patterns",
            "approved_by": "automated",
            "date": "2025-12-30"
          }
        },
        "reserved_keywords": {
          "fls_section": "2.6.2",
          "fls_ids": [
            "fls_cbsgp6k0qa82"
          ],
          "description": "Reserved Keywords",
          "status": "not_applicable",
          "findings": {
            "description": "Reserved keywords (abstract, become, box, do, final, macro, override, priv, try, typeof, unsized, virtual, yield) are reserved for future use and cannot be used. iceoryx2 does not use any reserved keywords."
          },
          "samples": [],
          "count": null,
          "count_methodology": "Pattern not defined for this section"
        },
        "weak_keywords": {
          "fls_section": "2.6.3",
          "fls_ids": [
            "fls_9kjpxri0axvg"
          ],
          "description": "Weak Keywords",
          "status": "demonstrated",
          "findings": {
            "description": "Weak keywords have special meaning only in certain contexts.",
            "union": {
              "count": 42,
              "note": "NEW in v0.8.0 - used for FFI C API discriminated unions"
            },
            "dyn": {
              "count": 319,
              "note": "Used for trait objects (Logger, allocators)"
            },
            "macro_rules": {
              "count": 28,
              "note": "Declarative macro definitions"
            }
          },
          "samples": [
            {
              "file": "iceoryx2-bb/posix/src/signal.rs",
              "line": [85],
              "code": "macro_rules! define_signals {",
              "purpose": "macro_rules weak keyword defining declarative macro for signal constant generation"
            },
            {
              "file": "iceoryx2-ffi/c/src/api/waitset.rs",
              "line": [128],
              "code": "pub(crate) union WaitSetUnion {",
              "purpose": "union weak keyword declaring FFI-compatible discriminated union for IPC/Local waitset variants"
            },
            {
              "file": "iceoryx2-ffi/c/src/api/service_builder.rs",
              "line": [54],
              "code": "pub(super) union ServiceBuilderUnion {",
              "purpose": "union weak keyword for service builder variant storage in C FFI bindings"
            }
          ],
          "count": 70
        }
      },
      "count": null,
      "count_methodology": "Conceptual - keywords pervasive",
      "samples_waiver": {
        "reason": "conceptual_section",
        "explanation": "This section describes an abstract concept not directly mappable to concrete code patterns",
        "approved_by": "automated",
        "date": "2025-12-30"
      }
    }
  },
  "safety_critical_summary": {
    "constructs_not_used": [
      {
        "construct": "async/await keywords",
        "fls_section": "2.6.1",
        "safety_benefit": "Avoids async complexity and non-determinism"
      },
      {
        "construct": "Raw identifiers (r#)",
        "fls_section": "2.3",
        "safety_benefit": "Clearer code"
      },
      {
        "construct": "Unicode identifiers",
        "fls_section": "2.3",
        "safety_benefit": "ASCII-only clarity"
      },
      {
        "construct": "Underscore digit separators",
        "fls_section": "2.4.4.1",
        "safety_benefit": "N/A"
      },
      {
        "construct": "Float exponent notation",
        "fls_section": "2.4.4.2",
        "safety_benefit": "N/A"
      },
      {
        "construct": "Raw string literals",
        "fls_section": "2.4.6.2",
        "safety_benefit": "N/A"
      },
      {
        "construct": "Block doc comments",
        "fls_section": "2.5",
        "safety_benefit": "Consistent style"
      },
      {
        "construct": "char literals",
        "fls_section": "2.4.5",
        "safety_benefit": "byte literals used instead for ASCII"
      }
    ],
    "constructs_requiring_review": [
      {
        "construct": "Division operator /",
        "fls_section": "2.2:17",
        "risk": "Panic on division by zero",
        "action": "Verify all divisors are non-zero"
      },
      {
        "construct": "Modulo operator %",
        "fls_section": "2.2:18",
        "risk": "Panic on modulo by zero",
        "action": "Verify all divisors are non-zero"
      },
      {
        "construct": "unsafe keyword",
        "fls_section": "2.6.1",
        "count": 4959,
        "count_change": "+2522 from v0.7.0",
        "risk": "Memory safety bypass",
        "action": "Individual safety justification required"
      },
      {
        "construct": "union keyword",
        "fls_section": "2.6.3",
        "count": 42,
        "count_change": "NEW - was 0 in v0.7.0",
        "risk": "Unsafe field access, memory layout concerns",
        "action": "Review FFI union types for memory safety"
      },
      {
        "construct": "Floating point literals",
        "fls_section": "2.4.4.2",
        "count": "~10",
        "risk": "IEEE 754 complexity",
        "action": "Consider fixed-point alternative for ASIL B"
      },
      {
        "construct": "dyn keyword (trait objects)",
        "fls_section": "2.6.1",
        "count": 319,
        "count_change": "+309 from v0.7.0",
        "risk": "Dynamic dispatch, vtable indirection",
        "action": "Review for determinism requirements"
      },
      {
        "construct": "extern keyword",
        "fls_section": "2.6.1",
        "count": 976,
        "count_change": "+928 from v0.7.0",
        "risk": "FFI boundary safety",
        "action": "Review all extern \"C\" functions for ABI compatibility"
      }
    ],
    "version_comparison": {
      "v0_7_0_unsafe_count": 2437,
      "v0_8_0_unsafe_count": 4959,
      "delta": "+2522 (103% increase)",
      "explanation": "Increase primarily due to expanded C/C++ FFI bindings in iceoryx2-ffi crate"
    }
  }
}