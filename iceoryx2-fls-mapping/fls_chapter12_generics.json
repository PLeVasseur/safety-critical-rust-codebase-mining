{
  "chapter": 12,
  "title": "Generics",
  "fls_url": "https://rust-lang.github.io/fls/generics.html",
  "fls_id": "fls_y2k5paj8m8ug",
  "repository": "eclipse-iceoryx/iceoryx2",
  "version": "0.8.0",
  "analysis_date": "2025-12-30",
  "version_changes": {
    "from_version": "0.7.0",
    "to_version": "0.8.0",
    "summary": "Major expansion in generic usage. Generic structs increased 62% (152->246), generic functions increased 25% (1142->1425), PhantomData usage dramatically increased (15->256). Where clauses doubled (88->182).",
    "key_changes": [
      "Directory structure changed: iceoryx2-bb-*-0.7.0/ -> iceoryx2-bb/*/",
      "Generic structs increased from 152 to 246 (+62%)",
      "Generic enums increased from 7 to 12 (+71%)",
      "Generic functions increased from 1142 to 1425 (+25%)",
      "Generic implementations increased from 197 to 571 (+190%)",
      "Generic traits increased from 28 to 41 (+46%)",
      "Where clauses increased from 88 to 182 (+107%)",
      "PhantomData usage increased from 15 to 256 (+1607%)",
      "Lifetime parameters increased from 171 to 342 (+100%)",
      "'static lifetime usage increased significantly (251 instances)"
    ]
  },
  "summary": "FLS Chapter 12 defines generics as placeholders for constants, lifetimes, or types that are supplied statically by generic arguments. iceoryx2 v0.8.0 makes extensive use of all three kinds of generic parameters: const generics for capacity/size parameters, type parameters for abstraction over payload types and service backends, and lifetime parameters for RAII guards. The codebase demonstrates sophisticated generic patterns including where clauses, multiple bounds, and PhantomData for unused type parameters.",
  "statistics": {
    "generic_structs": 246,
    "generic_enums": 12,
    "generic_functions": 1425,
    "generic_implementations": 571,
    "generic_traits": 41,
    "where_clauses": 182,
    "phantom_data_usages": 256,
    "lifetime_parameters": 342,
    "static_lifetime_usages": 251,
    "const_capacity_params": 99
  },
  "sections": {
    "12.1": {
      "fls_section": "12.1",
      "fls_ids": [],
      "description": "Generic Parameters",
      "status": "MUST_BE_FILLED"
    },
    "12.2": {
      "fls_section": "12.2",
      "fls_ids": [],
      "description": "Where Clauses",
      "status": "MUST_BE_FILLED"
    },
    "12.3": {
      "fls_section": "12.3",
      "fls_ids": [],
      "description": "Generic Arguments",
      "status": "MUST_BE_FILLED"
    },
    "12.4": {
      "fls_section": "12.4",
      "fls_ids": [],
      "description": "Generic Conformance",
      "status": "MUST_BE_FILLED"
    }
  },
  "design_patterns": {
    "const_generics_for_no_alloc": {
      "description": "Const generics enable fixed-size containers without heap allocation",
      "rationale": "Real-time systems need predictable memory usage"
    },
    "trait_bounds_for_safety": {
      "description": "Bounds like Send + Sync ensure thread safety",
      "example": "T: Send + Sync + Debug + 'static"
    },
    "question_sized_for_dsts": {
      "description": "?Sized allows dynamically-sized payloads",
      "example": "Payload: Debug + ?Sized + ZeroCopySend"
    },
    "lifetime_bounds_for_raii": {
      "description": "Lifetime parameters ensure guards don't outlive resources",
      "example": "MutexGuard<'handle, T>"
    }
  },
  "cross_chapter_references": {
    "chapter_3": "Generic items (structs, enums, functions, traits)",
    "chapter_4": "Type parameters create types; trait bounds",
    "chapter_9": "Generic functions",
    "chapter_10": "Generic associated items and GATs",
    "chapter_11": "Generic implementations",
    "chapter_15": "Lifetime parameters for ownership/borrowing"
  }
}