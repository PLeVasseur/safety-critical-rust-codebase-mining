{
  "chapter": 12,
  "title": "Generics",
  "fls_url": "https://rust-lang.github.io/fls/generics.html",
  "fls_id": "fls_y2k5paj8m8ug",
  "repository": "eclipse-iceoryx/iceoryx2",
  "version": "0.8.0",
  "analysis_date": "2025-12-30",
  "version_changes": {
    "from_version": "0.7.0",
    "to_version": "0.8.0",
    "summary": "Major expansion in generic usage. Generic structs increased 62% (152->246), generic functions increased 25% (1142->1425), PhantomData usage dramatically increased (15->256). Where clauses doubled (88->182).",
    "key_changes": [
      "Directory structure changed: iceoryx2-bb-*-0.7.0/ -> iceoryx2-bb/*/",
      "Generic structs increased from 152 to 246 (+62%)",
      "Generic enums increased from 7 to 12 (+71%)",
      "Generic functions increased from 1142 to 1425 (+25%)",
      "Generic implementations increased from 197 to 571 (+190%)",
      "Generic traits increased from 28 to 41 (+46%)",
      "Where clauses increased from 88 to 182 (+107%)",
      "PhantomData usage increased from 15 to 256 (+1607%)",
      "Lifetime parameters increased from 171 to 342 (+100%)",
      "'static lifetime usage increased significantly (251 instances)"
    ]
  },
  "summary": "FLS Chapter 12 defines generics as placeholders for constants, lifetimes, or types that are supplied statically by generic arguments. iceoryx2 v0.8.0 makes extensive use of all three kinds of generic parameters: const generics for capacity/size parameters, type parameters for abstraction over payload types and service backends, and lifetime parameters for RAII guards. The codebase demonstrates sophisticated generic patterns including where clauses, multiple bounds, and PhantomData for unused type parameters.",
  "statistics": {
    "generic_structs": 246,
    "generic_enums": 12,
    "generic_functions": 1425,
    "generic_implementations": 571,
    "generic_traits": 41,
    "where_clauses": 182,
    "phantom_data_usages": 256,
    "lifetime_parameters": 342,
    "static_lifetime_usages": 251,
    "const_capacity_params": 99
  },
  "sections": {
    "generic_parameters": {
      "fls_section": "12.1",
      "fls_ids": [
        "fls_vhpwge5123cm"
      ],
      "description": "Generic Parameters",
      "status": "demonstrated",
      "findings": {},
      "samples": [
        {
          "file": "iceoryx2/src/sample_mut_uninit.rs",
          "line": [119, 120, 121, 122, 123, 124],
          "code": "unsafe impl<\n        Service: crate::service::Service,\n        Payload: Debug + ZeroCopySend + ?Sized,\n        UserHeader: ZeroCopySend,\n    > Send for SampleMutUninit<Service, Payload, UserHeader>",
          "purpose": "Generic type parameters with trait bounds enabling thread-safe sample handling"
        },
        {
          "file": "iceoryx2/src/port/server.rs",
          "line": [235, 236, 237, 238, 239, 240, 241],
          "code": "unsafe impl<\n        Service: service::Service,\n        RequestPayload: Debug + ZeroCopySend + ?Sized,\n        RequestHeader: Debug + ZeroCopySend,\n        ResponsePayload: Debug + ZeroCopySend + ?Sized,\n        ResponseHeader: Debug + ZeroCopySend,\n    > Send for Server<Service, ...",
          "purpose": "Multiple generic type parameters with trait bounds for request-response server"
        },
        {
          "file": "iceoryx2/src/service/static_config/mod.rs",
          "line": [66, 67, 68],
          "code": "service_id: ServiceId::new::<Hasher>(\n    service_name,\n    crate::service::messaging_pattern::MessagingPattern::RequestResponse,\n),",
          "purpose": "Turbofish syntax providing concrete type argument for hash function"
        }
      ],
      "count": 7012
    },
    "where_clauses": {
      "fls_section": "12.2",
      "fls_ids": [
        "fls_7nv8ualeaqe3"
      ],
      "description": "Where Clauses",
      "status": "demonstrated",
      "findings": {},
      "samples": [
        {
          "file": "iceoryx2/src/sample_mut_uninit.rs",
          "line": [124, 125, 126, 127],
          "code": "    > Send for SampleMutUninit<Service, Payload, UserHeader>\nwhere\n    Service::ArcThreadSafetyPolicy<PublisherSharedState<Service>>: Send + Sync,\n{",
          "purpose": "Where clause constraining associated type to Send + Sync for thread safety"
        },
        {
          "file": "iceoryx2/src/active_request.rs",
          "line": [111, 112, 113, 114],
          "code": "for ActiveRequest<Service, RequestPayload, RequestHeader, ResponsePayload, ResponseHeader>\nwhere\n    Service::ArcThreadSafetyPolicy<SharedServerState<Service>>: Send + Sync,\n{",
          "purpose": "Where clause on ActiveRequest ensuring thread-safe service state handling"
        },
        {
          "file": "iceoryx2/src/port/server.rs",
          "line": [253, 254, 255, 256],
          "code": "> Sync for Server<Service, RequestPayload, RequestHeader, ResponsePayload, ResponseHeader>\nwhere\n    Service::ArcThreadSafetyPolicy<SharedServerState<Service>>: Send + Sync,\n{",
          "purpose": "Where clause enabling Sync trait impl only when service policy supports it"
        }
      ],
      "count": 67
    },
    "generic_arguments": {
      "fls_section": "12.3",
      "fls_ids": [
        "fls_utuu8mdbuyxm"
      ],
      "description": "Generic Arguments",
      "status": "demonstrated",
      "findings": {},
      "samples": [
        {
          "file": "iceoryx2/src/service/static_config/mod.rs",
          "line": [66],
          "code": "service_id: ServiceId::new::<Hasher>(",
          "purpose": "Turbofish generic argument specifying hash algorithm type"
        },
        {
          "file": "iceoryx2-cli/lib/src/filter.rs",
          "line": [45],
          "code": "if let Ok(pid) = s.parse::<pid_t>() {",
          "purpose": "Turbofish specifying target type for string parsing"
        },
        {
          "file": "iceoryx2-cli/iox2/src/command/paths.rs",
          "line": [22],
          "code": "let paths = IceoryxCommandFinder::<E>::paths().context(\"Failed to list search paths\")?;",
          "purpose": "Generic environment type parameter for command path lookup"
        }
      ],
      "count": 2617
    },
    "generic_conformance": {
      "fls_section": "12.4",
      "fls_ids": [
        "fls_i7g2n7hfg3ch"
      ],
      "description": "Generic Conformance",
      "status": "demonstrated",
      "findings": {},
      "samples": [],
      "count": null,
      "count_methodology": "Conceptual - conformance is compiler behavior",
      "samples_waiver": {
        "reason": "conceptual_section",
        "explanation": "This section describes an abstract concept not directly mappable to concrete code patterns",
        "approved_by": "automated",
        "date": "2025-12-30"
      }
    }
  },
  "design_patterns": {
    "const_generics_for_no_alloc": {
      "description": "Const generics enable fixed-size containers without heap allocation",
      "rationale": "Real-time systems need predictable memory usage"
    },
    "trait_bounds_for_safety": {
      "description": "Bounds like Send + Sync ensure thread safety",
      "example": "T: Send + Sync + Debug + 'static"
    },
    "question_sized_for_dsts": {
      "description": "?Sized allows dynamically-sized payloads",
      "example": "Payload: Debug + ?Sized + ZeroCopySend"
    },
    "lifetime_bounds_for_raii": {
      "description": "Lifetime parameters ensure guards don't outlive resources",
      "example": "MutexGuard<'handle, T>"
    }
  },
  "cross_chapter_references": {
    "chapter_3": "Generic items (structs, enums, functions, traits)",
    "chapter_4": "Type parameters create types; trait bounds",
    "chapter_9": "Generic functions",
    "chapter_10": "Generic associated items and GATs",
    "chapter_11": "Generic implementations",
    "chapter_15": "Lifetime parameters for ownership/borrowing"
  }
}