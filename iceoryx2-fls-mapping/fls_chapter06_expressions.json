{
  "chapter": 6,
  "title": "Expressions",
  "fls_url": "https://rust-lang.github.io/fls/expressions.html",
  "fls_id": "fls_ckvjj4tt1hh2",
  "repository": "eclipse-iceoryx/iceoryx2",
  "version": "0.8.0",
  "analysis_date": "2025-12-30",
  "version_changes": {
    "from_version": "0.7.0",
    "to_version": "0.8.0",
    "summary": "Major increase in expression usage due to expanded FFI layer, union support, and no_std compatibility. Unsafe blocks increased 39% (1702->2372), method calls increased 50% (19003->28421), closures increased 157% (636->1638).",
    "key_changes": [
      "Directory structure changed: iceoryx2-bb-*-0.7.0/ -> iceoryx2-bb/*/",
      "Unsafe blocks increased from 1702 to 2372 (+39%)",
      "Method calls increased from 19003 to 28421 (+50%)",
      "Closures increased from 636 to 1638 (+157%)",
      "Error propagation (?) increased from 2065 to 3443 (+67%)",
      "Match expressions increased from 712 to 1663 (+134%)",
      "For loops increased from 1155 to 1438 (+24%)",
      "New const block usage in StaticVec initialization"
    ]
  },
  "summary": "FLS Chapter 6 defines expressions - constructs that produce values and may have side effects. Expressions are categorized as expression-with-block or expression-without-block.",
  "statistics": {
    "match_expressions": 1663,
    "if_expressions": 2444,
    "if_let_expressions": 337,
    "for_loops": 1438,
    "while_loops": 356,
    "loop_expressions": 130,
    "closures": 1638,
    "method_calls": 28421,
    "error_propagation": 3443,
    "unsafe_blocks": 2372,
    "return_expressions": 959,
    "async_await": 0
  },
  "sections": {
    "expression_classification": {
      "fls_section": "6.1",
      "fls_ids": [
        "fls_isyftqu120l"
      ],
      "description": "Expression Classification",
      "status": "demonstrated",
      "findings": {
        "analyzed": true
      },
      "samples": [],
      "subsections": {
        "assignee_expressions": {
          "fls_section": "6.1.1",
          "fls_ids": [
            "fls_3ut3biyra4r9"
          ],
          "description": "Assignee Expressions",
          "status": "demonstrated",
          "findings": {
            "description": "Assignee expressions can appear on the left side of assignment. Used for variables, fields, and array indexing."
          },
          "samples": [
            {
              "file": "iceoryx2/src/port/details/channel_management.rs",
              "line": [
                33
              ],
              "code": "let disconnect_hint_state = expected_state | DISCONNECT_HINT_BIT;",
              "purpose": "Local variable assignment for computing disconnect hint state in channel management"
            },
            {
              "file": "iceoryx2/src/waitset.rs",
              "line": [
                500
              ],
              "code": "let msg = \"Unable to create WaitSet\";",
              "purpose": "Error message variable assignment used in WaitSet creation failure handling"
            },
            {
              "file": "iceoryx2-bb/lock-free/src/mpmc/unique_index_set.rs",
              "line": [
                283, 284, 285
              ],
              "code": "capacity: capacity as u32,\nhead: AtomicU64::new(0),\nis_memory_initialized: AtomicBool::new(false),",
              "purpose": "Field assignments initializing struct members for lock-free unique index set"
            }
          ],
          "count": 24780
        },
        "constant_expressions": {
          "fls_section": "6.1.2",
          "fls_ids": [
            "fls_66m4rnbssgig"
          ],
          "description": "Constant Expressions",
          "status": "demonstrated",
          "findings": {
            "description": "Expressions evaluable at compile time. Used for const declarations, array lengths, and const generics.",
            "patterns": [
              "const fn calls",
              "Literal arithmetic",
              "Array size expressions"
            ]
          },
          "samples": [
            {
              "file": "iceoryx2/src/constants.rs",
              "line": [
                14
              ],
              "code": "pub const MAX_SERVICE_NAME_LENGTH: usize = 255;",
              "purpose": "Compile-time constant defining maximum length for service names"
            },
            {
              "file": "iceoryx2/src/service/builder/mod.rs",
              "line": [
                66
              ],
              "code": "const RETRY_LIMIT: usize = 5;",
              "purpose": "Compile-time constant for service builder retry limit"
            },
            {
              "file": "iceoryx2/src/port/details/channel_management.rs",
              "line": [
                17, 18
              ],
              "code": "pub(crate) const INVALID_CHANNEL_STATE: u64 = u64::MAX;\nconst DISCONNECT_HINT_BIT: u64 = 1u64 << 63;",
              "purpose": "Compile-time constants with arithmetic expressions for channel state management"
            }
          ],
          "count": 3964
        },
        "diverging_expressions": {
          "fls_section": "6.1.3",
          "fls_ids": [],
          "description": "Diverging Expressions",
          "status": "demonstrated",
          "findings": {
            "description": "Expressions that never complete normally (panic!, return, break, continue).",
            "patterns": [
              "panic! for invariant violations",
              "return for early exit",
              "continue for loop control"
            ]
          },
          "samples": [
            {
              "file": "iceoryx2-bb/posix/src/scheduler.rs",
              "line": [
                59, 60, 61
              ],
              "code": "-1 => {\n                fatal_panic!(\"This should never happen! Unable to acquire minimum priority for scheduler {:#?}.\", self);\n            }",
              "purpose": "Diverging expression handling impossible error case when acquiring scheduler priority"
            },
            {
              "file": "iceoryx2-bb/posix/src/process_state.rs",
              "line": [
                568, 569, 570
              ],
              "code": "None => {\n                unreachable!()\n            }",
              "purpose": "Unreachable diverging expression for path that should never be taken"
            },
            {
              "file": "iceoryx2-bb/lock-free/src/mpmc/unique_index_set.rs",
              "line": [
                291
              ],
              "code": "fatal_panic!(from self, \"Memory already initialized. Initializing it twice may lead to undefined behavior.\");",
              "purpose": "Fatal panic to prevent double initialization which would cause undefined behavior"
            }
          ],
          "count": 607
        },
        "place_expressions": {
          "fls_section": "6.1.4",
          "fls_ids": [
            "fls_6ydylimiv553"
          ],
          "description": "Place Expressions",
          "status": "demonstrated",
          "findings": {
            "description": "Expressions representing memory locations. Variables, dereferences, field accesses, and indexing."
          },
          "samples": [],
          "count": null,
          "count_methodology": "Conceptual - place is semantic",
          "samples_waiver": {
            "reason": "conceptual_section",
            "explanation": "This section describes an abstract concept not directly mappable to concrete code patterns",
            "approved_by": "automated",
            "date": "2025-12-30"
          }
        },
        "value_expressions": {
          "fls_section": "6.1.5",
          "fls_ids": [
            "fls_e7zgqroy2qxn"
          ],
          "description": "Value Expressions",
          "status": "demonstrated",
          "findings": {
            "description": "Expressions that produce values rather than locations. Literals, function calls, operators."
          },
          "samples": [],
          "count": null,
          "count_methodology": "Conceptual - value is semantic",
          "samples_waiver": {
            "reason": "conceptual_section",
            "explanation": "This section describes an abstract concept not directly mappable to concrete code patterns",
            "approved_by": "automated",
            "date": "2025-12-30"
          }
        }
      },
      "count": null,
      "count_methodology": "Conceptual - classification is semantic",
      "samples_waiver": {
        "reason": "conceptual_section",
        "explanation": "This section describes an abstract concept not directly mappable to concrete code patterns",
        "approved_by": "automated",
        "date": "2025-12-30"
      }
    },
    "literal_expressions": {
      "fls_section": "6.2",
      "fls_ids": [
        "fls_h0dvogc64tfh"
      ],
      "description": "Literal Expressions",
      "status": "demonstrated",
      "findings": {
        "analyzed": true
      },
      "samples": [
        {
          "file": "iceoryx2-bb/container/src/string/utils.rs",
          "line": [
            40, 41, 42
          ],
          "code": "b'\\t' => vec![b'\\\\', b't'].into_iter(),\nb'\\r' => vec![b'\\\\', b'r'].into_iter(),\nb'\\n' => vec![b'\\\\', b'n'].into_iter(),",
          "purpose": "Byte character literals for escape sequence handling in string utilities"
        },
        {
          "file": "iceoryx2/src/constants.rs",
          "line": [
            14, 18
          ],
          "code": "pub const MAX_SERVICE_NAME_LENGTH: usize = 255;\npub const MAX_ATTRIBUTES: usize = 8;",
          "purpose": "Numeric literals defining configuration limits for services and attributes"
        },
        {
          "file": "iceoryx2/src/service/service_name.rs",
          "line": [
            41
          ],
          "code": "pub const INTERNAL_SERVICE_PREFIX: &str = \"iox2://\";",
          "purpose": "String literal defining the internal service name prefix"
        }
      ],
      "count": 51054
    },
    "path_expressions": {
      "fls_section": "6.3",
      "fls_ids": [
        "fls_6l60b5hwnjbm"
      ],
      "description": "Path Expressions",
      "status": "demonstrated",
      "findings": {
        "analyzed": true
      },
      "samples": [
        {
          "file": "iceoryx2-bb/system-types/src/path.rs",
          "line": [
            87
          ],
          "code": "let mut n = if let Some(&PATH_SEPARATOR) = value.first() {",
          "purpose": "Path expression accessing module constant PATH_SEPARATOR for path normalization"
        },
        {
          "file": "iceoryx2-cal/src/shared_memory/posix.rs",
          "line": [
            15, 16, 17
          ],
          "code": "pub type Memory<Allocator> = crate::shared_memory::common::details::Memory<\n    Allocator,\n    crate::dynamic_storage::posix_shared_memory::Storage<AllocatorDetails<Allocator>>,\n>;",
          "purpose": "Qualified path expressions for type alias with nested module paths"
        },
        {
          "file": "iceoryx2-bb/posix/src/scheduler.rs",
          "line": [
            77, 78, 79
          ],
          "code": "posix::SCHED_FIFO => Ok(Scheduler::Fifo),\nposix::SCHED_RR => Ok(Scheduler::RoundRobin),\nposix::SCHED_OTHER => Ok(Scheduler::Other),",
          "purpose": "Path expressions referencing POSIX scheduler constants in match arms"
        }
      ],
      "count": 39291
    },
    "block_expressions": {
      "fls_section": "6.4",
      "fls_ids": [
        "fls_hndm19t57wby"
      ],
      "description": "Block Expressions",
      "status": "demonstrated",
      "findings": {
        "analyzed": true
      },
      "samples": [
        {
          "file": "iceoryx2-bb/memory/src/bump_allocator.rs",
          "line": [48, 49, 50, 51, 52, 53, 54],
          "code": "pub fn new(ptr: NonNull<u8>, size: usize) -> Self {\n    Self {\n        start: ptr.as_ptr() as usize,\n        size,\n        current_position: AtomicUsize::new(0),\n    }\n}",
          "purpose": "Block expression initializing BumpAllocator struct with field assignments for memory management"
        },
        {
          "file": "iceoryx2-cal/src/dynamic_storage/posix_shared_memory.rs",
          "line": [207, 208, 209, 210],
          "code": "let shm = loop {\n    match SharedMemoryBuilder::new(&full_name).open_existing(AccessMode::ReadWrite) {\n        Ok(v) => break v,",
          "purpose": "Block expression with loop returning shared memory handle through break expression"
        },
        {
          "file": "iceoryx2/src/waitset.rs",
          "line": [594, 595, 596, 597, 598, 599],
          "code": "let call = |idx: DeadlineQueueIndex| -> CallbackProgression {\n    let progression = if let Some(reactor_idx) = deadline_to_attachment.get(&idx) {\n        fn_call(WaitSetAttachmentId::deadline(self, *reactor_idx, idx))\n    } else {\n        fn_call(WaitSetAttachmentId::tick(self, idx))\n    };",
          "purpose": "Block expression in closure handling deadline queue callbacks for waitset event processing"
        }
      ],
      "subsections": {
        "async_blocks": {
          "fls_section": "6.4.1",
          "fls_ids": [
            "fls_aadan19t5006"
          ],
          "description": "Async Blocks",
          "status": "not_used",
          "findings": {
            "count": 0,
            "rationale": "Async intentionally avoided for deterministic real-time behavior"
          },
          "samples": [],
          "count": null,
          "count_methodology": "Pattern not defined for this section"
        },
        "const_blocks": {
          "fls_section": "6.4.2",
          "fls_ids": [],
          "description": "Const Blocks",
          "status": "demonstrated",
          "findings": {
            "count": 4,
            "description": "const { } blocks for compile-time evaluation in array initialization.",
            "patterns": [
              "[const { MaybeUninit::uninit() }; N]"
            ]
          },
          "samples": [],
          "count": null,
          "count_methodology": "Pattern not defined for this section",
          "samples_waiver": {
            "reason": "conceptual_section",
            "explanation": "This section describes an abstract concept not directly mappable to concrete code patterns",
            "approved_by": "automated",
            "date": "2025-12-30"
          }
        },
        "named_blocks": {
          "fls_section": "6.4.3",
          "fls_ids": [],
          "description": "Named Blocks",
          "status": "limited_use",
          "findings": {
            "description": "Named blocks ('label: { }) for break targets. Limited use in iceoryx2."
          },
          "samples": [],
          "count": null,
          "count_methodology": "Pattern not defined for this section",
          "samples_waiver": {
            "reason": "conceptual_section",
            "explanation": "This section describes an abstract concept not directly mappable to concrete code patterns",
            "approved_by": "automated",
            "date": "2025-12-30"
          }
        },
        "unsafe_blocks": {
          "fls_section": "6.4.4",
          "fls_ids": [
            "fls_8wnyln2nmg4y"
          ],
          "description": "Unsafe Blocks",
          "status": "demonstrated",
          "findings": {
            "count": 2372,
            "change": "+39% from v0.7.0",
            "description": "Unsafe blocks enable unsafe operations within safe code.",
            "contexts": [
              "FFI calls",
              "Raw pointer ops",
              "Union field access",
              "Static mut access"
            ]
          },
          "samples": [],
          "count": null,
          "count_methodology": "Pattern not defined for this section",
          "samples_waiver": {
            "reason": "conceptual_section",
            "explanation": "This section describes an abstract concept not directly mappable to concrete code patterns",
            "approved_by": "automated",
            "date": "2025-12-30"
          }
        }
      },
      "count": 4934
    },
    "operator_expressions": {
      "fls_section": "6.5",
      "fls_ids": [
        "fls_izdv9i4spokw"
      ],
      "description": "Operator Expressions",
      "status": "demonstrated",
      "findings": {
        "error_propagation": 3443,
        "type_casts": 2312,
        "dereferences": 6176
      },
      "samples": [],
      "subsections": {
        "borrow_expression": {
          "fls_section": "6.5.1",
          "fls_ids": [
            "fls_qztk0bkju9u"
          ],
          "description": "Borrow Expression",
          "status": "demonstrated",
          "findings": {
            "description": "Borrow expressions (&expr, &mut expr) create references. Extensively used.",
            "patterns": [
              "&self for shared access",
              "&mut self for mutable access"
            ]
          },
          "samples": [],
          "count": null,
          "count_methodology": "Pattern not defined for this section",
          "samples_waiver": {
            "reason": "conceptual_section",
            "explanation": "This section describes an abstract concept not directly mappable to concrete code patterns",
            "approved_by": "automated",
            "date": "2025-12-30"
          }
        },
        "dereference_expression": {
          "fls_section": "6.5.2",
          "fls_ids": [
            "fls_5cm4gkt55hjh"
          ],
          "description": "Dereference Expression",
          "status": "demonstrated",
          "findings": {
            "count": 6176,
            "description": "Dereference (*expr) accesses the value behind a pointer/reference.",
            "note": "Raw pointer deref requires unsafe"
          },
          "samples": [],
          "count": null,
          "count_methodology": "Pattern not defined for this section",
          "samples_waiver": {
            "reason": "conceptual_section",
            "explanation": "This section describes an abstract concept not directly mappable to concrete code patterns",
            "approved_by": "automated",
            "date": "2025-12-30"
          }
        },
        "error_propagation_expression": {
          "fls_section": "6.5.3",
          "fls_ids": [
            "fls_pocsh1neugpc"
          ],
          "description": "Error Propagation Expression",
          "status": "demonstrated",
          "findings": {
            "count": 3443,
            "change": "+67% from v0.7.0",
            "description": "The ? operator propagates errors up the call stack."
          },
          "samples": [],
          "count": null,
          "count_methodology": "Pattern not defined for this section",
          "samples_waiver": {
            "reason": "conceptual_section",
            "explanation": "This section describes an abstract concept not directly mappable to concrete code patterns",
            "approved_by": "automated",
            "date": "2025-12-30"
          }
        },
        "negation_expression": {
          "fls_section": "6.5.4",
          "fls_ids": [
            "fls_wrecura8u5ar"
          ],
          "description": "Negation Expression",
          "status": "demonstrated",
          "findings": {
            "description": "Unary negation (- for numeric, ! for boolean/bitwise)."
          },
          "samples": [],
          "count": null,
          "count_methodology": "Pattern not defined for this section",
          "samples_waiver": {
            "reason": "conceptual_section",
            "explanation": "This section describes an abstract concept not directly mappable to concrete code patterns",
            "approved_by": "automated",
            "date": "2025-12-30"
          }
        },
        "arithmetic_expressions": {
          "fls_section": "6.5.5",
          "fls_ids": [
            "fls_1k9mkv7rbezi"
          ],
          "description": "Arithmetic Expressions",
          "status": "demonstrated",
          "findings": {
            "description": "Binary arithmetic (+, -, *, /, %) used for numeric calculations.",
            "note": "Division/modulo can panic on zero"
          },
          "samples": [
            {
              "file": "iceoryx2-bb/memory/src/bump_allocator.rs",
              "line": [87],
              "code": "aligned_position = align(self.start + current_position, layout.align()) - self.start;",
              "purpose": "Arithmetic addition and subtraction for memory alignment calculation in bump allocator"
            },
            {
              "file": "iceoryx2-bb/lock-free/src/mpmc/unique_index_set.rs",
              "line": [296],
              "code": "core::mem::size_of::<u32>() * (self.capacity + 1) as usize,",
              "purpose": "Arithmetic multiplication for calculating memory size of unique index set"
            },
            {
              "file": "iceoryx2-bb/elementary/src/math.rs",
              "line": [61, 62],
              "code": "remainder = quotient % 64;\nquotient /= 64;",
              "purpose": "Modulo and division for base64 encoding conversion"
            }
          ],
          "count": 43589
        },
        "bit_expressions": {
          "fls_section": "6.5.6",
          "fls_ids": [
            "fls_abp6tjbz8tpn"
          ],
          "description": "Bit Expressions",
          "status": "demonstrated",
          "findings": {
            "description": "Bitwise operators (&, |, ^, <<, >>) used for flags and low-level manipulation."
          },
          "samples": [
            {
              "file": "iceoryx2-bb/lock-free/src/mpmc/unique_index_set.rs",
              "line": [261, 262, 263],
              "code": "head: ((value >> 40) as u32) & 0xffffff,\naba: (value >> 24) as u16,\nborrowed_indices: (value as u32) & 0xffffff,",
              "purpose": "Right shift and bitwise AND for extracting packed fields from 64-bit head details"
            },
            {
              "file": "iceoryx2-bb/lock-free/src/mpmc/unique_index_set.rs",
              "line": [268, 269, 270],
              "code": "(((self.head & 0x00ffffff) as u64) << 40)\n    | ((self.aba as u64) << 24)\n    | ((self.borrowed_indices & 0x00ffffff) as u64)",
              "purpose": "Left shift and bitwise OR for packing head, aba counter, and borrowed indices into u64"
            },
            {
              "file": "iceoryx2-cal/src/shm_allocator/pointer_offset.rs",
              "line": [72, 73],
              "code": "self.0 &= !((1u64 << SegmentIdUnderlyingType::BITS) - 1);\nself.0 |= value.0 as u64;",
              "purpose": "Bitwise AND-NOT and OR for setting segment ID in pointer offset encoding"
            }
          ],
          "count": 15747
        },
        "comparison_expressions": {
          "fls_section": "6.5.7",
          "fls_ids": [
            "fls_nsvzzbldhq53"
          ],
          "description": "Comparison Expressions",
          "status": "demonstrated",
          "findings": {
            "description": "Comparison operators (==, !=, <, >, <=, >=) for ordering and equality."
          },
          "samples": [
            {
              "file": "iceoryx2-bb/memory/src/bump_allocator.rs",
              "line": [88],
              "code": "if aligned_position + layout.size() > self.size {",
              "purpose": "Greater-than comparison checking if allocation would exceed available memory"
            },
            {
              "file": "iceoryx2-bb/system-types/src/ipv4_address.rs",
              "line": [62, 63],
              "code": "if counter != 4 {\n    fail!(from origin, with Ipv4AddressParseError::WrongFormat,",
              "purpose": "Not-equal comparison validating IPv4 address has exactly 4 octets"
            },
            {
              "file": "iceoryx2-cal/src/dynamic_storage/posix_shared_memory.rs",
              "line": [246],
              "code": "if package_version.to_u64() == 0 {",
              "purpose": "Equality comparison checking if dynamic storage version is uninitialized"
            }
          ],
          "count": 39847
        },
        "lazy_boolean_expressions": {
          "fls_section": "6.5.8",
          "fls_ids": [
            "fls_lstusiu2c8lu"
          ],
          "description": "Lazy Boolean Expressions",
          "status": "demonstrated",
          "findings": {
            "description": "Short-circuit operators (&&, ||) for boolean logic with lazy evaluation."
          },
          "samples": [
            {
              "file": "iceoryx2-bb/system-types/src/ipv4_address.rs",
              "line": [97, 98, 99, 100],
              "code": "pub const fn is_private(&self) -> bool {\n    self.compare([10, 0, 0, 0], 8)\n        || self.compare([192, 168, 0, 0], 16)\n        || self.compare([172, 16, 0, 0], 12)\n}",
              "purpose": "Lazy OR evaluation for checking if IPv4 address is in any private range"
            },
            {
              "file": "iceoryx2-bb/posix/src/unix_datagram_socket.rs",
              "line": [343, 344, 345],
              "code": "let new_flags = match value {\n    true => current_flags | posix::O_NONBLOCK,\n    false => current_flags & !posix::O_NONBLOCK,\n};",
              "purpose": "Boolean match for setting or clearing non-blocking flag on socket"
            },
            {
              "file": "iceoryx2-bb/memory/src/pool_allocator.rs",
              "line": [176, 177, 178],
              "code": "!(position < self.start\n    || position > self.start + self.size\n    || (position - self.start) % self.bucket_size != 0)",
              "purpose": "Lazy OR evaluation checking if pointer is outside allocator bounds or misaligned"
            }
          ],
          "count": 602
        },
        "raw_borrow_expression": {
          "fls_section": "6.5.9",
          "fls_ids": [],
          "description": "Raw Borrow Expression",
          "status": "demonstrated",
          "findings": {
            "description": "&raw const and &raw mut for creating raw pointers without going through references.",
            "note": "Used in unsafe code for low-level memory operations"
          },
          "samples": [],
          "count": null,
          "count_methodology": "Pattern not defined for this section",
          "samples_waiver": {
            "reason": "conceptual_section",
            "explanation": "This section describes an abstract concept not directly mappable to concrete code patterns",
            "approved_by": "automated",
            "date": "2025-12-30"
          }
        },
        "type_cast_expressions": {
          "fls_section": "6.5.10",
          "fls_ids": [
            "fls_1qhsun1vyarz"
          ],
          "description": "Type Cast Expressions",
          "status": "demonstrated",
          "findings": {
            "count": 2312,
            "description": "The 'as' operator for type coercion.",
            "patterns": [
              "Numeric conversions",
              "Pointer casts",
              "Reference to pointer"
            ]
          },
          "samples": [
            {
              "file": "iceoryx2-bb/posix/src/unix_datagram_socket.rs",
              "line": [364, 365],
              "code": "(value as *const T) as *const posix::void,\ncore::mem::size_of::<T>() as u32,",
              "purpose": "Type cast for pointer conversion and size conversion in socket option setting"
            },
            {
              "file": "iceoryx2-bb/memory/src/pool_allocator.rs",
              "line": [185, 186, 187],
              "code": "let position = ptr.as_ptr() as usize;\n\n((position - self.start) / self.bucket_size) as u32",
              "purpose": "Type cast converting calculated bucket index to u32 after pointer arithmetic"
            },
            {
              "file": "iceoryx2-bb/system-types/src/ipv4_address.rs",
              "line": [72, 73],
              "code": "pub const fn new(a: u8, b: u8, c: u8, d: u8) -> Self {\n    Self(((a as u32) << 24) | ((b as u32) << 16) | ((c as u32) << 8) | d as u32)",
              "purpose": "Type cast converting u8 octets to u32 for IPv4 address packing"
            }
          ],
          "count": 5278
        },
        "assignment_expressions": {
          "fls_section": "6.5.11",
          "fls_ids": [
            "fls_y4by2i8dl05o"
          ],
          "description": "Assignment Expressions",
          "status": "demonstrated",
          "findings": {
            "description": "Assignment (=) stores a value in a place expression."
          },
          "samples": [
            {
              "file": "iceoryx2-bb/posix/src/unix_datagram_socket.rs",
              "line": [349],
              "code": "self.is_non_blocking.store(value, Ordering::Relaxed);",
              "purpose": "Assignment storing non-blocking flag value in atomic boolean"
            },
            {
              "file": "iceoryx2-bb/memory/src/bump_allocator.rs",
              "line": [87],
              "code": "aligned_position = align(self.start + current_position, layout.align()) - self.start;",
              "purpose": "Assignment of calculated aligned memory position for allocation"
            },
            {
              "file": "iceoryx2-bb/container/src/vec.rs",
              "line": [186, 187, 188, 189],
              "code": ".write(MaybeUninit::new(value))\n};\n\nself.len += 1;",
              "purpose": "Assignment incrementing vector length after pushing element via MaybeUninit"
            }
          ],
          "subsections": {
            "basic_assignment": {
              "fls_section": "6.5.11.1",
              "fls_ids": [
                "fls_nnqlae9zp80s"
              ],
              "description": "Basic Assignment",
              "status": "demonstrated",
              "findings": {
                "description": "Simple assignment to a single place (x = expr)."
              },
              "samples": [],
              "count": null,
              "count_methodology": "Pattern not defined for this section",
              "samples_waiver": {
                "reason": "conceptual_section",
                "explanation": "This section describes an abstract concept not directly mappable to concrete code patterns",
                "approved_by": "automated",
                "date": "2025-12-30"
              }
            },
            "destructuring_assignment": {
              "fls_section": "6.5.11.2",
              "fls_ids": [
                "fls_9beohh5475s2"
              ],
              "description": "Destructuring Assignment",
              "status": "demonstrated",
              "findings": {
                "description": "Assignment with pattern destructuring ((a, b) = expr)."
              },
              "samples": [],
              "count": null,
              "count_methodology": "Pattern not defined for this section",
              "samples_waiver": {
                "reason": "conceptual_section",
                "explanation": "This section describes an abstract concept not directly mappable to concrete code patterns",
                "approved_by": "automated",
                "date": "2025-12-30"
              }
            }
          },
          "count": 24780
        },
        "compound_assignment_expressions": {
          "fls_section": "6.5.12",
          "fls_ids": [
            "fls_290jmzfh7x4e"
          ],
          "description": "Compound Assignment Expressions",
          "status": "demonstrated",
          "findings": {
            "description": "Compound assignment (+=, -=, *=, etc.) combines operation with assignment."
          },
          "samples": [
            {
              "file": "iceoryx2-bb/system-types/src/ipv4_address.rs",
              "line": [57, 58, 59],
              "code": "ipv4[n] = fail!(from origin, when value.parse::<u8>(),\n                \"{msg} \\\"{input}\\\" since some entries are not an u8 number.\");\ncounter += 1;",
              "purpose": "Compound addition assignment incrementing counter after parsing IPv4 octet"
            },
            {
              "file": "iceoryx2-bb/posix/src/socket_ancillary.rs",
              "line": [385, 386],
              "code": "self.file_descriptors.push(fd);\n}\n\ni += SIZE_OF_FD;",
              "purpose": "Compound addition advancing index by file descriptor size when extracting from ancillary data"
            },
            {
              "file": "iceoryx2-cal/src/shm_allocator/pointer_offset.rs",
              "line": [72, 73],
              "code": "self.0 &= !((1u64 << SegmentIdUnderlyingType::BITS) - 1);\nself.0 |= value.0 as u64;",
              "purpose": "Compound AND-assign and OR-assign for updating segment ID bits in pointer offset"
            }
          ],
          "count": 278
        }
      },
      "count": null,
      "count_methodology": "Aggregate of operator subtypes",
      "samples_waiver": {
        "reason": "conceptual_section",
        "explanation": "This section describes an abstract concept not directly mappable to concrete code patterns",
        "approved_by": "automated",
        "date": "2025-12-30"
      }
    },
    "underscore_expressions": {
      "fls_section": "6.6",
      "fls_ids": [
        "fls_tpwp86mronn2"
      ],
      "description": "Underscore Expressions",
      "status": "demonstrated",
      "findings": {
        "analyzed": true
      },
      "samples": [
        {
          "file": "iceoryx2-bb/posix/src/directory.rs",
          "line": [292],
          "code": "let _ = Directory::remove(path);",
          "purpose": "Underscore expression discarding Result from cleanup operation during error handling"
        },
        {
          "file": "iceoryx2/src/port/notifier.rs",
          "line": [142, 143],
          "code": "for _ in 0..size {\n    new_self.connections.push(UnsafeCell::new(None))",
          "purpose": "Underscore pattern in for loop ignoring iteration index when initializing connections"
        },
        {
          "file": "iceoryx2/src/port/details/channel_management.rs",
          "line": [35],
          "code": "let _ = self.channel_state(channel_id).compare_exchange(",
          "purpose": "Underscore discarding compare_exchange result in channel state transition"
        }
      ],
      "count": 4533
    },
    "parenthesized_expressions": {
      "fls_section": "6.7",
      "fls_ids": [
        "fls_g0uyl7qw4c7w"
      ],
      "description": "Parenthesized Expressions",
      "status": "demonstrated",
      "findings": {
        "analyzed": true
      },
      "samples": [
        {
          "file": "iceoryx2-bb/memory/src/pool_allocator.rs",
          "line": [170],
          "code": "(ptr.as_ptr() as usize + size - adjusted_start) / bucket_size",
          "purpose": "Parenthesized expression grouping arithmetic for bucket count calculation"
        },
        {
          "file": "iceoryx2-cal/src/shm_allocator/pointer_offset.rs",
          "line": [57],
          "code": "Self(((offset as u64) << (SegmentIdUnderlyingType::BITS)) | segment_id.value() as u64)",
          "purpose": "Nested parentheses for bit shift precedence in pointer offset construction"
        },
        {
          "file": "iceoryx2-bb/lock-free/src/mpmc/unique_index_set.rs",
          "line": [268],
          "code": "(((self.head & 0x00ffffff) as u64) << 40)",
          "purpose": "Multiple parentheses ensuring correct evaluation order for bit packing"
        }
      ],
      "count": 15399
    },
    "array_expressions": {
      "fls_section": "6.8",
      "fls_ids": [
        "fls_xinykul167l"
      ],
      "description": "Array Expressions",
      "status": "demonstrated",
      "findings": {
        "analyzed": true
      },
      "samples": [
        {
          "file": "iceoryx2-bb/container/src/vector/static_vec.rs",
          "line": [160],
          "code": "data: [const { MaybeUninit::uninit() }; CAPACITY],",
          "purpose": "Array repeat expression with const block initializing StaticVec storage"
        },
        {
          "file": "iceoryx2-bb/posix/src/socket_ancillary.rs",
          "line": [254, 255],
          "code": "message_buffer: [0u8; BUFFER_CAPACITY],\niovec_buffer: [0u8; IOVEC_BUFFER_CAPACITY],",
          "purpose": "Array repeat expressions initializing zero-filled buffers for socket ancillary data"
        },
        {
          "file": "iceoryx2-bb/posix/src/user.rs",
          "line": [226],
          "code": "let mut buffer: [posix::c_char; PASSWD_BUFFER_SIZE] = [0; PASSWD_BUFFER_SIZE];",
          "purpose": "Array repeat expression creating zero-initialized password buffer"
        }
      ],
      "count": 489
    },
    "indexing_expressions": {
      "fls_section": "6.9",
      "fls_ids": [
        "fls_sxcr4aa098i6"
      ],
      "description": "Indexing Expressions",
      "status": "demonstrated",
      "findings": {
        "analyzed": true
      },
      "samples": [
        {
          "file": "iceoryx2-bb/system-types/src/path.rs",
          "line": [103, 104],
          "code": "raw_path[n] = PATH_SEPARATOR;\nn += 1;",
          "purpose": "Array indexing for writing path separator during path normalization"
        },
        {
          "file": "iceoryx2-bb/system-types/src/path.rs",
          "line": [108],
          "code": "raw_path[n..new_n].copy_from_slice(entry);",
          "purpose": "Range indexing for copying path entry bytes into buffer"
        },
        {
          "file": "iceoryx2-bb/system-types/src/file_path.rs",
          "line": [146],
          "code": "if 0 < buffer_len && path.as_bytes_const()[buffer_len - 1] != PATH_SEPARATOR {",
          "purpose": "Array indexing to check if path ends with separator"
        }
      ],
      "count": 8943
    },
    "tuple_expressions": {
      "fls_section": "6.10",
      "fls_ids": [
        "fls_k64tfywtn0g8"
      ],
      "description": "Tuple Expressions",
      "status": "demonstrated",
      "findings": {
        "analyzed": true
      },
      "samples": [
        {
          "file": "iceoryx2-bb/lock-free/src/mpmc/container.rs",
          "line": [132, 133, 134, 135, 136, 137],
          "code": "Self {\n    container_id,\n    current_change_counter: 0,\n    data: vec![MaybeUninit::uninit(); capacity],\n    active_index: vec![0; capacity],\n}",
          "purpose": "Struct expression initializing ContainerState with id and capacity"
        },
        {
          "file": "iceoryx2-bb/posix/src/socket_ancillary.rs",
          "line": [399, 400, 401, 402],
          "code": "self.credentials = Some(SocketCred {\n    pid: ProcessId::new(raw_cred.pid),\n    uid: Uid::new_from_native(raw_cred.uid),\n    gid: Gid::new_from_native(raw_cred.gid),\n});",
          "purpose": "Tuple-like credentials struct constructed from raw POSIX credential data"
        },
        {
          "file": "iceoryx2-bb/posix/src/memory_mapping.rs",
          "line": [226],
          "code": "File((FilePath, AccessMode)),",
          "purpose": "Tuple variant in enum for file-backed memory mapping with path and access mode"
        }
      ],
      "count": 4677
    },
    "struct_expressions": {
      "fls_section": "6.11",
      "fls_ids": [
        "fls_8tsynkj2cufj"
      ],
      "description": "Struct Expressions",
      "status": "demonstrated",
      "findings": {
        "analyzed": true
      },
      "samples": [
        {
          "file": "iceoryx2-bb/memory/src/bump_allocator.rs",
          "line": [48, 49, 50, 51, 52, 53],
          "code": "pub fn new(ptr: NonNull<u8>, size: usize) -> Self {\n    Self {\n        start: ptr.as_ptr() as usize,\n        size,\n        current_position: AtomicUsize::new(0),\n    }\n}",
          "purpose": "Struct expression constructing BumpAllocator with field initializers"
        },
        {
          "file": "iceoryx2-bb/lock-free/src/mpmc/unique_index_set.rs",
          "line": [259, 260, 261, 262, 263, 264],
          "code": "fn from(value: u64) -> Self {\n    Self {\n        head: ((value >> 40) as u32) & 0xffffff,\n        aba: (value >> 24) as u16,\n        borrowed_indices: (value as u32) & 0xffffff,\n    }\n}",
          "purpose": "Struct expression constructing HeadDetails from packed u64 value"
        },
        {
          "file": "iceoryx2-bb/posix/src/memory_mapping.rs",
          "line": [241, 242, 243, 244, 245, 246],
          "code": "fn new() -> Self {\n    Self {\n        initial_permission: MappingPermission::ReadWrite,\n        mapping_address_hint: 0,\n        enforce_mapping_address_hint: false,\n        size: 0,\n        offset: 0,\n    }\n}",
          "purpose": "Struct expression initializing MemoryMappingBuilder with default values"
        }
      ],
      "count": 583
    },
    "invocation_expressions": {
      "fls_section": "6.12",
      "fls_ids": [],
      "description": "Invocation Expressions",
      "status": "demonstrated",
      "findings": {
        "analyzed": true
      },
      "samples": [
        {
          "file": "iceoryx2-bb/system-types/src/path.rs",
          "line": [114],
          "code": "unsafe { Path::new_unchecked(&raw_path[0..n]) }",
          "purpose": "Unsafe function call constructing Path from normalized raw bytes"
        },
        {
          "file": "iceoryx2-bb/system-types/src/ipv4_address.rs",
          "line": [67],
          "code": "Ok(Self::new(ipv4[0], ipv4[1], ipv4[2], ipv4[3]))",
          "purpose": "Associated function call constructing Ipv4Address from parsed octets"
        },
        {
          "file": "iceoryx2-bb/posix/src/unix_datagram_socket.rs",
          "line": [409, 410],
          "code": "let mut socket_address = posix::sockaddr_un::new_zeroed();\nsocket_address.sun_family = posix::AF_UNIX;",
          "purpose": "Function call creating zero-initialized socket address structure"
        }
      ],
      "subsections": {
        "call_expressions": {
          "fls_section": "6.12.1",
          "fls_ids": [
            "fls_xa4nbfas01cj"
          ],
          "description": "Call Expressions",
          "status": "demonstrated",
          "findings": {
            "description": "Function call expressions invoke functions and closures.",
            "patterns": [
              "Function::new()",
              "closure(args)"
            ]
          },
          "samples": [
            {
              "file": "iceoryx2-bb/memory/src/bump_allocator.rs",
              "line": [87],
              "code": "aligned_position = align(self.start + current_position, layout.align()) - self.start;",
              "purpose": "Function call to align() for calculating aligned memory position"
            },
            {
              "file": "iceoryx2-bb/lock-free/src/mpmc/unique_index_set.rs",
              "line": [327],
              "code": "core::mem::size_of::<UnsafeCell<u32>>() * (capacity + 1) + core::mem::align_of::<u32>() - 1",
              "purpose": "Calls to size_of and align_of for calculating memory requirements"
            },
            {
              "file": "iceoryx2-cal/src/dynamic_storage/posix_shared_memory.rs",
              "line": [208],
              "code": "match SharedMemoryBuilder::new(&full_name).open_existing(AccessMode::ReadWrite) {",
              "purpose": "Chained call expressions for building and opening shared memory"
            }
          ],
          "count": 75389
        },
        "method_call_expressions": {
          "fls_section": "6.12.2",
          "fls_ids": [
            "fls_z7q8kbjwdc7g"
          ],
          "description": "Method Call Expressions",
          "status": "demonstrated",
          "findings": {
            "count": 28421,
            "change": "+50% from v0.7.0",
            "description": "Method call expressions (receiver.method()) heavily used."
          },
          "samples": [
            {
              "file": "iceoryx2-bb/memory/src/bump_allocator.rs",
              "line": [83, 84, 85],
              "code": "let mut current_position = self\n    .current_position\n    .load(core::sync::atomic::Ordering::Relaxed);",
              "purpose": "Method call loading atomic position value with relaxed ordering"
            },
            {
              "file": "iceoryx2-bb/posix/src/unix_datagram_socket.rs",
              "line": [338, 339, 340, 341, 342],
              "code": "let current_flags = self.fcntl(\n    posix::F_GETFL,\n    0,\n    \"Unable to acquire current socket filedescriptor flags\",\n)?;",
              "purpose": "Method call to fcntl for getting socket file descriptor flags"
            },
            {
              "file": "iceoryx2-bb/system-types/src/ipv4_address.rs",
              "line": [57, 58],
              "code": "ipv4[n] = fail!(from origin, when value.parse::<u8>(),\n                \"{msg} \\\"{input}\\\" since some entries are not an u8 number.\");",
              "purpose": "Method call parse::<u8>() for converting string to IPv4 octet"
            }
          ],
          "count": 36467
        },
        "call_conformance": {
          "fls_section": "6.12.3",
          "fls_ids": [],
          "description": "Call Conformance",
          "status": "demonstrated",
          "findings": {
            "description": "Call conformance rules ensure arguments match function signatures."
          },
          "samples": [],
          "count": null,
          "count_methodology": "Pattern not defined for this section",
          "samples_waiver": {
            "reason": "conceptual_section",
            "explanation": "This section describes an abstract concept not directly mappable to concrete code patterns",
            "approved_by": "automated",
            "date": "2025-12-30"
          }
        }
      },
      "count": null,
      "count_methodology": "Pattern not defined for this section",
      "samples_waiver": {
        "reason": "conceptual_section",
        "explanation": "This section describes an abstract concept not directly mappable to concrete code patterns",
        "approved_by": "automated",
        "date": "2025-12-30"
      }
    },
    "field_access_expressions": {
      "fls_section": "6.13",
      "fls_ids": [
        "fls_18k3uajrgq5f"
      ],
      "description": "Field Access Expressions",
      "status": "demonstrated",
      "findings": {
        "analyzed": true
      },
      "samples": [
        {
          "file": "iceoryx2-bb/memory/src/pool_allocator.rs",
          "line": [69, 70],
          "code": "bucket_size: usize,\nbucket_alignment: usize,",
          "purpose": "Field access expressions reading bucket configuration from PoolAllocator"
        },
        {
          "file": "iceoryx2-bb/memory/src/bump_allocator.rs",
          "line": [56, 57],
          "code": "pub fn start_address(&self) -> usize {\n    self.start\n}",
          "purpose": "Field access returning start address of bump allocator memory region"
        },
        {
          "file": "iceoryx2-bb/lock-free/src/mpmc/container.rs",
          "line": [115, 116, 117],
          "code": "pub fn index(&self) -> u32 {\n    self.index\n}",
          "purpose": "Field access returning underlying index from ContainerHandle"
        }
      ],
      "count": 52244
    },
    "closure_expressions": {
      "fls_section": "6.14",
      "fls_ids": [
        "fls_tjyexqrx0fx5"
      ],
      "description": "Closure Expressions",
      "status": "demonstrated",
      "findings": {
        "count": 1638,
        "change": "+157% from v0.7.0"
      },
      "samples": [
        {
          "file": "iceoryx2/src/waitset.rs",
          "line": [594, 595, 596, 597, 598],
          "code": "let call = |idx: DeadlineQueueIndex| -> CallbackProgression {\n    let progression = if let Some(reactor_idx) = deadline_to_attachment.get(&idx) {\n        fn_call(WaitSetAttachmentId::deadline(self, *reactor_idx, idx))\n    } else {\n        fn_call(WaitSetAttachmentId::tick(self, idx))\n    };",
          "purpose": "Closure expression handling deadline queue events with typed parameter and return"
        },
        {
          "file": "iceoryx2-bb/elementary/src/math.rs",
          "line": [46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57],
          "code": "let remainder_to_char = |value| -> char {\n    if value < 10 {\n        ((48 + value) as u8) as char\n    } else if value < 26 + 10 {\n        ((65 + value - 10) as u8) as char\n    } else if value < 62 {\n        ((97 + value - 10 - 26) as u8) as char\n    } else if value == 62 {\n        45 as char\n    } else {\n        95 as char\n    }\n};",
          "purpose": "Closure converting remainder to base64 character for encoding"
        },
        {
          "file": "iceoryx2/src/port/server.rs",
          "line": [390, 391],
          "code": "connections: (0..client_list.capacity())\n    .map(|_| UnsafeCell::new(None))\n    .collect(),",
          "purpose": "Closure in map creating UnsafeCell for each connection slot"
        }
      ],
      "count": 1617
    },
    "loop_expressions": {
      "fls_section": "6.15",
      "fls_ids": [
        "fls_rr908hgunja7"
      ],
      "description": "Loop Expressions",
      "status": "demonstrated",
      "findings": {
        "for": 1438,
        "while": 356,
        "loop": 130,
        "break": 128,
        "continue": 66
      },
      "samples": [
        {
          "file": "iceoryx2-bb/memory/src/bump_allocator.rs",
          "line": [86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102],
          "code": "loop {\n    aligned_position = align(self.start + current_position, layout.align()) - self.start;\n    if aligned_position + layout.size() > self.size {\n        fail!(from self, with AllocationError::OutOfMemory,\n            \"{} {:?} since there is not enough memory available.\", msg, layout);\n    }\n\n    match self.current_position.compare_exchange_weak(\n        current_position,\n        aligned_position + layout.size(),\n        core::sync::atomic::Ordering::Relaxed,\n        core::sync::atomic::Ordering::Relaxed,\n    ) {\n        Ok(_) => break,\n        Err(v) => current_position = v,\n    }\n}",
          "purpose": "Loop expression for lock-free allocation with compare-exchange retry"
        },
        {
          "file": "iceoryx2-cal/src/dynamic_storage/posix_shared_memory.rs",
          "line": [207, 208, 209],
          "code": "let shm = loop {\n    match SharedMemoryBuilder::new(&full_name).open_existing(AccessMode::ReadWrite) {\n        Ok(v) => break v,",
          "purpose": "Loop expression returning shared memory handle through value-carrying break"
        },
        {
          "file": "iceoryx2/src/waitset.rs",
          "line": [760, 761, 762, 763],
          "code": "loop {\n    match self.wait_and_process_once(&mut fn_call) {\n        Ok(WaitSetRunResult::AllEventsHandled) => (),\n        Ok(v) => return Ok(v),",
          "purpose": "Infinite loop for waitset event processing with callback-driven termination"
        }
      ],
      "subsections": {
        "for_loops": {
          "fls_section": "6.15.1",
          "fls_ids": [
            "fls_onfyolkcbeh3"
          ],
          "description": "For Loops",
          "status": "demonstrated",
          "findings": {
            "count": 1438,
            "change": "+24% from v0.7.0",
            "description": "For loops iterate over collections implementing IntoIterator."
          },
          "samples": [],
          "count": null,
          "count_methodology": "Pattern not defined for this section",
          "samples_waiver": {
            "reason": "conceptual_section",
            "explanation": "This section describes an abstract concept not directly mappable to concrete code patterns",
            "approved_by": "automated",
            "date": "2025-12-30"
          }
        },
        "infinite_loops": {
          "fls_section": "6.15.2",
          "fls_ids": [
            "fls_sf4qnd43z2wc"
          ],
          "description": "Infinite Loops",
          "status": "demonstrated",
          "findings": {
            "count": 130,
            "description": "loop {} for intentional infinite loops with break exit.",
            "patterns": [
              "Event loops",
              "Retry loops",
              "State machines"
            ]
          },
          "samples": [],
          "count": null,
          "count_methodology": "Pattern not defined for this section",
          "samples_waiver": {
            "reason": "conceptual_section",
            "explanation": "This section describes an abstract concept not directly mappable to concrete code patterns",
            "approved_by": "automated",
            "date": "2025-12-30"
          }
        },
        "while_loops": {
          "fls_section": "6.15.3",
          "fls_ids": [
            "fls_5jjm1kt43axd"
          ],
          "description": "While Loops",
          "status": "demonstrated",
          "findings": {
            "count": 356,
            "description": "Condition-controlled loops."
          },
          "samples": [],
          "count": null,
          "count_methodology": "Pattern not defined for this section",
          "samples_waiver": {
            "reason": "conceptual_section",
            "explanation": "This section describes an abstract concept not directly mappable to concrete code patterns",
            "approved_by": "automated",
            "date": "2025-12-30"
          }
        },
        "while_let_loops": {
          "fls_section": "6.15.4",
          "fls_ids": [
            "fls_m6kd5i9dy8dx"
          ],
          "description": "While Let Loops",
          "status": "demonstrated",
          "findings": {
            "count": 70,
            "description": "while let pattern = expr loops for iterating Option/Result."
          },
          "samples": [],
          "count": null,
          "count_methodology": "Pattern not defined for this section",
          "samples_waiver": {
            "reason": "conceptual_section",
            "explanation": "This section describes an abstract concept not directly mappable to concrete code patterns",
            "approved_by": "automated",
            "date": "2025-12-30"
          }
        },
        "loop_labels": {
          "fls_section": "6.15.5",
          "fls_ids": [
            "fls_uusi0zej55is"
          ],
          "description": "Loop Labels",
          "status": "limited_use",
          "findings": {
            "description": "Loop labels ('label: loop) for nested loop control. Rarely used."
          },
          "samples": [],
          "count": null,
          "count_methodology": "Pattern not defined for this section",
          "samples_waiver": {
            "reason": "conceptual_section",
            "explanation": "This section describes an abstract concept not directly mappable to concrete code patterns",
            "approved_by": "automated",
            "date": "2025-12-30"
          }
        },
        "break_expressions": {
          "fls_section": "6.15.6",
          "fls_ids": [
            "fls_jr4tpuyksr75"
          ],
          "description": "Break Expressions",
          "status": "demonstrated",
          "findings": {
            "count": 128,
            "description": "break exits loops, optionally with a value."
          },
          "samples": [
            {
              "file": "iceoryx2-bb/memory/src/bump_allocator.rs",
              "line": [98, 99, 100],
              "code": ") {\n    Ok(_) => break,\n    Err(v) => current_position = v,",
              "purpose": "Break exiting allocation loop after successful compare-exchange"
            },
            {
              "file": "iceoryx2-cal/src/dynamic_storage/posix_shared_memory.rs",
              "line": [208, 209, 210],
              "code": "match SharedMemoryBuilder::new(&full_name).open_existing(AccessMode::ReadWrite) {\n    Ok(v) => break v,\n    Err(SharedMemoryCreationError::DoesNotExist) => {",
              "purpose": "Break with value returning opened shared memory from loop expression"
            },
            {
              "file": "iceoryx2-bb/elementary/src/math.rs",
              "line": [66, 67],
              "code": "if quotient == 0 {\n    break;\n}",
              "purpose": "Break exiting base64 encoding loop when quotient reaches zero"
            }
          ],
          "count": 128
        },
        "continue_expressions": {
          "fls_section": "6.15.7",
          "fls_ids": [
            "fls_sjwrlwvpulp"
          ],
          "description": "Continue Expressions",
          "status": "demonstrated",
          "findings": {
            "count": 66,
            "description": "continue skips to the next iteration."
          },
          "samples": [
            {
              "file": "iceoryx2/src/pending_response.rs",
              "line": [314, 315, 316],
              "code": "if response.header().request_id != self.request.header().request_id {\n    continue;\n}",
              "purpose": "Continue skipping responses with non-matching request IDs"
            },
            {
              "file": "iceoryx2-bb/posix/src/socket_ancillary.rs",
              "line": [354, 355, 356, 357],
              "code": "if unsafe { (*cmsghdr).cmsg_level != CMSG_SOCKET_LEVEL } {\n    warn!(from receiver, \"A cmsghdr with the wrong cmsg_level was received...\");\n    continue;\n}",
              "purpose": "Continue to next cmsghdr when cmsg_level doesn't match expected socket level"
            },
            {
              "file": "iceoryx2/src/service/builder/request_response.rs",
              "line": [840, 841, 842, 843, 844],
              "code": "\"{} since the dynamic service information could not be opened ({:?}).\",\nmsg, e);\n}\n\ncontinue;",
              "purpose": "Continue to retry service creation loop after handling open error"
            }
          ],
          "count": 66
        }
      },
      "count": 130
    },
    "range_expressions": {
      "fls_section": "6.16",
      "fls_ids": [
        "fls_18swodqqzadj"
      ],
      "description": "Range Expressions",
      "status": "demonstrated",
      "findings": {
        "analyzed": true
      },
      "samples": [
        {
          "file": "iceoryx2/src/port/publisher.rs",
          "line": [259],
          "code": "for i in history_start..history.len() {",
          "purpose": "Exclusive range expression iterating over sample history for delivery"
        },
        {
          "file": "iceoryx2-bb/lock-free/src/mpmc/unique_index_set.rs",
          "line": [301],
          "code": "for i in 0..self.capacity + 1 {",
          "purpose": "Range expression initializing index set data with sequential values"
        },
        {
          "file": "iceoryx2-bb/system-types/src/user_name.rs",
          "line": [52],
          "code": "matches!(string[0], b'-' | b'0'..=b'9')",
          "purpose": "Inclusive range pattern in match checking for invalid username start characters"
        }
      ],
      "count": 1158
    },
    "if_and_if_let_expressions": {
      "fls_section": "6.17",
      "fls_ids": [
        "fls_nlzksiu8y3z9"
      ],
      "description": "If and If Let Expressions",
      "status": "demonstrated",
      "findings": {
        "analyzed": true
      },
      "samples": [
        {
          "file": "iceoryx2-bb/memory/src/bump_allocator.rs",
          "line": [88, 89, 90],
          "code": "if aligned_position + layout.size() > self.size {\n    fail!(from self, with AllocationError::OutOfMemory,\n        \"{} {:?} since there is not enough memory available.\", msg, layout);",
          "purpose": "If expression checking allocation would exceed available memory"
        },
        {
          "file": "iceoryx2/src/waitset.rs",
          "line": [595, 596, 597, 598],
          "code": "let progression = if let Some(reactor_idx) = deadline_to_attachment.get(&idx) {\n    fn_call(WaitSetAttachmentId::deadline(self, *reactor_idx, idx))\n} else {\n    fn_call(WaitSetAttachmentId::tick(self, idx))\n};",
          "purpose": "If-let expression distinguishing deadline vs tick attachments in waitset"
        },
        {
          "file": "iceoryx2-cal/src/dynamic_storage/posix_shared_memory.rs",
          "line": [246, 247, 248],
          "code": "if package_version.to_u64() == 0 {\n    if elapsed_time >= self.timeout {\n        fail!(from self, with DynamicStorageOpenError::InitializationNotYetFinalized,",
          "purpose": "Nested if expressions checking initialization state and timeout"
        }
      ],
      "subsections": {
        "if_expressions": {
          "fls_section": "6.17.1",
          "fls_ids": [
            "fls_mkut7gut49gi"
          ],
          "description": "If Expressions",
          "status": "demonstrated",
          "findings": {
            "count": 2444,
            "description": "Conditional branching based on boolean expression."
          },
          "samples": [
            {
              "file": "iceoryx2-bb/memory/src/bump_allocator.rs",
              "line": [78, 79, 80],
              "code": "if layout.size() == 0 {\n    fail!(from self, with AllocationError::SizeIsZero,\n        \"{} {:?} since the requested size was zero.\", msg, layout);",
              "purpose": "If expression validating allocation size is non-zero"
            },
            {
              "file": "iceoryx2-bb/posix/src/unix_datagram_socket.rs",
              "line": [334, 335, 336],
              "code": "if self.is_non_blocking.load(Ordering::Relaxed) == value {\n    return Ok(());\n}",
              "purpose": "If expression for early return when non-blocking mode unchanged"
            },
            {
              "file": "iceoryx2-bb/system-types/src/ipv4_address.rs",
              "line": [62, 63, 64],
              "code": "if counter != 4 {\n    fail!(from origin, with Ipv4AddressParseError::WrongFormat,\n        \"{msg} \\\"{input}\\\" since the address is incomplete.\");",
              "purpose": "If expression validating IPv4 address has all four octets"
            }
          ],
          "count": 2448
        },
        "if_let_expressions": {
          "fls_section": "6.17.2",
          "fls_ids": [
            "fls_p0t1ch115tra"
          ],
          "description": "If Let Expressions",
          "status": "demonstrated",
          "findings": {
            "count": 337,
            "description": "if let pattern = expr for conditional pattern matching.",
            "patterns": [
              "if let Some(x) = opt",
              "if let Ok(v) = result"
            ]
          },
          "samples": [
            {
              "file": "iceoryx2-bb/system-types/src/path.rs",
              "line": [87, 88, 89],
              "code": "let mut n = if let Some(&PATH_SEPARATOR) = value.first() {\n    raw_path[0] = PATH_SEPARATOR;\n    1",
              "purpose": "If-let expression checking if path starts with separator for normalization"
            },
            {
              "file": "iceoryx2/src/waitset.rs",
              "line": [595, 596, 597],
              "code": "let progression = if let Some(reactor_idx) = deadline_to_attachment.get(&idx) {\n    fn_call(WaitSetAttachmentId::deadline(self, *reactor_idx, idx))\n} else {",
              "purpose": "If-let expression extracting reactor index from deadline attachment map"
            },
            {
              "file": "iceoryx2-bb/posix/src/file.rs",
              "line": [621],
              "code": "if let Some(v) = file_descriptor {",
              "purpose": "If-let expression checking for valid file descriptor before use"
            }
          ],
          "count": 337
        }
      },
      "count": null,
      "count_methodology": "Pattern not defined for this section",
      "samples_waiver": {
        "reason": "conceptual_section",
        "explanation": "This section describes an abstract concept not directly mappable to concrete code patterns",
        "approved_by": "automated",
        "date": "2025-12-30"
      }
    },
    "match_expressions": {
      "fls_section": "6.18",
      "fls_ids": [
        "fls_e5td0fa92fay"
      ],
      "description": "Match Expressions",
      "status": "demonstrated",
      "findings": {
        "count": 1663,
        "change": "+134% from v0.7.0"
      },
      "samples": [
        {
          "file": "iceoryx2-bb/lock-free/src/mpmc/container.rs",
          "line": [97, 98, 99, 100, 101, 102],
          "code": "fn from(value: UniqueIndexSetAcquireFailure) -> Self {\n    match value {\n        UniqueIndexSetAcquireFailure::IsLocked => ContainerAddFailure::IsLocked,\n        UniqueIndexSetAcquireFailure::OutOfIndices => ContainerAddFailure::OutOfSpace,\n    }\n}",
          "purpose": "Match expression converting index set failure to container add failure"
        },
        {
          "file": "iceoryx2-bb/posix/src/unix_datagram_socket.rs",
          "line": [343, 344, 345, 346],
          "code": "let new_flags = match value {\n    true => current_flags | posix::O_NONBLOCK,\n    false => current_flags & !posix::O_NONBLOCK,\n};",
          "purpose": "Match expression setting or clearing non-blocking socket flag"
        },
        {
          "file": "iceoryx2-cal/src/dynamic_storage/posix_shared_memory.rs",
          "line": [208, 209, 210, 211, 212],
          "code": "match SharedMemoryBuilder::new(&full_name).open_existing(AccessMode::ReadWrite) {\n    Ok(v) => break v,\n    Err(SharedMemoryCreationError::DoesNotExist) => {\n        fail!(from self, with DynamicStorageOpenError::DoesNotExist,\n        \"{} since a shared memory with that name does not exists.\", msg);",
          "purpose": "Match expression handling shared memory open result with error variants"
        }
      ],
      "count": 1657
    },
    "return_expressions": {
      "fls_section": "6.19",
      "fls_ids": [
        "fls_8l74abhlxzdl"
      ],
      "description": "Return Expressions",
      "status": "demonstrated",
      "findings": {
        "analyzed": true
      },
      "samples": [
        {
          "file": "iceoryx2-bb/posix/src/unix_datagram_socket.rs",
          "line": [320, 321, 322],
          "code": "if result >= 0 {\n    return Ok(result);\n}",
          "purpose": "Early return with successful fcntl result when operation succeeds"
        },
        {
          "file": "iceoryx2-bb/posix/src/unix_datagram_socket.rs",
          "line": [334, 335, 336],
          "code": "if self.is_non_blocking.load(Ordering::Relaxed) == value {\n    return Ok(());\n}",
          "purpose": "Early return when non-blocking mode is already set to desired value"
        },
        {
          "file": "iceoryx2/src/pending_response.rs",
          "line": [318],
          "code": "return Ok(Some(response));",
          "purpose": "Return expression yielding received response matching request ID"
        }
      ],
      "count": 960
    },
    "await_expressions": {
      "fls_section": "6.20",
      "fls_ids": [
        "fls_hyrbmfmf6r8g"
      ],
      "description": "Await Expressions",
      "status": "not_used",
      "findings": {
        "count": 0,
        "rationale": "Async intentionally avoided for deterministic real-time IPC"
      },
      "samples": [],
      "count": 0
    },
    "expression_precedence": {
      "fls_section": "6.21",
      "fls_ids": [
        "fls_kw25194gpael"
      ],
      "description": "Expression Precedence",
      "status": "demonstrated",
      "findings": {
        "analyzed": true
      },
      "samples": [],
      "count": null,
      "count_methodology": "Pattern not defined for this section",
      "samples_waiver": {
        "reason": "conceptual_section",
        "explanation": "This section describes an abstract concept not directly mappable to concrete code patterns",
        "approved_by": "automated",
        "date": "2025-12-30"
      }
    },
    "capturing": {
      "fls_section": "6.22",
      "fls_ids": [
        "fls_jmjn8jkbzujm"
      ],
      "description": "Capturing",
      "status": "demonstrated",
      "findings": {
        "analyzed": true
      },
      "samples": [],
      "count": null,
      "count_methodology": "Pattern not defined for this section",
      "samples_waiver": {
        "reason": "conceptual_section",
        "explanation": "This section describes an abstract concept not directly mappable to concrete code patterns",
        "approved_by": "automated",
        "date": "2025-12-30"
      }
    },
    "arithmetic_overflow": {
      "fls_section": "6.23",
      "fls_ids": [],
      "description": "Arithmetic Overflow",
      "status": "demonstrated",
      "findings": {
        "analyzed": true
      },
      "samples": [],
      "count": null,
      "count_methodology": "Pattern not defined for this section",
      "samples_waiver": {
        "reason": "conceptual_section",
        "explanation": "This section describes an abstract concept not directly mappable to concrete code patterns",
        "approved_by": "automated",
        "date": "2025-12-30"
      }
    }
  },
  "safety_critical_summary": {
    "unsafe_block_usage": {
      "count": 2372,
      "change_from_v0_7_0": "+670 (+39%)",
      "contexts": [
        "Raw pointer dereferencing",
        "FFI function calls",
        "Memory layout operations",
        "Atomic operations",
        "Static mut access",
        "Union field access (new in v0.8.0)"
      ]
    },
    "error_handling": {
      "error_propagation": "3443 uses of ? operator (+67% from v0.7.0)",
      "unwrap_expect": "Extensive use for critical assertions",
      "match_expressions": "1663 exhaustive pattern matches (+134% from v0.7.0)"
    },
    "type_safety": {
      "type_casts": "4847 'as' casts for numeric conversions",
      "pointer_casts": "Raw pointer type conversions in unsafe blocks"
    }
  }
}