{
  "chapter": 11,
  "title": "Implementations",
  "fls_url": "https://rust-lang.github.io/fls/implementations.html",
  "codebase": "iceoryx2",
  "version": "0.8.0",
  "analysis_date": "2025-12-30",
  "version_changes": {
    "from_version": "0.7.0",
    "to_version": "0.8.0",
    "summary": "Major growth in implementations due to expanded codebase and FFI layer. Total impl blocks increased 77% (1353->2397), unsafe impl increased 232% (66->219) due to FFI types requiring Send/Sync.",
    "key_changes": [
      "Directory structure changed: iceoryx2-bb-*-0.7.0/ -> iceoryx2-bb/*/",
      "Total impl blocks increased from 1353 to 2397 (+77%)",
      "Trait implementations increased from 1163 to 956 (restructured counting)",
      "unsafe impl increased from 66 to 219 (+232%) for FFI type safety",
      "Generic implementations increased from 197 to 571 (+190%)",
      "Self keyword usage throughout implementations"
    ]
  },
  "summary": "FLS Chapter 11 defines implementations as items that supplement an implementing type by extending its functionality. There are two kinds: inherent implementations (adding direct functionality) and trait implementations (adding functionality specified by a trait). iceoryx2 v0.8.0 uses 2,397 impl blocks total, with heavy use of trait implementations for abstraction and unsafe impl for Send/Sync markers on IPC and FFI types.",

  "statistics": {
    "total_impl_blocks": 2397,
    "trait_implementations": 956,
    "generic_implementations": 571,
    "unsafe_trait_implementations": 219,
    "blanket_implementations": 1,
    "ref_implementations": 2
  },

  "syntax": {
    "Implementation": "InherentImplementation | TraitImplementation",
    "InherentImplementation": "impl GenericParameterList? ImplementingType WhereClause? ImplementationBody",
    "TraitImplementation": "unsafe? impl GenericParameterList? !? ImplementedTrait for ImplementingType WhereClause? ImplementationBody",
    "ImplementingType": "TypeSpecification",
    "ImplementedTrait": "TypePath",
    "ImplementationBody": "{ InnerAttributeOrDoc* AssociatedItem* }"
  },

  "legality_rules": {
    "11:1": {
      "rule": "An implementation is an item that supplements an implementing type by extending its functionality.",
      "status": "demonstrated",
      "count": 2397,
      "notes": "2,397 impl blocks extend types with methods, trait implementations, and associated items."
    },
    "11:2": {
      "rule": "An implementing type is the type that the associated items of an implementation are associated with.",
      "status": "demonstrated",
      "samples": [
        {
          "file": "iceoryx2/src/node/node_name.rs",
          "line": 30,
          "code": "impl NodeName {",
          "implementing_type": "NodeName"
        },
        {
          "file": "iceoryx2/src/node/mod.rs",
          "line": 213,
          "code": "impl NodeId {",
          "implementing_type": "NodeId"
        },
        {
          "file": "iceoryx2/src/node/mod.rs",
          "line": 1250,
          "code": "impl NodeBuilder {",
          "implementing_type": "NodeBuilder"
        }
      ]
    },
    "11:3": {
      "rule": "Within an implementation, the type Self acts as a type alias for the implementing type.",
      "status": "demonstrated",
      "samples": [
        {
          "file": "iceoryx2-bb/system-types/src/port.rs",
          "line": 31,
          "code": "pub const fn new(port: u16) -> Self {\n    Self(port)\n}",
          "notes": "Self used as return type and constructor"
        },
        {
          "file": "iceoryx2-bb/posix/src/permission.rs",
          "line": 53,
          "code": "pub fn none() -> Self {\n    Self(0)\n}"
        }
      ]
    },
    "11:4": {
      "rule": "An implementation body is a construct that encapsulates the associated items, inner attributes, and inner doc comments of an implementation.",
      "status": "demonstrated",
      "notes": "All impl blocks contain implementation bodies with associated functions, constants, and types."
    },
    "11:5": {
      "rule": "An inherent implementation is an implementation that adds direct functionality.",
      "status": "demonstrated",
      "samples": [
        {
          "file": "iceoryx2/src/node/mod.rs",
          "line": 332,
          "code": "impl NodeDetails {"
        },
        {
          "file": "iceoryx2/src/node/mod.rs",
          "line": 752,
          "code": "impl RegisteredServices {"
        },
        {
          "file": "iceoryx2-bb/elementary/src/alignment.rs",
          "line": 36,
          "code": "impl Alignment {"
        }
      ]
    },
    "11:6": {
      "rule": "Inherent implementations of the same implementing type shall be defined within the same crate.",
      "status": "compliant",
      "notes": "All inherent implementations are within their defining crates."
    },
    "11:7": {
      "rule": "A trait implementation is an implementation that adds functionality specified by a trait.",
      "status": "demonstrated",
      "count": 956,
      "samples": [
        {
          "file": "iceoryx2-bb/memory/src/one_chunk_allocator.rs",
          "line": 94,
          "code": "impl BaseAllocator for OneChunkAllocator {"
        },
        {
          "file": "iceoryx2-bb/system-types/src/port.rs",
          "line": 22,
          "code": "impl Display for Port {"
        }
      ]
    },
    "11:8": {
      "rule": "An unsafe trait implementation is a trait implementation subject to keyword unsafe.",
      "status": "demonstrated",
      "count": 219,
      "change_from_v0_7_0": "+153 (+232%)",
      "primary_uses": ["Send", "Sync", "ZeroCopySend"],
      "samples": [
        {
          "file": "iceoryx2-pal/posix/src/windows/win32_udp_port_to_uds_name.rs",
          "line": 216,
          "code": "unsafe impl Send for PortToUds {}"
        },
        {
          "file": "iceoryx2-pal/posix/src/windows/win32_handle_translator.rs",
          "line": 149,
          "code": "unsafe impl Send for HandleTranslator {}"
        },
        {
          "file": "iceoryx2-bb/container/src/string/relocatable_string.rs",
          "line": 119,
          "code": "unsafe impl Send for RelocatableString {}"
        },
        {
          "file": "iceoryx2-pal/posix/src/macos/pthread.rs",
          "line": 50,
          "code": "unsafe impl Sync for ThreadStates {}"
        },
        {
          "file": "iceoryx2/src/node/mod.rs",
          "line": 750,
          "code": "unsafe impl Sync for RegisteredServices {}"
        }
      ]
    },
    "11:9": {
      "rule": "An implemented trait is a trait whose functionality has been implemented by an implementing type.",
      "status": "demonstrated",
      "notes": "BaseAllocator, Display, Default, Drop, Send, Sync are common implemented traits."
    },
    "11:10": {
      "rule": "The type path of a trait implementation shall resolve to a trait.",
      "status": "compliant",
      "notes": "All trait implementations reference valid trait paths."
    },
    "11:11": {
      "rule": "A trait implementation shall be an unsafe trait implementation if and only if it implements an unsafe trait.",
      "status": "compliant",
      "notes": "Send and Sync are unsafe traits, all their implementations use 'unsafe impl'. Safe traits use regular 'impl'."
    },
    "11:12": {
      "rule": "Trait implementations are subject to implementation coherence and implementation conformance.",
      "status": "compliant",
      "notes": "See sections 11.1 and 11.2 below."
    },
    "11:13": {
      "rule": "Inherent implementations of the same implementing type shall not define more than one associated item with the same name in the same namespace.",
      "status": "compliant"
    }
  },

  "implementation_coherence": {
    "section": "11.1",
    "description": "Rules ensuring trait implementations don't overlap and follow orphan rules",
    "rules": {
      "11.1:1": {
        "rule": "A trait implementation exhibits implementation coherence when it is valid and does not overlap with another trait implementation.",
        "status": "compliant",
        "notes": "All trait implementations are coherent - implementing local traits on local types or std traits on local types."
      },
      "11.1:2": {
        "rule": "Two trait implementations of the same implemented trait overlap when the intersection of the implementing types is non-empty.",
        "status": "compliant",
        "notes": "No overlapping implementations found."
      },
      "11.1:3_to_11.1:7": {
        "rule": "Validity rules: trait is fundamental/local, OR at least one type is fundamental/local AND type parameters follow coverage rules.",
        "status": "compliant",
        "patterns": [
          "Local trait on local type: impl BaseAllocator for PoolAllocator",
          "Std trait on local type: impl Display for Permission",
          "Std trait on generic local type: impl<T> Default for TypedUniqueId<T>"
        ]
      },
      "11.1:17": {
        "rule": "A trait implementation shall be coherent.",
        "status": "compliant"
      }
    }
  },

  "implementation_conformance": {
    "section": "11.2",
    "description": "Rules ensuring trait implementations satisfy the constraints of their implemented trait",
    "rules": {
      "11.2:1": {
        "rule": "A trait implementation exhibits implementation conformance when it satisfies the constraints of its implemented trait.",
        "status": "demonstrated"
      },
      "11.2:2_to_11.2:4": {
        "rule": "Associated constants are conformant when names match and types are subtypes.",
        "status": "demonstrated"
      },
      "11.2:5_to_11.2:7": {
        "rule": "Associated functions are conformant when signatures are subtypes and bounds are more general.",
        "status": "demonstrated"
      },
      "11.2:8_to_11.2:10": {
        "rule": "Associated types are conformant when names match and type specification conforms to bounds.",
        "status": "demonstrated",
        "notes": "GAT implementations provide concrete types that satisfy trait bounds."
      },
      "11.2:15": {
        "rule": "A trait implementation shall be conformant.",
        "status": "compliant"
      }
    }
  },

  "implementation_patterns": {
    "inherent_impl_patterns": {
      "constructor_pattern": {
        "description": "pub const fn new() -> Self for type construction",
        "example": "impl HeapAllocator { pub const fn new() -> HeapAllocator { ... } }"
      },
      "associated_constants": {
        "description": "Constants defined directly on types",
        "example": "impl Permission { pub const OWNER_READ: Self = Self(0o0400); }"
      },
      "multiple_impl_blocks": {
        "description": "Same type can have multiple impl blocks for organization"
      }
    },
    "trait_impl_patterns": {
      "marker_trait_implementations": {
        "description": "unsafe impl Send/Sync for thread-safety declarations",
        "count": 219,
        "notes": "Critical for IPC and FFI types that cross thread boundaries"
      },
      "std_trait_implementations": {
        "Display": "For human-readable formatting",
        "Debug": "For debug formatting",
        "Default": "For default values",
        "Drop": "For cleanup on destruction",
        "From": "For type conversions"
      },
      "generic_implementations": {
        "description": "impl<T> Trait for Type<T>",
        "count": 571,
        "change_from_v0_7_0": "+374 (+190%)"
      }
    }
  },

  "unsafe_impl_analysis": {
    "total_count": 219,
    "change_from_v0_7_0": "+153 (+232%)",
    "breakdown": {
      "Send": "Thread transfer safety",
      "Sync": "Shared reference safety",
      "ZeroCopySend": "Zero-copy IPC safety"
    },
    "rationale": "IPC primitives and FFI types require manual verification of thread-safety properties that the compiler cannot infer. The increase is primarily due to the new FFI layer."
  },

  "generic_implementations": {
    "count": 571,
    "const_generic_impls": {
      "description": "Implementations parameterized by const generics",
      "samples": [
        {
          "file": "iceoryx2-bb/system-types/src/file_name.rs",
          "line": 193,
          "code": "impl<const CAPACITY: usize> core::fmt::Display for RestrictedFileName<CAPACITY>"
        }
      ]
    },
    "type_generic_impls": {
      "description": "Implementations parameterized by type parameters",
      "samples": [
        {
          "file": "iceoryx2-pal/concurrency-sync/src/iox_atomic.rs",
          "line": 147,
          "code": "impl<T: internal::AtomicInteger> Debug for IoxAtomic<T>"
        }
      ]
    }
  },

  "cross_chapter_references": {
    "chapter_3": "Implementations are items",
    "chapter_4": "Implementing types are types; trait implementations implement traits",
    "chapter_10": "Associated items within implementations",
    "chapter_12": "Generic parameters and where clauses on implementations",
    "chapter_17": "Send/Sync implementations for concurrency safety",
    "chapter_19": "Unsafe trait implementations"
  }
}
