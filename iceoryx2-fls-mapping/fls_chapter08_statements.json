{
  "chapter": 8,
  "title": "Statements",
  "fls_url": "https://rust-lang.github.io/fls/statements.html",
  "fls_id": "fls_wdicg3sqa98e",
  "repository": "eclipse-iceoryx/iceoryx2",
  "version": "0.8.0",
  "analysis_date": "2025-12-30",
  "version_changes": {
    "from_version": "0.7.0",
    "to_version": "0.8.0",
    "summary": "Significant increase in statement usage due to expanded codebase. Let statements increased 40%, macro statements increased substantially with debug_assert! now heavily used (634 instances). Let-else pattern now in use (6 instances).",
    "key_changes": [
      "Directory structure changed: iceoryx2-bb-*-0.7.0/ -> iceoryx2-bb/*/",
      "let statements increased from 9703 to 13605 (+40%)",
      "let mut statements increased from 1683 to 2338 (+39%)",
      "let with type ascription increased from 103 to 152 (+48%)",
      "let with tuple destructuring increased from 150 to 216 (+44%)",
      "Let-else pattern now in use (6 instances) - was NOT FOUND in v0.7.0",
      "debug_assert! heavily used (634 instances) - was minimal in v0.7.0",
      "assert_that! increased from 4571 to 5263 (+15%)",
      "fail! increased from 887 to 1065 (+20%)",
      "fatal_panic! increased from 192 to 320 (+67%)",
      "unimplemented! now used (161 instances)"
    ]
  },
  "summary": "FLS Chapter 8 defines statements - the executable units within block expressions. Statements include let statements for introducing bindings, expression statements for side effects, item statements for local declarations, macro statements, and empty statements.",
  "statistics": {
    "let_statements_total": 13605,
    "let_mut_statements": 2338,
    "let_with_type_ascription": 152,
    "let_with_tuple_destructuring": 216,
    "let_with_struct_pattern": 1,
    "let_else_statements": 6,
    "expression_statements_semicolons": 45398,
    "fn_declarations": 3941,
    "macro_statements": 8139
  },
  "sections": {
    "item_statement": {
      "fls_section": "8.-2.1",
      "fls_ids": [
        "fls_kdxe1ukmgl1"
      ],
      "description": "Item Statement",
      "status": "demonstrated",
      "findings": {
        "fls_reference": "8:2",
        "description": "An item statement is a statement expressed as an item, allowing items to be declared within block expressions (local scope). Common in iceoryx2 for test-local constants and helper functions.",
        "inner_const": "Used extensively in test functions for test-local constants",
        "inner_fn": "Less common, mostly in macro-generated code",
        "count": "~3232 inner function declarations"
      },
      "samples": [
        {
          "file": "iceoryx2/src/service/builder/request_response.rs",
          "line": [792],
          "code": "const OPEN_RETRY_LIMIT: usize = 5;",
          "purpose": "Local constant inside function defining retry limit for service opening"
        },
        {
          "file": "iceoryx2-bb/posix/src/unix_datagram_socket.rs",
          "line": [615],
          "code": "const FLAGS: i32 = 0;",
          "purpose": "Inner constant for sendmsg flags inside send_msg method"
        },
        {
          "file": "iceoryx2-bb/posix/src/directory.rs",
          "line": [458],
          "code": "const DOT: posix::c_char = b'.' as _;",
          "purpose": "Local constant for dot character comparison in directory iteration"
        }
      ],
      "count": 22288
    },
    "empty_statement": {
      "fls_section": "8.-2.2",
      "fls_ids": [
        "fls_fftdnwe22xrb"
      ],
      "description": "Empty Statement",
      "status": "not_used",
      "findings": {
        "fls_reference": "8:3",
        "description": "An empty statement is a statement expressed as character 0x3B (semicolon) that has no effect when executed.",
        "dynamic_semantics": "The execution of an empty statement has no effect.",
        "status": "Not intentionally used in iceoryx2 - empty statements are rare in production Rust code"
      },
      "samples": [],
      "count": 0
    },
    "macro_statement": {
      "fls_section": "8.-2.3",
      "fls_ids": [
        "fls_or125cqtxg9j"
      ],
      "description": "Macro Statement",
      "status": "demonstrated",
      "findings": {
        "fls_reference": "8:4",
        "description": "A macro statement is a statement expressed as a terminated macro invocation. Macro statements are heavily used in iceoryx2 for assertions, logging, and test infrastructure.",
        "assertion_macros": {
          "assert_that": 5263,
          "debug_assert": 634,
          "assert": 30,
          "assert_eq": 17
        },
        "error_macros": {
          "fail": 1065,
          "fatal_panic": 320,
          "panic": 107,
          "unreachable": 6
        },
        "development_macros": {
          "todo": 6,
          "unimplemented": 161,
          "test_requires": 93,
          "print_family": 437
        },
        "total_macro_statements": "~8139",
        "change_from_v0_7_0": "+1789 (~28% increase)"
      },
      "samples": [
        {
          "file": "iceoryx2-bb/memory/src/pool_allocator.rs",
          "line": [78, 79, 80],
          "code": "debug_assert!(\n    self.is_memory_initialized.load(Ordering::Relaxed),\n    \"From: {self:?}, Undefined behavior when calling \\\"{source}\\\" and the object is not initialized.\"\n);",
          "purpose": "Debug assertion verifying memory initialization before operations"
        },
        {
          "file": "iceoryx2-cal/src/zero_copy_connection/common.rs",
          "line": [657],
          "code": "debug_assert!(channel_id.value() < self.storage.get().channels.capacity());",
          "purpose": "Debug-only invariant check for channel ID bounds"
        },
        {
          "file": "iceoryx2-cal/src/zero_copy_connection/common.rs",
          "line": [688],
          "code": "debug_assert!(ptr.offset() % sample_size == 0);",
          "purpose": "Debug-only alignment validation for sample offsets"
        }
      ],
      "count": 10953
    },
    "empty_statement_execution": {
      "fls_section": "8.-3.1",
      "fls_ids": [
        "fls_dl763ssb54q1"
      ],
      "description": "Empty Statement Execution",
      "status": "not_applicable",
      "findings": {
        "description": "Dynamic semantics for empty statement execution - has no effect. Not applicable as empty statements are not used in iceoryx2."
      },
      "samples": [],
      "count": null,
      "count_methodology": "Pattern not defined for this section"
    },
    "let_statements": {
      "fls_section": "8.1",
      "fls_ids": [
        "fls_yivm43r5wnp1"
      ],
      "description": "Let Statements",
      "status": "demonstrated",
      "findings": {
        "description": "A let statement introduces new bindings by matching a pattern against a value. The primary mechanism for creating local variables in Rust.",
        "statistics": {
          "let_statements_total": 13605,
          "let_mut_statements": 2338,
          "let_with_type_ascription": 152,
          "let_with_tuple_destructuring": 216,
          "if_let_expressions": 337,
          "while_let_expressions": 70
        },
        "legality_rules": {
          "8.1:1": "let statements introduce bindings via pattern matching",
          "8.1:15": "A binding is uninitialized if the let statement lacks an initializer"
        },
        "patterns_used": [
          "Simple bindings: let x = expr;",
          "Mutable bindings: let mut x = expr;",
          "Type ascription: let x: Type = expr;",
          "Tuple destructuring: let (a, b) = expr;",
          "Struct destructuring: let Struct { field } = expr;"
        ],
        "let_else_status": "Not used - iceoryx2 uses if let / match instead"
      },
      "samples": [
        {
          "file": "iceoryx2/src/config.rs",
          "line": [237, 238],
          "code": "let mut path = *self.root_path();\npath.add_path_entry(&self.service.directory).unwrap();",
          "purpose": "Mutable let binding for path construction with method chaining"
        },
        {
          "file": "iceoryx2/src/node/mod.rs",
          "line": [552],
          "code": "let mut cleanup_failure = Ok(());",
          "purpose": "Mutable let binding initialized to Ok for accumulating errors"
        },
        {
          "file": "iceoryx2-bb/posix/src/shared_memory.rs",
          "line": [288, 289, 290],
          "code": "let shm_created;\nlet mut fd = match self\n    .config",
          "purpose": "Uninitialized binding pattern - shm_created must be assigned in all match arms before use"
        }
      ],
      "count": 13605
    },
    "expression_statements": {
      "fls_section": "8.2",
      "fls_ids": [
        "fls_1pg5ig740tg1"
      ],
      "description": "Expression Statements",
      "status": "demonstrated",
      "findings": {
        "description": "An expression statement is an expression whose result is ignored. Used for side effects like function calls, method invocations, and assignments.",
        "dynamic_semantics": "8:5 - The value of the operand is dropped after evaluation",
        "common_patterns": [
          "Function calls for side effects",
          "Method calls on objects",
          "Assignment expressions",
          "Increment/update operations"
        ]
      },
      "samples": [
        {
          "file": "iceoryx2/src/waitset.rs",
          "line": [558],
          "code": "self.attachment_counter.fetch_add(1, Ordering::Relaxed);",
          "purpose": "Expression statement for atomic counter increment (side effect only)"
        },
        {
          "file": "iceoryx2-bb/lock-free/src/spsc/safely_overflowing_index_queue.rs",
          "line": [318, 319],
          "code": "self.write_position\n    .store(write_position + 1, Ordering::Release);",
          "purpose": "Expression statement for atomic store with release ordering"
        },
        {
          "file": "iceoryx2-bb/lock-free/src/spsc/queue.rs",
          "line": [67],
          "code": "self.queue.has_producer.store(true, Ordering::Relaxed);",
          "purpose": "Expression statement for atomic flag update in producer registration"
        }
      ],
      "count": 45398
    }
  },
  "safety_critical_summary": {
    "positive_patterns": {
      "safety_patterns": {
        "uninitialized_variables": {
          "description": "Variables declared without initializers must be initialized before use",
          "fls_reference": "8.1:15 - binding is uninitialized if no let initializer",
          "samples": [
            {
              "file": "iceoryx2-bb/posix/src/shared_memory.rs",
              "line": [288],
              "code": "let shm_created; // Must be assigned in all match arms before use"
            },
            {
              "file": "iceoryx2-bb/posix/src/semaphore.rs",
              "line": [490],
              "code": "let msg; // Assigned conditionally before use"
            }
          ]
        },
        "drop_on_statement": {
          "description": "Expression statement values are dropped after evaluation",
          "fls_reference": "8.2:5 - value of operand is dropped"
        },
        "debug_assertions": {
          "description": "debug_assert! for invariant checking in debug builds",
          "count": 634,
          "usage": "Validates internal invariants without release build overhead"
        }
      }
    }
  }
}