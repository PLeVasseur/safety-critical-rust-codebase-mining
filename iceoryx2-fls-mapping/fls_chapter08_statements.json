{
  "chapter": 8,
  "title": "Statements",
  "fls_url": "https://rust-lang.github.io/fls/statements.html",
  "fls_id": "fls_wdicg3sqa98e",
  "repository": "eclipse-iceoryx/iceoryx2",
  "version": "0.8.0",
  "analysis_date": "2025-12-30",
  "version_changes": {
    "from_version": "0.7.0",
    "to_version": "0.8.0",
    "summary": "Significant increase in statement usage due to expanded codebase. Let statements increased 40%, macro statements increased substantially with debug_assert! now heavily used (634 instances). Let-else pattern now in use (6 instances).",
    "key_changes": [
      "Directory structure changed: iceoryx2-bb-*-0.7.0/ -> iceoryx2-bb/*/",
      "let statements increased from 9703 to 13605 (+40%)",
      "let mut statements increased from 1683 to 2338 (+39%)",
      "let with type ascription increased from 103 to 152 (+48%)",
      "let with tuple destructuring increased from 150 to 216 (+44%)",
      "Let-else pattern now in use (6 instances) - was NOT FOUND in v0.7.0",
      "debug_assert! heavily used (634 instances) - was minimal in v0.7.0",
      "assert_that! increased from 4571 to 5263 (+15%)",
      "fail! increased from 887 to 1065 (+20%)",
      "fatal_panic! increased from 192 to 320 (+67%)",
      "unimplemented! now used (161 instances)"
    ]
  },
  "summary": "FLS Chapter 8 defines statements - the executable units within block expressions. Statements include let statements for introducing bindings, expression statements for side effects, item statements for local declarations, macro statements, and empty statements.",
  "statistics": {
    "let_statements_total": 13605,
    "let_mut_statements": 2338,
    "let_with_type_ascription": 152,
    "let_with_tuple_destructuring": 216,
    "let_with_struct_pattern": 1,
    "let_else_statements": 6,
    "expression_statements_semicolons": 45398,
    "fn_declarations": 3941,
    "macro_statements": 8139
  },
  "sections": {
    "item_statement": {
      "fls_section": "8.-2.1",
      "fls_ids": [
        "fls_kdxe1ukmgl1"
      ],
      "description": "Item Statement",
      "status": "demonstrated",
      "findings": {
        "fls_reference": "8:2",
        "description": "An item statement is a statement expressed as an item, allowing items to be declared within block expressions (local scope). Common in iceoryx2 for test-local constants and helper functions.",
        "inner_const": "Used extensively in test functions for test-local constants",
        "inner_fn": "Less common, mostly in macro-generated code",
        "count": "~3232 inner function declarations"
      },
      "samples": [
        {
          "file": "iceoryx2-bb/memory/tests/pool_allocator_tests.rs",
          "line": [
            65,
            66
          ],
          "code": "const BUCKET_SIZE: usize = 128;\nconst BUCKET_ALIGNMENT: usize = 1;",
          "purpose": "Test-local constants declared inside test function"
        },
        {
          "file": "iceoryx2-services/discovery/tests/service_discovery_tracker_tests.rs",
          "line": [
            32
          ],
          "code": "const NUMBER_OF_SERVICES_ADDED: usize = 8;",
          "purpose": "Local constant for test configuration"
        }
      ]
    },
    "empty_statement": {
      "fls_section": "8.-2.2",
      "fls_ids": [
        "fls_fftdnwe22xrb"
      ],
      "description": "Empty Statement",
      "status": "not_used",
      "findings": {
        "fls_reference": "8:3",
        "description": "An empty statement is a statement expressed as character 0x3B (semicolon) that has no effect when executed.",
        "dynamic_semantics": "The execution of an empty statement has no effect.",
        "status": "Not intentionally used in iceoryx2 - empty statements are rare in production Rust code"
      },
      "samples": []
    },
    "macro_statement": {
      "fls_section": "8.-2.3",
      "fls_ids": [
        "fls_or125cqtxg9j"
      ],
      "description": "Macro Statement",
      "status": "demonstrated",
      "findings": {
        "fls_reference": "8:4",
        "description": "A macro statement is a statement expressed as a terminated macro invocation. Macro statements are heavily used in iceoryx2 for assertions, logging, and test infrastructure.",
        "assertion_macros": {
          "assert_that": 5263,
          "debug_assert": 634,
          "assert": 30,
          "assert_eq": 17
        },
        "error_macros": {
          "fail": 1065,
          "fatal_panic": 320,
          "panic": 107,
          "unreachable": 6
        },
        "development_macros": {
          "todo": 6,
          "unimplemented": 161,
          "test_requires": 93,
          "print_family": 437
        },
        "total_macro_statements": "~8139",
        "change_from_v0_7_0": "+1789 (~28% increase)"
      },
      "samples": [
        {
          "file": "iceoryx2-bb/elementary/tests/scope_guard_tests.rs",
          "line": [
            34
          ],
          "code": "assert_that!(guard, is_ok);",
          "purpose": "Custom assertion macro for testing"
        },
        {
          "file": "iceoryx2-cal/src/zero_copy_connection/common.rs",
          "line": [
            657
          ],
          "code": "debug_assert!(channel_id.value() < self.storage.get().channels.capacity());",
          "purpose": "Debug-only invariant check"
        },
        {
          "file": "iceoryx2-cal/src/zero_copy_connection/common.rs",
          "line": [
            688
          ],
          "code": "debug_assert!(ptr.offset() % sample_size == 0);",
          "purpose": "Debug-only alignment validation"
        }
      ]
    },
    "empty_statement_execution": {
      "fls_section": "8.-3.1",
      "fls_ids": [
        "fls_dl763ssb54q1"
      ],
      "description": "Empty Statement Execution",
      "status": "not_applicable",
      "findings": {
        "description": "Dynamic semantics for empty statement execution - has no effect. Not applicable as empty statements are not used in iceoryx2."
      },
      "samples": []
    },
    "let_statements": {
      "fls_section": "8.1",
      "fls_ids": [
        "fls_yivm43r5wnp1"
      ],
      "description": "Let Statements",
      "status": "demonstrated",
      "findings": {
        "description": "A let statement introduces new bindings by matching a pattern against a value. The primary mechanism for creating local variables in Rust.",
        "statistics": {
          "let_statements_total": 13605,
          "let_mut_statements": 2338,
          "let_with_type_ascription": 152,
          "let_with_tuple_destructuring": 216,
          "if_let_expressions": 337,
          "while_let_expressions": 70
        },
        "legality_rules": {
          "8.1:1": "let statements introduce bindings via pattern matching",
          "8.1:15": "A binding is uninitialized if the let statement lacks an initializer"
        },
        "patterns_used": [
          "Simple bindings: let x = expr;",
          "Mutable bindings: let mut x = expr;",
          "Type ascription: let x: Type = expr;",
          "Tuple destructuring: let (a, b) = expr;",
          "Struct destructuring: let Struct { field } = expr;"
        ],
        "let_else_status": "Not used - iceoryx2 uses if let / match instead"
      },
      "samples": [
        {
          "file": "iceoryx2-bb/elementary-traits/src/allocator.rs",
          "line": [
            56
          ],
          "code": "let memory = self.allocate(layout)?;",
          "purpose": "Simple let binding with error propagation"
        },
        {
          "file": "iceoryx2-bb/posix/tests/unix_datagram_socket_tests.rs",
          "line": [
            36
          ],
          "code": "let mut file = FileName::new(b\"unix_datagram_socket_tests\").unwrap();",
          "purpose": "Mutable let binding"
        },
        {
          "file": "iceoryx2-bb/posix/tests/udp_socket_tests.rs",
          "line": [
            86
          ],
          "code": "let port;",
          "purpose": "Uninitialized binding - must be assigned before use"
        }
      ]
    },
    "expression_statements": {
      "fls_section": "8.2",
      "fls_ids": [
        "fls_1pg5ig740tg1"
      ],
      "description": "Expression Statements",
      "status": "demonstrated",
      "findings": {
        "description": "An expression statement is an expression whose result is ignored. Used for side effects like function calls, method invocations, and assignments.",
        "dynamic_semantics": "8:5 - The value of the operand is dropped after evaluation",
        "common_patterns": [
          "Function calls for side effects",
          "Method calls on objects",
          "Assignment expressions",
          "Increment/update operations"
        ]
      },
      "samples": [
        {
          "file": "iceoryx2-bb/posix/tests/signal_tests.rs",
          "line": [
            45
          ],
          "code": "COUNTER.fetch_add(1, Ordering::Relaxed);",
          "purpose": "Expression statement for atomic increment side effect"
        },
        {
          "file": "iceoryx2-bb/testing/src/lifetime_tracker.rs",
          "line": [
            40
          ],
          "code": "*DROP_COUNTER.lock().unwrap() += 1;",
          "purpose": "Expression statement for mutex-guarded update"
        }
      ]
    }
  },
  "safety_critical_summary": {
    "positive_patterns": {
      "safety_patterns": {
        "uninitialized_variables": {
          "description": "Variables declared without initializers must be initialized before use",
          "fls_reference": "8.1:15 - binding is uninitialized if no let initializer",
          "samples": [
            {
              "file": "iceoryx2-bb/posix/tests/udp_socket_tests.rs",
              "line": [
                86
              ],
              "code": "let port; // Must be assigned before use"
            },
            {
              "file": "iceoryx2-bb/elementary/src/math.rs",
              "line": [
                43
              ],
              "code": "let mut remainder; // Assigned in loop"
            }
          ]
        },
        "drop_on_statement": {
          "description": "Expression statement values are dropped after evaluation",
          "fls_reference": "8.2:5 - value of operand is dropped"
        },
        "debug_assertions": {
          "description": "debug_assert! for invariant checking in debug builds",
          "count": 634,
          "usage": "Validates internal invariants without release build overhead"
        }
      }
    }
  }
}