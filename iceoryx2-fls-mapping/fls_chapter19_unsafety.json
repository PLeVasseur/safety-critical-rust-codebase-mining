{
  "chapter": 19,
  "title": "Unsafety",
  "fls_url": "https://rust-lang.github.io/fls/unsafety.html",
  "fls_id": "fls_jep7p27kaqlp",
  "repository": "eclipse-iceoryx/iceoryx2",
  "version": "0.8.0",
  "analysis_date": "2025-12-30",
  "version_changes": {
    "from_version": "0.7.0",
    "to_version": "0.8.0",
    "summary": "Significant unsafe increase due to FFI C layer. Union types introduced (0\u219242), ManuallyDrop for FFI union handling, expanded raw pointer usage.",
    "key_changes": [
      "unsafe blocks: 1,702 \u2192 2,372 (+39%)",
      "unsafe fn: 1,302 \u2192 1,763 (+35%)",
      "unsafe impl: 203 \u2192 219 (+8%)",
      "raw pointer types: 1,554 \u2192 3,435 (+121%)",
      "static mut: 3 \u2192 14 (+367% - logger restructuring)",
      "union types: 0 \u2192 42 (NEW - FFI C layer)",
      "transmute: 50 \u2192 82 (+64%)",
      "from_raw_parts: 46 \u2192 69 (+50%)",
      "MaybeUninit: 146 \u2192 219 (+50%)",
      "assume_init: 83 \u2192 133 (+60%)",
      "NonNull: 160 \u2192 356 (+123%)",
      "drop_in_place: 8 \u2192 29 (+263%)",
      "extern C blocks: 26 \u2192 11 (consolidated)",
      "SAFETY comments: 14 \u2192 11 (needs improvement)"
    ]
  },
  "summary": "FLS Chapter 19 covers unsafe operations that may result in undefined behavior. iceoryx2 v0.8.0 demonstrates extensive but disciplined unsafe usage: 2,372 unsafe blocks, 1,763 unsafe functions (primarily in pal-posix and ffi-c layers), 219 unsafe impl (mostly Send/Sync), 1 unsafe trait (ZeroCopySend), and 42 union types (NEW for FFI). Key unsafe operations: raw pointer manipulation (3,435 pointer types), FFI calls to POSIX APIs, interior mutability (231 UnsafeCell), and union field access for C API. static mut usage increased to 14 due to logger restructuring.",
  "statistics": {
    "unsafe_blocks": 2372,
    "unsafe_blocks_in_tests": 30,
    "unsafe_fn": 1763,
    "unsafe_impl": 219,
    "unsafe_trait": 1,
    "union_types": 42,
    "raw_pointer_types": 3435,
    "static_mut": 14,
    "inline_assembly": 0,
    "transmute": 82,
    "from_raw_parts": 69,
    "maybe_uninit": 219,
    "assume_init": 133,
    "unsafe_cell": 231,
    "non_null": 356,
    "addr_of_mut": 27,
    "drop_in_place": 29,
    "extern_c_blocks": 11,
    "safety_comments": 11
  },
  "sections": {
    "unsafety_definition": {
      "fls_section": "19.-2.1",
      "fls_ids": [
        "fls_8kqo952gjhaf"
      ],
      "description": "Unsafety Definition",
      "status": "demonstrated",
      "findings": {
        "unsafe_impl_categories": {
          "send_sync": {
            "count": 43,
            "purpose": "Manual thread-safety markers for types with raw pointers or FFI",
            "samples": [
              "unsafe impl Send for BarrierHandle",
              "unsafe impl Sync for UniqueIndexSet",
              "unsafe impl Send for SignalHandler"
            ]
          },
          "zero_copy_send": {
            "purpose": "IPC-safe type markers for shared memory transfer",
            "description": "Implemented via derive macro primarily"
          }
        },
        "unsafe_trait": {
          "count": 1,
          "trait": "ZeroCopySend",
          "file": "iceoryx2-bb/elementary-traits/src/zero_copy_send.rs",
          "line": 32,
          "purpose": "Marker for types safe to transfer across process boundaries",
          "safety_requirements": [
            "Types must be self-contained (no external resource handles)",
            "No pointers or references to heap/external memory",
            "Must have #[repr(C)] for uniform memory layout"
          ]
        }
      },
      "samples": [
        {
          "file": "iceoryx2/src/waitset.rs",
          "line": [341, 342, 343],
          "code": "GuardType::Deadline(r, t) => WaitSetAttachmentId::deadline(\n    guard.waitset,\n    unsafe { r.file_descriptor().native_handle() },",
          "purpose": "unsafe block to access raw file descriptor handle from reactor"
        },
        {
          "file": "iceoryx2/src/service/dynamic_config/blackboard.rs",
          "line": [84, 85],
          "code": "readers: unsafe { Container::new_uninit(config.number_of_readers) },\nwriters: unsafe { Container::new_uninit(config.number_of_writers) },",
          "purpose": "unsafe for uninitialized container allocation in shared memory"
        },
        {
          "file": "iceoryx2/src/pending_response.rs",
          "line": [305, 306],
          "code": "ptr: unsafe {\n    NonNull::new_unchecked(payload_ptr as *mut PayloadFfi)",
          "purpose": "unsafe for NonNull creation from raw pointer in response handling"
        }
      ],
      "count": 4961
    },
    "unsafe_operation_definition": {
      "fls_section": "19.-2.2",
      "fls_ids": [
        "fls_ovn9czwnwxue"
      ],
      "description": "Unsafe Operation Definition",
      "status": "demonstrated",
      "findings": {
        "description": "An unsafe operation is an operation that may result in undefined behavior if its safety invariants are not upheld. In iceoryx2, unsafe operations are used for FFI calls, raw pointer manipulation, shared memory access, and lock-free data structures.",
        "categories": {
          "ffi_operations": "Calling C POSIX APIs and providing C API exports",
          "raw_pointer_ops": "Dereferencing, reading, writing raw pointers",
          "memory_operations": "Creating slices from raw parts, transmuting types",
          "interior_mutability": "Accessing UnsafeCell contents",
          "union_access": "Reading/writing union fields"
        },
        "total_unsafe_blocks": 2372,
        "total_unsafe_fn": 1763
      },
      "samples": [
        {
          "file": "iceoryx2-bb/elementary/src/lazy_singleton.rs",
          "line": [94],
          "code": "unsafe { *self.data.get() = Some(value) };",
          "purpose": "Interior mutability access via UnsafeCell for lazy initialization"
        },
        {
          "file": "iceoryx2/src/waitset.rs",
          "line": [341, 342, 343, 344],
          "code": "GuardType::Deadline(r, t) => WaitSetAttachmentId::deadline(\n    guard.waitset,\n    unsafe { r.file_descriptor().native_handle() },\n    t.index(),",
          "purpose": "unsafe block accessing native file descriptor for deadline attachment"
        },
        {
          "file": "iceoryx2/src/service/dynamic_config/blackboard.rs",
          "line": [118],
          "code": "let state = unsafe { self.readers.get_state() };",
          "purpose": "unsafe access to container state for reader list iteration"
        }
      ],
      "count": 2376
    },
    "unsafe_operations_list": {
      "fls_section": "19.-2.3",
      "fls_ids": [
        "fls_pfhmcafsjyf7"
      ],
      "description": "Unsafe Operations List",
      "status": "demonstrated",
      "findings": {
        "unsafe_operation_patterns": {
          "raw_pointer_dereference": {
            "count": 3435,
            "patterns": [
              "Shared memory access through mapped addresses",
              "Relocatable pointers for IPC",
              "FFI return value handling",
              "Container internals (Vec, Queue)",
              "Union field access via pointers"
            ]
          },
          "ffi_calls": {
            "patterns": [
              "posix::mmap / posix::munmap (shared memory)",
              "posix::shm_open / posix::shm_unlink",
              "posix::sem_* (semaphores)",
              "posix::pthread_* (threads, mutexes)",
              "posix::socket (IPC)"
            ]
          },
          "transmute": {
            "count": 82,
            "patterns": [
              "Type punning for FFI struct compatibility",
              "IP address conversion",
              "Signal handler casting",
              "CPU set conversions",
              "Union variant access"
            ]
          },
          "from_raw_parts": {
            "count": 69,
            "patterns": [
              "Creating slices from raw memory regions",
              "Shared memory byte slices",
              "FFI buffer handling"
            ]
          },
          "interior_mutability": {
            "unsafe_cell_count": 231,
            "patterns": [
              "Shared memory data access",
              "Lock-free data structure internals",
              "Lazy initialization",
              "FFI callback storage"
            ]
          },
          "union_field_access": {
            "count": 42,
            "description": "NEW - Accessing union variants in FFI C layer",
            "pattern": "ManuallyDrop::drop(&mut union.variant) for explicit cleanup"
          },
          "placement_new": {
            "description": "In-place initialization without stack allocation",
            "trait": "PlacementDefault",
            "usage": "Large IPC types initialized directly in shared memory"
          }
        }
      },
      "samples": [
        {
          "file": "iceoryx2-ffi/c/src/api/active_request.rs",
          "line": [32, 33, 34, 35, 36, 37, 38, 39],
          "code": "pub(super) union ActiveRequestUnion {\n    ipc: ManuallyDrop<\n        ActiveRequest<crate::IpcService, PayloadFfi, UserHeaderFfi, PayloadFfi, UserHeaderFfi>,\n    >,\n    local: ManuallyDrop<\n        ActiveRequest<crate::LocalService, PayloadFfi, UserHeaderFfi, PayloadFfi, UserHeaderFfi>,\n    >,\n}",
          "purpose": "Union type with ManuallyDrop variants for FFI - accessing variants is unsafe"
        },
        {
          "file": "iceoryx2-bb/system-types/src/file_name.rs",
          "line": [231, 232, 233],
          "code": "// SAFETY: It is ensured that the RestrictedFileName contains always a valid FileName, just\n// with less capacity\nunsafe { FileName::new_unchecked(value.as_bytes()) }",
          "purpose": "unsafe unchecked constructor with SAFETY comment justifying invariant"
        },
        {
          "file": "iceoryx2/src/sample_mut_uninit.rs",
          "line": [450, 451],
          "code": "// SAFETY: this is safe since the payload was initialized on the line above\nunsafe { self.assume_init() }",
          "purpose": "unsafe assume_init after initialization with SAFETY comment"
        }
      ],
      "count": 2376
    },
    "raw_pointer_dereference": {
      "fls_section": "19.-2.4",
      "fls_ids": [
        "fls_jd1inwz7ulyw"
      ],
      "description": "Raw Pointer Dereference",
      "status": "demonstrated",
      "findings": {
        "description": "Dereferencing a raw pointer is an unsafe operation. iceoryx2 extensively uses raw pointer dereference for shared memory access, relocatable pointers, and FFI.",
        "count": 3435,
        "patterns": [
          "Shared memory access via mapped pointers",
          "Relocatable pointers for IPC container data",
          "FFI buffer/struct access",
          "Lock-free queue node manipulation",
          "Union field access through pointers"
        ],
        "safety_wrappers": {
          "NonNull": "356 uses - prevents null pointer dereference",
          "as_ptr": "Converts references to raw pointers safely",
          "as_mut_ptr": "Converts mutable references to raw pointers"
        }
      },
      "samples": [
        {
          "file": "iceoryx2-bb/lock-free/src/spsc/safely_overflowing_index_queue.rs",
          "line": [335],
          "code": "let value = unsafe { *self.at(read_position) };",
          "purpose": "Raw pointer dereference to read value at index in lock-free queue"
        },
        {
          "file": "iceoryx2-bb/container/src/vector/mod.rs",
          "line": [
            237
          ],
          "code": "let value = unsafe { core::ptr::read(data[index].as_ptr()) };",
          "purpose": "Reading value from container via raw pointer"
        },
        {
          "file": "iceoryx2-bb/posix/src/thread.rs",
          "line": [
            467
          ],
          "code": "unsafe { core::ptr::read(args as *const ThreadStartupArgs<TT, FF>) };",
          "purpose": "Reading thread startup args from raw pointer"
        }
      ],
      "count": null,
      "count_methodology": "Pattern not defined for this section"
    },
    "external_static_access": {
      "fls_section": "19.-2.5",
      "fls_ids": [
        "fls_3ra8s1v1vbek"
      ],
      "description": "External Static Access",
      "status": "demonstrated",
      "findings": {
        "description": "Accessing an external static (declared via extern block) is an unsafe operation because the compiler cannot verify the static's validity. iceoryx2 uses this only in bare-metal examples.",
        "usage": "Minimal - only in no_std bare-metal examples",
        "rationale": "Main codebase avoids extern statics; uses FFI function calls instead"
      },
      "samples": [
        {
          "file": "examples/nostd/bare-metal/rust/_common/src/global_allocator.rs",
          "line": [
            20,
            21,
            22
          ],
          "code": "extern \"C\" {\n    static _heap_start: u8;\n    static _heap_end: u8;\n}",
          "purpose": "Linker-defined symbols for heap bounds in bare-metal allocator"
        }
      ],
      "count": 0,
      "samples_waiver": {
        "reason": "insufficient_patterns",
        "explanation": "Only 0 instance(s) found in codebase, fewer than 3 required samples",
        "approved_by": "automated",
        "date": "2025-12-30"
      }
    },
    "mutable_static_access": {
      "fls_section": "19.-2.6",
      "fls_ids": [
        "fls_6ipl0xo5qjyl"
      ],
      "description": "Mutable Static Access",
      "status": "demonstrated",
      "findings": {
        "static_mut_usage": {
          "count": 14,
          "rationale": "Increased due to logger restructuring - still minimal global mutable state",
          "locations": [
            {
              "file": "iceoryx2-pal/posix/src/windows/socket.rs",
              "variables": [
                "WSA_INSTANCE",
                "INITIALIZATION_STATE"
              ],
              "purpose": "Windows socket initialization (platform-specific singleton)"
            },
            {
              "file": "iceoryx2-log/log/src/lib.rs",
              "variable": "LOGGER",
              "purpose": "Global logger instance"
            },
            {
              "file": "iceoryx2-log/loggers/src/writer.rs",
              "variables": [
                "STDOUT",
                "STDERR"
              ],
              "purpose": "Standard output/error handles"
            },
            {
              "file": "iceoryx2-ffi/c/src/api/log.rs",
              "variable": "LOGGER",
              "purpose": "C API logger instance"
            }
          ]
        }
      },
      "samples": [
        {
          "file": "iceoryx2-pal/posix/src/windows/socket.rs",
          "line": [51, 52],
          "code": "static mut WSA_INSTANCE: OnceCell<GlobalWsaInitializer> = OnceCell::new();\nstatic mut INITIALIZATION_STATE: AtomicU8 = AtomicU8::new(0);",
          "purpose": "static mut for Windows socket singleton - requires unsafe to access"
        },
        {
          "file": "iceoryx2-log/log/src/lib.rs",
          "line": [144],
          "code": "static mut LOGGER: Option<&'static dyn Log> = None;",
          "purpose": "static mut for global logger instance - unsafe access for set/get"
        },
        {
          "file": "iceoryx2-ffi/c/src/api/log.rs",
          "line": [79, 80],
          "code": "static mut LOGGER: Option<CLogger> = None;\nstatic INIT: Once = Once::new();",
          "purpose": "static mut for C API logger with Once guard for initialization"
        }
      ],
      "count": 14
    },
    "union_field_access": {
      "fls_section": "19.-2.7",
      "fls_ids": [
        "fls_ucghxcnpaq2t"
      ],
      "description": "Union Field Access",
      "status": "demonstrated",
      "findings": {
        "union_types": {
          "description": "NEW in v0.8.0 - Union types for FFI C API",
          "count": 42,
          "purpose": "Discriminated unions for C API type-safety across IPC/Local service variants",
          "pattern": "Each union contains ipc/local variants with ManuallyDrop wrapper for explicit destruction control"
        }
      },
      "samples": [
        {
          "file": "iceoryx2-ffi/c/src/api/writer.rs",
          "line": [50, 51, 52, 53],
          "code": "pub(super) union WriterUnion {\n    ipc: ManuallyDrop<Writer<crate::IpcService, KeyFfi>>,\n    local: ManuallyDrop<Writer<crate::LocalService, KeyFfi>>,\n}",
          "purpose": "Union type with ManuallyDrop for FFI - field access is unsafe"
        },
        {
          "file": "iceoryx2-ffi/c/src/api/waitset_guard.rs",
          "line": [25, 26, 27, 28],
          "code": "pub(crate) union GuardUnion {\n    ipc: ManuallyDrop<WaitSetGuard<crate::IpcService>>,\n    local: ManuallyDrop<WaitSetGuard<crate::LocalService>>,\n}",
          "purpose": "Union for WaitSet guard with IPC/Local variants"
        },
        {
          "file": "iceoryx2-ffi/c/src/api/waitset_attachment_id.rs",
          "line": [28, 29, 30, 31],
          "code": "pub(crate) union AttachmentIdUnion {\n    ipc: WaitSetAttachmentId<crate::IpcService>,\n    local: WaitSetAttachmentId<crate::LocalService>,\n}",
          "purpose": "Union for WaitSet attachment ID discriminated by service type"
        }
      ],
      "count": 42
    },
    "unsafe_function_call": {
      "fls_section": "19.-2.8",
      "fls_ids": [
        "fls_ljocmnaz2m49"
      ],
      "description": "Unsafe Function Call",
      "status": "demonstrated",
      "findings": {
        "unsafe_fn_purposes": {
          "ffi_wrappers": {
            "crate": "iceoryx2-pal/posix",
            "description": "Direct POSIX API wrappers - inherently unsafe due to C ABI"
          },
          "ffi_c_api": {
            "crate": "iceoryx2-ffi/c",
            "description": "NEW - C API export functions with extern C ABI"
          },
          "relocatable_containers": {
            "crate": "iceoryx2-bb/container",
            "description": "Container operations on relocatable types in shared memory"
          },
          "shared_memory_ops": {
            "crate": "iceoryx2-cal",
            "description": "Shared memory creation, mapping, and access"
          },
          "lock_free_ops": {
            "crate": "iceoryx2-bb/lock-free",
            "description": "Lock-free queue and container operations"
          }
        }
      },
      "samples": [],
      "count": null,
      "count_methodology": "Pattern not defined for this section",
      "samples_waiver": {
        "reason": "conceptual_section",
        "explanation": "This section describes an abstract concept not directly mappable to concrete code patterns",
        "approved_by": "automated",
        "date": "2025-12-30"
      }
    },
    "unsafe_context": {
      "fls_section": "19.-2.9",
      "fls_ids": [
        "fls_jb6krd90tjmc"
      ],
      "description": "Unsafe Context",
      "status": "demonstrated",
      "findings": {
        "safety_documentation": {
          "safety_comments": 11,
          "pattern": "// SAFETY: <explanation>",
          "note": "Low SAFETY comment count suggests opportunity for improved documentation"
        },
        "testing_unsafe": {
          "unsafe_blocks_in_tests": 30,
          "purpose": [
            "Testing unsafe APIs directly",
            "Simulating process crashes (mem::forget)",
            "Low-level data structure testing",
            "FFI integration testing"
          ]
        }
      },
      "samples": [],
      "count": null,
      "count_methodology": "Pattern not defined for this section",
      "samples_waiver": {
        "reason": "conceptual_section",
        "explanation": "This section describes an abstract concept not directly mappable to concrete code patterns",
        "approved_by": "automated",
        "date": "2025-12-30"
      }
    },
    "unsafe_operation_requirement": {
      "fls_section": "19.-2.10",
      "fls_ids": [
        "fls_ybnpe7ppq1vh"
      ],
      "description": "Unsafe Operation Requirement",
      "status": "demonstrated",
      "findings": {
        "description": "Unsafe operations can only be performed within an unsafe context (unsafe block or unsafe function). iceoryx2 consistently uses unsafe blocks to isolate unsafe operations.",
        "patterns": [
          "Unsafe blocks wrapping single operations for minimal scope",
          "Unsafe functions for operations requiring multiple unsafe calls",
          "SAFETY comments (11 instances) documenting invariants"
        ],
        "improvement_opportunity": "SAFETY comment count (11) is low for 2,372 unsafe blocks - documentation could be improved"
      },
      "samples": [
        {
          "file": "iceoryx2-bb/container/src/string/static_string.rs",
          "line": [
            291
          ],
          "code": "core::ptr::write::<u8>(new_self.data.as_mut_ptr().add(len).cast(), 0);",
          "purpose": "Writing null terminator within unsafe block"
        }
      ],
      "count": null,
      "count_methodology": "Pattern not defined for this section",
      "samples_waiver": {
        "reason": "conceptual_section",
        "explanation": "This section describes an abstract concept not directly mappable to concrete code patterns",
        "approved_by": "automated",
        "date": "2025-12-30"
      }
    }
  },
  "design_patterns": {
    "safe_abstraction": {
      "description": "Unsafe code encapsulated behind safe APIs",
      "example": "SharedMemory provides safe API over unsafe mmap/munmap"
    },
    "minimal_static_mut": {
      "description": "14 static mut - increased but still minimal for size of codebase",
      "alternative": "Arc, AtomicPtr, or dependency injection preferred"
    },
    "no_inline_assembly": {
      "description": "Zero asm! usage - relies on Rust/LLVM intrinsics",
      "benefit": "Portability across platforms"
    },
    "unsafe_trait_for_invariants": {
      "description": "ZeroCopySend as unsafe trait enforces IPC safety invariants",
      "benefit": "Compile-time guarantees for shared memory types"
    },
    "ffi_isolation": {
      "description": "FFI unsafe concentrated in pal-posix and ffi-c crates",
      "benefit": "Isolated platform-specific and C-API unsafety"
    },
    "union_with_manually_drop": {
      "description": "NEW - Unions use ManuallyDrop for explicit lifetime control",
      "benefit": "Safe FFI resource management without automatic Drop"
    },
    "interior_mutability_for_ipc": {
      "description": "UnsafeCell enables shared memory mutation patterns",
      "count": 231
    }
  },
  "cross_chapter_references": {
    "chapter_15": "Ownership - ManuallyDrop for union destruction control",
    "chapter_17": "Concurrency - unsafe impl Send/Sync",
    "chapter_21": "FFI - extern C functions, union types, #[no_mangle]"
  }
}