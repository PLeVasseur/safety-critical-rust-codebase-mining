{
  "chapter": 5,
  "title": "Patterns",
  "fls_url": "https://rust-lang.github.io/fls/patterns.html",
  "fls_id": "fls_xgqh0ju6bmbn",
  "repository": "eclipse-iceoryx/iceoryx2",
  "version": "0.8.0",
  "analysis_date": "2024-12-30",
  "version_changes": {
    "from_version": "0.7.0",
    "to_version": "0.8.0",
    "summary": "Pattern usage expanded proportionally with codebase growth, path updates for new directory structure",
    "key_changes": [
      "match expressions increased with FFI layer",
      "if let usage expanded",
      "while let usage increased for async-free event processing"
    ]
  },
  "summary": "FLS Chapter 5 defines patterns - constructs that match values satisfying pattern criteria. Patterns are used in let bindings, match expressions, if let, while let, function parameters, and for loops.",
  "statistics": {},
  "sections": {
    "refutability": {
      "fls_section": "5.1 Refutability",
      "fls_ids": [
        "fls_uh76pw6ykd57"
      ],
      "description": "Refutability expresses the ability to match all possible values of a type. Irrefutable patterns always match; refutable patterns may fail to match.",
      "findings": {
        "irrefutable_patterns": "let bindings use irrefutable patterns (identifier, underscore)",
        "refutable_patterns": "match arms and if let use refutable patterns (literals, enums, ranges)"
      }
    },
    "5.1.1_identifier_patterns": {
      "fls_section": "5.1.1 Identifier Patterns",
      "description": "Identifier pattern binds the matched value to a binding. Can include ref, mut keywords.",
      "findings": {
        "simple_bindings": "Extensive use of let x = ... bindings",
        "mutable_bindings": "2338 let mut bindings for mutable variables",
        "ref_patterns": "99 ref mut patterns for borrowing in patterns"
      },
      "samples": [
        {
          "file": "iceoryx2-bb/lock-free/tests/spsc_index_queue_tests.rs",
          "line": [
            22
          ],
          "code": "let sut = FixedSizeIndexQueue::<CAPACITY>::new();"
        },
        {
          "file": "iceoryx2-bb/lock-free/tests/spsc_index_queue_tests.rs",
          "line": [
            29
          ],
          "code": "let mut sut_producer = sut.acquire_producer().unwrap();"
        },
        {
          "file": "iceoryx2-bb/lock-free/tests/spsc_index_queue_tests.rs",
          "line": [
            138
          ],
          "code": "let mut counter: usize = 0;"
        },
        {
          "file": "iceoryx2-pal/posix/src/windows/win32_handle_translator.rs",
          "line": [
            251
          ],
          "code": "FdHandleEntry::SharedMemory(ref mut handle) => {"
        },
        {
          "file": "iceoryx2/src/service/static_config/mod.rs",
          "line": [
            160
          ],
          "code": "MessagingPattern::RequestResponse(ref mut v) => v,"
        }
      ]
    },
    "5.1.2_literal_patterns": {
      "fls_section": "5.1.2 Literal Patterns",
      "description": "Literal pattern matches a literal value (bool, char, numeric, string, byte).",
      "findings": {
        "numeric_literals": "0, 1, specific values in match arms",
        "byte_literals": "b'\\t', b'\\n', byte strings in character handling",
        "usage": "Error code matching, state machine transitions"
      },
      "samples": [
        {
          "file": "iceoryx2-pal/posix/src/linux/stat.rs",
          "line": [
            22
          ],
          "code": "0 => {"
        },
        {
          "file": "iceoryx2-pal/posix/src/windows/win32_call.rs",
          "line": [
            62
          ],
          "code": "0 => Errno::set(Errno::ESUCCES),"
        },
        {
          "file": "iceoryx2-bb/container/src/string/utils.rs",
          "line": [
            40
          ],
          "code": "b'\\t' => vec![b'\\\\', b't'].into_iter(),"
        },
        {
          "file": "iceoryx2-bb/container/src/string/utils.rs",
          "line": [
            41
          ],
          "code": "b'\\r' => vec![b'\\\\', b'r'].into_iter(),"
        },
        {
          "file": "iceoryx2-bb/container/src/string/utils.rs",
          "line": [
            42
          ],
          "code": "b'\\n' => vec![b'\\\\', b'n'].into_iter(),"
        }
      ]
    },
    "5.1.3_parenthesized_patterns": {
      "fls_section": "5.1.3 Parenthesized Patterns",
      "description": "Parenthesized pattern controls precedence of subpatterns.",
      "findings": {
        "usage": "Limited - used where needed for clarity"
      }
    },
    "5.1.4_path_patterns": {
      "fls_section": "5.1.4 Path Patterns",
      "description": "Path pattern matches a constant, unit enum variant, or unit struct constant.",
      "findings": {
        "enum_variants": "Some, None, Ok, Err extensively used",
        "custom_variants": "Custom enum variants for error handling and state"
      },
      "samples": [
        {
          "file": "iceoryx2-bb/lock-free/tests/mpmc_container_tests.rs",
          "line": [
            417
          ],
          "code": "Ok(index) => {"
        },
        {
          "file": "iceoryx2-bb/lock-free/tests/mpmc_container_tests.rs",
          "line": [
            425
          ],
          "code": "Err(ContainerAddFailure::OutOfSpace) => {"
        },
        {
          "file": "iceoryx2-bb/lock-free/tests/mpmc_unique_index_set_tests.rs",
          "line": [
            221
          ],
          "code": "Err(UniqueIndexSetAcquireFailure::OutOfIndices) => {"
        },
        {
          "file": "iceoryx2-bb/lock-free/tests/bitset_tests.rs",
          "line": [
            119
          ],
          "code": "assert_that!(sut.reset_next(), eq None);"
        }
      ]
    },
    "5.1.5_range_patterns": {
      "fls_section": "5.1.5 Range Patterns",
      "description": "Range pattern matches values within a range (half-open, inclusive, exclusive).",
      "findings": {
        "inclusive_ranges": "..= for inclusive range patterns",
        "usage": "Character classification, numeric ranges, priority matching"
      },
      "samples": [
        {
          "file": "iceoryx2-bb/posix/src/unix_datagram_socket.rs",
          "line": [
            961
          ],
          "code": "1..=isize::MAX => {"
        },
        {
          "file": "iceoryx2-bb/container/src/string/utils.rs",
          "line": [
            43
          ],
          "code": "b'\\x20'..=b'\\x7f' => vec![*c].into_iter(),"
        },
        {
          "file": "iceoryx2-bb/system-types/src/path.rs",
          "line": [
            57
          ],
          "code": "1..=31 => return true,"
        },
        {
          "file": "iceoryx2-bb/system-types/src/user_name.rs",
          "line": [
            52
          ],
          "code": "matches!(string[0], b'-' | b'0'..=b'9')"
        },
        {
          "file": "iceoryx2-bb/system-types/src/user_name.rs",
          "line": [
            57
          ],
          "code": "b'a'..=b'z' | b'A'..=b'Z' | b'0'..=b'9' | b'-' | b'_' => (),"
        }
      ]
    },
    "5.1.6_reference_patterns": {
      "fls_section": "5.1.6 Reference Patterns",
      "description": "Reference pattern dereferences a pointer being matched.",
      "findings": {
        "usage": "Limited direct use - ref keyword in identifier patterns more common"
      }
    },
    "5.1.7_rest_patterns": {
      "fls_section": "5.1.7 Rest Patterns",
      "description": "Rest pattern (..) matches zero or more elements not already matched.",
      "findings": {
        "usage": "Limited use in struct patterns"
      }
    },
    "5.1.8_slice_patterns": {
      "fls_section": "5.1.8 Slice Patterns",
      "description": "Slice pattern matches arrays of fixed size and slices of dynamic size.",
      "findings": {
        "usage": "Limited explicit use"
      }
    },
    "struct_patterns": {
      "fls_section": "5.2 Struct Patterns",
      "fls_ids": [
        "fls_7dbd5t2750ce"
      ],
      "description": "Struct pattern matches enum values, struct values, or union values.",
      "findings": {
        "enum_matching": "Extensive use for Result and Option",
        "struct_destructuring": "Used with custom types",
        "union_matching": "NEW in v0.8.0 - for FFI unions"
      }
    },
    "5.2.1_record_struct_patterns": {
      "fls_section": "5.2.1 Record Struct Patterns",
      "description": "Record struct pattern matches enum variant values, struct values, or union values with named fields.",
      "findings": {
        "shorthand_deconstructor": "ref mut handle pattern for mutable borrowing"
      },
      "samples": [
        {
          "file": "iceoryx2-pal/posix/src/windows/win32_handle_translator.rs",
          "line": [
            251
          ],
          "code": "FdHandleEntry::SharedMemory(ref mut handle) => {"
        },
        {
          "file": "iceoryx2-pal/posix/src/windows/win32_handle_translator.rs",
          "line": [
            266
          ],
          "code": "FdHandleEntry::File(ref mut handle) => {"
        },
        {
          "file": "iceoryx2/src/service/static_config/mod.rs",
          "line": [
            180
          ],
          "code": "MessagingPattern::Event(ref mut v) => v,"
        },
        {
          "file": "iceoryx2/src/service/static_config/mod.rs",
          "line": [
            200
          ],
          "code": "MessagingPattern::PublishSubscribe(ref mut v) => v,"
        }
      ]
    },
    "5.2.2_tuple_struct_patterns": {
      "fls_section": "5.2.2 Tuple Struct Patterns",
      "description": "Tuple struct pattern matches tuple enum variant values or tuple struct values.",
      "findings": {
        "option_patterns": "Some(v), None extensively used",
        "result_patterns": "Ok(x), Err(e) for error handling"
      },
      "samples": [
        {
          "file": "iceoryx2-bb/lock-free/tests/spsc_index_queue_tests.rs",
          "line": [
            151
          ],
          "code": "if let Some(v) = sut_consumer.pop() {"
        },
        {
          "file": "iceoryx2-bb/lock-free/tests/spsc_safely_overflowing_index_queue_tests.rs",
          "line": [
            148
          ],
          "code": "if let Some(s) = sut_producer.push(counter) {"
        },
        {
          "file": "iceoryx2-bb/lock-free/tests/mpmc_container_tests.rs",
          "line": [
            417
          ],
          "code": "Ok(index) => {"
        },
        {
          "file": "iceoryx2-bb/lock-free/tests/mpmc_unique_index_set_tests.rs",
          "line": [
            217
          ],
          "code": "Ok(e) => {"
        }
      ]
    },
    "5.2.3_tuple_patterns": {
      "fls_section": "5.2.3 Tuple Patterns",
      "description": "Tuple pattern matches a tuple satisfying all subpattern criteria.",
      "findings": {
        "usage": "Limited explicit tuple destructuring - more common with struct types"
      },
      "samples": [
        {
          "file": "iceoryx2-bb/lock-free/tests/mpmc_container_tests.rs",
          "line": [
            79
          ],
          "code": "let mut contained_values: Vec<(u32, usize)> = vec![];"
        }
      ]
    },
    "5.2.4_underscore_patterns": {
      "fls_section": "5.2.4 Underscore Patterns",
      "description": "Underscore pattern matches any single value without binding.",
      "findings": {
        "usage": "Wildcard binding, ignoring values, catch-all match arms"
      },
      "samples": [
        {
          "file": "iceoryx2-bb/lock-free/tests/spsc_index_queue_tests.rs",
          "line": [
            90
          ],
          "code": "let _consumer = sut.acquire_consumer().unwrap();"
        },
        {
          "file": "iceoryx2-bb/lock-free/tests/spsc_index_queue_tests.rs",
          "line": [
            106
          ],
          "code": "let _producer = sut.acquire_producer().unwrap();"
        },
        {
          "file": "iceoryx2-bb/lock-free/tests/bitset_tests.rs",
          "line": [
            149
          ],
          "code": "let _watchdog = Watchdog::new_with_timeout(Duration::from_secs(60));"
        },
        {
          "file": "iceoryx2-bb/lock-free/src/mpmc/unique_index_set.rs",
          "line": [
            34
          ],
          "code": "Err(_) => panic!(\"Out of indices\"),"
        }
      ]
    },
    "binding_modes": {
      "fls_section": "5.3 Binding Modes",
      "fls_ids": [
        "fls_qssijtofa9i8"
      ],
      "description": "Binding modes determine how matched values are bound: by value, by reference, or by mutable reference.",
      "findings": {
        "by_value": "Default binding mode - moves or copies value",
        "by_reference": "ref keyword for immutable borrow",
        "by_mutable_reference": "99 ref mut patterns for mutable borrow"
      },
      "samples": [
        {
          "file": "iceoryx2-pal/posix/src/windows/win32_handle_translator.rs",
          "line": [
            358
          ],
          "code": "if let FdHandleEntry::UdsDatagramSocket(ref mut s) = *self.fd2handle[fd as usize].get()"
        },
        {
          "file": "iceoryx2-pal/posix/src/macos/pthread.rs",
          "line": [
            119
          ],
          "code": "if let Some(ref mut v) = *state.get() {"
        },
        {
          "file": "iceoryx2/src/service/builder/publish_subscribe.rs",
          "line": [
            290
          ],
          "code": "MessagingPattern::PublishSubscribe(ref mut v) => v,"
        }
      ]
    },
    "pattern_matching": {
      "fls_section": "5.4 Pattern Matching",
      "fls_ids": [
        "fls_jm6l7b90h6wa"
      ],
      "description": "Pattern matching process involving a pattern and a context value.",
      "findings": {
        "match_expressions": "1663 match expressions (primary pattern matching construct)",
        "if_let": "337 if let expressions for conditional pattern matching",
        "while_let": "70 while let expressions for loop with pattern matching"
      }
    },
    "5.4.1_identifier_pattern_matching": {
      "fls_section": "5.4.1 Identifier Pattern Matching",
      "description": "Identifier pattern matching binds context value to the binding.",
      "findings": {
        "usage": "Fundamental pattern - every let binding uses this"
      }
    },
    "5.4.2_literal_pattern_matching": {
      "fls_section": "5.4.2 Literal Pattern Matching",
      "description": "Literal pattern matching compares literal with context value for equality.",
      "findings": {
        "usage": "Exact value matching in match arms"
      }
    },
    "5.4.3_parenthesized_pattern_matching": {
      "fls_section": "5.4.3 Parenthesized Pattern Matching",
      "description": "Parenthesized pattern matching performs pattern matching with subpattern."
    },
    "5.4.4_path_pattern_matching": {
      "fls_section": "5.4.4 Path Pattern Matching",
      "description": "Path pattern matching compares constant/enum variant with context value."
    },
    "5.4.5_range_pattern_matching": {
      "fls_section": "5.4.5 Range Pattern Matching",
      "description": "Range pattern matching checks if context value falls within range bounds."
    },
    "5.4.6_reference_pattern_matching": {
      "fls_section": "5.4.6 Reference Pattern Matching",
      "description": "Reference pattern matching dereferences context value and matches subpattern."
    },
    "5.4.7_slice_pattern_matching": {
      "fls_section": "5.4.7 Slice Pattern Matching",
      "description": "Slice pattern matching matches array/slice elements against subpatterns."
    },
    "5.4.8_record_struct_pattern_matching": {
      "fls_section": "5.4.8 Record Struct Pattern Matching",
      "description": "Record struct pattern matching matches struct fields against subpatterns."
    },
    "5.4.9_tuple_struct_pattern_matching": {
      "fls_section": "5.4.9 Tuple Struct Pattern Matching",
      "description": "Tuple struct pattern matching matches tuple struct fields against subpatterns."
    },
    "5.4.10_tuple_pattern_matching": {
      "fls_section": "5.4.10 Tuple Pattern Matching",
      "description": "Tuple pattern matching matches tuple fields against subpatterns."
    },
    "5.4.11_underscore_pattern_matching": {
      "fls_section": "5.4.11 Underscore Pattern Matching",
      "description": "Underscore pattern matching matches context value unconditionally."
    }
  },
  "safety_critical_summary": {
    "pattern_safety_features": {
      "exhaustive_matching": "Match expressions require exhaustive patterns",
      "irrefutable_requirement": "let bindings enforce irrefutable patterns",
      "type_checked": "All pattern types verified at compile time"
    },
    "common_patterns_in_safety_code": {
      "result_handling": "Ok(v)/Err(e) patterns for error propagation",
      "option_handling": "Some(v)/None patterns for nullable values",
      "enum_matching": "Exhaustive enum variant matching"
    },
    "binding_mode_safety": {
      "ref_patterns": "Borrow without ownership transfer",
      "ref_mut_patterns": "99 mutable borrow patterns in pattern context",
      "move_by_default": "Non-Copy types moved by default"
    },
    "version_comparison": {
      "match_expressions": {
        "v0_7_0": "~800",
        "v0_8_0": 1663,
        "change": "+863 (~108% increase)"
      },
      "if_let_expressions": {
        "v0_7_0": "~150",
        "v0_8_0": 337,
        "change": "+187 (~125% increase)"
      },
      "while_let_expressions": {
        "v0_7_0": "~30",
        "v0_8_0": 70,
        "change": "+40 (~133% increase)"
      }
    }
  }
}