{
  "source": "Rustonomicon",
  "source_repo": "https://github.com/rust-lang/nomicon",
  "extraction_date": "2026-01-03",
  "chapter": 10,
  "title": "Implementing Vec",
  "file": "./vec/vec.md",
  "sections": [
    {
      "id": "nomicon_example_implementing_vec",
      "title": "Example: Implementing Vec",
      "level": 1,
      "content": "To bring everything together, we're going to write `std::Vec` from scratch.\nWe will limit ourselves to stable Rust. In particular we won't use any\nintrinsics that could make our code a little bit nicer or efficient because\nintrinsics are permanently unstable. Although many intrinsics *do* become\nstabilized elsewhere (`std::ptr` and `std::mem` consist of many intrinsics).\n\nUltimately this means our implementation may not take advantage of all\npossible optimizations, though it will be by no means *naive*. We will\ndefinitely get into the weeds over nitty-gritty details, even\nwhen the problem doesn't *really* merit it.\n\nYou wanted advanced. We're gonna go advanced.",
      "parent_id": null,
      "paragraphs": {
        "nomicon_example_implementing_vec_p1": "To bring everything together, we're going to write `std::Vec` from scratch.\nWe will limit ourselves to stable Rust. In particular we won't use any\nintrinsics that could make our code a little bit nicer or efficient because\nintrinsics are permanently unstable. Although many intrinsics *do* become\nstabilized elsewhere (`std::ptr` and `std::mem` consist of many intrinsics).",
        "nomicon_example_implementing_vec_p2": "Ultimately this means our implementation may not take advantage of all\npossible optimizations, though it will be by no means *naive*. We will\ndefinitely get into the weeds over nitty-gritty details, even\nwhen the problem doesn't *really* merit it.",
        "nomicon_example_implementing_vec_p3": "You wanted advanced. We're gonna go advanced."
      }
    },
    {
      "id": "nomicon_layout",
      "title": "Layout",
      "level": 1,
      "content": "First off, we need to come up with the struct layout. A Vec has three parts:\na pointer to the allocation, the size of the allocation, and the number of\nelements that have been initialized.\n\nNaively, this means we just want this design:\n\n<!-- ignore: simplified code -->\n,ignore\npub struct Vec<T> {\n    ptr: *mut T,\n    cap: usize,\n    len: usize,\n}\n\nAnd indeed this would compile. Unfortunately, it would be too strict. The\ncompiler will give us too strict variance. So a `&Vec<&'static str>`\ncouldn't be used where a `&Vec<&'a str>` was expected. See the chapter\non ownership and lifetimes for all the details on variance.\n\nAs we saw in the ownership chapter, the standard library uses `Unique<T>` in place of\n`*mut T` when it has a raw pointer to an allocation that it owns. Unique is unstable,\nso we'd like to not use it if possible, though.\n\nAs a recap, Unique is a wrapper around a raw pointer that declares that:\n\n* We are covariant over `T`\n* We may own a value of type `T` (this is not relevant for our example here, but see \n  the chapter on PhantomData on why the real `std::vec::Vec<T>` needs this)\n* We are Send/Sync if `T` is Send/Sync\n* Our pointer is never null (so `Option<Vec<T>>` is null-pointer-optimized)\n\nWe can implement all of the above requirements in stable Rust. To do this, instead\nof using `Unique<T>` we will use `NonNull<T>`, another wrapper around a\nraw pointer, which gives us two of the above properties, namely it is covariant\nover `T` and is declared to never be null. By implementing Send/Sync if `T` is,\nwe get the same results as using `Unique<T>`:\n\nuse std::ptr::NonNull;\n\npub struct Vec<T> {\n    ptr: NonNull<T>,\n    cap: usize,\n    len: usize,\n}\n\nunsafe impl<T: Send> Send for Vec<T> {}\nunsafe impl<T: Sync> Sync for Vec<T> {}",
      "parent_id": null,
      "paragraphs": {
        "nomicon_layout_p1": "First off, we need to come up with the struct layout. A Vec has three parts:\na pointer to the allocation, the size of the allocation, and the number of\nelements that have been initialized.",
        "nomicon_layout_p2": "Naively, this means we just want this design:",
        "nomicon_layout_p3": "<!-- ignore: simplified code -->\n,ignore\npub struct Vec<T> {\n    ptr: *mut T,\n    cap: usize,\n    len: usize,\n}",
        "nomicon_layout_p4": "And indeed this would compile. Unfortunately, it would be too strict. The\ncompiler will give us too strict variance. So a `&Vec<&'static str>`\ncouldn't be used where a `&Vec<&'a str>` was expected. See the chapter\non ownership and lifetimes for all the details on variance.",
        "nomicon_layout_p5": "As we saw in the ownership chapter, the standard library uses `Unique<T>` in place of\n`*mut T` when it has a raw pointer to an allocation that it owns. Unique is unstable,\nso we'd like to not use it if possible, though.",
        "nomicon_layout_p6": "As a recap, Unique is a wrapper around a raw pointer that declares that:",
        "nomicon_layout_p7": "* We are covariant over `T`\n* We may own a value of type `T` (this is not relevant for our example here, but see \n  the chapter on PhantomData on why the real `std::vec::Vec<T>` needs this)\n* We are Send/Sync if `T` is Send/Sync\n* Our pointer is never null (so `Option<Vec<T>>` is null-pointer-optimized)",
        "nomicon_layout_p8": "We can implement all of the above requirements in stable Rust. To do this, instead\nof using `Unique<T>` we will use `NonNull<T>`, another wrapper around a\nraw pointer, which gives us two of the above properties, namely it is covariant\nover `T` and is declared to never be null. By implementing Send/Sync if `T` is,\nwe get the same results as using `Unique<T>`:",
        "nomicon_layout_p9": "use std::ptr::NonNull;",
        "nomicon_layout_p10": "pub struct Vec<T> {\n    ptr: NonNull<T>,\n    cap: usize,\n    len: usize,\n}",
        "nomicon_layout_p11": "unsafe impl<T: Send> Send for Vec<T> {}\nunsafe impl<T: Sync> Sync for Vec<T> {}"
      }
    },
    {
      "id": "nomicon_fn_main",
      "title": "fn main() {}",
      "level": 1,
      "content": "[ownership]: ../ownership.html\n[phantom-data]: ../phantom-data.md\n[NonNull]: ../../std/ptr/struct.NonNull.html",
      "parent_id": null,
      "paragraphs": {
        "nomicon_fn_main_p1": "",
        "nomicon_fn_main_p2": "[ownership]: ../ownership.html\n[phantom-data]: ../phantom-data.md\n[NonNull]: ../../std/ptr/struct.NonNull.html"
      }
    },
    {
      "id": "nomicon_allocating_memory",
      "title": "Allocating Memory",
      "level": 1,
      "content": "Using `NonNull` throws a wrench in an important feature of Vec (and indeed all of\nthe std collections): creating an empty Vec doesn't actually allocate at all. This\nis not the same as allocating a zero-sized memory block, which is not allowed by\nthe global allocator (it results in undefined behavior!). So if we can't allocate,\nbut also can't put a null pointer in `ptr`, what do we do in `Vec::new`? Well, we\njust put some other garbage in there!\n\nThis is perfectly fine because we already have `cap == 0` as our sentinel for no\nallocation. We don't even need to handle it specially in almost any code because\nwe usually need to check if `cap > len` or `len > 0` anyway. The recommended\nRust value to put here is `mem::align_of::<T>()`. `NonNull` provides a convenience\nfor this: `NonNull::dangling()`. There are quite a few places where we'll\nwant to use `dangling` because there's no real allocation to talk about but\n`null` would make the compiler do bad things.\n\nSo:\n\n<!-- ignore: explanation code -->\n,ignore\nuse std::mem;\n\nimpl<T> Vec<T> {\n    pub fn new() -> Self {\n        assert!(mem::size_of::<T>() != 0, \"We're not ready to handle ZSTs\");\n        Vec {\n            ptr: NonNull::dangling(),\n            len: 0,\n            cap: 0,\n        }\n    }\n}",
      "parent_id": null,
      "paragraphs": {
        "nomicon_allocating_memory_p1": "Using `NonNull` throws a wrench in an important feature of Vec (and indeed all of\nthe std collections): creating an empty Vec doesn't actually allocate at all. This\nis not the same as allocating a zero-sized memory block, which is not allowed by\nthe global allocator (it results in undefined behavior!). So if we can't allocate,\nbut also can't put a null pointer in `ptr`, what do we do in `Vec::new`? Well, we\njust put some other garbage in there!",
        "nomicon_allocating_memory_p2": "This is perfectly fine because we already have `cap == 0` as our sentinel for no\nallocation. We don't even need to handle it specially in almost any code because\nwe usually need to check if `cap > len` or `len > 0` anyway. The recommended\nRust value to put here is `mem::align_of::<T>()`. `NonNull` provides a convenience\nfor this: `NonNull::dangling()`. There are quite a few places where we'll\nwant to use `dangling` because there's no real allocation to talk about but\n`null` would make the compiler do bad things.",
        "nomicon_allocating_memory_p3": "So:",
        "nomicon_allocating_memory_p4": "<!-- ignore: explanation code -->\n,ignore\nuse std::mem;",
        "nomicon_allocating_memory_p5": "impl<T> Vec<T> {\n    pub fn new() -> Self {\n        assert!(mem::size_of::<T>() != 0, \"We're not ready to handle ZSTs\");\n        Vec {\n            ptr: NonNull::dangling(),\n            len: 0,\n            cap: 0,\n        }\n    }\n}"
      }
    },
    {
      "id": "nomicon_fn_main",
      "title": "fn main() {}",
      "level": 1,
      "content": "I slipped in that assert there because zero-sized types will require some\nspecial handling throughout our code, and I want to defer the issue for now.\nWithout this assert, some of our early drafts will do some Very Bad Things.\n\nNext we need to figure out what to actually do when we *do* want space. For that,\nwe use the global allocation functions `alloc`, `realloc`,\nand `dealloc` which are available in stable Rust in\n`std::alloc`. These functions are expected to become deprecated in\nfavor of the methods of `std::alloc::Global` after this type is stabilized.\n\nWe'll also need a way to handle out-of-memory (OOM) conditions. The standard\nlibrary provides a function `alloc::handle_alloc_error`,\nwhich will abort the program in a platform-specific manner.\nThe reason we abort and don't panic is because unwinding can cause allocations\nto happen, and that seems like a bad thing to do when your allocator just came\nback with \"hey I don't have any more memory\".\n\nOf course, this is a bit silly since most platforms don't actually run out of\nmemory in a conventional way. Your operating system will probably kill the\napplication by another means if you legitimately start using up all the memory.\nThe most likely way we'll trigger OOM is by just asking for ludicrous quantities\nof memory at once (e.g. half the theoretical address space). As such it's\n*probably* fine to panic and nothing bad will happen. Still, we're trying to be\nlike the standard library as much as possible, so we'll just kill the whole\nprogram.\n\nOkay, now we can write growing. Roughly, we want to have this logic:\n\nif cap == 0:\n    allocate()\n    cap = 1\nelse:\n    reallocate()\n    cap *= 2\n\nBut Rust's only supported allocator API is so low level that we'll need to do a\nfair bit of extra work. We also need to guard against some special\nconditions that can occur with really large allocations or empty allocations.\n\nIn particular, `ptr::offset` will cause us a lot of trouble, because it has\nthe semantics of LLVM's GEP inbounds instruction. If you're fortunate enough to\nnot have dealt with this instruction, here's the basic story with GEP: alias\nanalysis, alias analysis, alias analysis. It's super important to an optimizing\ncompiler to be able to reason about data dependencies and aliasing.\n\nAs a simple example, consider the following fragment of code:\n\n<!-- ignore: simplified code -->\n,ignore\n*x *= 7;\n*y *= 3;\n\nIf the compiler can prove that `x` and `y` point to different locations in\nmemory, the two operations can in theory be executed in parallel (by e.g.\nloading them into different registers and working on them independently).\nHowever the compiler can't do this in general because if x and y point to\nthe same location in memory, the operations need to be done to the same value,\nand they can't just be merged afterwards.\n\nWhen you use GEP inbounds, you are specifically telling LLVM that the offsets\nyou're about to do are within the bounds of a single \"allocated\" entity. The\nultimate payoff being that LLVM can assume that if two pointers are known to\npoint to two disjoint objects, all the offsets of those pointers are *also*\nknown to not alias (because you won't just end up in some random place in\nmemory). LLVM is heavily optimized to work with GEP offsets, and inbounds\noffsets are the best of all, so it's important that we use them as much as\npossible.\n\nSo that's what GEP's about, how can it cause us trouble?\n\nThe first problem is that we index into arrays with unsigned integers, but\nGEP (and as a consequence `ptr::offset`) takes a signed integer. This means\nthat half of the seemingly valid indices into an array will overflow GEP and\nactually go in the wrong direction! As such we must limit all allocations to\n`isize::MAX` elements. This actually means we only need to worry about\nbyte-sized objects, because e.g. `> isize::MAX` `u16`s will truly exhaust all of\nthe system's memory. However in order to avoid subtle corner cases where someone\nreinterprets some array of `< isize::MAX` objects as bytes, std limits all\nallocations to `isize::MAX` bytes.\n\nOn all 64-bit targets that Rust currently supports we're artificially limited\nto significantly less than all 64 bits of the address space (modern x64\nplatforms only expose 48-bit addressing), so we can rely on just running out of\nmemory first. However on 32-bit targets, particularly those with extensions to\nuse more of the address space (PAE x86 or x32), it's theoretically possible to\nsuccessfully allocate more than `isize::MAX` bytes of memory.\n\nHowever since this is a tutorial, we're not going to be particularly optimal\nhere, and just unconditionally check, rather than use clever platform-specific\n`cfg`s.\n\nThe other corner-case we need to worry about is empty allocations. There will\nbe two kinds of empty allocations we need to worry about: `cap = 0` for all T,\nand `cap > 0` for zero-sized types.\n\nThese cases are tricky because they come\ndown to what LLVM means by \"allocated\". LLVM's notion of an\nallocation is significantly more abstract than how we usually use it. Because\nLLVM needs to work with different languages' semantics and custom allocators,\nit can't really intimately understand allocation. Instead, the main idea behind\nallocation is \"doesn't overlap with other stuff\". That is, heap allocations,\nstack allocations, and globals don't randomly overlap. Yep, it's about alias\nanalysis. As such, Rust can technically play a bit fast and loose with the notion of\nan allocation as long as it's *consistent*.\n\nGetting back to the empty allocation case, there are a couple of places where\nwe want to offset by 0 as a consequence of generic code. The question is then:\nis it consistent to do so? For zero-sized types, we have concluded that it is\nindeed consistent to do a GEP inbounds offset by an arbitrary number of\nelements. This is a runtime no-op because every element takes up no space,\nand it's fine to pretend that there's infinite zero-sized types allocated\nat `0x01`. No allocator will ever allocate that address, because they won't\nallocate `0x00` and they generally allocate to some minimal alignment higher\nthan a byte. Also generally the whole first page of memory is\nprotected from being allocated anyway (a whole 4k, on many platforms).\n\nHowever what about for positive-sized types? That one's a bit trickier. In\nprinciple, you can argue that offsetting by 0 gives LLVM no information: either\nthere's an element before the address or after it, but it can't know which.\nHowever we've chosen to conservatively assume that it may do bad things. As\nsuch we will guard against this case explicitly.\n\n*Phew*\n\nOk with all the nonsense out of the way, let's actually allocate some memory:\n\n<!-- ignore: simplified code -->\n,ignore\nuse std::alloc::{self, Layout};\n\nimpl<T> Vec<T> {\n    fn grow(&mut self) {\n        let (new_cap, new_layout) = if self.cap == 0 {\n            (1, Layout::array::<T>(1))\n        } else {\n            // This can't overflow since self.cap <= isize::MAX.\n            let new_cap = 2 * self.cap;\n            (new_cap, Layout::array::<T>(new_cap))\n        };\n\n        // `Layout::array` checks that the number of bytes allocated is\n        // in 1..=isize::MAX and will error otherwise.  An allocation of\n        // 0 bytes isn't possible thanks to the above condition.\n        let new_layout = new_layout.expect(\"Allocation too large\");\n\n        let new_ptr = if self.cap == 0 {\n            unsafe { alloc::alloc(new_layout) }\n        } else {\n            let old_layout = Layout::array::<T>(self.cap).unwrap();\n            let old_ptr = self.ptr.as_ptr() as *mut u8;\n            unsafe { alloc::realloc(old_ptr, old_layout, new_layout.size()) }\n        };\n\n        // If allocation fails, `new_ptr` will be null, in which case we abort.\n        self.ptr = match NonNull::new(new_ptr as *mut T) {\n            Some(p) => p,\n            None => alloc::handle_alloc_error(new_layout),\n        };\n        self.cap = new_cap;\n    }\n}",
      "parent_id": null,
      "paragraphs": {
        "nomicon_fn_main_p1": "",
        "nomicon_fn_main_p2": "I slipped in that assert there because zero-sized types will require some\nspecial handling throughout our code, and I want to defer the issue for now.\nWithout this assert, some of our early drafts will do some Very Bad Things.",
        "nomicon_fn_main_p3": "Next we need to figure out what to actually do when we *do* want space. For that,\nwe use the global allocation functions `alloc`, `realloc`,\nand `dealloc` which are available in stable Rust in\n`std::alloc`. These functions are expected to become deprecated in\nfavor of the methods of `std::alloc::Global` after this type is stabilized.",
        "nomicon_fn_main_p4": "We'll also need a way to handle out-of-memory (OOM) conditions. The standard\nlibrary provides a function `alloc::handle_alloc_error`,\nwhich will abort the program in a platform-specific manner.\nThe reason we abort and don't panic is because unwinding can cause allocations\nto happen, and that seems like a bad thing to do when your allocator just came\nback with \"hey I don't have any more memory\".",
        "nomicon_fn_main_p5": "Of course, this is a bit silly since most platforms don't actually run out of\nmemory in a conventional way. Your operating system will probably kill the\napplication by another means if you legitimately start using up all the memory.\nThe most likely way we'll trigger OOM is by just asking for ludicrous quantities\nof memory at once (e.g. half the theoretical address space). As such it's\n*probably* fine to panic and nothing bad will happen. Still, we're trying to be\nlike the standard library as much as possible, so we'll just kill the whole\nprogram.",
        "nomicon_fn_main_p6": "Okay, now we can write growing. Roughly, we want to have this logic:",
        "nomicon_fn_main_p7": "if cap == 0:\n    allocate()\n    cap = 1\nelse:\n    reallocate()\n    cap *= 2",
        "nomicon_fn_main_p8": "But Rust's only supported allocator API is so low level that we'll need to do a\nfair bit of extra work. We also need to guard against some special\nconditions that can occur with really large allocations or empty allocations.",
        "nomicon_fn_main_p9": "In particular, `ptr::offset` will cause us a lot of trouble, because it has\nthe semantics of LLVM's GEP inbounds instruction. If you're fortunate enough to\nnot have dealt with this instruction, here's the basic story with GEP: alias\nanalysis, alias analysis, alias analysis. It's super important to an optimizing\ncompiler to be able to reason about data dependencies and aliasing.",
        "nomicon_fn_main_p10": "As a simple example, consider the following fragment of code:",
        "nomicon_fn_main_p11": "<!-- ignore: simplified code -->\n,ignore\n*x *= 7;\n*y *= 3;",
        "nomicon_fn_main_p12": "If the compiler can prove that `x` and `y` point to different locations in\nmemory, the two operations can in theory be executed in parallel (by e.g.\nloading them into different registers and working on them independently).\nHowever the compiler can't do this in general because if x and y point to\nthe same location in memory, the operations need to be done to the same value,\nand they can't just be merged afterwards.",
        "nomicon_fn_main_p13": "When you use GEP inbounds, you are specifically telling LLVM that the offsets\nyou're about to do are within the bounds of a single \"allocated\" entity. The\nultimate payoff being that LLVM can assume that if two pointers are known to\npoint to two disjoint objects, all the offsets of those pointers are *also*\nknown to not alias (because you won't just end up in some random place in\nmemory). LLVM is heavily optimized to work with GEP offsets, and inbounds\noffsets are the best of all, so it's important that we use them as much as\npossible.",
        "nomicon_fn_main_p14": "So that's what GEP's about, how can it cause us trouble?",
        "nomicon_fn_main_p15": "The first problem is that we index into arrays with unsigned integers, but\nGEP (and as a consequence `ptr::offset`) takes a signed integer. This means\nthat half of the seemingly valid indices into an array will overflow GEP and\nactually go in the wrong direction! As such we must limit all allocations to\n`isize::MAX` elements. This actually means we only need to worry about\nbyte-sized objects, because e.g. `> isize::MAX` `u16`s will truly exhaust all of\nthe system's memory. However in order to avoid subtle corner cases where someone\nreinterprets some array of `< isize::MAX` objects as bytes, std limits all\nallocations to `isize::MAX` bytes.",
        "nomicon_fn_main_p16": "On all 64-bit targets that Rust currently supports we're artificially limited\nto significantly less than all 64 bits of the address space (modern x64\nplatforms only expose 48-bit addressing), so we can rely on just running out of\nmemory first. However on 32-bit targets, particularly those with extensions to\nuse more of the address space (PAE x86 or x32), it's theoretically possible to\nsuccessfully allocate more than `isize::MAX` bytes of memory.",
        "nomicon_fn_main_p17": "However since this is a tutorial, we're not going to be particularly optimal\nhere, and just unconditionally check, rather than use clever platform-specific\n`cfg`s.",
        "nomicon_fn_main_p18": "The other corner-case we need to worry about is empty allocations. There will\nbe two kinds of empty allocations we need to worry about: `cap = 0` for all T,\nand `cap > 0` for zero-sized types.",
        "nomicon_fn_main_p19": "These cases are tricky because they come\ndown to what LLVM means by \"allocated\". LLVM's notion of an\nallocation is significantly more abstract than how we usually use it. Because\nLLVM needs to work with different languages' semantics and custom allocators,\nit can't really intimately understand allocation. Instead, the main idea behind\nallocation is \"doesn't overlap with other stuff\". That is, heap allocations,\nstack allocations, and globals don't randomly overlap. Yep, it's about alias\nanalysis. As such, Rust can technically play a bit fast and loose with the notion of\nan allocation as long as it's *consistent*.",
        "nomicon_fn_main_p20": "Getting back to the empty allocation case, there are a couple of places where\nwe want to offset by 0 as a consequence of generic code. The question is then:\nis it consistent to do so? For zero-sized types, we have concluded that it is\nindeed consistent to do a GEP inbounds offset by an arbitrary number of\nelements. This is a runtime no-op because every element takes up no space,\nand it's fine to pretend that there's infinite zero-sized types allocated\nat `0x01`. No allocator will ever allocate that address, because they won't\nallocate `0x00` and they generally allocate to some minimal alignment higher\nthan a byte. Also generally the whole first page of memory is\nprotected from being allocated anyway (a whole 4k, on many platforms).",
        "nomicon_fn_main_p21": "However what about for positive-sized types? That one's a bit trickier. In\nprinciple, you can argue that offsetting by 0 gives LLVM no information: either\nthere's an element before the address or after it, but it can't know which.\nHowever we've chosen to conservatively assume that it may do bad things. As\nsuch we will guard against this case explicitly.",
        "nomicon_fn_main_p22": "*Phew*",
        "nomicon_fn_main_p23": "Ok with all the nonsense out of the way, let's actually allocate some memory:",
        "nomicon_fn_main_p24": "<!-- ignore: simplified code -->\n,ignore\nuse std::alloc::{self, Layout};",
        "nomicon_fn_main_p25": "impl<T> Vec<T> {\n    fn grow(&mut self) {\n        let (new_cap, new_layout) = if self.cap == 0 {\n            (1, Layout::array::<T>(1))\n        } else {\n            // This can't overflow since self.cap <= isize::MAX.\n            let new_cap = 2 * self.cap;\n            (new_cap, Layout::array::<T>(new_cap))\n        };",
        "nomicon_fn_main_p26": "// `Layout::array` checks that the number of bytes allocated is\n        // in 1..=isize::MAX and will error otherwise.  An allocation of\n        // 0 bytes isn't possible thanks to the above condition.\n        let new_layout = new_layout.expect(\"Allocation too large\");",
        "nomicon_fn_main_p27": "let new_ptr = if self.cap == 0 {\n            unsafe { alloc::alloc(new_layout) }\n        } else {\n            let old_layout = Layout::array::<T>(self.cap).unwrap();\n            let old_ptr = self.ptr.as_ptr() as *mut u8;\n            unsafe { alloc::realloc(old_ptr, old_layout, new_layout.size()) }\n        };",
        "nomicon_fn_main_p28": "// If allocation fails, `new_ptr` will be null, in which case we abort.\n        self.ptr = match NonNull::new(new_ptr as *mut T) {\n            Some(p) => p,\n            None => alloc::handle_alloc_error(new_layout),\n        };\n        self.cap = new_cap;\n    }\n}"
      }
    },
    {
      "id": "nomicon_fn_main",
      "title": "fn main() {}",
      "level": 1,
      "content": "[Global]: ../../std/alloc/struct.Global.html\n[handle_alloc_error]: ../../alloc/alloc/fn.handle_alloc_error.html\n[alloc]: ../../alloc/alloc/fn.alloc.html\n[realloc]: ../../alloc/alloc/fn.realloc.html\n[dealloc]: ../../alloc/alloc/fn.dealloc.html\n[std_alloc]: ../../alloc/alloc/index.html",
      "parent_id": null,
      "paragraphs": {
        "nomicon_fn_main_p1": "",
        "nomicon_fn_main_p2": "[Global]: ../../std/alloc/struct.Global.html\n[handle_alloc_error]: ../../alloc/alloc/fn.handle_alloc_error.html\n[alloc]: ../../alloc/alloc/fn.alloc.html\n[realloc]: ../../alloc/alloc/fn.realloc.html\n[dealloc]: ../../alloc/alloc/fn.dealloc.html\n[std_alloc]: ../../alloc/alloc/index.html"
      }
    },
    {
      "id": "nomicon_push_and_pop",
      "title": "Push and Pop",
      "level": 1,
      "content": "Alright. We can initialize. We can allocate. Let's actually implement some\nfunctionality! Let's start with `push`. All it needs to do is check if we're\nfull to grow, unconditionally write to the next index, and then increment our\nlength.\n\nTo do the write we have to be careful not to evaluate the memory we want to write\nto. At worst, it's truly uninitialized memory from the allocator. At best it's the\nbits of some old value we popped off. Either way, we can't just index to the memory\nand dereference it, because that will evaluate the memory as a valid instance of\nT. Worse, `foo[idx] = x` will try to call `drop` on the old value of `foo[idx]`!\n\nThe correct way to do this is with `ptr::write`, which just blindly overwrites the\ntarget address with the bits of the value we provide. No evaluation involved.\n\nFor `push`, if the old len (before push was called) is 0, then we want to write\nto the 0th index. So we should offset by the old len.\n\n<!-- ignore: simplified code -->\n,ignore\npub fn push(&mut self, elem: T) {\n    if self.len == self.cap { self.grow(); }\n\n    unsafe {\n        ptr::write(self.ptr.as_ptr().add(self.len), elem);\n    }\n\n    // Can't fail, we'll OOM first.\n    self.len += 1;\n}\n\nEasy! How about `pop`? Although this time the index we want to access is\ninitialized, Rust won't just let us dereference the location of memory to move\nthe value out, because that would leave the memory uninitialized! For this we\nneed `ptr::read`, which just copies out the bits from the target address and\ninterprets it as a value of type T. This will leave the memory at this address\nlogically uninitialized, even though there is in fact a perfectly good instance\nof T there.\n\nFor `pop`, if the old len is 1, for example, we want to read out of the 0th\nindex. So we should offset by the new len.\n\n<!-- ignore: simplified code -->\n,ignore\npub fn pop(&mut self) -> Option<T> {\n    if self.len == 0 {\n        None\n    } else {\n        self.len -= 1;\n        unsafe {\n            Some(ptr::read(self.ptr.as_ptr().add(self.len)))\n        }\n    }\n}",
      "parent_id": null,
      "paragraphs": {
        "nomicon_push_and_pop_p1": "Alright. We can initialize. We can allocate. Let's actually implement some\nfunctionality! Let's start with `push`. All it needs to do is check if we're\nfull to grow, unconditionally write to the next index, and then increment our\nlength.",
        "nomicon_push_and_pop_p2": "To do the write we have to be careful not to evaluate the memory we want to write\nto. At worst, it's truly uninitialized memory from the allocator. At best it's the\nbits of some old value we popped off. Either way, we can't just index to the memory\nand dereference it, because that will evaluate the memory as a valid instance of\nT. Worse, `foo[idx] = x` will try to call `drop` on the old value of `foo[idx]`!",
        "nomicon_push_and_pop_p3": "The correct way to do this is with `ptr::write`, which just blindly overwrites the\ntarget address with the bits of the value we provide. No evaluation involved.",
        "nomicon_push_and_pop_p4": "For `push`, if the old len (before push was called) is 0, then we want to write\nto the 0th index. So we should offset by the old len.",
        "nomicon_push_and_pop_p5": "<!-- ignore: simplified code -->\n,ignore\npub fn push(&mut self, elem: T) {\n    if self.len == self.cap { self.grow(); }",
        "nomicon_push_and_pop_p6": "unsafe {\n        ptr::write(self.ptr.as_ptr().add(self.len), elem);\n    }",
        "nomicon_push_and_pop_p7": "// Can't fail, we'll OOM first.\n    self.len += 1;\n}",
        "nomicon_push_and_pop_p8": "Easy! How about `pop`? Although this time the index we want to access is\ninitialized, Rust won't just let us dereference the location of memory to move\nthe value out, because that would leave the memory uninitialized! For this we\nneed `ptr::read`, which just copies out the bits from the target address and\ninterprets it as a value of type T. This will leave the memory at this address\nlogically uninitialized, even though there is in fact a perfectly good instance\nof T there.",
        "nomicon_push_and_pop_p9": "For `pop`, if the old len is 1, for example, we want to read out of the 0th\nindex. So we should offset by the new len.",
        "nomicon_push_and_pop_p10": "<!-- ignore: simplified code -->\n,ignore\npub fn pop(&mut self) -> Option<T> {\n    if self.len == 0 {\n        None\n    } else {\n        self.len -= 1;\n        unsafe {\n            Some(ptr::read(self.ptr.as_ptr().add(self.len)))\n        }\n    }\n}"
      }
    },
    {
      "id": "nomicon_deallocating",
      "title": "Deallocating",
      "level": 1,
      "content": "Next we should implement Drop so that we don't massively leak tons of resources.\nThe easiest way is to just call `pop` until it yields None, and then deallocate\nour buffer. Note that calling `pop` is unneeded if `T: !Drop`. In theory we can\nask Rust if `T` `needs_drop` and omit the calls to `pop`. However in practice\nLLVM is *really* good at removing simple side-effect free code like this, so I\nwouldn't bother unless you notice it's not being stripped (in this case it is).\n\nWe must not call `alloc::dealloc` when `self.cap == 0`, as in this case we\nhaven't actually allocated any memory.\n\n<!-- ignore: simplified code -->\n,ignore\nimpl<T> Drop for Vec<T> {\n    fn drop(&mut self) {\n        if self.cap != 0 {\n            while let Some(_) = self.pop() { }\n            let layout = Layout::array::<T>(self.cap).unwrap();\n            unsafe {\n                alloc::dealloc(self.ptr.as_ptr() as *mut u8, layout);\n            }\n        }\n    }\n}",
      "parent_id": null,
      "paragraphs": {
        "nomicon_deallocating_p1": "Next we should implement Drop so that we don't massively leak tons of resources.\nThe easiest way is to just call `pop` until it yields None, and then deallocate\nour buffer. Note that calling `pop` is unneeded if `T: !Drop`. In theory we can\nask Rust if `T` `needs_drop` and omit the calls to `pop`. However in practice\nLLVM is *really* good at removing simple side-effect free code like this, so I\nwouldn't bother unless you notice it's not being stripped (in this case it is).",
        "nomicon_deallocating_p2": "We must not call `alloc::dealloc` when `self.cap == 0`, as in this case we\nhaven't actually allocated any memory.",
        "nomicon_deallocating_p3": "<!-- ignore: simplified code -->\n,ignore\nimpl<T> Drop for Vec<T> {\n    fn drop(&mut self) {\n        if self.cap != 0 {\n            while let Some(_) = self.pop() { }\n            let layout = Layout::array::<T>(self.cap).unwrap();\n            unsafe {\n                alloc::dealloc(self.ptr.as_ptr() as *mut u8, layout);\n            }\n        }\n    }\n}"
      }
    },
    {
      "id": "nomicon_deref",
      "title": "Deref",
      "level": 1,
      "content": "Alright! We've got a decent minimal stack implemented. We can push, we can\npop, and we can clean up after ourselves. However there's a whole mess of\nfunctionality we'd reasonably want. In particular, we have a proper array, but\nnone of the slice functionality. That's actually pretty easy to solve: we can\nimplement `Deref<Target=[T]>`. This will magically make our Vec coerce to, and\nbehave like, a slice in all sorts of conditions.\n\nAll we need is `slice::from_raw_parts`. It will correctly handle empty slices\nfor us. Later once we set up zero-sized type support it will also Just Work\nfor those too.\n\n<!-- ignore: simplified code -->\n,ignore\nuse std::ops::Deref;\n\nimpl<T> Deref for Vec<T> {\n    type Target = [T];\n    fn deref(&self) -> &[T] {\n        unsafe {\n            std::slice::from_raw_parts(self.ptr.as_ptr(), self.len)\n        }\n    }\n}\n\nAnd let's do DerefMut too:\n\n<!-- ignore: simplified code -->\n,ignore\nuse std::ops::DerefMut;\n\nimpl<T> DerefMut for Vec<T> {\n    fn deref_mut(&mut self) -> &mut [T] {\n        unsafe {\n            std::slice::from_raw_parts_mut(self.ptr.as_ptr(), self.len)\n        }\n    }\n}\n\nNow we have `len`, `first`, `last`, indexing, slicing, sorting, `iter`,\n`iter_mut`, and all other sorts of bells and whistles provided by slice. Sweet!",
      "parent_id": null,
      "paragraphs": {
        "nomicon_deref_p1": "Alright! We've got a decent minimal stack implemented. We can push, we can\npop, and we can clean up after ourselves. However there's a whole mess of\nfunctionality we'd reasonably want. In particular, we have a proper array, but\nnone of the slice functionality. That's actually pretty easy to solve: we can\nimplement `Deref<Target=[T]>`. This will magically make our Vec coerce to, and\nbehave like, a slice in all sorts of conditions.",
        "nomicon_deref_p2": "All we need is `slice::from_raw_parts`. It will correctly handle empty slices\nfor us. Later once we set up zero-sized type support it will also Just Work\nfor those too.",
        "nomicon_deref_p3": "<!-- ignore: simplified code -->\n,ignore\nuse std::ops::Deref;",
        "nomicon_deref_p4": "impl<T> Deref for Vec<T> {\n    type Target = [T];\n    fn deref(&self) -> &[T] {\n        unsafe {\n            std::slice::from_raw_parts(self.ptr.as_ptr(), self.len)\n        }\n    }\n}",
        "nomicon_deref_p5": "And let's do DerefMut too:",
        "nomicon_deref_p6": "<!-- ignore: simplified code -->\n,ignore\nuse std::ops::DerefMut;",
        "nomicon_deref_p7": "impl<T> DerefMut for Vec<T> {\n    fn deref_mut(&mut self) -> &mut [T] {\n        unsafe {\n            std::slice::from_raw_parts_mut(self.ptr.as_ptr(), self.len)\n        }\n    }\n}",
        "nomicon_deref_p8": "Now we have `len`, `first`, `last`, indexing, slicing, sorting, `iter`,\n`iter_mut`, and all other sorts of bells and whistles provided by slice. Sweet!"
      }
    },
    {
      "id": "nomicon_insert_and_remove",
      "title": "Insert and Remove",
      "level": 1,
      "content": "Something *not* provided by slice is `insert` and `remove`, so let's do those\nnext.\n\nInsert needs to shift all the elements at the target index to the right by one.\nTo do this we need to use `ptr::copy`, which is our version of C's `memmove`.\nThis copies some chunk of memory from one location to another, correctly\nhandling the case where the source and destination overlap (which will\ndefinitely happen here).\n\nIf we insert at index `i`, we want to shift the `[i .. len]` to `[i+1 .. len+1]`\nusing the old len.\n\n<!-- ignore: simplified code -->\n,ignore\npub fn insert(&mut self, index: usize, elem: T) {\n    // Note: `<=` because it's valid to insert after everything\n    // which would be equivalent to push.\n    assert!(index <= self.len, \"index out of bounds\");\n    if self.len == self.cap { self.grow(); }\n\n    unsafe {\n        // ptr::copy(src, dest, len): \"copy from src to dest len elems\"\n        ptr::copy(\n            self.ptr.as_ptr().add(index),\n            self.ptr.as_ptr().add(index + 1),\n            self.len - index,\n        );\n        ptr::write(self.ptr.as_ptr().add(index), elem);\n    }\n\n    self.len += 1;\n}\n\nRemove behaves in the opposite manner. We need to shift all the elements from\n`[i+1 .. len + 1]` to `[i .. len]` using the *new* len.\n\n<!-- ignore: simplified code -->\n,ignore\npub fn remove(&mut self, index: usize) -> T {\n    // Note: `<` because it's *not* valid to remove after everything\n    assert!(index < self.len, \"index out of bounds\");\n    unsafe {\n        self.len -= 1;\n        let result = ptr::read(self.ptr.as_ptr().add(index));\n        ptr::copy(\n            self.ptr.as_ptr().add(index + 1),\n            self.ptr.as_ptr().add(index),\n            self.len - index,\n        );\n        result\n    }\n}",
      "parent_id": null,
      "paragraphs": {
        "nomicon_insert_and_remove_p1": "Something *not* provided by slice is `insert` and `remove`, so let's do those\nnext.",
        "nomicon_insert_and_remove_p2": "Insert needs to shift all the elements at the target index to the right by one.\nTo do this we need to use `ptr::copy`, which is our version of C's `memmove`.\nThis copies some chunk of memory from one location to another, correctly\nhandling the case where the source and destination overlap (which will\ndefinitely happen here).",
        "nomicon_insert_and_remove_p3": "If we insert at index `i`, we want to shift the `[i .. len]` to `[i+1 .. len+1]`\nusing the old len.",
        "nomicon_insert_and_remove_p4": "<!-- ignore: simplified code -->\n,ignore\npub fn insert(&mut self, index: usize, elem: T) {\n    // Note: `<=` because it's valid to insert after everything\n    // which would be equivalent to push.\n    assert!(index <= self.len, \"index out of bounds\");\n    if self.len == self.cap { self.grow(); }",
        "nomicon_insert_and_remove_p5": "unsafe {\n        // ptr::copy(src, dest, len): \"copy from src to dest len elems\"\n        ptr::copy(\n            self.ptr.as_ptr().add(index),\n            self.ptr.as_ptr().add(index + 1),\n            self.len - index,\n        );\n        ptr::write(self.ptr.as_ptr().add(index), elem);\n    }",
        "nomicon_insert_and_remove_p6": "self.len += 1;\n}",
        "nomicon_insert_and_remove_p7": "Remove behaves in the opposite manner. We need to shift all the elements from\n`[i+1 .. len + 1]` to `[i .. len]` using the *new* len.",
        "nomicon_insert_and_remove_p8": "<!-- ignore: simplified code -->\n,ignore\npub fn remove(&mut self, index: usize) -> T {\n    // Note: `<` because it's *not* valid to remove after everything\n    assert!(index < self.len, \"index out of bounds\");\n    unsafe {\n        self.len -= 1;\n        let result = ptr::read(self.ptr.as_ptr().add(index));\n        ptr::copy(\n            self.ptr.as_ptr().add(index + 1),\n            self.ptr.as_ptr().add(index),\n            self.len - index,\n        );\n        result\n    }\n}"
      }
    },
    {
      "id": "nomicon_intoiter",
      "title": "IntoIter",
      "level": 1,
      "content": "Let's move on to writing iterators. `iter` and `iter_mut` have already been\nwritten for us thanks to The Magic of Deref. However there's two interesting\niterators that Vec provides that slices can't: `into_iter` and `drain`.\n\nIntoIter consumes the Vec by-value, and can consequently yield its elements\nby-value. In order to enable this, IntoIter needs to take control of Vec's\nallocation.\n\nIntoIter needs to be DoubleEnded as well, to enable reading from both ends.\nReading from the back could just be implemented as calling `pop`, but reading\nfrom the front is harder. We could call `remove(0)` but that would be insanely\nexpensive. Instead we're going to just use ptr::read to copy values out of\neither end of the Vec without mutating the buffer at all.\n\nTo do this we're going to use a very common C idiom for array iteration. We'll\nmake two pointers; one that points to the start of the array, and one that\npoints to one-element past the end. When we want an element from one end, we'll\nread out the value pointed to at that end and move the pointer over by one. When\nthe two pointers are equal, we know we're done.\n\nNote that the order of read and offset are reversed for `next` and `next_back`\nFor `next_back` the pointer is always after the element it wants to read next,\nwhile for `next` the pointer is always at the element it wants to read next.\nTo see why this is, consider the case where every element but one has been\nyielded.\n\nThe array looks like this:\n\n          S  E\n[X, X, X, O, X, X, X]\n\nIf E pointed directly at the element it wanted to yield next, it would be\nindistinguishable from the case where there are no more elements to yield.\n\nAlthough we don't actually care about it during iteration, we also need to hold\nonto the Vec's allocation information in order to free it once IntoIter is\ndropped.\n\nSo we're going to use the following struct:\n\n<!-- ignore: simplified code -->\n,ignore\npub struct IntoIter<T> {\n    buf: NonNull<T>,\n    cap: usize,\n    start: *const T,\n    end: *const T,\n}\n\nAnd this is what we end up with for initialization:\n\n<!-- ignore: simplified code -->\n,ignore\nimpl<T> IntoIterator for Vec<T> {\n    type Item = T;\n    type IntoIter = IntoIter<T>;\n    fn into_iter(self) -> IntoIter<T> {\n        // Make sure not to drop Vec since that would free the buffer\n        let vec = ManuallyDrop::new(self);\n\n        // Can't destructure Vec since it's Drop\n        let ptr = vec.ptr;\n        let cap = vec.cap;\n        let len = vec.len;\n\n        IntoIter {\n            buf: ptr,\n            cap,\n            start: ptr.as_ptr(),\n            end: if cap == 0 {\n                // can't offset off this pointer, it's not allocated!\n                ptr.as_ptr()\n            } else {\n                unsafe { ptr.as_ptr().add(len) }\n            },\n        }\n    }\n}\n\nHere's iterating forward:\n\n<!-- ignore: simplified code -->\n,ignore\nimpl<T> Iterator for IntoIter<T> {\n    type Item = T;\n    fn next(&mut self) -> Option<T> {\n        if self.start == self.end {\n            None\n        } else {\n            unsafe {\n                let result = ptr::read(self.start);\n                self.start = self.start.offset(1);\n                Some(result)\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let len = (self.end as usize - self.start as usize)\n                  / mem::size_of::<T>();\n        (len, Some(len))\n    }\n}\n\nAnd here's iterating backwards.\n\n<!-- ignore: simplified code -->\n,ignore\nimpl<T> DoubleEndedIterator for IntoIter<T> {\n    fn next_back(&mut self) -> Option<T> {\n        if self.start == self.end {\n            None\n        } else {\n            unsafe {\n                self.end = self.end.offset(-1);\n                Some(ptr::read(self.end))\n            }\n        }\n    }\n}\n\nBecause IntoIter takes ownership of its allocation, it needs to implement Drop\nto free it. However it also wants to implement Drop to drop any elements it\ncontains that weren't yielded.\n\n<!-- ignore: simplified code -->\n,ignore\nimpl<T> Drop for IntoIter<T> {\n    fn drop(&mut self) {\n        if self.cap != 0 {\n            // drop any remaining elements\n            for _ in &mut *self {}\n            let layout = Layout::array::<T>(self.cap).unwrap();\n            unsafe {\n                alloc::dealloc(self.buf.as_ptr() as *mut u8, layout);\n            }\n        }\n    }\n}",
      "parent_id": null,
      "paragraphs": {
        "nomicon_intoiter_p1": "Let's move on to writing iterators. `iter` and `iter_mut` have already been\nwritten for us thanks to The Magic of Deref. However there's two interesting\niterators that Vec provides that slices can't: `into_iter` and `drain`.",
        "nomicon_intoiter_p2": "IntoIter consumes the Vec by-value, and can consequently yield its elements\nby-value. In order to enable this, IntoIter needs to take control of Vec's\nallocation.",
        "nomicon_intoiter_p3": "IntoIter needs to be DoubleEnded as well, to enable reading from both ends.\nReading from the back could just be implemented as calling `pop`, but reading\nfrom the front is harder. We could call `remove(0)` but that would be insanely\nexpensive. Instead we're going to just use ptr::read to copy values out of\neither end of the Vec without mutating the buffer at all.",
        "nomicon_intoiter_p4": "To do this we're going to use a very common C idiom for array iteration. We'll\nmake two pointers; one that points to the start of the array, and one that\npoints to one-element past the end. When we want an element from one end, we'll\nread out the value pointed to at that end and move the pointer over by one. When\nthe two pointers are equal, we know we're done.",
        "nomicon_intoiter_p5": "Note that the order of read and offset are reversed for `next` and `next_back`\nFor `next_back` the pointer is always after the element it wants to read next,\nwhile for `next` the pointer is always at the element it wants to read next.\nTo see why this is, consider the case where every element but one has been\nyielded.",
        "nomicon_intoiter_p6": "The array looks like this:",
        "nomicon_intoiter_p7": "S  E\n[X, X, X, O, X, X, X]",
        "nomicon_intoiter_p8": "If E pointed directly at the element it wanted to yield next, it would be\nindistinguishable from the case where there are no more elements to yield.",
        "nomicon_intoiter_p9": "Although we don't actually care about it during iteration, we also need to hold\nonto the Vec's allocation information in order to free it once IntoIter is\ndropped.",
        "nomicon_intoiter_p10": "So we're going to use the following struct:",
        "nomicon_intoiter_p11": "<!-- ignore: simplified code -->\n,ignore\npub struct IntoIter<T> {\n    buf: NonNull<T>,\n    cap: usize,\n    start: *const T,\n    end: *const T,\n}",
        "nomicon_intoiter_p12": "And this is what we end up with for initialization:",
        "nomicon_intoiter_p13": "<!-- ignore: simplified code -->\n,ignore\nimpl<T> IntoIterator for Vec<T> {\n    type Item = T;\n    type IntoIter = IntoIter<T>;\n    fn into_iter(self) -> IntoIter<T> {\n        // Make sure not to drop Vec since that would free the buffer\n        let vec = ManuallyDrop::new(self);",
        "nomicon_intoiter_p14": "// Can't destructure Vec since it's Drop\n        let ptr = vec.ptr;\n        let cap = vec.cap;\n        let len = vec.len;",
        "nomicon_intoiter_p15": "IntoIter {\n            buf: ptr,\n            cap,\n            start: ptr.as_ptr(),\n            end: if cap == 0 {\n                // can't offset off this pointer, it's not allocated!\n                ptr.as_ptr()\n            } else {\n                unsafe { ptr.as_ptr().add(len) }\n            },\n        }\n    }\n}",
        "nomicon_intoiter_p16": "Here's iterating forward:",
        "nomicon_intoiter_p17": "<!-- ignore: simplified code -->\n,ignore\nimpl<T> Iterator for IntoIter<T> {\n    type Item = T;\n    fn next(&mut self) -> Option<T> {\n        if self.start == self.end {\n            None\n        } else {\n            unsafe {\n                let result = ptr::read(self.start);\n                self.start = self.start.offset(1);\n                Some(result)\n            }\n        }\n    }",
        "nomicon_intoiter_p18": "fn size_hint(&self) -> (usize, Option<usize>) {\n        let len = (self.end as usize - self.start as usize)\n                  / mem::size_of::<T>();\n        (len, Some(len))\n    }\n}",
        "nomicon_intoiter_p19": "And here's iterating backwards.",
        "nomicon_intoiter_p20": "<!-- ignore: simplified code -->\n,ignore\nimpl<T> DoubleEndedIterator for IntoIter<T> {\n    fn next_back(&mut self) -> Option<T> {\n        if self.start == self.end {\n            None\n        } else {\n            unsafe {\n                self.end = self.end.offset(-1);\n                Some(ptr::read(self.end))\n            }\n        }\n    }\n}",
        "nomicon_intoiter_p21": "Because IntoIter takes ownership of its allocation, it needs to implement Drop\nto free it. However it also wants to implement Drop to drop any elements it\ncontains that weren't yielded.",
        "nomicon_intoiter_p22": "<!-- ignore: simplified code -->\n,ignore\nimpl<T> Drop for IntoIter<T> {\n    fn drop(&mut self) {\n        if self.cap != 0 {\n            // drop any remaining elements\n            for _ in &mut *self {}\n            let layout = Layout::array::<T>(self.cap).unwrap();\n            unsafe {\n                alloc::dealloc(self.buf.as_ptr() as *mut u8, layout);\n            }\n        }\n    }\n}"
      }
    },
    {
      "id": "nomicon_rawvec",
      "title": "RawVec",
      "level": 1,
      "content": "We've actually reached an interesting situation here: we've duplicated the logic\nfor specifying a buffer and freeing its memory in Vec and IntoIter. Now that\nwe've implemented it and identified *actual* logic duplication, this is a good\ntime to perform some logic compression.\n\nWe're going to abstract out the `(ptr, cap)` pair and give them the logic for\nallocating, growing, and freeing:\n\n<!-- ignore: simplified code -->\n,ignore\nstruct RawVec<T> {\n    ptr: NonNull<T>,\n    cap: usize,\n}\n\nunsafe impl<T: Send> Send for RawVec<T> {}\nunsafe impl<T: Sync> Sync for RawVec<T> {}\n\nimpl<T> RawVec<T> {\n    fn new() -> Self {\n        assert!(mem::size_of::<T>() != 0, \"TODO: implement ZST support\");\n        RawVec {\n            ptr: NonNull::dangling(),\n            cap: 0,\n        }\n    }\n\n    fn grow(&mut self) {\n        // This can't overflow because we ensure self.cap <= isize::MAX.\n        let new_cap = if self.cap == 0 { 1 } else { 2 * self.cap };\n\n        // Layout::array checks that the number of bytes is <= usize::MAX,\n        // but this is redundant since old_layout.size() <= isize::MAX,\n        // so the `unwrap` should never fail.\n        let new_layout = Layout::array::<T>(new_cap).unwrap();\n\n        // Ensure that the new allocation doesn't exceed `isize::MAX` bytes.\n        assert!(new_layout.size() <= isize::MAX as usize, \"Allocation too large\");\n\n        let new_ptr = if self.cap == 0 {\n            unsafe { alloc::alloc(new_layout) }\n        } else {\n            let old_layout = Layout::array::<T>(self.cap).unwrap();\n            let old_ptr = self.ptr.as_ptr() as *mut u8;\n            unsafe { alloc::realloc(old_ptr, old_layout, new_layout.size()) }\n        };\n\n        // If allocation fails, `new_ptr` will be null, in which case we abort.\n        self.ptr = match NonNull::new(new_ptr as *mut T) {\n            Some(p) => p,\n            None => alloc::handle_alloc_error(new_layout),\n        };\n        self.cap = new_cap;\n    }\n}\n\nimpl<T> Drop for RawVec<T> {\n    fn drop(&mut self) {\n        if self.cap != 0 {\n            let layout = Layout::array::<T>(self.cap).unwrap();\n            unsafe {\n                alloc::dealloc(self.ptr.as_ptr() as *mut u8, layout);\n            }\n        }\n    }\n}\n\nAnd change Vec as follows:\n\n<!-- ignore: simplified code -->\n,ignore\npub struct Vec<T> {\n    buf: RawVec<T>,\n    len: usize,\n}\n\nimpl<T> Vec<T> {\n    fn ptr(&self) -> *mut T {\n        self.buf.ptr.as_ptr()\n    }\n\n    fn cap(&self) -> usize {\n        self.buf.cap\n    }\n\n    pub fn new() -> Self {\n        Vec {\n            buf: RawVec::new(),\n            len: 0,\n        }\n    }\n\n    // push/pop/insert/remove largely unchanged:\n    // * `self.ptr.as_ptr() -> self.ptr()`\n    // * `self.cap -> self.cap()`\n    // * `self.grow() -> self.buf.grow()`\n}\n\nimpl<T> Drop for Vec<T> {\n    fn drop(&mut self) {\n        while let Some(_) = self.pop() {}\n        // deallocation is handled by RawVec\n    }\n}\n\nAnd finally we can really simplify IntoIter:\n\n<!-- ignore: simplified code -->\n,ignore\npub struct IntoIter<T> {\n    _buf: RawVec<T>, // we don't actually care about this. Just need it to live.\n    start: *const T,\n    end: *const T,\n}\n\n// next and next_back literally unchanged since they never referred to the buf\n\nimpl<T> Drop for IntoIter<T> {\n    fn drop(&mut self) {\n        // only need to ensure all our elements are read;\n        // buffer will clean itself up afterwards.\n        for _ in &mut *self {}\n    }\n}\n\nimpl<T> IntoIterator for Vec<T> {\n    type Item = T;\n    type IntoIter = IntoIter<T>;\n    fn into_iter(self) -> IntoIter<T> {\n        // need to use ptr::read to unsafely move the buf out since it's\n        // not Copy, and Vec implements Drop (so we can't destructure it).\n        let buf = unsafe { ptr::read(&self.buf) };\n        let len = self.len;\n        mem::forget(self);\n\n        IntoIter {\n            start: buf.ptr.as_ptr(),\n            end: if buf.cap == 0 {\n                // can't offset off of a pointer unless it's part of an allocation\n                buf.ptr.as_ptr()\n            } else {\n                unsafe { buf.ptr.as_ptr().add(len) }\n            },\n            _buf: buf,\n        }\n    }\n}\n\nMuch better.",
      "parent_id": null,
      "paragraphs": {
        "nomicon_rawvec_p1": "We've actually reached an interesting situation here: we've duplicated the logic\nfor specifying a buffer and freeing its memory in Vec and IntoIter. Now that\nwe've implemented it and identified *actual* logic duplication, this is a good\ntime to perform some logic compression.",
        "nomicon_rawvec_p2": "We're going to abstract out the `(ptr, cap)` pair and give them the logic for\nallocating, growing, and freeing:",
        "nomicon_rawvec_p3": "<!-- ignore: simplified code -->\n,ignore\nstruct RawVec<T> {\n    ptr: NonNull<T>,\n    cap: usize,\n}",
        "nomicon_rawvec_p4": "unsafe impl<T: Send> Send for RawVec<T> {}\nunsafe impl<T: Sync> Sync for RawVec<T> {}",
        "nomicon_rawvec_p5": "impl<T> RawVec<T> {\n    fn new() -> Self {\n        assert!(mem::size_of::<T>() != 0, \"TODO: implement ZST support\");\n        RawVec {\n            ptr: NonNull::dangling(),\n            cap: 0,\n        }\n    }",
        "nomicon_rawvec_p6": "fn grow(&mut self) {\n        // This can't overflow because we ensure self.cap <= isize::MAX.\n        let new_cap = if self.cap == 0 { 1 } else { 2 * self.cap };",
        "nomicon_rawvec_p7": "// Layout::array checks that the number of bytes is <= usize::MAX,\n        // but this is redundant since old_layout.size() <= isize::MAX,\n        // so the `unwrap` should never fail.\n        let new_layout = Layout::array::<T>(new_cap).unwrap();",
        "nomicon_rawvec_p8": "// Ensure that the new allocation doesn't exceed `isize::MAX` bytes.\n        assert!(new_layout.size() <= isize::MAX as usize, \"Allocation too large\");",
        "nomicon_rawvec_p9": "let new_ptr = if self.cap == 0 {\n            unsafe { alloc::alloc(new_layout) }\n        } else {\n            let old_layout = Layout::array::<T>(self.cap).unwrap();\n            let old_ptr = self.ptr.as_ptr() as *mut u8;\n            unsafe { alloc::realloc(old_ptr, old_layout, new_layout.size()) }\n        };",
        "nomicon_rawvec_p10": "// If allocation fails, `new_ptr` will be null, in which case we abort.\n        self.ptr = match NonNull::new(new_ptr as *mut T) {\n            Some(p) => p,\n            None => alloc::handle_alloc_error(new_layout),\n        };\n        self.cap = new_cap;\n    }\n}",
        "nomicon_rawvec_p11": "impl<T> Drop for RawVec<T> {\n    fn drop(&mut self) {\n        if self.cap != 0 {\n            let layout = Layout::array::<T>(self.cap).unwrap();\n            unsafe {\n                alloc::dealloc(self.ptr.as_ptr() as *mut u8, layout);\n            }\n        }\n    }\n}",
        "nomicon_rawvec_p12": "And change Vec as follows:",
        "nomicon_rawvec_p13": "<!-- ignore: simplified code -->\n,ignore\npub struct Vec<T> {\n    buf: RawVec<T>,\n    len: usize,\n}",
        "nomicon_rawvec_p14": "impl<T> Vec<T> {\n    fn ptr(&self) -> *mut T {\n        self.buf.ptr.as_ptr()\n    }",
        "nomicon_rawvec_p15": "fn cap(&self) -> usize {\n        self.buf.cap\n    }",
        "nomicon_rawvec_p16": "pub fn new() -> Self {\n        Vec {\n            buf: RawVec::new(),\n            len: 0,\n        }\n    }",
        "nomicon_rawvec_p17": "// push/pop/insert/remove largely unchanged:\n    // * `self.ptr.as_ptr() -> self.ptr()`\n    // * `self.cap -> self.cap()`\n    // * `self.grow() -> self.buf.grow()`\n}",
        "nomicon_rawvec_p18": "impl<T> Drop for Vec<T> {\n    fn drop(&mut self) {\n        while let Some(_) = self.pop() {}\n        // deallocation is handled by RawVec\n    }\n}",
        "nomicon_rawvec_p19": "And finally we can really simplify IntoIter:",
        "nomicon_rawvec_p20": "<!-- ignore: simplified code -->\n,ignore\npub struct IntoIter<T> {\n    _buf: RawVec<T>, // we don't actually care about this. Just need it to live.\n    start: *const T,\n    end: *const T,\n}",
        "nomicon_rawvec_p21": "// next and next_back literally unchanged since they never referred to the buf",
        "nomicon_rawvec_p22": "impl<T> Drop for IntoIter<T> {\n    fn drop(&mut self) {\n        // only need to ensure all our elements are read;\n        // buffer will clean itself up afterwards.\n        for _ in &mut *self {}\n    }\n}",
        "nomicon_rawvec_p23": "impl<T> IntoIterator for Vec<T> {\n    type Item = T;\n    type IntoIter = IntoIter<T>;\n    fn into_iter(self) -> IntoIter<T> {\n        // need to use ptr::read to unsafely move the buf out since it's\n        // not Copy, and Vec implements Drop (so we can't destructure it).\n        let buf = unsafe { ptr::read(&self.buf) };\n        let len = self.len;\n        mem::forget(self);",
        "nomicon_rawvec_p24": "IntoIter {\n            start: buf.ptr.as_ptr(),\n            end: if buf.cap == 0 {\n                // can't offset off of a pointer unless it's part of an allocation\n                buf.ptr.as_ptr()\n            } else {\n                unsafe { buf.ptr.as_ptr().add(len) }\n            },\n            _buf: buf,\n        }\n    }\n}",
        "nomicon_rawvec_p25": "Much better."
      }
    },
    {
      "id": "nomicon_drain",
      "title": "Drain",
      "level": 1,
      "content": "Let's move on to Drain. Drain is largely the same as IntoIter, except that\ninstead of consuming the Vec, it borrows the Vec and leaves its allocation\nuntouched. For now we'll only implement the \"basic\" full-range version.\n\n<!-- ignore: simplified code -->\n,ignore\nuse std::marker::PhantomData;\n\nstruct Drain<'a, T: 'a> {\n    // Need to bound the lifetime here, so we do it with `&'a mut Vec<T>`\n    // because that's semantically what we contain. We're \"just\" calling\n    // `pop()` and `remove(0)`.\n    vec: PhantomData<&'a mut Vec<T>>,\n    start: *const T,\n    end: *const T,\n}\n\nimpl<'a, T> Iterator for Drain<'a, T> {\n    type Item = T;\n    fn next(&mut self) -> Option<T> {\n        if self.start == self.end {\n            None\n\n-- wait, this is seeming familiar. Let's do some more compression. Both\nIntoIter and Drain have the exact same structure, let's just factor it out.\n\n<!-- ignore: simplified code -->\n,ignore\nstruct RawValIter<T> {\n    start: *const T,\n    end: *const T,\n}\n\nimpl<T> RawValIter<T> {\n    // unsafe to construct because it has no associated lifetimes.\n    // This is necessary to store a RawValIter in the same struct as\n    // its actual allocation. OK since it's a private implementation\n    // detail.\n    unsafe fn new(slice: &[T]) -> Self {\n        RawValIter {\n            start: slice.as_ptr(),\n            end: if slice.len() == 0 {\n                // if `len = 0`, then this is not actually allocated memory.\n                // Need to avoid offsetting because that will give wrong\n                // information to LLVM via GEP.\n                slice.as_ptr()\n            } else {\n                slice.as_ptr().add(slice.len())\n            }\n        }\n    }\n}\n\n// Iterator and DoubleEndedIterator impls identical to IntoIter.\n\nAnd IntoIter becomes the following:\n\n<!-- ignore: simplified code -->\n,ignore\npub struct IntoIter<T> {\n    _buf: RawVec<T>, // we don't actually care about this. Just need it to live.\n    iter: RawValIter<T>,\n}\n\nimpl<T> Iterator for IntoIter<T> {\n    type Item = T;\n    fn next(&mut self) -> Option<T> { self.iter.next() }\n    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n}\n\nimpl<T> DoubleEndedIterator for IntoIter<T> {\n    fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n}\n\nimpl<T> Drop for IntoIter<T> {\n    fn drop(&mut self) {\n        for _ in &mut *self {}\n    }\n}\n\nimpl<T> IntoIterator for Vec<T> {\n    type Item = T;\n    type IntoIter = IntoIter<T>;\n    fn into_iter(self) -> IntoIter<T> {\n        unsafe {\n            let iter = RawValIter::new(&self);\n\n            let buf = ptr::read(&self.buf);\n            mem::forget(self);\n\n            IntoIter {\n                iter,\n                _buf: buf,\n            }\n        }\n    }\n}\n\nNote that I've left a few quirks in this design to make upgrading Drain to work\nwith arbitrary subranges a bit easier. In particular we *could* have RawValIter\ndrain itself on drop, but that won't work right for a more complex Drain.\nWe also take a slice to simplify Drain initialization.\n\nAlright, now Drain is really easy:\n\n<!-- ignore: simplified code -->\n,ignore\nuse std::marker::PhantomData;\n\npub struct Drain<'a, T: 'a> {\n    vec: PhantomData<&'a mut Vec<T>>,\n    iter: RawValIter<T>,\n}\n\nimpl<'a, T> Iterator for Drain<'a, T> {\n    type Item = T;\n    fn next(&mut self) -> Option<T> { self.iter.next() }\n    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n}\n\nimpl<'a, T> DoubleEndedIterator for Drain<'a, T> {\n    fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n}\n\nimpl<'a, T> Drop for Drain<'a, T> {\n    fn drop(&mut self) {\n        for _ in &mut *self {}\n    }\n}\n\nimpl<T> Vec<T> {\n    pub fn drain(&mut self) -> Drain<T> {\n        let iter = unsafe { RawValIter::new(&self) };\n\n        // this is a mem::forget safety thing. If Drain is forgotten, we just\n        // leak the whole Vec's contents. Also we need to do this *eventually*\n        // anyway, so why not do it now?\n        self.len = 0;\n\n        Drain {\n            iter,\n            vec: PhantomData,\n        }\n    }\n}\n\nFor more details on the `mem::forget` problem, see the\nsection on leaks.\n\n[leaks]: ../leaking.html",
      "parent_id": null,
      "paragraphs": {
        "nomicon_drain_p1": "Let's move on to Drain. Drain is largely the same as IntoIter, except that\ninstead of consuming the Vec, it borrows the Vec and leaves its allocation\nuntouched. For now we'll only implement the \"basic\" full-range version.",
        "nomicon_drain_p2": "<!-- ignore: simplified code -->\n,ignore\nuse std::marker::PhantomData;",
        "nomicon_drain_p3": "struct Drain<'a, T: 'a> {\n    // Need to bound the lifetime here, so we do it with `&'a mut Vec<T>`\n    // because that's semantically what we contain. We're \"just\" calling\n    // `pop()` and `remove(0)`.\n    vec: PhantomData<&'a mut Vec<T>>,\n    start: *const T,\n    end: *const T,\n}",
        "nomicon_drain_p4": "impl<'a, T> Iterator for Drain<'a, T> {\n    type Item = T;\n    fn next(&mut self) -> Option<T> {\n        if self.start == self.end {\n            None",
        "nomicon_drain_p5": "-- wait, this is seeming familiar. Let's do some more compression. Both\nIntoIter and Drain have the exact same structure, let's just factor it out.",
        "nomicon_drain_p6": "<!-- ignore: simplified code -->\n,ignore\nstruct RawValIter<T> {\n    start: *const T,\n    end: *const T,\n}",
        "nomicon_drain_p7": "impl<T> RawValIter<T> {\n    // unsafe to construct because it has no associated lifetimes.\n    // This is necessary to store a RawValIter in the same struct as\n    // its actual allocation. OK since it's a private implementation\n    // detail.\n    unsafe fn new(slice: &[T]) -> Self {\n        RawValIter {\n            start: slice.as_ptr(),\n            end: if slice.len() == 0 {\n                // if `len = 0`, then this is not actually allocated memory.\n                // Need to avoid offsetting because that will give wrong\n                // information to LLVM via GEP.\n                slice.as_ptr()\n            } else {\n                slice.as_ptr().add(slice.len())\n            }\n        }\n    }\n}",
        "nomicon_drain_p8": "// Iterator and DoubleEndedIterator impls identical to IntoIter.",
        "nomicon_drain_p9": "And IntoIter becomes the following:",
        "nomicon_drain_p10": "<!-- ignore: simplified code -->\n,ignore\npub struct IntoIter<T> {\n    _buf: RawVec<T>, // we don't actually care about this. Just need it to live.\n    iter: RawValIter<T>,\n}",
        "nomicon_drain_p11": "impl<T> Iterator for IntoIter<T> {\n    type Item = T;\n    fn next(&mut self) -> Option<T> { self.iter.next() }\n    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n}",
        "nomicon_drain_p12": "impl<T> DoubleEndedIterator for IntoIter<T> {\n    fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n}",
        "nomicon_drain_p13": "impl<T> Drop for IntoIter<T> {\n    fn drop(&mut self) {\n        for _ in &mut *self {}\n    }\n}",
        "nomicon_drain_p14": "impl<T> IntoIterator for Vec<T> {\n    type Item = T;\n    type IntoIter = IntoIter<T>;\n    fn into_iter(self) -> IntoIter<T> {\n        unsafe {\n            let iter = RawValIter::new(&self);",
        "nomicon_drain_p15": "let buf = ptr::read(&self.buf);\n            mem::forget(self);",
        "nomicon_drain_p16": "IntoIter {\n                iter,\n                _buf: buf,\n            }\n        }\n    }\n}",
        "nomicon_drain_p17": "Note that I've left a few quirks in this design to make upgrading Drain to work\nwith arbitrary subranges a bit easier. In particular we *could* have RawValIter\ndrain itself on drop, but that won't work right for a more complex Drain.\nWe also take a slice to simplify Drain initialization.",
        "nomicon_drain_p18": "Alright, now Drain is really easy:",
        "nomicon_drain_p19": "<!-- ignore: simplified code -->\n,ignore\nuse std::marker::PhantomData;",
        "nomicon_drain_p20": "pub struct Drain<'a, T: 'a> {\n    vec: PhantomData<&'a mut Vec<T>>,\n    iter: RawValIter<T>,\n}",
        "nomicon_drain_p21": "impl<'a, T> Iterator for Drain<'a, T> {\n    type Item = T;\n    fn next(&mut self) -> Option<T> { self.iter.next() }\n    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n}",
        "nomicon_drain_p22": "impl<'a, T> DoubleEndedIterator for Drain<'a, T> {\n    fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n}",
        "nomicon_drain_p23": "impl<'a, T> Drop for Drain<'a, T> {\n    fn drop(&mut self) {\n        for _ in &mut *self {}\n    }\n}",
        "nomicon_drain_p24": "impl<T> Vec<T> {\n    pub fn drain(&mut self) -> Drain<T> {\n        let iter = unsafe { RawValIter::new(&self) };",
        "nomicon_drain_p25": "// this is a mem::forget safety thing. If Drain is forgotten, we just\n        // leak the whole Vec's contents. Also we need to do this *eventually*\n        // anyway, so why not do it now?\n        self.len = 0;",
        "nomicon_drain_p26": "Drain {\n            iter,\n            vec: PhantomData,\n        }\n    }\n}",
        "nomicon_drain_p27": "For more details on the `mem::forget` problem, see the\nsection on leaks.",
        "nomicon_drain_p28": "[leaks]: ../leaking.html"
      }
    },
    {
      "id": "nomicon_handling_zero_sized_types",
      "title": "Handling Zero-Sized Types",
      "level": 1,
      "content": "It's time. We're going to fight the specter that is zero-sized types. Safe Rust\n*never* needs to care about this, but Vec is very intensive on raw pointers and\nraw allocations, which are exactly the two things that care about\nzero-sized types. We need to be careful of two things:\n\n* The raw allocator API has undefined behavior if you pass in 0 for an\n  allocation size.\n* raw pointer offsets are no-ops for zero-sized types, which will break our\n  C-style pointer iterator.\n\nThankfully we abstracted out pointer-iterators and allocating handling into\n`RawValIter` and `RawVec` respectively. How mysteriously convenient.",
      "parent_id": null,
      "paragraphs": {
        "nomicon_handling_zero_sized_types_p1": "It's time. We're going to fight the specter that is zero-sized types. Safe Rust\n*never* needs to care about this, but Vec is very intensive on raw pointers and\nraw allocations, which are exactly the two things that care about\nzero-sized types. We need to be careful of two things:",
        "nomicon_handling_zero_sized_types_p2": "* The raw allocator API has undefined behavior if you pass in 0 for an\n  allocation size.\n* raw pointer offsets are no-ops for zero-sized types, which will break our\n  C-style pointer iterator.",
        "nomicon_handling_zero_sized_types_p3": "Thankfully we abstracted out pointer-iterators and allocating handling into\n`RawValIter` and `RawVec` respectively. How mysteriously convenient."
      }
    },
    {
      "id": "nomicon_allocating_zero_sized_types",
      "title": "Allocating Zero-Sized Types",
      "level": 2,
      "content": "So if the allocator API doesn't support zero-sized allocations, what on earth\ndo we store as our allocation? `NonNull::dangling()` of course! Almost every operation\nwith a ZST is a no-op since ZSTs have exactly one value, and therefore no state needs\nto be considered to store or load them. This actually extends to `ptr::read` and\n`ptr::write`: they won't actually look at the pointer at all. As such we never need\nto change the pointer.\n\nNote however that our previous reliance on running out of memory before overflow is\nno longer valid with zero-sized types. We must explicitly guard against capacity\noverflow for zero-sized types.\n\nDue to our current architecture, all this means is writing 3 guards, one in each\nmethod of `RawVec`.\n\n<!-- ignore: simplified code -->\n,ignore\nimpl<T> RawVec<T> {\n    fn new() -> Self {\n        // This branch should be stripped at compile time.\n        let cap = if mem::size_of::<T>() == 0 { usize::MAX } else { 0 };\n\n        // `NonNull::dangling()` doubles as \"unallocated\" and \"zero-sized allocation\"\n        RawVec {\n            ptr: NonNull::dangling(),\n            cap,\n        }\n    }\n\n    fn grow(&mut self) {\n        // since we set the capacity to usize::MAX when T has size 0,\n        // getting to here necessarily means the Vec is overfull.\n        assert!(mem::size_of::<T>() != 0, \"capacity overflow\");\n\n        let (new_cap, new_layout) = if self.cap == 0 {\n            (1, Layout::array::<T>(1).unwrap())\n        } else {\n            // This can't overflow because we ensure self.cap <= isize::MAX.\n            let new_cap = 2 * self.cap;\n\n            // `Layout::array` checks that the number of bytes is <= usize::MAX,\n            // but this is redundant since old_layout.size() <= isize::MAX,\n            // so the `unwrap` should never fail.\n            let new_layout = Layout::array::<T>(new_cap).unwrap();\n            (new_cap, new_layout)\n        };\n\n        // Ensure that the new allocation doesn't exceed `isize::MAX` bytes.\n        assert!(new_layout.size() <= isize::MAX as usize, \"Allocation too large\");\n\n        let new_ptr = if self.cap == 0 {\n            unsafe { alloc::alloc(new_layout) }\n        } else {\n            let old_layout = Layout::array::<T>(self.cap).unwrap();\n            let old_ptr = self.ptr.as_ptr() as *mut u8;\n            unsafe { alloc::realloc(old_ptr, old_layout, new_layout.size()) }\n        };\n\n        // If allocation fails, `new_ptr` will be null, in which case we abort.\n        self.ptr = match NonNull::new(new_ptr as *mut T) {\n            Some(p) => p,\n            None => alloc::handle_alloc_error(new_layout),\n        };\n        self.cap = new_cap;\n    }\n}\n\nimpl<T> Drop for RawVec<T> {\n    fn drop(&mut self) {\n        let elem_size = mem::size_of::<T>();\n\n        if self.cap != 0 && elem_size != 0 {\n            unsafe {\n                alloc::dealloc(\n                    self.ptr.as_ptr() as *mut u8,\n                    Layout::array::<T>(self.cap).unwrap(),\n                );\n            }\n        }\n    }\n}\n\nThat's it. We support pushing and popping zero-sized types now. Our iterators\n(that aren't provided by slice Deref) are still busted, though.",
      "parent_id": null,
      "paragraphs": {
        "nomicon_allocating_zero_sized_types_p1": "So if the allocator API doesn't support zero-sized allocations, what on earth\ndo we store as our allocation? `NonNull::dangling()` of course! Almost every operation\nwith a ZST is a no-op since ZSTs have exactly one value, and therefore no state needs\nto be considered to store or load them. This actually extends to `ptr::read` and\n`ptr::write`: they won't actually look at the pointer at all. As such we never need\nto change the pointer.",
        "nomicon_allocating_zero_sized_types_p2": "Note however that our previous reliance on running out of memory before overflow is\nno longer valid with zero-sized types. We must explicitly guard against capacity\noverflow for zero-sized types.",
        "nomicon_allocating_zero_sized_types_p3": "Due to our current architecture, all this means is writing 3 guards, one in each\nmethod of `RawVec`.",
        "nomicon_allocating_zero_sized_types_p4": "<!-- ignore: simplified code -->\n,ignore\nimpl<T> RawVec<T> {\n    fn new() -> Self {\n        // This branch should be stripped at compile time.\n        let cap = if mem::size_of::<T>() == 0 { usize::MAX } else { 0 };",
        "nomicon_allocating_zero_sized_types_p5": "// `NonNull::dangling()` doubles as \"unallocated\" and \"zero-sized allocation\"\n        RawVec {\n            ptr: NonNull::dangling(),\n            cap,\n        }\n    }",
        "nomicon_allocating_zero_sized_types_p6": "fn grow(&mut self) {\n        // since we set the capacity to usize::MAX when T has size 0,\n        // getting to here necessarily means the Vec is overfull.\n        assert!(mem::size_of::<T>() != 0, \"capacity overflow\");",
        "nomicon_allocating_zero_sized_types_p7": "let (new_cap, new_layout) = if self.cap == 0 {\n            (1, Layout::array::<T>(1).unwrap())\n        } else {\n            // This can't overflow because we ensure self.cap <= isize::MAX.\n            let new_cap = 2 * self.cap;",
        "nomicon_allocating_zero_sized_types_p8": "// `Layout::array` checks that the number of bytes is <= usize::MAX,\n            // but this is redundant since old_layout.size() <= isize::MAX,\n            // so the `unwrap` should never fail.\n            let new_layout = Layout::array::<T>(new_cap).unwrap();\n            (new_cap, new_layout)\n        };",
        "nomicon_allocating_zero_sized_types_p9": "// Ensure that the new allocation doesn't exceed `isize::MAX` bytes.\n        assert!(new_layout.size() <= isize::MAX as usize, \"Allocation too large\");",
        "nomicon_allocating_zero_sized_types_p10": "let new_ptr = if self.cap == 0 {\n            unsafe { alloc::alloc(new_layout) }\n        } else {\n            let old_layout = Layout::array::<T>(self.cap).unwrap();\n            let old_ptr = self.ptr.as_ptr() as *mut u8;\n            unsafe { alloc::realloc(old_ptr, old_layout, new_layout.size()) }\n        };",
        "nomicon_allocating_zero_sized_types_p11": "// If allocation fails, `new_ptr` will be null, in which case we abort.\n        self.ptr = match NonNull::new(new_ptr as *mut T) {\n            Some(p) => p,\n            None => alloc::handle_alloc_error(new_layout),\n        };\n        self.cap = new_cap;\n    }\n}",
        "nomicon_allocating_zero_sized_types_p12": "impl<T> Drop for RawVec<T> {\n    fn drop(&mut self) {\n        let elem_size = mem::size_of::<T>();",
        "nomicon_allocating_zero_sized_types_p13": "if self.cap != 0 && elem_size != 0 {\n            unsafe {\n                alloc::dealloc(\n                    self.ptr.as_ptr() as *mut u8,\n                    Layout::array::<T>(self.cap).unwrap(),\n                );\n            }\n        }\n    }\n}",
        "nomicon_allocating_zero_sized_types_p14": "That's it. We support pushing and popping zero-sized types now. Our iterators\n(that aren't provided by slice Deref) are still busted, though."
      }
    },
    {
      "id": "nomicon_iterating_zero_sized_types",
      "title": "Iterating Zero-Sized Types",
      "level": 2,
      "content": "Zero-sized offsets are no-ops. This means that our current design will always\ninitialize `start` and `end` as the same value, and our iterators will yield\nnothing. The current solution to this is to cast the pointers to integers,\nincrement, and then cast them back:\n\n<!-- ignore: simplified code -->\n,ignore\nimpl<T> RawValIter<T> {\n    unsafe fn new(slice: &[T]) -> Self {\n        RawValIter {\n            start: slice.as_ptr(),\n            end: if mem::size_of::<T>() == 0 {\n                ((slice.as_ptr() as usize) + slice.len()) as *const _\n            } else if slice.len() == 0 {\n                slice.as_ptr()\n            } else {\n                slice.as_ptr().add(slice.len())\n            },\n        }\n    }\n}\n\nNow we have a different bug. Instead of our iterators not running at all, our\niterators now run *forever*. We need to do the same trick in our iterator impls.\nAlso, our size_hint computation code will divide by 0 for ZSTs. Since we'll\nbasically be treating the two pointers as if they point to bytes, we'll just\nmap size 0 to divide by 1. Here's what `next` will be:\n\n<!-- ignore: simplified code -->\n,ignore\nfn next(&mut self) -> Option<T> {\n    if self.start == self.end {\n        None\n    } else {\n        unsafe {\n            let result = ptr::read(self.start);\n            self.start = if mem::size_of::<T>() == 0 {\n                (self.start as usize + 1) as *const _\n            } else {\n                self.start.offset(1)\n            };\n            Some(result)\n        }\n    }\n}\n\nDo you see the \"bug\"? No one else did! The original author only noticed the\nproblem when linking to this page years later. This code is kind of dubious\nbecause abusing the iterator pointers to be *counters* makes them unaligned!\nOur *one job* when using ZSTs is to keep pointers aligned! *forehead slap*\n\nRaw pointers don't need to be aligned at all times, so the basic trick of\nusing pointers as counters is *fine*, but they *should* definitely be aligned\nwhen passed to `ptr::read`! This is *possibly* needless pedantry\nbecause `ptr::read` is a noop for a ZST, but let's be a *little* more\nresponsible and read from `NonNull::dangling` on the ZST path.\n\n(Alternatively you could call `read_unaligned` on the ZST path. Either is fine,\nbecause either way we're making up a value from nothing and it all compiles\nto doing nothing.)\n\n<!-- ignore: simplified code -->\n,ignore\nimpl<T> Iterator for RawValIter<T> {\n    type Item = T;\n    fn next(&mut self) -> Option<T> {\n        if self.start == self.end {\n            None\n        } else {\n            unsafe {\n                if mem::size_of::<T>() == 0 {\n                    self.start = (self.start as usize + 1) as *const _;\n                    Some(ptr::read(NonNull::<T>::dangling().as_ptr()))\n                } else {\n                    let old_ptr = self.start;\n                    self.start = self.start.offset(1);\n                    Some(ptr::read(old_ptr))\n                }\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let elem_size = mem::size_of::<T>();\n        let len = (self.end as usize - self.start as usize)\n                  / if elem_size == 0 { 1 } else { elem_size };\n        (len, Some(len))\n    }\n}\n\nimpl<T> DoubleEndedIterator for RawValIter<T> {\n    fn next_back(&mut self) -> Option<T> {\n        if self.start == self.end {\n            None\n        } else {\n            unsafe {\n                if mem::size_of::<T>() == 0 {\n                    self.end = (self.end as usize - 1) as *const _;\n                    Some(ptr::read(NonNull::<T>::dangling().as_ptr()))\n                } else {\n                    self.end = self.end.offset(-1);\n                    Some(ptr::read(self.end))\n                }\n            }\n        }\n    }\n}\n\nAnd that's it. Iteration works!\n\nOne last thing we need to consider is that when our vector is dropped, it deallocates the memory that was allocated while it was alive. With ZSTs, we didn't allocate any memory; in fact, we never do. So, right now, our code has unsoundness: we're still trying to deallocate a `NonNull::dangling()` pointer that we use to simulate the ZST in our vector. This means we'd cause undefined behavior if we tried to deallocate something we never allocated (obviously, and for good reasons). To fix this, in our `RawVec`'s `Drop` trait, we're going to tweak it to ensure we only deallocate types that are sized.\n\n,ignore\nimpl<T> Drop for RawVec<T> {\n    fn drop(&mut self) {\n        println!(\"RawVec<T> Drop called, deallocating memory\");\n        if self.cap != 0 && std::mem::size_of::<T>() > 0 {\n            let layout = std::alloc::Layout::array::<T>(self.cap).unwrap();\n            unsafe {\n                std::alloc::dealloc(self.ptr.as_ptr() as *mut _, layout);\n            }\n        }\n    }\n}",
      "parent_id": null,
      "paragraphs": {
        "nomicon_iterating_zero_sized_types_p1": "Zero-sized offsets are no-ops. This means that our current design will always\ninitialize `start` and `end` as the same value, and our iterators will yield\nnothing. The current solution to this is to cast the pointers to integers,\nincrement, and then cast them back:",
        "nomicon_iterating_zero_sized_types_p2": "<!-- ignore: simplified code -->\n,ignore\nimpl<T> RawValIter<T> {\n    unsafe fn new(slice: &[T]) -> Self {\n        RawValIter {\n            start: slice.as_ptr(),\n            end: if mem::size_of::<T>() == 0 {\n                ((slice.as_ptr() as usize) + slice.len()) as *const _\n            } else if slice.len() == 0 {\n                slice.as_ptr()\n            } else {\n                slice.as_ptr().add(slice.len())\n            },\n        }\n    }\n}",
        "nomicon_iterating_zero_sized_types_p3": "Now we have a different bug. Instead of our iterators not running at all, our\niterators now run *forever*. We need to do the same trick in our iterator impls.\nAlso, our size_hint computation code will divide by 0 for ZSTs. Since we'll\nbasically be treating the two pointers as if they point to bytes, we'll just\nmap size 0 to divide by 1. Here's what `next` will be:",
        "nomicon_iterating_zero_sized_types_p4": "<!-- ignore: simplified code -->\n,ignore\nfn next(&mut self) -> Option<T> {\n    if self.start == self.end {\n        None\n    } else {\n        unsafe {\n            let result = ptr::read(self.start);\n            self.start = if mem::size_of::<T>() == 0 {\n                (self.start as usize + 1) as *const _\n            } else {\n                self.start.offset(1)\n            };\n            Some(result)\n        }\n    }\n}",
        "nomicon_iterating_zero_sized_types_p5": "Do you see the \"bug\"? No one else did! The original author only noticed the\nproblem when linking to this page years later. This code is kind of dubious\nbecause abusing the iterator pointers to be *counters* makes them unaligned!\nOur *one job* when using ZSTs is to keep pointers aligned! *forehead slap*",
        "nomicon_iterating_zero_sized_types_p6": "Raw pointers don't need to be aligned at all times, so the basic trick of\nusing pointers as counters is *fine*, but they *should* definitely be aligned\nwhen passed to `ptr::read`! This is *possibly* needless pedantry\nbecause `ptr::read` is a noop for a ZST, but let's be a *little* more\nresponsible and read from `NonNull::dangling` on the ZST path.",
        "nomicon_iterating_zero_sized_types_p7": "(Alternatively you could call `read_unaligned` on the ZST path. Either is fine,\nbecause either way we're making up a value from nothing and it all compiles\nto doing nothing.)",
        "nomicon_iterating_zero_sized_types_p8": "<!-- ignore: simplified code -->\n,ignore\nimpl<T> Iterator for RawValIter<T> {\n    type Item = T;\n    fn next(&mut self) -> Option<T> {\n        if self.start == self.end {\n            None\n        } else {\n            unsafe {\n                if mem::size_of::<T>() == 0 {\n                    self.start = (self.start as usize + 1) as *const _;\n                    Some(ptr::read(NonNull::<T>::dangling().as_ptr()))\n                } else {\n                    let old_ptr = self.start;\n                    self.start = self.start.offset(1);\n                    Some(ptr::read(old_ptr))\n                }\n            }\n        }\n    }",
        "nomicon_iterating_zero_sized_types_p9": "fn size_hint(&self) -> (usize, Option<usize>) {\n        let elem_size = mem::size_of::<T>();\n        let len = (self.end as usize - self.start as usize)\n                  / if elem_size == 0 { 1 } else { elem_size };\n        (len, Some(len))\n    }\n}",
        "nomicon_iterating_zero_sized_types_p10": "impl<T> DoubleEndedIterator for RawValIter<T> {\n    fn next_back(&mut self) -> Option<T> {\n        if self.start == self.end {\n            None\n        } else {\n            unsafe {\n                if mem::size_of::<T>() == 0 {\n                    self.end = (self.end as usize - 1) as *const _;\n                    Some(ptr::read(NonNull::<T>::dangling().as_ptr()))\n                } else {\n                    self.end = self.end.offset(-1);\n                    Some(ptr::read(self.end))\n                }\n            }\n        }\n    }\n}",
        "nomicon_iterating_zero_sized_types_p11": "And that's it. Iteration works!",
        "nomicon_iterating_zero_sized_types_p12": "One last thing we need to consider is that when our vector is dropped, it deallocates the memory that was allocated while it was alive. With ZSTs, we didn't allocate any memory; in fact, we never do. So, right now, our code has unsoundness: we're still trying to deallocate a `NonNull::dangling()` pointer that we use to simulate the ZST in our vector. This means we'd cause undefined behavior if we tried to deallocate something we never allocated (obviously, and for good reasons). To fix this, in our `RawVec`'s `Drop` trait, we're going to tweak it to ensure we only deallocate types that are sized.",
        "nomicon_iterating_zero_sized_types_p13": ",ignore\nimpl<T> Drop for RawVec<T> {\n    fn drop(&mut self) {\n        println!(\"RawVec<T> Drop called, deallocating memory\");\n        if self.cap != 0 && std::mem::size_of::<T>() > 0 {\n            let layout = std::alloc::Layout::array::<T>(self.cap).unwrap();\n            unsafe {\n                std::alloc::dealloc(self.ptr.as_ptr() as *mut _, layout);\n            }\n        }\n    }\n}"
      }
    },
    {
      "id": "nomicon_the_final_code",
      "title": "The Final Code",
      "level": 1,
      "content": "use std::alloc::{self, Layout};\nuse std::marker::PhantomData;\nuse std::mem;\nuse std::ops::{Deref, DerefMut};\nuse std::ptr::{self, NonNull};\n\nstruct RawVec<T> {\n    ptr: NonNull<T>,\n    cap: usize,\n}\n\nunsafe impl<T: Send> Send for RawVec<T> {}\nunsafe impl<T: Sync> Sync for RawVec<T> {}\n\nimpl<T> RawVec<T> {\n    fn new() -> Self {\n        // !0 is usize::MAX. This branch should be stripped at compile time.\n        let cap = if mem::size_of::<T>() == 0 { !0 } else { 0 };\n\n        // `NonNull::dangling()` doubles as \"unallocated\" and \"zero-sized allocation\"\n        RawVec {\n            ptr: NonNull::dangling(),\n            cap,\n        }\n    }\n\n    fn grow(&mut self) {\n        // since we set the capacity to usize::MAX when T has size 0,\n        // getting to here necessarily means the Vec is overfull.\n        assert!(mem::size_of::<T>() != 0, \"capacity overflow\");\n\n        let (new_cap, new_layout) = if self.cap == 0 {\n            (1, Layout::array::<T>(1))\n        } else {\n            // This can't overflow since self.cap <= isize::MAX.\n            let new_cap = 2 * self.cap;\n            (new_cap, Layout::array::<T>(new_cap))\n        };\n\n        // `Layout::array` checks that the number of bytes allocated is\n        // in 1..=isize::MAX and will error otherwise.  An allocation of\n        // 0 bytes isn't possible thanks to the above condition.\n        let new_layout = new_layout.expect(\"Allocation too large\");\n\n        let new_ptr = if self.cap == 0 {\n            unsafe { alloc::alloc(new_layout) }\n        } else {\n            let old_layout = Layout::array::<T>(self.cap).unwrap();\n            let old_ptr = self.ptr.as_ptr() as *mut u8;\n            unsafe { alloc::realloc(old_ptr, old_layout, new_layout.size()) }\n        };\n\n        // If allocation fails, `new_ptr` will be null, in which case we abort.\n        self.ptr = match NonNull::new(new_ptr as *mut T) {\n            Some(p) => p,\n            None => alloc::handle_alloc_error(new_layout),\n        };\n        self.cap = new_cap;\n    }\n}\n\nimpl<T> Drop for RawVec<T> {\n    fn drop(&mut self) {\n        let elem_size = mem::size_of::<T>();\n\n        if self.cap != 0 && elem_size != 0 {\n            unsafe {\n                alloc::dealloc(\n                    self.ptr.as_ptr() as *mut u8,\n                    Layout::array::<T>(self.cap).unwrap(),\n                );\n            }\n        }\n    }\n}\n\npub struct Vec<T> {\n    buf: RawVec<T>,\n    len: usize,\n}\n\nimpl<T> Vec<T> {\n    fn ptr(&self) -> *mut T {\n        self.buf.ptr.as_ptr()\n    }\n\n    fn cap(&self) -> usize {\n        self.buf.cap\n    }\n\n    pub fn new() -> Self {\n        Vec {\n            buf: RawVec::new(),\n            len: 0,\n        }\n    }\n    pub fn push(&mut self, elem: T) {\n        if self.len == self.cap() {\n            self.buf.grow();\n        }\n\n        unsafe {\n            ptr::write(self.ptr().add(self.len), elem);\n        }\n\n        // Can't overflow, we'll OOM first.\n        self.len += 1;\n    }\n\n    pub fn pop(&mut self) -> Option<T> {\n        if self.len == 0 {\n            None\n        } else {\n            self.len -= 1;\n            unsafe { Some(ptr::read(self.ptr().add(self.len))) }\n        }\n    }\n\n    pub fn insert(&mut self, index: usize, elem: T) {\n        assert!(index <= self.len, \"index out of bounds\");\n        if self.len == self.cap() {\n            self.buf.grow();\n        }\n\n        unsafe {\n            ptr::copy(\n                self.ptr().add(index),\n                self.ptr().add(index + 1),\n                self.len - index,\n            );\n            ptr::write(self.ptr().add(index), elem);\n        }\n\n        self.len += 1;\n    }\n\n    pub fn remove(&mut self, index: usize) -> T {\n        assert!(index < self.len, \"index out of bounds\");\n\n        self.len -= 1;\n\n        unsafe {\n            let result = ptr::read(self.ptr().add(index));\n            ptr::copy(\n                self.ptr().add(index + 1),\n                self.ptr().add(index),\n                self.len - index,\n            );\n            result\n        }\n    }\n\n    pub fn drain(&mut self) -> Drain<T> {\n        let iter = unsafe { RawValIter::new(&self) };\n\n        // this is a mem::forget safety thing. If Drain is forgotten, we just\n        // leak the whole Vec's contents. Also we need to do this *eventually*\n        // anyway, so why not do it now?\n        self.len = 0;\n\n        Drain {\n            iter,\n            vec: PhantomData,\n        }\n    }\n}\n\nimpl<T> Drop for Vec<T> {\n    fn drop(&mut self) {\n        while let Some(_) = self.pop() {}\n        // deallocation is handled by RawVec\n    }\n}\n\nimpl<T> Deref for Vec<T> {\n    type Target = [T];\n    fn deref(&self) -> &[T] {\n        unsafe { std::slice::from_raw_parts(self.ptr(), self.len) }\n    }\n}\n\nimpl<T> DerefMut for Vec<T> {\n    fn deref_mut(&mut self) -> &mut [T] {\n        unsafe { std::slice::from_raw_parts_mut(self.ptr(), self.len) }\n    }\n}\n\nimpl<T> IntoIterator for Vec<T> {\n    type Item = T;\n    type IntoIter = IntoIter<T>;\n    fn into_iter(self) -> IntoIter<T> {\n        let (iter, buf) = unsafe {\n            (RawValIter::new(&self), ptr::read(&self.buf))\n        };\n\n        mem::forget(self);\n\n        IntoIter {\n            iter,\n            _buf: buf,\n        }\n    }\n}\n\nstruct RawValIter<T> {\n    start: *const T,\n    end: *const T,\n}\n\nimpl<T> RawValIter<T> {\n    unsafe fn new(slice: &[T]) -> Self {\n        RawValIter {\n            start: slice.as_ptr(),\n            end: if mem::size_of::<T>() == 0 {\n                ((slice.as_ptr() as usize) + slice.len()) as *const _\n            } else if slice.len() == 0 {\n                slice.as_ptr()\n            } else {\n                slice.as_ptr().add(slice.len())\n            },\n        }\n    }\n}\n\nimpl<T> Iterator for RawValIter<T> {\n    type Item = T;\n    fn next(&mut self) -> Option<T> {\n        if self.start == self.end {\n            None\n        } else {\n            unsafe {\n                if mem::size_of::<T>() == 0 {\n                    self.start = (self.start as usize + 1) as *const _;\n                    Some(ptr::read(NonNull::<T>::dangling().as_ptr()))\n                } else {\n                    let old_ptr = self.start;\n                    self.start = self.start.offset(1);\n                    Some(ptr::read(old_ptr))\n                }\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let elem_size = mem::size_of::<T>();\n        let len = (self.end as usize - self.start as usize)\n                  / if elem_size == 0 { 1 } else { elem_size };\n        (len, Some(len))\n    }\n}\n\nimpl<T> DoubleEndedIterator for RawValIter<T> {\n    fn next_back(&mut self) -> Option<T> {\n        if self.start == self.end {\n            None\n        } else {\n            unsafe {\n                if mem::size_of::<T>() == 0 {\n                    self.end = (self.end as usize - 1) as *const _;\n                    Some(ptr::read(NonNull::<T>::dangling().as_ptr()))\n                } else {\n                    self.end = self.end.offset(-1);\n                    Some(ptr::read(self.end))\n                }\n            }\n        }\n    }\n}\n\npub struct IntoIter<T> {\n    _buf: RawVec<T>, // we don't actually care about this. Just need it to live.\n    iter: RawValIter<T>,\n}\n\nimpl<T> Iterator for IntoIter<T> {\n    type Item = T;\n    fn next(&mut self) -> Option<T> {\n        self.iter.next()\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\nimpl<T> DoubleEndedIterator for IntoIter<T> {\n    fn next_back(&mut self) -> Option<T> {\n        self.iter.next_back()\n    }\n}\n\nimpl<T> Drop for IntoIter<T> {\n    fn drop(&mut self) {\n        for _ in &mut *self {}\n    }\n}\n\npub struct Drain<'a, T: 'a> {\n    vec: PhantomData<&'a mut Vec<T>>,\n    iter: RawValIter<T>,\n}\n\nimpl<'a, T> Iterator for Drain<'a, T> {\n    type Item = T;\n    fn next(&mut self) -> Option<T> {\n        self.iter.next()\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\nimpl<'a, T> DoubleEndedIterator for Drain<'a, T> {\n    fn next_back(&mut self) -> Option<T> {\n        self.iter.next_back()\n    }\n}\n\nimpl<'a, T> Drop for Drain<'a, T> {\n    fn drop(&mut self) {\n        // pre-drain the iter\n        for _ in &mut *self {}\n    }\n}",
      "parent_id": null,
      "paragraphs": {
        "nomicon_the_final_code_p1": "use std::alloc::{self, Layout};\nuse std::marker::PhantomData;\nuse std::mem;\nuse std::ops::{Deref, DerefMut};\nuse std::ptr::{self, NonNull};",
        "nomicon_the_final_code_p2": "struct RawVec<T> {\n    ptr: NonNull<T>,\n    cap: usize,\n}",
        "nomicon_the_final_code_p3": "unsafe impl<T: Send> Send for RawVec<T> {}\nunsafe impl<T: Sync> Sync for RawVec<T> {}",
        "nomicon_the_final_code_p4": "impl<T> RawVec<T> {\n    fn new() -> Self {\n        // !0 is usize::MAX. This branch should be stripped at compile time.\n        let cap = if mem::size_of::<T>() == 0 { !0 } else { 0 };",
        "nomicon_the_final_code_p5": "// `NonNull::dangling()` doubles as \"unallocated\" and \"zero-sized allocation\"\n        RawVec {\n            ptr: NonNull::dangling(),\n            cap,\n        }\n    }",
        "nomicon_the_final_code_p6": "fn grow(&mut self) {\n        // since we set the capacity to usize::MAX when T has size 0,\n        // getting to here necessarily means the Vec is overfull.\n        assert!(mem::size_of::<T>() != 0, \"capacity overflow\");",
        "nomicon_the_final_code_p7": "let (new_cap, new_layout) = if self.cap == 0 {\n            (1, Layout::array::<T>(1))\n        } else {\n            // This can't overflow since self.cap <= isize::MAX.\n            let new_cap = 2 * self.cap;\n            (new_cap, Layout::array::<T>(new_cap))\n        };",
        "nomicon_the_final_code_p8": "// `Layout::array` checks that the number of bytes allocated is\n        // in 1..=isize::MAX and will error otherwise.  An allocation of\n        // 0 bytes isn't possible thanks to the above condition.\n        let new_layout = new_layout.expect(\"Allocation too large\");",
        "nomicon_the_final_code_p9": "let new_ptr = if self.cap == 0 {\n            unsafe { alloc::alloc(new_layout) }\n        } else {\n            let old_layout = Layout::array::<T>(self.cap).unwrap();\n            let old_ptr = self.ptr.as_ptr() as *mut u8;\n            unsafe { alloc::realloc(old_ptr, old_layout, new_layout.size()) }\n        };",
        "nomicon_the_final_code_p10": "// If allocation fails, `new_ptr` will be null, in which case we abort.\n        self.ptr = match NonNull::new(new_ptr as *mut T) {\n            Some(p) => p,\n            None => alloc::handle_alloc_error(new_layout),\n        };\n        self.cap = new_cap;\n    }\n}",
        "nomicon_the_final_code_p11": "impl<T> Drop for RawVec<T> {\n    fn drop(&mut self) {\n        let elem_size = mem::size_of::<T>();",
        "nomicon_the_final_code_p12": "if self.cap != 0 && elem_size != 0 {\n            unsafe {\n                alloc::dealloc(\n                    self.ptr.as_ptr() as *mut u8,\n                    Layout::array::<T>(self.cap).unwrap(),\n                );\n            }\n        }\n    }\n}",
        "nomicon_the_final_code_p13": "pub struct Vec<T> {\n    buf: RawVec<T>,\n    len: usize,\n}",
        "nomicon_the_final_code_p14": "impl<T> Vec<T> {\n    fn ptr(&self) -> *mut T {\n        self.buf.ptr.as_ptr()\n    }",
        "nomicon_the_final_code_p15": "fn cap(&self) -> usize {\n        self.buf.cap\n    }",
        "nomicon_the_final_code_p16": "pub fn new() -> Self {\n        Vec {\n            buf: RawVec::new(),\n            len: 0,\n        }\n    }\n    pub fn push(&mut self, elem: T) {\n        if self.len == self.cap() {\n            self.buf.grow();\n        }",
        "nomicon_the_final_code_p17": "unsafe {\n            ptr::write(self.ptr().add(self.len), elem);\n        }",
        "nomicon_the_final_code_p18": "// Can't overflow, we'll OOM first.\n        self.len += 1;\n    }",
        "nomicon_the_final_code_p19": "pub fn pop(&mut self) -> Option<T> {\n        if self.len == 0 {\n            None\n        } else {\n            self.len -= 1;\n            unsafe { Some(ptr::read(self.ptr().add(self.len))) }\n        }\n    }",
        "nomicon_the_final_code_p20": "pub fn insert(&mut self, index: usize, elem: T) {\n        assert!(index <= self.len, \"index out of bounds\");\n        if self.len == self.cap() {\n            self.buf.grow();\n        }",
        "nomicon_the_final_code_p21": "unsafe {\n            ptr::copy(\n                self.ptr().add(index),\n                self.ptr().add(index + 1),\n                self.len - index,\n            );\n            ptr::write(self.ptr().add(index), elem);\n        }",
        "nomicon_the_final_code_p22": "self.len += 1;\n    }",
        "nomicon_the_final_code_p23": "pub fn remove(&mut self, index: usize) -> T {\n        assert!(index < self.len, \"index out of bounds\");",
        "nomicon_the_final_code_p24": "self.len -= 1;",
        "nomicon_the_final_code_p25": "unsafe {\n            let result = ptr::read(self.ptr().add(index));\n            ptr::copy(\n                self.ptr().add(index + 1),\n                self.ptr().add(index),\n                self.len - index,\n            );\n            result\n        }\n    }",
        "nomicon_the_final_code_p26": "pub fn drain(&mut self) -> Drain<T> {\n        let iter = unsafe { RawValIter::new(&self) };",
        "nomicon_the_final_code_p27": "// this is a mem::forget safety thing. If Drain is forgotten, we just\n        // leak the whole Vec's contents. Also we need to do this *eventually*\n        // anyway, so why not do it now?\n        self.len = 0;",
        "nomicon_the_final_code_p28": "Drain {\n            iter,\n            vec: PhantomData,\n        }\n    }\n}",
        "nomicon_the_final_code_p29": "impl<T> Drop for Vec<T> {\n    fn drop(&mut self) {\n        while let Some(_) = self.pop() {}\n        // deallocation is handled by RawVec\n    }\n}",
        "nomicon_the_final_code_p30": "impl<T> Deref for Vec<T> {\n    type Target = [T];\n    fn deref(&self) -> &[T] {\n        unsafe { std::slice::from_raw_parts(self.ptr(), self.len) }\n    }\n}",
        "nomicon_the_final_code_p31": "impl<T> DerefMut for Vec<T> {\n    fn deref_mut(&mut self) -> &mut [T] {\n        unsafe { std::slice::from_raw_parts_mut(self.ptr(), self.len) }\n    }\n}",
        "nomicon_the_final_code_p32": "impl<T> IntoIterator for Vec<T> {\n    type Item = T;\n    type IntoIter = IntoIter<T>;\n    fn into_iter(self) -> IntoIter<T> {\n        let (iter, buf) = unsafe {\n            (RawValIter::new(&self), ptr::read(&self.buf))\n        };",
        "nomicon_the_final_code_p33": "mem::forget(self);",
        "nomicon_the_final_code_p34": "IntoIter {\n            iter,\n            _buf: buf,\n        }\n    }\n}",
        "nomicon_the_final_code_p35": "struct RawValIter<T> {\n    start: *const T,\n    end: *const T,\n}",
        "nomicon_the_final_code_p36": "impl<T> RawValIter<T> {\n    unsafe fn new(slice: &[T]) -> Self {\n        RawValIter {\n            start: slice.as_ptr(),\n            end: if mem::size_of::<T>() == 0 {\n                ((slice.as_ptr() as usize) + slice.len()) as *const _\n            } else if slice.len() == 0 {\n                slice.as_ptr()\n            } else {\n                slice.as_ptr().add(slice.len())\n            },\n        }\n    }\n}",
        "nomicon_the_final_code_p37": "impl<T> Iterator for RawValIter<T> {\n    type Item = T;\n    fn next(&mut self) -> Option<T> {\n        if self.start == self.end {\n            None\n        } else {\n            unsafe {\n                if mem::size_of::<T>() == 0 {\n                    self.start = (self.start as usize + 1) as *const _;\n                    Some(ptr::read(NonNull::<T>::dangling().as_ptr()))\n                } else {\n                    let old_ptr = self.start;\n                    self.start = self.start.offset(1);\n                    Some(ptr::read(old_ptr))\n                }\n            }\n        }\n    }",
        "nomicon_the_final_code_p38": "fn size_hint(&self) -> (usize, Option<usize>) {\n        let elem_size = mem::size_of::<T>();\n        let len = (self.end as usize - self.start as usize)\n                  / if elem_size == 0 { 1 } else { elem_size };\n        (len, Some(len))\n    }\n}",
        "nomicon_the_final_code_p39": "impl<T> DoubleEndedIterator for RawValIter<T> {\n    fn next_back(&mut self) -> Option<T> {\n        if self.start == self.end {\n            None\n        } else {\n            unsafe {\n                if mem::size_of::<T>() == 0 {\n                    self.end = (self.end as usize - 1) as *const _;\n                    Some(ptr::read(NonNull::<T>::dangling().as_ptr()))\n                } else {\n                    self.end = self.end.offset(-1);\n                    Some(ptr::read(self.end))\n                }\n            }\n        }\n    }\n}",
        "nomicon_the_final_code_p40": "pub struct IntoIter<T> {\n    _buf: RawVec<T>, // we don't actually care about this. Just need it to live.\n    iter: RawValIter<T>,\n}",
        "nomicon_the_final_code_p41": "impl<T> Iterator for IntoIter<T> {\n    type Item = T;\n    fn next(&mut self) -> Option<T> {\n        self.iter.next()\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}",
        "nomicon_the_final_code_p42": "impl<T> DoubleEndedIterator for IntoIter<T> {\n    fn next_back(&mut self) -> Option<T> {\n        self.iter.next_back()\n    }\n}",
        "nomicon_the_final_code_p43": "impl<T> Drop for IntoIter<T> {\n    fn drop(&mut self) {\n        for _ in &mut *self {}\n    }\n}",
        "nomicon_the_final_code_p44": "pub struct Drain<'a, T: 'a> {\n    vec: PhantomData<&'a mut Vec<T>>,\n    iter: RawValIter<T>,\n}",
        "nomicon_the_final_code_p45": "impl<'a, T> Iterator for Drain<'a, T> {\n    type Item = T;\n    fn next(&mut self) -> Option<T> {\n        self.iter.next()\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}",
        "nomicon_the_final_code_p46": "impl<'a, T> DoubleEndedIterator for Drain<'a, T> {\n    fn next_back(&mut self) -> Option<T> {\n        self.iter.next_back()\n    }\n}",
        "nomicon_the_final_code_p47": "impl<'a, T> Drop for Drain<'a, T> {\n    fn drop(&mut self) {\n        // pre-drain the iter\n        for _ in &mut *self {}\n    }\n}"
      }
    },
    {
      "id": "nomicon_fn_main",
      "title": "# fn main() {",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_tests_create_push_pop",
      "title": "tests::create_push_pop();",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_tests_iter_test",
      "title": "tests::iter_test();",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_tests_test_drain",
      "title": "tests::test_drain();",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_tests_test_zst",
      "title": "tests::test_zst();",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_println_all_tests_finished_ok",
      "title": "println!(\"All tests finished OK\");",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon",
      "title": "}",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_mod_tests",
      "title": "# mod tests {",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_use_super",
      "title": "use super::*;",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_pub_fn_create_push_pop",
      "title": "#     pub fn create_push_pop() {",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_let_mut_v_vec_new",
      "title": "let mut v = Vec::new();",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_v_push_1",
      "title": "v.push(1);",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_assert_eq_1_v_len",
      "title": "assert_eq!(1, v.len());",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_assert_eq_1_v_0",
      "title": "assert_eq!(1, v[0]);",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_for_i_in_v_iter_mut",
      "title": "for i in v.iter_mut() {",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_i_1",
      "title": "*i += 1;",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon",
      "title": "}",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_v_insert_0_5",
      "title": "v.insert(0, 5);",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_let_x_v_pop",
      "title": "let x = v.pop();",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_assert_eq_some_2_x",
      "title": "assert_eq!(Some(2), x);",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_assert_eq_1_v_len",
      "title": "assert_eq!(1, v.len());",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_v_push_10",
      "title": "v.push(10);",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_let_x_v_remove_0",
      "title": "let x = v.remove(0);",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_assert_eq_5_x",
      "title": "assert_eq!(5, x);",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_assert_eq_1_v_len",
      "title": "assert_eq!(1, v.len());",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon",
      "title": "}",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_pub_fn_iter_test",
      "title": "#     pub fn iter_test() {",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_let_mut_v_vec_new",
      "title": "let mut v = Vec::new();",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_for_i_in_0_10",
      "title": "for i in 0..10 {",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_v_push_box_new_i",
      "title": "v.push(Box::new(i))",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon",
      "title": "}",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_let_mut_iter_v_into_iter",
      "title": "let mut iter = v.into_iter();",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_let_first_iter_next_unwrap",
      "title": "let first = iter.next().unwrap();",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_let_last_iter_next_back_unwrap",
      "title": "let last = iter.next_back().unwrap();",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_drop_iter",
      "title": "drop(iter);",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_assert_eq_0_first",
      "title": "assert_eq!(0, *first);",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_assert_eq_9_last",
      "title": "assert_eq!(9, *last);",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon",
      "title": "}",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_pub_fn_test_drain",
      "title": "#     pub fn test_drain() {",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_let_mut_v_vec_new",
      "title": "let mut v = Vec::new();",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_for_i_in_0_10",
      "title": "for i in 0..10 {",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_v_push_box_new_i",
      "title": "v.push(Box::new(i))",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon",
      "title": "}",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon",
      "title": "{",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_let_mut_drain_v_drain",
      "title": "let mut drain = v.drain();",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_let_first_drain_next_unwrap",
      "title": "let first = drain.next().unwrap();",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_let_last_drain_next_back_unwrap",
      "title": "let last = drain.next_back().unwrap();",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_assert_eq_0_first",
      "title": "assert_eq!(0, *first);",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_assert_eq_9_last",
      "title": "assert_eq!(9, *last);",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon",
      "title": "}",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_assert_eq_0_v_len",
      "title": "assert_eq!(0, v.len());",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_v_push_box_new_1",
      "title": "v.push(Box::new(1));",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_assert_eq_1_v_pop_unwrap",
      "title": "assert_eq!(1, *v.pop().unwrap());",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon",
      "title": "}",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_pub_fn_test_zst",
      "title": "#     pub fn test_zst() {",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_let_mut_v_vec_new",
      "title": "let mut v = Vec::new();",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_for_i_in_0_10",
      "title": "for _i in 0..10 {",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_v_push",
      "title": "v.push(())",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon",
      "title": "}",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_let_mut_count_0",
      "title": "#         let mut count = 0;",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_for_in_v_into_iter",
      "title": "#         for _ in v.into_iter() {",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_count_1",
      "title": "count += 1",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon",
      "title": "}",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_assert_eq_10_count",
      "title": "#         assert_eq!(10, count);",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon",
      "title": "}",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon",
      "title": "}",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {
        "nomicon_p1": ""
      }
    }
  ],
  "ids": [
    "nomicon_iterating_zero_sized_types_p13",
    "nomicon_deref_p6",
    "nomicon_the_final_code_p13",
    "nomicon_rawvec_p4",
    "nomicon_iterating_zero_sized_types_p6",
    "nomicon_fn_main_p4",
    "nomicon_the_final_code_p1",
    "nomicon_deref_p2",
    "nomicon_allocating_memory_p5",
    "nomicon_v_push",
    "nomicon_iterating_zero_sized_types_p2",
    "nomicon_fn_main_p22",
    "nomicon_v_push_10",
    "nomicon_the_final_code_p25",
    "nomicon_intoiter_p10",
    "nomicon_the_final_code_p27",
    "nomicon_rawvec_p25",
    "nomicon_drain_p10",
    "nomicon_the_final_code_p6",
    "nomicon_iterating_zero_sized_types",
    "nomicon_assert_eq_1_v_len",
    "nomicon_deref_p4",
    "nomicon_rawvec_p13",
    "nomicon_pub_fn_iter_test",
    "nomicon_layout_p2",
    "nomicon_fn_main_p21",
    "nomicon_drain_p26",
    "nomicon_the_final_code_p40",
    "nomicon_v_insert_0_5",
    "nomicon_example_implementing_vec_p2",
    "nomicon_iterating_zero_sized_types_p12",
    "nomicon_fn_main_p23",
    "nomicon_the_final_code_p9",
    "nomicon_push_and_pop_p3",
    "nomicon_fn_main_p12",
    "nomicon_iterating_zero_sized_types_p5",
    "nomicon_the_final_code_p43",
    "nomicon_the_final_code_p12",
    "nomicon_drop_iter",
    "nomicon_fn_main_p24",
    "nomicon_fn_main_p18",
    "nomicon_intoiter_p6",
    "nomicon_the_final_code_p16",
    "nomicon_rawvec_p10",
    "nomicon_intoiter_p22",
    "nomicon_allocating_memory",
    "nomicon_push_and_pop_p4",
    "nomicon_let_mut_count_0",
    "nomicon_drain_p3",
    "nomicon_tests_create_push_pop",
    "nomicon_intoiter_p7",
    "nomicon_handling_zero_sized_types_p2",
    "nomicon_assert_eq_10_count",
    "nomicon_deallocating_p3",
    "nomicon_intoiter_p11",
    "nomicon_drain_p17",
    "nomicon_the_final_code_p41",
    "nomicon_the_final_code_p47",
    "nomicon_deref_p5",
    "nomicon_tests_test_drain",
    "nomicon_iterating_zero_sized_types_p4",
    "nomicon_push_and_pop_p9",
    "nomicon_deallocating",
    "nomicon_for_i_in_v_iter_mut",
    "nomicon_layout_p6",
    "nomicon_the_final_code_p38",
    "nomicon_pub_fn_test_drain",
    "nomicon_fn_main",
    "nomicon_allocating_memory_p3",
    "nomicon_fn_main_p10",
    "nomicon_layout_p4",
    "nomicon_let_first_iter_next_unwrap",
    "nomicon_intoiter_p5",
    "nomicon_fn_main_p26",
    "nomicon_drain_p11",
    "nomicon_iterating_zero_sized_types_p10",
    "nomicon_let_last_iter_next_back_unwrap",
    "nomicon_p1",
    "nomicon_push_and_pop_p5",
    "nomicon_drain_p13",
    "nomicon_allocating_zero_sized_types_p7",
    "nomicon_the_final_code_p3",
    "nomicon_the_final_code_p22",
    "nomicon_iterating_zero_sized_types_p7",
    "nomicon_fn_main_p15",
    "nomicon_v_push_1",
    "nomicon_rawvec_p15",
    "nomicon_use_super",
    "nomicon_intoiter_p13",
    "nomicon_assert_eq_0_first",
    "nomicon_fn_main_p7",
    "nomicon_intoiter_p19",
    "nomicon_example_implementing_vec_p3",
    "nomicon_deref_p7",
    "nomicon_intoiter_p12",
    "nomicon_the_final_code_p5",
    "nomicon_the_final_code_p7",
    "nomicon_the_final_code_p26",
    "nomicon_fn_main_p20",
    "nomicon_handling_zero_sized_types_p3",
    "nomicon_rawvec_p9",
    "nomicon_the_final_code_p37",
    "nomicon_count_1",
    "nomicon_deref",
    "nomicon_fn_main_p6",
    "nomicon_drain_p5",
    "nomicon_fn_main_p5",
    "nomicon_intoiter_p18",
    "nomicon_allocating_zero_sized_types_p6",
    "nomicon_allocating_zero_sized_types_p3",
    "nomicon_rawvec_p2",
    "nomicon_handling_zero_sized_types",
    "nomicon_assert_eq_9_last",
    "nomicon_push_and_pop_p7",
    "nomicon_insert_and_remove_p5",
    "nomicon_the_final_code_p4",
    "nomicon_fn_main_p28",
    "nomicon_push_and_pop_p8",
    "nomicon_allocating_memory_p2",
    "nomicon_fn_main_p25",
    "nomicon_allocating_zero_sized_types_p10",
    "nomicon_fn_main_p13",
    "nomicon_allocating_zero_sized_types_p13",
    "nomicon_the_final_code_p18",
    "nomicon_let_last_drain_next_back_unwrap",
    "nomicon_drain_p15",
    "nomicon_insert_and_remove_p6",
    "nomicon_allocating_memory_p4",
    "nomicon_fn_main_p2",
    "nomicon_iterating_zero_sized_types_p9",
    "nomicon_assert_eq_0_v_len",
    "nomicon_rawvec_p7",
    "nomicon_for_in_v_into_iter",
    "nomicon_push_and_pop_p6",
    "nomicon_assert_eq_some_2_x",
    "nomicon_layout_p8",
    "nomicon_intoiter_p15",
    "nomicon_the_final_code_p10",
    "nomicon_let_mut_iter_v_into_iter",
    "nomicon_assert_eq_1_v_pop_unwrap",
    "nomicon_fn_main_p27",
    "nomicon_intoiter_p1",
    "nomicon_insert_and_remove_p2",
    "nomicon_intoiter_p16",
    "nomicon_the_final_code_p30",
    "nomicon_v_push_box_new_1",
    "nomicon_intoiter",
    "nomicon_rawvec_p17",
    "nomicon_the_final_code_p24",
    "nomicon_drain_p23",
    "nomicon_drain_p24",
    "nomicon_iterating_zero_sized_types_p11",
    "nomicon_the_final_code_p34",
    "nomicon_rawvec_p3",
    "nomicon",
    "nomicon_let_x_v_remove_0",
    "nomicon_drain_p6",
    "nomicon_let_mut_drain_v_drain",
    "nomicon_allocating_zero_sized_types_p4",
    "nomicon_assert_eq_5_x",
    "nomicon_deallocating_p1",
    "nomicon_the_final_code_p21",
    "nomicon_the_final_code_p32",
    "nomicon_intoiter_p21",
    "nomicon_the_final_code_p20",
    "nomicon_drain_p27",
    "nomicon_drain_p22",
    "nomicon_allocating_zero_sized_types_p12",
    "nomicon_i_1",
    "nomicon_intoiter_p17",
    "nomicon_pub_fn_test_zst",
    "nomicon_rawvec_p22",
    "nomicon_the_final_code_p8",
    "nomicon_let_mut_v_vec_new",
    "nomicon_handling_zero_sized_types_p1",
    "nomicon_deallocating_p2",
    "nomicon_example_implementing_vec",
    "nomicon_the_final_code_p39",
    "nomicon_drain_p20",
    "nomicon_push_and_pop_p10",
    "nomicon_intoiter_p14",
    "nomicon_rawvec_p20",
    "nomicon_rawvec",
    "nomicon_allocating_zero_sized_types_p5",
    "nomicon_the_final_code_p14",
    "nomicon_layout_p3",
    "nomicon_mod_tests",
    "nomicon_allocating_zero_sized_types_p8",
    "nomicon_the_final_code_p19",
    "nomicon_intoiter_p20",
    "nomicon_insert_and_remove_p1",
    "nomicon_intoiter_p8",
    "nomicon_drain_p18",
    "nomicon_drain_p7",
    "nomicon_let_x_v_pop",
    "nomicon_layout_p7",
    "nomicon_iterating_zero_sized_types_p3",
    "nomicon_allocating_zero_sized_types_p2",
    "nomicon_insert_and_remove_p4",
    "nomicon_deref_p3",
    "nomicon_insert_and_remove_p7",
    "nomicon_deref_p8",
    "nomicon_push_and_pop",
    "nomicon_intoiter_p4",
    "nomicon_drain_p2",
    "nomicon_drain_p19",
    "nomicon_the_final_code_p35",
    "nomicon_rawvec_p11",
    "nomicon_layout_p10",
    "nomicon_rawvec_p16",
    "nomicon_layout",
    "nomicon_iterating_zero_sized_types_p1",
    "nomicon_push_and_pop_p2",
    "nomicon_layout_p1",
    "nomicon_rawvec_p1",
    "nomicon_rawvec_p14",
    "nomicon_rawvec_p23",
    "nomicon_rawvec_p12",
    "nomicon_drain_p25",
    "nomicon_drain_p28",
    "nomicon_fn_main_p16",
    "nomicon_rawvec_p24",
    "nomicon_fn_main_p8",
    "nomicon_the_final_code_p33",
    "nomicon_tests_test_zst",
    "nomicon_allocating_zero_sized_types_p11",
    "nomicon_tests_iter_test",
    "nomicon_drain_p21",
    "nomicon_the_final_code_p28",
    "nomicon_let_first_drain_next_unwrap",
    "nomicon_example_implementing_vec_p1",
    "nomicon_fn_main_p9",
    "nomicon_allocating_zero_sized_types",
    "nomicon_rawvec_p8",
    "nomicon_the_final_code_p29",
    "nomicon_fn_main_p14",
    "nomicon_fn_main_p3",
    "nomicon_iterating_zero_sized_types_p8",
    "nomicon_layout_p11",
    "nomicon_the_final_code_p23",
    "nomicon_rawvec_p19",
    "nomicon_the_final_code_p11",
    "nomicon_the_final_code_p45",
    "nomicon_insert_and_remove_p8",
    "nomicon_the_final_code_p46",
    "nomicon_fn_main_p17",
    "nomicon_rawvec_p18",
    "nomicon_drain_p16",
    "nomicon_the_final_code_p31",
    "nomicon_drain_p12",
    "nomicon_drain_p4",
    "nomicon_fn_main_p1",
    "nomicon_the_final_code_p15",
    "nomicon_drain_p8",
    "nomicon_the_final_code_p17",
    "nomicon_fn_main_p19",
    "nomicon_intoiter_p3",
    "nomicon_for_i_in_0_10",
    "nomicon_intoiter_p2",
    "nomicon_assert_eq_1_v_0",
    "nomicon_rawvec_p6",
    "nomicon_rawvec_p21",
    "nomicon_the_final_code_p44",
    "nomicon_allocating_memory_p1",
    "nomicon_layout_p9",
    "nomicon_layout_p5",
    "nomicon_drain_p1",
    "nomicon_drain_p9",
    "nomicon_fn_main_p11",
    "nomicon_allocating_zero_sized_types_p9",
    "nomicon_drain_p14",
    "nomicon_drain",
    "nomicon_rawvec_p5",
    "nomicon_pub_fn_create_push_pop",
    "nomicon_insert_and_remove",
    "nomicon_deref_p1",
    "nomicon_push_and_pop_p1",
    "nomicon_allocating_zero_sized_types_p1",
    "nomicon_println_all_tests_finished_ok",
    "nomicon_the_final_code",
    "nomicon_the_final_code_p36",
    "nomicon_the_final_code_p42",
    "nomicon_intoiter_p9",
    "nomicon_allocating_zero_sized_types_p14",
    "nomicon_v_push_box_new_i",
    "nomicon_the_final_code_p2",
    "nomicon_insert_and_remove_p3"
  ]
}
