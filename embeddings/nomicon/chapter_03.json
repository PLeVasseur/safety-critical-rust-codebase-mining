{
  "source": "Rustonomicon",
  "source_repo": "https://github.com/rust-lang/nomicon",
  "extraction_date": "2026-01-03",
  "chapter": 3,
  "title": "Data Layout",
  "file": "data.md",
  "sections": [
    {
      "id": "nomicon_data_representation_in_rust",
      "title": "Data Representation in Rust",
      "level": 1,
      "content": "Low-level programming cares a lot about data layout. It's a big deal. It also\npervasively influences the rest of the language, so we're going to start by\ndigging into how data is represented in Rust.\n\nThis chapter is ideally in agreement with, and rendered redundant by,\nthe Type Layout section of the Reference. When this\nbook was first written, the reference was in complete disrepair, and the\nRustonomicon was attempting to serve as a partial replacement for the reference.\nThis is no longer the case, so this whole chapter can ideally be deleted.\n\nWe'll keep this chapter around for a bit longer, but ideally you should be\ncontributing any new facts or improvements to the Reference instead.\n\n[ref-type-layout]: ../reference/type-layout.html",
      "parent_id": null,
      "paragraphs": {
        "nomicon_data_representation_in_rust_p1": "Low-level programming cares a lot about data layout. It's a big deal. It also\npervasively influences the rest of the language, so we're going to start by\ndigging into how data is represented in Rust.",
        "nomicon_data_representation_in_rust_p2": "This chapter is ideally in agreement with, and rendered redundant by,\nthe Type Layout section of the Reference. When this\nbook was first written, the reference was in complete disrepair, and the\nRustonomicon was attempting to serve as a partial replacement for the reference.\nThis is no longer the case, so this whole chapter can ideally be deleted.",
        "nomicon_data_representation_in_rust_p3": "We'll keep this chapter around for a bit longer, but ideally you should be\ncontributing any new facts or improvements to the Reference instead.",
        "nomicon_data_representation_in_rust_p4": "[ref-type-layout]: ../reference/type-layout.html"
      }
    },
    {
      "id": "nomicon_repr_rust",
      "title": "repr(Rust)",
      "level": 1,
      "content": "First and foremost, all types have an alignment specified in bytes. The\nalignment of a type specifies what addresses are valid to store the value at. A\nvalue with alignment `n` must only be stored at an address that is a multiple of\n`n`. So alignment 2 means you must be stored at an even address, and 1 means\nthat you can be stored anywhere. Alignment is at least 1, and always a power\nof 2.\n\nPrimitives are usually aligned to their size, although this is\nplatform-specific behavior. For example, on x86 `u64` and `f64` are often\naligned to 4 bytes (32 bits).\n\nA type's size must always be a multiple of its alignment (Zero being a valid size\nfor any alignment). This ensures that an array of that type may always be indexed\nby offsetting by a multiple of its size. Note that the size and alignment of a\ntype may not be known statically in the case of dynamically sized types.\n\nRust gives you the following ways to lay out composite data:\n\n* structs (named product types)\n* tuples (anonymous product types)\n* arrays (homogeneous product types)\n* enums (named sum types -- tagged unions)\n* unions (untagged unions)\n\nAn enum is said to be *field-less* if none of its variants have associated data.\n\nBy default, composite structures have an alignment equal to the maximum\nof their fields' alignments. Rust will consequently insert padding where\nnecessary to ensure that all fields are properly aligned and that the overall\ntype's size is a multiple of its alignment. For instance:\n\nstruct A {\n    a: u8,\n    b: u32,\n    c: u16,\n}\n\nwill be 32-bit aligned on a target that aligns these primitives to their\nrespective sizes. The whole struct will therefore have a size that is a multiple\nof 32-bits. It may become:\n\nstruct A {\n    a: u8,\n    _pad1: [u8; 3], // to align `b`\n    b: u32,\n    c: u16,\n    _pad2: [u8; 2], // to make overall size multiple of 4\n}\n\nor maybe:\n\nstruct A {\n    b: u32,\n    c: u16,\n    a: u8,\n    _pad: u8,\n}\n\nThere is *no indirection* for these types; all data is stored within the struct,\nas you would expect in C. However with the exception of arrays (which are\ndensely packed and in-order), the layout of data is not specified by default.\nGiven the two following struct definitions:\n\nstruct A {\n    a: i32,\n    b: u64,\n}\n\nstruct B {\n    a: i32,\n    b: u64,\n}\n\nRust *does* guarantee that two instances of A have their data laid out in\nexactly the same way. However Rust *does not* currently guarantee that an\ninstance of A has the same field ordering or padding as an instance of B.\n\nWith A and B as written, this point would seem to be pedantic, but several other\nfeatures of Rust make it desirable for the language to play with data layout in\ncomplex ways.\n\nFor instance, consider this struct:\n\nstruct Foo<T, U> {\n    count: u16,\n    data1: T,\n    data2: U,\n}\n\nNow consider the monomorphizations of `Foo<u32, u16>` and `Foo<u16, u32>`. If\nRust lays out the fields in the order specified, we expect it to pad the\nvalues in the struct to satisfy their alignment requirements. So if Rust\ndidn't reorder fields, we would expect it to produce the following:\n\n<!-- ignore: explanation code -->\n,ignore\nstruct Foo<u16, u32> {\n    count: u16,\n    data1: u16,\n    data2: u32,\n}\n\nstruct Foo<u32, u16> {\n    count: u16,\n    _pad1: u16,\n    data1: u32,\n    data2: u16,\n    _pad2: u16,\n}\n\nThe latter case quite simply wastes space. An optimal use of space\nrequires different monomorphizations to have *different field orderings*.\n\nEnums make this consideration even more complicated. Naively, an enum such as:\n\nenum Foo {\n    A(u32),\n    B(u64),\n    C(u8),\n}\n\nmight be laid out as:\n\nstruct FooRepr {\n    data: u64, // this is either a u64, u32, or u8 based on `tag`\n    tag: u8,   // 0 = A, 1 = B, 2 = C\n}\n\nAnd indeed this is approximately how it would be laid out (modulo the\nsize and position of `tag`).\n\nHowever there are several cases where such a representation is inefficient. The\nclassic case of this is Rust's \"null pointer optimization\": an enum consisting\nof a single outer unit variant (e.g. `None`) and a (potentially nested) non-\nnullable pointer variant (e.g. `Some(&T)`) makes the tag unnecessary. A null\npointer can safely be interpreted as the unit (`None`) variant. The net\nresult is that, for example, `size_of::<Option<&T>>() == size_of::<&T>()`.\n\nThere are many types in Rust that are, or contain, non-nullable pointers such as\n`Box<T>`, `Vec<T>`, `String`, `&T`, and `&mut T`. Similarly, one can imagine\nnested enums pooling their tags into a single discriminant, as they are by\ndefinition known to have a limited range of valid values. In principle enums could\nuse fairly elaborate algorithms to store bits throughout nested types with\nforbidden values. As such it is *especially* desirable that\nwe leave enum layout unspecified today.\n\n[dst]: exotic-sizes.html#dynamically-sized-types-dsts",
      "parent_id": null,
      "paragraphs": {
        "nomicon_repr_rust_p1": "First and foremost, all types have an alignment specified in bytes. The\nalignment of a type specifies what addresses are valid to store the value at. A\nvalue with alignment `n` must only be stored at an address that is a multiple of\n`n`. So alignment 2 means you must be stored at an even address, and 1 means\nthat you can be stored anywhere. Alignment is at least 1, and always a power\nof 2.",
        "nomicon_repr_rust_p2": "Primitives are usually aligned to their size, although this is\nplatform-specific behavior. For example, on x86 `u64` and `f64` are often\naligned to 4 bytes (32 bits).",
        "nomicon_repr_rust_p3": "A type's size must always be a multiple of its alignment (Zero being a valid size\nfor any alignment). This ensures that an array of that type may always be indexed\nby offsetting by a multiple of its size. Note that the size and alignment of a\ntype may not be known statically in the case of dynamically sized types.",
        "nomicon_repr_rust_p4": "Rust gives you the following ways to lay out composite data:",
        "nomicon_repr_rust_p5": "* structs (named product types)\n* tuples (anonymous product types)\n* arrays (homogeneous product types)\n* enums (named sum types -- tagged unions)\n* unions (untagged unions)",
        "nomicon_repr_rust_p6": "An enum is said to be *field-less* if none of its variants have associated data.",
        "nomicon_repr_rust_p7": "By default, composite structures have an alignment equal to the maximum\nof their fields' alignments. Rust will consequently insert padding where\nnecessary to ensure that all fields are properly aligned and that the overall\ntype's size is a multiple of its alignment. For instance:",
        "nomicon_repr_rust_p8": "struct A {\n    a: u8,\n    b: u32,\n    c: u16,\n}",
        "nomicon_repr_rust_p9": "will be 32-bit aligned on a target that aligns these primitives to their\nrespective sizes. The whole struct will therefore have a size that is a multiple\nof 32-bits. It may become:",
        "nomicon_repr_rust_p10": "struct A {\n    a: u8,\n    _pad1: [u8; 3], // to align `b`\n    b: u32,\n    c: u16,\n    _pad2: [u8; 2], // to make overall size multiple of 4\n}",
        "nomicon_repr_rust_p11": "or maybe:",
        "nomicon_repr_rust_p12": "struct A {\n    b: u32,\n    c: u16,\n    a: u8,\n    _pad: u8,\n}",
        "nomicon_repr_rust_p13": "There is *no indirection* for these types; all data is stored within the struct,\nas you would expect in C. However with the exception of arrays (which are\ndensely packed and in-order), the layout of data is not specified by default.\nGiven the two following struct definitions:",
        "nomicon_repr_rust_p14": "struct A {\n    a: i32,\n    b: u64,\n}",
        "nomicon_repr_rust_p15": "struct B {\n    a: i32,\n    b: u64,\n}",
        "nomicon_repr_rust_p16": "Rust *does* guarantee that two instances of A have their data laid out in\nexactly the same way. However Rust *does not* currently guarantee that an\ninstance of A has the same field ordering or padding as an instance of B.",
        "nomicon_repr_rust_p17": "With A and B as written, this point would seem to be pedantic, but several other\nfeatures of Rust make it desirable for the language to play with data layout in\ncomplex ways.",
        "nomicon_repr_rust_p18": "For instance, consider this struct:",
        "nomicon_repr_rust_p19": "struct Foo<T, U> {\n    count: u16,\n    data1: T,\n    data2: U,\n}",
        "nomicon_repr_rust_p20": "Now consider the monomorphizations of `Foo<u32, u16>` and `Foo<u16, u32>`. If\nRust lays out the fields in the order specified, we expect it to pad the\nvalues in the struct to satisfy their alignment requirements. So if Rust\ndidn't reorder fields, we would expect it to produce the following:",
        "nomicon_repr_rust_p21": "<!-- ignore: explanation code -->\n,ignore\nstruct Foo<u16, u32> {\n    count: u16,\n    data1: u16,\n    data2: u32,\n}",
        "nomicon_repr_rust_p22": "struct Foo<u32, u16> {\n    count: u16,\n    _pad1: u16,\n    data1: u32,\n    data2: u16,\n    _pad2: u16,\n}",
        "nomicon_repr_rust_p23": "The latter case quite simply wastes space. An optimal use of space\nrequires different monomorphizations to have *different field orderings*.",
        "nomicon_repr_rust_p24": "Enums make this consideration even more complicated. Naively, an enum such as:",
        "nomicon_repr_rust_p25": "enum Foo {\n    A(u32),\n    B(u64),\n    C(u8),\n}",
        "nomicon_repr_rust_p26": "might be laid out as:",
        "nomicon_repr_rust_p27": "struct FooRepr {\n    data: u64, // this is either a u64, u32, or u8 based on `tag`\n    tag: u8,   // 0 = A, 1 = B, 2 = C\n}",
        "nomicon_repr_rust_p28": "And indeed this is approximately how it would be laid out (modulo the\nsize and position of `tag`).",
        "nomicon_repr_rust_p29": "However there are several cases where such a representation is inefficient. The\nclassic case of this is Rust's \"null pointer optimization\": an enum consisting\nof a single outer unit variant (e.g. `None`) and a (potentially nested) non-\nnullable pointer variant (e.g. `Some(&T)`) makes the tag unnecessary. A null\npointer can safely be interpreted as the unit (`None`) variant. The net\nresult is that, for example, `size_of::<Option<&T>>() == size_of::<&T>()`.",
        "nomicon_repr_rust_p30": "There are many types in Rust that are, or contain, non-nullable pointers such as\n`Box<T>`, `Vec<T>`, `String`, `&T`, and `&mut T`. Similarly, one can imagine\nnested enums pooling their tags into a single discriminant, as they are by\ndefinition known to have a limited range of valid values. In principle enums could\nuse fairly elaborate algorithms to store bits throughout nested types with\nforbidden values. As such it is *especially* desirable that\nwe leave enum layout unspecified today.",
        "nomicon_repr_rust_p31": "[dst]: exotic-sizes.html#dynamically-sized-types-dsts"
      }
    },
    {
      "id": "nomicon_exotically_sized_types",
      "title": "Exotically Sized Types",
      "level": 1,
      "content": "Most of the time, we expect types to have a statically known and positive size.\nThis isn't always the case in Rust.",
      "parent_id": null,
      "paragraphs": {
        "nomicon_exotically_sized_types_p1": "Most of the time, we expect types to have a statically known and positive size.\nThis isn't always the case in Rust."
      }
    },
    {
      "id": "nomicon_dynamically_sized_types_dsts",
      "title": "Dynamically Sized Types (DSTs)",
      "level": 2,
      "content": "Rust supports Dynamically Sized Types (DSTs): types without a statically\nknown size or alignment. On the surface, this is a bit nonsensical: Rust *must*\nknow the size and alignment of something in order to correctly work with it! In\nthis regard, DSTs are not normal types. Since they lack a statically known\nsize, these types can only exist behind a pointer. Any pointer to a\nDST consequently becomes a *wide* pointer consisting of the pointer and the\ninformation that \"completes\" them (more on this below).\n\nThere are two major DSTs exposed by the language:\n\n* trait objects: `dyn MyTrait`\n* slices: [`[T]`][slice], [`str`], and others\n\nA trait object represents some type that implements the traits it specifies.\nThe exact original type is *erased* in favor of runtime reflection\nwith a vtable containing all the information necessary to use the type.\nThe information that completes a trait object pointer is the vtable pointer.\nThe runtime size of the pointee can be dynamically requested from the vtable.\n\nA slice is simply a view into some contiguous storage -- typically an array or\n`Vec`. The information that completes a slice pointer is just the number of elements\nit points to. The runtime size of the pointee is just the statically known size\nof an element multiplied by the number of elements.\n\nStructs can actually store a single DST directly as their last field, but this\nmakes them a DST as well:\n\n// Can't be stored on the stack directly\nstruct MySuperSlice {\n    info: u32,\n    data: [u8],\n}\n\nUnfortunately, such a type is largely useless without a way to construct it. Currently the\nonly properly supported way to create a custom DST is by making your type generic\nand performing an *unsizing coercion*:\n\nstruct MySuperSliceable<T: ?Sized> {\n    info: u32,\n    data: T,\n}\n\nfn main() {\n    let sized: MySuperSliceable<[u8; 8]> = MySuperSliceable {\n        info: 17,\n        data: [0; 8],\n    };\n\n    let dynamic: &MySuperSliceable<[u8]> = &sized;\n\n    // prints: \"17 [0, 0, 0, 0, 0, 0, 0, 0]\"\n    println!(\"{} {:?}\", dynamic.info, &dynamic.data);\n}\n\n(Yes, custom DSTs are a largely half-baked feature for now.)",
      "parent_id": null,
      "paragraphs": {
        "nomicon_dynamically_sized_types_dsts_p1": "Rust supports Dynamically Sized Types (DSTs): types without a statically\nknown size or alignment. On the surface, this is a bit nonsensical: Rust *must*\nknow the size and alignment of something in order to correctly work with it! In\nthis regard, DSTs are not normal types. Since they lack a statically known\nsize, these types can only exist behind a pointer. Any pointer to a\nDST consequently becomes a *wide* pointer consisting of the pointer and the\ninformation that \"completes\" them (more on this below).",
        "nomicon_dynamically_sized_types_dsts_p2": "There are two major DSTs exposed by the language:",
        "nomicon_dynamically_sized_types_dsts_p3": "* trait objects: `dyn MyTrait`\n* slices: [`[T]`][slice], [`str`], and others",
        "nomicon_dynamically_sized_types_dsts_p4": "A trait object represents some type that implements the traits it specifies.\nThe exact original type is *erased* in favor of runtime reflection\nwith a vtable containing all the information necessary to use the type.\nThe information that completes a trait object pointer is the vtable pointer.\nThe runtime size of the pointee can be dynamically requested from the vtable.",
        "nomicon_dynamically_sized_types_dsts_p5": "A slice is simply a view into some contiguous storage -- typically an array or\n`Vec`. The information that completes a slice pointer is just the number of elements\nit points to. The runtime size of the pointee is just the statically known size\nof an element multiplied by the number of elements.",
        "nomicon_dynamically_sized_types_dsts_p6": "Structs can actually store a single DST directly as their last field, but this\nmakes them a DST as well:",
        "nomicon_dynamically_sized_types_dsts_p7": "// Can't be stored on the stack directly\nstruct MySuperSlice {\n    info: u32,\n    data: [u8],\n}",
        "nomicon_dynamically_sized_types_dsts_p8": "Unfortunately, such a type is largely useless without a way to construct it. Currently the\nonly properly supported way to create a custom DST is by making your type generic\nand performing an *unsizing coercion*:",
        "nomicon_dynamically_sized_types_dsts_p9": "struct MySuperSliceable<T: ?Sized> {\n    info: u32,\n    data: T,\n}",
        "nomicon_dynamically_sized_types_dsts_p10": "fn main() {\n    let sized: MySuperSliceable<[u8; 8]> = MySuperSliceable {\n        info: 17,\n        data: [0; 8],\n    };",
        "nomicon_dynamically_sized_types_dsts_p11": "let dynamic: &MySuperSliceable<[u8]> = &sized;",
        "nomicon_dynamically_sized_types_dsts_p12": "// prints: \"17 [0, 0, 0, 0, 0, 0, 0, 0]\"\n    println!(\"{} {:?}\", dynamic.info, &dynamic.data);\n}",
        "nomicon_dynamically_sized_types_dsts_p13": "(Yes, custom DSTs are a largely half-baked feature for now.)"
      }
    },
    {
      "id": "nomicon_zero_sized_types_zsts",
      "title": "Zero Sized Types (ZSTs)",
      "level": 2,
      "content": "Rust also allows types to be specified that occupy no space:\n\nstruct Nothing; // No fields = no size\n\n// All fields have no size = no size\nstruct LotsOfNothing {\n    foo: Nothing,\n    qux: (),      // empty tuple has no size\n    baz: [u8; 0], // empty array has no size\n}\n\nOn their own, Zero Sized Types (ZSTs) are, for obvious reasons, pretty useless.\nHowever as with many curious layout choices in Rust, their potential is realized\nin a generic context: Rust largely understands that any operation that produces\nor stores a ZST can be reduced to a no-op. First off, storing it doesn't even\nmake sense -- it doesn't occupy any space. Also there's only one value of that\ntype, so anything that loads it can just produce it from the aether -- which is\nalso a no-op since it doesn't occupy any space.\n\nOne of the most extreme examples of this is Sets and Maps. Given a\n`Map<Key, Value>`, it is common to implement a `Set<Key>` as just a thin wrapper\naround `Map<Key, UselessJunk>`. In many languages, this would necessitate\nallocating space for UselessJunk and doing work to store and load UselessJunk\nonly to discard it. Proving this unnecessary would be a difficult analysis for\nthe compiler.\n\nHowever in Rust, we can just say that  `Set<Key> = Map<Key, ()>`. Now Rust\nstatically knows that every load and store is useless, and no allocation has any\nsize. The result is that the monomorphized code is basically a custom\nimplementation of a HashSet with none of the overhead that HashMap would have to\nsupport values.\n\nSafe code need not worry about ZSTs, but *unsafe* code must be careful about the\nconsequence of types with no size. In particular, pointer offsets are no-ops,\nand allocators typically require a non-zero size.\n\nNote that references to ZSTs (including empty slices), just like all other\nreferences, must be non-null and suitably aligned. However, loading or storing\nthrough a null pointer to a ZST is not undefined behavior, unlike\npointers to other types.\n\n[alloc]: ../std/alloc/trait.GlobalAlloc.html#tymethod.alloc\n[ub]: what-unsafe-does.html",
      "parent_id": null,
      "paragraphs": {
        "nomicon_zero_sized_types_zsts_p1": "Rust also allows types to be specified that occupy no space:",
        "nomicon_zero_sized_types_zsts_p2": "struct Nothing; // No fields = no size",
        "nomicon_zero_sized_types_zsts_p3": "// All fields have no size = no size\nstruct LotsOfNothing {\n    foo: Nothing,\n    qux: (),      // empty tuple has no size\n    baz: [u8; 0], // empty array has no size\n}",
        "nomicon_zero_sized_types_zsts_p4": "On their own, Zero Sized Types (ZSTs) are, for obvious reasons, pretty useless.\nHowever as with many curious layout choices in Rust, their potential is realized\nin a generic context: Rust largely understands that any operation that produces\nor stores a ZST can be reduced to a no-op. First off, storing it doesn't even\nmake sense -- it doesn't occupy any space. Also there's only one value of that\ntype, so anything that loads it can just produce it from the aether -- which is\nalso a no-op since it doesn't occupy any space.",
        "nomicon_zero_sized_types_zsts_p5": "One of the most extreme examples of this is Sets and Maps. Given a\n`Map<Key, Value>`, it is common to implement a `Set<Key>` as just a thin wrapper\naround `Map<Key, UselessJunk>`. In many languages, this would necessitate\nallocating space for UselessJunk and doing work to store and load UselessJunk\nonly to discard it. Proving this unnecessary would be a difficult analysis for\nthe compiler.",
        "nomicon_zero_sized_types_zsts_p6": "However in Rust, we can just say that  `Set<Key> = Map<Key, ()>`. Now Rust\nstatically knows that every load and store is useless, and no allocation has any\nsize. The result is that the monomorphized code is basically a custom\nimplementation of a HashSet with none of the overhead that HashMap would have to\nsupport values.",
        "nomicon_zero_sized_types_zsts_p7": "Safe code need not worry about ZSTs, but *unsafe* code must be careful about the\nconsequence of types with no size. In particular, pointer offsets are no-ops,\nand allocators typically require a non-zero size.",
        "nomicon_zero_sized_types_zsts_p8": "Note that references to ZSTs (including empty slices), just like all other\nreferences, must be non-null and suitably aligned. However, loading or storing\nthrough a null pointer to a ZST is not undefined behavior, unlike\npointers to other types.",
        "nomicon_zero_sized_types_zsts_p9": "[alloc]: ../std/alloc/trait.GlobalAlloc.html#tymethod.alloc\n[ub]: what-unsafe-does.html"
      }
    },
    {
      "id": "nomicon_empty_types",
      "title": "Empty Types",
      "level": 2,
      "content": "Rust also enables types to be declared that *cannot even be instantiated*. These\ntypes can only be talked about at the type level, and never at the value level.\nEmpty types can be declared by specifying an enum with no variants:\n\nenum Void {} // No variants = EMPTY\n\nEmpty types are even more marginal than ZSTs. The primary motivating example for\nan empty type is type-level unreachability. For instance, suppose an API needs to\nreturn a Result in general, but a specific case actually is infallible. It's\nactually possible to communicate this at the type level by returning a\n`Result<T, Void>`. Consumers of the API can confidently unwrap such a Result\nknowing that it's *statically impossible* for this value to be an `Err`, as\nthis would require providing a value of type `Void`.\n\nIn principle, Rust can do some interesting analyses and optimizations based\non this fact. For instance, `Result<T, Void>` is represented as just `T`,\nbecause the `Err` case doesn't actually exist (strictly speaking, this is only\nan optimization that is not guaranteed, so for example transmuting one into the\nother is still Undefined Behavior).\n\nThe following also compiles:\n\nenum Void {}\n\nlet res: Result<u32, Void> = Ok(0);\n\n// Err doesn't exist anymore, so Ok is actually irrefutable.\nlet Ok(num) = res;\n\nOne final subtle detail about empty types is that raw pointers to them are\nactually valid to construct, but dereferencing them is Undefined Behavior\nbecause that wouldn't make sense.\n\nWe recommend against modelling C's `void*` type with `*const Void`.\nA lot of people started doing that but quickly ran into trouble because\nRust doesn't really have any safety guards against trying to instantiate\nempty types with unsafe code, and if you do it, it's Undefined Behavior.\nThis was especially problematic because developers had a habit of converting\nraw pointers to references and `&Void` is *also* Undefined Behavior to\nconstruct.\n\n`*const ()` (or equivalent) works reasonably well for `void*`, and can be made\ninto a reference without any safety problems. It still doesn't prevent you from\ntrying to read or write values, but at least it compiles to a no-op instead\nof Undefined Behavior.",
      "parent_id": null,
      "paragraphs": {
        "nomicon_empty_types_p1": "Rust also enables types to be declared that *cannot even be instantiated*. These\ntypes can only be talked about at the type level, and never at the value level.\nEmpty types can be declared by specifying an enum with no variants:",
        "nomicon_empty_types_p2": "enum Void {} // No variants = EMPTY",
        "nomicon_empty_types_p3": "Empty types are even more marginal than ZSTs. The primary motivating example for\nan empty type is type-level unreachability. For instance, suppose an API needs to\nreturn a Result in general, but a specific case actually is infallible. It's\nactually possible to communicate this at the type level by returning a\n`Result<T, Void>`. Consumers of the API can confidently unwrap such a Result\nknowing that it's *statically impossible* for this value to be an `Err`, as\nthis would require providing a value of type `Void`.",
        "nomicon_empty_types_p4": "In principle, Rust can do some interesting analyses and optimizations based\non this fact. For instance, `Result<T, Void>` is represented as just `T`,\nbecause the `Err` case doesn't actually exist (strictly speaking, this is only\nan optimization that is not guaranteed, so for example transmuting one into the\nother is still Undefined Behavior).",
        "nomicon_empty_types_p5": "The following also compiles:",
        "nomicon_empty_types_p6": "enum Void {}",
        "nomicon_empty_types_p7": "let res: Result<u32, Void> = Ok(0);",
        "nomicon_empty_types_p8": "// Err doesn't exist anymore, so Ok is actually irrefutable.\nlet Ok(num) = res;",
        "nomicon_empty_types_p9": "One final subtle detail about empty types is that raw pointers to them are\nactually valid to construct, but dereferencing them is Undefined Behavior\nbecause that wouldn't make sense.",
        "nomicon_empty_types_p10": "We recommend against modelling C's `void*` type with `*const Void`.\nA lot of people started doing that but quickly ran into trouble because\nRust doesn't really have any safety guards against trying to instantiate\nempty types with unsafe code, and if you do it, it's Undefined Behavior.\nThis was especially problematic because developers had a habit of converting\nraw pointers to references and `&Void` is *also* Undefined Behavior to\nconstruct.",
        "nomicon_empty_types_p11": "`*const ()` (or equivalent) works reasonably well for `void*`, and can be made\ninto a reference without any safety problems. It still doesn't prevent you from\ntrying to read or write values, but at least it compiles to a no-op instead\nof Undefined Behavior."
      }
    },
    {
      "id": "nomicon_extern_types",
      "title": "Extern Types",
      "level": 2,
      "content": "There is an accepted RFC to add proper types with an unknown size,\ncalled *extern types*, which would let Rust developers model things like C's `void*`\nand other \"declared but never defined\" types more accurately. However as of\nRust 2018, the feature is stuck in limbo over how `size_of_val::<MyExternType>()`\nshould behave.\n\n[extern-types]: https://github.com/rust-lang/rfcs/blob/master/text/1861-extern-types.md\n[extern-types-issue]: https://github.com/rust-lang/rust/issues/43467\n[`str`]: ../std/primitive.str.html\n[slice]: ../std/primitive.slice.html",
      "parent_id": null,
      "paragraphs": {
        "nomicon_extern_types_p1": "There is an accepted RFC to add proper types with an unknown size,\ncalled *extern types*, which would let Rust developers model things like C's `void*`\nand other \"declared but never defined\" types more accurately. However as of\nRust 2018, the feature is stuck in limbo over how `size_of_val::<MyExternType>()`\nshould behave.",
        "nomicon_extern_types_p2": "[extern-types]: https://github.com/rust-lang/rfcs/blob/master/text/1861-extern-types.md\n[extern-types-issue]: https://github.com/rust-lang/rust/issues/43467\n[`str`]: ../std/primitive.str.html\n[slice]: ../std/primitive.slice.html"
      }
    },
    {
      "id": "nomicon_alternative_representations",
      "title": "Alternative representations",
      "level": 1,
      "content": "Rust allows you to specify alternative data layout strategies from the default.",
      "parent_id": null,
      "paragraphs": {
        "nomicon_alternative_representations_p1": "Rust allows you to specify alternative data layout strategies from the default."
      }
    },
    {
      "id": "nomicon_repr_c",
      "title": "repr(C)",
      "level": 2,
      "content": "This is the most important `repr`. It has fairly simple intent: do what C does.\nThe order, size, and alignment of fields is exactly what you would expect from C\nor C++. The type is also passed across `extern \"C\"` function call boundaries the\nsame way C would pass the corresponding type. Any type you expect to pass through an FFI boundary should have\n`repr(C)`, as C is the lingua-franca of the programming world. This is also\nnecessary to soundly do more elaborate tricks with data layout such as\nreinterpreting values as a different type.\n\nWe strongly recommend using [rust-bindgen] and/or [cbindgen] to manage your FFI\nboundaries for you. The Rust team works closely with those projects to ensure\nthat they work robustly and are compatible with current and future guarantees\nabout type layouts and `repr`s.\n\nThe interaction of `repr(C)` with Rust's more exotic data layout features must be\nkept in mind. Due to its dual purpose as \"for FFI\" and \"for layout control\",\n`repr(C)` can be applied to types that will be nonsensical or problematic if\npassed through the FFI boundary.\n\n* ZSTs are still zero-sized, even though this is not a standard behavior in\nC, and is explicitly contrary to the behavior of an empty type in C++, which\nsays they should still consume a byte of space.\n\n* DST pointers (wide pointers) and tuples are not a concept\n  in C, and as such are never FFI-safe.\n\n* Enums with fields also aren't a concept in C or C++, but a valid bridging\n  of the types is defined.\n\n* If `T` is an FFI-safe non-nullable pointer\n  type,\n  `Option<T>` is guaranteed to have the same layout and ABI as `T` and is\n  therefore also FFI-safe. As of this writing, this covers `&`, `&mut`,\n  and function pointers, all of which can never be null.\n\n* Tuple structs are like structs with regards to `repr(C)`, as the only\n  difference from a struct is that the fields aren\u2019t named.\n\n* `repr(C)` is equivalent to one of `repr(u*)` (see the next section) for\nfieldless enums. The chosen size and sign is the default enum size and sign for the target platform's C\napplication binary interface (ABI). Note that enum representation in C is implementation\ndefined, so this is really a \"best guess\". In particular, this may be incorrect\nwhen the C code of interest is compiled with certain flags.\n\n* Fieldless enums with `repr(C)` or `repr(u*)` still may not be set to an\ninteger value without a corresponding variant, even though this is\npermitted behavior in C or C++. It is undefined behavior to (unsafely)\nconstruct an instance of an enum that does not match one of its\nvariants. (This allows exhaustive matches to continue to be written and\ncompiled as normal.)",
      "parent_id": null,
      "paragraphs": {
        "nomicon_repr_c_p1": "This is the most important `repr`. It has fairly simple intent: do what C does.\nThe order, size, and alignment of fields is exactly what you would expect from C\nor C++. The type is also passed across `extern \"C\"` function call boundaries the\nsame way C would pass the corresponding type. Any type you expect to pass through an FFI boundary should have\n`repr(C)`, as C is the lingua-franca of the programming world. This is also\nnecessary to soundly do more elaborate tricks with data layout such as\nreinterpreting values as a different type.",
        "nomicon_repr_c_p2": "We strongly recommend using [rust-bindgen] and/or [cbindgen] to manage your FFI\nboundaries for you. The Rust team works closely with those projects to ensure\nthat they work robustly and are compatible with current and future guarantees\nabout type layouts and `repr`s.",
        "nomicon_repr_c_p3": "The interaction of `repr(C)` with Rust's more exotic data layout features must be\nkept in mind. Due to its dual purpose as \"for FFI\" and \"for layout control\",\n`repr(C)` can be applied to types that will be nonsensical or problematic if\npassed through the FFI boundary.",
        "nomicon_repr_c_p4": "* ZSTs are still zero-sized, even though this is not a standard behavior in\nC, and is explicitly contrary to the behavior of an empty type in C++, which\nsays they should still consume a byte of space.",
        "nomicon_repr_c_p5": "* DST pointers (wide pointers) and tuples are not a concept\n  in C, and as such are never FFI-safe.",
        "nomicon_repr_c_p6": "* Enums with fields also aren't a concept in C or C++, but a valid bridging\n  of the types is defined.",
        "nomicon_repr_c_p7": "* If `T` is an FFI-safe non-nullable pointer\n  type,\n  `Option<T>` is guaranteed to have the same layout and ABI as `T` and is\n  therefore also FFI-safe. As of this writing, this covers `&`, `&mut`,\n  and function pointers, all of which can never be null.",
        "nomicon_repr_c_p8": "* Tuple structs are like structs with regards to `repr(C)`, as the only\n  difference from a struct is that the fields aren\u2019t named.",
        "nomicon_repr_c_p9": "* `repr(C)` is equivalent to one of `repr(u*)` (see the next section) for\nfieldless enums. The chosen size and sign is the default enum size and sign for the target platform's C\napplication binary interface (ABI). Note that enum representation in C is implementation\ndefined, so this is really a \"best guess\". In particular, this may be incorrect\nwhen the C code of interest is compiled with certain flags.",
        "nomicon_repr_c_p10": "* Fieldless enums with `repr(C)` or `repr(u*)` still may not be set to an\ninteger value without a corresponding variant, even though this is\npermitted behavior in C or C++. It is undefined behavior to (unsafely)\nconstruct an instance of an enum that does not match one of its\nvariants. (This allows exhaustive matches to continue to be written and\ncompiled as normal.)"
      }
    },
    {
      "id": "nomicon_repr_transparent",
      "title": "repr(transparent)",
      "level": 2,
      "content": "`#[repr(transparent)]` can only be used on a struct or single-variant enum that has a single non-zero-sized field (there may be additional zero-sized fields).\nThe effect is that the layout and ABI of the whole struct/enum is guaranteed to be the same as that one field.\n\n> NOTE: There's a `transparent_unions` nightly feature to apply `repr(transparent)` to unions,\n> but it hasn't been stabilized due to design concerns. See the tracking issue for more details.\n\nThe goal is to make it possible to transmute between the single field and the\nstruct/enum. An example of that is [`UnsafeCell`], which can be transmuted into\nthe type it wraps ([`UnsafeCell`] also uses the unstable no_niche,\nso its ABI is not actually guaranteed to be the same when nested in other types).\n\nAlso, passing the struct/enum through FFI where the inner field type is expected on\nthe other side is guaranteed to work. In particular, this is necessary for\n`struct Foo(f32)` or `enum Foo { Bar(f32) }` to always have the same ABI as `f32`.\n\nThis repr is only considered part of the public ABI of a type if either the single\nfield is `pub`, or if its layout is documented in prose. Otherwise, the layout should\nnot be relied upon by other crates.\n\nMore details are in the RFC 1758 and the RFC 2645.",
      "parent_id": null,
      "paragraphs": {
        "nomicon_repr_transparent_p1": "`#[repr(transparent)]` can only be used on a struct or single-variant enum that has a single non-zero-sized field (there may be additional zero-sized fields).\nThe effect is that the layout and ABI of the whole struct/enum is guaranteed to be the same as that one field.",
        "nomicon_repr_transparent_p2": "> NOTE: There's a `transparent_unions` nightly feature to apply `repr(transparent)` to unions,\n> but it hasn't been stabilized due to design concerns. See the tracking issue for more details.",
        "nomicon_repr_transparent_p3": "The goal is to make it possible to transmute between the single field and the\nstruct/enum. An example of that is [`UnsafeCell`], which can be transmuted into\nthe type it wraps ([`UnsafeCell`] also uses the unstable no_niche,\nso its ABI is not actually guaranteed to be the same when nested in other types).",
        "nomicon_repr_transparent_p4": "Also, passing the struct/enum through FFI where the inner field type is expected on\nthe other side is guaranteed to work. In particular, this is necessary for\n`struct Foo(f32)` or `enum Foo { Bar(f32) }` to always have the same ABI as `f32`.",
        "nomicon_repr_transparent_p5": "This repr is only considered part of the public ABI of a type if either the single\nfield is `pub`, or if its layout is documented in prose. Otherwise, the layout should\nnot be relied upon by other crates.",
        "nomicon_repr_transparent_p6": "More details are in the RFC 1758 and the RFC 2645."
      }
    },
    {
      "id": "nomicon_repr_u_repr_i",
      "title": "repr(u*), repr(i*)",
      "level": 2,
      "content": "These specify the size and sign to make a fieldless enum. If the discriminant overflows\nthe integer it has to fit in, it will produce a compile-time error. You can\nmanually ask Rust to allow this by setting the overflowing element to explicitly\nbe 0. However Rust will not allow you to create an enum where two variants have\nthe same discriminant.\n\nThe term \"fieldless enum\" only means that the enum doesn't have data in any\nof its variants. A fieldless enum without a `repr` is\nstill a Rust native type, and does not have a stable layout or representation.\nAdding a `repr(u*)`/`repr(i*)` causes it to be treated exactly like the specified\ninteger type for layout purposes (except that the compiler will still exploit its\nknowledge of \"invalid\" values at this type to optimize enum layout, such as when\nthis enum is wrapped in `Option`). Note that the function call ABI for these\ntypes is still in general unspecified, except that across `extern \"C\"` calls they\nare ABI-compatible with C enums of the same sign and size.\n\nIf the enum has fields, the effect is similar to the effect of `repr(C)`\nin that there is a defined layout of the type. This makes it possible to\npass the enum to C code, or access the type's raw representation and directly\nmanipulate its tag and fields. See the RFC for details.\n\nThese `repr`s have no effect on a struct.\n\nAdding an explicit `repr(u*)`, `repr(i*)`, or `repr(C)` to an enum with fields suppresses the null-pointer optimization, like:",
      "parent_id": null,
      "paragraphs": {
        "nomicon_repr_u_repr_i_p1": "These specify the size and sign to make a fieldless enum. If the discriminant overflows\nthe integer it has to fit in, it will produce a compile-time error. You can\nmanually ask Rust to allow this by setting the overflowing element to explicitly\nbe 0. However Rust will not allow you to create an enum where two variants have\nthe same discriminant.",
        "nomicon_repr_u_repr_i_p2": "The term \"fieldless enum\" only means that the enum doesn't have data in any\nof its variants. A fieldless enum without a `repr` is\nstill a Rust native type, and does not have a stable layout or representation.\nAdding a `repr(u*)`/`repr(i*)` causes it to be treated exactly like the specified\ninteger type for layout purposes (except that the compiler will still exploit its\nknowledge of \"invalid\" values at this type to optimize enum layout, such as when\nthis enum is wrapped in `Option`). Note that the function call ABI for these\ntypes is still in general unspecified, except that across `extern \"C\"` calls they\nare ABI-compatible with C enums of the same sign and size.",
        "nomicon_repr_u_repr_i_p3": "If the enum has fields, the effect is similar to the effect of `repr(C)`\nin that there is a defined layout of the type. This makes it possible to\npass the enum to C code, or access the type's raw representation and directly\nmanipulate its tag and fields. See the RFC for details.",
        "nomicon_repr_u_repr_i_p4": "These `repr`s have no effect on a struct.",
        "nomicon_repr_u_repr_i_p5": "Adding an explicit `repr(u*)`, `repr(i*)`, or `repr(C)` to an enum with fields suppresses the null-pointer optimization, like:",
        "nomicon_repr_u_repr_i_p6": ""
      }
    },
    {
      "id": "nomicon_use_std_mem_size_of",
      "title": "use std::mem::size_of;",
      "level": 1,
      "content": "enum MyOption<T> {\n    Some(T),\n    None,\n}\n\n#[repr(u8)]\nenum MyReprOption<T> {\n    Some(T),\n    None,\n}\n\nassert_eq!(8, size_of::<MyOption<&u16>>());\nassert_eq!(16, size_of::<MyReprOption<&u16>>());\n\nThis optimization still applies to fieldless enums with an explicit `repr(u*)`, `repr(i*)`, or `repr(C)`.",
      "parent_id": null,
      "paragraphs": {
        "nomicon_use_std_mem_size_of_p1": "enum MyOption<T> {\n    Some(T),\n    None,\n}",
        "nomicon_use_std_mem_size_of_p2": "#[repr(u8)]\nenum MyReprOption<T> {\n    Some(T),\n    None,\n}",
        "nomicon_use_std_mem_size_of_p3": "assert_eq!(8, size_of::<MyOption<&u16>>());\nassert_eq!(16, size_of::<MyReprOption<&u16>>());",
        "nomicon_use_std_mem_size_of_p4": "This optimization still applies to fieldless enums with an explicit `repr(u*)`, `repr(i*)`, or `repr(C)`."
      }
    },
    {
      "id": "nomicon_repr_packed_repr_packed_n",
      "title": "repr(packed), repr(packed(n))",
      "level": 2,
      "content": "`repr(packed(n))` (where `n` is a power of two) forces the type to have an\nalignment of *at most* `n`. Most commonly used without an explicit `n`,\n`repr(packed)` is equivalent to `repr(packed(1))` which forces Rust to strip\nany padding, and only align the type to a byte. This may improve the memory\nfootprint, but will likely have other negative side-effects.\n\nIn particular, most architectures *strongly* prefer values to be naturally\naligned. This may mean that unaligned loads are penalized (x86), or even fault\n(some ARM chips). For simple cases like directly loading or storing a packed\nfield, the compiler might be able to paper over alignment issues with shifts\nand masks. However if you take a reference to a packed field, it's unlikely\nthat the compiler will be able to emit code to avoid an unaligned load.\n\nAs this can cause undefined behavior, the lint has been implemented\nand it will become a hard error.\n\n`repr(packed)/repr(packed(n))` is not to be used lightly. Unless you have\nextreme requirements, this should not be used.\n\nThis repr is a modifier on `repr(C)` and `repr(Rust)`. For FFI compatibility\nyou most likely always want to be explicit: `repr(C, packed)`.",
      "parent_id": null,
      "paragraphs": {
        "nomicon_repr_packed_repr_packed_n_p1": "`repr(packed(n))` (where `n` is a power of two) forces the type to have an\nalignment of *at most* `n`. Most commonly used without an explicit `n`,\n`repr(packed)` is equivalent to `repr(packed(1))` which forces Rust to strip\nany padding, and only align the type to a byte. This may improve the memory\nfootprint, but will likely have other negative side-effects.",
        "nomicon_repr_packed_repr_packed_n_p2": "In particular, most architectures *strongly* prefer values to be naturally\naligned. This may mean that unaligned loads are penalized (x86), or even fault\n(some ARM chips). For simple cases like directly loading or storing a packed\nfield, the compiler might be able to paper over alignment issues with shifts\nand masks. However if you take a reference to a packed field, it's unlikely\nthat the compiler will be able to emit code to avoid an unaligned load.",
        "nomicon_repr_packed_repr_packed_n_p3": "As this can cause undefined behavior, the lint has been implemented\nand it will become a hard error.",
        "nomicon_repr_packed_repr_packed_n_p4": "`repr(packed)/repr(packed(n))` is not to be used lightly. Unless you have\nextreme requirements, this should not be used.",
        "nomicon_repr_packed_repr_packed_n_p5": "This repr is a modifier on `repr(C)` and `repr(Rust)`. For FFI compatibility\nyou most likely always want to be explicit: `repr(C, packed)`."
      }
    },
    {
      "id": "nomicon_repr_align_n",
      "title": "repr(align(n))",
      "level": 2,
      "content": "`repr(align(n))` (where `n` is a power of two) forces the type to have an\nalignment of *at least* `n`.\n\nThis enables several tricks, like making sure neighboring elements of an array\nnever share the same cache line with each other (which may speed up certain\nkinds of concurrent code).\n\nThis is a modifier on `repr(C)` and `repr(Rust)`. It is incompatible with\n`repr(packed)`.\n\n[drop flags]: drop-flags.html\n[ub loads]: https://github.com/rust-lang/rust/issues/27060\n[issue-60405]: https://github.com/rust-lang/rust/issues/60405\n[`UnsafeCell`]: ../std/cell/struct.UnsafeCell.html\n[rfc-transparent]: https://github.com/rust-lang/rfcs/blob/master/text/1758-repr-transparent.md\n[rfc-transparent-unions-enums]: https://rust-lang.github.io/rfcs/2645-transparent-unions.html\n[really-tagged]: https://github.com/rust-lang/rfcs/blob/master/text/2195-really-tagged-unions.md\n[rust-bindgen]: https://rust-lang.github.io/rust-bindgen/\n[cbindgen]: https://github.com/eqrion/cbindgen\n[no-niche-pull]: https://github.com/rust-lang/rust/pull/68491",
      "parent_id": null,
      "paragraphs": {
        "nomicon_repr_align_n_p1": "`repr(align(n))` (where `n` is a power of two) forces the type to have an\nalignment of *at least* `n`.",
        "nomicon_repr_align_n_p2": "This enables several tricks, like making sure neighboring elements of an array\nnever share the same cache line with each other (which may speed up certain\nkinds of concurrent code).",
        "nomicon_repr_align_n_p3": "This is a modifier on `repr(C)` and `repr(Rust)`. It is incompatible with\n`repr(packed)`.",
        "nomicon_repr_align_n_p4": "[drop flags]: drop-flags.html\n[ub loads]: https://github.com/rust-lang/rust/issues/27060\n[issue-60405]: https://github.com/rust-lang/rust/issues/60405\n[`UnsafeCell`]: ../std/cell/struct.UnsafeCell.html\n[rfc-transparent]: https://github.com/rust-lang/rfcs/blob/master/text/1758-repr-transparent.md\n[rfc-transparent-unions-enums]: https://rust-lang.github.io/rfcs/2645-transparent-unions.html\n[really-tagged]: https://github.com/rust-lang/rfcs/blob/master/text/2195-really-tagged-unions.md\n[rust-bindgen]: https://rust-lang.github.io/rust-bindgen/\n[cbindgen]: https://github.com/eqrion/cbindgen\n[no-niche-pull]: https://github.com/rust-lang/rust/pull/68491"
      }
    }
  ],
  "ids": [
    "nomicon_repr_rust_p18",
    "nomicon_repr_rust_p4",
    "nomicon_repr_rust",
    "nomicon_repr_packed_repr_packed_n_p4",
    "nomicon_repr_transparent_p6",
    "nomicon_dynamically_sized_types_dsts_p12",
    "nomicon_zero_sized_types_zsts_p1",
    "nomicon_repr_rust_p7",
    "nomicon_repr_rust_p19",
    "nomicon_repr_rust_p15",
    "nomicon_zero_sized_types_zsts_p5",
    "nomicon_repr_rust_p20",
    "nomicon_repr_packed_repr_packed_n",
    "nomicon_dynamically_sized_types_dsts_p11",
    "nomicon_repr_rust_p5",
    "nomicon_empty_types_p9",
    "nomicon_repr_c_p6",
    "nomicon_repr_packed_repr_packed_n_p3",
    "nomicon_repr_packed_repr_packed_n_p5",
    "nomicon_repr_c_p4",
    "nomicon_repr_align_n_p2",
    "nomicon_repr_rust_p12",
    "nomicon_repr_transparent_p4",
    "nomicon_use_std_mem_size_of_p3",
    "nomicon_repr_c_p5",
    "nomicon_repr_rust_p8",
    "nomicon_dynamically_sized_types_dsts_p9",
    "nomicon_empty_types_p3",
    "nomicon_zero_sized_types_zsts_p7",
    "nomicon_repr_rust_p9",
    "nomicon_dynamically_sized_types_dsts_p1",
    "nomicon_repr_u_repr_i_p1",
    "nomicon_repr_rust_p31",
    "nomicon_zero_sized_types_zsts_p4",
    "nomicon_repr_packed_repr_packed_n_p2",
    "nomicon_zero_sized_types_zsts_p2",
    "nomicon_use_std_mem_size_of_p1",
    "nomicon_repr_rust_p23",
    "nomicon_dynamically_sized_types_dsts_p3",
    "nomicon_repr_rust_p11",
    "nomicon_exotically_sized_types",
    "nomicon_repr_rust_p25",
    "nomicon_repr_u_repr_i_p5",
    "nomicon_repr_rust_p26",
    "nomicon_use_std_mem_size_of",
    "nomicon_dynamically_sized_types_dsts_p4",
    "nomicon_repr_transparent_p5",
    "nomicon_empty_types_p2",
    "nomicon_empty_types_p11",
    "nomicon_repr_rust_p17",
    "nomicon_repr_rust_p2",
    "nomicon_exotically_sized_types_p1",
    "nomicon_repr_rust_p14",
    "nomicon_empty_types_p5",
    "nomicon_repr_transparent_p3",
    "nomicon_repr_rust_p24",
    "nomicon_empty_types_p4",
    "nomicon_dynamically_sized_types_dsts_p8",
    "nomicon_repr_align_n_p1",
    "nomicon_repr_packed_repr_packed_n_p1",
    "nomicon_empty_types",
    "nomicon_repr_align_n_p4",
    "nomicon_repr_rust_p28",
    "nomicon_repr_c_p2",
    "nomicon_data_representation_in_rust_p1",
    "nomicon_alternative_representations",
    "nomicon_repr_rust_p1",
    "nomicon_repr_c_p3",
    "nomicon_empty_types_p8",
    "nomicon_repr_align_n",
    "nomicon_zero_sized_types_zsts",
    "nomicon_dynamically_sized_types_dsts_p7",
    "nomicon_repr_transparent_p2",
    "nomicon_repr_u_repr_i",
    "nomicon_data_representation_in_rust",
    "nomicon_dynamically_sized_types_dsts_p13",
    "nomicon_repr_rust_p10",
    "nomicon_repr_transparent_p1",
    "nomicon_repr_rust_p3",
    "nomicon_empty_types_p1",
    "nomicon_repr_rust_p29",
    "nomicon_repr_align_n_p3",
    "nomicon_data_representation_in_rust_p2",
    "nomicon_dynamically_sized_types_dsts_p6",
    "nomicon_data_representation_in_rust_p4",
    "nomicon_repr_rust_p16",
    "nomicon_zero_sized_types_zsts_p9",
    "nomicon_repr_rust_p6",
    "nomicon_repr_c_p10",
    "nomicon_use_std_mem_size_of_p2",
    "nomicon_repr_u_repr_i_p2",
    "nomicon_repr_rust_p13",
    "nomicon_zero_sized_types_zsts_p8",
    "nomicon_repr_c",
    "nomicon_repr_c_p1",
    "nomicon_dynamically_sized_types_dsts_p2",
    "nomicon_empty_types_p10",
    "nomicon_repr_c_p8",
    "nomicon_repr_c_p9",
    "nomicon_repr_c_p7",
    "nomicon_repr_rust_p27",
    "nomicon_dynamically_sized_types_dsts_p5",
    "nomicon_extern_types_p1",
    "nomicon_repr_transparent",
    "nomicon_repr_rust_p22",
    "nomicon_repr_rust_p30",
    "nomicon_repr_u_repr_i_p4",
    "nomicon_empty_types_p6",
    "nomicon_data_representation_in_rust_p3",
    "nomicon_alternative_representations_p1",
    "nomicon_zero_sized_types_zsts_p6",
    "nomicon_repr_rust_p21",
    "nomicon_empty_types_p7",
    "nomicon_extern_types_p2",
    "nomicon_zero_sized_types_zsts_p3",
    "nomicon_use_std_mem_size_of_p4",
    "nomicon_repr_u_repr_i_p3",
    "nomicon_dynamically_sized_types_dsts",
    "nomicon_extern_types",
    "nomicon_repr_u_repr_i_p6",
    "nomicon_dynamically_sized_types_dsts_p10"
  ]
}
