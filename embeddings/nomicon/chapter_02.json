{
  "source": "Rustonomicon",
  "source_repo": "https://github.com/rust-lang/nomicon",
  "extraction_date": "2026-01-03",
  "chapter": 2,
  "title": "Meet Safe and Unsafe",
  "file": "meet-safe-and-unsafe.md",
  "sections": [
    {
      "id": "nomicon_meet_safe_and_unsafe",
      "title": "Meet Safe and Unsafe",
      "level": 1,
      "content": "!safe and unsafe\n\nIt would be great to not have to worry about low-level implementation details.\nWho could possibly care how much space the empty tuple occupies? Sadly, it\nsometimes matters and we need to worry about it. The most common reason\ndevelopers start to care about implementation details is performance, but more\nimportantly, these details can become a matter of correctness when interfacing\ndirectly with hardware, operating systems, or other languages.\n\nWhen implementation details start to matter in a safe programming language,\nprogrammers usually have three options:\n\n* fiddle with the code to encourage the compiler/runtime to perform an optimization\n* adopt a more unidiomatic or cumbersome design to get the desired implementation\n* rewrite the implementation in a language that lets you deal with those details\n\nFor that last option, the language programmers tend to use is *C*. This is often\nnecessary to interface with systems that only declare a C interface.\n\nUnfortunately, C is incredibly unsafe to use (sometimes for good reason),\nand this unsafety is magnified when trying to interoperate with another\nlanguage. Care must be taken to ensure C and the other language agree on\nwhat's happening, and that they don't step on each other's toes.\n\nSo what does this have to do with Rust?\n\nWell, unlike C, Rust is a safe programming language.\n\nBut, like C, Rust is an unsafe programming language.\n\nMore accurately, Rust *contains* both a safe and unsafe programming language.\n\nRust can be thought of as a combination of two programming languages: *Safe\nRust* and *Unsafe Rust*. Conveniently, these names mean exactly what they say:\nSafe Rust is Safe. Unsafe Rust is, well, not. In fact, Unsafe Rust lets us\ndo some *really* unsafe things. Things the Rust authors will implore you not to\ndo, but we'll do anyway.\n\nSafe Rust is the *true* Rust programming language. If all you do is write Safe\nRust, you will never have to worry about type-safety or memory-safety. You will\nnever endure a dangling pointer, a use-after-free, or any other kind of\nUndefined Behavior (a.k.a. UB).\n\nThe standard library also gives you enough utilities out of the box that you'll\nbe able to write high-performance applications and libraries in pure idiomatic\nSafe Rust.\n\nBut maybe you want to talk to another language. Maybe you're writing a\nlow-level abstraction not exposed by the standard library. Maybe you're\n*writing* the standard library (which is written entirely in Rust). Maybe you\nneed to do something the type-system doesn't understand and just *frob some dang\nbits*. Maybe you need Unsafe Rust.\n\nUnsafe Rust is exactly like Safe Rust with all the same rules and semantics.\nIt just lets you do some *extra* things that are Definitely Not Safe\n(which we will define in the next section).\n\nThe value of this separation is that we gain the benefits of using an unsafe\nlanguage like C \u2014 low level control over implementation details \u2014 without most\nof the problems that come with trying to integrate it with a completely\ndifferent safe language.\n\nThere are still some problems \u2014 most notably, we must become aware of properties\nthat the type system assumes and audit them in any code that interacts with\nUnsafe Rust. That's the purpose of this book: to teach you about these assumptions\nand how to manage them.",
      "parent_id": null,
      "paragraphs": {
        "nomicon_meet_safe_and_unsafe_p1": "!safe and unsafe",
        "nomicon_meet_safe_and_unsafe_p2": "It would be great to not have to worry about low-level implementation details.\nWho could possibly care how much space the empty tuple occupies? Sadly, it\nsometimes matters and we need to worry about it. The most common reason\ndevelopers start to care about implementation details is performance, but more\nimportantly, these details can become a matter of correctness when interfacing\ndirectly with hardware, operating systems, or other languages.",
        "nomicon_meet_safe_and_unsafe_p3": "When implementation details start to matter in a safe programming language,\nprogrammers usually have three options:",
        "nomicon_meet_safe_and_unsafe_p4": "* fiddle with the code to encourage the compiler/runtime to perform an optimization\n* adopt a more unidiomatic or cumbersome design to get the desired implementation\n* rewrite the implementation in a language that lets you deal with those details",
        "nomicon_meet_safe_and_unsafe_p5": "For that last option, the language programmers tend to use is *C*. This is often\nnecessary to interface with systems that only declare a C interface.",
        "nomicon_meet_safe_and_unsafe_p6": "Unfortunately, C is incredibly unsafe to use (sometimes for good reason),\nand this unsafety is magnified when trying to interoperate with another\nlanguage. Care must be taken to ensure C and the other language agree on\nwhat's happening, and that they don't step on each other's toes.",
        "nomicon_meet_safe_and_unsafe_p7": "So what does this have to do with Rust?",
        "nomicon_meet_safe_and_unsafe_p8": "Well, unlike C, Rust is a safe programming language.",
        "nomicon_meet_safe_and_unsafe_p9": "But, like C, Rust is an unsafe programming language.",
        "nomicon_meet_safe_and_unsafe_p10": "More accurately, Rust *contains* both a safe and unsafe programming language.",
        "nomicon_meet_safe_and_unsafe_p11": "Rust can be thought of as a combination of two programming languages: *Safe\nRust* and *Unsafe Rust*. Conveniently, these names mean exactly what they say:\nSafe Rust is Safe. Unsafe Rust is, well, not. In fact, Unsafe Rust lets us\ndo some *really* unsafe things. Things the Rust authors will implore you not to\ndo, but we'll do anyway.",
        "nomicon_meet_safe_and_unsafe_p12": "Safe Rust is the *true* Rust programming language. If all you do is write Safe\nRust, you will never have to worry about type-safety or memory-safety. You will\nnever endure a dangling pointer, a use-after-free, or any other kind of\nUndefined Behavior (a.k.a. UB).",
        "nomicon_meet_safe_and_unsafe_p13": "The standard library also gives you enough utilities out of the box that you'll\nbe able to write high-performance applications and libraries in pure idiomatic\nSafe Rust.",
        "nomicon_meet_safe_and_unsafe_p14": "But maybe you want to talk to another language. Maybe you're writing a\nlow-level abstraction not exposed by the standard library. Maybe you're\n*writing* the standard library (which is written entirely in Rust). Maybe you\nneed to do something the type-system doesn't understand and just *frob some dang\nbits*. Maybe you need Unsafe Rust.",
        "nomicon_meet_safe_and_unsafe_p15": "Unsafe Rust is exactly like Safe Rust with all the same rules and semantics.\nIt just lets you do some *extra* things that are Definitely Not Safe\n(which we will define in the next section).",
        "nomicon_meet_safe_and_unsafe_p16": "The value of this separation is that we gain the benefits of using an unsafe\nlanguage like C \u2014 low level control over implementation details \u2014 without most\nof the problems that come with trying to integrate it with a completely\ndifferent safe language.",
        "nomicon_meet_safe_and_unsafe_p17": "There are still some problems \u2014 most notably, we must become aware of properties\nthat the type system assumes and audit them in any code that interacts with\nUnsafe Rust. That's the purpose of this book: to teach you about these assumptions\nand how to manage them."
      }
    },
    {
      "id": "nomicon_how_safe_and_unsafe_interact",
      "title": "How Safe and Unsafe Interact",
      "level": 1,
      "content": "What's the relationship between Safe Rust and Unsafe Rust? How do they\ninteract?\n\nThe separation between Safe Rust and Unsafe Rust is controlled with the\n`unsafe` keyword, which acts as an interface from one to the other. This is\nwhy we can say Safe Rust is a safe language: all the unsafe parts are kept\nexclusively behind the `unsafe` boundary. If you wish, you can even toss\n`#![forbid(unsafe_code)]` into your code base to statically guarantee that\nyou're only writing Safe Rust.\n\nThe `unsafe` keyword has two uses: to declare the existence of contracts the\ncompiler can't check, and to declare that a programmer has checked that these\ncontracts have been upheld.\n\nYou can use `unsafe` to indicate the existence of unchecked contracts on\n_functions_ and _trait declarations_. On functions, `unsafe` means that\nusers of the function must check that function's documentation to ensure\nthey are using it in a way that maintains the contracts the function\nrequires. On trait declarations, `unsafe` means that implementors of the\ntrait must check the trait documentation to ensure their implementation\nmaintains the contracts the trait requires.\n\nYou can use `unsafe` on a block to declare that all unsafe actions performed\nwithin are verified to uphold the contracts of those operations. For instance,\nthe index passed to `slice::get_unchecked` is in-bounds.\n\nYou can use `unsafe` on a trait implementation to declare that the implementation\nupholds the trait's contract. For instance, that a type implementing [`Send`] is\nreally safe to move to another thread.\n\nThe standard library has a number of unsafe functions, including:\n\n* `slice::get_unchecked`, which performs unchecked indexing,\n  allowing memory safety to be freely violated.\n* `mem::transmute` reinterprets some value as having a given type,\n  bypassing type safety in arbitrary ways (see [conversions] for details).\n* Every raw pointer to a sized type has an `offset` method that\n  invokes Undefined Behavior if the passed offset is not \"in bounds\".\n* All FFI (Foreign Function Interface) functions are `unsafe` to call because the\n  other language can do arbitrary operations that the Rust compiler can't check.\n\nAs of Rust 1.29.2 the standard library defines the following unsafe traits\n(there are others, but they are not stabilized yet and some of them may never\nbe):\n\n* [`Send`] is a marker trait (a trait with no API) that promises implementors\n  are safe to send (move) to another thread.\n* [`Sync`] is a marker trait that promises threads can safely share implementors\n  through a shared reference.\n* [`GlobalAlloc`] allows customizing the memory allocator of the whole program.\n\nMuch of the Rust standard library also uses Unsafe Rust internally. These\nimplementations have generally been rigorously manually checked, so the Safe Rust\ninterfaces built on top of these implementations can be assumed to be safe.\n\nThe need for all of this separation boils down a single fundamental property\nof Safe Rust, the *soundness property*:\n\n**No matter what, Safe Rust can't cause Undefined Behavior.**\n\nThe design of the safe/unsafe split means that there is an asymmetric trust\nrelationship between Safe and Unsafe Rust. Safe Rust inherently has to\ntrust that any Unsafe Rust it touches has been written correctly.\nOn the other hand, Unsafe Rust cannot trust Safe Rust without care.\n\nAs an example, Rust has the [`PartialOrd`] and [`Ord`] traits to differentiate\nbetween types which can \"just\" be compared, and those that provide a \"total\"\nordering (which basically means that comparison behaves reasonably).\n\n[`BTreeMap`] doesn't really make sense for partially-ordered types, and so it\nrequires that its keys implement `Ord`. However, `BTreeMap` has Unsafe Rust code\ninside of its implementation. Because it would be unacceptable for a sloppy `Ord`\nimplementation (which is Safe to write) to cause Undefined Behavior, the Unsafe\ncode in BTreeMap must be written to be robust against `Ord` implementations which\naren't actually total \u2014 even though that's the whole point of requiring `Ord`.\n\nThe Unsafe Rust code just can't trust the Safe Rust code to be written correctly.\nThat said, `BTreeMap` will still behave completely erratically if you feed in\nvalues that don't have a total ordering. It just won't ever cause Undefined\nBehavior.\n\nOne may wonder, if `BTreeMap` cannot trust `Ord` because it's Safe, why can it\ntrust *any* Safe code? For instance `BTreeMap` relies on integers and slices to\nbe implemented correctly. Those are safe too, right?\n\nThe difference is one of scope. When `BTreeMap` relies on integers and slices,\nit's relying on one very specific implementation. This is a measured risk that\ncan be weighed against the benefit. In this case there's basically zero risk;\nif integers and slices are broken, *everyone* is broken. Also, they're maintained\nby the same people who maintain `BTreeMap`, so it's easy to keep tabs on them.\n\nOn the other hand, `BTreeMap`'s key type is generic. Trusting its `Ord` implementation\nmeans trusting every `Ord` implementation in the past, present, and future.\nHere the risk is high: someone somewhere is going to make a mistake and mess up\ntheir `Ord` implementation, or even just straight up lie about providing a total\nordering because \"it seems to work\". When that happens, `BTreeMap` needs to be\nprepared.\n\nThe same logic applies to trusting a closure that's passed to you to behave\ncorrectly.\n\nThis problem of unbounded generic trust is the problem that `unsafe` traits\nexist to resolve. The `BTreeMap` type could theoretically require that keys\nimplement a new trait called `UnsafeOrd`, rather than `Ord`, that might look\nlike this:\n\nuse std::cmp::Ordering;\n\nunsafe trait UnsafeOrd {\n    fn cmp(&self, other: &Self) -> Ordering;\n}\n\nThen, a type would use `unsafe` to implement `UnsafeOrd`, indicating that\nthey've ensured their implementation maintains whatever contracts the\ntrait expects. In this situation, the Unsafe Rust in the internals of\n`BTreeMap` would be justified in trusting that the key type's `UnsafeOrd`\nimplementation is correct. If it isn't, it's the fault of the unsafe trait\nimplementation, which is consistent with Rust's safety guarantees.\n\nThe decision of whether to mark a trait `unsafe` is an API design choice. A\nsafe trait is easier to implement, but any unsafe code that relies on it must\ndefend against incorrect behavior. Marking a trait `unsafe` shifts this\nresponsibility to the implementor. Rust has traditionally avoided marking\ntraits `unsafe` because it makes Unsafe Rust pervasive, which isn't desirable.\n\n`Send` and `Sync` are marked unsafe because thread safety is a *fundamental\nproperty* that unsafe code can't possibly hope to defend against in the way it\ncould defend against a buggy `Ord` implementation. Similarly, `GlobalAllocator`\nis keeping accounts of all the memory in the program and other things like\n`Box` or `Vec` build on top of it. If it does something weird (giving the same\nchunk of memory to another request when it is still in use), there's no chance\nto detect that and do anything about it.\n\nThe decision of whether to mark your own traits `unsafe` depends on the same\nsort of consideration. If `unsafe` code can't reasonably expect to defend\nagainst a broken implementation of the trait, then marking the trait `unsafe` is\na reasonable choice.\n\nAs an aside, while `Send` and `Sync` are `unsafe` traits, they are *also*\nautomatically implemented for types when such derivations are provably safe\nto do. `Send` is automatically derived for all types composed only of values\nwhose types also implement `Send`. `Sync` is automatically derived for all\ntypes composed only of values whose types also implement `Sync`. This minimizes\nthe pervasive unsafety of making these two traits `unsafe`. And not many people\nare going to *implement* memory allocators (or use them directly, for that\nmatter).\n\nThis is the balance between Safe and Unsafe Rust. The separation is designed to\nmake using Safe Rust as ergonomic as possible, but requires extra effort and\ncare when writing Unsafe Rust. The rest of this book is largely a discussion\nof the sort of care that must be taken, and what contracts Unsafe Rust must uphold.\n\n[`Send`]: ../std/marker/trait.Send.html\n[`Sync`]: ../std/marker/trait.Sync.html\n[`GlobalAlloc`]: ../std/alloc/trait.GlobalAlloc.html\n[conversions]: conversions.html\n[ptr_offset]: ../std/primitive.pointer.html#method.offset\n[get_unchecked]: ../std/primitive.slice.html#method.get_unchecked\n[transmute]: ../std/mem/fn.transmute.html\n[`PartialOrd`]: ../std/cmp/trait.PartialOrd.html\n[`Ord`]: ../std/cmp/trait.Ord.html\n[`BTreeMap`]: ../std/collections/struct.BTreeMap.html",
      "parent_id": null,
      "paragraphs": {
        "nomicon_how_safe_and_unsafe_interact_p1": "What's the relationship between Safe Rust and Unsafe Rust? How do they\ninteract?",
        "nomicon_how_safe_and_unsafe_interact_p2": "The separation between Safe Rust and Unsafe Rust is controlled with the\n`unsafe` keyword, which acts as an interface from one to the other. This is\nwhy we can say Safe Rust is a safe language: all the unsafe parts are kept\nexclusively behind the `unsafe` boundary. If you wish, you can even toss\n`#![forbid(unsafe_code)]` into your code base to statically guarantee that\nyou're only writing Safe Rust.",
        "nomicon_how_safe_and_unsafe_interact_p3": "The `unsafe` keyword has two uses: to declare the existence of contracts the\ncompiler can't check, and to declare that a programmer has checked that these\ncontracts have been upheld.",
        "nomicon_how_safe_and_unsafe_interact_p4": "You can use `unsafe` to indicate the existence of unchecked contracts on\n_functions_ and _trait declarations_. On functions, `unsafe` means that\nusers of the function must check that function's documentation to ensure\nthey are using it in a way that maintains the contracts the function\nrequires. On trait declarations, `unsafe` means that implementors of the\ntrait must check the trait documentation to ensure their implementation\nmaintains the contracts the trait requires.",
        "nomicon_how_safe_and_unsafe_interact_p5": "You can use `unsafe` on a block to declare that all unsafe actions performed\nwithin are verified to uphold the contracts of those operations. For instance,\nthe index passed to `slice::get_unchecked` is in-bounds.",
        "nomicon_how_safe_and_unsafe_interact_p6": "You can use `unsafe` on a trait implementation to declare that the implementation\nupholds the trait's contract. For instance, that a type implementing [`Send`] is\nreally safe to move to another thread.",
        "nomicon_how_safe_and_unsafe_interact_p7": "The standard library has a number of unsafe functions, including:",
        "nomicon_how_safe_and_unsafe_interact_p8": "* `slice::get_unchecked`, which performs unchecked indexing,\n  allowing memory safety to be freely violated.\n* `mem::transmute` reinterprets some value as having a given type,\n  bypassing type safety in arbitrary ways (see [conversions] for details).\n* Every raw pointer to a sized type has an `offset` method that\n  invokes Undefined Behavior if the passed offset is not \"in bounds\".\n* All FFI (Foreign Function Interface) functions are `unsafe` to call because the\n  other language can do arbitrary operations that the Rust compiler can't check.",
        "nomicon_how_safe_and_unsafe_interact_p9": "As of Rust 1.29.2 the standard library defines the following unsafe traits\n(there are others, but they are not stabilized yet and some of them may never\nbe):",
        "nomicon_how_safe_and_unsafe_interact_p10": "* [`Send`] is a marker trait (a trait with no API) that promises implementors\n  are safe to send (move) to another thread.\n* [`Sync`] is a marker trait that promises threads can safely share implementors\n  through a shared reference.\n* [`GlobalAlloc`] allows customizing the memory allocator of the whole program.",
        "nomicon_how_safe_and_unsafe_interact_p11": "Much of the Rust standard library also uses Unsafe Rust internally. These\nimplementations have generally been rigorously manually checked, so the Safe Rust\ninterfaces built on top of these implementations can be assumed to be safe.",
        "nomicon_how_safe_and_unsafe_interact_p12": "The need for all of this separation boils down a single fundamental property\nof Safe Rust, the *soundness property*:",
        "nomicon_how_safe_and_unsafe_interact_p13": "**No matter what, Safe Rust can't cause Undefined Behavior.**",
        "nomicon_how_safe_and_unsafe_interact_p14": "The design of the safe/unsafe split means that there is an asymmetric trust\nrelationship between Safe and Unsafe Rust. Safe Rust inherently has to\ntrust that any Unsafe Rust it touches has been written correctly.\nOn the other hand, Unsafe Rust cannot trust Safe Rust without care.",
        "nomicon_how_safe_and_unsafe_interact_p15": "As an example, Rust has the [`PartialOrd`] and [`Ord`] traits to differentiate\nbetween types which can \"just\" be compared, and those that provide a \"total\"\nordering (which basically means that comparison behaves reasonably).",
        "nomicon_how_safe_and_unsafe_interact_p16": "[`BTreeMap`] doesn't really make sense for partially-ordered types, and so it\nrequires that its keys implement `Ord`. However, `BTreeMap` has Unsafe Rust code\ninside of its implementation. Because it would be unacceptable for a sloppy `Ord`\nimplementation (which is Safe to write) to cause Undefined Behavior, the Unsafe\ncode in BTreeMap must be written to be robust against `Ord` implementations which\naren't actually total \u2014 even though that's the whole point of requiring `Ord`.",
        "nomicon_how_safe_and_unsafe_interact_p17": "The Unsafe Rust code just can't trust the Safe Rust code to be written correctly.\nThat said, `BTreeMap` will still behave completely erratically if you feed in\nvalues that don't have a total ordering. It just won't ever cause Undefined\nBehavior.",
        "nomicon_how_safe_and_unsafe_interact_p18": "One may wonder, if `BTreeMap` cannot trust `Ord` because it's Safe, why can it\ntrust *any* Safe code? For instance `BTreeMap` relies on integers and slices to\nbe implemented correctly. Those are safe too, right?",
        "nomicon_how_safe_and_unsafe_interact_p19": "The difference is one of scope. When `BTreeMap` relies on integers and slices,\nit's relying on one very specific implementation. This is a measured risk that\ncan be weighed against the benefit. In this case there's basically zero risk;\nif integers and slices are broken, *everyone* is broken. Also, they're maintained\nby the same people who maintain `BTreeMap`, so it's easy to keep tabs on them.",
        "nomicon_how_safe_and_unsafe_interact_p20": "On the other hand, `BTreeMap`'s key type is generic. Trusting its `Ord` implementation\nmeans trusting every `Ord` implementation in the past, present, and future.\nHere the risk is high: someone somewhere is going to make a mistake and mess up\ntheir `Ord` implementation, or even just straight up lie about providing a total\nordering because \"it seems to work\". When that happens, `BTreeMap` needs to be\nprepared.",
        "nomicon_how_safe_and_unsafe_interact_p21": "The same logic applies to trusting a closure that's passed to you to behave\ncorrectly.",
        "nomicon_how_safe_and_unsafe_interact_p22": "This problem of unbounded generic trust is the problem that `unsafe` traits\nexist to resolve. The `BTreeMap` type could theoretically require that keys\nimplement a new trait called `UnsafeOrd`, rather than `Ord`, that might look\nlike this:",
        "nomicon_how_safe_and_unsafe_interact_p23": "use std::cmp::Ordering;",
        "nomicon_how_safe_and_unsafe_interact_p24": "unsafe trait UnsafeOrd {\n    fn cmp(&self, other: &Self) -> Ordering;\n}",
        "nomicon_how_safe_and_unsafe_interact_p25": "Then, a type would use `unsafe` to implement `UnsafeOrd`, indicating that\nthey've ensured their implementation maintains whatever contracts the\ntrait expects. In this situation, the Unsafe Rust in the internals of\n`BTreeMap` would be justified in trusting that the key type's `UnsafeOrd`\nimplementation is correct. If it isn't, it's the fault of the unsafe trait\nimplementation, which is consistent with Rust's safety guarantees.",
        "nomicon_how_safe_and_unsafe_interact_p26": "The decision of whether to mark a trait `unsafe` is an API design choice. A\nsafe trait is easier to implement, but any unsafe code that relies on it must\ndefend against incorrect behavior. Marking a trait `unsafe` shifts this\nresponsibility to the implementor. Rust has traditionally avoided marking\ntraits `unsafe` because it makes Unsafe Rust pervasive, which isn't desirable.",
        "nomicon_how_safe_and_unsafe_interact_p27": "`Send` and `Sync` are marked unsafe because thread safety is a *fundamental\nproperty* that unsafe code can't possibly hope to defend against in the way it\ncould defend against a buggy `Ord` implementation. Similarly, `GlobalAllocator`\nis keeping accounts of all the memory in the program and other things like\n`Box` or `Vec` build on top of it. If it does something weird (giving the same\nchunk of memory to another request when it is still in use), there's no chance\nto detect that and do anything about it.",
        "nomicon_how_safe_and_unsafe_interact_p28": "The decision of whether to mark your own traits `unsafe` depends on the same\nsort of consideration. If `unsafe` code can't reasonably expect to defend\nagainst a broken implementation of the trait, then marking the trait `unsafe` is\na reasonable choice.",
        "nomicon_how_safe_and_unsafe_interact_p29": "As an aside, while `Send` and `Sync` are `unsafe` traits, they are *also*\nautomatically implemented for types when such derivations are provably safe\nto do. `Send` is automatically derived for all types composed only of values\nwhose types also implement `Send`. `Sync` is automatically derived for all\ntypes composed only of values whose types also implement `Sync`. This minimizes\nthe pervasive unsafety of making these two traits `unsafe`. And not many people\nare going to *implement* memory allocators (or use them directly, for that\nmatter).",
        "nomicon_how_safe_and_unsafe_interact_p30": "This is the balance between Safe and Unsafe Rust. The separation is designed to\nmake using Safe Rust as ergonomic as possible, but requires extra effort and\ncare when writing Unsafe Rust. The rest of this book is largely a discussion\nof the sort of care that must be taken, and what contracts Unsafe Rust must uphold.",
        "nomicon_how_safe_and_unsafe_interact_p31": "[`Send`]: ../std/marker/trait.Send.html\n[`Sync`]: ../std/marker/trait.Sync.html\n[`GlobalAlloc`]: ../std/alloc/trait.GlobalAlloc.html\n[conversions]: conversions.html\n[ptr_offset]: ../std/primitive.pointer.html#method.offset\n[get_unchecked]: ../std/primitive.slice.html#method.get_unchecked\n[transmute]: ../std/mem/fn.transmute.html\n[`PartialOrd`]: ../std/cmp/trait.PartialOrd.html\n[`Ord`]: ../std/cmp/trait.Ord.html\n[`BTreeMap`]: ../std/collections/struct.BTreeMap.html"
      }
    },
    {
      "id": "nomicon_what_unsafe_rust_can_do",
      "title": "What Unsafe Rust Can Do",
      "level": 1,
      "content": "The only things that are different in Unsafe Rust are that you can:\n\n* Dereference raw pointers\n* Call `unsafe` functions (including C functions, compiler intrinsics, and the raw allocator)\n* Implement `unsafe` traits\n* Access or modify mutable statics\n* Access fields of `union`s\n\nThat's it. The reason these operations are relegated to Unsafe is that misusing\nany of these things will cause the ever dreaded Undefined Behavior. Invoking\nUndefined Behavior gives the compiler full rights to do arbitrarily bad things\nto your program. You definitely *should not* invoke Undefined Behavior.\n\nUnlike C, Undefined Behavior is pretty limited in scope in Rust. All the core\nlanguage cares about is preventing the following things:\n\n* Dereferencing (using the `*` operator on) dangling or unaligned pointers (see below)\n* Breaking the pointer aliasing rules\n* Calling a function with the wrong call ABI or unwinding from a function with the wrong unwind ABI.\n* Causing a data race\n* Executing code compiled with target features that the current thread of execution does\n  not support\n* Producing invalid values (either alone or as a field of a compound type such\n  as `enum`/`struct`/array/tuple):\n  * a `bool` that isn't 0 or 1\n  * an `enum` with an invalid discriminant\n  * a null `fn` pointer\n  * a `char` outside the ranges [0x0, 0xD7FF] and [0xE000, 0x10FFFF]\n  * a `!` (all values are invalid for this type)\n  * an integer (`i*`/`u*`), floating point value (`f*`), or raw pointer read from\n    uninitialized memory, or uninitialized memory in a `str`.\n  * a reference/`Box` that is dangling, unaligned, or points to an invalid value.\n  * a wide reference, `Box`, or raw pointer that has invalid metadata:\n    * `dyn Trait` metadata is invalid if it is not a pointer to a vtable for\n      `Trait` that matches the actual dynamic trait the pointer or reference points to\n    * slice metadata is invalid if the length is not a valid `usize`\n      (i.e., it must not be read from uninitialized memory)\n  * a type with custom invalid values that is one of those values, such as a\n    [`NonNull`] that is null. (Requesting custom invalid values is an unstable\n    feature, but some stable libstd types, like `NonNull`, make use of it.)\n\nFor a more detailed explanation about \"Undefined Behavior\", you may refer to\nthe reference.\n\n\"Producing\" a value happens any time a value is assigned, passed to a\nfunction/primitive operation or returned from a function/primitive operation.\n\nA reference/pointer is \"dangling\" if it is null or not all of the bytes it\npoints to are part of the same allocation (so in particular they all have to be\npart of *some* allocation). The span of bytes it points to is determined by the\npointer value and the size of the pointee type. As a consequence, if the span is\nempty, \"dangling\" is the same as \"null\". Note that slices and strings point\nto their entire range, so it's important that the length metadata is never too\nlarge (in particular, allocations and therefore slices and strings cannot be\nbigger than `isize::MAX` bytes). If for some reason this is too cumbersome,\nconsider using raw pointers.\n\nThat's it. That's all the causes of Undefined Behavior baked into Rust. Of\ncourse, unsafe functions and traits are free to declare arbitrary other\nconstraints that a program must maintain to avoid Undefined Behavior. For\ninstance, the allocator APIs declare that deallocating unallocated memory is\nUndefined Behavior.\n\nHowever, violations of these constraints generally will just transitively lead to one of\nthe above problems. Some additional constraints may also derive from compiler\nintrinsics that make special assumptions about how code can be optimized. For instance,\nVec and Box make use of intrinsics that require their pointers to be non-null at all times.\n\nRust is otherwise quite permissive with respect to other dubious operations.\nRust considers it \"safe\" to:\n\n* Deadlock\n* Have a race condition\n* Leak memory\n* Overflow integers (with the built-in operators such as `+` etc.)\n* Abort the program\n* Delete the production database\n\nFor more detailed information, you may refer to the reference.\n\nHowever any program that actually manages to do such a thing is *probably*\nincorrect. Rust provides lots of tools to make these things rare, but\nthese problems are considered impractical to categorically prevent.\n\n[pointer aliasing rules]: references.html\n[uninitialized memory]: uninitialized.html\n[race]: races.html\n[target features]: ../reference/attributes/codegen.html#the-target_feature-attribute\n[`NonNull`]: ../std/ptr/struct.NonNull.html\n[behavior-considered-undefined]: ../reference/behavior-considered-undefined.html\n[behavior-not-considered-unsafe]: ../reference/behavior-not-considered-unsafe.html",
      "parent_id": null,
      "paragraphs": {
        "nomicon_what_unsafe_rust_can_do_p1": "The only things that are different in Unsafe Rust are that you can:",
        "nomicon_what_unsafe_rust_can_do_p2": "* Dereference raw pointers\n* Call `unsafe` functions (including C functions, compiler intrinsics, and the raw allocator)\n* Implement `unsafe` traits\n* Access or modify mutable statics\n* Access fields of `union`s",
        "nomicon_what_unsafe_rust_can_do_p3": "That's it. The reason these operations are relegated to Unsafe is that misusing\nany of these things will cause the ever dreaded Undefined Behavior. Invoking\nUndefined Behavior gives the compiler full rights to do arbitrarily bad things\nto your program. You definitely *should not* invoke Undefined Behavior.",
        "nomicon_what_unsafe_rust_can_do_p4": "Unlike C, Undefined Behavior is pretty limited in scope in Rust. All the core\nlanguage cares about is preventing the following things:",
        "nomicon_what_unsafe_rust_can_do_p5": "* Dereferencing (using the `*` operator on) dangling or unaligned pointers (see below)\n* Breaking the pointer aliasing rules\n* Calling a function with the wrong call ABI or unwinding from a function with the wrong unwind ABI.\n* Causing a data race\n* Executing code compiled with target features that the current thread of execution does\n  not support\n* Producing invalid values (either alone or as a field of a compound type such\n  as `enum`/`struct`/array/tuple):\n  * a `bool` that isn't 0 or 1\n  * an `enum` with an invalid discriminant\n  * a null `fn` pointer\n  * a `char` outside the ranges [0x0, 0xD7FF] and [0xE000, 0x10FFFF]\n  * a `!` (all values are invalid for this type)\n  * an integer (`i*`/`u*`), floating point value (`f*`), or raw pointer read from\n    uninitialized memory, or uninitialized memory in a `str`.\n  * a reference/`Box` that is dangling, unaligned, or points to an invalid value.\n  * a wide reference, `Box`, or raw pointer that has invalid metadata:\n    * `dyn Trait` metadata is invalid if it is not a pointer to a vtable for\n      `Trait` that matches the actual dynamic trait the pointer or reference points to\n    * slice metadata is invalid if the length is not a valid `usize`\n      (i.e., it must not be read from uninitialized memory)\n  * a type with custom invalid values that is one of those values, such as a\n    [`NonNull`] that is null. (Requesting custom invalid values is an unstable\n    feature, but some stable libstd types, like `NonNull`, make use of it.)",
        "nomicon_what_unsafe_rust_can_do_p6": "For a more detailed explanation about \"Undefined Behavior\", you may refer to\nthe reference.",
        "nomicon_what_unsafe_rust_can_do_p7": "\"Producing\" a value happens any time a value is assigned, passed to a\nfunction/primitive operation or returned from a function/primitive operation.",
        "nomicon_what_unsafe_rust_can_do_p8": "A reference/pointer is \"dangling\" if it is null or not all of the bytes it\npoints to are part of the same allocation (so in particular they all have to be\npart of *some* allocation). The span of bytes it points to is determined by the\npointer value and the size of the pointee type. As a consequence, if the span is\nempty, \"dangling\" is the same as \"null\". Note that slices and strings point\nto their entire range, so it's important that the length metadata is never too\nlarge (in particular, allocations and therefore slices and strings cannot be\nbigger than `isize::MAX` bytes). If for some reason this is too cumbersome,\nconsider using raw pointers.",
        "nomicon_what_unsafe_rust_can_do_p9": "That's it. That's all the causes of Undefined Behavior baked into Rust. Of\ncourse, unsafe functions and traits are free to declare arbitrary other\nconstraints that a program must maintain to avoid Undefined Behavior. For\ninstance, the allocator APIs declare that deallocating unallocated memory is\nUndefined Behavior.",
        "nomicon_what_unsafe_rust_can_do_p10": "However, violations of these constraints generally will just transitively lead to one of\nthe above problems. Some additional constraints may also derive from compiler\nintrinsics that make special assumptions about how code can be optimized. For instance,\nVec and Box make use of intrinsics that require their pointers to be non-null at all times.",
        "nomicon_what_unsafe_rust_can_do_p11": "Rust is otherwise quite permissive with respect to other dubious operations.\nRust considers it \"safe\" to:",
        "nomicon_what_unsafe_rust_can_do_p12": "* Deadlock\n* Have a race condition\n* Leak memory\n* Overflow integers (with the built-in operators such as `+` etc.)\n* Abort the program\n* Delete the production database",
        "nomicon_what_unsafe_rust_can_do_p13": "For more detailed information, you may refer to the reference.",
        "nomicon_what_unsafe_rust_can_do_p14": "However any program that actually manages to do such a thing is *probably*\nincorrect. Rust provides lots of tools to make these things rare, but\nthese problems are considered impractical to categorically prevent.",
        "nomicon_what_unsafe_rust_can_do_p15": "[pointer aliasing rules]: references.html\n[uninitialized memory]: uninitialized.html\n[race]: races.html\n[target features]: ../reference/attributes/codegen.html#the-target_feature-attribute\n[`NonNull`]: ../std/ptr/struct.NonNull.html\n[behavior-considered-undefined]: ../reference/behavior-considered-undefined.html\n[behavior-not-considered-unsafe]: ../reference/behavior-not-considered-unsafe.html"
      }
    },
    {
      "id": "nomicon_working_with_unsafe",
      "title": "Working with Unsafe",
      "level": 1,
      "content": "Rust generally only gives us the tools to talk about Unsafe Rust in a scoped and\nbinary manner. Unfortunately, reality is significantly more complicated than\nthat. For instance, consider the following toy function:\n\nfn index(idx: usize, arr: &[u8]) -> Option<u8> {\n    if idx < arr.len() {\n        unsafe {\n            Some(*arr.get_unchecked(idx))\n        }\n    } else {\n        None\n    }\n}\n\nThis function is safe and correct. We check that the index is in bounds, and if\nit is, index into the array in an unchecked manner. We say that such a correct\nunsafely implemented function is *sound*, meaning that safe code cannot cause\nUndefined Behavior through it (which, remember, is the single fundamental\nproperty of Safe Rust).\n\nBut even in such a trivial function, the scope of the unsafe block is\nquestionable. Consider changing the `<` to a `<=`:\n\nfn index(idx: usize, arr: &[u8]) -> Option<u8> {\n    if idx <= arr.len() {\n        unsafe {\n            Some(*arr.get_unchecked(idx))\n        }\n    } else {\n        None\n    }\n}\n\nThis program is now *unsound*, Safe Rust can cause Undefined Behavior, and yet\n*we only modified safe code*. This is the fundamental problem of safety: it's\nnon-local. The soundness of our unsafe operations necessarily depends on the\nstate established by otherwise \"safe\" operations.\n\nSafety is modular in the sense that opting into unsafety doesn't require you\nto consider arbitrary other kinds of badness. For instance, doing an unchecked\nindex into a slice doesn't mean you suddenly need to worry about the slice being\nnull or containing uninitialized memory. Nothing fundamentally changes. However\nsafety *isn't* modular in the sense that programs are inherently stateful and\nyour unsafe operations may depend on arbitrary other state.\n\nThis non-locality gets much worse when we incorporate actual persistent state.\nConsider a simple implementation of `Vec`:\n\nuse std::ptr;\n\n// Note: This definition is naive. See the chapter on implementing Vec.\npub struct Vec<T> {\n    ptr: *mut T,\n    len: usize,\n    cap: usize,\n}\n\n// Note this implementation does not correctly handle zero-sized types.\n// See the chapter on implementing Vec.\nimpl<T> Vec<T> {\n    pub fn push(&mut self, elem: T) {\n        if self.len == self.cap {\n            // not important for this example\n            self.reallocate();\n        }\n        unsafe {\n            ptr::write(self.ptr.add(self.len), elem);\n            self.len += 1;\n        }\n    }\n    # fn reallocate(&mut self) { }\n}",
      "parent_id": null,
      "paragraphs": {
        "nomicon_working_with_unsafe_p1": "Rust generally only gives us the tools to talk about Unsafe Rust in a scoped and\nbinary manner. Unfortunately, reality is significantly more complicated than\nthat. For instance, consider the following toy function:",
        "nomicon_working_with_unsafe_p2": "fn index(idx: usize, arr: &[u8]) -> Option<u8> {\n    if idx < arr.len() {\n        unsafe {\n            Some(*arr.get_unchecked(idx))\n        }\n    } else {\n        None\n    }\n}",
        "nomicon_working_with_unsafe_p3": "This function is safe and correct. We check that the index is in bounds, and if\nit is, index into the array in an unchecked manner. We say that such a correct\nunsafely implemented function is *sound*, meaning that safe code cannot cause\nUndefined Behavior through it (which, remember, is the single fundamental\nproperty of Safe Rust).",
        "nomicon_working_with_unsafe_p4": "But even in such a trivial function, the scope of the unsafe block is\nquestionable. Consider changing the `<` to a `<=`:",
        "nomicon_working_with_unsafe_p5": "fn index(idx: usize, arr: &[u8]) -> Option<u8> {\n    if idx <= arr.len() {\n        unsafe {\n            Some(*arr.get_unchecked(idx))\n        }\n    } else {\n        None\n    }\n}",
        "nomicon_working_with_unsafe_p6": "This program is now *unsound*, Safe Rust can cause Undefined Behavior, and yet\n*we only modified safe code*. This is the fundamental problem of safety: it's\nnon-local. The soundness of our unsafe operations necessarily depends on the\nstate established by otherwise \"safe\" operations.",
        "nomicon_working_with_unsafe_p7": "Safety is modular in the sense that opting into unsafety doesn't require you\nto consider arbitrary other kinds of badness. For instance, doing an unchecked\nindex into a slice doesn't mean you suddenly need to worry about the slice being\nnull or containing uninitialized memory. Nothing fundamentally changes. However\nsafety *isn't* modular in the sense that programs are inherently stateful and\nyour unsafe operations may depend on arbitrary other state.",
        "nomicon_working_with_unsafe_p8": "This non-locality gets much worse when we incorporate actual persistent state.\nConsider a simple implementation of `Vec`:",
        "nomicon_working_with_unsafe_p9": "use std::ptr;",
        "nomicon_working_with_unsafe_p10": "// Note: This definition is naive. See the chapter on implementing Vec.\npub struct Vec<T> {\n    ptr: *mut T,\n    len: usize,\n    cap: usize,\n}",
        "nomicon_working_with_unsafe_p11": "// Note this implementation does not correctly handle zero-sized types.\n// See the chapter on implementing Vec.\nimpl<T> Vec<T> {\n    pub fn push(&mut self, elem: T) {\n        if self.len == self.cap {\n            // not important for this example\n            self.reallocate();\n        }\n        unsafe {\n            ptr::write(self.ptr.add(self.len), elem);\n            self.len += 1;\n        }\n    }\n    # fn reallocate(&mut self) { }\n}"
      }
    },
    {
      "id": "nomicon_fn_main",
      "title": "fn main() {}",
      "level": 1,
      "content": "This code is simple enough to reasonably audit and informally verify. Now consider\nadding the following method:\n\n<!-- ignore: simplified code -->\n,ignore\nfn make_room(&mut self) {\n    // grow the capacity\n    self.cap += 1;\n}\n\nThis code is 100% Safe Rust but it is also completely unsound. Changing the\ncapacity violates the invariants of Vec (that `cap` reflects the allocated space\nin the Vec). This is not something the rest of Vec can guard against. It *has*\nto trust the capacity field because there's no way to verify it.\n\nBecause it relies on invariants of a struct field, this `unsafe` code\ndoes more than pollute a whole function: it pollutes a whole *module*.\nGenerally, the only bullet-proof way to limit the scope of unsafe code is at the\nmodule boundary with privacy.\n\nHowever this works *perfectly*. The existence of `make_room` is *not* a\nproblem for the soundness of Vec because we didn't mark it as public. Only the\nmodule that defines this function can call it. Also, `make_room` directly\naccesses the private fields of Vec, so it can only be written in the same module\nas Vec.\n\nIt is therefore possible for us to write a completely safe abstraction that\nrelies on complex invariants. This is *critical* to the relationship between\nSafe Rust and Unsafe Rust.\n\nWe have already seen that Unsafe code must trust *some* Safe code, but shouldn't\ntrust *generic* Safe code. Privacy is important to unsafe code for similar reasons:\nit prevents us from having to trust all the safe code in the universe from messing\nwith our trusted state.\n\nSafety lives!",
      "parent_id": null,
      "paragraphs": {
        "nomicon_fn_main_p1": "",
        "nomicon_fn_main_p2": "This code is simple enough to reasonably audit and informally verify. Now consider\nadding the following method:",
        "nomicon_fn_main_p3": "<!-- ignore: simplified code -->\n,ignore\nfn make_room(&mut self) {\n    // grow the capacity\n    self.cap += 1;\n}",
        "nomicon_fn_main_p4": "This code is 100% Safe Rust but it is also completely unsound. Changing the\ncapacity violates the invariants of Vec (that `cap` reflects the allocated space\nin the Vec). This is not something the rest of Vec can guard against. It *has*\nto trust the capacity field because there's no way to verify it.",
        "nomicon_fn_main_p5": "Because it relies on invariants of a struct field, this `unsafe` code\ndoes more than pollute a whole function: it pollutes a whole *module*.\nGenerally, the only bullet-proof way to limit the scope of unsafe code is at the\nmodule boundary with privacy.",
        "nomicon_fn_main_p6": "However this works *perfectly*. The existence of `make_room` is *not* a\nproblem for the soundness of Vec because we didn't mark it as public. Only the\nmodule that defines this function can call it. Also, `make_room` directly\naccesses the private fields of Vec, so it can only be written in the same module\nas Vec.",
        "nomicon_fn_main_p7": "It is therefore possible for us to write a completely safe abstraction that\nrelies on complex invariants. This is *critical* to the relationship between\nSafe Rust and Unsafe Rust.",
        "nomicon_fn_main_p8": "We have already seen that Unsafe code must trust *some* Safe code, but shouldn't\ntrust *generic* Safe code. Privacy is important to unsafe code for similar reasons:\nit prevents us from having to trust all the safe code in the universe from messing\nwith our trusted state.",
        "nomicon_fn_main_p9": "Safety lives!"
      }
    }
  ],
  "ids": [
    "nomicon_working_with_unsafe_p4",
    "nomicon_fn_main_p4",
    "nomicon_meet_safe_and_unsafe_p17",
    "nomicon_what_unsafe_rust_can_do_p15",
    "nomicon_meet_safe_and_unsafe_p12",
    "nomicon_how_safe_and_unsafe_interact_p24",
    "nomicon_what_unsafe_rust_can_do_p5",
    "nomicon_working_with_unsafe_p1",
    "nomicon_what_unsafe_rust_can_do_p12",
    "nomicon_how_safe_and_unsafe_interact_p13",
    "nomicon_meet_safe_and_unsafe_p1",
    "nomicon_meet_safe_and_unsafe_p7",
    "nomicon_meet_safe_and_unsafe_p5",
    "nomicon_meet_safe_and_unsafe_p6",
    "nomicon_how_safe_and_unsafe_interact_p17",
    "nomicon_working_with_unsafe_p2",
    "nomicon_how_safe_and_unsafe_interact_p22",
    "nomicon_how_safe_and_unsafe_interact_p15",
    "nomicon_working_with_unsafe_p8",
    "nomicon_how_safe_and_unsafe_interact_p7",
    "nomicon_fn_main",
    "nomicon_how_safe_and_unsafe_interact_p19",
    "nomicon_what_unsafe_rust_can_do_p14",
    "nomicon_how_safe_and_unsafe_interact_p5",
    "nomicon_how_safe_and_unsafe_interact_p3",
    "nomicon_how_safe_and_unsafe_interact_p18",
    "nomicon_working_with_unsafe_p10",
    "nomicon_meet_safe_and_unsafe_p10",
    "nomicon_how_safe_and_unsafe_interact_p23",
    "nomicon_what_unsafe_rust_can_do_p13",
    "nomicon_fn_main_p7",
    "nomicon_how_safe_and_unsafe_interact_p12",
    "nomicon_what_unsafe_rust_can_do_p9",
    "nomicon_how_safe_and_unsafe_interact_p11",
    "nomicon_fn_main_p6",
    "nomicon_fn_main_p5",
    "nomicon_how_safe_and_unsafe_interact_p10",
    "nomicon_how_safe_and_unsafe_interact_p1",
    "nomicon_how_safe_and_unsafe_interact_p4",
    "nomicon_what_unsafe_rust_can_do_p8",
    "nomicon_working_with_unsafe_p6",
    "nomicon_how_safe_and_unsafe_interact",
    "nomicon_how_safe_and_unsafe_interact_p20",
    "nomicon_fn_main_p2",
    "nomicon_how_safe_and_unsafe_interact_p9",
    "nomicon_what_unsafe_rust_can_do_p11",
    "nomicon_how_safe_and_unsafe_interact_p6",
    "nomicon_how_safe_and_unsafe_interact_p21",
    "nomicon_working_with_unsafe_p9",
    "nomicon_what_unsafe_rust_can_do_p4",
    "nomicon_what_unsafe_rust_can_do_p10",
    "nomicon_what_unsafe_rust_can_do_p7",
    "nomicon_what_unsafe_rust_can_do_p1",
    "nomicon_working_with_unsafe_p7",
    "nomicon_meet_safe_and_unsafe_p4",
    "nomicon_meet_safe_and_unsafe_p11",
    "nomicon_meet_safe_and_unsafe_p14",
    "nomicon_what_unsafe_rust_can_do_p2",
    "nomicon_what_unsafe_rust_can_do_p6",
    "nomicon_meet_safe_and_unsafe",
    "nomicon_how_safe_and_unsafe_interact_p26",
    "nomicon_how_safe_and_unsafe_interact_p16",
    "nomicon_how_safe_and_unsafe_interact_p8",
    "nomicon_how_safe_and_unsafe_interact_p14",
    "nomicon_working_with_unsafe_p3",
    "nomicon_fn_main_p8",
    "nomicon_working_with_unsafe",
    "nomicon_meet_safe_and_unsafe_p2",
    "nomicon_how_safe_and_unsafe_interact_p27",
    "nomicon_what_unsafe_rust_can_do",
    "nomicon_fn_main_p9",
    "nomicon_meet_safe_and_unsafe_p13",
    "nomicon_working_with_unsafe_p5",
    "nomicon_what_unsafe_rust_can_do_p3",
    "nomicon_fn_main_p3",
    "nomicon_meet_safe_and_unsafe_p16",
    "nomicon_meet_safe_and_unsafe_p15",
    "nomicon_fn_main_p1",
    "nomicon_working_with_unsafe_p11",
    "nomicon_how_safe_and_unsafe_interact_p31",
    "nomicon_meet_safe_and_unsafe_p8",
    "nomicon_how_safe_and_unsafe_interact_p30",
    "nomicon_how_safe_and_unsafe_interact_p29",
    "nomicon_how_safe_and_unsafe_interact_p25",
    "nomicon_how_safe_and_unsafe_interact_p28",
    "nomicon_how_safe_and_unsafe_interact_p2",
    "nomicon_meet_safe_and_unsafe_p3",
    "nomicon_meet_safe_and_unsafe_p9"
  ]
}
