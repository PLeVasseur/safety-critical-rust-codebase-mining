{
  "source": "Rustonomicon",
  "source_repo": "https://github.com/rust-lang/nomicon",
  "extraction_date": "2026-01-03",
  "chapter": 8,
  "title": "Unwinding",
  "file": "unwinding.md",
  "sections": [
    {
      "id": "nomicon_unwinding",
      "title": "Unwinding",
      "level": 1,
      "content": "Rust has a *tiered* error-handling scheme:\n\n* If something might reasonably be absent, Option is used.\n* If something goes wrong and can reasonably be handled, Result is used.\n* If something goes wrong and cannot reasonably be handled, the thread panics.\n* If something catastrophic happens, the program aborts.\n\nOption and Result are overwhelmingly preferred in most situations, especially\nsince they can be promoted into a panic or abort at the API user's discretion.\nPanics cause the thread to halt normal execution and unwind its stack, calling\ndestructors as if every function instantly returned.\n\nAs of 1.0, Rust is of two minds when it comes to panics. In the long-long-ago,\nRust was much more like Erlang. Like Erlang, Rust had lightweight tasks,\nand tasks were intended to kill themselves with a panic when they reached an\nuntenable state. Unlike an exception in Java or C++, a panic could not be\ncaught at any time. Panics could only be caught by the owner of the task, at which\npoint they had to be handled or *that* task would itself panic.\n\nUnwinding was important to this story because if a task's\ndestructors weren't called, it would cause memory and other system resources to\nleak. Since tasks were expected to die during normal execution, this would make\nRust very poor for long-running systems!\n\nAs the Rust we know today came to be, this style of programming grew out of\nfashion in the push for less-and-less abstraction. Light-weight tasks were\nkilled in the name of heavy-weight OS threads. Still, on stable Rust as of 1.0\npanics can only be caught by the parent thread. This means catching a panic\nrequires spinning up an entire OS thread! This unfortunately stands in conflict\nto Rust's philosophy of zero-cost abstractions.\n\nThere is an API called [`catch_unwind`] that enables catching a panic\nwithout spawning a thread. Still, we would encourage you to only do this\nsparingly. In particular, Rust's current unwinding implementation is heavily\noptimized for the \"doesn't unwind\" case. If a program doesn't unwind, there\nshould be no runtime cost for the program being *ready* to unwind. As a\nconsequence, actually unwinding will be more expensive than in e.g. Java.\nDon't build your programs to unwind under normal circumstances. Ideally, you\nshould only panic for programming errors or *extreme* problems.\n\nRust's unwinding strategy is not specified to be fundamentally compatible\nwith any other language's unwinding. As such, unwinding into Rust from another\nlanguage, or unwinding into another language from Rust is Undefined Behavior.\nYou must *absolutely* catch any panics at the FFI boundary! What you do at that\npoint is up to you, but *something* must be done. If you fail to do this,\nat best, your application will crash and burn. At worst, your application *won't*\ncrash and burn, and will proceed with completely clobbered state.\n\n[`catch_unwind`]: https://doc.rust-lang.org/std/panic/fn.catch_unwind.html",
      "parent_id": null,
      "paragraphs": {
        "nomicon_unwinding_p1": "Rust has a *tiered* error-handling scheme:",
        "nomicon_unwinding_p2": "* If something might reasonably be absent, Option is used.\n* If something goes wrong and can reasonably be handled, Result is used.\n* If something goes wrong and cannot reasonably be handled, the thread panics.\n* If something catastrophic happens, the program aborts.",
        "nomicon_unwinding_p3": "Option and Result are overwhelmingly preferred in most situations, especially\nsince they can be promoted into a panic or abort at the API user's discretion.\nPanics cause the thread to halt normal execution and unwind its stack, calling\ndestructors as if every function instantly returned.",
        "nomicon_unwinding_p4": "As of 1.0, Rust is of two minds when it comes to panics. In the long-long-ago,\nRust was much more like Erlang. Like Erlang, Rust had lightweight tasks,\nand tasks were intended to kill themselves with a panic when they reached an\nuntenable state. Unlike an exception in Java or C++, a panic could not be\ncaught at any time. Panics could only be caught by the owner of the task, at which\npoint they had to be handled or *that* task would itself panic.",
        "nomicon_unwinding_p5": "Unwinding was important to this story because if a task's\ndestructors weren't called, it would cause memory and other system resources to\nleak. Since tasks were expected to die during normal execution, this would make\nRust very poor for long-running systems!",
        "nomicon_unwinding_p6": "As the Rust we know today came to be, this style of programming grew out of\nfashion in the push for less-and-less abstraction. Light-weight tasks were\nkilled in the name of heavy-weight OS threads. Still, on stable Rust as of 1.0\npanics can only be caught by the parent thread. This means catching a panic\nrequires spinning up an entire OS thread! This unfortunately stands in conflict\nto Rust's philosophy of zero-cost abstractions.",
        "nomicon_unwinding_p7": "There is an API called [`catch_unwind`] that enables catching a panic\nwithout spawning a thread. Still, we would encourage you to only do this\nsparingly. In particular, Rust's current unwinding implementation is heavily\noptimized for the \"doesn't unwind\" case. If a program doesn't unwind, there\nshould be no runtime cost for the program being *ready* to unwind. As a\nconsequence, actually unwinding will be more expensive than in e.g. Java.\nDon't build your programs to unwind under normal circumstances. Ideally, you\nshould only panic for programming errors or *extreme* problems.",
        "nomicon_unwinding_p8": "Rust's unwinding strategy is not specified to be fundamentally compatible\nwith any other language's unwinding. As such, unwinding into Rust from another\nlanguage, or unwinding into another language from Rust is Undefined Behavior.\nYou must *absolutely* catch any panics at the FFI boundary! What you do at that\npoint is up to you, but *something* must be done. If you fail to do this,\nat best, your application will crash and burn. At worst, your application *won't*\ncrash and burn, and will proceed with completely clobbered state.",
        "nomicon_unwinding_p9": "[`catch_unwind`]: https://doc.rust-lang.org/std/panic/fn.catch_unwind.html"
      }
    },
    {
      "id": "nomicon_exception_safety",
      "title": "Exception Safety",
      "level": 1,
      "content": "Although programs should use unwinding sparingly, there's a lot of code that\n*can* panic. If you unwrap a None, index out of bounds, or divide by 0, your\nprogram will panic. On debug builds, every arithmetic operation can panic\nif it overflows. Unless you are very careful and tightly control what code runs,\npretty much everything can unwind, and you need to be ready for it.\n\nBeing ready for unwinding is often referred to as *exception safety*\nin the broader programming world. In Rust, there are two levels of exception\nsafety that one may concern themselves with:\n\n* In unsafe code, we *must* be exception safe to the point of not violating\n  memory safety. We'll call this *minimal* exception safety.\n\n* In safe code, it is *good* to be exception safe to the point of your program\n  doing the right thing. We'll call this *maximal* exception safety.\n\nAs is the case in many places in Rust, Unsafe code must be ready to deal with\nbad Safe code when it comes to unwinding. Code that transiently creates\nunsound states must be careful that a panic does not cause that state to be\nused. Generally this means ensuring that only non-panicking code is run while\nthese states exist, or making a guard that cleans up the state in the case of\na panic. This does not necessarily mean that the state a panic witnesses is a\nfully coherent state. We need only guarantee that it's a *safe* state.\n\nMost Unsafe code is leaf-like, and therefore fairly easy to make exception-safe.\nIt controls all the code that runs, and most of that code can't panic. However\nit is not uncommon for Unsafe code to work with arrays of temporarily\nuninitialized data while repeatedly invoking caller-provided code. Such code\nneeds to be careful and consider exception safety.",
      "parent_id": null,
      "paragraphs": {
        "nomicon_exception_safety_p1": "Although programs should use unwinding sparingly, there's a lot of code that\n*can* panic. If you unwrap a None, index out of bounds, or divide by 0, your\nprogram will panic. On debug builds, every arithmetic operation can panic\nif it overflows. Unless you are very careful and tightly control what code runs,\npretty much everything can unwind, and you need to be ready for it.",
        "nomicon_exception_safety_p2": "Being ready for unwinding is often referred to as *exception safety*\nin the broader programming world. In Rust, there are two levels of exception\nsafety that one may concern themselves with:",
        "nomicon_exception_safety_p3": "* In unsafe code, we *must* be exception safe to the point of not violating\n  memory safety. We'll call this *minimal* exception safety.",
        "nomicon_exception_safety_p4": "* In safe code, it is *good* to be exception safe to the point of your program\n  doing the right thing. We'll call this *maximal* exception safety.",
        "nomicon_exception_safety_p5": "As is the case in many places in Rust, Unsafe code must be ready to deal with\nbad Safe code when it comes to unwinding. Code that transiently creates\nunsound states must be careful that a panic does not cause that state to be\nused. Generally this means ensuring that only non-panicking code is run while\nthese states exist, or making a guard that cleans up the state in the case of\na panic. This does not necessarily mean that the state a panic witnesses is a\nfully coherent state. We need only guarantee that it's a *safe* state.",
        "nomicon_exception_safety_p6": "Most Unsafe code is leaf-like, and therefore fairly easy to make exception-safe.\nIt controls all the code that runs, and most of that code can't panic. However\nit is not uncommon for Unsafe code to work with arrays of temporarily\nuninitialized data while repeatedly invoking caller-provided code. Such code\nneeds to be careful and consider exception safety."
      }
    },
    {
      "id": "nomicon_vec_push_all",
      "title": "Vec::push_all",
      "level": 2,
      "content": "`Vec::push_all` is a temporary hack to get extending a Vec by a slice reliably\nefficient without specialization. Here's a simple implementation:\n\n<!-- ignore: simplified code -->\n,ignore\nimpl<T: Clone> Vec<T> {\n    fn push_all(&mut self, to_push: &[T]) {\n        self.reserve(to_push.len());\n        unsafe {\n            // can't overflow because we just reserved this\n            self.set_len(self.len() + to_push.len());\n\n            for (i, x) in to_push.iter().enumerate() {\n                self.ptr().add(i).write(x.clone());\n            }\n        }\n    }\n}\n\nWe bypass `push` in order to avoid redundant capacity and `len` checks on the\nVec that we definitely know has capacity. The logic is totally correct, except\nthere's a subtle problem with our code: it's not exception-safe! `set_len`,\n`add`, and `write` are all fine; `clone` is the panic bomb we over-looked.\n\nClone is completely out of our control, and is totally free to panic. If it\ndoes, our function will exit early with the length of the Vec set too large. If\nthe Vec is looked at or dropped, uninitialized memory will be read!\n\nThe fix in this case is fairly simple. If we want to guarantee that the values\nwe *did* clone are dropped, we can set the `len` every loop iteration. If we\njust want to guarantee that uninitialized memory can't be observed, we can set\nthe `len` after the loop.",
      "parent_id": null,
      "paragraphs": {
        "nomicon_vec_push_all_p1": "`Vec::push_all` is a temporary hack to get extending a Vec by a slice reliably\nefficient without specialization. Here's a simple implementation:",
        "nomicon_vec_push_all_p2": "<!-- ignore: simplified code -->\n,ignore\nimpl<T: Clone> Vec<T> {\n    fn push_all(&mut self, to_push: &[T]) {\n        self.reserve(to_push.len());\n        unsafe {\n            // can't overflow because we just reserved this\n            self.set_len(self.len() + to_push.len());",
        "nomicon_vec_push_all_p3": "for (i, x) in to_push.iter().enumerate() {\n                self.ptr().add(i).write(x.clone());\n            }\n        }\n    }\n}",
        "nomicon_vec_push_all_p4": "We bypass `push` in order to avoid redundant capacity and `len` checks on the\nVec that we definitely know has capacity. The logic is totally correct, except\nthere's a subtle problem with our code: it's not exception-safe! `set_len`,\n`add`, and `write` are all fine; `clone` is the panic bomb we over-looked.",
        "nomicon_vec_push_all_p5": "Clone is completely out of our control, and is totally free to panic. If it\ndoes, our function will exit early with the length of the Vec set too large. If\nthe Vec is looked at or dropped, uninitialized memory will be read!",
        "nomicon_vec_push_all_p6": "The fix in this case is fairly simple. If we want to guarantee that the values\nwe *did* clone are dropped, we can set the `len` every loop iteration. If we\njust want to guarantee that uninitialized memory can't be observed, we can set\nthe `len` after the loop."
      }
    },
    {
      "id": "nomicon_binaryheap_sift_up",
      "title": "BinaryHeap::sift_up",
      "level": 2,
      "content": "Bubbling an element up a heap is a bit more complicated than extending a Vec.\nThe pseudocode is as follows:\n\nbubble_up(heap, index):\n    while index != 0 && heap[index] < heap[parent(index)]:\n        heap.swap(index, parent(index))\n        index = parent(index)\n\nA literal transcription of this code to Rust is totally fine, but has an annoying\nperformance characteristic: the `self` element is swapped over and over again\nuselessly. We would rather have the following:\n\nbubble_up(heap, index):\n    let elem = heap[index]\n    while index != 0 && elem < heap[parent(index)]:\n        heap[index] = heap[parent(index)]\n        index = parent(index)\n    heap[index] = elem\n\nThis code ensures that each element is copied as little as possible (it is in\nfact necessary that elem be copied twice in general). However it now exposes\nsome exception safety trouble! At all times, there exists two copies of one\nvalue. If we panic in this function something will be double-dropped.\nUnfortunately, we also don't have full control of the code: that comparison is\nuser-defined!\n\nUnlike Vec, the fix isn't as easy here. One option is to break the user-defined\ncode and the unsafe code into two separate phases:\n\nbubble_up(heap, index):\n    let end_index = index;\n    while end_index != 0 && heap[index] < heap[parent(end_index)]:\n        end_index = parent(end_index)\n\n    let elem = heap[index]\n    while index != end_index:\n        heap[index] = heap[parent(index)]\n        index = parent(index)\n    heap[index] = elem\n\nIf the user-defined code blows up, that's no problem anymore, because we haven't\nactually touched the state of the heap yet. Once we do start messing with the\nheap, we're working with only data and functions that we trust, so there's no\nconcern of panics.\n\nPerhaps you're not happy with this design. Surely it's cheating! And we have\nto do the complex heap traversal *twice*! Alright, let's bite the bullet. Let's\nintermix untrusted and unsafe code *for reals*.\n\nIf Rust had `try` and `finally` like in Java, we could do the following:\n\nbubble_up(heap, index):\n    let elem = heap[index]\n    try:\n \u00a0 \u00a0 \u00a0 \u00a0while index != 0 && elem < heap[parent(index)]:\n            heap[index] = heap[parent(index)]\n            index = parent(index)\n    finally:\n        heap[index] = elem\n\nThe basic idea is simple: if the comparison panics, we just toss the loose\nelement in the logically uninitialized index and bail out. Anyone who observes\nthe heap will see a potentially *inconsistent* heap, but at least it won't\ncause any double-drops! If the algorithm terminates normally, then this\noperation happens to coincide precisely with how we finish up regardless.\n\nSadly, Rust has no such construct, so we're going to need to roll our own! The\nway to do this is to store the algorithm's state in a separate struct with a\ndestructor for the \"finally\" logic. Whether we panic or not, that destructor\nwill run and clean up after us.\n\n<!-- ignore: simplified code -->\n,ignore\nstruct Hole<'a, T: 'a> {\n    data: &'a mut [T],\n    /// `elt` is always `Some` from new until drop.\n    elt: Option<T>,\n    pos: usize,\n}\n\nimpl<'a, T> Hole<'a, T> {\n    fn new(data: &'a mut [T], pos: usize) -> Self {\n        unsafe {\n            let elt = ptr::read(&data[pos]);\n            Hole {\n                data,\n                elt: Some(elt),\n                pos,\n            }\n        }\n    }\n\n    fn pos(&self) -> usize { self.pos }\n\n    fn removed(&self) -> &T { self.elt.as_ref().unwrap() }\n\n    fn get(&self, index: usize) -> &T { &self.data[index] }\n\n    unsafe fn move_to(&mut self, index: usize) {\n        let index_ptr: *const _ = &self.data[index];\n        let hole_ptr = &mut self.data[self.pos];\n        ptr::copy_nonoverlapping(index_ptr, hole_ptr, 1);\n        self.pos = index;\n    }\n}\n\nimpl<'a, T> Drop for Hole<'a, T> {\n    fn drop(&mut self) {\n        // fill the hole again\n        unsafe {\n            let pos = self.pos;\n            ptr::write(&mut self.data[pos], self.elt.take().unwrap());\n        }\n    }\n}\n\nimpl<T: Ord> BinaryHeap<T> {\n    fn sift_up(&mut self, pos: usize) {\n        unsafe {\n            // Take out the value at `pos` and create a hole.\n            let mut hole = Hole::new(&mut self.data, pos);\n\n            while hole.pos() != 0 {\n                let parent = parent(hole.pos());\n                if hole.removed() <= hole.get(parent) { break }\n                hole.move_to(parent);\n            }\n            // Hole will be unconditionally filled here; panic or not!\n        }\n    }\n}",
      "parent_id": null,
      "paragraphs": {
        "nomicon_binaryheap_sift_up_p1": "Bubbling an element up a heap is a bit more complicated than extending a Vec.\nThe pseudocode is as follows:",
        "nomicon_binaryheap_sift_up_p2": "bubble_up(heap, index):\n    while index != 0 && heap[index] < heap[parent(index)]:\n        heap.swap(index, parent(index))\n        index = parent(index)",
        "nomicon_binaryheap_sift_up_p3": "A literal transcription of this code to Rust is totally fine, but has an annoying\nperformance characteristic: the `self` element is swapped over and over again\nuselessly. We would rather have the following:",
        "nomicon_binaryheap_sift_up_p4": "bubble_up(heap, index):\n    let elem = heap[index]\n    while index != 0 && elem < heap[parent(index)]:\n        heap[index] = heap[parent(index)]\n        index = parent(index)\n    heap[index] = elem",
        "nomicon_binaryheap_sift_up_p5": "This code ensures that each element is copied as little as possible (it is in\nfact necessary that elem be copied twice in general). However it now exposes\nsome exception safety trouble! At all times, there exists two copies of one\nvalue. If we panic in this function something will be double-dropped.\nUnfortunately, we also don't have full control of the code: that comparison is\nuser-defined!",
        "nomicon_binaryheap_sift_up_p6": "Unlike Vec, the fix isn't as easy here. One option is to break the user-defined\ncode and the unsafe code into two separate phases:",
        "nomicon_binaryheap_sift_up_p7": "bubble_up(heap, index):\n    let end_index = index;\n    while end_index != 0 && heap[index] < heap[parent(end_index)]:\n        end_index = parent(end_index)",
        "nomicon_binaryheap_sift_up_p8": "let elem = heap[index]\n    while index != end_index:\n        heap[index] = heap[parent(index)]\n        index = parent(index)\n    heap[index] = elem",
        "nomicon_binaryheap_sift_up_p9": "If the user-defined code blows up, that's no problem anymore, because we haven't\nactually touched the state of the heap yet. Once we do start messing with the\nheap, we're working with only data and functions that we trust, so there's no\nconcern of panics.",
        "nomicon_binaryheap_sift_up_p10": "Perhaps you're not happy with this design. Surely it's cheating! And we have\nto do the complex heap traversal *twice*! Alright, let's bite the bullet. Let's\nintermix untrusted and unsafe code *for reals*.",
        "nomicon_binaryheap_sift_up_p11": "If Rust had `try` and `finally` like in Java, we could do the following:",
        "nomicon_binaryheap_sift_up_p12": "bubble_up(heap, index):\n    let elem = heap[index]\n    try:\n \u00a0 \u00a0 \u00a0 \u00a0while index != 0 && elem < heap[parent(index)]:\n            heap[index] = heap[parent(index)]\n            index = parent(index)\n    finally:\n        heap[index] = elem",
        "nomicon_binaryheap_sift_up_p13": "The basic idea is simple: if the comparison panics, we just toss the loose\nelement in the logically uninitialized index and bail out. Anyone who observes\nthe heap will see a potentially *inconsistent* heap, but at least it won't\ncause any double-drops! If the algorithm terminates normally, then this\noperation happens to coincide precisely with how we finish up regardless.",
        "nomicon_binaryheap_sift_up_p14": "Sadly, Rust has no such construct, so we're going to need to roll our own! The\nway to do this is to store the algorithm's state in a separate struct with a\ndestructor for the \"finally\" logic. Whether we panic or not, that destructor\nwill run and clean up after us.",
        "nomicon_binaryheap_sift_up_p15": "<!-- ignore: simplified code -->\n,ignore\nstruct Hole<'a, T: 'a> {\n    data: &'a mut [T],\n    /// `elt` is always `Some` from new until drop.\n    elt: Option<T>,\n    pos: usize,\n}",
        "nomicon_binaryheap_sift_up_p16": "impl<'a, T> Hole<'a, T> {\n    fn new(data: &'a mut [T], pos: usize) -> Self {\n        unsafe {\n            let elt = ptr::read(&data[pos]);\n            Hole {\n                data,\n                elt: Some(elt),\n                pos,\n            }\n        }\n    }",
        "nomicon_binaryheap_sift_up_p17": "fn pos(&self) -> usize { self.pos }",
        "nomicon_binaryheap_sift_up_p18": "fn removed(&self) -> &T { self.elt.as_ref().unwrap() }",
        "nomicon_binaryheap_sift_up_p19": "fn get(&self, index: usize) -> &T { &self.data[index] }",
        "nomicon_binaryheap_sift_up_p20": "unsafe fn move_to(&mut self, index: usize) {\n        let index_ptr: *const _ = &self.data[index];\n        let hole_ptr = &mut self.data[self.pos];\n        ptr::copy_nonoverlapping(index_ptr, hole_ptr, 1);\n        self.pos = index;\n    }\n}",
        "nomicon_binaryheap_sift_up_p21": "impl<'a, T> Drop for Hole<'a, T> {\n    fn drop(&mut self) {\n        // fill the hole again\n        unsafe {\n            let pos = self.pos;\n            ptr::write(&mut self.data[pos], self.elt.take().unwrap());\n        }\n    }\n}",
        "nomicon_binaryheap_sift_up_p22": "impl<T: Ord> BinaryHeap<T> {\n    fn sift_up(&mut self, pos: usize) {\n        unsafe {\n            // Take out the value at `pos` and create a hole.\n            let mut hole = Hole::new(&mut self.data, pos);",
        "nomicon_binaryheap_sift_up_p23": "while hole.pos() != 0 {\n                let parent = parent(hole.pos());\n                if hole.removed() <= hole.get(parent) { break }\n                hole.move_to(parent);\n            }\n            // Hole will be unconditionally filled here; panic or not!\n        }\n    }\n}"
      }
    },
    {
      "id": "nomicon_poisoning",
      "title": "Poisoning",
      "level": 1,
      "content": "Although all unsafe code *must* ensure it has minimal exception safety, not all\ntypes ensure *maximal* exception safety. Even if the type does, your code may\nascribe additional meaning to it. For instance, an integer is certainly\nexception-safe, but has no semantics on its own. It's possible that code that\npanics could fail to correctly update the integer, producing an inconsistent\nprogram state.\n\nThis is *usually* fine, because anything that witnesses an exception is about\nto get destroyed. For instance, if you send a Vec to another thread and that\nthread panics, it doesn't matter if the Vec is in a weird state. It will be\ndropped and go away forever. However some types are especially good at smuggling\nvalues across the panic boundary.\n\nThese types may choose to explicitly *poison* themselves if they witness a panic.\nPoisoning doesn't entail anything in particular. Generally it just means\npreventing normal usage from proceeding. The most notable example of this is the\nstandard library's Mutex type. A Mutex will poison itself if one of its\nMutexGuards (the thing it returns when a lock is obtained) is dropped during a\npanic. Any future attempts to lock the Mutex will return an `Err` or panic.\n\nMutex poisons not for true safety in the sense that Rust normally cares about. It\npoisons as a safety-guard against blindly using the data that comes out of a Mutex\nthat has witnessed a panic while locked. The data in such a Mutex was likely in the\nmiddle of being modified, and as such may be in an inconsistent or incomplete state.\nIt is important to note that one cannot violate memory safety with such a type\nif it is correctly written. After all, it must be minimally exception-safe!\n\nHowever if the Mutex contained, say, a BinaryHeap that does not actually have the\nheap property, it's unlikely that any code that uses it will do\nwhat the author intended. As such, the program should not proceed normally.\nStill, if you're double-plus-sure that you can do *something* with the value,\nthe Mutex exposes a method to get the lock anyway. It *is* safe, after all.\nJust maybe nonsense.",
      "parent_id": null,
      "paragraphs": {
        "nomicon_poisoning_p1": "Although all unsafe code *must* ensure it has minimal exception safety, not all\ntypes ensure *maximal* exception safety. Even if the type does, your code may\nascribe additional meaning to it. For instance, an integer is certainly\nexception-safe, but has no semantics on its own. It's possible that code that\npanics could fail to correctly update the integer, producing an inconsistent\nprogram state.",
        "nomicon_poisoning_p2": "This is *usually* fine, because anything that witnesses an exception is about\nto get destroyed. For instance, if you send a Vec to another thread and that\nthread panics, it doesn't matter if the Vec is in a weird state. It will be\ndropped and go away forever. However some types are especially good at smuggling\nvalues across the panic boundary.",
        "nomicon_poisoning_p3": "These types may choose to explicitly *poison* themselves if they witness a panic.\nPoisoning doesn't entail anything in particular. Generally it just means\npreventing normal usage from proceeding. The most notable example of this is the\nstandard library's Mutex type. A Mutex will poison itself if one of its\nMutexGuards (the thing it returns when a lock is obtained) is dropped during a\npanic. Any future attempts to lock the Mutex will return an `Err` or panic.",
        "nomicon_poisoning_p4": "Mutex poisons not for true safety in the sense that Rust normally cares about. It\npoisons as a safety-guard against blindly using the data that comes out of a Mutex\nthat has witnessed a panic while locked. The data in such a Mutex was likely in the\nmiddle of being modified, and as such may be in an inconsistent or incomplete state.\nIt is important to note that one cannot violate memory safety with such a type\nif it is correctly written. After all, it must be minimally exception-safe!",
        "nomicon_poisoning_p5": "However if the Mutex contained, say, a BinaryHeap that does not actually have the\nheap property, it's unlikely that any code that uses it will do\nwhat the author intended. As such, the program should not proceed normally.\nStill, if you're double-plus-sure that you can do *something* with the value,\nthe Mutex exposes a method to get the lock anyway. It *is* safe, after all.\nJust maybe nonsense."
      }
    }
  ],
  "ids": [
    "nomicon_unwinding_p4",
    "nomicon_binaryheap_sift_up_p22",
    "nomicon_binaryheap_sift_up_p8",
    "nomicon_unwinding",
    "nomicon_binaryheap_sift_up_p13",
    "nomicon_exception_safety_p1",
    "nomicon_vec_push_all",
    "nomicon_unwinding_p3",
    "nomicon_vec_push_all_p2",
    "nomicon_unwinding_p8",
    "nomicon_poisoning_p5",
    "nomicon_binaryheap_sift_up_p15",
    "nomicon_exception_safety_p2",
    "nomicon_poisoning_p1",
    "nomicon_binaryheap_sift_up_p19",
    "nomicon_vec_push_all_p4",
    "nomicon_vec_push_all_p1",
    "nomicon_binaryheap_sift_up_p16",
    "nomicon_binaryheap_sift_up",
    "nomicon_binaryheap_sift_up_p11",
    "nomicon_exception_safety_p6",
    "nomicon_vec_push_all_p3",
    "nomicon_binaryheap_sift_up_p20",
    "nomicon_binaryheap_sift_up_p23",
    "nomicon_exception_safety_p5",
    "nomicon_binaryheap_sift_up_p5",
    "nomicon_binaryheap_sift_up_p6",
    "nomicon_exception_safety_p4",
    "nomicon_binaryheap_sift_up_p3",
    "nomicon_binaryheap_sift_up_p4",
    "nomicon_unwinding_p1",
    "nomicon_binaryheap_sift_up_p17",
    "nomicon_poisoning_p3",
    "nomicon_binaryheap_sift_up_p2",
    "nomicon_unwinding_p6",
    "nomicon_unwinding_p7",
    "nomicon_vec_push_all_p5",
    "nomicon_binaryheap_sift_up_p7",
    "nomicon_vec_push_all_p6",
    "nomicon_binaryheap_sift_up_p12",
    "nomicon_exception_safety",
    "nomicon_poisoning_p2",
    "nomicon_binaryheap_sift_up_p14",
    "nomicon_binaryheap_sift_up_p9",
    "nomicon_poisoning",
    "nomicon_unwinding_p2",
    "nomicon_binaryheap_sift_up_p10",
    "nomicon_poisoning_p4",
    "nomicon_unwinding_p5",
    "nomicon_binaryheap_sift_up_p21",
    "nomicon_unwinding_p9",
    "nomicon_binaryheap_sift_up_p1",
    "nomicon_exception_safety_p3",
    "nomicon_binaryheap_sift_up_p18"
  ]
}
