{
  "source": "Rustonomicon",
  "source_repo": "https://github.com/rust-lang/nomicon",
  "extraction_date": "2026-01-03",
  "chapter": 6,
  "title": "Uninitialized Memory",
  "file": "uninitialized.md",
  "sections": [
    {
      "id": "nomicon_working_with_uninitialized_memory",
      "title": "Working With Uninitialized Memory",
      "level": 1,
      "content": "All runtime-allocated memory in a Rust program begins its life as\n*uninitialized*. In this state the value of the memory is an indeterminate pile\nof bits that may or may not even reflect a valid state for the type that is\nsupposed to inhabit that location of memory. Attempting to interpret this memory\nas a value of *any* type will cause Undefined Behavior. Do Not Do This.\n\nRust provides mechanisms to work with uninitialized memory in checked (safe) and\nunchecked (unsafe) ways.",
      "parent_id": null,
      "paragraphs": {
        "nomicon_working_with_uninitialized_memory_p1": "All runtime-allocated memory in a Rust program begins its life as\n*uninitialized*. In this state the value of the memory is an indeterminate pile\nof bits that may or may not even reflect a valid state for the type that is\nsupposed to inhabit that location of memory. Attempting to interpret this memory\nas a value of *any* type will cause Undefined Behavior. Do Not Do This.",
        "nomicon_working_with_uninitialized_memory_p2": "Rust provides mechanisms to work with uninitialized memory in checked (safe) and\nunchecked (unsafe) ways."
      }
    },
    {
      "id": "nomicon_checked_uninitialized_memory",
      "title": "Checked Uninitialized Memory",
      "level": 1,
      "content": "Like C, all stack variables in Rust are uninitialized until a value is\nexplicitly assigned to them. Unlike C, Rust statically prevents you from ever\nreading them until you do:\n\n,compile_fail\nfn main() {\n    let x: i32;\n    println!(\"{}\", x);\n}\n\n  |\n3 |     println!(\"{}\", x);\n  |                    ^ use of possibly uninitialized `x`\n\nThis is based off of a basic branch analysis: every branch must assign a value\nto `x` before it is first used. For short, we also say that \"`x` is init\" or\n\"`x` is uninit\".\n\nInterestingly, Rust doesn't require the variable\nto be mutable to perform a delayed initialization if every branch assigns\nexactly once. However the analysis does not take advantage of constant analysis\nor anything like that. So this compiles:\n\nfn main() {\n    let x: i32;\n\n    if true {\n        x = 1;\n    } else {\n        x = 2;\n    }\n\n    println!(\"{}\", x);\n}\n\nbut this doesn't:\n\n,compile_fail\nfn main() {\n    let x: i32;\n    if true {\n        x = 1;\n    }\n    println!(\"{}\", x);\n}\n\n  |\n6 |     println!(\"{}\", x);\n  |                    ^ use of possibly uninitialized `x`\n\nwhile this does:\n\nfn main() {\n    let x: i32;\n    if true {\n        x = 1;\n        println!(\"{}\", x);\n    }\n    // Don't care that there are branches where it's not initialized\n    // since we don't use the value in those branches\n}\n\nOf course, while the analysis doesn't consider actual values, it does\nhave a relatively sophisticated understanding of dependencies and control\nflow. For instance, this works:\n\nlet x: i32;\n\nloop {\n    // Rust doesn't understand that this branch will be taken unconditionally,\n    // because it relies on actual values.\n    if true {\n        // But it does understand that it will only be taken once because\n        // we unconditionally break out of it. Therefore `x` doesn't\n        // need to be marked as mutable.\n        x = 0;\n        break;\n    }\n}\n// It also knows that it's impossible to get here without reaching the break.\n// And therefore that `x` must be initialized here!\nprintln!(\"{}\", x);\n\nIf a value is moved out of a variable, that variable becomes logically\nuninitialized if the type of the value isn't Copy. That is:\n\nfn main() {\n    let x = 0;\n    let y = Box::new(0);\n    let z1 = x; // x is still valid because i32 is Copy\n    let z2 = y; // y is now logically uninitialized because Box isn't Copy\n}\n\nHowever reassigning `y` in this example *would* require `y` to be marked as\nmutable, as a Safe Rust program could observe that the value of `y` changed:\n\nfn main() {\n    let mut y = Box::new(0);\n    let z = y; // y is now logically uninitialized because Box isn't Copy\n    y = Box::new(1); // reinitialize y\n}\n\nOtherwise it's like `y` is a brand new variable.",
      "parent_id": null,
      "paragraphs": {
        "nomicon_checked_uninitialized_memory_p1": "Like C, all stack variables in Rust are uninitialized until a value is\nexplicitly assigned to them. Unlike C, Rust statically prevents you from ever\nreading them until you do:",
        "nomicon_checked_uninitialized_memory_p2": ",compile_fail\nfn main() {\n    let x: i32;\n    println!(\"{}\", x);\n}",
        "nomicon_checked_uninitialized_memory_p3": "|\n3 |     println!(\"{}\", x);\n  |                    ^ use of possibly uninitialized `x`",
        "nomicon_checked_uninitialized_memory_p4": "This is based off of a basic branch analysis: every branch must assign a value\nto `x` before it is first used. For short, we also say that \"`x` is init\" or\n\"`x` is uninit\".",
        "nomicon_checked_uninitialized_memory_p5": "Interestingly, Rust doesn't require the variable\nto be mutable to perform a delayed initialization if every branch assigns\nexactly once. However the analysis does not take advantage of constant analysis\nor anything like that. So this compiles:",
        "nomicon_checked_uninitialized_memory_p6": "fn main() {\n    let x: i32;",
        "nomicon_checked_uninitialized_memory_p7": "if true {\n        x = 1;\n    } else {\n        x = 2;\n    }",
        "nomicon_checked_uninitialized_memory_p8": "println!(\"{}\", x);\n}",
        "nomicon_checked_uninitialized_memory_p9": "but this doesn't:",
        "nomicon_checked_uninitialized_memory_p10": ",compile_fail\nfn main() {\n    let x: i32;\n    if true {\n        x = 1;\n    }\n    println!(\"{}\", x);\n}",
        "nomicon_checked_uninitialized_memory_p11": "|\n6 |     println!(\"{}\", x);\n  |                    ^ use of possibly uninitialized `x`",
        "nomicon_checked_uninitialized_memory_p12": "while this does:",
        "nomicon_checked_uninitialized_memory_p13": "fn main() {\n    let x: i32;\n    if true {\n        x = 1;\n        println!(\"{}\", x);\n    }\n    // Don't care that there are branches where it's not initialized\n    // since we don't use the value in those branches\n}",
        "nomicon_checked_uninitialized_memory_p14": "Of course, while the analysis doesn't consider actual values, it does\nhave a relatively sophisticated understanding of dependencies and control\nflow. For instance, this works:",
        "nomicon_checked_uninitialized_memory_p15": "let x: i32;",
        "nomicon_checked_uninitialized_memory_p16": "loop {\n    // Rust doesn't understand that this branch will be taken unconditionally,\n    // because it relies on actual values.\n    if true {\n        // But it does understand that it will only be taken once because\n        // we unconditionally break out of it. Therefore `x` doesn't\n        // need to be marked as mutable.\n        x = 0;\n        break;\n    }\n}\n// It also knows that it's impossible to get here without reaching the break.\n// And therefore that `x` must be initialized here!\nprintln!(\"{}\", x);",
        "nomicon_checked_uninitialized_memory_p17": "If a value is moved out of a variable, that variable becomes logically\nuninitialized if the type of the value isn't Copy. That is:",
        "nomicon_checked_uninitialized_memory_p18": "fn main() {\n    let x = 0;\n    let y = Box::new(0);\n    let z1 = x; // x is still valid because i32 is Copy\n    let z2 = y; // y is now logically uninitialized because Box isn't Copy\n}",
        "nomicon_checked_uninitialized_memory_p19": "However reassigning `y` in this example *would* require `y` to be marked as\nmutable, as a Safe Rust program could observe that the value of `y` changed:",
        "nomicon_checked_uninitialized_memory_p20": "fn main() {\n    let mut y = Box::new(0);\n    let z = y; // y is now logically uninitialized because Box isn't Copy\n    y = Box::new(1); // reinitialize y\n}",
        "nomicon_checked_uninitialized_memory_p21": "Otherwise it's like `y` is a brand new variable."
      }
    },
    {
      "id": "nomicon_drop_flags",
      "title": "Drop Flags",
      "level": 1,
      "content": "The examples in the previous section introduce an interesting problem for Rust.\nWe have seen that it's possible to conditionally initialize, deinitialize, and\nreinitialize locations of memory totally safely. For Copy types, this isn't\nparticularly notable since they're just a random pile of bits. However types\nwith destructors are a different story: Rust needs to know whether to call a\ndestructor whenever a variable is assigned to, or a variable goes out of scope.\nHow can it do this with conditional initialization?\n\nNote that this is not a problem that all assignments need worry about. In\nparticular, assigning through a dereference unconditionally drops, and assigning\nin a `let` unconditionally doesn't drop:\n\nlet mut x = Box::new(0); // let makes a fresh variable, so never need to drop\nlet y = &mut x;\n*y = Box::new(1); // Deref assumes the referent is initialized, so always drops\n\nThis is only a problem when overwriting a previously initialized variable or\none of its subfields.\n\nIt turns out that Rust actually tracks whether a type should be dropped or not\n*at runtime*. As a variable becomes initialized and uninitialized, a *drop flag*\nfor that variable is toggled. When a variable might need to be dropped, this\nflag is evaluated to determine if it should be dropped.\n\nOf course, it is often the case that a value's initialization state can be\nstatically known at every point in the program. If this is the case, then the\ncompiler can theoretically generate more efficient code! For instance, straight-\nline code has such *static drop semantics*:\n\nlet mut x = Box::new(0); // x was uninit; just overwrite.\nlet mut y = x;           // y was uninit; just overwrite and make x uninit.\nx = Box::new(0);         // x was uninit; just overwrite.\ny = x;                   // y was init; Drop y, overwrite it, and make x uninit!\n                         // y goes out of scope; y was init; Drop y!\n                         // x goes out of scope; x was uninit; do nothing.\n\nSimilarly, branched code where all branches have the same behavior with respect\nto initialization has static drop semantics:",
      "parent_id": null,
      "paragraphs": {
        "nomicon_drop_flags_p1": "The examples in the previous section introduce an interesting problem for Rust.\nWe have seen that it's possible to conditionally initialize, deinitialize, and\nreinitialize locations of memory totally safely. For Copy types, this isn't\nparticularly notable since they're just a random pile of bits. However types\nwith destructors are a different story: Rust needs to know whether to call a\ndestructor whenever a variable is assigned to, or a variable goes out of scope.\nHow can it do this with conditional initialization?",
        "nomicon_drop_flags_p2": "Note that this is not a problem that all assignments need worry about. In\nparticular, assigning through a dereference unconditionally drops, and assigning\nin a `let` unconditionally doesn't drop:",
        "nomicon_drop_flags_p3": "let mut x = Box::new(0); // let makes a fresh variable, so never need to drop\nlet y = &mut x;\n*y = Box::new(1); // Deref assumes the referent is initialized, so always drops",
        "nomicon_drop_flags_p4": "This is only a problem when overwriting a previously initialized variable or\none of its subfields.",
        "nomicon_drop_flags_p5": "It turns out that Rust actually tracks whether a type should be dropped or not\n*at runtime*. As a variable becomes initialized and uninitialized, a *drop flag*\nfor that variable is toggled. When a variable might need to be dropped, this\nflag is evaluated to determine if it should be dropped.",
        "nomicon_drop_flags_p6": "Of course, it is often the case that a value's initialization state can be\nstatically known at every point in the program. If this is the case, then the\ncompiler can theoretically generate more efficient code! For instance, straight-\nline code has such *static drop semantics*:",
        "nomicon_drop_flags_p7": "let mut x = Box::new(0); // x was uninit; just overwrite.\nlet mut y = x;           // y was uninit; just overwrite and make x uninit.\nx = Box::new(0);         // x was uninit; just overwrite.\ny = x;                   // y was init; Drop y, overwrite it, and make x uninit!\n                         // y goes out of scope; y was init; Drop y!\n                         // x goes out of scope; x was uninit; do nothing.",
        "nomicon_drop_flags_p8": "Similarly, branched code where all branches have the same behavior with respect\nto initialization has static drop semantics:",
        "nomicon_drop_flags_p9": ""
      }
    },
    {
      "id": "nomicon_let_condition_true",
      "title": "let condition = true;",
      "level": 1,
      "content": "let mut x = Box::new(0);    // x was uninit; just overwrite.\nif condition {\n    drop(x)                 // x gets moved out; make x uninit.\n} else {\n    println!(\"{}\", x);\n    drop(x)                 // x gets moved out; make x uninit.\n}\nx = Box::new(0);            // x was uninit; just overwrite.\n                            // x goes out of scope; x was init; Drop x!\n\nHowever code like this *requires* runtime information to correctly Drop:",
      "parent_id": null,
      "paragraphs": {
        "nomicon_let_condition_true_p1": "let mut x = Box::new(0);    // x was uninit; just overwrite.\nif condition {\n    drop(x)                 // x gets moved out; make x uninit.\n} else {\n    println!(\"{}\", x);\n    drop(x)                 // x gets moved out; make x uninit.\n}\nx = Box::new(0);            // x was uninit; just overwrite.\n                            // x goes out of scope; x was init; Drop x!",
        "nomicon_let_condition_true_p2": "However code like this *requires* runtime information to correctly Drop:",
        "nomicon_let_condition_true_p3": ""
      }
    },
    {
      "id": "nomicon_let_condition_true",
      "title": "let condition = true;",
      "level": 1,
      "content": "let x;\nif condition {\n    x = Box::new(0);        // x was uninit; just overwrite.\n    println!(\"{}\", x);\n}\n                            // x goes out of scope; x might be uninit;\n                            // check the flag!\n\nOf course, in this case it's trivial to retrieve static drop semantics:",
      "parent_id": null,
      "paragraphs": {
        "nomicon_let_condition_true_p1": "let x;\nif condition {\n    x = Box::new(0);        // x was uninit; just overwrite.\n    println!(\"{}\", x);\n}\n                            // x goes out of scope; x might be uninit;\n                            // check the flag!",
        "nomicon_let_condition_true_p2": "Of course, in this case it's trivial to retrieve static drop semantics:",
        "nomicon_let_condition_true_p3": ""
      }
    },
    {
      "id": "nomicon_let_condition_true",
      "title": "let condition = true;",
      "level": 1,
      "content": "if condition {\n    let x = Box::new(0);\n    println!(\"{}\", x);\n}\n\nThe drop flags are tracked on the stack.\nIn old Rust versions, drop flags were stashed in a hidden field of types that implement `Drop`.",
      "parent_id": null,
      "paragraphs": {
        "nomicon_let_condition_true_p1": "if condition {\n    let x = Box::new(0);\n    println!(\"{}\", x);\n}",
        "nomicon_let_condition_true_p2": "The drop flags are tracked on the stack.\nIn old Rust versions, drop flags were stashed in a hidden field of types that implement `Drop`."
      }
    },
    {
      "id": "nomicon_unchecked_uninitialized_memory",
      "title": "Unchecked Uninitialized Memory",
      "level": 1,
      "content": "One interesting exception to this rule is working with arrays. Safe Rust doesn't\npermit you to partially initialize an array. When you initialize an array, you\ncan either set every value to the same thing with `let x = [val; N]`, or you can\nspecify each member individually with `let x = [val1, val2, val3]`.\nUnfortunately this is pretty rigid, especially if you need to initialize your\narray in a more incremental or dynamic way.\n\nUnsafe Rust gives us a powerful tool to handle this problem:\n[`MaybeUninit`]. This type can be used to handle memory that has not been fully\ninitialized yet.\n\nWith `MaybeUninit`, we can initialize an array element by element as follows:\n\nuse std::mem::{self, MaybeUninit};\n\n// Size of the array is hard-coded but easy to change (meaning, changing just\n// the constant is sufficient). This means we can't use [a, b, c] syntax to\n// initialize the array, though, as we would have to keep that in sync\n// with `SIZE`!\nconst SIZE: usize = 10;\n\nlet x = {\n    // Create an uninitialized array of `MaybeUninit`.\n    let mut x = [const { MaybeUninit::uninit() }; SIZE];\n\n    // Dropping a `MaybeUninit` does nothing. Thus using raw pointer\n    // assignment instead of `ptr::write` does not cause the old\n    // uninitialized value to be dropped.\n    // Exception safety is not a concern because Box can't panic\n    for i in 0..SIZE {\n        x[i] = MaybeUninit::new(Box::new(i as u32));\n    }\n\n    // Everything is initialized. Transmute the array to the\n    // initialized type.\n    unsafe { mem::transmute::<_, [Box<u32>; SIZE]>(x) }\n};\n\nprintln!(\"{x:?}\");\n\nThis code proceeds in three steps:\n\n1. Create an array of `MaybeUninit<T>`.\n\n2. Initialize the array. The subtle aspect of this is that usually, when we use\n   `=` to assign to a value that the Rust type checker considers to already be\n   initialized (like `x[i]`), the old value stored on the left-hand side gets\n   dropped. This would be a disaster. However, in this case, the type of the\n   left-hand side is `MaybeUninit<Box<u32>>`, and dropping that does not do\n   anything! See below for some more discussion of this `drop` issue.\n\n3. Finally, we have to change the type of our array to remove the\n   `MaybeUninit`. With current stable Rust, this requires a `transmute`.\n   This transmute is legal because in memory, `MaybeUninit<T>` looks the same as `T`.\n\n    However, note that in general, `Container<MaybeUninit<T>>>` does *not* look\n   the same as `Container<T>`! Imagine if `Container` was `Option`, and `T` was\n   `bool`, then `Option<bool>` exploits that `bool` only has two valid values,\n   but `Option<MaybeUninit<bool>>` cannot do that because the `bool` does not\n   have to be initialized.\n\n    So, it depends on `Container` whether transmuting away the `MaybeUninit` is\n   allowed. For arrays, it is (and eventually the standard library will\n   acknowledge that by providing appropriate methods).\n\nIt's worth spending a bit more time on the loop in the middle, and in particular\nthe assignment operator and its interaction with `drop`. If we wrote something like:\n\n<!-- ignore: simplified code -->\n,ignore\n*x[i].as_mut_ptr() = Box::new(i as u32); // WRONG!\n\nwe would actually overwrite a `Box<u32>`, leading to `drop` of uninitialized\ndata, which would cause much sadness and pain.\n\nThe correct alternative, if for some reason we cannot use `MaybeUninit::new`, is\nto use the [`ptr`] module. In particular, it provides three functions that allow\nus to assign bytes to a location in memory without dropping the old value:\n[`write`], [`copy`], and [`copy_nonoverlapping`].\n\n* `ptr::write(ptr, val)` takes a `val` and moves it into the address pointed\n  to by `ptr`.\n* `ptr::copy(src, dest, count)` copies the bits that `count` T items would occupy\n  from src to dest. (this is equivalent to C's memmove -- note that the argument\n  order is reversed!)\n* `ptr::copy_nonoverlapping(src, dest, count)` does what `copy` does, but a\n  little faster on the assumption that the two ranges of memory don't overlap.\n  (this is equivalent to C's memcpy -- note that the argument order is reversed!)\n\nIt should go without saying that these functions, if misused, will cause serious\nhavoc or just straight up Undefined Behavior. The only requirement of these\nfunctions *themselves* is that the locations you want to read and write\nare allocated and properly aligned. However, the ways writing arbitrary bits to\narbitrary locations of memory can break things are basically uncountable!\n\nIt's worth noting that you don't need to worry about `ptr::write`-style\nshenanigans with types which don't implement `Drop` or contain `Drop` types,\nbecause Rust knows not to try to drop them. This is what we relied on in the\nabove example.\n\nHowever when working with uninitialized memory you need to be ever-vigilant for\nRust trying to drop values you make like this before they're fully initialized.\nEvery control path through that variable's scope must initialize the value\nbefore it ends, if it has a destructor.\n*This includes code panicking*. `MaybeUninit` helps a bit\nhere, because it does not implicitly drop its content - but all this really\nmeans in case of a panic is that instead of a double-free of the not yet\ninitialized parts, you end up with a memory leak of the already initialized\nparts.\n\nNote that, to use the `ptr` methods, you need to first obtain a *raw pointer* to\nthe data you want to initialize. It is illegal to construct a *reference* to\nuninitialized data, which implies that you have to be careful when obtaining\nsaid raw pointer:\n\n* For an array of `T`, you can use `base_ptr.add(idx)` where `base_ptr: *mut T`\nto compute the address of array index `idx`. This relies on\nhow arrays are laid out in memory.\n* For a struct, however, in general we do not know how it is laid out, and we\nalso cannot use `&mut base_ptr.field` as that would be creating a\nreference. So, you must carefully use the raw reference syntax. This creates\na raw pointer to the field without creating an intermediate reference:\n\nuse std::{ptr, mem::MaybeUninit};\n\nstruct Demo {\n    field: bool,\n}\n\nlet mut uninit = MaybeUninit::<Demo>::uninit();\n// `&uninit.as_mut().field` would create a reference to an uninitialized `bool`,\n// and thus be Undefined Behavior!\nlet f1_ptr = unsafe { &raw mut (*uninit.as_mut_ptr()).field };\nunsafe { f1_ptr.write(true); }\n\nlet init = unsafe { uninit.assume_init() };\n\nOne last remark: when reading old Rust code, you might stumble upon the\ndeprecated `mem::uninitialized` function.  That function used to be the only way\nto deal with uninitialized memory on the stack, but it turned out to be\nimpossible to properly integrate with the rest of the language.  Always use\n`MaybeUninit` instead in new code, and port old code over when you get the\nopportunity.\n\nAnd that's about it for working with uninitialized memory! Basically nothing\nanywhere expects to be handed uninitialized memory, so if you're going to pass\nit around at all, be sure to be *really* careful.\n\n[`MaybeUninit`]: ../core/mem/union.MaybeUninit.html\n[`ptr`]: ../core/ptr/index.html\n[raw_reference]: ../reference/types/pointer.html#r-type.pointer.raw.constructor\n[`write`]: ../core/ptr/fn.write.html\n[`copy`]: ../std/ptr/fn.copy.html\n[`copy_nonoverlapping`]: ../std/ptr/fn.copy_nonoverlapping.html",
      "parent_id": null,
      "paragraphs": {
        "nomicon_unchecked_uninitialized_memory_p1": "One interesting exception to this rule is working with arrays. Safe Rust doesn't\npermit you to partially initialize an array. When you initialize an array, you\ncan either set every value to the same thing with `let x = [val; N]`, or you can\nspecify each member individually with `let x = [val1, val2, val3]`.\nUnfortunately this is pretty rigid, especially if you need to initialize your\narray in a more incremental or dynamic way.",
        "nomicon_unchecked_uninitialized_memory_p2": "Unsafe Rust gives us a powerful tool to handle this problem:\n[`MaybeUninit`]. This type can be used to handle memory that has not been fully\ninitialized yet.",
        "nomicon_unchecked_uninitialized_memory_p3": "With `MaybeUninit`, we can initialize an array element by element as follows:",
        "nomicon_unchecked_uninitialized_memory_p4": "use std::mem::{self, MaybeUninit};",
        "nomicon_unchecked_uninitialized_memory_p5": "// Size of the array is hard-coded but easy to change (meaning, changing just\n// the constant is sufficient). This means we can't use [a, b, c] syntax to\n// initialize the array, though, as we would have to keep that in sync\n// with `SIZE`!\nconst SIZE: usize = 10;",
        "nomicon_unchecked_uninitialized_memory_p6": "let x = {\n    // Create an uninitialized array of `MaybeUninit`.\n    let mut x = [const { MaybeUninit::uninit() }; SIZE];",
        "nomicon_unchecked_uninitialized_memory_p7": "// Dropping a `MaybeUninit` does nothing. Thus using raw pointer\n    // assignment instead of `ptr::write` does not cause the old\n    // uninitialized value to be dropped.\n    // Exception safety is not a concern because Box can't panic\n    for i in 0..SIZE {\n        x[i] = MaybeUninit::new(Box::new(i as u32));\n    }",
        "nomicon_unchecked_uninitialized_memory_p8": "// Everything is initialized. Transmute the array to the\n    // initialized type.\n    unsafe { mem::transmute::<_, [Box<u32>; SIZE]>(x) }\n};",
        "nomicon_unchecked_uninitialized_memory_p9": "println!(\"{x:?}\");",
        "nomicon_unchecked_uninitialized_memory_p10": "This code proceeds in three steps:",
        "nomicon_unchecked_uninitialized_memory_p11": "1. Create an array of `MaybeUninit<T>`.",
        "nomicon_unchecked_uninitialized_memory_p12": "2. Initialize the array. The subtle aspect of this is that usually, when we use\n   `=` to assign to a value that the Rust type checker considers to already be\n   initialized (like `x[i]`), the old value stored on the left-hand side gets\n   dropped. This would be a disaster. However, in this case, the type of the\n   left-hand side is `MaybeUninit<Box<u32>>`, and dropping that does not do\n   anything! See below for some more discussion of this `drop` issue.",
        "nomicon_unchecked_uninitialized_memory_p13": "3. Finally, we have to change the type of our array to remove the\n   `MaybeUninit`. With current stable Rust, this requires a `transmute`.\n   This transmute is legal because in memory, `MaybeUninit<T>` looks the same as `T`.",
        "nomicon_unchecked_uninitialized_memory_p14": "However, note that in general, `Container<MaybeUninit<T>>>` does *not* look\n   the same as `Container<T>`! Imagine if `Container` was `Option`, and `T` was\n   `bool`, then `Option<bool>` exploits that `bool` only has two valid values,\n   but `Option<MaybeUninit<bool>>` cannot do that because the `bool` does not\n   have to be initialized.",
        "nomicon_unchecked_uninitialized_memory_p15": "So, it depends on `Container` whether transmuting away the `MaybeUninit` is\n   allowed. For arrays, it is (and eventually the standard library will\n   acknowledge that by providing appropriate methods).",
        "nomicon_unchecked_uninitialized_memory_p16": "It's worth spending a bit more time on the loop in the middle, and in particular\nthe assignment operator and its interaction with `drop`. If we wrote something like:",
        "nomicon_unchecked_uninitialized_memory_p17": "<!-- ignore: simplified code -->\n,ignore\n*x[i].as_mut_ptr() = Box::new(i as u32); // WRONG!",
        "nomicon_unchecked_uninitialized_memory_p18": "we would actually overwrite a `Box<u32>`, leading to `drop` of uninitialized\ndata, which would cause much sadness and pain.",
        "nomicon_unchecked_uninitialized_memory_p19": "The correct alternative, if for some reason we cannot use `MaybeUninit::new`, is\nto use the [`ptr`] module. In particular, it provides three functions that allow\nus to assign bytes to a location in memory without dropping the old value:\n[`write`], [`copy`], and [`copy_nonoverlapping`].",
        "nomicon_unchecked_uninitialized_memory_p20": "* `ptr::write(ptr, val)` takes a `val` and moves it into the address pointed\n  to by `ptr`.\n* `ptr::copy(src, dest, count)` copies the bits that `count` T items would occupy\n  from src to dest. (this is equivalent to C's memmove -- note that the argument\n  order is reversed!)\n* `ptr::copy_nonoverlapping(src, dest, count)` does what `copy` does, but a\n  little faster on the assumption that the two ranges of memory don't overlap.\n  (this is equivalent to C's memcpy -- note that the argument order is reversed!)",
        "nomicon_unchecked_uninitialized_memory_p21": "It should go without saying that these functions, if misused, will cause serious\nhavoc or just straight up Undefined Behavior. The only requirement of these\nfunctions *themselves* is that the locations you want to read and write\nare allocated and properly aligned. However, the ways writing arbitrary bits to\narbitrary locations of memory can break things are basically uncountable!",
        "nomicon_unchecked_uninitialized_memory_p22": "It's worth noting that you don't need to worry about `ptr::write`-style\nshenanigans with types which don't implement `Drop` or contain `Drop` types,\nbecause Rust knows not to try to drop them. This is what we relied on in the\nabove example.",
        "nomicon_unchecked_uninitialized_memory_p23": "However when working with uninitialized memory you need to be ever-vigilant for\nRust trying to drop values you make like this before they're fully initialized.\nEvery control path through that variable's scope must initialize the value\nbefore it ends, if it has a destructor.\n*This includes code panicking*. `MaybeUninit` helps a bit\nhere, because it does not implicitly drop its content - but all this really\nmeans in case of a panic is that instead of a double-free of the not yet\ninitialized parts, you end up with a memory leak of the already initialized\nparts.",
        "nomicon_unchecked_uninitialized_memory_p24": "Note that, to use the `ptr` methods, you need to first obtain a *raw pointer* to\nthe data you want to initialize. It is illegal to construct a *reference* to\nuninitialized data, which implies that you have to be careful when obtaining\nsaid raw pointer:",
        "nomicon_unchecked_uninitialized_memory_p25": "* For an array of `T`, you can use `base_ptr.add(idx)` where `base_ptr: *mut T`\nto compute the address of array index `idx`. This relies on\nhow arrays are laid out in memory.\n* For a struct, however, in general we do not know how it is laid out, and we\nalso cannot use `&mut base_ptr.field` as that would be creating a\nreference. So, you must carefully use the raw reference syntax. This creates\na raw pointer to the field without creating an intermediate reference:",
        "nomicon_unchecked_uninitialized_memory_p26": "use std::{ptr, mem::MaybeUninit};",
        "nomicon_unchecked_uninitialized_memory_p27": "struct Demo {\n    field: bool,\n}",
        "nomicon_unchecked_uninitialized_memory_p28": "let mut uninit = MaybeUninit::<Demo>::uninit();\n// `&uninit.as_mut().field` would create a reference to an uninitialized `bool`,\n// and thus be Undefined Behavior!\nlet f1_ptr = unsafe { &raw mut (*uninit.as_mut_ptr()).field };\nunsafe { f1_ptr.write(true); }",
        "nomicon_unchecked_uninitialized_memory_p29": "let init = unsafe { uninit.assume_init() };",
        "nomicon_unchecked_uninitialized_memory_p30": "One last remark: when reading old Rust code, you might stumble upon the\ndeprecated `mem::uninitialized` function.  That function used to be the only way\nto deal with uninitialized memory on the stack, but it turned out to be\nimpossible to properly integrate with the rest of the language.  Always use\n`MaybeUninit` instead in new code, and port old code over when you get the\nopportunity.",
        "nomicon_unchecked_uninitialized_memory_p31": "And that's about it for working with uninitialized memory! Basically nothing\nanywhere expects to be handed uninitialized memory, so if you're going to pass\nit around at all, be sure to be *really* careful.",
        "nomicon_unchecked_uninitialized_memory_p32": "[`MaybeUninit`]: ../core/mem/union.MaybeUninit.html\n[`ptr`]: ../core/ptr/index.html\n[raw_reference]: ../reference/types/pointer.html#r-type.pointer.raw.constructor\n[`write`]: ../core/ptr/fn.write.html\n[`copy`]: ../std/ptr/fn.copy.html\n[`copy_nonoverlapping`]: ../std/ptr/fn.copy_nonoverlapping.html"
      }
    }
  ],
  "ids": [
    "nomicon_unchecked_uninitialized_memory_p23",
    "nomicon_drop_flags_p3",
    "nomicon_let_condition_true_p3",
    "nomicon_checked_uninitialized_memory_p13",
    "nomicon_unchecked_uninitialized_memory_p15",
    "nomicon_unchecked_uninitialized_memory_p3",
    "nomicon_unchecked_uninitialized_memory_p32",
    "nomicon_checked_uninitialized_memory_p3",
    "nomicon_unchecked_uninitialized_memory_p31",
    "nomicon_checked_uninitialized_memory_p1",
    "nomicon_unchecked_uninitialized_memory_p13",
    "nomicon_checked_uninitialized_memory_p9",
    "nomicon_unchecked_uninitialized_memory_p30",
    "nomicon_unchecked_uninitialized_memory_p7",
    "nomicon_unchecked_uninitialized_memory_p12",
    "nomicon_checked_uninitialized_memory_p11",
    "nomicon_checked_uninitialized_memory_p7",
    "nomicon_unchecked_uninitialized_memory_p9",
    "nomicon_working_with_uninitialized_memory_p2",
    "nomicon_drop_flags_p5",
    "nomicon_let_condition_true_p1",
    "nomicon_unchecked_uninitialized_memory_p14",
    "nomicon_unchecked_uninitialized_memory_p2",
    "nomicon_drop_flags_p9",
    "nomicon_drop_flags",
    "nomicon_unchecked_uninitialized_memory_p17",
    "nomicon_unchecked_uninitialized_memory_p22",
    "nomicon_unchecked_uninitialized_memory_p24",
    "nomicon_drop_flags_p8",
    "nomicon_unchecked_uninitialized_memory_p5",
    "nomicon_checked_uninitialized_memory_p8",
    "nomicon_unchecked_uninitialized_memory_p25",
    "nomicon_checked_uninitialized_memory_p12",
    "nomicon_unchecked_uninitialized_memory_p28",
    "nomicon_unchecked_uninitialized_memory_p20",
    "nomicon_unchecked_uninitialized_memory_p6",
    "nomicon_checked_uninitialized_memory_p19",
    "nomicon_checked_uninitialized_memory",
    "nomicon_working_with_uninitialized_memory_p1",
    "nomicon_unchecked_uninitialized_memory_p19",
    "nomicon_let_condition_true_p2",
    "nomicon_checked_uninitialized_memory_p4",
    "nomicon_drop_flags_p6",
    "nomicon_unchecked_uninitialized_memory_p1",
    "nomicon_working_with_uninitialized_memory",
    "nomicon_unchecked_uninitialized_memory_p8",
    "nomicon_unchecked_uninitialized_memory_p18",
    "nomicon_checked_uninitialized_memory_p20",
    "nomicon_drop_flags_p1",
    "nomicon_drop_flags_p2",
    "nomicon_unchecked_uninitialized_memory_p26",
    "nomicon_unchecked_uninitialized_memory_p11",
    "nomicon_unchecked_uninitialized_memory_p27",
    "nomicon_unchecked_uninitialized_memory_p10",
    "nomicon_checked_uninitialized_memory_p10",
    "nomicon_drop_flags_p4",
    "nomicon_unchecked_uninitialized_memory_p29",
    "nomicon_checked_uninitialized_memory_p15",
    "nomicon_unchecked_uninitialized_memory_p4",
    "nomicon_checked_uninitialized_memory_p5",
    "nomicon_checked_uninitialized_memory_p21",
    "nomicon_unchecked_uninitialized_memory_p16",
    "nomicon_let_condition_true",
    "nomicon_checked_uninitialized_memory_p14",
    "nomicon_checked_uninitialized_memory_p16",
    "nomicon_checked_uninitialized_memory_p18",
    "nomicon_unchecked_uninitialized_memory",
    "nomicon_drop_flags_p7",
    "nomicon_checked_uninitialized_memory_p6",
    "nomicon_checked_uninitialized_memory_p2",
    "nomicon_unchecked_uninitialized_memory_p21",
    "nomicon_checked_uninitialized_memory_p17"
  ]
}
