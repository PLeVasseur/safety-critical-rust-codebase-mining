{
  "source": "Rustonomicon",
  "source_repo": "https://github.com/rust-lang/nomicon",
  "extraction_date": "2026-01-03",
  "chapter": 4,
  "title": "Ownership",
  "file": "ownership.md",
  "sections": [
    {
      "id": "nomicon_ownership_and_lifetimes",
      "title": "Ownership and Lifetimes",
      "level": 1,
      "content": "Ownership is the breakout feature of Rust. It allows Rust to be completely\nmemory-safe and efficient, while avoiding garbage collection. Before getting\ninto the ownership system in detail, we will consider the motivation of this\ndesign.\n\nWe will assume that you accept that garbage collection (GC) is not always an\noptimal solution, and that it is desirable to manually manage memory in some\ncontexts. If you do not accept this, might I interest you in a different\nlanguage?\n\nRegardless of your feelings on GC, it is pretty clearly a *massive* boon to\nmaking code safe. You never have to worry about things going away *too soon*\n(although whether you still wanted to be pointing at that thing is a different\nissue...). This is a pervasive problem that C and C++ programs need to deal\nwith. Consider this simple mistake that all of us who have used a non-GC'd\nlanguage have made at one point:\n\n,compile_fail\nfn as_str(data: &u32) -> &str {\n    // compute the string\n    let s = format!(\"{}\", data);\n\n    // OH NO! We returned a reference to something that\n    // exists only in this function!\n    // Dangling pointer! Use after free! Alas!\n    // (this does not compile in Rust)\n    &s\n}\n\nThis is exactly what Rust's ownership system was built to solve.\nRust knows the scope in which the `&s` lives, and as such can prevent it from\nescaping. However this is a simple case that even a C compiler could plausibly\ncatch. Things get more complicated as code gets bigger and pointers get fed through\nvarious functions. Eventually, a C compiler will fall down and won't be able to\nperform sufficient escape analysis to prove your code unsound. It will consequently\nbe forced to accept your program on the assumption that it is correct.\n\nThis will never happen to Rust. It's up to the programmer to prove to the\ncompiler that everything is sound.\n\nOf course, Rust's story around ownership is much more complicated than just\nverifying that references don't escape the scope of their referent. That's\nbecause ensuring pointers are always valid is much more complicated than this.\nFor instance in this code,\n\n,compile_fail\nlet mut data = vec![1, 2, 3];\n// get an internal reference\nlet x = &data[0];\n\n// OH NO! `push` causes the backing storage of `data` to be reallocated.\n// Dangling pointer! Use after free! Alas!\n// (this does not compile in Rust)\ndata.push(4);\n\nprintln!(\"{}\", x);\n\nnaive scope analysis would be insufficient to prevent this bug, because `data`\ndoes in fact live as long as we needed. However it was *changed* while we had\na reference into it. This is why Rust requires any references to freeze the\nreferent and its owners.",
      "parent_id": null,
      "paragraphs": {
        "nomicon_ownership_and_lifetimes_p1": "Ownership is the breakout feature of Rust. It allows Rust to be completely\nmemory-safe and efficient, while avoiding garbage collection. Before getting\ninto the ownership system in detail, we will consider the motivation of this\ndesign.",
        "nomicon_ownership_and_lifetimes_p2": "We will assume that you accept that garbage collection (GC) is not always an\noptimal solution, and that it is desirable to manually manage memory in some\ncontexts. If you do not accept this, might I interest you in a different\nlanguage?",
        "nomicon_ownership_and_lifetimes_p3": "Regardless of your feelings on GC, it is pretty clearly a *massive* boon to\nmaking code safe. You never have to worry about things going away *too soon*\n(although whether you still wanted to be pointing at that thing is a different\nissue...). This is a pervasive problem that C and C++ programs need to deal\nwith. Consider this simple mistake that all of us who have used a non-GC'd\nlanguage have made at one point:",
        "nomicon_ownership_and_lifetimes_p4": ",compile_fail\nfn as_str(data: &u32) -> &str {\n    // compute the string\n    let s = format!(\"{}\", data);",
        "nomicon_ownership_and_lifetimes_p5": "// OH NO! We returned a reference to something that\n    // exists only in this function!\n    // Dangling pointer! Use after free! Alas!\n    // (this does not compile in Rust)\n    &s\n}",
        "nomicon_ownership_and_lifetimes_p6": "This is exactly what Rust's ownership system was built to solve.\nRust knows the scope in which the `&s` lives, and as such can prevent it from\nescaping. However this is a simple case that even a C compiler could plausibly\ncatch. Things get more complicated as code gets bigger and pointers get fed through\nvarious functions. Eventually, a C compiler will fall down and won't be able to\nperform sufficient escape analysis to prove your code unsound. It will consequently\nbe forced to accept your program on the assumption that it is correct.",
        "nomicon_ownership_and_lifetimes_p7": "This will never happen to Rust. It's up to the programmer to prove to the\ncompiler that everything is sound.",
        "nomicon_ownership_and_lifetimes_p8": "Of course, Rust's story around ownership is much more complicated than just\nverifying that references don't escape the scope of their referent. That's\nbecause ensuring pointers are always valid is much more complicated than this.\nFor instance in this code,",
        "nomicon_ownership_and_lifetimes_p9": ",compile_fail\nlet mut data = vec![1, 2, 3];\n// get an internal reference\nlet x = &data[0];",
        "nomicon_ownership_and_lifetimes_p10": "// OH NO! `push` causes the backing storage of `data` to be reallocated.\n// Dangling pointer! Use after free! Alas!\n// (this does not compile in Rust)\ndata.push(4);",
        "nomicon_ownership_and_lifetimes_p11": "println!(\"{}\", x);",
        "nomicon_ownership_and_lifetimes_p12": "naive scope analysis would be insufficient to prevent this bug, because `data`\ndoes in fact live as long as we needed. However it was *changed* while we had\na reference into it. This is why Rust requires any references to freeze the\nreferent and its owners."
      }
    },
    {
      "id": "nomicon_references",
      "title": "References",
      "level": 1,
      "content": "There are two kinds of references:\n\n* Shared reference: `&`\n* Mutable reference: `&mut`\n\nWhich obey the following rules:\n\n* A reference cannot outlive its referent\n* A mutable reference cannot be aliased\n\nThat's it. That's the whole model references follow.\n\nOf course, we should probably define what *aliased* means.\n\nerror[E0425]: cannot find value `aliased` in this scope\n --> <rust.rs>:2:20\n  |\n2 |     println!(\"{}\", aliased);\n  |                    ^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nUnfortunately, Rust hasn't actually defined its aliasing model. \ud83d\ude40\n\nWhile we wait for the Rust devs to specify the semantics of their language,\nlet's use the next section to discuss what aliasing is in general, and why it\nmatters.",
      "parent_id": null,
      "paragraphs": {
        "nomicon_references_p1": "There are two kinds of references:",
        "nomicon_references_p2": "* Shared reference: `&`\n* Mutable reference: `&mut`",
        "nomicon_references_p3": "Which obey the following rules:",
        "nomicon_references_p4": "* A reference cannot outlive its referent\n* A mutable reference cannot be aliased",
        "nomicon_references_p5": "That's it. That's the whole model references follow.",
        "nomicon_references_p6": "Of course, we should probably define what *aliased* means.",
        "nomicon_references_p7": "error[E0425]: cannot find value `aliased` in this scope\n --> <rust.rs>:2:20\n  |\n2 |     println!(\"{}\", aliased);\n  |                    ^^^^^^^ not found in this scope",
        "nomicon_references_p8": "error: aborting due to previous error",
        "nomicon_references_p9": "Unfortunately, Rust hasn't actually defined its aliasing model. \ud83d\ude40",
        "nomicon_references_p10": "While we wait for the Rust devs to specify the semantics of their language,\nlet's use the next section to discuss what aliasing is in general, and why it\nmatters."
      }
    },
    {
      "id": "nomicon_aliasing",
      "title": "Aliasing",
      "level": 1,
      "content": "First off, let's get some important caveats out of the way:\n\n* We will be using the broadest possible definition of aliasing for the sake\nof discussion. Rust's definition will probably be more restricted to factor\nin mutations and liveness.\n\n* We will be assuming a single-threaded, interrupt-free, execution. We will also\nbe ignoring things like memory-mapped hardware. Rust assumes these things\ndon't happen unless you tell it otherwise. For more details, see the\nConcurrency Chapter.\n\nWith that said, here's our working definition: variables and pointers *alias*\nif they refer to overlapping regions of memory.",
      "parent_id": null,
      "paragraphs": {
        "nomicon_aliasing_p1": "First off, let's get some important caveats out of the way:",
        "nomicon_aliasing_p2": "* We will be using the broadest possible definition of aliasing for the sake\nof discussion. Rust's definition will probably be more restricted to factor\nin mutations and liveness.",
        "nomicon_aliasing_p3": "* We will be assuming a single-threaded, interrupt-free, execution. We will also\nbe ignoring things like memory-mapped hardware. Rust assumes these things\ndon't happen unless you tell it otherwise. For more details, see the\nConcurrency Chapter.",
        "nomicon_aliasing_p4": "With that said, here's our working definition: variables and pointers *alias*\nif they refer to overlapping regions of memory."
      }
    },
    {
      "id": "nomicon_why_aliasing_matters",
      "title": "Why Aliasing Matters",
      "level": 2,
      "content": "So why should we care about aliasing?\n\nConsider this simple function:\n\nfn compute(input: &u32, output: &mut u32) {\n    if *input > 10 {\n        *output = 1;\n    }\n    if *input > 5 {\n        *output *= 2;\n    }\n    // remember that `output` will be `2` if `input > 10`\n}\n\nWe would *like* to be able to optimize it to the following function:\n\nfn compute(input: &u32, output: &mut u32) {\n    let cached_input = *input; // keep `*input` in a register\n    if cached_input > 10 {\n        // If the input is greater than 10, the previous code would set the output to 1 and then double it,\n        // resulting in an output of 2 (because `>10` implies `>5`).\n        // Here, we avoid the double assignment and just set it directly to 2.\n        *output = 2;\n    } else if cached_input > 5 {\n        *output *= 2;\n    }\n}\n\nIn Rust, this optimization should be sound. For almost any other language, it\nwouldn't be (barring global analysis). This is because the optimization relies\non knowing that aliasing doesn't occur, which most languages are fairly liberal\nwith. Specifically, we need to worry about function arguments that make `input`\nand `output` overlap, such as `compute(&x, &mut x)`.\n\nWith that input, we could get this execution:\n\n<!-- ignore: expanded code -->\n,ignore\n                    //  input ==  output == 0xabad1dea\n                    // *input == *output == 20\nif *input > 10 {    // true  (*input == 20)\n    *output = 1;    // also overwrites *input, because they are the same\n}\nif *input > 5 {     // false (*input == 1)\n    *output *= 2;\n}\n                    // *input == *output == 1\n\nOur optimized function would produce `*output == 2` for this input, so the\ncorrectness of our optimization relies on this input being impossible.\n\nIn Rust we know this input should be impossible because `&mut` isn't allowed to be\naliased. So we can safely reject its possibility and perform this optimization.\nIn most other languages, this input would be entirely possible, and must be considered.\n\nThis is why alias analysis is important: it lets the compiler perform useful\noptimizations! Some examples:\n\n* keeping values in registers by proving no pointers access the value's memory\n* eliminating reads by proving some memory hasn't been written to since last we read it\n* eliminating writes by proving some memory is never read before the next write to it\n* moving or reordering reads and writes by proving they don't depend on each other\n\nThese optimizations also tend to prove the soundness of bigger optimizations\nsuch as loop vectorization, constant propagation, and dead code elimination.\n\nIn the previous example, we used the fact that `&mut u32` can't be aliased to prove\nthat writes to `*output` can't possibly affect `*input`. This lets us cache `*input`\nin a register, eliminating a read.\n\nBy caching this read, we knew that the write in the `> 10` branch couldn't\naffect whether we take the `> 5` branch, allowing us to also eliminate a\nread-modify-write (doubling `*output`) when `*input > 10`.\n\nThe key thing to remember about alias analysis is that writes are the primary\nhazard for optimizations. That is, the only thing that prevents us\nfrom moving a read to any other part of the program is the possibility of us\nre-ordering it with a write to the same location.\n\nFor instance, we have no concern for aliasing in the following modified version\nof our function, because we've moved the only write to `*output` to the very\nend of our function. This allows us to freely reorder the reads of `*input` that\noccur before it:\n\nfn compute(input: &u32, output: &mut u32) {\n    let mut temp = *output;\n    if *input > 10 {\n        temp = 1;\n    }\n    if *input > 5 {\n        temp *= 2;\n    }\n    *output = temp;\n}\n\nWe're still relying on alias analysis to assume that `input` doesn't alias\n`temp`, but the proof is much simpler: the value of a local variable can't be\naliased by things that existed before it was declared. This is an assumption\nevery language freely makes, and so this version of the function could be\noptimized the way we want in any language.\n\nThis is why the definition of \"alias\" that Rust will use likely involves some\nnotion of liveness and mutation: we don't actually care if aliasing occurs if\nthere aren't any actual writes to memory happening.\n\nOf course, a full aliasing model for Rust must also take into consideration things like\nfunction calls (which may mutate things we don't see), raw pointers (which have\nno aliasing requirements on their own), and UnsafeCell (which lets the referent\nof an `&` be mutated).",
      "parent_id": null,
      "paragraphs": {
        "nomicon_why_aliasing_matters_p1": "So why should we care about aliasing?",
        "nomicon_why_aliasing_matters_p2": "Consider this simple function:",
        "nomicon_why_aliasing_matters_p3": "fn compute(input: &u32, output: &mut u32) {\n    if *input > 10 {\n        *output = 1;\n    }\n    if *input > 5 {\n        *output *= 2;\n    }\n    // remember that `output` will be `2` if `input > 10`\n}",
        "nomicon_why_aliasing_matters_p4": "We would *like* to be able to optimize it to the following function:",
        "nomicon_why_aliasing_matters_p5": "fn compute(input: &u32, output: &mut u32) {\n    let cached_input = *input; // keep `*input` in a register\n    if cached_input > 10 {\n        // If the input is greater than 10, the previous code would set the output to 1 and then double it,\n        // resulting in an output of 2 (because `>10` implies `>5`).\n        // Here, we avoid the double assignment and just set it directly to 2.\n        *output = 2;\n    } else if cached_input > 5 {\n        *output *= 2;\n    }\n}",
        "nomicon_why_aliasing_matters_p6": "In Rust, this optimization should be sound. For almost any other language, it\nwouldn't be (barring global analysis). This is because the optimization relies\non knowing that aliasing doesn't occur, which most languages are fairly liberal\nwith. Specifically, we need to worry about function arguments that make `input`\nand `output` overlap, such as `compute(&x, &mut x)`.",
        "nomicon_why_aliasing_matters_p7": "With that input, we could get this execution:",
        "nomicon_why_aliasing_matters_p8": "<!-- ignore: expanded code -->\n,ignore\n                    //  input ==  output == 0xabad1dea\n                    // *input == *output == 20\nif *input > 10 {    // true  (*input == 20)\n    *output = 1;    // also overwrites *input, because they are the same\n}\nif *input > 5 {     // false (*input == 1)\n    *output *= 2;\n}\n                    // *input == *output == 1",
        "nomicon_why_aliasing_matters_p9": "Our optimized function would produce `*output == 2` for this input, so the\ncorrectness of our optimization relies on this input being impossible.",
        "nomicon_why_aliasing_matters_p10": "In Rust we know this input should be impossible because `&mut` isn't allowed to be\naliased. So we can safely reject its possibility and perform this optimization.\nIn most other languages, this input would be entirely possible, and must be considered.",
        "nomicon_why_aliasing_matters_p11": "This is why alias analysis is important: it lets the compiler perform useful\noptimizations! Some examples:",
        "nomicon_why_aliasing_matters_p12": "* keeping values in registers by proving no pointers access the value's memory\n* eliminating reads by proving some memory hasn't been written to since last we read it\n* eliminating writes by proving some memory is never read before the next write to it\n* moving or reordering reads and writes by proving they don't depend on each other",
        "nomicon_why_aliasing_matters_p13": "These optimizations also tend to prove the soundness of bigger optimizations\nsuch as loop vectorization, constant propagation, and dead code elimination.",
        "nomicon_why_aliasing_matters_p14": "In the previous example, we used the fact that `&mut u32` can't be aliased to prove\nthat writes to `*output` can't possibly affect `*input`. This lets us cache `*input`\nin a register, eliminating a read.",
        "nomicon_why_aliasing_matters_p15": "By caching this read, we knew that the write in the `> 10` branch couldn't\naffect whether we take the `> 5` branch, allowing us to also eliminate a\nread-modify-write (doubling `*output`) when `*input > 10`.",
        "nomicon_why_aliasing_matters_p16": "The key thing to remember about alias analysis is that writes are the primary\nhazard for optimizations. That is, the only thing that prevents us\nfrom moving a read to any other part of the program is the possibility of us\nre-ordering it with a write to the same location.",
        "nomicon_why_aliasing_matters_p17": "For instance, we have no concern for aliasing in the following modified version\nof our function, because we've moved the only write to `*output` to the very\nend of our function. This allows us to freely reorder the reads of `*input` that\noccur before it:",
        "nomicon_why_aliasing_matters_p18": "fn compute(input: &u32, output: &mut u32) {\n    let mut temp = *output;\n    if *input > 10 {\n        temp = 1;\n    }\n    if *input > 5 {\n        temp *= 2;\n    }\n    *output = temp;\n}",
        "nomicon_why_aliasing_matters_p19": "We're still relying on alias analysis to assume that `input` doesn't alias\n`temp`, but the proof is much simpler: the value of a local variable can't be\naliased by things that existed before it was declared. This is an assumption\nevery language freely makes, and so this version of the function could be\noptimized the way we want in any language.",
        "nomicon_why_aliasing_matters_p20": "This is why the definition of \"alias\" that Rust will use likely involves some\nnotion of liveness and mutation: we don't actually care if aliasing occurs if\nthere aren't any actual writes to memory happening.",
        "nomicon_why_aliasing_matters_p21": "Of course, a full aliasing model for Rust must also take into consideration things like\nfunction calls (which may mutate things we don't see), raw pointers (which have\nno aliasing requirements on their own), and UnsafeCell (which lets the referent\nof an `&` be mutated)."
      }
    },
    {
      "id": "nomicon_lifetimes",
      "title": "Lifetimes",
      "level": 1,
      "content": "Rust enforces these rules through *lifetimes*. Lifetimes are named\nregions of code that a reference must be valid for. Those regions\nmay be fairly complex, as they correspond to paths of execution\nin the program. There may even be holes in these paths of execution,\nas it's possible to invalidate a reference as long as it's reinitialized\nbefore it's used again. Types which contain references (or pretend to)\nmay also be tagged with lifetimes so that Rust can prevent them from\nbeing invalidated as well.\n\nIn most of our examples, the lifetimes will coincide with scopes. This is\nbecause our examples are simple. The more complex cases where they don't\ncoincide are described below.\n\nWithin a function body, Rust generally doesn't let you explicitly name the\nlifetimes involved. This is because it's generally not really necessary\nto talk about lifetimes in a local context; Rust has all the information and\ncan work out everything as optimally as possible. Many anonymous scopes and\ntemporaries that you would otherwise have to write are often introduced to\nmake your code Just Work.\n\nHowever once you cross the function boundary, you need to start talking about\nlifetimes. Lifetimes are denoted with an apostrophe: `'a`, `'static`. To dip\nour toes with lifetimes, we're going to pretend that we're actually allowed\nto label scopes with lifetimes, and desugar the examples from the start of\nthis chapter.\n\nOriginally, our examples made use of *aggressive* sugar -- high fructose corn\nsyrup even -- around scopes and lifetimes, because writing everything out\nexplicitly is *extremely noisy*. All Rust code relies on aggressive inference\nand elision of \"obvious\" things.\n\nOne particularly interesting piece of sugar is that each `let` statement\nimplicitly introduces a scope. For the most part, this doesn't really matter.\nHowever it does matter for variables that refer to each other. As a simple\nexample, let's completely desugar this simple piece of Rust code:\n\nlet x = 0;\nlet y = &x;\nlet z = &y;\n\nThe borrow checker always tries to minimize the extent of a lifetime, so it will\nlikely desugar to the following:\n\n<!-- ignore: desugared code -->\n,ignore\n// NOTE: `'a: {` and `&'b x` is not valid syntax!\n'a: {\n    let x: i32 = 0;\n    'b: {\n        // lifetime used is 'b because that's good enough.\n        let y: &'b i32 = &'b x;\n        'c: {\n            // ditto on 'c\n            let z: &'c &'b i32 = &'c y; // \"a reference to a reference to an i32\" (with lifetimes annotated)\n        }\n    }\n}\n\nWow. That's... awful. Let's all take a moment to thank Rust for making this easier.\n\nActually passing references to outer scopes will cause Rust to infer\na larger lifetime:\n\nlet x = 0;\nlet z;\nlet y = &x;\nz = y;\n\n<!-- ignore: desugared code -->\n,ignore\n'a: {\n    let x: i32 = 0;\n    'b: {\n        let z: &'b i32;\n        'c: {\n            // Must use 'b here because the reference to x is\n            // being passed to the scope 'b.\n            let y: &'b i32 = &'b x;\n            z = y;\n        }\n    }\n}",
      "parent_id": null,
      "paragraphs": {
        "nomicon_lifetimes_p1": "Rust enforces these rules through *lifetimes*. Lifetimes are named\nregions of code that a reference must be valid for. Those regions\nmay be fairly complex, as they correspond to paths of execution\nin the program. There may even be holes in these paths of execution,\nas it's possible to invalidate a reference as long as it's reinitialized\nbefore it's used again. Types which contain references (or pretend to)\nmay also be tagged with lifetimes so that Rust can prevent them from\nbeing invalidated as well.",
        "nomicon_lifetimes_p2": "In most of our examples, the lifetimes will coincide with scopes. This is\nbecause our examples are simple. The more complex cases where they don't\ncoincide are described below.",
        "nomicon_lifetimes_p3": "Within a function body, Rust generally doesn't let you explicitly name the\nlifetimes involved. This is because it's generally not really necessary\nto talk about lifetimes in a local context; Rust has all the information and\ncan work out everything as optimally as possible. Many anonymous scopes and\ntemporaries that you would otherwise have to write are often introduced to\nmake your code Just Work.",
        "nomicon_lifetimes_p4": "However once you cross the function boundary, you need to start talking about\nlifetimes. Lifetimes are denoted with an apostrophe: `'a`, `'static`. To dip\nour toes with lifetimes, we're going to pretend that we're actually allowed\nto label scopes with lifetimes, and desugar the examples from the start of\nthis chapter.",
        "nomicon_lifetimes_p5": "Originally, our examples made use of *aggressive* sugar -- high fructose corn\nsyrup even -- around scopes and lifetimes, because writing everything out\nexplicitly is *extremely noisy*. All Rust code relies on aggressive inference\nand elision of \"obvious\" things.",
        "nomicon_lifetimes_p6": "One particularly interesting piece of sugar is that each `let` statement\nimplicitly introduces a scope. For the most part, this doesn't really matter.\nHowever it does matter for variables that refer to each other. As a simple\nexample, let's completely desugar this simple piece of Rust code:",
        "nomicon_lifetimes_p7": "let x = 0;\nlet y = &x;\nlet z = &y;",
        "nomicon_lifetimes_p8": "The borrow checker always tries to minimize the extent of a lifetime, so it will\nlikely desugar to the following:",
        "nomicon_lifetimes_p9": "<!-- ignore: desugared code -->\n,ignore\n// NOTE: `'a: {` and `&'b x` is not valid syntax!\n'a: {\n    let x: i32 = 0;\n    'b: {\n        // lifetime used is 'b because that's good enough.\n        let y: &'b i32 = &'b x;\n        'c: {\n            // ditto on 'c\n            let z: &'c &'b i32 = &'c y; // \"a reference to a reference to an i32\" (with lifetimes annotated)\n        }\n    }\n}",
        "nomicon_lifetimes_p10": "Wow. That's... awful. Let's all take a moment to thank Rust for making this easier.",
        "nomicon_lifetimes_p11": "Actually passing references to outer scopes will cause Rust to infer\na larger lifetime:",
        "nomicon_lifetimes_p12": "let x = 0;\nlet z;\nlet y = &x;\nz = y;",
        "nomicon_lifetimes_p13": "<!-- ignore: desugared code -->\n,ignore\n'a: {\n    let x: i32 = 0;\n    'b: {\n        let z: &'b i32;\n        'c: {\n            // Must use 'b here because the reference to x is\n            // being passed to the scope 'b.\n            let y: &'b i32 = &'b x;\n            z = y;\n        }\n    }\n}"
      }
    },
    {
      "id": "nomicon_example_references_that_outlive_referents",
      "title": "Example: references that outlive referents",
      "level": 2,
      "content": "Alright, let's look at some of those examples from before:\n\n,compile_fail\nfn as_str(data: &u32) -> &str {\n    let s = format!(\"{}\", data);\n    &s\n}\n\ndesugars to:\n\n<!-- ignore: desugared code -->\n,ignore\nfn as_str<'a>(data: &'a u32) -> &'a str {\n    'b: {\n        let s = format!(\"{}\", data);\n        return &'a s;\n    }\n}\n\nThis signature of `as_str` takes a reference to a u32 with *some* lifetime, and\npromises that it can produce a reference to a str that can live *just as long*.\nAlready we can see why this signature might be trouble. That basically implies\nthat we're going to find a str somewhere in the scope the reference\nto the u32 originated in, or somewhere *even earlier*. That's a bit of a tall\norder.\n\nWe then proceed to compute the string `s`, and return a reference to it. Since\nthe contract of our function says the reference must outlive `'a`, that's the\nlifetime we infer for the reference. Unfortunately, `s` was defined in the\nscope `'b`, so the only way this is sound is if `'b` contains `'a` -- which is\nclearly false since `'a` must contain the function call itself. We have therefore\ncreated a reference whose lifetime outlives its referent, which is *literally*\nthe first thing we said that references can't do. The compiler rightfully blows\nup in our face.\n\nTo make this more clear, we can expand the example:\n\n<!-- ignore: desugared code -->\n,ignore\nfn as_str<'a>(data: &'a u32) -> &'a str {\n    'b: {\n        let s = format!(\"{}\", data);\n        return &'a s\n    }\n}\n\nfn main() {\n    'c: {\n        let x: u32 = 0;\n        'd: {\n            // An anonymous scope is introduced because the borrow does not\n            // need to last for the whole scope x is valid for. The return\n            // of as_str must find a str somewhere before this function\n            // call. Obviously not happening.\n            println!(\"{}\", as_str::<'d>(&'d x));\n        }\n    }\n}\n\nShoot!\n\nOf course, the right way to write this function is as follows:\n\nfn to_string(data: &u32) -> String {\n    format!(\"{}\", data)\n}\n\nWe must produce an owned value inside the function to return it! The only way\nwe could have returned an `&'a str` would have been if it was in a field of the\n`&'a u32`, which is obviously not the case.\n\n(Actually we could have also just returned a string literal, which as a global\ncan be considered to reside at the bottom of the stack; though this limits\nour implementation *just a bit*.)",
      "parent_id": null,
      "paragraphs": {
        "nomicon_example_references_that_outlive_referents_p1": "Alright, let's look at some of those examples from before:",
        "nomicon_example_references_that_outlive_referents_p2": ",compile_fail\nfn as_str(data: &u32) -> &str {\n    let s = format!(\"{}\", data);\n    &s\n}",
        "nomicon_example_references_that_outlive_referents_p3": "desugars to:",
        "nomicon_example_references_that_outlive_referents_p4": "<!-- ignore: desugared code -->\n,ignore\nfn as_str<'a>(data: &'a u32) -> &'a str {\n    'b: {\n        let s = format!(\"{}\", data);\n        return &'a s;\n    }\n}",
        "nomicon_example_references_that_outlive_referents_p5": "This signature of `as_str` takes a reference to a u32 with *some* lifetime, and\npromises that it can produce a reference to a str that can live *just as long*.\nAlready we can see why this signature might be trouble. That basically implies\nthat we're going to find a str somewhere in the scope the reference\nto the u32 originated in, or somewhere *even earlier*. That's a bit of a tall\norder.",
        "nomicon_example_references_that_outlive_referents_p6": "We then proceed to compute the string `s`, and return a reference to it. Since\nthe contract of our function says the reference must outlive `'a`, that's the\nlifetime we infer for the reference. Unfortunately, `s` was defined in the\nscope `'b`, so the only way this is sound is if `'b` contains `'a` -- which is\nclearly false since `'a` must contain the function call itself. We have therefore\ncreated a reference whose lifetime outlives its referent, which is *literally*\nthe first thing we said that references can't do. The compiler rightfully blows\nup in our face.",
        "nomicon_example_references_that_outlive_referents_p7": "To make this more clear, we can expand the example:",
        "nomicon_example_references_that_outlive_referents_p8": "<!-- ignore: desugared code -->\n,ignore\nfn as_str<'a>(data: &'a u32) -> &'a str {\n    'b: {\n        let s = format!(\"{}\", data);\n        return &'a s\n    }\n}",
        "nomicon_example_references_that_outlive_referents_p9": "fn main() {\n    'c: {\n        let x: u32 = 0;\n        'd: {\n            // An anonymous scope is introduced because the borrow does not\n            // need to last for the whole scope x is valid for. The return\n            // of as_str must find a str somewhere before this function\n            // call. Obviously not happening.\n            println!(\"{}\", as_str::<'d>(&'d x));\n        }\n    }\n}",
        "nomicon_example_references_that_outlive_referents_p10": "Shoot!",
        "nomicon_example_references_that_outlive_referents_p11": "Of course, the right way to write this function is as follows:",
        "nomicon_example_references_that_outlive_referents_p12": "fn to_string(data: &u32) -> String {\n    format!(\"{}\", data)\n}",
        "nomicon_example_references_that_outlive_referents_p13": "We must produce an owned value inside the function to return it! The only way\nwe could have returned an `&'a str` would have been if it was in a field of the\n`&'a u32`, which is obviously not the case.",
        "nomicon_example_references_that_outlive_referents_p14": "(Actually we could have also just returned a string literal, which as a global\ncan be considered to reside at the bottom of the stack; though this limits\nour implementation *just a bit*.)"
      }
    },
    {
      "id": "nomicon_example_aliasing_a_mutable_reference",
      "title": "Example: aliasing a mutable reference",
      "level": 2,
      "content": "How about the other example:\n\n,compile_fail\nlet mut data = vec![1, 2, 3];\nlet x = &data[0];\ndata.push(4);\nprintln!(\"{}\", x);\n\n<!-- ignore: desugared code -->\n,ignore\n'a: {\n    let mut data: Vec<i32> = vec![1, 2, 3];\n    'b: {\n        // 'b is as big as we need this borrow to be\n        // (just need to get to `println!`)\n        let x: &'b i32 = Index::index::<'b>(&'b data, 0);\n        'c: {\n            // Temporary scope because we don't need the\n            // &mut to last any longer.\n            Vec::push(&'c mut data, 4);\n        }\n        println!(\"{}\", x);\n    }\n}\n\nThe problem here is a bit more subtle and interesting. We want Rust to\nreject this program for the following reason: We have a live shared reference `x`\nto a descendant of `data` when we try to take a mutable reference to `data`\nto `push`. This would create an aliased mutable reference, which would\nviolate the *second* rule of references.\n\nHowever this is *not at all* how Rust reasons that this program is bad. Rust\ndoesn't understand that `x` is a reference to a subpath of `data`. It doesn't\nunderstand `Vec` at all. What it *does* see is that `x` has to live for `'b` in\norder to be printed. The signature of `Index::index` subsequently demands that\nthe reference we take to `data` has to survive for `'b`. When we try to call\n`push`, it then sees us try to make an `&'c mut data`. Rust knows that `'c` is\ncontained within `'b`, and rejects our program because the `&'b data` must still\nbe alive!\n\nHere we see that the lifetime system is much more coarse than the reference\nsemantics we're actually interested in preserving. For the most part, *that's\ntotally ok*, because it keeps us from spending all day explaining our program\nto the compiler. However it does mean that several programs that are totally\ncorrect with respect to Rust's *true* semantics are rejected because lifetimes\nare too dumb.",
      "parent_id": null,
      "paragraphs": {
        "nomicon_example_aliasing_a_mutable_reference_p1": "How about the other example:",
        "nomicon_example_aliasing_a_mutable_reference_p2": ",compile_fail\nlet mut data = vec![1, 2, 3];\nlet x = &data[0];\ndata.push(4);\nprintln!(\"{}\", x);",
        "nomicon_example_aliasing_a_mutable_reference_p3": "<!-- ignore: desugared code -->\n,ignore\n'a: {\n    let mut data: Vec<i32> = vec![1, 2, 3];\n    'b: {\n        // 'b is as big as we need this borrow to be\n        // (just need to get to `println!`)\n        let x: &'b i32 = Index::index::<'b>(&'b data, 0);\n        'c: {\n            // Temporary scope because we don't need the\n            // &mut to last any longer.\n            Vec::push(&'c mut data, 4);\n        }\n        println!(\"{}\", x);\n    }\n}",
        "nomicon_example_aliasing_a_mutable_reference_p4": "The problem here is a bit more subtle and interesting. We want Rust to\nreject this program for the following reason: We have a live shared reference `x`\nto a descendant of `data` when we try to take a mutable reference to `data`\nto `push`. This would create an aliased mutable reference, which would\nviolate the *second* rule of references.",
        "nomicon_example_aliasing_a_mutable_reference_p5": "However this is *not at all* how Rust reasons that this program is bad. Rust\ndoesn't understand that `x` is a reference to a subpath of `data`. It doesn't\nunderstand `Vec` at all. What it *does* see is that `x` has to live for `'b` in\norder to be printed. The signature of `Index::index` subsequently demands that\nthe reference we take to `data` has to survive for `'b`. When we try to call\n`push`, it then sees us try to make an `&'c mut data`. Rust knows that `'c` is\ncontained within `'b`, and rejects our program because the `&'b data` must still\nbe alive!",
        "nomicon_example_aliasing_a_mutable_reference_p6": "Here we see that the lifetime system is much more coarse than the reference\nsemantics we're actually interested in preserving. For the most part, *that's\ntotally ok*, because it keeps us from spending all day explaining our program\nto the compiler. However it does mean that several programs that are totally\ncorrect with respect to Rust's *true* semantics are rejected because lifetimes\nare too dumb."
      }
    },
    {
      "id": "nomicon_the_area_covered_by_a_lifetime",
      "title": "The area covered by a lifetime",
      "level": 2,
      "content": "A reference (sometimes called a *borrow*) is *alive* from the place it is\ncreated to its last use. The borrowed value needs to outlive only borrows that\nare alive. This looks simple, but there are a few subtleties.\n\nThe following snippet compiles, because after printing `x`, it is no longer\nneeded, so it doesn't matter if it is dangling or aliased (even though the\nvariable `x` *technically* exists to the very end of the scope).\n\nlet mut data = vec![1, 2, 3];\nlet x = &data[0];\nprintln!(\"{}\", x);\n// This is OK, x is no longer needed\ndata.push(4);\n\nHowever, if the value has a destructor, the destructor is run at the end of the\nscope. And running the destructor is considered a use \u2012 obviously the last one.\nSo, this will *not* compile.\n\n,compile_fail\n#[derive(Debug)]\nstruct X<'a>(&'a i32);\n\nimpl Drop for X<'_> {\n    fn drop(&mut self) {}\n}\n\nlet mut data = vec![1, 2, 3];\nlet x = X(&data[0]);\nprintln!(\"{:?}\", x);\ndata.push(4);\n// Here, the destructor is run and therefore this'll fail to compile.\n\nOne way to convince the compiler that `x` is no longer valid is by using `drop(x)` before `data.push(4)`.\n\nFurthermore, there might be multiple possible last uses of the borrow, for\nexample in each branch of a condition.",
      "parent_id": null,
      "paragraphs": {
        "nomicon_the_area_covered_by_a_lifetime_p1": "A reference (sometimes called a *borrow*) is *alive* from the place it is\ncreated to its last use. The borrowed value needs to outlive only borrows that\nare alive. This looks simple, but there are a few subtleties.",
        "nomicon_the_area_covered_by_a_lifetime_p2": "The following snippet compiles, because after printing `x`, it is no longer\nneeded, so it doesn't matter if it is dangling or aliased (even though the\nvariable `x` *technically* exists to the very end of the scope).",
        "nomicon_the_area_covered_by_a_lifetime_p3": "let mut data = vec![1, 2, 3];\nlet x = &data[0];\nprintln!(\"{}\", x);\n// This is OK, x is no longer needed\ndata.push(4);",
        "nomicon_the_area_covered_by_a_lifetime_p4": "However, if the value has a destructor, the destructor is run at the end of the\nscope. And running the destructor is considered a use \u2012 obviously the last one.\nSo, this will *not* compile.",
        "nomicon_the_area_covered_by_a_lifetime_p5": ",compile_fail\n#[derive(Debug)]\nstruct X<'a>(&'a i32);",
        "nomicon_the_area_covered_by_a_lifetime_p6": "impl Drop for X<'_> {\n    fn drop(&mut self) {}\n}",
        "nomicon_the_area_covered_by_a_lifetime_p7": "let mut data = vec![1, 2, 3];\nlet x = X(&data[0]);\nprintln!(\"{:?}\", x);\ndata.push(4);\n// Here, the destructor is run and therefore this'll fail to compile.",
        "nomicon_the_area_covered_by_a_lifetime_p8": "One way to convince the compiler that `x` is no longer valid is by using `drop(x)` before `data.push(4)`.",
        "nomicon_the_area_covered_by_a_lifetime_p9": "Furthermore, there might be multiple possible last uses of the borrow, for\nexample in each branch of a condition.",
        "nomicon_the_area_covered_by_a_lifetime_p10": ""
      }
    },
    {
      "id": "nomicon_fn_some_condition_bool_true",
      "title": "fn some_condition() -> bool { true }",
      "level": 1,
      "content": "let mut data = vec![1, 2, 3];\nlet x = &data[0];\n\nif some_condition() {\n    println!(\"{}\", x); // This is the last use of `x` in this branch\n    data.push(4);      // So we can push here\n} else {\n    // There's no use of `x` in here, so effectively the last use is the\n    // creation of x at the top of the example.\n    data.push(5);\n}\n\nAnd a lifetime can have a pause in it. Or you might look at it as two distinct\nborrows just being tied to the same local variable. This often happens around\nloops (writing a new value of a variable at the end of the loop and using it for\nthe last time at the top of the next iteration).\n\nlet mut data = vec![1, 2, 3];\n// This mut allows us to change where the reference points to\nlet mut x = &data[0];\n\nprintln!(\"{}\", x); // Last use of this borrow\ndata.push(4);\nx = &data[3]; // We start a new borrow here\nprintln!(\"{}\", x);\n\nHistorically, Rust kept the borrow alive until the end of scope, so these\nexamples might fail to compile with older compilers. Also, there are still some\ncorner cases where Rust fails to properly shorten the live part of the borrow\nand fails to compile even when it looks like it should. These'll be solved over\ntime.",
      "parent_id": null,
      "paragraphs": {
        "nomicon_fn_some_condition_bool_true_p1": "let mut data = vec![1, 2, 3];\nlet x = &data[0];",
        "nomicon_fn_some_condition_bool_true_p2": "if some_condition() {\n    println!(\"{}\", x); // This is the last use of `x` in this branch\n    data.push(4);      // So we can push here\n} else {\n    // There's no use of `x` in here, so effectively the last use is the\n    // creation of x at the top of the example.\n    data.push(5);\n}",
        "nomicon_fn_some_condition_bool_true_p3": "And a lifetime can have a pause in it. Or you might look at it as two distinct\nborrows just being tied to the same local variable. This often happens around\nloops (writing a new value of a variable at the end of the loop and using it for\nthe last time at the top of the next iteration).",
        "nomicon_fn_some_condition_bool_true_p4": "let mut data = vec![1, 2, 3];\n// This mut allows us to change where the reference points to\nlet mut x = &data[0];",
        "nomicon_fn_some_condition_bool_true_p5": "println!(\"{}\", x); // Last use of this borrow\ndata.push(4);\nx = &data[3]; // We start a new borrow here\nprintln!(\"{}\", x);",
        "nomicon_fn_some_condition_bool_true_p6": "Historically, Rust kept the borrow alive until the end of scope, so these\nexamples might fail to compile with older compilers. Also, there are still some\ncorner cases where Rust fails to properly shorten the live part of the borrow\nand fails to compile even when it looks like it should. These'll be solved over\ntime."
      }
    },
    {
      "id": "nomicon_limits_of_lifetimes",
      "title": "Limits of Lifetimes",
      "level": 1,
      "content": "Given the following code:\n\n,compile_fail\n#[derive(Debug)]\nstruct Foo;\n\nimpl Foo {\n    fn mutate_and_share(&mut self) -> &Self { &*self }\n    fn share(&self) {}\n}\n\nfn main() {\n    let mut foo = Foo;\n    let loan = foo.mutate_and_share();\n    foo.share();\n    println!(\"{:?}\", loan);\n}\n\nOne might expect it to compile. We call `mutate_and_share`, which mutably\nborrows `foo` temporarily, but then returns only a shared reference. Therefore\nwe would expect `foo.share()` to succeed as `foo` shouldn't be mutably borrowed.\n\nHowever when we try to compile it:\n\nerror[E0502]: cannot borrow `foo` as immutable because it is also borrowed as mutable\n  --> src/main.rs:12:5\n   |\n11 |     let loan = foo.mutate_and_share();\n   |                --- mutable borrow occurs here\n12 |     foo.share();\n   |     ^^^ immutable borrow occurs here\n13 |     println!(\"{:?}\", loan);\n\nWhat happened? Well, we got the exact same reasoning as we did for\nExample 2 in the previous section. We desugar the program and we get\nthe following:\n\n<!-- ignore: desugared code -->\n,ignore\nstruct Foo;\n\nimpl Foo {\n    fn mutate_and_share<'a>(&'a mut self) -> &'a Self { &'a *self }\n    fn share<'a>(&'a self) {}\n}\n\nfn main() {\n    'b: {\n        let mut foo: Foo = Foo;\n        'c: {\n            let loan: &'c Foo = Foo::mutate_and_share::<'c>(&'c mut foo);\n            'd: {\n                Foo::share::<'d>(&'d foo);\n            }\n            println!(\"{:?}\", loan);\n        }\n    }\n}\n\nThe lifetime system is forced to extend the `&mut foo` to have lifetime `'c`,\ndue to the lifetime of `loan` and `mutate_and_share`'s signature. Then when we\ntry to call `share`, it sees we're trying to alias that `&'c mut foo` and\nblows up in our face!\n\nThis program is clearly correct according to the reference semantics we actually\ncare about, but the lifetime system is too coarse-grained to handle that.",
      "parent_id": null,
      "paragraphs": {
        "nomicon_limits_of_lifetimes_p1": "Given the following code:",
        "nomicon_limits_of_lifetimes_p2": ",compile_fail\n#[derive(Debug)]\nstruct Foo;",
        "nomicon_limits_of_lifetimes_p3": "impl Foo {\n    fn mutate_and_share(&mut self) -> &Self { &*self }\n    fn share(&self) {}\n}",
        "nomicon_limits_of_lifetimes_p4": "fn main() {\n    let mut foo = Foo;\n    let loan = foo.mutate_and_share();\n    foo.share();\n    println!(\"{:?}\", loan);\n}",
        "nomicon_limits_of_lifetimes_p5": "One might expect it to compile. We call `mutate_and_share`, which mutably\nborrows `foo` temporarily, but then returns only a shared reference. Therefore\nwe would expect `foo.share()` to succeed as `foo` shouldn't be mutably borrowed.",
        "nomicon_limits_of_lifetimes_p6": "However when we try to compile it:",
        "nomicon_limits_of_lifetimes_p7": "error[E0502]: cannot borrow `foo` as immutable because it is also borrowed as mutable\n  --> src/main.rs:12:5\n   |\n11 |     let loan = foo.mutate_and_share();\n   |                --- mutable borrow occurs here\n12 |     foo.share();\n   |     ^^^ immutable borrow occurs here\n13 |     println!(\"{:?}\", loan);",
        "nomicon_limits_of_lifetimes_p8": "What happened? Well, we got the exact same reasoning as we did for\nExample 2 in the previous section. We desugar the program and we get\nthe following:",
        "nomicon_limits_of_lifetimes_p9": "<!-- ignore: desugared code -->\n,ignore\nstruct Foo;",
        "nomicon_limits_of_lifetimes_p10": "impl Foo {\n    fn mutate_and_share<'a>(&'a mut self) -> &'a Self { &'a *self }\n    fn share<'a>(&'a self) {}\n}",
        "nomicon_limits_of_lifetimes_p11": "fn main() {\n    'b: {\n        let mut foo: Foo = Foo;\n        'c: {\n            let loan: &'c Foo = Foo::mutate_and_share::<'c>(&'c mut foo);\n            'd: {\n                Foo::share::<'d>(&'d foo);\n            }\n            println!(\"{:?}\", loan);\n        }\n    }\n}",
        "nomicon_limits_of_lifetimes_p12": "The lifetime system is forced to extend the `&mut foo` to have lifetime `'c`,\ndue to the lifetime of `loan` and `mutate_and_share`'s signature. Then when we\ntry to call `share`, it sees we're trying to alias that `&'c mut foo` and\nblows up in our face!",
        "nomicon_limits_of_lifetimes_p13": "This program is clearly correct according to the reference semantics we actually\ncare about, but the lifetime system is too coarse-grained to handle that."
      }
    },
    {
      "id": "nomicon_improperly_reduced_borrows",
      "title": "Improperly reduced borrows",
      "level": 2,
      "content": "The following code fails to compile, because Rust sees that a variable, `map`,\nis borrowed twice, and can not infer that the first borrow ceases to be needed\nbefore the second one occurs. This is caused by Rust conservatively falling back\nto using a whole scope for the first borrow. This will eventually get fixed.\n\n,compile_fail",
      "parent_id": null,
      "paragraphs": {
        "nomicon_improperly_reduced_borrows_p1": "The following code fails to compile, because Rust sees that a variable, `map`,\nis borrowed twice, and can not infer that the first borrow ceases to be needed\nbefore the second one occurs. This is caused by Rust conservatively falling back\nto using a whole scope for the first borrow. This will eventually get fixed.",
        "nomicon_improperly_reduced_borrows_p2": ",compile_fail"
      }
    },
    {
      "id": "nomicon_use_std_collections_hashmap",
      "title": "use std::collections::HashMap;",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_use_std_hash_hash",
      "title": "use std::hash::Hash;",
      "level": 1,
      "content": "fn get_default<'m, K, V>(map: &'m mut HashMap<K, V>, key: K) -> &'m mut V\nwhere\n    K: Clone + Eq + Hash,\n    V: Default,\n{\n    match map.get_mut(&key) {\n        Some(value) => value,\n        None => {\n            map.insert(key.clone(), V::default());\n            map.get_mut(&key).unwrap()\n        }\n    }\n}\n\nBecause of the lifetime restrictions imposed, `&mut map`'s lifetime\noverlaps other mutable borrows, resulting in a compile error:\n\nerror[E0499]: cannot borrow `*map` as mutable more than once at a time\n  --> src/main.rs:12:13\n   |\n4  |   fn get_default<'m, K, V>(map: &'m mut HashMap<K, V>, key: K) -> &'m mut V\n   |                  -- lifetime `'m` defined here\n...\n9  |       match map.get_mut(&key) {\n   |       -     --- first mutable borrow occurs here\n   |  _____|\n   | |\n10 | |         Some(value) => value,\n11 | |         None => {\n12 | |             map.insert(key.clone(), V::default());\n   | |             ^^^ second mutable borrow occurs here\n13 | |             map.get_mut(&key).unwrap()\n14 | |         }\n15 | |     }\n   | |_____- returning this value requires that `*map` is borrowed for `'m`\n\n[ex2]: lifetimes.html#example-aliasing-a-mutable-reference",
      "parent_id": null,
      "paragraphs": {
        "nomicon_use_std_hash_hash_p1": "fn get_default<'m, K, V>(map: &'m mut HashMap<K, V>, key: K) -> &'m mut V\nwhere\n    K: Clone + Eq + Hash,\n    V: Default,\n{\n    match map.get_mut(&key) {\n        Some(value) => value,\n        None => {\n            map.insert(key.clone(), V::default());\n            map.get_mut(&key).unwrap()\n        }\n    }\n}",
        "nomicon_use_std_hash_hash_p2": "Because of the lifetime restrictions imposed, `&mut map`'s lifetime\noverlaps other mutable borrows, resulting in a compile error:",
        "nomicon_use_std_hash_hash_p3": "error[E0499]: cannot borrow `*map` as mutable more than once at a time\n  --> src/main.rs:12:13\n   |\n4  |   fn get_default<'m, K, V>(map: &'m mut HashMap<K, V>, key: K) -> &'m mut V\n   |                  -- lifetime `'m` defined here\n...\n9  |       match map.get_mut(&key) {\n   |       -     --- first mutable borrow occurs here\n   |  _____|\n   | |\n10 | |         Some(value) => value,\n11 | |         None => {\n12 | |             map.insert(key.clone(), V::default());\n   | |             ^^^ second mutable borrow occurs here\n13 | |             map.get_mut(&key).unwrap()\n14 | |         }\n15 | |     }\n   | |_____- returning this value requires that `*map` is borrowed for `'m`",
        "nomicon_use_std_hash_hash_p4": "[ex2]: lifetimes.html#example-aliasing-a-mutable-reference"
      }
    },
    {
      "id": "nomicon_lifetime_elision",
      "title": "Lifetime Elision",
      "level": 1,
      "content": "In order to make common patterns more ergonomic, Rust allows lifetimes to be\n*elided* in function signatures.\n\nA *lifetime position* is anywhere you can write a lifetime in a type:\n\n<!-- ignore: simplified code -->\n,ignore\n&'a T\n&'a mut T\nT<'a>\n\nLifetime positions can appear as either \"input\" or \"output\":\n\n* For `fn` definitions, `fn` types, and the traits `Fn`, `FnMut`, and `FnOnce`,\n  input refers to the types of the formal arguments, while output refers to\n  result types. So `fn foo(s: &str) -> (&str, &str)` has elided one lifetime in\n  input position and two lifetimes in output position. Note that the input\n  positions of a `fn` method definition do not include the lifetimes that occur\n  in the method's `impl` header (nor lifetimes that occur in the trait header,\n  for a default method).\n\n* For `impl` headers, all types are input. So `impl Trait<&T> for Struct<&T>`\n  has elided two lifetimes in input position, while `impl Struct<&T>` has elided\n  one.\n\nElision rules are as follows:\n\n* Each elided lifetime in input position becomes a distinct lifetime\n  parameter.\n\n* If there is exactly one input lifetime position (elided or not), that lifetime\n  is assigned to *all* elided output lifetimes.\n\n* If there are multiple input lifetime positions, but one of them is `&self` or\n  `&mut self`, the lifetime of `self` is assigned to *all* elided output lifetimes.\n\n* Otherwise, it is an error to elide an output lifetime.\n\nExamples:\n\n<!-- ignore: simplified code -->\n,ignore\nfn print(s: &str);                                      // elided\nfn print<'a>(s: &'a str);                               // expanded\n\nfn debug(lvl: usize, s: &str);                          // elided\nfn debug<'a>(lvl: usize, s: &'a str);                   // expanded\n\nfn substr(s: &str, until: usize) -> &str;               // elided\nfn substr<'a>(s: &'a str, until: usize) -> &'a str;     // expanded\n\nfn get_str() -> &str;                                   // ILLEGAL\n\nfn frob(s: &str, t: &str) -> &str;                      // ILLEGAL\n\nfn get_mut(&mut self) -> &mut T;                        // elided\nfn get_mut<'a>(&'a mut self) -> &'a mut T;              // expanded\n\nfn args<T: ToCStr>(&mut self, args: &[T]) -> &mut Command                  // elided\nfn args<'a, 'b, T: ToCStr>(&'a mut self, args: &'b [T]) -> &'a mut Command // expanded\n\nfn new(buf: &mut [u8]) -> BufWriter;                    // elided\nfn new(buf: &mut [u8]) -> BufWriter<'_>;                // elided (with `rust_2018_idioms`)\nfn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a>          // expanded",
      "parent_id": null,
      "paragraphs": {
        "nomicon_lifetime_elision_p1": "In order to make common patterns more ergonomic, Rust allows lifetimes to be\n*elided* in function signatures.",
        "nomicon_lifetime_elision_p2": "A *lifetime position* is anywhere you can write a lifetime in a type:",
        "nomicon_lifetime_elision_p3": "<!-- ignore: simplified code -->\n,ignore\n&'a T\n&'a mut T\nT<'a>",
        "nomicon_lifetime_elision_p4": "Lifetime positions can appear as either \"input\" or \"output\":",
        "nomicon_lifetime_elision_p5": "* For `fn` definitions, `fn` types, and the traits `Fn`, `FnMut`, and `FnOnce`,\n  input refers to the types of the formal arguments, while output refers to\n  result types. So `fn foo(s: &str) -> (&str, &str)` has elided one lifetime in\n  input position and two lifetimes in output position. Note that the input\n  positions of a `fn` method definition do not include the lifetimes that occur\n  in the method's `impl` header (nor lifetimes that occur in the trait header,\n  for a default method).",
        "nomicon_lifetime_elision_p6": "* For `impl` headers, all types are input. So `impl Trait<&T> for Struct<&T>`\n  has elided two lifetimes in input position, while `impl Struct<&T>` has elided\n  one.",
        "nomicon_lifetime_elision_p7": "Elision rules are as follows:",
        "nomicon_lifetime_elision_p8": "* Each elided lifetime in input position becomes a distinct lifetime\n  parameter.",
        "nomicon_lifetime_elision_p9": "* If there is exactly one input lifetime position (elided or not), that lifetime\n  is assigned to *all* elided output lifetimes.",
        "nomicon_lifetime_elision_p10": "* If there are multiple input lifetime positions, but one of them is `&self` or\n  `&mut self`, the lifetime of `self` is assigned to *all* elided output lifetimes.",
        "nomicon_lifetime_elision_p11": "* Otherwise, it is an error to elide an output lifetime.",
        "nomicon_lifetime_elision_p12": "Examples:",
        "nomicon_lifetime_elision_p13": "<!-- ignore: simplified code -->\n,ignore\nfn print(s: &str);                                      // elided\nfn print<'a>(s: &'a str);                               // expanded",
        "nomicon_lifetime_elision_p14": "fn debug(lvl: usize, s: &str);                          // elided\nfn debug<'a>(lvl: usize, s: &'a str);                   // expanded",
        "nomicon_lifetime_elision_p15": "fn substr(s: &str, until: usize) -> &str;               // elided\nfn substr<'a>(s: &'a str, until: usize) -> &'a str;     // expanded",
        "nomicon_lifetime_elision_p16": "fn get_str() -> &str;                                   // ILLEGAL",
        "nomicon_lifetime_elision_p17": "fn frob(s: &str, t: &str) -> &str;                      // ILLEGAL",
        "nomicon_lifetime_elision_p18": "fn get_mut(&mut self) -> &mut T;                        // elided\nfn get_mut<'a>(&'a mut self) -> &'a mut T;              // expanded",
        "nomicon_lifetime_elision_p19": "fn args<T: ToCStr>(&mut self, args: &[T]) -> &mut Command                  // elided\nfn args<'a, 'b, T: ToCStr>(&'a mut self, args: &'b [T]) -> &'a mut Command // expanded",
        "nomicon_lifetime_elision_p20": "fn new(buf: &mut [u8]) -> BufWriter;                    // elided\nfn new(buf: &mut [u8]) -> BufWriter<'_>;                // elided (with `rust_2018_idioms`)\nfn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a>          // expanded"
      }
    },
    {
      "id": "nomicon_unbounded_lifetimes",
      "title": "Unbounded Lifetimes",
      "level": 1,
      "content": "Unsafe code can often end up producing references or lifetimes out of thin air.\nSuch lifetimes come into the world as *unbounded*. The most common source of\nthis is taking a reference to a dereferenced raw pointer, which produces a\nreference with an unbounded lifetime. Such a lifetime becomes as big as context\ndemands. This is in fact more powerful than simply becoming `'static`, because\nfor instance `&'static &'a T` will fail to typecheck, but the unbound lifetime\nwill perfectly mold into `&'a &'a T` as needed. However for most intents and\npurposes, such an unbounded lifetime can be regarded as `'static`.\n\nAlmost no reference is `'static`, so this is probably wrong. `transmute` and\n`transmute_copy` are the two other primary offenders. One should endeavor to\nbound an unbounded lifetime as quickly as possible, especially across function\nboundaries.\n\nGiven a function, any output lifetimes that don't derive from inputs are\nunbounded. For instance:\n\n<!-- no_run: This example exhibits undefined behavior. -->\n,no_run\nfn get_str<'a>(s: *const String) -> &'a str {\n    unsafe { &*s }\n}\n\nfn main() {\n    let soon_dropped = String::from(\"hello\");\n    let dangling = get_str(&soon_dropped);\n    drop(soon_dropped);\n    println!(\"Invalid str: {}\", dangling); // Invalid str: g\u04da_`\n}\n\nThe easiest way to avoid unbounded lifetimes is to use lifetime elision at the\nfunction boundary. If an output lifetime is elided, then it *must* be bounded by\nan input lifetime. Of course it might be bounded by the *wrong* lifetime, but\nthis will usually just cause a compiler error, rather than allow memory safety\nto be trivially violated.\n\nWithin a function, bounding lifetimes is more error-prone. The safest and easiest\nway to bound a lifetime is to return it from a function with a bound lifetime.\nHowever if this is unacceptable, the reference can be placed in a location with\na specific lifetime. Unfortunately it's impossible to name all lifetimes involved\nin a function.",
      "parent_id": null,
      "paragraphs": {
        "nomicon_unbounded_lifetimes_p1": "Unsafe code can often end up producing references or lifetimes out of thin air.\nSuch lifetimes come into the world as *unbounded*. The most common source of\nthis is taking a reference to a dereferenced raw pointer, which produces a\nreference with an unbounded lifetime. Such a lifetime becomes as big as context\ndemands. This is in fact more powerful than simply becoming `'static`, because\nfor instance `&'static &'a T` will fail to typecheck, but the unbound lifetime\nwill perfectly mold into `&'a &'a T` as needed. However for most intents and\npurposes, such an unbounded lifetime can be regarded as `'static`.",
        "nomicon_unbounded_lifetimes_p2": "Almost no reference is `'static`, so this is probably wrong. `transmute` and\n`transmute_copy` are the two other primary offenders. One should endeavor to\nbound an unbounded lifetime as quickly as possible, especially across function\nboundaries.",
        "nomicon_unbounded_lifetimes_p3": "Given a function, any output lifetimes that don't derive from inputs are\nunbounded. For instance:",
        "nomicon_unbounded_lifetimes_p4": "<!-- no_run: This example exhibits undefined behavior. -->\n,no_run\nfn get_str<'a>(s: *const String) -> &'a str {\n    unsafe { &*s }\n}",
        "nomicon_unbounded_lifetimes_p5": "fn main() {\n    let soon_dropped = String::from(\"hello\");\n    let dangling = get_str(&soon_dropped);\n    drop(soon_dropped);\n    println!(\"Invalid str: {}\", dangling); // Invalid str: g\u04da_`\n}",
        "nomicon_unbounded_lifetimes_p6": "The easiest way to avoid unbounded lifetimes is to use lifetime elision at the\nfunction boundary. If an output lifetime is elided, then it *must* be bounded by\nan input lifetime. Of course it might be bounded by the *wrong* lifetime, but\nthis will usually just cause a compiler error, rather than allow memory safety\nto be trivially violated.",
        "nomicon_unbounded_lifetimes_p7": "Within a function, bounding lifetimes is more error-prone. The safest and easiest\nway to bound a lifetime is to return it from a function with a bound lifetime.\nHowever if this is unacceptable, the reference can be placed in a location with\na specific lifetime. Unfortunately it's impossible to name all lifetimes involved\nin a function."
      }
    },
    {
      "id": "nomicon_higher_rank_trait_bounds_hrtbs",
      "title": "Higher-Rank Trait Bounds (HRTBs)",
      "level": 1,
      "content": "Rust's `Fn` traits are a little bit magic. For instance, we can write the\nfollowing code:\n\nstruct Closure<F> {\n    data: (u8, u16),\n    func: F,\n}\n\nimpl<F> Closure<F>\n    where F: Fn(&(u8, u16)) -> &u8,\n{\n    fn call(&self) -> &u8 {\n        (self.func)(&self.data)\n    }\n}\n\nfn do_it(data: &(u8, u16)) -> &u8 { &data.0 }\n\nfn main() {\n    let clo = Closure { data: (0, 1), func: do_it };\n    println!(\"{}\", clo.call());\n}\n\nIf we try to naively desugar this code in the same way that we did in the\nlifetimes section, we run into some trouble:\n\n<!-- ignore: desugared code -->\n,ignore\n// NOTE: `&'b data.0` and `'x: {` is not valid syntax!\nstruct Closure<F> {\n    data: (u8, u16),\n    func: F,\n}\n\nimpl<F> Closure<F>\n    // where F: Fn(&'??? (u8, u16)) -> &'??? u8,\n{\n    fn call<'a>(&'a self) -> &'a u8 {\n        (self.func)(&self.data)\n    }\n}\n\nfn do_it<'b>(data: &'b (u8, u16)) -> &'b u8 { &'b data.0 }\n\nfn main() {\n    'x: {\n        let clo = Closure { data: (0, 1), func: do_it };\n        println!(\"{}\", clo.call());\n    }\n}\n\nHow on earth are we supposed to express the lifetimes on `F`'s trait bound? We\nneed to provide some lifetime there, but the lifetime we care about can't be\nnamed until we enter the body of `call`! Also, that isn't some fixed lifetime;\n`call` works with *any* lifetime `&self` happens to have at that point.\n\nThis job requires The Magic of Higher-Rank Trait Bounds (HRTBs). The way we\ndesugar this is as follows:\n\n<!-- ignore: simplified code -->\n,ignore\nwhere for<'a> F: Fn(&'a (u8, u16)) -> &'a u8,\n\nAlternatively:\n\n<!-- ignore: simplified code -->\n,ignore\nwhere F: for<'a> Fn(&'a (u8, u16)) -> &'a u8,\n\n(Where `Fn(a, b, c) -> d` is itself just sugar for the unstable *real* `Fn`\ntrait)\n\n`for<'a>` can be read as \"for all choices of `'a`\", and basically produces an\n*infinite list* of trait bounds that F must satisfy. Intense. There aren't many\nplaces outside of the `Fn` traits where we encounter HRTBs, and even for\nthose we have a nice magic sugar for the common cases.\n\nIn summary, we can rewrite the original code more explicitly as:\n\nstruct Closure<F> {\n    data: (u8, u16),\n    func: F,\n}\n\nimpl<F> Closure<F>\n    where for<'a> F: Fn(&'a (u8, u16)) -> &'a u8,\n{\n    fn call(&self) -> &u8 {\n        (self.func)(&self.data)\n    }\n}\n\nfn do_it(data: &(u8, u16)) -> &u8 { &data.0 }\n\nfn main() {\n    let clo = Closure { data: (0, 1), func: do_it };\n    println!(\"{}\", clo.call());\n}\n\n[lt]: lifetimes.html",
      "parent_id": null,
      "paragraphs": {
        "nomicon_higher_rank_trait_bounds_hrtbs_p1": "Rust's `Fn` traits are a little bit magic. For instance, we can write the\nfollowing code:",
        "nomicon_higher_rank_trait_bounds_hrtbs_p2": "struct Closure<F> {\n    data: (u8, u16),\n    func: F,\n}",
        "nomicon_higher_rank_trait_bounds_hrtbs_p3": "impl<F> Closure<F>\n    where F: Fn(&(u8, u16)) -> &u8,\n{\n    fn call(&self) -> &u8 {\n        (self.func)(&self.data)\n    }\n}",
        "nomicon_higher_rank_trait_bounds_hrtbs_p4": "fn do_it(data: &(u8, u16)) -> &u8 { &data.0 }",
        "nomicon_higher_rank_trait_bounds_hrtbs_p5": "fn main() {\n    let clo = Closure { data: (0, 1), func: do_it };\n    println!(\"{}\", clo.call());\n}",
        "nomicon_higher_rank_trait_bounds_hrtbs_p6": "If we try to naively desugar this code in the same way that we did in the\nlifetimes section, we run into some trouble:",
        "nomicon_higher_rank_trait_bounds_hrtbs_p7": "<!-- ignore: desugared code -->\n,ignore\n// NOTE: `&'b data.0` and `'x: {` is not valid syntax!\nstruct Closure<F> {\n    data: (u8, u16),\n    func: F,\n}",
        "nomicon_higher_rank_trait_bounds_hrtbs_p8": "impl<F> Closure<F>\n    // where F: Fn(&'??? (u8, u16)) -> &'??? u8,\n{\n    fn call<'a>(&'a self) -> &'a u8 {\n        (self.func)(&self.data)\n    }\n}",
        "nomicon_higher_rank_trait_bounds_hrtbs_p9": "fn do_it<'b>(data: &'b (u8, u16)) -> &'b u8 { &'b data.0 }",
        "nomicon_higher_rank_trait_bounds_hrtbs_p10": "fn main() {\n    'x: {\n        let clo = Closure { data: (0, 1), func: do_it };\n        println!(\"{}\", clo.call());\n    }\n}",
        "nomicon_higher_rank_trait_bounds_hrtbs_p11": "How on earth are we supposed to express the lifetimes on `F`'s trait bound? We\nneed to provide some lifetime there, but the lifetime we care about can't be\nnamed until we enter the body of `call`! Also, that isn't some fixed lifetime;\n`call` works with *any* lifetime `&self` happens to have at that point.",
        "nomicon_higher_rank_trait_bounds_hrtbs_p12": "This job requires The Magic of Higher-Rank Trait Bounds (HRTBs). The way we\ndesugar this is as follows:",
        "nomicon_higher_rank_trait_bounds_hrtbs_p13": "<!-- ignore: simplified code -->\n,ignore\nwhere for<'a> F: Fn(&'a (u8, u16)) -> &'a u8,",
        "nomicon_higher_rank_trait_bounds_hrtbs_p14": "Alternatively:",
        "nomicon_higher_rank_trait_bounds_hrtbs_p15": "<!-- ignore: simplified code -->\n,ignore\nwhere F: for<'a> Fn(&'a (u8, u16)) -> &'a u8,",
        "nomicon_higher_rank_trait_bounds_hrtbs_p16": "(Where `Fn(a, b, c) -> d` is itself just sugar for the unstable *real* `Fn`\ntrait)",
        "nomicon_higher_rank_trait_bounds_hrtbs_p17": "`for<'a>` can be read as \"for all choices of `'a`\", and basically produces an\n*infinite list* of trait bounds that F must satisfy. Intense. There aren't many\nplaces outside of the `Fn` traits where we encounter HRTBs, and even for\nthose we have a nice magic sugar for the common cases.",
        "nomicon_higher_rank_trait_bounds_hrtbs_p18": "In summary, we can rewrite the original code more explicitly as:",
        "nomicon_higher_rank_trait_bounds_hrtbs_p19": "struct Closure<F> {\n    data: (u8, u16),\n    func: F,\n}",
        "nomicon_higher_rank_trait_bounds_hrtbs_p20": "impl<F> Closure<F>\n    where for<'a> F: Fn(&'a (u8, u16)) -> &'a u8,\n{\n    fn call(&self) -> &u8 {\n        (self.func)(&self.data)\n    }\n}",
        "nomicon_higher_rank_trait_bounds_hrtbs_p21": "fn do_it(data: &(u8, u16)) -> &u8 { &data.0 }",
        "nomicon_higher_rank_trait_bounds_hrtbs_p22": "fn main() {\n    let clo = Closure { data: (0, 1), func: do_it };\n    println!(\"{}\", clo.call());\n}",
        "nomicon_higher_rank_trait_bounds_hrtbs_p23": "[lt]: lifetimes.html"
      }
    },
    {
      "id": "nomicon_subtyping_and_variance",
      "title": "Subtyping and Variance",
      "level": 1,
      "content": "Rust uses lifetimes to track the relationships between borrows and ownership.\nHowever, a naive implementation of lifetimes would be either too restrictive,\nor permit undefined behavior.\n\nIn order to allow flexible usage of lifetimes\nwhile also preventing their misuse, Rust uses **subtyping** and **variance**.\n\nLet's start with an example.\n\n// Note: debug expects two parameters with the *same* lifetime\nfn debug<'a>(a: &'a str, b: &'a str) {\n    println!(\"a = {a:?} b = {b:?}\");\n}\n\nfn main() {\n    let hello: &'static str = \"hello\";\n    {\n        let world = String::from(\"world\");\n        let world = &world; // 'world has a shorter lifetime than 'static\n        debug(hello, world);\n    }\n}\n\nIn a conservative implementation of lifetimes, since `hello` and `world` have different lifetimes,\nwe might see the following error:\n\nerror[E0308]: mismatched types\n --> src/main.rs:10:16\n   |\n10 |         debug(hello, world);\n   |                      ^\n   |                      |\n   |                      expected `&'static str`, found struct `&'world str`\n\nThis would be rather unfortunate. In this case,\nwhat we want is to accept any type that lives *at least as long* as `'world`.\nLet's try using subtyping with our lifetimes.",
      "parent_id": null,
      "paragraphs": {
        "nomicon_subtyping_and_variance_p1": "Rust uses lifetimes to track the relationships between borrows and ownership.\nHowever, a naive implementation of lifetimes would be either too restrictive,\nor permit undefined behavior.",
        "nomicon_subtyping_and_variance_p2": "In order to allow flexible usage of lifetimes\nwhile also preventing their misuse, Rust uses **subtyping** and **variance**.",
        "nomicon_subtyping_and_variance_p3": "Let's start with an example.",
        "nomicon_subtyping_and_variance_p4": "// Note: debug expects two parameters with the *same* lifetime\nfn debug<'a>(a: &'a str, b: &'a str) {\n    println!(\"a = {a:?} b = {b:?}\");\n}",
        "nomicon_subtyping_and_variance_p5": "fn main() {\n    let hello: &'static str = \"hello\";\n    {\n        let world = String::from(\"world\");\n        let world = &world; // 'world has a shorter lifetime than 'static\n        debug(hello, world);\n    }\n}",
        "nomicon_subtyping_and_variance_p6": "In a conservative implementation of lifetimes, since `hello` and `world` have different lifetimes,\nwe might see the following error:",
        "nomicon_subtyping_and_variance_p7": "error[E0308]: mismatched types\n --> src/main.rs:10:16\n   |\n10 |         debug(hello, world);\n   |                      ^\n   |                      |\n   |                      expected `&'static str`, found struct `&'world str`",
        "nomicon_subtyping_and_variance_p8": "This would be rather unfortunate. In this case,\nwhat we want is to accept any type that lives *at least as long* as `'world`.\nLet's try using subtyping with our lifetimes."
      }
    },
    {
      "id": "nomicon_subtyping",
      "title": "Subtyping",
      "level": 2,
      "content": "Subtyping is the idea that one type can be used in place of another.\n\nLet's define that `Sub` is a subtype of `Super` (we'll be using the notation `Sub <: Super` throughout this chapter).\n\nWhat this is suggesting to us is that the set of *requirements* that `Super` defines\nare completely satisfied by `Sub`. `Sub` may then have more requirements.\n\nNow, in order to use subtyping with lifetimes, we need to define the requirement of a lifetime:\n\n> `'a` defines a region of code.\n\nNow that we have a defined set of requirements for lifetimes, we can define how they relate to each other:\n\n> `'long <: 'short` if and only if `'long` defines a region of code that **completely contains** `'short`.\n\n`'long` may define a region larger than `'short`, but that still fits our definition.\n\n> As we will see throughout the rest of this chapter,\nsubtyping is a lot more complicated and subtle than this,\nbut this simple rule is a very good 99% intuition.\nAnd unless you write unsafe code, the compiler will automatically handle all the corner cases for you.\n\n> But this is the Rustonomicon. We're writing unsafe code,\nso we need to understand how this stuff really works, and how we can mess it up.\n\nGoing back to our example above, we can say that `'static <: 'world`.\nFor now, let's also accept the idea that subtypes of lifetimes can be passed through references\n(more on this in Variance),\n_e.g._ `&'static str` is a subtype of `&'world str`, then we can \"downgrade\" `&'static str` into a `&'world str`.\nWith that, the example above will compile:\n\nfn debug<'a>(a: &'a str, b: &'a str) {\n    println!(\"a = {a:?} b = {b:?}\");\n}\n\nfn main() {\n    let hello: &'static str = \"hello\";\n    {\n        let world = String::from(\"world\");\n        let world = &world; // 'world has a shorter lifetime than 'static\n        debug(hello, world); // hello silently downgrades from `&'static str` into `&'world str`\n    }\n}",
      "parent_id": null,
      "paragraphs": {
        "nomicon_subtyping_p1": "Subtyping is the idea that one type can be used in place of another.",
        "nomicon_subtyping_p2": "Let's define that `Sub` is a subtype of `Super` (we'll be using the notation `Sub <: Super` throughout this chapter).",
        "nomicon_subtyping_p3": "What this is suggesting to us is that the set of *requirements* that `Super` defines\nare completely satisfied by `Sub`. `Sub` may then have more requirements.",
        "nomicon_subtyping_p4": "Now, in order to use subtyping with lifetimes, we need to define the requirement of a lifetime:",
        "nomicon_subtyping_p5": "> `'a` defines a region of code.",
        "nomicon_subtyping_p6": "Now that we have a defined set of requirements for lifetimes, we can define how they relate to each other:",
        "nomicon_subtyping_p7": "> `'long <: 'short` if and only if `'long` defines a region of code that **completely contains** `'short`.",
        "nomicon_subtyping_p8": "`'long` may define a region larger than `'short`, but that still fits our definition.",
        "nomicon_subtyping_p9": "> As we will see throughout the rest of this chapter,\nsubtyping is a lot more complicated and subtle than this,\nbut this simple rule is a very good 99% intuition.\nAnd unless you write unsafe code, the compiler will automatically handle all the corner cases for you.",
        "nomicon_subtyping_p10": "> But this is the Rustonomicon. We're writing unsafe code,\nso we need to understand how this stuff really works, and how we can mess it up.",
        "nomicon_subtyping_p11": "Going back to our example above, we can say that `'static <: 'world`.\nFor now, let's also accept the idea that subtypes of lifetimes can be passed through references\n(more on this in Variance),\n_e.g._ `&'static str` is a subtype of `&'world str`, then we can \"downgrade\" `&'static str` into a `&'world str`.\nWith that, the example above will compile:",
        "nomicon_subtyping_p12": "fn debug<'a>(a: &'a str, b: &'a str) {\n    println!(\"a = {a:?} b = {b:?}\");\n}",
        "nomicon_subtyping_p13": "fn main() {\n    let hello: &'static str = \"hello\";\n    {\n        let world = String::from(\"world\");\n        let world = &world; // 'world has a shorter lifetime than 'static\n        debug(hello, world); // hello silently downgrades from `&'static str` into `&'world str`\n    }\n}"
      }
    },
    {
      "id": "nomicon_variance",
      "title": "Variance",
      "level": 2,
      "content": "Above, we glossed over the fact that `'static <: 'b` implied that `&'static T <: &'b T`. This uses a property known as _variance_.\nIt's not always as simple as this example, though. To understand that, let's try to extend this example a bit:\n\n,compile_fail,E0597\nfn assign<T>(input: &mut T, val: T) {\n    *input = val;\n}\n\nfn main() {\n    let mut hello: &'static str = \"hello\";\n    {\n        let world = String::from(\"world\");\n        assign(&mut hello, &world);\n    }\n    println!(\"{hello}\"); // use after free \ud83d\ude3f\n}\n\nIn `assign`, we are setting the `hello` reference to point to `world`.\nBut then `world` goes out of scope, before the later use of `hello` in the println!\n\nThis is a classic use-after-free bug!\n\nOur first instinct might be to blame the `assign` impl, but there's really nothing wrong here.\nIt shouldn't be surprising that we might want to assign a `T` into a `T`.\n\nThe problem is that we cannot assume that `&mut &'static str` and `&mut &'b str` are compatible.\nThis means that `&mut &'static str` **cannot** be a *subtype* of `&mut &'b str`,\neven if `'static` is a subtype of `'b`.\n\nVariance is the concept that Rust borrows to define relationships about subtypes through their generic parameters.\n\n> NOTE: For convenience we will define a generic type `F<T>` so\n> that we can easily talk about `T`. Hopefully this is clear in context.\n\nThe type `F`'s *variance* is how the subtyping of its inputs affects the\nsubtyping of its outputs. There are three kinds of variance in Rust. Given two\ntypes `Sub` and `Super`, where `Sub` is a subtype of `Super`:\n\n* `F` is **covariant** if `F<Sub>` is a subtype of `F<Super>` (the subtype property is passed through)\n* `F` is **contravariant** if `F<Super>` is a subtype of `F<Sub>` (the subtype property is \"inverted\")\n* `F` is **invariant** otherwise (no subtyping relationship exists)\n\nIf we remember from the above examples,\nit was ok for us to treat `&'a T` as a subtype of `&'b T` if `'a <: 'b`,\ntherefore we can say that `&'a T` is *covariant* over `'a`.\n\nAlso, we saw that it was not ok for us to treat `&mut &'a T` as a subtype of `&mut &'b T`,\ntherefore we can say that `&mut T` is *invariant* over `T`\n\nHere is a table of some other generic types and their variances:\n\n|                 |     'a    |         T         |     U     |\n|-----------------|:---------:|:-----------------:|:---------:|\n| `&'a T `        | covariant | covariant         |           |\n| `&'a mut T`     | covariant | invariant         |           |\n| `Box<T>`        |           | covariant         |           |\n| `Vec<T>`        |           | covariant         |           |\n| `UnsafeCell<T>` |           | invariant         |           |\n| `Cell<T>`       |           | invariant         |           |\n| `fn(T) -> U`    |           | **contra**variant | covariant |\n| `*const T`      |           | covariant         |           |\n| `*mut T`        |           | invariant         |           |\n\nSome of these can be explained simply in relation to the others:\n\n* `Vec<T>` and all other owning pointers and collections follow the same logic as `Box<T>`\n* `Cell<T>` and all other interior mutability types follow the same logic as `UnsafeCell<T>`\n* `UnsafeCell<T>` having interior mutability gives it the same variance properties as `&mut T`\n* `*const T` follows the logic of `&T`\n* `*mut T` follows the logic of `&mut T` (or `UnsafeCell<T>`)\n\nFor more types, see the \"Variance\" section on the reference.\n\n[variance-table]: ../reference/subtyping.html#variance\n\n> NOTE: the *only* source of contravariance in the language is the arguments to\n> a function, which is why it really doesn't come up much in practice. Invoking\n> contravariance involves higher-order programming with function pointers that\n> take references with specific lifetimes (as opposed to the usual \"any lifetime\",\n> which gets into higher rank lifetimes, which work independently of subtyping).\n\nNow that we have some more formal understanding of variance,\nlet's go through some more examples in more detail.\n\n,compile_fail,E0597\nfn assign<T>(input: &mut T, val: T) {\n    *input = val;\n}\n\nfn main() {\n    let mut hello: &'static str = \"hello\";\n    {\n        let world = String::from(\"world\");\n        assign(&mut hello, &world);\n    }\n    println!(\"{hello}\");\n}\n\nAnd what do we get when we run this?\n\nerror[E0597]: `world` does not live long enough\n  --> src/main.rs:9:28\n   |\n6  |     let mut hello: &'static str = \"hello\";\n   |                    ------------ type annotation requires that `world` is borrowed for `'static`\n...\n9  |         assign(&mut hello, &world);\n   |                            ^^^^^^ borrowed value does not live long enough\n10 |     }\n   |     - `world` dropped here while still borrowed\n\nGood, it doesn't compile! Let's break down what's happening here in detail.\n\nFirst let's look at the `assign` function:\n\nfn assign<T>(input: &mut T, val: T) {\n    *input = val;\n}\n\nAll it does is take a mutable reference and a value and overwrite the referent with it.\nWhat's important about this function is that it creates a type equality constraint. It\nclearly says in its signature the referent and the value must be the *exact same* type.\n\nMeanwhile, in the caller we pass in `&mut &'static str` and `&'world str`.\n\nBecause `&mut T` is invariant over `T`, the compiler concludes it can't apply any subtyping\nto the first argument, and so `T` must be exactly `&'static str`.\n\nThis is counter to the `&T` case:\n\nfn debug<T: std::fmt::Debug>(a: T, b: T) {\n    println!(\"a = {a:?} b = {b:?}\");\n}\n\nwhere similarly `a` and `b` must have the same type `T`.\nBut since `&'a T` *is* covariant over `'a`, we are allowed to perform subtyping.\nSo the compiler decides that `&'static str` can become `&'b str` if and only if\n`&'static str` is a subtype of `&'b str`, which will hold if `'static <: 'b`.\nThis is true, so the compiler is happy to continue compiling this code.\n\nAs it turns out, the argument for why it's ok for Box (and Vec, HashMap, etc.) to be covariant is pretty similar to the argument for why it's ok for lifetimes to be covariant: as soon as you try to stuff them in something like a mutable reference, they inherit invariance and you're prevented from doing anything bad.\n\nHowever Box makes it easier to focus on the by-value aspect of references that we partially glossed over.\n\nUnlike a lot of languages which allow values to be freely aliased at all times, Rust has a very strict rule: if you're allowed to mutate or move a value, you are guaranteed to be the only one with access to it.\n\nConsider the following code:\n\n,ignore\nlet hello: Box<&'static str> = Box::new(\"hello\");\n\nlet mut world: Box<&'b str>;\nworld = hello;\n\nThere is no problem at all with the fact that we have forgotten that `hello` was alive for `'static`,\nbecause as soon as we moved `hello` to a variable that only knew it was alive for `'b`,\n**we destroyed the only thing in the universe that remembered it lived for longer**!\n\nOnly one thing left to explain: function pointers.\n\nTo see why `fn(T) -> U` should be covariant over `U`, consider the following signature:\n\n<!-- ignore: simplified code -->\n,ignore\nfn get_str() -> &'a str;\n\nThis function claims to produce a `str` bound by some lifetime `'a`. As such, it is perfectly valid to\nprovide a function with the following signature instead:\n\n<!-- ignore: simplified code -->\n,ignore\nfn get_static() -> &'static str;\n\nSo when the function is called, all it's expecting is a `&str` which lives at least the lifetime of `'a`,\nit doesn't matter if the value actually lives longer.\n\nHowever, the same logic does not apply to *arguments*. Consider trying to satisfy:\n\n<!-- ignore: simplified code -->\n,ignore\nfn store_ref(&'a str);\n\nwith:\n\n<!-- ignore: simplified code -->\n,ignore\nfn store_static(&'static str);\n\nThe first function can accept any string reference as long as it lives at least for `'a`,\nbut the second cannot accept a string reference that lives for any duration less than `'static`,\nwhich would cause a conflict.\nCovariance doesn't work here. But if we flip it around, it actually *does*\nwork! If we need a function that can handle `&'static str`, a function that can handle *any* reference lifetime\nwill surely work fine.\n\nLet's see this in practice\n\n,compile_fail",
      "parent_id": null,
      "paragraphs": {
        "nomicon_variance_p1": "Above, we glossed over the fact that `'static <: 'b` implied that `&'static T <: &'b T`. This uses a property known as _variance_.\nIt's not always as simple as this example, though. To understand that, let's try to extend this example a bit:",
        "nomicon_variance_p2": ",compile_fail,E0597\nfn assign<T>(input: &mut T, val: T) {\n    *input = val;\n}",
        "nomicon_variance_p3": "fn main() {\n    let mut hello: &'static str = \"hello\";\n    {\n        let world = String::from(\"world\");\n        assign(&mut hello, &world);\n    }\n    println!(\"{hello}\"); // use after free \ud83d\ude3f\n}",
        "nomicon_variance_p4": "In `assign`, we are setting the `hello` reference to point to `world`.\nBut then `world` goes out of scope, before the later use of `hello` in the println!",
        "nomicon_variance_p5": "This is a classic use-after-free bug!",
        "nomicon_variance_p6": "Our first instinct might be to blame the `assign` impl, but there's really nothing wrong here.\nIt shouldn't be surprising that we might want to assign a `T` into a `T`.",
        "nomicon_variance_p7": "The problem is that we cannot assume that `&mut &'static str` and `&mut &'b str` are compatible.\nThis means that `&mut &'static str` **cannot** be a *subtype* of `&mut &'b str`,\neven if `'static` is a subtype of `'b`.",
        "nomicon_variance_p8": "Variance is the concept that Rust borrows to define relationships about subtypes through their generic parameters.",
        "nomicon_variance_p9": "> NOTE: For convenience we will define a generic type `F<T>` so\n> that we can easily talk about `T`. Hopefully this is clear in context.",
        "nomicon_variance_p10": "The type `F`'s *variance* is how the subtyping of its inputs affects the\nsubtyping of its outputs. There are three kinds of variance in Rust. Given two\ntypes `Sub` and `Super`, where `Sub` is a subtype of `Super`:",
        "nomicon_variance_p11": "* `F` is **covariant** if `F<Sub>` is a subtype of `F<Super>` (the subtype property is passed through)\n* `F` is **contravariant** if `F<Super>` is a subtype of `F<Sub>` (the subtype property is \"inverted\")\n* `F` is **invariant** otherwise (no subtyping relationship exists)",
        "nomicon_variance_p12": "If we remember from the above examples,\nit was ok for us to treat `&'a T` as a subtype of `&'b T` if `'a <: 'b`,\ntherefore we can say that `&'a T` is *covariant* over `'a`.",
        "nomicon_variance_p13": "Also, we saw that it was not ok for us to treat `&mut &'a T` as a subtype of `&mut &'b T`,\ntherefore we can say that `&mut T` is *invariant* over `T`",
        "nomicon_variance_p14": "Here is a table of some other generic types and their variances:",
        "nomicon_variance_p15": "|                 |     'a    |         T         |     U     |\n|-----------------|:---------:|:-----------------:|:---------:|\n| `&'a T `        | covariant | covariant         |           |\n| `&'a mut T`     | covariant | invariant         |           |\n| `Box<T>`        |           | covariant         |           |\n| `Vec<T>`        |           | covariant         |           |\n| `UnsafeCell<T>` |           | invariant         |           |\n| `Cell<T>`       |           | invariant         |           |\n| `fn(T) -> U`    |           | **contra**variant | covariant |\n| `*const T`      |           | covariant         |           |\n| `*mut T`        |           | invariant         |           |",
        "nomicon_variance_p16": "Some of these can be explained simply in relation to the others:",
        "nomicon_variance_p17": "* `Vec<T>` and all other owning pointers and collections follow the same logic as `Box<T>`\n* `Cell<T>` and all other interior mutability types follow the same logic as `UnsafeCell<T>`\n* `UnsafeCell<T>` having interior mutability gives it the same variance properties as `&mut T`\n* `*const T` follows the logic of `&T`\n* `*mut T` follows the logic of `&mut T` (or `UnsafeCell<T>`)",
        "nomicon_variance_p18": "For more types, see the \"Variance\" section on the reference.",
        "nomicon_variance_p19": "[variance-table]: ../reference/subtyping.html#variance",
        "nomicon_variance_p20": "> NOTE: the *only* source of contravariance in the language is the arguments to\n> a function, which is why it really doesn't come up much in practice. Invoking\n> contravariance involves higher-order programming with function pointers that\n> take references with specific lifetimes (as opposed to the usual \"any lifetime\",\n> which gets into higher rank lifetimes, which work independently of subtyping).",
        "nomicon_variance_p21": "Now that we have some more formal understanding of variance,\nlet's go through some more examples in more detail.",
        "nomicon_variance_p22": ",compile_fail,E0597\nfn assign<T>(input: &mut T, val: T) {\n    *input = val;\n}",
        "nomicon_variance_p23": "fn main() {\n    let mut hello: &'static str = \"hello\";\n    {\n        let world = String::from(\"world\");\n        assign(&mut hello, &world);\n    }\n    println!(\"{hello}\");\n}",
        "nomicon_variance_p24": "And what do we get when we run this?",
        "nomicon_variance_p25": "error[E0597]: `world` does not live long enough\n  --> src/main.rs:9:28\n   |\n6  |     let mut hello: &'static str = \"hello\";\n   |                    ------------ type annotation requires that `world` is borrowed for `'static`\n...\n9  |         assign(&mut hello, &world);\n   |                            ^^^^^^ borrowed value does not live long enough\n10 |     }\n   |     - `world` dropped here while still borrowed",
        "nomicon_variance_p26": "Good, it doesn't compile! Let's break down what's happening here in detail.",
        "nomicon_variance_p27": "First let's look at the `assign` function:",
        "nomicon_variance_p28": "fn assign<T>(input: &mut T, val: T) {\n    *input = val;\n}",
        "nomicon_variance_p29": "All it does is take a mutable reference and a value and overwrite the referent with it.\nWhat's important about this function is that it creates a type equality constraint. It\nclearly says in its signature the referent and the value must be the *exact same* type.",
        "nomicon_variance_p30": "Meanwhile, in the caller we pass in `&mut &'static str` and `&'world str`.",
        "nomicon_variance_p31": "Because `&mut T` is invariant over `T`, the compiler concludes it can't apply any subtyping\nto the first argument, and so `T` must be exactly `&'static str`.",
        "nomicon_variance_p32": "This is counter to the `&T` case:",
        "nomicon_variance_p33": "fn debug<T: std::fmt::Debug>(a: T, b: T) {\n    println!(\"a = {a:?} b = {b:?}\");\n}",
        "nomicon_variance_p34": "where similarly `a` and `b` must have the same type `T`.\nBut since `&'a T` *is* covariant over `'a`, we are allowed to perform subtyping.\nSo the compiler decides that `&'static str` can become `&'b str` if and only if\n`&'static str` is a subtype of `&'b str`, which will hold if `'static <: 'b`.\nThis is true, so the compiler is happy to continue compiling this code.",
        "nomicon_variance_p35": "As it turns out, the argument for why it's ok for Box (and Vec, HashMap, etc.) to be covariant is pretty similar to the argument for why it's ok for lifetimes to be covariant: as soon as you try to stuff them in something like a mutable reference, they inherit invariance and you're prevented from doing anything bad.",
        "nomicon_variance_p36": "However Box makes it easier to focus on the by-value aspect of references that we partially glossed over.",
        "nomicon_variance_p37": "Unlike a lot of languages which allow values to be freely aliased at all times, Rust has a very strict rule: if you're allowed to mutate or move a value, you are guaranteed to be the only one with access to it.",
        "nomicon_variance_p38": "Consider the following code:",
        "nomicon_variance_p39": ",ignore\nlet hello: Box<&'static str> = Box::new(\"hello\");",
        "nomicon_variance_p40": "let mut world: Box<&'b str>;\nworld = hello;",
        "nomicon_variance_p41": "There is no problem at all with the fact that we have forgotten that `hello` was alive for `'static`,\nbecause as soon as we moved `hello` to a variable that only knew it was alive for `'b`,\n**we destroyed the only thing in the universe that remembered it lived for longer**!",
        "nomicon_variance_p42": "Only one thing left to explain: function pointers.",
        "nomicon_variance_p43": "To see why `fn(T) -> U` should be covariant over `U`, consider the following signature:",
        "nomicon_variance_p44": "<!-- ignore: simplified code -->\n,ignore\nfn get_str() -> &'a str;",
        "nomicon_variance_p45": "This function claims to produce a `str` bound by some lifetime `'a`. As such, it is perfectly valid to\nprovide a function with the following signature instead:",
        "nomicon_variance_p46": "<!-- ignore: simplified code -->\n,ignore\nfn get_static() -> &'static str;",
        "nomicon_variance_p47": "So when the function is called, all it's expecting is a `&str` which lives at least the lifetime of `'a`,\nit doesn't matter if the value actually lives longer.",
        "nomicon_variance_p48": "However, the same logic does not apply to *arguments*. Consider trying to satisfy:",
        "nomicon_variance_p49": "<!-- ignore: simplified code -->\n,ignore\nfn store_ref(&'a str);",
        "nomicon_variance_p50": "with:",
        "nomicon_variance_p51": "<!-- ignore: simplified code -->\n,ignore\nfn store_static(&'static str);",
        "nomicon_variance_p52": "The first function can accept any string reference as long as it lives at least for `'a`,\nbut the second cannot accept a string reference that lives for any duration less than `'static`,\nwhich would cause a conflict.\nCovariance doesn't work here. But if we flip it around, it actually *does*\nwork! If we need a function that can handle `&'static str`, a function that can handle *any* reference lifetime\nwill surely work fine.",
        "nomicon_variance_p53": "Let's see this in practice",
        "nomicon_variance_p54": ",compile_fail"
      }
    },
    {
      "id": "nomicon_use_std_cell_refcell",
      "title": "use std::cell::RefCell;",
      "level": 1,
      "content": "thread_local! {\n    pub static StaticVecs: RefCell<Vec<&'static str>> = RefCell::new(Vec::new());\n}\n\n/// saves the input given into a thread local `Vec<&'static str>`\nfn store(input: &'static str) {\n    StaticVecs.with_borrow_mut(|v| v.push(input));\n}\n\n/// Calls the function with it's input (must have the same lifetime!)\nfn demo<'a>(input: &'a str, f: fn(&'a str)) {\n    f(input);\n}\n\nfn main() {\n    demo(\"hello\", store); // \"hello\" is 'static. Can call `store` fine\n\n    {\n        let smuggle = String::from(\"smuggle\");\n\n        // `&smuggle` is not static. If we were to call `store` with `&smuggle`,\n        // we would have pushed an invalid lifetime into the `StaticVecs`.\n        // Therefore, `fn(&'static str)` cannot be a subtype of `fn(&'a str)`\n        demo(&smuggle, store);\n    }\n\n    // use after free \ud83d\ude3f\n    StaticVecs.with_borrow(|v| println!(\"{v:?}\"));\n}\n\nAnd that's why function types, unlike anything else in the language, are\n**contra**variant over their arguments.\n\nNow, this is all well and good for the types the standard library provides, but\nhow is variance determined for types that *you* define? A struct, informally\nspeaking, inherits the variance of its fields. If a struct `MyType`\nhas a generic argument `A` that is used in a field `a`, then MyType's variance\nover `A` is exactly `a`'s variance over `A`.\n\nHowever if `A` is used in multiple fields:\n\n* If all uses of `A` are covariant, then MyType is covariant over `A`\n* If all uses of `A` are contravariant, then MyType is contravariant over `A`\n* Otherwise, MyType is invariant over `A`\n\nuse std::cell::Cell;\n\nstruct MyType<'a, 'b, A: 'a, B: 'b, C, D, E, F, G, H, In, Out, Mixed> {\n    a: &'a A,     // covariant over 'a and A\n    b: &'b mut B, // covariant over 'b and invariant over B\n\n    c: *const C,  // covariant over C\n    d: *mut D,    // invariant over D\n\n    e: E,         // covariant over E\n    f: Vec<F>,    // covariant over F\n    g: Cell<G>,   // invariant over G\n\n    h1: H,        // would also be covariant over H except...\n    h2: Cell<H>,  // invariant over H, because invariance wins all conflicts\n\n    i: fn(In) -> Out,       // contravariant over In, covariant over Out\n\n    k1: fn(Mixed) -> usize, // would be contravariant over Mixed except..\n    k2: Mixed,              // invariant over Mixed, because invariance wins all conflicts\n}",
      "parent_id": null,
      "paragraphs": {
        "nomicon_use_std_cell_refcell_p1": "thread_local! {\n    pub static StaticVecs: RefCell<Vec<&'static str>> = RefCell::new(Vec::new());\n}",
        "nomicon_use_std_cell_refcell_p2": "/// saves the input given into a thread local `Vec<&'static str>`\nfn store(input: &'static str) {\n    StaticVecs.with_borrow_mut(|v| v.push(input));\n}",
        "nomicon_use_std_cell_refcell_p3": "/// Calls the function with it's input (must have the same lifetime!)\nfn demo<'a>(input: &'a str, f: fn(&'a str)) {\n    f(input);\n}",
        "nomicon_use_std_cell_refcell_p4": "fn main() {\n    demo(\"hello\", store); // \"hello\" is 'static. Can call `store` fine",
        "nomicon_use_std_cell_refcell_p5": "{\n        let smuggle = String::from(\"smuggle\");",
        "nomicon_use_std_cell_refcell_p6": "// `&smuggle` is not static. If we were to call `store` with `&smuggle`,\n        // we would have pushed an invalid lifetime into the `StaticVecs`.\n        // Therefore, `fn(&'static str)` cannot be a subtype of `fn(&'a str)`\n        demo(&smuggle, store);\n    }",
        "nomicon_use_std_cell_refcell_p7": "// use after free \ud83d\ude3f\n    StaticVecs.with_borrow(|v| println!(\"{v:?}\"));\n}",
        "nomicon_use_std_cell_refcell_p8": "And that's why function types, unlike anything else in the language, are\n**contra**variant over their arguments.",
        "nomicon_use_std_cell_refcell_p9": "Now, this is all well and good for the types the standard library provides, but\nhow is variance determined for types that *you* define? A struct, informally\nspeaking, inherits the variance of its fields. If a struct `MyType`\nhas a generic argument `A` that is used in a field `a`, then MyType's variance\nover `A` is exactly `a`'s variance over `A`.",
        "nomicon_use_std_cell_refcell_p10": "However if `A` is used in multiple fields:",
        "nomicon_use_std_cell_refcell_p11": "* If all uses of `A` are covariant, then MyType is covariant over `A`\n* If all uses of `A` are contravariant, then MyType is contravariant over `A`\n* Otherwise, MyType is invariant over `A`",
        "nomicon_use_std_cell_refcell_p12": "use std::cell::Cell;",
        "nomicon_use_std_cell_refcell_p13": "struct MyType<'a, 'b, A: 'a, B: 'b, C, D, E, F, G, H, In, Out, Mixed> {\n    a: &'a A,     // covariant over 'a and A\n    b: &'b mut B, // covariant over 'b and invariant over B",
        "nomicon_use_std_cell_refcell_p14": "c: *const C,  // covariant over C\n    d: *mut D,    // invariant over D",
        "nomicon_use_std_cell_refcell_p15": "e: E,         // covariant over E\n    f: Vec<F>,    // covariant over F\n    g: Cell<G>,   // invariant over G",
        "nomicon_use_std_cell_refcell_p16": "h1: H,        // would also be covariant over H except...\n    h2: Cell<H>,  // invariant over H, because invariance wins all conflicts",
        "nomicon_use_std_cell_refcell_p17": "i: fn(In) -> Out,       // contravariant over In, covariant over Out",
        "nomicon_use_std_cell_refcell_p18": "k1: fn(Mixed) -> usize, // would be contravariant over Mixed except..\n    k2: Mixed,              // invariant over Mixed, because invariance wins all conflicts\n}"
      }
    },
    {
      "id": "nomicon_drop_check",
      "title": "Drop Check",
      "level": 1,
      "content": "We have seen how lifetimes provide us some fairly simple rules for ensuring\nthat we never read dangling references. However up to this point we have only ever\ninteracted with the _outlives_ relationship in an inclusive manner. That is,\nwhen we talked about `'a: 'b`, it was ok for `'a` to live _exactly_ as long as\n`'b`. At first glance, this seems to be a meaningless distinction. Nothing ever\ngets dropped at the same time as another, right? This is why we used the\nfollowing desugaring of `let` statements:\n\n<!-- ignore: simplified code -->\n,ignore\nlet x;\nlet y;\n\ndesugaring to:\n\n<!-- ignore: desugared code -->\n,ignore\n{\n    let x;\n    {\n        let y;\n    }\n}\n\nThere are some more complex situations which are not possible to desugar using\nscopes, but the order is still defined \u2012 variables are dropped in the reverse\norder of their definition, fields of structs and tuples in order of their\ndefinition. There are some more details about order of drop in RFC 1857.\n\nLet's do this:\n\n<!-- ignore: simplified code -->\n,ignore\nlet tuple = (vec![], vec![]);\n\nThe left vector is dropped first. But does it mean the right one strictly\noutlives it in the eyes of the borrow checker? The answer to this question is\n_no_. The borrow checker could track fields of tuples separately, but it would\nstill be unable to decide what outlives what in case of vector elements, which\nare dropped manually via pure-library code the borrow checker doesn't\nunderstand.\n\nSo why do we care? We care because if the type system isn't careful, it could\naccidentally make dangling pointers. Consider the following simple program:\n\nstruct Inspector<'a>(&'a u8);\n\nstruct World<'a> {\n    inspector: Option<Inspector<'a>>,\n    days: Box<u8>,\n}\n\nfn main() {\n    let mut world = World {\n        inspector: None,\n        days: Box::new(1),\n    };\n    world.inspector = Some(Inspector(&world.days));\n}\n\nThis program is totally sound and compiles today. The fact that `days` does not\nstrictly outlive `inspector` doesn't matter. As long as the `inspector` is\nalive, so is `days`.\n\nHowever if we add a destructor, the program will no longer compile!\n\n,compile_fail\nstruct Inspector<'a>(&'a u8);\n\nimpl<'a> Drop for Inspector<'a> {\n    fn drop(&mut self) {\n        println!(\"I was only {} days from retirement!\", self.0);\n    }\n}\n\nstruct World<'a> {\n    inspector: Option<Inspector<'a>>,\n    days: Box<u8>,\n}\n\nfn main() {\n    let mut world = World {\n        inspector: None,\n        days: Box::new(1),\n    };\n    world.inspector = Some(Inspector(&world.days));\n    // Let's say `days` happens to get dropped first.\n    // Then when Inspector is dropped, it will try to read free'd memory!\n}\n\nerror[E0597]: `world.days` does not live long enough\n  --> src/main.rs:19:38\n   |\n19 |     world.inspector = Some(Inspector(&world.days));\n   |                                      ^^^^^^^^^^^ borrowed value does not live long enough\n...\n22 | }\n   | -\n   | |\n   | `world.days` dropped here while still borrowed\n   | borrow might be used here, when `world` is dropped and runs the destructor for type `World<'_>`\n\nYou can try changing the order of fields or use a tuple instead of the struct,\nit'll still not compile.\n\nImplementing `Drop` lets the `Inspector` execute some arbitrary code during its\ndeath. This means it can potentially observe that types that are supposed to\nlive as long as it does actually were destroyed first.\n\nInterestingly, only generic types need to worry about this. If they aren't\ngeneric, then the only lifetimes they can harbor are `'static`, which will truly\nlive _forever_. This is why this problem is referred to as _sound generic drop_.\nSound generic drop is enforced by the _drop checker_. As of this writing, some\nof the finer details of how the drop checker (also called dropck) validates\ntypes is totally up in the air. However The Big Rule is the subtlety that we\nhave focused on this whole section:\n\n**For a generic type to soundly implement drop, its generics arguments must\nstrictly outlive it.**\n\nObeying this rule is (usually) necessary to satisfy the borrow\nchecker; obeying it is sufficient but not necessary to be\nsound. That is, if your type obeys this rule then it's definitely\nsound to drop.\n\nThe reason that it is not always necessary to satisfy the above rule\nis that some Drop implementations will not access borrowed data even\nthough their type gives them the capability for such access, or because we know\nthe specific drop order and the borrowed data is still fine even if the borrow\nchecker doesn't know that.\n\nFor example, this variant of the above `Inspector` example will never\naccess borrowed data:\n\n,compile_fail\nstruct Inspector<'a>(&'a u8, &'static str);\n\nimpl<'a> Drop for Inspector<'a> {\n    fn drop(&mut self) {\n        println!(\"Inspector(_, {}) knows when *not* to inspect.\", self.1);\n    }\n}\n\nstruct World<'a> {\n    inspector: Option<Inspector<'a>>,\n    days: Box<u8>,\n}\n\nfn main() {\n    let mut world = World {\n        inspector: None,\n        days: Box::new(1),\n    };\n    world.inspector = Some(Inspector(&world.days, \"gadget\"));\n    // Let's say `days` happens to get dropped first.\n    // Even when Inspector is dropped, its destructor will not access the\n    // borrowed `days`.\n}\n\nLikewise, this variant will also never access borrowed data:\n\n,compile_fail\nstruct Inspector<T>(T, &'static str);\n\nimpl<T> Drop for Inspector<T> {\n    fn drop(&mut self) {\n        println!(\"Inspector(_, {}) knows when *not* to inspect.\", self.1);\n    }\n}\n\nstruct World<T> {\n    inspector: Option<Inspector<T>>,\n    days: Box<u8>,\n}\n\nfn main() {\n    let mut world = World {\n        inspector: None,\n        days: Box::new(1),\n    };\n    world.inspector = Some(Inspector(&world.days, \"gadget\"));\n    // Let's say `days` happens to get dropped first.\n    // Even when Inspector is dropped, its destructor will not access the\n    // borrowed `days`.\n}\n\nHowever, _both_ of the above variants are rejected by the borrow\nchecker during the analysis of `fn main`, saying that `days` does not\nlive long enough.\n\nThe reason is that the borrow checking analysis of `main` does not\nknow about the internals of each `Inspector`'s `Drop` implementation. As\nfar as the borrow checker knows while it is analyzing `main`, the body\nof an inspector's destructor might access that borrowed data.\n\nTherefore, the drop checker forces all borrowed data in a value to\nstrictly outlive that value.",
      "parent_id": null,
      "paragraphs": {
        "nomicon_drop_check_p1": "We have seen how lifetimes provide us some fairly simple rules for ensuring\nthat we never read dangling references. However up to this point we have only ever\ninteracted with the _outlives_ relationship in an inclusive manner. That is,\nwhen we talked about `'a: 'b`, it was ok for `'a` to live _exactly_ as long as\n`'b`. At first glance, this seems to be a meaningless distinction. Nothing ever\ngets dropped at the same time as another, right? This is why we used the\nfollowing desugaring of `let` statements:",
        "nomicon_drop_check_p2": "<!-- ignore: simplified code -->\n,ignore\nlet x;\nlet y;",
        "nomicon_drop_check_p3": "desugaring to:",
        "nomicon_drop_check_p4": "<!-- ignore: desugared code -->\n,ignore\n{\n    let x;\n    {\n        let y;\n    }\n}",
        "nomicon_drop_check_p5": "There are some more complex situations which are not possible to desugar using\nscopes, but the order is still defined \u2012 variables are dropped in the reverse\norder of their definition, fields of structs and tuples in order of their\ndefinition. There are some more details about order of drop in RFC 1857.",
        "nomicon_drop_check_p6": "Let's do this:",
        "nomicon_drop_check_p7": "<!-- ignore: simplified code -->\n,ignore\nlet tuple = (vec![], vec![]);",
        "nomicon_drop_check_p8": "The left vector is dropped first. But does it mean the right one strictly\noutlives it in the eyes of the borrow checker? The answer to this question is\n_no_. The borrow checker could track fields of tuples separately, but it would\nstill be unable to decide what outlives what in case of vector elements, which\nare dropped manually via pure-library code the borrow checker doesn't\nunderstand.",
        "nomicon_drop_check_p9": "So why do we care? We care because if the type system isn't careful, it could\naccidentally make dangling pointers. Consider the following simple program:",
        "nomicon_drop_check_p10": "struct Inspector<'a>(&'a u8);",
        "nomicon_drop_check_p11": "struct World<'a> {\n    inspector: Option<Inspector<'a>>,\n    days: Box<u8>,\n}",
        "nomicon_drop_check_p12": "fn main() {\n    let mut world = World {\n        inspector: None,\n        days: Box::new(1),\n    };\n    world.inspector = Some(Inspector(&world.days));\n}",
        "nomicon_drop_check_p13": "This program is totally sound and compiles today. The fact that `days` does not\nstrictly outlive `inspector` doesn't matter. As long as the `inspector` is\nalive, so is `days`.",
        "nomicon_drop_check_p14": "However if we add a destructor, the program will no longer compile!",
        "nomicon_drop_check_p15": ",compile_fail\nstruct Inspector<'a>(&'a u8);",
        "nomicon_drop_check_p16": "impl<'a> Drop for Inspector<'a> {\n    fn drop(&mut self) {\n        println!(\"I was only {} days from retirement!\", self.0);\n    }\n}",
        "nomicon_drop_check_p17": "struct World<'a> {\n    inspector: Option<Inspector<'a>>,\n    days: Box<u8>,\n}",
        "nomicon_drop_check_p18": "fn main() {\n    let mut world = World {\n        inspector: None,\n        days: Box::new(1),\n    };\n    world.inspector = Some(Inspector(&world.days));\n    // Let's say `days` happens to get dropped first.\n    // Then when Inspector is dropped, it will try to read free'd memory!\n}",
        "nomicon_drop_check_p19": "error[E0597]: `world.days` does not live long enough\n  --> src/main.rs:19:38\n   |\n19 |     world.inspector = Some(Inspector(&world.days));\n   |                                      ^^^^^^^^^^^ borrowed value does not live long enough\n...\n22 | }\n   | -\n   | |\n   | `world.days` dropped here while still borrowed\n   | borrow might be used here, when `world` is dropped and runs the destructor for type `World<'_>`",
        "nomicon_drop_check_p20": "You can try changing the order of fields or use a tuple instead of the struct,\nit'll still not compile.",
        "nomicon_drop_check_p21": "Implementing `Drop` lets the `Inspector` execute some arbitrary code during its\ndeath. This means it can potentially observe that types that are supposed to\nlive as long as it does actually were destroyed first.",
        "nomicon_drop_check_p22": "Interestingly, only generic types need to worry about this. If they aren't\ngeneric, then the only lifetimes they can harbor are `'static`, which will truly\nlive _forever_. This is why this problem is referred to as _sound generic drop_.\nSound generic drop is enforced by the _drop checker_. As of this writing, some\nof the finer details of how the drop checker (also called dropck) validates\ntypes is totally up in the air. However The Big Rule is the subtlety that we\nhave focused on this whole section:",
        "nomicon_drop_check_p23": "**For a generic type to soundly implement drop, its generics arguments must\nstrictly outlive it.**",
        "nomicon_drop_check_p24": "Obeying this rule is (usually) necessary to satisfy the borrow\nchecker; obeying it is sufficient but not necessary to be\nsound. That is, if your type obeys this rule then it's definitely\nsound to drop.",
        "nomicon_drop_check_p25": "The reason that it is not always necessary to satisfy the above rule\nis that some Drop implementations will not access borrowed data even\nthough their type gives them the capability for such access, or because we know\nthe specific drop order and the borrowed data is still fine even if the borrow\nchecker doesn't know that.",
        "nomicon_drop_check_p26": "For example, this variant of the above `Inspector` example will never\naccess borrowed data:",
        "nomicon_drop_check_p27": ",compile_fail\nstruct Inspector<'a>(&'a u8, &'static str);",
        "nomicon_drop_check_p28": "impl<'a> Drop for Inspector<'a> {\n    fn drop(&mut self) {\n        println!(\"Inspector(_, {}) knows when *not* to inspect.\", self.1);\n    }\n}",
        "nomicon_drop_check_p29": "struct World<'a> {\n    inspector: Option<Inspector<'a>>,\n    days: Box<u8>,\n}",
        "nomicon_drop_check_p30": "fn main() {\n    let mut world = World {\n        inspector: None,\n        days: Box::new(1),\n    };\n    world.inspector = Some(Inspector(&world.days, \"gadget\"));\n    // Let's say `days` happens to get dropped first.\n    // Even when Inspector is dropped, its destructor will not access the\n    // borrowed `days`.\n}",
        "nomicon_drop_check_p31": "Likewise, this variant will also never access borrowed data:",
        "nomicon_drop_check_p32": ",compile_fail\nstruct Inspector<T>(T, &'static str);",
        "nomicon_drop_check_p33": "impl<T> Drop for Inspector<T> {\n    fn drop(&mut self) {\n        println!(\"Inspector(_, {}) knows when *not* to inspect.\", self.1);\n    }\n}",
        "nomicon_drop_check_p34": "struct World<T> {\n    inspector: Option<Inspector<T>>,\n    days: Box<u8>,\n}",
        "nomicon_drop_check_p35": "fn main() {\n    let mut world = World {\n        inspector: None,\n        days: Box::new(1),\n    };\n    world.inspector = Some(Inspector(&world.days, \"gadget\"));\n    // Let's say `days` happens to get dropped first.\n    // Even when Inspector is dropped, its destructor will not access the\n    // borrowed `days`.\n}",
        "nomicon_drop_check_p36": "However, _both_ of the above variants are rejected by the borrow\nchecker during the analysis of `fn main`, saying that `days` does not\nlive long enough.",
        "nomicon_drop_check_p37": "The reason is that the borrow checking analysis of `main` does not\nknow about the internals of each `Inspector`'s `Drop` implementation. As\nfar as the borrow checker knows while it is analyzing `main`, the body\nof an inspector's destructor might access that borrowed data.",
        "nomicon_drop_check_p38": "Therefore, the drop checker forces all borrowed data in a value to\nstrictly outlive that value."
      }
    },
    {
      "id": "nomicon_an_escape_hatch",
      "title": "An Escape Hatch",
      "level": 2,
      "content": "The precise rules that govern drop checking may be less restrictive in\nthe future.\n\nThe current analysis is deliberately conservative; it forces all\nborrowed data in a value to outlive that value, which is certainly sound.\n\nFuture versions of the language may make the analysis more precise, to\nreduce the number of cases where sound code is rejected as unsafe.\nThis would help address cases such as the two `Inspector`s above that\nknow not to inspect during destruction.\n\nIn the meantime, there is an unstable attribute that one can use to\nassert (unsafely) that a generic type's destructor is _guaranteed_ to\nnot access any expired data, even if its type gives it the capability\nto do so.\n\nThat attribute is called `may_dangle` and was introduced in RFC 1327.\nTo deploy it on the `Inspector` from above, we would write:\n\n#![feature(dropck_eyepatch)]\n\nstruct Inspector<'a>(&'a u8, &'static str);\n\nunsafe impl<#[may_dangle] 'a> Drop for Inspector<'a> {\n    fn drop(&mut self) {\n        println!(\"Inspector(_, {}) knows when *not* to inspect.\", self.1);\n    }\n}\n\nstruct World<'a> {\n    days: Box<u8>,\n    inspector: Option<Inspector<'a>>,\n}\n\nfn main() {\n    let mut world = World {\n        inspector: None,\n        days: Box::new(1),\n    };\n    world.inspector = Some(Inspector(&world.days, \"gadget\"));\n}\n\nUse of this attribute requires the `Drop` impl to be marked `unsafe` because the\ncompiler is not checking the implicit assertion that no potentially expired data\n(e.g. `self.0` above) is accessed.\n\nThe attribute can be applied to any number of lifetime and type parameters. In\nthe following example, we assert that we access no data behind a reference of\nlifetime `'b` and that the only uses of `T` will be moves or drops, but omit\nthe attribute from `'a` and `U`, because we do access data with that lifetime\nand that type:\n\n#![feature(dropck_eyepatch)]\nuse std::fmt::Display;\n\nstruct Inspector<'a, 'b, T, U: Display>(&'a u8, &'b u8, T, U);\n\nunsafe impl<'a, #[may_dangle] 'b, #[may_dangle] T, U: Display> Drop for Inspector<'a, 'b, T, U> {\n    fn drop(&mut self) {\n        println!(\"Inspector({}, _, _, {})\", self.0, self.3);\n    }\n}\n\nIt is sometimes obvious that no such access can occur, like the case above.\nHowever, when dealing with a generic type parameter, such access can\noccur indirectly. Examples of such indirect access are:\n\n- invoking a callback,\n- via a trait method call.\n\n(Future changes to the language, such as impl specialization, may add\nother avenues for such indirect access.)\n\nHere is an example of invoking a callback:\n\nstruct Inspector<T>(T, &'static str, Box<for <'r> fn(&'r T) -> String>);\n\nimpl<T> Drop for Inspector<T> {\n    fn drop(&mut self) {\n        // The `self.2` call could access a borrow e.g. if `T` is `&'a _`.\n        println!(\"Inspector({}, {}) unwittingly inspects expired data.\",\n                 (self.2)(&self.0), self.1);\n    }\n}\n\nHere is an example of a trait method call:\n\nuse std::fmt;\n\nstruct Inspector<T: fmt::Display>(T, &'static str);\n\nimpl<T: fmt::Display> Drop for Inspector<T> {\n    fn drop(&mut self) {\n        // There is a hidden call to `<T as Display>::fmt` below, which\n        // could access a borrow e.g. if `T` is `&'a _`\n        println!(\"Inspector({}, {}) unwittingly inspects expired data.\",\n                 self.0, self.1);\n    }\n}\n\nAnd of course, all of these accesses could be further hidden within\nsome other method invoked by the destructor, rather than being written\ndirectly within it.\n\nIn all of the above cases where the `&'a u8` is accessed in the\ndestructor, adding the `#[may_dangle]`\nattribute makes the type vulnerable to misuse that the borrow\nchecker will not catch, inviting havoc. It is better to avoid adding\nthe attribute.",
      "parent_id": null,
      "paragraphs": {
        "nomicon_an_escape_hatch_p1": "The precise rules that govern drop checking may be less restrictive in\nthe future.",
        "nomicon_an_escape_hatch_p2": "The current analysis is deliberately conservative; it forces all\nborrowed data in a value to outlive that value, which is certainly sound.",
        "nomicon_an_escape_hatch_p3": "Future versions of the language may make the analysis more precise, to\nreduce the number of cases where sound code is rejected as unsafe.\nThis would help address cases such as the two `Inspector`s above that\nknow not to inspect during destruction.",
        "nomicon_an_escape_hatch_p4": "In the meantime, there is an unstable attribute that one can use to\nassert (unsafely) that a generic type's destructor is _guaranteed_ to\nnot access any expired data, even if its type gives it the capability\nto do so.",
        "nomicon_an_escape_hatch_p5": "That attribute is called `may_dangle` and was introduced in RFC 1327.\nTo deploy it on the `Inspector` from above, we would write:",
        "nomicon_an_escape_hatch_p6": "#![feature(dropck_eyepatch)]",
        "nomicon_an_escape_hatch_p7": "struct Inspector<'a>(&'a u8, &'static str);",
        "nomicon_an_escape_hatch_p8": "unsafe impl<#[may_dangle] 'a> Drop for Inspector<'a> {\n    fn drop(&mut self) {\n        println!(\"Inspector(_, {}) knows when *not* to inspect.\", self.1);\n    }\n}",
        "nomicon_an_escape_hatch_p9": "struct World<'a> {\n    days: Box<u8>,\n    inspector: Option<Inspector<'a>>,\n}",
        "nomicon_an_escape_hatch_p10": "fn main() {\n    let mut world = World {\n        inspector: None,\n        days: Box::new(1),\n    };\n    world.inspector = Some(Inspector(&world.days, \"gadget\"));\n}",
        "nomicon_an_escape_hatch_p11": "Use of this attribute requires the `Drop` impl to be marked `unsafe` because the\ncompiler is not checking the implicit assertion that no potentially expired data\n(e.g. `self.0` above) is accessed.",
        "nomicon_an_escape_hatch_p12": "The attribute can be applied to any number of lifetime and type parameters. In\nthe following example, we assert that we access no data behind a reference of\nlifetime `'b` and that the only uses of `T` will be moves or drops, but omit\nthe attribute from `'a` and `U`, because we do access data with that lifetime\nand that type:",
        "nomicon_an_escape_hatch_p13": "#![feature(dropck_eyepatch)]\nuse std::fmt::Display;",
        "nomicon_an_escape_hatch_p14": "struct Inspector<'a, 'b, T, U: Display>(&'a u8, &'b u8, T, U);",
        "nomicon_an_escape_hatch_p15": "unsafe impl<'a, #[may_dangle] 'b, #[may_dangle] T, U: Display> Drop for Inspector<'a, 'b, T, U> {\n    fn drop(&mut self) {\n        println!(\"Inspector({}, _, _, {})\", self.0, self.3);\n    }\n}",
        "nomicon_an_escape_hatch_p16": "It is sometimes obvious that no such access can occur, like the case above.\nHowever, when dealing with a generic type parameter, such access can\noccur indirectly. Examples of such indirect access are:",
        "nomicon_an_escape_hatch_p17": "- invoking a callback,\n- via a trait method call.",
        "nomicon_an_escape_hatch_p18": "(Future changes to the language, such as impl specialization, may add\nother avenues for such indirect access.)",
        "nomicon_an_escape_hatch_p19": "Here is an example of invoking a callback:",
        "nomicon_an_escape_hatch_p20": "struct Inspector<T>(T, &'static str, Box<for <'r> fn(&'r T) -> String>);",
        "nomicon_an_escape_hatch_p21": "impl<T> Drop for Inspector<T> {\n    fn drop(&mut self) {\n        // The `self.2` call could access a borrow e.g. if `T` is `&'a _`.\n        println!(\"Inspector({}, {}) unwittingly inspects expired data.\",\n                 (self.2)(&self.0), self.1);\n    }\n}",
        "nomicon_an_escape_hatch_p22": "Here is an example of a trait method call:",
        "nomicon_an_escape_hatch_p23": "use std::fmt;",
        "nomicon_an_escape_hatch_p24": "struct Inspector<T: fmt::Display>(T, &'static str);",
        "nomicon_an_escape_hatch_p25": "impl<T: fmt::Display> Drop for Inspector<T> {\n    fn drop(&mut self) {\n        // There is a hidden call to `<T as Display>::fmt` below, which\n        // could access a borrow e.g. if `T` is `&'a _`\n        println!(\"Inspector({}, {}) unwittingly inspects expired data.\",\n                 self.0, self.1);\n    }\n}",
        "nomicon_an_escape_hatch_p26": "And of course, all of these accesses could be further hidden within\nsome other method invoked by the destructor, rather than being written\ndirectly within it.",
        "nomicon_an_escape_hatch_p27": "In all of the above cases where the `&'a u8` is accessed in the\ndestructor, adding the `#[may_dangle]`\nattribute makes the type vulnerable to misuse that the borrow\nchecker will not catch, inviting havoc. It is better to avoid adding\nthe attribute."
      }
    },
    {
      "id": "nomicon_a_related_side_note_about_drop_order",
      "title": "A related side note about drop order",
      "level": 2,
      "content": "While the drop order of fields inside a struct is defined, relying on it is\nfragile and subtle. When the order matters, it is better to use the\n[`ManuallyDrop`] wrapper.",
      "parent_id": null,
      "paragraphs": {
        "nomicon_a_related_side_note_about_drop_order_p1": "While the drop order of fields inside a struct is defined, relying on it is\nfragile and subtle. When the order matters, it is better to use the\n[`ManuallyDrop`] wrapper."
      }
    },
    {
      "id": "nomicon_is_that_all_about_drop_checker",
      "title": "Is that all about drop checker?",
      "level": 2,
      "content": "It turns out that when writing unsafe code, we generally don't need to\nworry at all about doing the right thing for the drop checker. However there\nis one special case that you need to worry about, which we will look at in\nthe next section.\n\n[rfc1327]: https://github.com/rust-lang/rfcs/blob/master/text/1327-dropck-param-eyepatch.md\n[rfc1857]: https://github.com/rust-lang/rfcs/blob/master/text/1857-stabilize-drop-order.md\n[`manuallydrop`]: ../std/mem/struct.ManuallyDrop.html",
      "parent_id": null,
      "paragraphs": {
        "nomicon_is_that_all_about_drop_checker_p1": "It turns out that when writing unsafe code, we generally don't need to\nworry at all about doing the right thing for the drop checker. However there\nis one special case that you need to worry about, which we will look at in\nthe next section.",
        "nomicon_is_that_all_about_drop_checker_p2": "[rfc1327]: https://github.com/rust-lang/rfcs/blob/master/text/1327-dropck-param-eyepatch.md\n[rfc1857]: https://github.com/rust-lang/rfcs/blob/master/text/1857-stabilize-drop-order.md\n[`manuallydrop`]: ../std/mem/struct.ManuallyDrop.html"
      }
    },
    {
      "id": "nomicon_phantomdata",
      "title": "PhantomData",
      "level": 1,
      "content": "When working with unsafe code, we can often end up in a situation where\ntypes or lifetimes are logically associated with a struct, but not actually\npart of a field. This most commonly occurs with lifetimes. For instance, the\n`Iter` for `&'a [T]` is (approximately) defined as follows:\n\n,compile_fail\nstruct Iter<'a, T: 'a> {\n    ptr: *const T,\n    end: *const T,\n}\n\nHowever because `'a` is unused within the struct's body, it's *unbounded*.\nBecause of the troubles this has historically caused,\nunbounded lifetimes and types are *forbidden* in struct definitions.\nTherefore we must somehow refer to these types in the body.\nCorrectly doing this is necessary to have correct variance and drop checking.\n\n[unused-param]: https://rust-lang.github.io/rfcs/0738-variance.html#the-corner-case-unused-parameters-and-parameters-that-are-only-used-unsafely\n\nWe do this using `PhantomData`, which is a special marker type. `PhantomData`\nconsumes no space, but simulates a field of the given type for the purpose of\nstatic analysis. This was deemed to be less error-prone than explicitly telling\nthe type-system the kind of variance that you want, while also providing other\nuseful things such as auto traits and the information needed by drop check.\n\nIter logically contains a bunch of `&'a T`s, so this is exactly what we tell\nthe `PhantomData` to simulate:\n\nuse std::marker;\n\nstruct Iter<'a, T: 'a> {\n    ptr: *const T,\n    end: *const T,\n    _marker: marker::PhantomData<&'a T>,\n}\n\nand that's it. The lifetime will be bounded, and your iterator will be covariant\nover `'a` and `T`. Everything Just Works.",
      "parent_id": null,
      "paragraphs": {
        "nomicon_phantomdata_p1": "When working with unsafe code, we can often end up in a situation where\ntypes or lifetimes are logically associated with a struct, but not actually\npart of a field. This most commonly occurs with lifetimes. For instance, the\n`Iter` for `&'a [T]` is (approximately) defined as follows:",
        "nomicon_phantomdata_p2": ",compile_fail\nstruct Iter<'a, T: 'a> {\n    ptr: *const T,\n    end: *const T,\n}",
        "nomicon_phantomdata_p3": "However because `'a` is unused within the struct's body, it's *unbounded*.\nBecause of the troubles this has historically caused,\nunbounded lifetimes and types are *forbidden* in struct definitions.\nTherefore we must somehow refer to these types in the body.\nCorrectly doing this is necessary to have correct variance and drop checking.",
        "nomicon_phantomdata_p4": "[unused-param]: https://rust-lang.github.io/rfcs/0738-variance.html#the-corner-case-unused-parameters-and-parameters-that-are-only-used-unsafely",
        "nomicon_phantomdata_p5": "We do this using `PhantomData`, which is a special marker type. `PhantomData`\nconsumes no space, but simulates a field of the given type for the purpose of\nstatic analysis. This was deemed to be less error-prone than explicitly telling\nthe type-system the kind of variance that you want, while also providing other\nuseful things such as auto traits and the information needed by drop check.",
        "nomicon_phantomdata_p6": "Iter logically contains a bunch of `&'a T`s, so this is exactly what we tell\nthe `PhantomData` to simulate:",
        "nomicon_phantomdata_p7": "use std::marker;",
        "nomicon_phantomdata_p8": "struct Iter<'a, T: 'a> {\n    ptr: *const T,\n    end: *const T,\n    _marker: marker::PhantomData<&'a T>,\n}",
        "nomicon_phantomdata_p9": "and that's it. The lifetime will be bounded, and your iterator will be covariant\nover `'a` and `T`. Everything Just Works."
      }
    },
    {
      "id": "nomicon_generic_parameters_and_drop_checking",
      "title": "Generic parameters and drop-checking",
      "level": 2,
      "content": "In the past, there used to be another thing to take into consideration.\n\nThis very documentation used to say:\n\n> Another important example is Vec, which is (approximately) defined as follows:\n>\n> ```rust\n> struct Vec<T> {\n>     data: *const T, // *const for variance!\n>     len: usize,\n>     cap: usize,\n> }\n> ```\n>\n> Unlike the previous example, it *appears* that everything is exactly as we\n> want. Every generic argument to Vec shows up in at least one field.\n> Good to go!\n>\n> Nope.\n>\n> The drop checker will generously determine that `Vec<T>` does not own any values\n> of type T. This will in turn make it conclude that it doesn't need to worry\n> about Vec dropping any T's in its destructor for determining drop check\n> soundness. This will in turn allow people to create unsoundness using\n> Vec's destructor.\n>\n> In order to tell the drop checker that we *do* own values of type T, and\n> therefore may drop some T's when *we* drop, we must add an extra `PhantomData`\n> saying exactly that:\n>\n> ```rust\n> use std::marker;\n>\n> struct Vec<T> {\n>     data: *const T, // *const for variance!\n>     len: usize,\n>     cap: usize,\n>     _owns_T: marker::PhantomData<T>,\n> }\n> ```\n\nBut ever since RFC 1238,\n**this is no longer true nor necessary**.\n\nIf you were to write:\n\nstruct Vec<T> {\n    data: *const T, // `*const` for variance!\n    len: usize,\n    cap: usize,\n}",
      "parent_id": null,
      "paragraphs": {
        "nomicon_generic_parameters_and_drop_checking_p1": "In the past, there used to be another thing to take into consideration.",
        "nomicon_generic_parameters_and_drop_checking_p2": "This very documentation used to say:",
        "nomicon_generic_parameters_and_drop_checking_p3": "> Another important example is Vec, which is (approximately) defined as follows:\n>\n> ```rust\n> struct Vec<T> {\n>     data: *const T, // *const for variance!\n>     len: usize,\n>     cap: usize,\n> }\n> ```\n>\n> Unlike the previous example, it *appears* that everything is exactly as we\n> want. Every generic argument to Vec shows up in at least one field.\n> Good to go!\n>\n> Nope.\n>\n> The drop checker will generously determine that `Vec<T>` does not own any values\n> of type T. This will in turn make it conclude that it doesn't need to worry\n> about Vec dropping any T's in its destructor for determining drop check\n> soundness. This will in turn allow people to create unsoundness using\n> Vec's destructor.\n>\n> In order to tell the drop checker that we *do* own values of type T, and\n> therefore may drop some T's when *we* drop, we must add an extra `PhantomData`\n> saying exactly that:\n>\n> ```rust\n> use std::marker;\n>\n> struct Vec<T> {\n>     data: *const T, // *const for variance!\n>     len: usize,\n>     cap: usize,\n>     _owns_T: marker::PhantomData<T>,\n> }\n> ```",
        "nomicon_generic_parameters_and_drop_checking_p4": "But ever since RFC 1238,\n**this is no longer true nor necessary**.",
        "nomicon_generic_parameters_and_drop_checking_p5": "If you were to write:",
        "nomicon_generic_parameters_and_drop_checking_p6": "struct Vec<T> {\n    data: *const T, // `*const` for variance!\n    len: usize,\n    cap: usize,\n}"
      }
    },
    {
      "id": "nomicon_cfg_any",
      "title": "#[cfg(any())]",
      "level": 1,
      "content": "impl<T> Drop for Vec<T> { /* \u2026 */ }\n\nthen the existence of that `impl<T> Drop for Vec<T>` makes it so Rust will consider\nthat that `Vec<T>` _owns_ values of type `T` (more precisely: may use values of type `T`\nin its `Drop` implementation), and Rust will thus not allow them to _dangle_ should a\n`Vec<T>` be dropped.\n\nWhen a type already has a `Drop impl`, **adding an extra `_owns_T: PhantomData<T>` field\nis thus _superfluous_ and accomplishes nothing**, dropck-wise (it still affects variance\nand auto-traits).\n\n  - (advanced edge case: if the type containing the `PhantomData` has no `Drop` impl at all,\n    but still has drop glue (by having _another_ field with drop glue), then the\n    dropck/`#[may_dangle]` considerations mentioned herein do apply as well: a `PhantomData<T>`\n    field will then require `T` to be droppable whenever the containing type goes out of scope).\n\n___\n\nBut this situation can sometimes lead to overly restrictive code. That's why the\nstandard library uses an unstable and `unsafe` attribute to opt back into the old\n\"unchecked\" drop-checking behavior, that this very documentation warned about: the\n`#[may_dangle]` attribute.",
      "parent_id": null,
      "paragraphs": {
        "nomicon_cfg_any_p1": "impl<T> Drop for Vec<T> { /* \u2026 */ }",
        "nomicon_cfg_any_p2": "then the existence of that `impl<T> Drop for Vec<T>` makes it so Rust will consider\nthat that `Vec<T>` _owns_ values of type `T` (more precisely: may use values of type `T`\nin its `Drop` implementation), and Rust will thus not allow them to _dangle_ should a\n`Vec<T>` be dropped.",
        "nomicon_cfg_any_p3": "When a type already has a `Drop impl`, **adding an extra `_owns_T: PhantomData<T>` field\nis thus _superfluous_ and accomplishes nothing**, dropck-wise (it still affects variance\nand auto-traits).",
        "nomicon_cfg_any_p4": "- (advanced edge case: if the type containing the `PhantomData` has no `Drop` impl at all,\n    but still has drop glue (by having _another_ field with drop glue), then the\n    dropck/`#[may_dangle]` considerations mentioned herein do apply as well: a `PhantomData<T>`\n    field will then require `T` to be droppable whenever the containing type goes out of scope).",
        "nomicon_cfg_any_p5": "___",
        "nomicon_cfg_any_p6": "But this situation can sometimes lead to overly restrictive code. That's why the\nstandard library uses an unstable and `unsafe` attribute to opt back into the old\n\"unchecked\" drop-checking behavior, that this very documentation warned about: the\n`#[may_dangle]` attribute."
      }
    },
    {
      "id": "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle",
      "title": "An exception: the special case of the standard library and its unstable `#[may_dangle]`",
      "level": 3,
      "content": "This section can be skipped if you are only writing your own library code; but if you are\ncurious about what the standard library does with the actual `Vec` definition, you'll notice\nthat it still needs to use a `_owns_T: PhantomData<T>` field for soundness.\n\n<details><summary>Click here to see why</summary>\n\nConsider the following example:\n\nfn main() {\n    let mut v: Vec<&str> = Vec::new();\n    let s: String = \"Short-lived\".into();\n    v.push(&s);\n    drop(s);\n} // <- `v` is dropped here\n\nwith a classical `impl<T> Drop for Vec<T> {` definition, the above [is denied].\n\n[is denied]: https://rust.godbolt.org/z/ans15Kqz3\n\nIndeed, in this case we have a `Vec</* T = */ &'s str>` vector of `'s`-lived references\nto `str`ings, but in the case of `let s: String`, it is dropped before the `Vec` is, and\nthus `'s` **is expired** by the time the `Vec` is dropped, and the\n`impl<'s> Drop for Vec<&'s str> {` is used.\n\nThis means that if such `Drop` were to be used, it would be dealing with an _expired_, or\n_dangling_ lifetime `'s`. But this is contrary to Rust principles, where by default all\nRust references involved in a function signature are non-dangling and valid to dereference.\n\nHence why Rust has to conservatively deny this snippet.\n\nAnd yet, in the case of the real `Vec`, the `Drop` impl does not care about `&'s str`,\n_since it has no drop glue of its own_: it only wants to deallocate the backing buffer.\n\nIn other words, it would be nice if the above snippet was somehow accepted, by special\ncasing `Vec`, or by relying on some special property of `Vec`: `Vec` could try to\n_promise not to use the `&'s str`s it holds when being dropped_.\n\nThis is the kind of `unsafe` promise that can be expressed with `#[may_dangle]`:\n\n ,ignore\nunsafe impl<#[may_dangle] 's> Drop for Vec<&'s str> { /* \u2026 */ }\n\nor, more generally:\n\n ,ignore\nunsafe impl<#[may_dangle] T> Drop for Vec<T> { /* \u2026 */ }\n\nis the `unsafe` way to opt out of this conservative assumption that Rust's drop\nchecker makes about type parameters of a dropped instance not being allowed to dangle.\n\nAnd when this is done, such as in the standard library, we need to be careful in the\ncase where `T` has drop glue of its own. In this instance, imagine replacing the\n`&'s str`s with a `struct PrintOnDrop<'s> /* = */ (&'s str);` which would have a\n`Drop` impl wherein the inner `&'s str` would be dereferenced and printed to the screen.\n\nIndeed, `Drop for Vec<T> {`, before deallocating the backing buffer, does have to transitively\ndrop each `T` item when it has drop glue; in the case of `PrintOnDrop<'s>`, it means that\n`Drop for Vec<PrintOnDrop<'s>>` has to transitively drop the `PrintOnDrop<'s>`s elements before\ndeallocating the backing buffer.\n\nSo when we said that `'s` `#[may_dangle]`, it was an excessively loose statement. We'd rather want\nto say: \"`'s` may dangle provided it not be involved in some transitive drop glue\". Or, more generally,\n\"`T` may dangle provided it not be involved in some transitive drop glue\". This \"exception to the\nexception\" is a pervasive situation whenever **we own a `T`**. That's why Rust's `#[may_dangle]` is\nsmart enough to know of this opt-out, and will thus be disabled _when the generic parameter is held\nin an owned fashion_ by the fields of the struct.\n\nHence why the standard library ends up with:",
      "parent_id": null,
      "paragraphs": {
        "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p1": "This section can be skipped if you are only writing your own library code; but if you are\ncurious about what the standard library does with the actual `Vec` definition, you'll notice\nthat it still needs to use a `_owns_T: PhantomData<T>` field for soundness.",
        "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p2": "<details><summary>Click here to see why</summary>",
        "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p3": "Consider the following example:",
        "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p4": "fn main() {\n    let mut v: Vec<&str> = Vec::new();\n    let s: String = \"Short-lived\".into();\n    v.push(&s);\n    drop(s);\n} // <- `v` is dropped here",
        "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p5": "with a classical `impl<T> Drop for Vec<T> {` definition, the above [is denied].",
        "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p6": "[is denied]: https://rust.godbolt.org/z/ans15Kqz3",
        "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p7": "Indeed, in this case we have a `Vec</* T = */ &'s str>` vector of `'s`-lived references\nto `str`ings, but in the case of `let s: String`, it is dropped before the `Vec` is, and\nthus `'s` **is expired** by the time the `Vec` is dropped, and the\n`impl<'s> Drop for Vec<&'s str> {` is used.",
        "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p8": "This means that if such `Drop` were to be used, it would be dealing with an _expired_, or\n_dangling_ lifetime `'s`. But this is contrary to Rust principles, where by default all\nRust references involved in a function signature are non-dangling and valid to dereference.",
        "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p9": "Hence why Rust has to conservatively deny this snippet.",
        "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p10": "And yet, in the case of the real `Vec`, the `Drop` impl does not care about `&'s str`,\n_since it has no drop glue of its own_: it only wants to deallocate the backing buffer.",
        "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p11": "In other words, it would be nice if the above snippet was somehow accepted, by special\ncasing `Vec`, or by relying on some special property of `Vec`: `Vec` could try to\n_promise not to use the `&'s str`s it holds when being dropped_.",
        "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p12": "This is the kind of `unsafe` promise that can be expressed with `#[may_dangle]`:",
        "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p13": ",ignore\nunsafe impl<#[may_dangle] 's> Drop for Vec<&'s str> { /* \u2026 */ }",
        "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p14": "or, more generally:",
        "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p15": ",ignore\nunsafe impl<#[may_dangle] T> Drop for Vec<T> { /* \u2026 */ }",
        "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p16": "is the `unsafe` way to opt out of this conservative assumption that Rust's drop\nchecker makes about type parameters of a dropped instance not being allowed to dangle.",
        "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p17": "And when this is done, such as in the standard library, we need to be careful in the\ncase where `T` has drop glue of its own. In this instance, imagine replacing the\n`&'s str`s with a `struct PrintOnDrop<'s> /* = */ (&'s str);` which would have a\n`Drop` impl wherein the inner `&'s str` would be dereferenced and printed to the screen.",
        "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p18": "Indeed, `Drop for Vec<T> {`, before deallocating the backing buffer, does have to transitively\ndrop each `T` item when it has drop glue; in the case of `PrintOnDrop<'s>`, it means that\n`Drop for Vec<PrintOnDrop<'s>>` has to transitively drop the `PrintOnDrop<'s>`s elements before\ndeallocating the backing buffer.",
        "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p19": "So when we said that `'s` `#[may_dangle]`, it was an excessively loose statement. We'd rather want\nto say: \"`'s` may dangle provided it not be involved in some transitive drop glue\". Or, more generally,\n\"`T` may dangle provided it not be involved in some transitive drop glue\". This \"exception to the\nexception\" is a pervasive situation whenever **we own a `T`**. That's why Rust's `#[may_dangle]` is\nsmart enough to know of this opt-out, and will thus be disabled _when the generic parameter is held\nin an owned fashion_ by the fields of the struct.",
        "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p20": "Hence why the standard library ends up with:",
        "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p21": ""
      }
    },
    {
      "id": "nomicon_cfg_any",
      "title": "#[cfg(any())]",
      "level": 1,
      "content": "// we pinky-swear not to use `T` when dropping a `Vec`\u2026\nunsafe impl<#[may_dangle] T> Drop for Vec<T> {\n    fn drop(&mut self) {\n        unsafe {\n            if mem::needs_drop::<T>() {\n                /* \u2026 except here, that is, \u2026 */\n                ptr::drop_in_place::<[T]>(/* \u2026 */);\n            }\n            // \u2026\n            dealloc(/* \u2026 */)\n            // \u2026\n        }\n    }\n}\n\nstruct Vec<T> {\n    // \u2026 except for the fact that a `Vec` owns `T` items and\n    // may thus be dropping `T` items on drop!\n    _owns_T: core::marker::PhantomData<T>,\n\n    ptr: *const T, // `*const` for variance (but this does not express ownership of a `T` *per se*)\n    len: usize,\n    cap: usize,\n}\n\n</details>\n\n___\n\nRaw pointers that own an allocation is such a pervasive pattern that the\nstandard library made a utility for itself called `Unique<T>` which:\n\n* wraps a `*const T` for variance\n* includes a `PhantomData<T>`\n* auto-derives `Send`/`Sync` as if T was contained\n* marks the pointer as `NonZero` for the null-pointer optimization",
      "parent_id": null,
      "paragraphs": {
        "nomicon_cfg_any_p1": "// we pinky-swear not to use `T` when dropping a `Vec`\u2026\nunsafe impl<#[may_dangle] T> Drop for Vec<T> {\n    fn drop(&mut self) {\n        unsafe {\n            if mem::needs_drop::<T>() {\n                /* \u2026 except here, that is, \u2026 */\n                ptr::drop_in_place::<[T]>(/* \u2026 */);\n            }\n            // \u2026\n            dealloc(/* \u2026 */)\n            // \u2026\n        }\n    }\n}",
        "nomicon_cfg_any_p2": "struct Vec<T> {\n    // \u2026 except for the fact that a `Vec` owns `T` items and\n    // may thus be dropping `T` items on drop!\n    _owns_T: core::marker::PhantomData<T>,",
        "nomicon_cfg_any_p3": "ptr: *const T, // `*const` for variance (but this does not express ownership of a `T` *per se*)\n    len: usize,\n    cap: usize,\n}",
        "nomicon_cfg_any_p4": "</details>",
        "nomicon_cfg_any_p5": "___",
        "nomicon_cfg_any_p6": "Raw pointers that own an allocation is such a pervasive pattern that the\nstandard library made a utility for itself called `Unique<T>` which:",
        "nomicon_cfg_any_p7": "* wraps a `*const T` for variance\n* includes a `PhantomData<T>`\n* auto-derives `Send`/`Sync` as if T was contained\n* marks the pointer as `NonZero` for the null-pointer optimization"
      }
    },
    {
      "id": "nomicon_table_of_phantomdata_patterns",
      "title": "Table of `PhantomData` patterns",
      "level": 2,
      "content": "Here\u2019s a table of all the wonderful ways `PhantomData` could be used:\n\n| Phantom type                | variance of `'a` | variance of `T`   | `Send`/`Sync`<br/>(or lack thereof)       | dangling `'a` or `T` in drop glue<br/>(_e.g._, `#[may_dangle] Drop`) |\n|-----------------------------|:----------------:|:-----------------:|:-----------------------------------------:|:------------------------------------------------:|\n| `PhantomData<T>`            | -                | **cov**ariant     | inherited                                 | disallowed (\"owns `T`\")                          |\n| `PhantomData<&'a T>`        | **cov**ariant    | **cov**ariant     | `Send + Sync`<br/>requires<br/>`T : Sync` | allowed                                          |\n| `PhantomData<&'a mut T>`    | **cov**ariant    | **inv**ariant     | inherited                                 | allowed                                          |\n| `PhantomData<*const T>`     | -                | **cov**ariant     | `!Send + !Sync`                           | allowed                                          |\n| `PhantomData<*mut T>`       | -                | **inv**ariant     | `!Send + !Sync`                           | allowed                                          |\n| `PhantomData<fn(T)>`        | -                | **contra**variant | `Send + Sync`                             | allowed                                          |\n| `PhantomData<fn() -> T>`    | -                | **cov**ariant     | `Send + Sync`                             | allowed                                          |\n| `PhantomData<fn(T) -> T>`   | -                | **inv**ariant     | `Send + Sync`                             | allowed                                          |\n| `PhantomData<Cell<&'a ()>>` | **inv**ariant    | -                 | `Send + !Sync`                            | allowed                                          |\n\n  - Note: opting out of the `Unpin` auto-trait requires the dedicated [`PhantomPinned`] type instead.\n\n[`PhantomPinned`]: ../core/marker/struct.PhantomPinned.html",
      "parent_id": null,
      "paragraphs": {
        "nomicon_table_of_phantomdata_patterns_p1": "Here\u2019s a table of all the wonderful ways `PhantomData` could be used:",
        "nomicon_table_of_phantomdata_patterns_p2": "| Phantom type                | variance of `'a` | variance of `T`   | `Send`/`Sync`<br/>(or lack thereof)       | dangling `'a` or `T` in drop glue<br/>(_e.g._, `#[may_dangle] Drop`) |\n|-----------------------------|:----------------:|:-----------------:|:-----------------------------------------:|:------------------------------------------------:|\n| `PhantomData<T>`            | -                | **cov**ariant     | inherited                                 | disallowed (\"owns `T`\")                          |\n| `PhantomData<&'a T>`        | **cov**ariant    | **cov**ariant     | `Send + Sync`<br/>requires<br/>`T : Sync` | allowed                                          |\n| `PhantomData<&'a mut T>`    | **cov**ariant    | **inv**ariant     | inherited                                 | allowed                                          |\n| `PhantomData<*const T>`     | -                | **cov**ariant     | `!Send + !Sync`                           | allowed                                          |\n| `PhantomData<*mut T>`       | -                | **inv**ariant     | `!Send + !Sync`                           | allowed                                          |\n| `PhantomData<fn(T)>`        | -                | **contra**variant | `Send + Sync`                             | allowed                                          |\n| `PhantomData<fn() -> T>`    | -                | **cov**ariant     | `Send + Sync`                             | allowed                                          |\n| `PhantomData<fn(T) -> T>`   | -                | **inv**ariant     | `Send + Sync`                             | allowed                                          |\n| `PhantomData<Cell<&'a ()>>` | **inv**ariant    | -                 | `Send + !Sync`                            | allowed                                          |",
        "nomicon_table_of_phantomdata_patterns_p3": "- Note: opting out of the `Unpin` auto-trait requires the dedicated [`PhantomPinned`] type instead.",
        "nomicon_table_of_phantomdata_patterns_p4": "[`PhantomPinned`]: ../core/marker/struct.PhantomPinned.html"
      }
    },
    {
      "id": "nomicon_splitting_borrows",
      "title": "Splitting Borrows",
      "level": 1,
      "content": "The mutual exclusion property of mutable references can be very limiting when\nworking with a composite structure. The borrow checker (a.k.a. borrowck)\nunderstands some basic stuff, but will fall over pretty easily. It does\nunderstand structs sufficiently to know that it's possible to borrow disjoint\nfields of a struct simultaneously. So this works today:\n\nstruct Foo {\n    a: i32,\n    b: i32,\n    c: i32,\n}\n\nlet mut x = Foo {a: 0, b: 0, c: 0};\nlet a = &mut x.a;\nlet b = &mut x.b;\nlet c = &x.c;\n*b += 1;\nlet c2 = &x.c;\n*a += 10;\nprintln!(\"{} {} {} {}\", a, b, c, c2);\n\nHowever borrowck doesn't understand arrays or slices in any way, so this doesn't\nwork:\n\n,compile_fail\nlet mut x = [1, 2, 3];\nlet a = &mut x[0];\nlet b = &mut x[1];\nprintln!(\"{} {}\", a, b);\n\nerror[E0499]: cannot borrow `x[..]` as mutable more than once at a time\n --> src/lib.rs:4:18\n  |\n3 |     let a = &mut x[0];\n  |                  ---- first mutable borrow occurs here\n4 |     let b = &mut x[1];\n  |                  ^^^^ second mutable borrow occurs here\n5 |     println!(\"{} {}\", a, b);\n6 | }\n  | - first borrow ends here\n\nerror: aborting due to previous error\n\nWhile it was plausible that borrowck could understand this simple case, it's\npretty clearly hopeless for borrowck to understand disjointness in general\ncontainer types like a tree, especially if distinct keys actually *do* map\nto the same value.\n\nIn order to \"teach\" borrowck that what we're doing is ok, we need to drop down\nto unsafe code. For instance, mutable slices expose a `split_at_mut` function\nthat consumes the slice and returns two mutable slices. One for everything to\nthe left of the index, and one for everything to the right. Intuitively we know\nthis is safe because the slices don't overlap, and therefore alias. However\nthe implementation requires some unsafety:",
      "parent_id": null,
      "paragraphs": {
        "nomicon_splitting_borrows_p1": "The mutual exclusion property of mutable references can be very limiting when\nworking with a composite structure. The borrow checker (a.k.a. borrowck)\nunderstands some basic stuff, but will fall over pretty easily. It does\nunderstand structs sufficiently to know that it's possible to borrow disjoint\nfields of a struct simultaneously. So this works today:",
        "nomicon_splitting_borrows_p2": "struct Foo {\n    a: i32,\n    b: i32,\n    c: i32,\n}",
        "nomicon_splitting_borrows_p3": "let mut x = Foo {a: 0, b: 0, c: 0};\nlet a = &mut x.a;\nlet b = &mut x.b;\nlet c = &x.c;\n*b += 1;\nlet c2 = &x.c;\n*a += 10;\nprintln!(\"{} {} {} {}\", a, b, c, c2);",
        "nomicon_splitting_borrows_p4": "However borrowck doesn't understand arrays or slices in any way, so this doesn't\nwork:",
        "nomicon_splitting_borrows_p5": ",compile_fail\nlet mut x = [1, 2, 3];\nlet a = &mut x[0];\nlet b = &mut x[1];\nprintln!(\"{} {}\", a, b);",
        "nomicon_splitting_borrows_p6": "error[E0499]: cannot borrow `x[..]` as mutable more than once at a time\n --> src/lib.rs:4:18\n  |\n3 |     let a = &mut x[0];\n  |                  ---- first mutable borrow occurs here\n4 |     let b = &mut x[1];\n  |                  ^^^^ second mutable borrow occurs here\n5 |     println!(\"{} {}\", a, b);\n6 | }\n  | - first borrow ends here",
        "nomicon_splitting_borrows_p7": "error: aborting due to previous error",
        "nomicon_splitting_borrows_p8": "While it was plausible that borrowck could understand this simple case, it's\npretty clearly hopeless for borrowck to understand disjointness in general\ncontainer types like a tree, especially if distinct keys actually *do* map\nto the same value.",
        "nomicon_splitting_borrows_p9": "In order to \"teach\" borrowck that what we're doing is ok, we need to drop down\nto unsafe code. For instance, mutable slices expose a `split_at_mut` function\nthat consumes the slice and returns two mutable slices. One for everything to\nthe left of the index, and one for everything to the right. Intuitively we know\nthis is safe because the slices don't overlap, and therefore alias. However\nthe implementation requires some unsafety:",
        "nomicon_splitting_borrows_p10": ""
      }
    },
    {
      "id": "nomicon_use_std_slice_from_raw_parts_mut",
      "title": "use std::slice::from_raw_parts_mut;",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_struct_fakeslice_t_t",
      "title": "struct FakeSlice<T>(T);",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_impl_t_fakeslice_t",
      "title": "impl<T> FakeSlice<T> {",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_fn_len_self_usize_unimplemented",
      "title": "fn len(&self) -> usize { unimplemented!() }",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "nomicon_fn_as_mut_ptr_mut_self_mut_t_unimplemented",
      "title": "fn as_mut_ptr(&mut self) -> *mut T { unimplemented!() }",
      "level": 1,
      "content": "pub fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n    let len = self.len();\n    let ptr = self.as_mut_ptr();\n\n    unsafe {\n        assert!(mid <= len);\n\n        (from_raw_parts_mut(ptr, mid),\n         from_raw_parts_mut(ptr.add(mid), len - mid))\n    }\n}",
      "parent_id": null,
      "paragraphs": {
        "nomicon_fn_as_mut_ptr_mut_self_mut_t_unimplemented_p1": "pub fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n    let len = self.len();\n    let ptr = self.as_mut_ptr();",
        "nomicon_fn_as_mut_ptr_mut_self_mut_t_unimplemented_p2": "unsafe {\n        assert!(mid <= len);",
        "nomicon_fn_as_mut_ptr_mut_self_mut_t_unimplemented_p3": "(from_raw_parts_mut(ptr, mid),\n         from_raw_parts_mut(ptr.add(mid), len - mid))\n    }\n}"
      }
    },
    {
      "id": "nomicon",
      "title": "}",
      "level": 1,
      "content": "This is actually a bit subtle. So as to avoid ever making two `&mut`'s to the\nsame value, we explicitly construct brand-new slices through raw pointers.\n\nHowever more subtle is how iterators that yield mutable references work.\nThe iterator trait is defined as follows:\n\ntrait Iterator {\n    type Item;\n\n    fn next(&mut self) -> Option<Self::Item>;\n}\n\nGiven this definition, Self::Item has *no* connection to `self`. This means that\nwe can call `next` several times in a row, and hold onto all the results\n*concurrently*. This is perfectly fine for by-value iterators, which have\nexactly these semantics. It's also actually fine for shared references, as they\nadmit arbitrarily many references to the same thing (although the iterator needs\nto be a separate object from the thing being shared).\n\nBut mutable references make this a mess. At first glance, they might seem\ncompletely incompatible with this API, as it would produce multiple mutable\nreferences to the same object!\n\nHowever it actually *does* work, exactly because iterators are one-shot objects.\nEverything an IterMut yields will be yielded at most once, so we don't\nactually ever yield multiple mutable references to the same piece of data.\n\nPerhaps surprisingly, mutable iterators don't require unsafe code to be\nimplemented for many types!\n\nFor instance here's a singly linked list:",
      "parent_id": null,
      "paragraphs": {
        "nomicon_p1": "",
        "nomicon_p2": "This is actually a bit subtle. So as to avoid ever making two `&mut`'s to the\nsame value, we explicitly construct brand-new slices through raw pointers.",
        "nomicon_p3": "However more subtle is how iterators that yield mutable references work.\nThe iterator trait is defined as follows:",
        "nomicon_p4": "trait Iterator {\n    type Item;",
        "nomicon_p5": "fn next(&mut self) -> Option<Self::Item>;\n}",
        "nomicon_p6": "Given this definition, Self::Item has *no* connection to `self`. This means that\nwe can call `next` several times in a row, and hold onto all the results\n*concurrently*. This is perfectly fine for by-value iterators, which have\nexactly these semantics. It's also actually fine for shared references, as they\nadmit arbitrarily many references to the same thing (although the iterator needs\nto be a separate object from the thing being shared).",
        "nomicon_p7": "But mutable references make this a mess. At first glance, they might seem\ncompletely incompatible with this API, as it would produce multiple mutable\nreferences to the same object!",
        "nomicon_p8": "However it actually *does* work, exactly because iterators are one-shot objects.\nEverything an IterMut yields will be yielded at most once, so we don't\nactually ever yield multiple mutable references to the same piece of data.",
        "nomicon_p9": "Perhaps surprisingly, mutable iterators don't require unsafe code to be\nimplemented for many types!",
        "nomicon_p10": "For instance here's a singly linked list:",
        "nomicon_p11": ""
      }
    },
    {
      "id": "nomicon_fn_main",
      "title": "fn main() {}",
      "level": 1,
      "content": "type Link<T> = Option<Box<Node<T>>>;\n\nstruct Node<T> {\n    elem: T,\n    next: Link<T>,\n}\n\npub struct LinkedList<T> {\n    head: Link<T>,\n}\n\npub struct IterMut<'a, T: 'a>(Option<&'a mut Node<T>>);\n\nimpl<T> LinkedList<T> {\n    fn iter_mut(&mut self) -> IterMut<T> {\n        IterMut(self.head.as_mut().map(|node| &mut **node))\n    }\n}\n\nimpl<'a, T> Iterator for IterMut<'a, T> {\n    type Item = &'a mut T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.0.take().map(|node| {\n            self.0 = node.next.as_mut().map(|node| &mut **node);\n            &mut node.elem\n        })\n    }\n}\n\nHere's a mutable slice:",
      "parent_id": null,
      "paragraphs": {
        "nomicon_fn_main_p1": "type Link<T> = Option<Box<Node<T>>>;",
        "nomicon_fn_main_p2": "struct Node<T> {\n    elem: T,\n    next: Link<T>,\n}",
        "nomicon_fn_main_p3": "pub struct LinkedList<T> {\n    head: Link<T>,\n}",
        "nomicon_fn_main_p4": "pub struct IterMut<'a, T: 'a>(Option<&'a mut Node<T>>);",
        "nomicon_fn_main_p5": "impl<T> LinkedList<T> {\n    fn iter_mut(&mut self) -> IterMut<T> {\n        IterMut(self.head.as_mut().map(|node| &mut **node))\n    }\n}",
        "nomicon_fn_main_p6": "impl<'a, T> Iterator for IterMut<'a, T> {\n    type Item = &'a mut T;",
        "nomicon_fn_main_p7": "fn next(&mut self) -> Option<Self::Item> {\n        self.0.take().map(|node| {\n            self.0 = node.next.as_mut().map(|node| &mut **node);\n            &mut node.elem\n        })\n    }\n}",
        "nomicon_fn_main_p8": "Here's a mutable slice:",
        "nomicon_fn_main_p9": ""
      }
    },
    {
      "id": "nomicon_fn_main",
      "title": "fn main() {}",
      "level": 1,
      "content": "use std::mem;\n\npub struct IterMut<'a, T: 'a>(&'a mut[T]);\n\nimpl<'a, T> Iterator for IterMut<'a, T> {\n    type Item = &'a mut T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let slice = mem::take(&mut self.0);\n        if slice.is_empty() { return None; }\n\n        let (l, r) = slice.split_at_mut(1);\n        self.0 = r;\n        l.get_mut(0)\n    }\n}\n\nimpl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n    fn next_back(&mut self) -> Option<Self::Item> {\n        let slice = mem::take(&mut self.0);\n        if slice.is_empty() { return None; }\n\n        let new_len = slice.len() - 1;\n        let (l, r) = slice.split_at_mut(new_len);\n        self.0 = l;\n        r.get_mut(0)\n    }\n}\n\nAnd here's a binary tree:",
      "parent_id": null,
      "paragraphs": {
        "nomicon_fn_main_p1": "use std::mem;",
        "nomicon_fn_main_p2": "pub struct IterMut<'a, T: 'a>(&'a mut[T]);",
        "nomicon_fn_main_p3": "impl<'a, T> Iterator for IterMut<'a, T> {\n    type Item = &'a mut T;",
        "nomicon_fn_main_p4": "fn next(&mut self) -> Option<Self::Item> {\n        let slice = mem::take(&mut self.0);\n        if slice.is_empty() { return None; }",
        "nomicon_fn_main_p5": "let (l, r) = slice.split_at_mut(1);\n        self.0 = r;\n        l.get_mut(0)\n    }\n}",
        "nomicon_fn_main_p6": "impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n    fn next_back(&mut self) -> Option<Self::Item> {\n        let slice = mem::take(&mut self.0);\n        if slice.is_empty() { return None; }",
        "nomicon_fn_main_p7": "let new_len = slice.len() - 1;\n        let (l, r) = slice.split_at_mut(new_len);\n        self.0 = l;\n        r.get_mut(0)\n    }\n}",
        "nomicon_fn_main_p8": "And here's a binary tree:",
        "nomicon_fn_main_p9": ""
      }
    },
    {
      "id": "nomicon_fn_main",
      "title": "fn main() {}",
      "level": 1,
      "content": "use std::collections::VecDeque;\n\ntype Link<T> = Option<Box<Node<T>>>;\n\nstruct Node<T> {\n    elem: T,\n    left: Link<T>,\n    right: Link<T>,\n}\n\npub struct Tree<T> {\n    root: Link<T>,\n}\n\nstruct NodeIterMut<'a, T: 'a> {\n    elem: Option<&'a mut T>,\n    left: Option<&'a mut Node<T>>,\n    right: Option<&'a mut Node<T>>,\n}\n\nenum State<'a, T: 'a> {\n    Elem(&'a mut T),\n    Node(&'a mut Node<T>),\n}\n\npub struct IterMut<'a, T: 'a>(VecDeque<NodeIterMut<'a, T>>);\n\nimpl<T> Tree<T> {\n    pub fn iter_mut(&mut self) -> IterMut<T> {\n        let mut deque = VecDeque::new();\n        if let Some(root) = self.root.as_mut() {\n            deque.push_front(root.iter_mut());\n        }\n        IterMut(deque)\n    }\n}\n\nimpl<T> Node<T> {\n    pub fn iter_mut(&mut self) -> NodeIterMut<T> {\n        NodeIterMut {\n            elem: Some(&mut self.elem),\n            left: self.left.as_deref_mut(),\n            right: self.right.as_deref_mut(),\n        }\n    }\n}\n\nimpl<'a, T> Iterator for NodeIterMut<'a, T> {\n    type Item = State<'a, T>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.left.take().map(State::Node).or_else(|| {\n            self.elem\n                .take()\n                .map(State::Elem)\n                .or_else(|| self.right.take().map(State::Node))\n        })\n    }\n}\n\nimpl<'a, T> DoubleEndedIterator for NodeIterMut<'a, T> {\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.right.take().map(State::Node).or_else(|| {\n            self.elem\n                .take()\n                .map(State::Elem)\n                .or_else(|| self.left.take().map(State::Node))\n        })\n    }\n}\n\nimpl<'a, T> Iterator for IterMut<'a, T> {\n    type Item = &'a mut T;\n    fn next(&mut self) -> Option<Self::Item> {\n        loop {\n            match self.0.front_mut().and_then(Iterator::next) {\n                Some(State::Elem(elem)) => return Some(elem),\n                Some(State::Node(node)) => self.0.push_front(node.iter_mut()),\n                None => {\n                    self.0.pop_front()?;\n                }\n            }\n        }\n    }\n}\n\nimpl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n    fn next_back(&mut self) -> Option<Self::Item> {\n        loop {\n            match self.0.back_mut().and_then(DoubleEndedIterator::next_back) {\n                Some(State::Elem(elem)) => return Some(elem),\n                Some(State::Node(node)) => self.0.push_back(node.iter_mut()),\n                None => {\n                    self.0.pop_back()?;\n                }\n            }\n        }\n    }\n}\n\nAll of these are completely safe and work on stable Rust! This ultimately\nfalls out of the simple struct case we saw before: Rust understands that you\ncan safely split a mutable reference into subfields. We can then encode\npermanently consuming a reference via Options (or in the case of slices,\nreplacing with an empty slice).",
      "parent_id": null,
      "paragraphs": {
        "nomicon_fn_main_p1": "use std::collections::VecDeque;",
        "nomicon_fn_main_p2": "type Link<T> = Option<Box<Node<T>>>;",
        "nomicon_fn_main_p3": "struct Node<T> {\n    elem: T,\n    left: Link<T>,\n    right: Link<T>,\n}",
        "nomicon_fn_main_p4": "pub struct Tree<T> {\n    root: Link<T>,\n}",
        "nomicon_fn_main_p5": "struct NodeIterMut<'a, T: 'a> {\n    elem: Option<&'a mut T>,\n    left: Option<&'a mut Node<T>>,\n    right: Option<&'a mut Node<T>>,\n}",
        "nomicon_fn_main_p6": "enum State<'a, T: 'a> {\n    Elem(&'a mut T),\n    Node(&'a mut Node<T>),\n}",
        "nomicon_fn_main_p7": "pub struct IterMut<'a, T: 'a>(VecDeque<NodeIterMut<'a, T>>);",
        "nomicon_fn_main_p8": "impl<T> Tree<T> {\n    pub fn iter_mut(&mut self) -> IterMut<T> {\n        let mut deque = VecDeque::new();\n        if let Some(root) = self.root.as_mut() {\n            deque.push_front(root.iter_mut());\n        }\n        IterMut(deque)\n    }\n}",
        "nomicon_fn_main_p9": "impl<T> Node<T> {\n    pub fn iter_mut(&mut self) -> NodeIterMut<T> {\n        NodeIterMut {\n            elem: Some(&mut self.elem),\n            left: self.left.as_deref_mut(),\n            right: self.right.as_deref_mut(),\n        }\n    }\n}",
        "nomicon_fn_main_p10": "impl<'a, T> Iterator for NodeIterMut<'a, T> {\n    type Item = State<'a, T>;",
        "nomicon_fn_main_p11": "fn next(&mut self) -> Option<Self::Item> {\n        self.left.take().map(State::Node).or_else(|| {\n            self.elem\n                .take()\n                .map(State::Elem)\n                .or_else(|| self.right.take().map(State::Node))\n        })\n    }\n}",
        "nomicon_fn_main_p12": "impl<'a, T> DoubleEndedIterator for NodeIterMut<'a, T> {\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.right.take().map(State::Node).or_else(|| {\n            self.elem\n                .take()\n                .map(State::Elem)\n                .or_else(|| self.left.take().map(State::Node))\n        })\n    }\n}",
        "nomicon_fn_main_p13": "impl<'a, T> Iterator for IterMut<'a, T> {\n    type Item = &'a mut T;\n    fn next(&mut self) -> Option<Self::Item> {\n        loop {\n            match self.0.front_mut().and_then(Iterator::next) {\n                Some(State::Elem(elem)) => return Some(elem),\n                Some(State::Node(node)) => self.0.push_front(node.iter_mut()),\n                None => {\n                    self.0.pop_front()?;\n                }\n            }\n        }\n    }\n}",
        "nomicon_fn_main_p14": "impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n    fn next_back(&mut self) -> Option<Self::Item> {\n        loop {\n            match self.0.back_mut().and_then(DoubleEndedIterator::next_back) {\n                Some(State::Elem(elem)) => return Some(elem),\n                Some(State::Node(node)) => self.0.push_back(node.iter_mut()),\n                None => {\n                    self.0.pop_back()?;\n                }\n            }\n        }\n    }\n}",
        "nomicon_fn_main_p15": "All of these are completely safe and work on stable Rust! This ultimately\nfalls out of the simple struct case we saw before: Rust understands that you\ncan safely split a mutable reference into subfields. We can then encode\npermanently consuming a reference via Options (or in the case of slices,\nreplacing with an empty slice)."
      }
    }
  ],
  "ids": [
    "nomicon_limits_of_lifetimes_p13",
    "nomicon_lifetime_elision_p3",
    "nomicon_higher_rank_trait_bounds_hrtbs_p13",
    "nomicon_lifetime_elision_p10",
    "nomicon_lifetime_elision_p9",
    "nomicon_higher_rank_trait_bounds_hrtbs_p10",
    "nomicon_subtyping_and_variance_p7",
    "nomicon_drop_check_p1",
    "nomicon_drop_check_p34",
    "nomicon_generic_parameters_and_drop_checking",
    "nomicon_use_std_cell_refcell_p13",
    "nomicon_is_that_all_about_drop_checker_p2",
    "nomicon_p7",
    "nomicon_limits_of_lifetimes_p10",
    "nomicon_use_std_hash_hash_p4",
    "nomicon_use_std_cell_refcell_p6",
    "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p3",
    "nomicon_why_aliasing_matters_p8",
    "nomicon_a_related_side_note_about_drop_order",
    "nomicon_limits_of_lifetimes_p6",
    "nomicon_variance_p51",
    "nomicon_subtyping_and_variance_p1",
    "nomicon_an_escape_hatch_p23",
    "nomicon_use_std_cell_refcell_p9",
    "nomicon_why_aliasing_matters_p18",
    "nomicon_variance_p19",
    "nomicon_drop_check_p37",
    "nomicon_ownership_and_lifetimes_p4",
    "nomicon_why_aliasing_matters_p14",
    "nomicon_subtyping_p3",
    "nomicon_use_std_cell_refcell_p5",
    "nomicon_variance_p46",
    "nomicon_use_std_cell_refcell_p4",
    "nomicon_an_escape_hatch_p1",
    "nomicon_cfg_any_p5",
    "nomicon_ownership_and_lifetimes_p2",
    "nomicon_fn_main_p5",
    "nomicon_higher_rank_trait_bounds_hrtbs_p21",
    "nomicon_drop_check",
    "nomicon_limits_of_lifetimes_p7",
    "nomicon_why_aliasing_matters_p20",
    "nomicon_subtyping_p7",
    "nomicon_generic_parameters_and_drop_checking_p2",
    "nomicon_fn_main_p13",
    "nomicon_phantomdata_p5",
    "nomicon_an_escape_hatch_p25",
    "nomicon_aliasing_p3",
    "nomicon_why_aliasing_matters_p3",
    "nomicon_lifetimes_p12",
    "nomicon_why_aliasing_matters_p17",
    "nomicon_lifetime_elision_p7",
    "nomicon_why_aliasing_matters_p21",
    "nomicon_limits_of_lifetimes_p8",
    "nomicon_table_of_phantomdata_patterns_p1",
    "nomicon_limits_of_lifetimes_p2",
    "nomicon_variance_p18",
    "nomicon_lifetime_elision_p8",
    "nomicon_an_escape_hatch_p27",
    "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle",
    "nomicon_variance_p54",
    "nomicon_splitting_borrows_p1",
    "nomicon_example_references_that_outlive_referents_p9",
    "nomicon_references_p7",
    "nomicon_cfg_any_p3",
    "nomicon_example_references_that_outlive_referents_p4",
    "nomicon_references_p8",
    "nomicon_lifetimes_p7",
    "nomicon_the_area_covered_by_a_lifetime_p4",
    "nomicon_an_escape_hatch_p19",
    "nomicon_lifetime_elision",
    "nomicon_lifetime_elision_p16",
    "nomicon_example_references_that_outlive_referents_p11",
    "nomicon_aliasing_p1",
    "nomicon_impl_t_fakeslice_t",
    "nomicon_use_std_cell_refcell",
    "nomicon_generic_parameters_and_drop_checking_p4",
    "nomicon_example_references_that_outlive_referents",
    "nomicon_drop_check_p4",
    "nomicon_variance_p22",
    "nomicon_why_aliasing_matters_p15",
    "nomicon_example_aliasing_a_mutable_reference_p4",
    "nomicon_is_that_all_about_drop_checker_p1",
    "nomicon_use_std_hash_hash_p1",
    "nomicon_higher_rank_trait_bounds_hrtbs_p19",
    "nomicon_drop_check_p13",
    "nomicon_lifetimes_p13",
    "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p2",
    "nomicon_phantomdata",
    "nomicon_use_std_cell_refcell_p16",
    "nomicon_phantomdata_p3",
    "nomicon_variance_p49",
    "nomicon_unbounded_lifetimes_p3",
    "nomicon_variance_p50",
    "nomicon_example_aliasing_a_mutable_reference_p2",
    "nomicon_higher_rank_trait_bounds_hrtbs_p16",
    "nomicon_why_aliasing_matters_p12",
    "nomicon_lifetimes_p10",
    "nomicon_variance_p5",
    "nomicon_variance_p42",
    "nomicon_fn_main_p11",
    "nomicon_lifetime_elision_p15",
    "nomicon_higher_rank_trait_bounds_hrtbs_p18",
    "nomicon_drop_check_p15",
    "nomicon_lifetimes_p4",
    "nomicon_the_area_covered_by_a_lifetime_p10",
    "nomicon_an_escape_hatch_p10",
    "nomicon_higher_rank_trait_bounds_hrtbs_p17",
    "nomicon_splitting_borrows_p7",
    "nomicon_subtyping_p13",
    "nomicon_higher_rank_trait_bounds_hrtbs_p22",
    "nomicon_use_std_cell_refcell_p15",
    "nomicon_variance_p30",
    "nomicon_references_p5",
    "nomicon_drop_check_p18",
    "nomicon_example_aliasing_a_mutable_reference",
    "nomicon_an_escape_hatch_p6",
    "nomicon_higher_rank_trait_bounds_hrtbs_p7",
    "nomicon_variance_p45",
    "nomicon_p10",
    "nomicon_variance_p3",
    "nomicon_struct_fakeslice_t_t",
    "nomicon_cfg_any_p7",
    "nomicon_drop_check_p20",
    "nomicon_is_that_all_about_drop_checker",
    "nomicon_use_std_cell_refcell_p12",
    "nomicon_fn_main_p12",
    "nomicon_ownership_and_lifetimes_p10",
    "nomicon_references",
    "nomicon_unbounded_lifetimes_p6",
    "nomicon_why_aliasing_matters_p19",
    "nomicon_drop_check_p8",
    "nomicon_higher_rank_trait_bounds_hrtbs_p15",
    "nomicon_ownership_and_lifetimes_p3",
    "nomicon_limits_of_lifetimes_p11",
    "nomicon_limits_of_lifetimes_p12",
    "nomicon_why_aliasing_matters_p16",
    "nomicon_splitting_borrows_p6",
    "nomicon_fn_as_mut_ptr_mut_self_mut_t_unimplemented_p1",
    "nomicon_fn_main_p10",
    "nomicon_p8",
    "nomicon_subtyping_and_variance_p6",
    "nomicon_an_escape_hatch_p12",
    "nomicon_p1",
    "nomicon_limits_of_lifetimes",
    "nomicon_variance_p20",
    "nomicon_lifetimes_p6",
    "nomicon_subtyping_p1",
    "nomicon_splitting_borrows_p8",
    "nomicon_ownership_and_lifetimes_p6",
    "nomicon_use_std_hash_hash_p2",
    "nomicon_use_std_cell_refcell_p17",
    "nomicon_ownership_and_lifetimes_p12",
    "nomicon_references_p2",
    "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p12",
    "nomicon_fn_main_p6",
    "nomicon_higher_rank_trait_bounds_hrtbs_p8",
    "nomicon_subtyping_p12",
    "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p16",
    "nomicon_an_escape_hatch_p16",
    "nomicon_generic_parameters_and_drop_checking_p6",
    "nomicon_table_of_phantomdata_patterns_p3",
    "nomicon_an_escape_hatch_p20",
    "nomicon_lifetimes_p2",
    "nomicon_higher_rank_trait_bounds_hrtbs_p3",
    "nomicon_fn_some_condition_bool_true_p4",
    "nomicon_table_of_phantomdata_patterns_p2",
    "nomicon_subtyping_p5",
    "nomicon_variance_p53",
    "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p13",
    "nomicon_lifetime_elision_p19",
    "nomicon_variance_p26",
    "nomicon_limits_of_lifetimes_p1",
    "nomicon_subtyping_and_variance_p3",
    "nomicon_unbounded_lifetimes_p1",
    "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p20",
    "nomicon_drop_check_p19",
    "nomicon_improperly_reduced_borrows_p2",
    "nomicon_the_area_covered_by_a_lifetime_p2",
    "nomicon_drop_check_p30",
    "nomicon_an_escape_hatch_p4",
    "nomicon_improperly_reduced_borrows_p1",
    "nomicon_variance_p14",
    "nomicon_variance_p43",
    "nomicon_an_escape_hatch_p22",
    "nomicon_variance_p17",
    "nomicon_p6",
    "nomicon_fn_some_condition_bool_true_p6",
    "nomicon_drop_check_p36",
    "nomicon_variance_p31",
    "nomicon_variance_p10",
    "nomicon_variance_p15",
    "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p19",
    "nomicon_use_std_cell_refcell_p11",
    "nomicon_ownership_and_lifetimes_p8",
    "nomicon_p5",
    "nomicon_the_area_covered_by_a_lifetime_p9",
    "nomicon_splitting_borrows_p2",
    "nomicon_variance_p52",
    "nomicon_the_area_covered_by_a_lifetime_p5",
    "nomicon_higher_rank_trait_bounds_hrtbs_p14",
    "nomicon_fn_main_p9",
    "nomicon_variance_p7",
    "nomicon_phantomdata_p6",
    "nomicon_lifetimes_p11",
    "nomicon_unbounded_lifetimes_p4",
    "nomicon_use_std_cell_refcell_p2",
    "nomicon_fn_main_p14",
    "nomicon_lifetime_elision_p17",
    "nomicon_fn_main_p3",
    "nomicon_ownership_and_lifetimes_p5",
    "nomicon_drop_check_p11",
    "nomicon_splitting_borrows_p3",
    "nomicon_phantomdata_p9",
    "nomicon_example_references_that_outlive_referents_p8",
    "nomicon_higher_rank_trait_bounds_hrtbs_p11",
    "nomicon_lifetimes_p3",
    "nomicon_higher_rank_trait_bounds_hrtbs_p2",
    "nomicon_lifetime_elision_p14",
    "nomicon_higher_rank_trait_bounds_hrtbs_p4",
    "nomicon_limits_of_lifetimes_p9",
    "nomicon_p2",
    "nomicon_aliasing",
    "nomicon_variance_p44",
    "nomicon_an_escape_hatch",
    "nomicon_fn_some_condition_bool_true_p5",
    "nomicon_drop_check_p38",
    "nomicon_higher_rank_trait_bounds_hrtbs_p12",
    "nomicon_lifetime_elision_p2",
    "nomicon_drop_check_p12",
    "nomicon_references_p1",
    "nomicon_ownership_and_lifetimes_p7",
    "nomicon_variance_p40",
    "nomicon_limits_of_lifetimes_p3",
    "nomicon_drop_check_p35",
    "nomicon_ownership_and_lifetimes",
    "nomicon_subtyping_p8",
    "nomicon_lifetimes_p8",
    "nomicon_lifetimes",
    "nomicon_drop_check_p29",
    "nomicon_lifetime_elision_p11",
    "nomicon_drop_check_p6",
    "nomicon_lifetimes_p9",
    "nomicon_lifetime_elision_p4",
    "nomicon_phantomdata_p4",
    "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p7",
    "nomicon_variance",
    "nomicon_subtyping_and_variance",
    "nomicon_generic_parameters_and_drop_checking_p5",
    "nomicon_drop_check_p25",
    "nomicon_variance_p6",
    "nomicon_example_references_that_outlive_referents_p7",
    "nomicon_variance_p29",
    "nomicon_fn_some_condition_bool_true",
    "nomicon_example_aliasing_a_mutable_reference_p1",
    "nomicon_drop_check_p7",
    "nomicon_why_aliasing_matters_p4",
    "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p8",
    "nomicon_drop_check_p14",
    "nomicon_why_aliasing_matters_p9",
    "nomicon_splitting_borrows_p10",
    "nomicon_splitting_borrows_p4",
    "nomicon_use_std_cell_refcell_p8",
    "nomicon_higher_rank_trait_bounds_hrtbs_p9",
    "nomicon_higher_rank_trait_bounds_hrtbs_p20",
    "nomicon_fn_len_self_usize_unimplemented",
    "nomicon_p11",
    "nomicon_unbounded_lifetimes",
    "nomicon_table_of_phantomdata_patterns_p4",
    "nomicon_variance_p39",
    "nomicon_drop_check_p31",
    "nomicon_an_escape_hatch_p26",
    "nomicon_fn_main_p15",
    "nomicon_drop_check_p17",
    "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p14",
    "nomicon_variance_p8",
    "nomicon_an_escape_hatch_p21",
    "nomicon_limits_of_lifetimes_p4",
    "nomicon_generic_parameters_and_drop_checking_p3",
    "nomicon_drop_check_p16",
    "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p6",
    "nomicon_example_references_that_outlive_referents_p5",
    "nomicon_an_escape_hatch_p7",
    "nomicon_drop_check_p26",
    "nomicon_variance_p13",
    "nomicon",
    "nomicon_fn_some_condition_bool_true_p1",
    "nomicon_subtyping_p10",
    "nomicon_example_references_that_outlive_referents_p13",
    "nomicon_use_std_collections_hashmap",
    "nomicon_higher_rank_trait_bounds_hrtbs_p23",
    "nomicon_higher_rank_trait_bounds_hrtbs_p1",
    "nomicon_lifetime_elision_p5",
    "nomicon_why_aliasing_matters_p5",
    "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p17",
    "nomicon_why_aliasing_matters",
    "nomicon_subtyping_p4",
    "nomicon_use_std_hash_hash",
    "nomicon_variance_p12",
    "nomicon_subtyping_p2",
    "nomicon_why_aliasing_matters_p13",
    "nomicon_example_aliasing_a_mutable_reference_p3",
    "nomicon_drop_check_p2",
    "nomicon_an_escape_hatch_p18",
    "nomicon_use_std_cell_refcell_p18",
    "nomicon_variance_p27",
    "nomicon_why_aliasing_matters_p7",
    "nomicon_example_aliasing_a_mutable_reference_p6",
    "nomicon_use_std_cell_refcell_p1",
    "nomicon_phantomdata_p1",
    "nomicon_aliasing_p4",
    "nomicon_why_aliasing_matters_p6",
    "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p5",
    "nomicon_an_escape_hatch_p24",
    "nomicon_a_related_side_note_about_drop_order_p1",
    "nomicon_references_p10",
    "nomicon_splitting_borrows_p5",
    "nomicon_an_escape_hatch_p9",
    "nomicon_drop_check_p27",
    "nomicon_an_escape_hatch_p17",
    "nomicon_variance_p33",
    "nomicon_variance_p34",
    "nomicon_why_aliasing_matters_p2",
    "nomicon_phantomdata_p7",
    "nomicon_variance_p28",
    "nomicon_subtyping_and_variance_p8",
    "nomicon_use_std_cell_refcell_p14",
    "nomicon_use_std_cell_refcell_p3",
    "nomicon_the_area_covered_by_a_lifetime_p7",
    "nomicon_variance_p47",
    "nomicon_drop_check_p5",
    "nomicon_example_references_that_outlive_referents_p3",
    "nomicon_ownership_and_lifetimes_p1",
    "nomicon_subtyping_p6",
    "nomicon_example_references_that_outlive_referents_p2",
    "nomicon_improperly_reduced_borrows",
    "nomicon_fn_main_p4",
    "nomicon_cfg_any_p6",
    "nomicon_drop_check_p9",
    "nomicon_drop_check_p3",
    "nomicon_references_p3",
    "nomicon_the_area_covered_by_a_lifetime",
    "nomicon_lifetime_elision_p18",
    "nomicon_lifetimes_p1",
    "nomicon_subtyping_and_variance_p4",
    "nomicon_unbounded_lifetimes_p2",
    "nomicon_example_references_that_outlive_referents_p6",
    "nomicon_fn_as_mut_ptr_mut_self_mut_t_unimplemented_p2",
    "nomicon_references_p4",
    "nomicon_drop_check_p21",
    "nomicon_subtyping",
    "nomicon_phantomdata_p8",
    "nomicon_fn_some_condition_bool_true_p3",
    "nomicon_higher_rank_trait_bounds_hrtbs",
    "nomicon_why_aliasing_matters_p11",
    "nomicon_p9",
    "nomicon_subtyping_p11",
    "nomicon_an_escape_hatch_p3",
    "nomicon_fn_main",
    "nomicon_subtyping_and_variance_p2",
    "nomicon_use_std_hash_hash_p3",
    "nomicon_variance_p35",
    "nomicon_phantomdata_p2",
    "nomicon_drop_check_p33",
    "nomicon_unbounded_lifetimes_p7",
    "nomicon_table_of_phantomdata_patterns",
    "nomicon_use_std_slice_from_raw_parts_mut",
    "nomicon_fn_main_p7",
    "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p1",
    "nomicon_references_p9",
    "nomicon_higher_rank_trait_bounds_hrtbs_p6",
    "nomicon_cfg_any_p2",
    "nomicon_higher_rank_trait_bounds_hrtbs_p5",
    "nomicon_fn_as_mut_ptr_mut_self_mut_t_unimplemented_p3",
    "nomicon_subtyping_p9",
    "nomicon_drop_check_p24",
    "nomicon_variance_p1",
    "nomicon_cfg_any",
    "nomicon_an_escape_hatch_p5",
    "nomicon_splitting_borrows",
    "nomicon_variance_p37",
    "nomicon_drop_check_p28",
    "nomicon_subtyping_and_variance_p5",
    "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p4",
    "nomicon_why_aliasing_matters_p10",
    "nomicon_use_std_cell_refcell_p7",
    "nomicon_fn_main_p2",
    "nomicon_why_aliasing_matters_p1",
    "nomicon_lifetime_elision_p6",
    "nomicon_generic_parameters_and_drop_checking_p1",
    "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p10",
    "nomicon_references_p6",
    "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p21",
    "nomicon_variance_p16",
    "nomicon_variance_p32",
    "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p15",
    "nomicon_use_std_cell_refcell_p10",
    "nomicon_fn_as_mut_ptr_mut_self_mut_t_unimplemented",
    "nomicon_ownership_and_lifetimes_p11",
    "nomicon_splitting_borrows_p9",
    "nomicon_fn_some_condition_bool_true_p2",
    "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p11",
    "nomicon_an_escape_hatch_p15",
    "nomicon_ownership_and_lifetimes_p9",
    "nomicon_cfg_any_p1",
    "nomicon_example_references_that_outlive_referents_p12",
    "nomicon_example_references_that_outlive_referents_p14",
    "nomicon_variance_p38",
    "nomicon_an_escape_hatch_p13",
    "nomicon_variance_p41",
    "nomicon_an_escape_hatch_p8",
    "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p18",
    "nomicon_lifetime_elision_p13",
    "nomicon_variance_p36",
    "nomicon_lifetime_elision_p12",
    "nomicon_lifetime_elision_p20",
    "nomicon_the_area_covered_by_a_lifetime_p1",
    "nomicon_an_escape_hatch_p2",
    "nomicon_fn_main_p8",
    "nomicon_p3",
    "nomicon_drop_check_p10",
    "nomicon_variance_p4",
    "nomicon_lifetimes_p5",
    "nomicon_variance_p2",
    "nomicon_variance_p23",
    "nomicon_unbounded_lifetimes_p5",
    "nomicon_example_references_that_outlive_referents_p1",
    "nomicon_drop_check_p23",
    "nomicon_an_escape_hatch_p14",
    "nomicon_the_area_covered_by_a_lifetime_p8",
    "nomicon_p4",
    "nomicon_example_aliasing_a_mutable_reference_p5",
    "nomicon_fn_main_p1",
    "nomicon_variance_p48",
    "nomicon_an_exception_the_special_case_of_the_standard_library_and_its_unstable_may_dangle_p9",
    "nomicon_example_references_that_outlive_referents_p10",
    "nomicon_variance_p25",
    "nomicon_variance_p11",
    "nomicon_aliasing_p2",
    "nomicon_the_area_covered_by_a_lifetime_p6",
    "nomicon_the_area_covered_by_a_lifetime_p3",
    "nomicon_variance_p9",
    "nomicon_variance_p21",
    "nomicon_variance_p24",
    "nomicon_drop_check_p22",
    "nomicon_limits_of_lifetimes_p5",
    "nomicon_cfg_any_p4",
    "nomicon_an_escape_hatch_p11",
    "nomicon_drop_check_p32",
    "nomicon_lifetime_elision_p1"
  ]
}
