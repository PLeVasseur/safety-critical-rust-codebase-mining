{
  "source": "Rustonomicon",
  "source_repo": "https://github.com/rust-lang/nomicon",
  "extraction_date": "2026-01-03",
  "chapter": 7,
  "title": "Ownership Based Resource Management",
  "file": "obrm.md",
  "sections": [
    {
      "id": "nomicon_the_perils_of_ownership_based_resource_management_obrm",
      "title": "The Perils Of Ownership Based Resource Management (OBRM)",
      "level": 1,
      "content": "OBRM (AKA RAII: Resource Acquisition Is Initialization) is something you'll\ninteract with a lot in Rust. Especially if you use the standard library.\n\nRoughly speaking the pattern is as follows: to acquire a resource, you create an\nobject that manages it. To release the resource, you simply destroy the object,\nand it cleans up the resource for you. The most common \"resource\" this pattern\nmanages is simply *memory*. `Box`, `Rc`, and basically everything in\n`std::collections` is a convenience to enable correctly managing memory. This is\nparticularly important in Rust because we have no pervasive GC to rely on for\nmemory management. Which is the point, really: Rust is about control. However we\nare not limited to just memory. Pretty much every other system resource like a\nthread, file, or socket is exposed through this kind of API.",
      "parent_id": null,
      "paragraphs": {
        "nomicon_the_perils_of_ownership_based_resource_management_obrm_p1": "OBRM (AKA RAII: Resource Acquisition Is Initialization) is something you'll\ninteract with a lot in Rust. Especially if you use the standard library.",
        "nomicon_the_perils_of_ownership_based_resource_management_obrm_p2": "Roughly speaking the pattern is as follows: to acquire a resource, you create an\nobject that manages it. To release the resource, you simply destroy the object,\nand it cleans up the resource for you. The most common \"resource\" this pattern\nmanages is simply *memory*. `Box`, `Rc`, and basically everything in\n`std::collections` is a convenience to enable correctly managing memory. This is\nparticularly important in Rust because we have no pervasive GC to rely on for\nmemory management. Which is the point, really: Rust is about control. However we\nare not limited to just memory. Pretty much every other system resource like a\nthread, file, or socket is exposed through this kind of API."
      }
    },
    {
      "id": "nomicon_constructors",
      "title": "Constructors",
      "level": 1,
      "content": "There is exactly one way to create an instance of a user-defined type: name it,\nand initialize all its fields at once:\n\nstruct Foo {\n    a: u8,\n    b: u32,\n    c: bool,\n}\n\nenum Bar {\n    X(u32),\n    Y(bool),\n}\n\nstruct Unit;\n\nlet foo = Foo { a: 0, b: 1, c: false };\nlet bar = Bar::X(0);\nlet empty = Unit;\n\nThat's it. Every other way you make an instance of a type is just calling a\ntotally vanilla function that does some stuff and eventually bottoms out to The\nOne True Constructor.\n\nUnlike C++, Rust does not come with a slew of built-in kinds of constructor.\nThere are no Copy, Default, Assignment, Move, or whatever constructors. The\nreasons for this are varied, but it largely boils down to Rust's philosophy of\n*being explicit*.\n\nMove constructors are meaningless in Rust because we don't enable types to\n\"care\" about their location in memory. Every type must be ready for it to be\nblindly memcopied to somewhere else in memory. This means pure on-the-stack-but-\nstill-movable intrusive linked lists are simply not happening in Rust (safely).\n\nAssignment and copy constructors similarly don't exist because move semantics\nare the only semantics in Rust. At most `x = y` just moves the bits of y into\nthe x variable. Rust does provide two facilities for providing C++'s copy-\noriented semantics: `Copy` and `Clone`. Clone is our moral equivalent of a copy\nconstructor, but it's never implicitly invoked. You have to explicitly call\n`clone` on an element you want to be cloned. Copy is a special case of Clone\nwhere the implementation is just \"copy the bits\". Copy types *are* implicitly\ncloned whenever they're moved, but because of the definition of Copy this just\nmeans not treating the old copy as uninitialized -- a no-op.\n\nWhile Rust provides a `Default` trait for specifying the moral equivalent of a\ndefault constructor, it's incredibly rare for this trait to be used. This is\nbecause variables aren't implicitly initialized. Default is basically\nonly useful for generic programming. In concrete contexts, a type will provide a\nstatic `new` method for any kind of \"default\" constructor. This has no relation\nto `new` in other languages and has no special meaning. It's just a naming\nconvention.\n\nTODO: talk about \"placement new\"?\n\n[uninit]: uninitialized.html",
      "parent_id": null,
      "paragraphs": {
        "nomicon_constructors_p1": "There is exactly one way to create an instance of a user-defined type: name it,\nand initialize all its fields at once:",
        "nomicon_constructors_p2": "struct Foo {\n    a: u8,\n    b: u32,\n    c: bool,\n}",
        "nomicon_constructors_p3": "enum Bar {\n    X(u32),\n    Y(bool),\n}",
        "nomicon_constructors_p4": "struct Unit;",
        "nomicon_constructors_p5": "let foo = Foo { a: 0, b: 1, c: false };\nlet bar = Bar::X(0);\nlet empty = Unit;",
        "nomicon_constructors_p6": "That's it. Every other way you make an instance of a type is just calling a\ntotally vanilla function that does some stuff and eventually bottoms out to The\nOne True Constructor.",
        "nomicon_constructors_p7": "Unlike C++, Rust does not come with a slew of built-in kinds of constructor.\nThere are no Copy, Default, Assignment, Move, or whatever constructors. The\nreasons for this are varied, but it largely boils down to Rust's philosophy of\n*being explicit*.",
        "nomicon_constructors_p8": "Move constructors are meaningless in Rust because we don't enable types to\n\"care\" about their location in memory. Every type must be ready for it to be\nblindly memcopied to somewhere else in memory. This means pure on-the-stack-but-\nstill-movable intrusive linked lists are simply not happening in Rust (safely).",
        "nomicon_constructors_p9": "Assignment and copy constructors similarly don't exist because move semantics\nare the only semantics in Rust. At most `x = y` just moves the bits of y into\nthe x variable. Rust does provide two facilities for providing C++'s copy-\noriented semantics: `Copy` and `Clone`. Clone is our moral equivalent of a copy\nconstructor, but it's never implicitly invoked. You have to explicitly call\n`clone` on an element you want to be cloned. Copy is a special case of Clone\nwhere the implementation is just \"copy the bits\". Copy types *are* implicitly\ncloned whenever they're moved, but because of the definition of Copy this just\nmeans not treating the old copy as uninitialized -- a no-op.",
        "nomicon_constructors_p10": "While Rust provides a `Default` trait for specifying the moral equivalent of a\ndefault constructor, it's incredibly rare for this trait to be used. This is\nbecause variables aren't implicitly initialized. Default is basically\nonly useful for generic programming. In concrete contexts, a type will provide a\nstatic `new` method for any kind of \"default\" constructor. This has no relation\nto `new` in other languages and has no special meaning. It's just a naming\nconvention.",
        "nomicon_constructors_p11": "TODO: talk about \"placement new\"?",
        "nomicon_constructors_p12": "[uninit]: uninitialized.html"
      }
    },
    {
      "id": "nomicon_destructors",
      "title": "Destructors",
      "level": 1,
      "content": "What the language *does* provide is full-blown automatic destructors through the\n`Drop` trait, which provides the following method:\n\n<!-- ignore: function header -->\n,ignore\nfn drop(&mut self);\n\nThis method gives the type time to somehow finish what it was doing.\n\n**After `drop` is run, Rust will recursively try to drop all of the fields\nof `self`.**\n\nThis is a convenience feature so that you don't have to write \"destructor\nboilerplate\" to drop children. If a struct has no special logic for being\ndropped other than dropping its children, then it means `Drop` doesn't need to\nbe implemented at all!\n\n**There is no stable way to prevent this behavior in Rust 1.0.**\n\nNote that taking `&mut self` means that even if you could suppress recursive\nDrop, Rust will prevent you from e.g. moving fields out of self. For most types,\nthis is totally fine.\n\nFor instance, a custom implementation of `Box` might write `Drop` like this:\n\n#![feature(ptr_internals, allocator_api)]\n\nuse std::alloc::{Allocator, Global, GlobalAlloc, Layout};\nuse std::mem;\nuse std::ptr::{drop_in_place, NonNull, Unique};\n\nstruct Box<T>{ ptr: Unique<T> }\n\nimpl<T> Drop for Box<T> {\n    fn drop(&mut self) {\n        unsafe {\n            drop_in_place(self.ptr.as_ptr());\n            let c: NonNull<T> = self.ptr.into();\n            Global.deallocate(c.cast(), Layout::new::<T>())\n        }\n    }\n}",
      "parent_id": null,
      "paragraphs": {
        "nomicon_destructors_p1": "What the language *does* provide is full-blown automatic destructors through the\n`Drop` trait, which provides the following method:",
        "nomicon_destructors_p2": "<!-- ignore: function header -->\n,ignore\nfn drop(&mut self);",
        "nomicon_destructors_p3": "This method gives the type time to somehow finish what it was doing.",
        "nomicon_destructors_p4": "**After `drop` is run, Rust will recursively try to drop all of the fields\nof `self`.**",
        "nomicon_destructors_p5": "This is a convenience feature so that you don't have to write \"destructor\nboilerplate\" to drop children. If a struct has no special logic for being\ndropped other than dropping its children, then it means `Drop` doesn't need to\nbe implemented at all!",
        "nomicon_destructors_p6": "**There is no stable way to prevent this behavior in Rust 1.0.**",
        "nomicon_destructors_p7": "Note that taking `&mut self` means that even if you could suppress recursive\nDrop, Rust will prevent you from e.g. moving fields out of self. For most types,\nthis is totally fine.",
        "nomicon_destructors_p8": "For instance, a custom implementation of `Box` might write `Drop` like this:",
        "nomicon_destructors_p9": "#![feature(ptr_internals, allocator_api)]",
        "nomicon_destructors_p10": "use std::alloc::{Allocator, Global, GlobalAlloc, Layout};\nuse std::mem;\nuse std::ptr::{drop_in_place, NonNull, Unique};",
        "nomicon_destructors_p11": "struct Box<T>{ ptr: Unique<T> }",
        "nomicon_destructors_p12": "impl<T> Drop for Box<T> {\n    fn drop(&mut self) {\n        unsafe {\n            drop_in_place(self.ptr.as_ptr());\n            let c: NonNull<T> = self.ptr.into();\n            Global.deallocate(c.cast(), Layout::new::<T>())\n        }\n    }\n}"
      }
    },
    {
      "id": "nomicon_fn_main",
      "title": "fn main() {}",
      "level": 1,
      "content": "and this works fine because when Rust goes to drop the `ptr` field it just sees\na [Unique] that has no actual `Drop` implementation. Similarly nothing can\nuse-after-free the `ptr` because when drop exits, it becomes inaccessible.\n\nHowever this wouldn't work:\n\n#![feature(allocator_api, ptr_internals)]\n\nuse std::alloc::{Allocator, Global, GlobalAlloc, Layout};\nuse std::ptr::{drop_in_place, Unique, NonNull};\nuse std::mem;\n\nstruct Box<T>{ ptr: Unique<T> }\n\nimpl<T> Drop for Box<T> {\n    fn drop(&mut self) {\n        unsafe {\n            drop_in_place(self.ptr.as_ptr());\n            let c: NonNull<T> = self.ptr.into();\n            Global.deallocate(c.cast(), Layout::new::<T>());\n        }\n    }\n}\n\nstruct SuperBox<T> { my_box: Box<T> }\n\nimpl<T> Drop for SuperBox<T> {\n    fn drop(&mut self) {\n        unsafe {\n            // Hyper-optimized: deallocate the box's contents for it\n            // without `drop`ing the contents\n            let c: NonNull<T> = self.my_box.ptr.into();\n            Global.deallocate(c.cast::<u8>(), Layout::new::<T>());\n        }\n    }\n}",
      "parent_id": null,
      "paragraphs": {
        "nomicon_fn_main_p1": "",
        "nomicon_fn_main_p2": "and this works fine because when Rust goes to drop the `ptr` field it just sees\na [Unique] that has no actual `Drop` implementation. Similarly nothing can\nuse-after-free the `ptr` because when drop exits, it becomes inaccessible.",
        "nomicon_fn_main_p3": "However this wouldn't work:",
        "nomicon_fn_main_p4": "#![feature(allocator_api, ptr_internals)]",
        "nomicon_fn_main_p5": "use std::alloc::{Allocator, Global, GlobalAlloc, Layout};\nuse std::ptr::{drop_in_place, Unique, NonNull};\nuse std::mem;",
        "nomicon_fn_main_p6": "struct Box<T>{ ptr: Unique<T> }",
        "nomicon_fn_main_p7": "impl<T> Drop for Box<T> {\n    fn drop(&mut self) {\n        unsafe {\n            drop_in_place(self.ptr.as_ptr());\n            let c: NonNull<T> = self.ptr.into();\n            Global.deallocate(c.cast(), Layout::new::<T>());\n        }\n    }\n}",
        "nomicon_fn_main_p8": "struct SuperBox<T> { my_box: Box<T> }",
        "nomicon_fn_main_p9": "impl<T> Drop for SuperBox<T> {\n    fn drop(&mut self) {\n        unsafe {\n            // Hyper-optimized: deallocate the box's contents for it\n            // without `drop`ing the contents\n            let c: NonNull<T> = self.my_box.ptr.into();\n            Global.deallocate(c.cast::<u8>(), Layout::new::<T>());\n        }\n    }\n}"
      }
    },
    {
      "id": "nomicon_fn_main",
      "title": "fn main() {}",
      "level": 1,
      "content": "After we deallocate the `box`'s ptr in SuperBox's destructor, Rust will\nhappily proceed to tell the box to Drop itself and everything will blow up with\nuse-after-frees and double-frees.\n\nNote that the recursive drop behavior applies to all structs and enums\nregardless of whether they implement Drop. Therefore something like\n\nstruct Boxy<T> {\n    data1: Box<T>,\n    data2: Box<T>,\n    info: u32,\n}\n\nwill have the destructors of its `data1` and `data2` fields called whenever it \"would\" be\ndropped, even though it itself doesn't implement Drop. We say that such a type\n*needs Drop*, even though it is not itself Drop.\n\nSimilarly,\n\nenum Link {\n    Next(Box<Link>),\n    None,\n}\n\nwill have its inner Box field dropped if and only if an instance stores the\nNext variant.\n\nIn general this works really nicely because you don't need to worry about\nadding/removing drops when you refactor your data layout. Still there's\ncertainly many valid use cases for needing to do trickier things with\ndestructors.\n\nThe classic safe solution to overriding recursive drop and allowing moving out\nof Self during `drop` is to use an Option:\n\n#![feature(allocator_api, ptr_internals)]\n\nuse std::alloc::{Allocator, GlobalAlloc, Global, Layout};\nuse std::ptr::{drop_in_place, Unique, NonNull};\nuse std::mem;\n\nstruct Box<T>{ ptr: Unique<T> }\n\nimpl<T> Drop for Box<T> {\n    fn drop(&mut self) {\n        unsafe {\n            drop_in_place(self.ptr.as_ptr());\n            let c: NonNull<T> = self.ptr.into();\n            Global.deallocate(c.cast(), Layout::new::<T>());\n        }\n    }\n}\n\nstruct SuperBox<T> { my_box: Option<Box<T>> }\n\nimpl<T> Drop for SuperBox<T> {\n    fn drop(&mut self) {\n        unsafe {\n            // Hyper-optimized: deallocate the box's contents for it\n            // without `drop`ing the contents. Need to set the `box`\n            // field as `None` to prevent Rust from trying to Drop it.\n            let my_box = self.my_box.take().unwrap();\n            let c: NonNull<T> = my_box.ptr.into();\n            Global.deallocate(c.cast(), Layout::new::<T>());\n            mem::forget(my_box);\n        }\n    }\n}",
      "parent_id": null,
      "paragraphs": {
        "nomicon_fn_main_p1": "",
        "nomicon_fn_main_p2": "After we deallocate the `box`'s ptr in SuperBox's destructor, Rust will\nhappily proceed to tell the box to Drop itself and everything will blow up with\nuse-after-frees and double-frees.",
        "nomicon_fn_main_p3": "Note that the recursive drop behavior applies to all structs and enums\nregardless of whether they implement Drop. Therefore something like",
        "nomicon_fn_main_p4": "struct Boxy<T> {\n    data1: Box<T>,\n    data2: Box<T>,\n    info: u32,\n}",
        "nomicon_fn_main_p5": "will have the destructors of its `data1` and `data2` fields called whenever it \"would\" be\ndropped, even though it itself doesn't implement Drop. We say that such a type\n*needs Drop*, even though it is not itself Drop.",
        "nomicon_fn_main_p6": "Similarly,",
        "nomicon_fn_main_p7": "enum Link {\n    Next(Box<Link>),\n    None,\n}",
        "nomicon_fn_main_p8": "will have its inner Box field dropped if and only if an instance stores the\nNext variant.",
        "nomicon_fn_main_p9": "In general this works really nicely because you don't need to worry about\nadding/removing drops when you refactor your data layout. Still there's\ncertainly many valid use cases for needing to do trickier things with\ndestructors.",
        "nomicon_fn_main_p10": "The classic safe solution to overriding recursive drop and allowing moving out\nof Self during `drop` is to use an Option:",
        "nomicon_fn_main_p11": "#![feature(allocator_api, ptr_internals)]",
        "nomicon_fn_main_p12": "use std::alloc::{Allocator, GlobalAlloc, Global, Layout};\nuse std::ptr::{drop_in_place, Unique, NonNull};\nuse std::mem;",
        "nomicon_fn_main_p13": "struct Box<T>{ ptr: Unique<T> }",
        "nomicon_fn_main_p14": "impl<T> Drop for Box<T> {\n    fn drop(&mut self) {\n        unsafe {\n            drop_in_place(self.ptr.as_ptr());\n            let c: NonNull<T> = self.ptr.into();\n            Global.deallocate(c.cast(), Layout::new::<T>());\n        }\n    }\n}",
        "nomicon_fn_main_p15": "struct SuperBox<T> { my_box: Option<Box<T>> }",
        "nomicon_fn_main_p16": "impl<T> Drop for SuperBox<T> {\n    fn drop(&mut self) {\n        unsafe {\n            // Hyper-optimized: deallocate the box's contents for it\n            // without `drop`ing the contents. Need to set the `box`\n            // field as `None` to prevent Rust from trying to Drop it.\n            let my_box = self.my_box.take().unwrap();\n            let c: NonNull<T> = my_box.ptr.into();\n            Global.deallocate(c.cast(), Layout::new::<T>());\n            mem::forget(my_box);\n        }\n    }\n}"
      }
    },
    {
      "id": "nomicon_fn_main",
      "title": "fn main() {}",
      "level": 1,
      "content": "However this has fairly odd semantics: you are saying that a field that *should*\nalways be Some *may* be None, just because of what happens in the destructor. Of\ncourse this conversely makes a lot of sense: you can call arbitrary methods on\nself during the destructor, and this should prevent you from ever doing so after\ndeinitializing the field. Not that it will prevent you from producing any other\narbitrarily invalid state in there.\n\nOn balance this is an ok choice. Certainly what you should reach for by default.\nHowever, in the future we expect there to be a first-class way to announce that\na field shouldn't be automatically dropped.\n\n[Unique]: phantom-data.html",
      "parent_id": null,
      "paragraphs": {
        "nomicon_fn_main_p1": "",
        "nomicon_fn_main_p2": "However this has fairly odd semantics: you are saying that a field that *should*\nalways be Some *may* be None, just because of what happens in the destructor. Of\ncourse this conversely makes a lot of sense: you can call arbitrary methods on\nself during the destructor, and this should prevent you from ever doing so after\ndeinitializing the field. Not that it will prevent you from producing any other\narbitrarily invalid state in there.",
        "nomicon_fn_main_p3": "On balance this is an ok choice. Certainly what you should reach for by default.\nHowever, in the future we expect there to be a first-class way to announce that\na field shouldn't be automatically dropped.",
        "nomicon_fn_main_p4": "[Unique]: phantom-data.html"
      }
    },
    {
      "id": "nomicon_leaking",
      "title": "Leaking",
      "level": 1,
      "content": "Ownership-based resource management is intended to simplify composition. You\nacquire resources when you create the object, and you release the resources when\nit gets destroyed. Since destruction is handled for you, it means you can't\nforget to release the resources, and it happens as soon as possible! Surely this\nis perfect and all of our problems are solved.\n\nEverything is terrible and we have new and exotic problems to try to solve.\n\nMany people like to believe that Rust eliminates resource leaks. In practice,\nthis is basically true. You would be surprised to see a Safe Rust program\nleak resources in an uncontrolled way.\n\nHowever from a theoretical perspective this is absolutely not the case, no\nmatter how you look at it. In the strictest sense, \"leaking\" is so abstract as\nto be unpreventable. It's quite trivial to initialize a collection at the start\nof a program, fill it with tons of objects with destructors, and then enter an\ninfinite event loop that never refers to it. The collection will sit around\nuselessly, holding on to its precious resources until the program terminates (at\nwhich point all those resources would have been reclaimed by the OS anyway).\n\nWe may consider a more restricted form of leak: failing to drop a value that is\nunreachable. Rust also doesn't prevent this. In fact Rust *has a function for\ndoing this*: `mem::forget`. This function consumes the value it is passed *and\nthen doesn't run its destructor*.\n\nIn the past `mem::forget` was marked as unsafe as a sort of lint against using\nit, since failing to call a destructor is generally not a well-behaved thing to\ndo (though useful for some special unsafe code). However this was generally\ndetermined to be an untenable stance to take: there are many ways to fail to\ncall a destructor in safe code. The most famous example is creating a cycle of\nreference-counted pointers using interior mutability.\n\nIt is reasonable for safe code to assume that destructor leaks do not happen, as\nany program that leaks destructors is probably wrong. However *unsafe* code\ncannot rely on destructors to be run in order to be safe. For most types this\ndoesn't matter: if you leak the destructor then the type is by definition\ninaccessible, so it doesn't matter, right? For instance, if you leak a `Box<u8>`\nthen you waste some memory but that's hardly going to violate memory-safety.\n\nHowever where we must be careful with destructor leaks are *proxy* types. These\nare types which manage access to a distinct object, but don't actually own it.\nProxy objects are quite rare. Proxy objects you'll need to care about are even\nrarer. However we'll focus on three interesting examples in the standard\nlibrary:\n\n* `vec::Drain`\n* `Rc`\n* `thread::scoped::JoinGuard`",
      "parent_id": null,
      "paragraphs": {
        "nomicon_leaking_p1": "Ownership-based resource management is intended to simplify composition. You\nacquire resources when you create the object, and you release the resources when\nit gets destroyed. Since destruction is handled for you, it means you can't\nforget to release the resources, and it happens as soon as possible! Surely this\nis perfect and all of our problems are solved.",
        "nomicon_leaking_p2": "Everything is terrible and we have new and exotic problems to try to solve.",
        "nomicon_leaking_p3": "Many people like to believe that Rust eliminates resource leaks. In practice,\nthis is basically true. You would be surprised to see a Safe Rust program\nleak resources in an uncontrolled way.",
        "nomicon_leaking_p4": "However from a theoretical perspective this is absolutely not the case, no\nmatter how you look at it. In the strictest sense, \"leaking\" is so abstract as\nto be unpreventable. It's quite trivial to initialize a collection at the start\nof a program, fill it with tons of objects with destructors, and then enter an\ninfinite event loop that never refers to it. The collection will sit around\nuselessly, holding on to its precious resources until the program terminates (at\nwhich point all those resources would have been reclaimed by the OS anyway).",
        "nomicon_leaking_p5": "We may consider a more restricted form of leak: failing to drop a value that is\nunreachable. Rust also doesn't prevent this. In fact Rust *has a function for\ndoing this*: `mem::forget`. This function consumes the value it is passed *and\nthen doesn't run its destructor*.",
        "nomicon_leaking_p6": "In the past `mem::forget` was marked as unsafe as a sort of lint against using\nit, since failing to call a destructor is generally not a well-behaved thing to\ndo (though useful for some special unsafe code). However this was generally\ndetermined to be an untenable stance to take: there are many ways to fail to\ncall a destructor in safe code. The most famous example is creating a cycle of\nreference-counted pointers using interior mutability.",
        "nomicon_leaking_p7": "It is reasonable for safe code to assume that destructor leaks do not happen, as\nany program that leaks destructors is probably wrong. However *unsafe* code\ncannot rely on destructors to be run in order to be safe. For most types this\ndoesn't matter: if you leak the destructor then the type is by definition\ninaccessible, so it doesn't matter, right? For instance, if you leak a `Box<u8>`\nthen you waste some memory but that's hardly going to violate memory-safety.",
        "nomicon_leaking_p8": "However where we must be careful with destructor leaks are *proxy* types. These\nare types which manage access to a distinct object, but don't actually own it.\nProxy objects are quite rare. Proxy objects you'll need to care about are even\nrarer. However we'll focus on three interesting examples in the standard\nlibrary:",
        "nomicon_leaking_p9": "* `vec::Drain`\n* `Rc`\n* `thread::scoped::JoinGuard`"
      }
    },
    {
      "id": "nomicon_drain",
      "title": "Drain",
      "level": 2,
      "content": "`drain` is a collections API that moves data out of the container without\nconsuming the container. This enables us to reuse the allocation of a `Vec`\nafter claiming ownership over all of its contents. It produces an iterator\n(Drain) that returns the contents of the Vec by-value.\n\nNow, consider Drain in the middle of iteration: some values have been moved out,\nand others haven't. This means that part of the Vec is now full of logically\nuninitialized data! We could backshift all the elements in the Vec every time we\nremove a value, but this would have pretty catastrophic performance\nconsequences.\n\nInstead, we would like Drain to fix the Vec's backing storage when it is\ndropped. It should run itself to completion, backshift any elements that weren't\nremoved (drain supports subranges), and then fix Vec's `len`. It's even\nunwinding-safe! Easy!\n\nNow consider the following:\n\n<!-- ignore: simplified code -->\n,ignore\nlet mut vec = vec![Box::new(0); 4];\n\n{\n    // start draining, vec can no longer be accessed\n    let mut drainer = vec.drain(..);\n\n    // pull out two elements and immediately drop them\n    drainer.next();\n    drainer.next();\n\n    // get rid of drainer, but don't call its destructor\n    mem::forget(drainer);\n}\n\n// Oops, vec[0] was dropped, we're reading a pointer into free'd memory!\nprintln!(\"{}\", vec[0]);\n\nThis is pretty clearly Not Good. Unfortunately, we're kind of stuck between a\nrock and a hard place: maintaining consistent state at every step has an\nenormous cost (and would negate any benefits of the API). Failing to maintain\nconsistent state gives us Undefined Behavior in safe code (making the API\nunsound).\n\nSo what can we do? Well, we can pick a trivially consistent state: set the Vec's\nlen to be 0 when we start the iteration, and fix it up if necessary in the\ndestructor. That way, if everything executes like normal we get the desired\nbehavior with minimal overhead. But if someone has the *audacity* to\nmem::forget us in the middle of the iteration, all that does is *leak even more*\n(and possibly leave the Vec in an unexpected but otherwise consistent state).\nSince we've accepted that mem::forget is safe, this is definitely safe. We call\nleaks causing more leaks a *leak amplification*.",
      "parent_id": null,
      "paragraphs": {
        "nomicon_drain_p1": "`drain` is a collections API that moves data out of the container without\nconsuming the container. This enables us to reuse the allocation of a `Vec`\nafter claiming ownership over all of its contents. It produces an iterator\n(Drain) that returns the contents of the Vec by-value.",
        "nomicon_drain_p2": "Now, consider Drain in the middle of iteration: some values have been moved out,\nand others haven't. This means that part of the Vec is now full of logically\nuninitialized data! We could backshift all the elements in the Vec every time we\nremove a value, but this would have pretty catastrophic performance\nconsequences.",
        "nomicon_drain_p3": "Instead, we would like Drain to fix the Vec's backing storage when it is\ndropped. It should run itself to completion, backshift any elements that weren't\nremoved (drain supports subranges), and then fix Vec's `len`. It's even\nunwinding-safe! Easy!",
        "nomicon_drain_p4": "Now consider the following:",
        "nomicon_drain_p5": "<!-- ignore: simplified code -->\n,ignore\nlet mut vec = vec![Box::new(0); 4];",
        "nomicon_drain_p6": "{\n    // start draining, vec can no longer be accessed\n    let mut drainer = vec.drain(..);",
        "nomicon_drain_p7": "// pull out two elements and immediately drop them\n    drainer.next();\n    drainer.next();",
        "nomicon_drain_p8": "// get rid of drainer, but don't call its destructor\n    mem::forget(drainer);\n}",
        "nomicon_drain_p9": "// Oops, vec[0] was dropped, we're reading a pointer into free'd memory!\nprintln!(\"{}\", vec[0]);",
        "nomicon_drain_p10": "This is pretty clearly Not Good. Unfortunately, we're kind of stuck between a\nrock and a hard place: maintaining consistent state at every step has an\nenormous cost (and would negate any benefits of the API). Failing to maintain\nconsistent state gives us Undefined Behavior in safe code (making the API\nunsound).",
        "nomicon_drain_p11": "So what can we do? Well, we can pick a trivially consistent state: set the Vec's\nlen to be 0 when we start the iteration, and fix it up if necessary in the\ndestructor. That way, if everything executes like normal we get the desired\nbehavior with minimal overhead. But if someone has the *audacity* to\nmem::forget us in the middle of the iteration, all that does is *leak even more*\n(and possibly leave the Vec in an unexpected but otherwise consistent state).\nSince we've accepted that mem::forget is safe, this is definitely safe. We call\nleaks causing more leaks a *leak amplification*."
      }
    },
    {
      "id": "nomicon_rc",
      "title": "Rc",
      "level": 2,
      "content": "Rc is an interesting case because at first glance it doesn't appear to be a\nproxy value at all. After all, it manages the data it points to, and dropping\nall the Rcs for a value will drop that value. Leaking an Rc doesn't seem like it\nwould be particularly dangerous. It will leave the refcount permanently\nincremented and prevent the data from being freed or dropped, but that seems\njust like Box, right?\n\nNope.\n\nLet's consider a simplified implementation of Rc:\n\n<!-- ignore: simplified code -->\n,ignore\nstruct Rc<T> {\n    ptr: *mut RcBox<T>,\n}\n\nstruct RcBox<T> {\n    data: T,\n    ref_count: usize,\n}\n\nimpl<T> Rc<T> {\n    fn new(data: T) -> Self {\n        unsafe {\n            // Wouldn't it be nice if heap::allocate worked like this?\n            let ptr = heap::allocate::<RcBox<T>>();\n            ptr::write(ptr, RcBox {\n                data,\n                ref_count: 1,\n            });\n            Rc { ptr }\n        }\n    }\n\n    fn clone(&self) -> Self {\n        unsafe {\n            (*self.ptr).ref_count += 1;\n        }\n        Rc { ptr: self.ptr }\n    }\n}\n\nimpl<T> Drop for Rc<T> {\n    fn drop(&mut self) {\n        unsafe {\n            (*self.ptr).ref_count -= 1;\n            if (*self.ptr).ref_count == 0 {\n                // drop the data and then free it\n                ptr::read(self.ptr);\n                heap::deallocate(self.ptr);\n            }\n        }\n    }\n}\n\nThis code contains an implicit and subtle assumption: `ref_count` can fit in a\n`usize`, because there can't be more than `usize::MAX` Rcs in memory. However\nthis itself assumes that the `ref_count` accurately reflects the number of Rcs\nin memory, which we know is false with `mem::forget`. Using `mem::forget` we can\noverflow the `ref_count`, and then get it down to 0 with outstanding Rcs. Then\nwe can happily use-after-free the inner data. Bad Bad Not Good.\n\nThis can be solved by just checking the `ref_count` and doing *something*. The\nstandard library's stance is to just abort, because your program has become\nhorribly degenerate. Also *oh my gosh* it's such a ridiculous corner case.",
      "parent_id": null,
      "paragraphs": {
        "nomicon_rc_p1": "Rc is an interesting case because at first glance it doesn't appear to be a\nproxy value at all. After all, it manages the data it points to, and dropping\nall the Rcs for a value will drop that value. Leaking an Rc doesn't seem like it\nwould be particularly dangerous. It will leave the refcount permanently\nincremented and prevent the data from being freed or dropped, but that seems\njust like Box, right?",
        "nomicon_rc_p2": "Nope.",
        "nomicon_rc_p3": "Let's consider a simplified implementation of Rc:",
        "nomicon_rc_p4": "<!-- ignore: simplified code -->\n,ignore\nstruct Rc<T> {\n    ptr: *mut RcBox<T>,\n}",
        "nomicon_rc_p5": "struct RcBox<T> {\n    data: T,\n    ref_count: usize,\n}",
        "nomicon_rc_p6": "impl<T> Rc<T> {\n    fn new(data: T) -> Self {\n        unsafe {\n            // Wouldn't it be nice if heap::allocate worked like this?\n            let ptr = heap::allocate::<RcBox<T>>();\n            ptr::write(ptr, RcBox {\n                data,\n                ref_count: 1,\n            });\n            Rc { ptr }\n        }\n    }",
        "nomicon_rc_p7": "fn clone(&self) -> Self {\n        unsafe {\n            (*self.ptr).ref_count += 1;\n        }\n        Rc { ptr: self.ptr }\n    }\n}",
        "nomicon_rc_p8": "impl<T> Drop for Rc<T> {\n    fn drop(&mut self) {\n        unsafe {\n            (*self.ptr).ref_count -= 1;\n            if (*self.ptr).ref_count == 0 {\n                // drop the data and then free it\n                ptr::read(self.ptr);\n                heap::deallocate(self.ptr);\n            }\n        }\n    }\n}",
        "nomicon_rc_p9": "This code contains an implicit and subtle assumption: `ref_count` can fit in a\n`usize`, because there can't be more than `usize::MAX` Rcs in memory. However\nthis itself assumes that the `ref_count` accurately reflects the number of Rcs\nin memory, which we know is false with `mem::forget`. Using `mem::forget` we can\noverflow the `ref_count`, and then get it down to 0 with outstanding Rcs. Then\nwe can happily use-after-free the inner data. Bad Bad Not Good.",
        "nomicon_rc_p10": "This can be solved by just checking the `ref_count` and doing *something*. The\nstandard library's stance is to just abort, because your program has become\nhorribly degenerate. Also *oh my gosh* it's such a ridiculous corner case."
      }
    },
    {
      "id": "nomicon_thread_scoped_joinguard",
      "title": "thread::scoped::JoinGuard",
      "level": 2,
      "content": "> Note: This API has already been removed from std, for more information\n> you may refer issue #24292.\n>\n> This section remains here because we think this example is still\n> important, regardless of whether it is part of std or not.\n\nThe thread::scoped API intended to allow threads to be spawned that reference\ndata on their parent's stack without any synchronization over that data by\nensuring the parent joins the thread before any of the shared data goes out\nof scope.\n\n<!-- ignore: simplified code -->\n,ignore\npub fn scoped<'a, F>(f: F) -> JoinGuard<'a>\n    where F: FnOnce() + Send + 'a\n\nHere `f` is some closure for the other thread to execute. Saying that\n`F: Send + 'a` is saying that it closes over data that lives for `'a`, and it\neither owns that data or the data was Sync (implying `&data` is Send).\n\nBecause JoinGuard has a lifetime, it keeps all the data it closes over\nborrowed in the parent thread. This means the JoinGuard can't outlive\nthe data that the other thread is working on. When the JoinGuard *does* get\ndropped it blocks the parent thread, ensuring the child terminates before any\nof the closed-over data goes out of scope in the parent.\n\nUsage looked like:\n\n<!-- ignore: simplified code -->\n,ignore\nlet mut data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n{\n    let mut guards = vec![];\n    for x in &mut data {\n        // Move the mutable reference into the closure, and execute\n        // it on a different thread. The closure has a lifetime bound\n        // by the lifetime of the mutable reference `x` we store in it.\n        // The guard that is returned is in turn assigned the lifetime\n        // of the closure, so it also mutably borrows `data` as `x` did.\n        // This means we cannot access `data` until the guard goes away.\n        let guard = thread::scoped(move || {\n            *x *= 2;\n        });\n        // store the thread's guard for later\n        guards.push(guard);\n    }\n    // All guards are dropped here, forcing the threads to join\n    // (this thread blocks here until the others terminate).\n    // Once the threads join, the borrow expires and the data becomes\n    // accessible again in this thread.\n}\n// data is definitely mutated here.\n\nIn principle, this totally works! Rust's ownership system perfectly ensures it!\n...except it relies on a destructor being called to be safe.\n\n<!-- ignore: simplified code -->\n,ignore\nlet mut data = Box::new(0);\n{\n    let guard = thread::scoped(|| {\n        // This is at best a data race. At worst, it's also a use-after-free.\n        *data += 1;\n    });\n    // Because the guard is forgotten, expiring the loan without blocking this\n    // thread.\n    mem::forget(guard);\n}\n// So the Box is dropped here while the scoped thread may or may not be trying\n// to access it.\n\nDang. Here the destructor running was pretty fundamental to the API, and it had\nto be scrapped in favor of a completely different design.",
      "parent_id": null,
      "paragraphs": {
        "nomicon_thread_scoped_joinguard_p1": "> Note: This API has already been removed from std, for more information\n> you may refer issue #24292.\n>\n> This section remains here because we think this example is still\n> important, regardless of whether it is part of std or not.",
        "nomicon_thread_scoped_joinguard_p2": "The thread::scoped API intended to allow threads to be spawned that reference\ndata on their parent's stack without any synchronization over that data by\nensuring the parent joins the thread before any of the shared data goes out\nof scope.",
        "nomicon_thread_scoped_joinguard_p3": "<!-- ignore: simplified code -->\n,ignore\npub fn scoped<'a, F>(f: F) -> JoinGuard<'a>\n    where F: FnOnce() + Send + 'a",
        "nomicon_thread_scoped_joinguard_p4": "Here `f` is some closure for the other thread to execute. Saying that\n`F: Send + 'a` is saying that it closes over data that lives for `'a`, and it\neither owns that data or the data was Sync (implying `&data` is Send).",
        "nomicon_thread_scoped_joinguard_p5": "Because JoinGuard has a lifetime, it keeps all the data it closes over\nborrowed in the parent thread. This means the JoinGuard can't outlive\nthe data that the other thread is working on. When the JoinGuard *does* get\ndropped it blocks the parent thread, ensuring the child terminates before any\nof the closed-over data goes out of scope in the parent.",
        "nomicon_thread_scoped_joinguard_p6": "Usage looked like:",
        "nomicon_thread_scoped_joinguard_p7": "<!-- ignore: simplified code -->\n,ignore\nlet mut data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n{\n    let mut guards = vec![];\n    for x in &mut data {\n        // Move the mutable reference into the closure, and execute\n        // it on a different thread. The closure has a lifetime bound\n        // by the lifetime of the mutable reference `x` we store in it.\n        // The guard that is returned is in turn assigned the lifetime\n        // of the closure, so it also mutably borrows `data` as `x` did.\n        // This means we cannot access `data` until the guard goes away.\n        let guard = thread::scoped(move || {\n            *x *= 2;\n        });\n        // store the thread's guard for later\n        guards.push(guard);\n    }\n    // All guards are dropped here, forcing the threads to join\n    // (this thread blocks here until the others terminate).\n    // Once the threads join, the borrow expires and the data becomes\n    // accessible again in this thread.\n}\n// data is definitely mutated here.",
        "nomicon_thread_scoped_joinguard_p8": "In principle, this totally works! Rust's ownership system perfectly ensures it!\n...except it relies on a destructor being called to be safe.",
        "nomicon_thread_scoped_joinguard_p9": "<!-- ignore: simplified code -->\n,ignore\nlet mut data = Box::new(0);\n{\n    let guard = thread::scoped(|| {\n        // This is at best a data race. At worst, it's also a use-after-free.\n        *data += 1;\n    });\n    // Because the guard is forgotten, expiring the loan without blocking this\n    // thread.\n    mem::forget(guard);\n}\n// So the Box is dropped here while the scoped thread may or may not be trying\n// to access it.",
        "nomicon_thread_scoped_joinguard_p10": "Dang. Here the destructor running was pretty fundamental to the API, and it had\nto be scrapped in favor of a completely different design."
      }
    }
  ],
  "ids": [
    "nomicon_rc_p5",
    "nomicon_fn_main_p4",
    "nomicon_constructors",
    "nomicon_destructors_p11",
    "nomicon_rc_p6",
    "nomicon_drain_p10",
    "nomicon_destructors_p4",
    "nomicon_thread_scoped_joinguard_p4",
    "nomicon_constructors_p1",
    "nomicon_destructors_p3",
    "nomicon_leaking_p8",
    "nomicon_fn_main_p12",
    "nomicon_leaking_p4",
    "nomicon_drain_p3",
    "nomicon_rc_p9",
    "nomicon_constructors_p8",
    "nomicon_fn_main",
    "nomicon_fn_main_p10",
    "nomicon_destructors_p6",
    "nomicon_thread_scoped_joinguard_p8",
    "nomicon_drain_p11",
    "nomicon_leaking_p9",
    "nomicon_rc_p8",
    "nomicon_rc_p1",
    "nomicon_fn_main_p15",
    "nomicon_destructors_p1",
    "nomicon_fn_main_p7",
    "nomicon_leaking",
    "nomicon_constructors_p2",
    "nomicon_fn_main_p6",
    "nomicon_leaking_p7",
    "nomicon_drain_p5",
    "nomicon_fn_main_p5",
    "nomicon_thread_scoped_joinguard_p1",
    "nomicon_thread_scoped_joinguard_p3",
    "nomicon_leaking_p2",
    "nomicon_destructors_p5",
    "nomicon_constructors_p3",
    "nomicon_rc_p4",
    "nomicon_destructors_p10",
    "nomicon_fn_main_p13",
    "nomicon_the_perils_of_ownership_based_resource_management_obrm",
    "nomicon_destructors_p8",
    "nomicon_fn_main_p2",
    "nomicon_leaking_p6",
    "nomicon_rc_p2",
    "nomicon_the_perils_of_ownership_based_resource_management_obrm_p1",
    "nomicon_thread_scoped_joinguard_p5",
    "nomicon_drain_p6",
    "nomicon_constructors_p7",
    "nomicon_leaking_p3",
    "nomicon_thread_scoped_joinguard_p10",
    "nomicon_destructors_p9",
    "nomicon_constructors_p12",
    "nomicon_thread_scoped_joinguard_p2",
    "nomicon_rc_p10",
    "nomicon_constructors_p6",
    "nomicon_constructors_p11",
    "nomicon_constructors_p5",
    "nomicon_leaking_p1",
    "nomicon_leaking_p5",
    "nomicon_thread_scoped_joinguard",
    "nomicon_thread_scoped_joinguard_p9",
    "nomicon_drain_p7",
    "nomicon_rc_p7",
    "nomicon_destructors_p2",
    "nomicon_constructors_p9",
    "nomicon_drain_p2",
    "nomicon_destructors",
    "nomicon_thread_scoped_joinguard_p6",
    "nomicon_fn_main_p16",
    "nomicon_fn_main_p8",
    "nomicon_rc_p3",
    "nomicon_thread_scoped_joinguard_p7",
    "nomicon_fn_main_p9",
    "nomicon_constructors_p4",
    "nomicon_fn_main_p14",
    "nomicon_fn_main_p3",
    "nomicon_destructors_p7",
    "nomicon_drain_p4",
    "nomicon_fn_main_p1",
    "nomicon_rc",
    "nomicon_drain_p8",
    "nomicon_the_perils_of_ownership_based_resource_management_obrm_p2",
    "nomicon_drain_p1",
    "nomicon_drain_p9",
    "nomicon_fn_main_p11",
    "nomicon_destructors_p12",
    "nomicon_drain",
    "nomicon_constructors_p10"
  ]
}
