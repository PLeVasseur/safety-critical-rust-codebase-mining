{
  "source": "Unsafe Code Guidelines",
  "source_repo": "https://github.com/rust-lang/unsafe-code-guidelines",
  "extraction_date": "2026-01-03",
  "chapter": 2,
  "title": "Glossary",
  "file": "./glossary.md",
  "sections": [
    {
      "id": "ucg_glossary",
      "title": "Glossary",
      "level": 2,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "ucg_abi_of_a_type",
      "title": "ABI (of a type)",
      "level": 3,
      "content": "The *function call ABI* or short *ABI* of a type defines how it is passed *by-value* across a function boundary.\nPossible ABIs include passing the value directly in zero or more registers, or passing it indirectly as a pointer to the actual data.\nThe space of all possible ABIs is huge and extremely target-dependent.\nRust therefore does generally not clearly define the ABI of any type, it only defines when two types are *ABI-compatible*,\nwhich means that it is legal to call a function declared with an argument or return type `T` using a declaration or function pointer with argument or return type `U`.\n\nNote that ABI compatibility is stricter than layout compatibility.\nFor instance `#[repr(C)] struct S(i32)` is (guaranteed to be) layout-compatible with `i32`, but it is *not* ABI-compatible.",
      "parent_id": null,
      "paragraphs": {
        "ucg_abi_of_a_type_p1": "",
        "ucg_abi_of_a_type_p2": "The *function call ABI* or short *ABI* of a type defines how it is passed *by-value* across a function boundary.\nPossible ABIs include passing the value directly in zero or more registers, or passing it indirectly as a pointer to the actual data.\nThe space of all possible ABIs is huge and extremely target-dependent.\nRust therefore does generally not clearly define the ABI of any type, it only defines when two types are *ABI-compatible*,\nwhich means that it is legal to call a function declared with an argument or return type `T` using a declaration or function pointer with argument or return type `U`.",
        "ucg_abi_of_a_type_p3": "Note that ABI compatibility is stricter than layout compatibility.\nFor instance `#[repr(C)] struct S(i32)` is (guaranteed to be) layout-compatible with `i32`, but it is *not* ABI-compatible."
      }
    },
    {
      "id": "ucg_abstract_byte",
      "title": "Abstract Byte",
      "level": 3,
      "content": "The *byte* is the smallest unit of storage in Rust.\nMemory allocations are thought of as storing a list of bytes, and at the lowest level each load returns a list of bytes and each store takes a list of bytes and puts it into memory.\n(The [representation relation] then defines how to convert between those lists of bytes and higher-level values such as mathematical integers or pointers.)\n\nHowever, a *byte* in the Rust Abstract Machine is more complicated than just an integer in `0..256` -- think of it as there being some extra \"shadow state\" that is relevant for the Abstract Machine execution (in particular, for whether this execution has UB), but that disappears when compiling the program to assembly.\nThat's why we call it *abstract byte*, to distinguish it from the physical machine byte in `0..256`.\n\nThe most obvious \"shadow state\" is tracking whether memory is initialized.\nSee this blog post for details, but the gist of it is that bytes in memory are more like `Option<u8>` where `None` indicates that this byte is uninitialized.\nOperations like `copy` work on that representation, so if you copy from some uninitialized memory into initialized memory, the target memory becomes \"de-initialized\".\nAnother piece of shadow state is pointer provenance: the Abstract Machine tracks the \"origin\" of each pointer value to enforce the rule that a pointer used to access some memory is \"based on\" the original pointer produced when that memory got allocated.\nThis provenance must be preserved when the pointer is stored to memory and loaded again later, which implies that abstract bytes must be able to carry provenance.\n\nWithout committing to the exact shape of provenance in Rust, we can therefore say that an (abstract) byte in the Rust Abstract Machine looks as follows:\n\npub enum AbstractByte<Provenance> {\n    /// An uninitialized byte.\n    Uninit,\n    /// An initialized byte with a value in `0..256`,\n    /// optionally with some provenance (if it is encoding a pointer).\n    Init(u8, Option<Provenance>),\n}",
      "parent_id": null,
      "paragraphs": {
        "ucg_abstract_byte_p1": "",
        "ucg_abstract_byte_p2": "The *byte* is the smallest unit of storage in Rust.\nMemory allocations are thought of as storing a list of bytes, and at the lowest level each load returns a list of bytes and each store takes a list of bytes and puts it into memory.\n(The [representation relation] then defines how to convert between those lists of bytes and higher-level values such as mathematical integers or pointers.)",
        "ucg_abstract_byte_p3": "However, a *byte* in the Rust Abstract Machine is more complicated than just an integer in `0..256` -- think of it as there being some extra \"shadow state\" that is relevant for the Abstract Machine execution (in particular, for whether this execution has UB), but that disappears when compiling the program to assembly.\nThat's why we call it *abstract byte*, to distinguish it from the physical machine byte in `0..256`.",
        "ucg_abstract_byte_p4": "The most obvious \"shadow state\" is tracking whether memory is initialized.\nSee this blog post for details, but the gist of it is that bytes in memory are more like `Option<u8>` where `None` indicates that this byte is uninitialized.\nOperations like `copy` work on that representation, so if you copy from some uninitialized memory into initialized memory, the target memory becomes \"de-initialized\".\nAnother piece of shadow state is pointer provenance: the Abstract Machine tracks the \"origin\" of each pointer value to enforce the rule that a pointer used to access some memory is \"based on\" the original pointer produced when that memory got allocated.\nThis provenance must be preserved when the pointer is stored to memory and loaded again later, which implies that abstract bytes must be able to carry provenance.",
        "ucg_abstract_byte_p5": "Without committing to the exact shape of provenance in Rust, we can therefore say that an (abstract) byte in the Rust Abstract Machine looks as follows:",
        "ucg_abstract_byte_p6": "pub enum AbstractByte<Provenance> {\n    /// An uninitialized byte.\n    Uninit,\n    /// An initialized byte with a value in `0..256`,\n    /// optionally with some provenance (if it is encoding a pointer).\n    Init(u8, Option<Provenance>),\n}"
      }
    },
    {
      "id": "ucg_aliasing",
      "title": "Aliasing",
      "level": 3,
      "content": "*Aliasing* occurs when one pointer or reference points to a \"span\" of memory\nthat overlaps with the span of another pointer or reference. A span of memory is\nsimilar to how a slice works: there's a base byte address as well as a length in\nbytes.\n\n**Note**: a full aliasing model for Rust, defining when aliasing is allowed\nand when not, has not yet been defined. The purpose of this definition is to\ndefine when aliasing *happens*, not when it is *allowed*. The most developed\npotential aliasing model so far is Stacked Borrows.\n\nConsider the following example:\n\nfn main() {\n    let u: u64 = 7_u64;\n    let r: &u64 = &u;\n    let s: &[u8] = unsafe {\n        core::slice::from_raw_parts(&u as *const u64 as *const u8, 8)\n    };\n    let (head, tail) = s.split_first().unwrap();\n}\n\nIn this case, both `r` and `s` alias each other, since they both point to all of\nthe bytes of `u`.\n\nHowever, `head` and `tail` do not alias each other: `head` points to the first\nbyte of `u` and `tail` points to the other seven bytes of `u` after it. Both `head`\nand `tail` alias `s`, any overlap is sufficient to count as an alias.\n\nThe span of a pointer or reference is the size of the value being pointed to or referenced.\nDepending on the type, you can determine the size as follows:\n\n* For a type `T` that is `Sized`\n  The span length of a pointer or reference to `T` is found with `size_of::<T>()`.\n* When `T` is not `Sized` the story is a little tricker:\n  * If you have a reference `r` you can use `size_of_val(r)` to determine the\n    span of the reference.\n  * If you have a pointer `p` you must unsafely convert that to a reference before\n    you can use `size_of_val`. There is not currently a safe way to determine the\n    span of a pointer to an unsized type.\n\nThe Data layout chapter also has more information on the sizes of different types.\n\nOne interesting side effect of these rules is that references and pointers to\nZero Sized Types _never_ alias each other, because their span length is always 0\nbytes.\n\nIt is also important to know that LLVM IR has a `noalias` attribute that works\nsomewhat differently from this definition. However, that's considered a low\nlevel detail of a particular Rust implementation. When programming Rust, the\nAbstract Rust Machine is intended to operate according to the definition here.",
      "parent_id": null,
      "paragraphs": {
        "ucg_aliasing_p1": "*Aliasing* occurs when one pointer or reference points to a \"span\" of memory\nthat overlaps with the span of another pointer or reference. A span of memory is\nsimilar to how a slice works: there's a base byte address as well as a length in\nbytes.",
        "ucg_aliasing_p2": "**Note**: a full aliasing model for Rust, defining when aliasing is allowed\nand when not, has not yet been defined. The purpose of this definition is to\ndefine when aliasing *happens*, not when it is *allowed*. The most developed\npotential aliasing model so far is Stacked Borrows.",
        "ucg_aliasing_p3": "Consider the following example:",
        "ucg_aliasing_p4": "fn main() {\n    let u: u64 = 7_u64;\n    let r: &u64 = &u;\n    let s: &[u8] = unsafe {\n        core::slice::from_raw_parts(&u as *const u64 as *const u8, 8)\n    };\n    let (head, tail) = s.split_first().unwrap();\n}",
        "ucg_aliasing_p5": "In this case, both `r` and `s` alias each other, since they both point to all of\nthe bytes of `u`.",
        "ucg_aliasing_p6": "However, `head` and `tail` do not alias each other: `head` points to the first\nbyte of `u` and `tail` points to the other seven bytes of `u` after it. Both `head`\nand `tail` alias `s`, any overlap is sufficient to count as an alias.",
        "ucg_aliasing_p7": "The span of a pointer or reference is the size of the value being pointed to or referenced.\nDepending on the type, you can determine the size as follows:",
        "ucg_aliasing_p8": "* For a type `T` that is `Sized`\n  The span length of a pointer or reference to `T` is found with `size_of::<T>()`.\n* When `T` is not `Sized` the story is a little tricker:\n  * If you have a reference `r` you can use `size_of_val(r)` to determine the\n    span of the reference.\n  * If you have a pointer `p` you must unsafely convert that to a reference before\n    you can use `size_of_val`. There is not currently a safe way to determine the\n    span of a pointer to an unsized type.",
        "ucg_aliasing_p9": "The Data layout chapter also has more information on the sizes of different types.",
        "ucg_aliasing_p10": "One interesting side effect of these rules is that references and pointers to\nZero Sized Types _never_ alias each other, because their span length is always 0\nbytes.",
        "ucg_aliasing_p11": "It is also important to know that LLVM IR has a `noalias` attribute that works\nsomewhat differently from this definition. However, that's considered a low\nlevel detail of a particular Rust implementation. When programming Rust, the\nAbstract Rust Machine is intended to operate according to the definition here."
      }
    },
    {
      "id": "ucg_allocation",
      "title": "Allocation",
      "level": 3,
      "content": "An *allocation* is a chunk of memory that is addressable from Rust.\nAllocations are created for objects on the heap, for stack-allocated variables, for globals (statics and consts), but also for objects that do not have Rust-inspectable data such as functions and vtables.\nAn allocation has a contiguous range of memory addresses that it covers, and it can generally only be deallocated all at once.\n(Though in the future, we might allow allocations with holes, and we might allow growing/shrinking an allocation.)\nThis range can be empty, but even empty allocations have a *base address* that they are located at.\nThe base address of an allocation is not necessarily unique; but if two distinct allocations have the same base address then at least one of them must be empty.\n\nPointer arithmetic is generally only possible within an allocation:\nprovenance ensures that each pointer \"remembers\" which allocation it points to,\nand accesses are only permitted if the address is in range of the allocation associated with the pointer.\n\nData inside an allocation is stored as abstract bytes;\nin particular, allocations do not track which type the data inside them has.",
      "parent_id": null,
      "paragraphs": {
        "ucg_allocation_p1": "",
        "ucg_allocation_p2": "An *allocation* is a chunk of memory that is addressable from Rust.\nAllocations are created for objects on the heap, for stack-allocated variables, for globals (statics and consts), but also for objects that do not have Rust-inspectable data such as functions and vtables.\nAn allocation has a contiguous range of memory addresses that it covers, and it can generally only be deallocated all at once.\n(Though in the future, we might allow allocations with holes, and we might allow growing/shrinking an allocation.)\nThis range can be empty, but even empty allocations have a *base address* that they are located at.\nThe base address of an allocation is not necessarily unique; but if two distinct allocations have the same base address then at least one of them must be empty.",
        "ucg_allocation_p3": "Pointer arithmetic is generally only possible within an allocation:\nprovenance ensures that each pointer \"remembers\" which allocation it points to,\nand accesses are only permitted if the address is in range of the allocation associated with the pointer.",
        "ucg_allocation_p4": "Data inside an allocation is stored as abstract bytes;\nin particular, allocations do not track which type the data inside them has."
      }
    },
    {
      "id": "ucg_interior_mutability",
      "title": "Interior mutability",
      "level": 3,
      "content": "*Interior Mutation* means mutating memory where there also exists a live shared reference pointing to the same memory; or mutating memory through a pointer derived from a shared reference.\n\"live\" here means a value that will be \"used again\" later.\n\"derived from\" means that the pointer was obtained by casting a shared reference and potentially adding an offset.\nThis is not yet precisely defined, which will be fixed as part of developing a precise aliasing model.\n\nFinding live shared references propagates recursively through references, but not through raw pointers.\nSo, for example, if data immediately pointed to by a `&T` or `& &mut T` is mutated, that's interior mutability.\nIf data immediately pointed to by a `*const T` or `&*const T` is mutated, that's *not* interior mutability.\n\n*Interior mutability* refers to the ability to perform interior mutation without causing UB.\nAll interior mutation in Rust has to happen inside an `UnsafeCell`, so all data structures that have interior mutability must (directly or indirectly) use `UnsafeCell` for this purpose.",
      "parent_id": null,
      "paragraphs": {
        "ucg_interior_mutability_p1": "*Interior Mutation* means mutating memory where there also exists a live shared reference pointing to the same memory; or mutating memory through a pointer derived from a shared reference.\n\"live\" here means a value that will be \"used again\" later.\n\"derived from\" means that the pointer was obtained by casting a shared reference and potentially adding an offset.\nThis is not yet precisely defined, which will be fixed as part of developing a precise aliasing model.",
        "ucg_interior_mutability_p2": "Finding live shared references propagates recursively through references, but not through raw pointers.\nSo, for example, if data immediately pointed to by a `&T` or `& &mut T` is mutated, that's interior mutability.\nIf data immediately pointed to by a `*const T` or `&*const T` is mutated, that's *not* interior mutability.",
        "ucg_interior_mutability_p3": "*Interior mutability* refers to the ability to perform interior mutation without causing UB.\nAll interior mutation in Rust has to happen inside an `UnsafeCell`, so all data structures that have interior mutability must (directly or indirectly) use `UnsafeCell` for this purpose."
      }
    },
    {
      "id": "ucg_layout",
      "title": "Layout",
      "level": 3,
      "content": "The *layout* of a type defines its size and alignment as well as the offsets of its subobjects (e.g. fields of structs/unions/enums/... or elements of arrays, and the discriminant of enums).\n\nNote that layout does not capture everything that there is to say about how a type is represented on the machine; it notably does not include ABI or Niches.\n\nNote: Originally, *layout* and *representation* were treated as synonyms, and Rust language features like the `#[repr]` attribute reflect this. \nIn this document, *layout* and *representation* are not synonyms.",
      "parent_id": null,
      "paragraphs": {
        "ucg_layout_p1": "",
        "ucg_layout_p2": "The *layout* of a type defines its size and alignment as well as the offsets of its subobjects (e.g. fields of structs/unions/enums/... or elements of arrays, and the discriminant of enums).",
        "ucg_layout_p3": "Note that layout does not capture everything that there is to say about how a type is represented on the machine; it notably does not include ABI or Niches.",
        "ucg_layout_p4": "Note: Originally, *layout* and *representation* were treated as synonyms, and Rust language features like the `#[repr]` attribute reflect this. \nIn this document, *layout* and *representation* are not synonyms."
      }
    },
    {
      "id": "ucg_memory_address",
      "title": "Memory Address",
      "level": 3,
      "content": "A *memory address* is an integer value that identifies where in the process' memory some data is stored.\nThis will typically be a virtual address, if the Rust process runs as a regular user-space program.\nIt can also be a physical address for bare-level / kernel code. Rust doesn't really care either way, the point is:\nit's an address as understood by the CPU, it's what the load/store instructions need to identify where in memory to perform the load/store.\n\nNote that a pointer in Rust is *not* just a memory address.\nA pointer value consists of a memory address and provenance.",
      "parent_id": null,
      "paragraphs": {
        "ucg_memory_address_p1": "",
        "ucg_memory_address_p2": "A *memory address* is an integer value that identifies where in the process' memory some data is stored.\nThis will typically be a virtual address, if the Rust process runs as a regular user-space program.\nIt can also be a physical address for bare-level / kernel code. Rust doesn't really care either way, the point is:\nit's an address as understood by the CPU, it's what the load/store instructions need to identify where in memory to perform the load/store.",
        "ucg_memory_address_p3": "Note that a pointer in Rust is *not* just a memory address.\nA pointer value consists of a memory address and provenance."
      }
    },
    {
      "id": "ucg_niche",
      "title": "Niche",
      "level": 3,
      "content": "The *niche* of a type determines invalid bit-patterns that will be used by layout optimizations.\n\nFor example, `&mut T` has at least one niche, the \"all zeros\" bit-pattern. This\nniche is used by layout optimizations like \"`enum` discriminant\nelision\" to\nguarantee that `Option<&mut T>` has the same size as `&mut T`.\n\nWhile all niches are invalid bit-patterns, not all invalid bit-patterns are\nniches. For example, the \"all bits uninitialized\" is an invalid bit-pattern for\n`&mut T`, but this bit-pattern cannot be used by layout optimizations, and is not a\nniche.",
      "parent_id": null,
      "paragraphs": {
        "ucg_niche_p1": "",
        "ucg_niche_p2": "The *niche* of a type determines invalid bit-patterns that will be used by layout optimizations.",
        "ucg_niche_p3": "For example, `&mut T` has at least one niche, the \"all zeros\" bit-pattern. This\nniche is used by layout optimizations like \"`enum` discriminant\nelision\" to\nguarantee that `Option<&mut T>` has the same size as `&mut T`.",
        "ucg_niche_p4": "While all niches are invalid bit-patterns, not all invalid bit-patterns are\nniches. For example, the \"all bits uninitialized\" is an invalid bit-pattern for\n`&mut T`, but this bit-pattern cannot be used by layout optimizations, and is not a\nniche."
      }
    },
    {
      "id": "ucg_padding",
      "title": "Padding",
      "level": 3,
      "content": "*Padding* (of a type `T`) refers to the space that the compiler leaves between fields of a struct or enum variant to satisfy alignment requirements, and before/after variants of a union or enum to make all variants equally sized.\n\nPadding can be thought of as the type containing secret fields of type `[Pad; N]` for some hypothetical type `Pad` (of size 1) with the following properties:\n* `Pad` is valid for any byte, i.e., it has the same validity invariant as `MaybeUninit<u8>`.\n* Copying `Pad` ignores the source byte, and writes *any* value to the target byte. Or, equivalently (in terms of Abstract Machine behavior), copying `Pad` marks the target byte as uninitialized.\n\nNote that padding is a property of the *type* and not the memory: reading from the padding of an `&Foo` (by casting to a byte reference) may produce initialized values if the `&Foo` is pointing to memory that was initialized (for example, if it was originally a byte buffer initialized to `0`), but the moment you perform a typed copy out of that reference you will have uninitialized padding bytes in the copy.\n\nWe can also define padding in terms of the [representation relation]:\nA byte at index `i` is a padding byte for type `T` if,\nfor all values `v` and lists of bytes `b` such that `v` and `b` are related at `T` (let's write this `Vrel_T(v, b)`),\nchanging `b` at index `i` to any other byte yields a `b'` such `v` and `b'` are related (`Vrel_T(v, b')`).\nIn other words, the byte at index `i` is entirely ignored by `Vrel_T` (the value relation for `T`), and two lists of bytes that only differ in padding bytes relate to the same value(s), if any.\n\nThis definition works fine for product types (structs, tuples, arrays, ...).\nThe desired notion of \"padding byte\" for enums and unions is still unclear.",
      "parent_id": null,
      "paragraphs": {
        "ucg_padding_p1": "",
        "ucg_padding_p2": "*Padding* (of a type `T`) refers to the space that the compiler leaves between fields of a struct or enum variant to satisfy alignment requirements, and before/after variants of a union or enum to make all variants equally sized.",
        "ucg_padding_p3": "Padding can be thought of as the type containing secret fields of type `[Pad; N]` for some hypothetical type `Pad` (of size 1) with the following properties:\n* `Pad` is valid for any byte, i.e., it has the same validity invariant as `MaybeUninit<u8>`.\n* Copying `Pad` ignores the source byte, and writes *any* value to the target byte. Or, equivalently (in terms of Abstract Machine behavior), copying `Pad` marks the target byte as uninitialized.",
        "ucg_padding_p4": "Note that padding is a property of the *type* and not the memory: reading from the padding of an `&Foo` (by casting to a byte reference) may produce initialized values if the `&Foo` is pointing to memory that was initialized (for example, if it was originally a byte buffer initialized to `0`), but the moment you perform a typed copy out of that reference you will have uninitialized padding bytes in the copy.",
        "ucg_padding_p5": "We can also define padding in terms of the [representation relation]:\nA byte at index `i` is a padding byte for type `T` if,\nfor all values `v` and lists of bytes `b` such that `v` and `b` are related at `T` (let's write this `Vrel_T(v, b)`),\nchanging `b` at index `i` to any other byte yields a `b'` such `v` and `b'` are related (`Vrel_T(v, b')`).\nIn other words, the byte at index `i` is entirely ignored by `Vrel_T` (the value relation for `T`), and two lists of bytes that only differ in padding bytes relate to the same value(s), if any.",
        "ucg_padding_p6": "This definition works fine for product types (structs, tuples, arrays, ...).\nThe desired notion of \"padding byte\" for enums and unions is still unclear."
      }
    },
    {
      "id": "ucg_place",
      "title": "Place",
      "level": 3,
      "content": "A *place* (called \"lvalue\" in C and \"glvalue\" in C++) is the result of computing a *place expression*.\nA place is basically a pointer (pointing to some location in memory, potentially carrying [provenance]), but might contain more information such as size or alignment (the details will have to be determined as the Rust Abstract Machine gets specified more precisely).\nA place has a type, indicating the type of values that it stores.\n\nThe key operations on a place are:\n* Storing a [value] of the same type in it (when it is used on the left-hand side of an assignment).\n* Loading a [value] of the same type from it (through the place-to-value coercion).\n* Converting between a place (of type `T`) and a pointer value (of type `&T`, `&mut T`, `*const T` or `*mut T`) using the `&` and `*` operators.\n  This is also the only way a place can be \"stored\": by converting it to a value first.",
      "parent_id": null,
      "paragraphs": {
        "ucg_place_p1": "",
        "ucg_place_p2": "A *place* (called \"lvalue\" in C and \"glvalue\" in C++) is the result of computing a *place expression*.\nA place is basically a pointer (pointing to some location in memory, potentially carrying [provenance]), but might contain more information such as size or alignment (the details will have to be determined as the Rust Abstract Machine gets specified more precisely).\nA place has a type, indicating the type of values that it stores.",
        "ucg_place_p3": "The key operations on a place are:\n* Storing a [value] of the same type in it (when it is used on the left-hand side of an assignment).\n* Loading a [value] of the same type from it (through the place-to-value coercion).\n* Converting between a place (of type `T`) and a pointer value (of type `&T`, `&mut T`, `*const T` or `*mut T`) using the `&` and `*` operators.\n  This is also the only way a place can be \"stored\": by converting it to a value first."
      }
    },
    {
      "id": "ucg_pointer_provenance",
      "title": "Pointer Provenance",
      "level": 3,
      "content": "The *provenance* of a pointer is used to distinguish pointers that point to the same [memory address] (i.e., pointers that, when cast to `usize`, will compare equal).\nProvenance is extra state that only exists in the Rust Abstract Machine; it is needed to specify program behavior but not present any more when the program runs on real hardware.\nIn other words, pointers that only differ in their provenance can *not* be distinguished any more in the final binary (but provenance can influence how the compiler translates the program).\n\nThe exact form of provenance in Rust is unclear.\nIt is also unclear whether provenance applies to more than just pointers, i.e., one could imagine integers having provenance as well (so that pointer provenance can be preserved when pointers are cast to an integer and back).\nIn the following, we give some examples if what provenance *could* look like.\n\n*Using provenance to track originating allocation.*\nFor example, we have to distinguish pointers to the same location if they originated from different allocations.\nCross-allocation pointer arithmetic does not lead to usable pointers, so the Rust Abstract Machine *somehow* has to remember the original allocation to which a pointer pointed.\nIt could use provenance to achieve this:\n\n// Let's assume the two allocations here have base addresses 0x100 and 0x200.\n// We write pointer provenance as `@N` where `N` is some kind of ID uniquely\n// identifying the allocation.\nlet raw1 = Box::into_raw(Box::new(13u8));\nlet raw2 = Box::into_raw(Box::new(42u8));\nlet raw2_wrong = raw1.wrapping_add(raw2.wrapping_sub(raw1 as usize) as usize);\n// These pointers now have the following values:\n// raw1 points to address 0x100 and has provenance @1.\n// raw2 points to address 0x200 and has provenance @2.\n// raw2_wrong points to address 0x200 and has provenance @1.\n// In other words, raw2 and raw2_wrong have same *address*...\nassert_eq!(raw2 as usize, raw2_wrong as usize);\n// ...but it would be UB to dereference raw2_wrong, as it has the wrong *provenance*:\n// it points to address 0x200, which is in allocation @2, but the pointer\n// has provenance @1.\n\nThis kind of provenance also exists in C/C++, but Rust is more permissive by (a) providing a way to do pointer arithmetic across allocation boundaries without causing immediate UB (though, as we have seen, the resulting pointer still cannot be used for locations outside the allocation it originates), and (b) by allowing pointers to always be compared safely, even if their provenance differs.\nFor some more information, see this document proposing a more precise definition of provenance for C.\n\n*Using provenance for Rust's aliasing rules.*\nAnother example of pointer provenance is the \"tag\" from Stacked Borrows.\nFor some more information, see this blog post.",
      "parent_id": null,
      "paragraphs": {
        "ucg_pointer_provenance_p1": "",
        "ucg_pointer_provenance_p2": "The *provenance* of a pointer is used to distinguish pointers that point to the same [memory address] (i.e., pointers that, when cast to `usize`, will compare equal).\nProvenance is extra state that only exists in the Rust Abstract Machine; it is needed to specify program behavior but not present any more when the program runs on real hardware.\nIn other words, pointers that only differ in their provenance can *not* be distinguished any more in the final binary (but provenance can influence how the compiler translates the program).",
        "ucg_pointer_provenance_p3": "The exact form of provenance in Rust is unclear.\nIt is also unclear whether provenance applies to more than just pointers, i.e., one could imagine integers having provenance as well (so that pointer provenance can be preserved when pointers are cast to an integer and back).\nIn the following, we give some examples if what provenance *could* look like.",
        "ucg_pointer_provenance_p4": "*Using provenance to track originating allocation.*\nFor example, we have to distinguish pointers to the same location if they originated from different allocations.\nCross-allocation pointer arithmetic does not lead to usable pointers, so the Rust Abstract Machine *somehow* has to remember the original allocation to which a pointer pointed.\nIt could use provenance to achieve this:",
        "ucg_pointer_provenance_p5": "// Let's assume the two allocations here have base addresses 0x100 and 0x200.\n// We write pointer provenance as `@N` where `N` is some kind of ID uniquely\n// identifying the allocation.\nlet raw1 = Box::into_raw(Box::new(13u8));\nlet raw2 = Box::into_raw(Box::new(42u8));\nlet raw2_wrong = raw1.wrapping_add(raw2.wrapping_sub(raw1 as usize) as usize);\n// These pointers now have the following values:\n// raw1 points to address 0x100 and has provenance @1.\n// raw2 points to address 0x200 and has provenance @2.\n// raw2_wrong points to address 0x200 and has provenance @1.\n// In other words, raw2 and raw2_wrong have same *address*...\nassert_eq!(raw2 as usize, raw2_wrong as usize);\n// ...but it would be UB to dereference raw2_wrong, as it has the wrong *provenance*:\n// it points to address 0x200, which is in allocation @2, but the pointer\n// has provenance @1.",
        "ucg_pointer_provenance_p6": "This kind of provenance also exists in C/C++, but Rust is more permissive by (a) providing a way to do pointer arithmetic across allocation boundaries without causing immediate UB (though, as we have seen, the resulting pointer still cannot be used for locations outside the allocation it originates), and (b) by allowing pointers to always be compared safely, even if their provenance differs.\nFor some more information, see this document proposing a more precise definition of provenance for C.",
        "ucg_pointer_provenance_p7": "*Using provenance for Rust's aliasing rules.*\nAnother example of pointer provenance is the \"tag\" from Stacked Borrows.\nFor some more information, see this blog post."
      }
    },
    {
      "id": "ucg_representation_relation",
      "title": "Representation (relation)",
      "level": 3,
      "content": "A *representation* of a [value] is a list of (abstract) bytes that is used to store or \"represent\" that value in memory.\n\nWe also sometimes speak of the *representation of a type*; this should more correctly be called the *representation relation* as it relates values of this type to lists of bytes that represent this value.\nThe term \"relation\" here is used in the mathematical sense: the representation relation is a predicate that, given a value and a list of bytes, says whether this value is represented by that list of bytes (`val -> list byte -> Prop`).\n\nThe relation should be functional for a fixed list of bytes (i.e., every list of bytes has at most one associated representation).\nIt is partial in both directions: not all values have a representation (e.g. the mathematical integer `300` has no representation at type `u8`), and not all lists of bytes correspond to a value of a specific type (e.g. lists of the wrong size correspond to no value, and the list consisting of the single byte `0x10` corresponds to no value of type `bool`).\nFor a fixed value, there can be many representations (e.g., when considering type `#[repr(C)] Pair(u8, u16)`, the second byte is a padding byte so changing it does not affect the value represented by a list of bytes).\n\nSee the value domain for an example how values and representation relations can be made more precise.",
      "parent_id": null,
      "paragraphs": {
        "ucg_representation_relation_p1": "",
        "ucg_representation_relation_p2": "A *representation* of a [value] is a list of (abstract) bytes that is used to store or \"represent\" that value in memory.",
        "ucg_representation_relation_p3": "We also sometimes speak of the *representation of a type*; this should more correctly be called the *representation relation* as it relates values of this type to lists of bytes that represent this value.\nThe term \"relation\" here is used in the mathematical sense: the representation relation is a predicate that, given a value and a list of bytes, says whether this value is represented by that list of bytes (`val -> list byte -> Prop`).",
        "ucg_representation_relation_p4": "The relation should be functional for a fixed list of bytes (i.e., every list of bytes has at most one associated representation).\nIt is partial in both directions: not all values have a representation (e.g. the mathematical integer `300` has no representation at type `u8`), and not all lists of bytes correspond to a value of a specific type (e.g. lists of the wrong size correspond to no value, and the list consisting of the single byte `0x10` corresponds to no value of type `bool`).\nFor a fixed value, there can be many representations (e.g., when considering type `#[repr(C)] Pair(u8, u16)`, the second byte is a padding byte so changing it does not affect the value represented by a list of bytes).",
        "ucg_representation_relation_p5": "See the value domain for an example how values and representation relations can be made more precise."
      }
    },
    {
      "id": "ucg_soundness_of_code_of_a_library",
      "title": "Soundness (of code / of a library)",
      "level": 3,
      "content": "*Soundness* is a type system concept (actually originating from the study of logics) and means that the type system is \"correct\" in the sense that well-typed programs actually have the desired properties.\nFor Rust, this means well-typed programs cannot cause Undefined Behavior.\nThis promise only extends to safe code however; for `unsafe` code, it is up to the programmer to uphold this contract.\n\nAccordingly, we say that a library (or an individual function) is *sound* if it is impossible for safe code to cause Undefined Behavior using its public API.\nConversely, the library/function is *unsound* if safe code *can* cause Undefined Behavior.",
      "parent_id": null,
      "paragraphs": {
        "ucg_soundness_of_code_of_a_library_p1": "",
        "ucg_soundness_of_code_of_a_library_p2": "*Soundness* is a type system concept (actually originating from the study of logics) and means that the type system is \"correct\" in the sense that well-typed programs actually have the desired properties.\nFor Rust, this means well-typed programs cannot cause Undefined Behavior.\nThis promise only extends to safe code however; for `unsafe` code, it is up to the programmer to uphold this contract.",
        "ucg_soundness_of_code_of_a_library_p3": "Accordingly, we say that a library (or an individual function) is *sound* if it is impossible for safe code to cause Undefined Behavior using its public API.\nConversely, the library/function is *unsound* if safe code *can* cause Undefined Behavior."
      }
    },
    {
      "id": "ucg_undefined_behavior",
      "title": "Undefined Behavior",
      "level": 3,
      "content": "*Undefined Behavior* is a concept of the contract between the Rust programmer and the compiler:\nThe programmer promises that the code exhibits no undefined behavior.\nIn return, the compiler promises to compile the code in a way that the final program does on the real hardware what the source program does according to the Rust Abstract Machine.\nIf it turns out the program *does* have undefined behavior, the contract is void, and the program produced by the compiler is essentially garbage (in particular, it is not bound by any specification; the program does not even have to be well-formed executable code).\n\nIn Rust, the Nomicon and the Reference both have a list of behavior that the language considers undefined.\nRust promises that safe code cannot cause Undefined Behavior---the compiler and authors of unsafe code takes the burden of this contract on themselves.\nFor unsafe code, however, the burden is still on the programmer.\n\nAlso see: Soundness.",
      "parent_id": null,
      "paragraphs": {
        "ucg_undefined_behavior_p1": "",
        "ucg_undefined_behavior_p2": "*Undefined Behavior* is a concept of the contract between the Rust programmer and the compiler:\nThe programmer promises that the code exhibits no undefined behavior.\nIn return, the compiler promises to compile the code in a way that the final program does on the real hardware what the source program does according to the Rust Abstract Machine.\nIf it turns out the program *does* have undefined behavior, the contract is void, and the program produced by the compiler is essentially garbage (in particular, it is not bound by any specification; the program does not even have to be well-formed executable code).",
        "ucg_undefined_behavior_p3": "In Rust, the Nomicon and the Reference both have a list of behavior that the language considers undefined.\nRust promises that safe code cannot cause Undefined Behavior---the compiler and authors of unsafe code takes the burden of this contract on themselves.\nFor unsafe code, however, the burden is still on the programmer.",
        "ucg_undefined_behavior_p4": "Also see: Soundness."
      }
    },
    {
      "id": "ucg_validity_and_safety_invariant",
      "title": "Validity and safety invariant",
      "level": 3,
      "content": "The *validity invariant* is an invariant that all data must uphold any time it is accessed or copied in a typed manner.\nThis invariant is known to the compiler and exploited by optimizations such as improved enum layout or eliding in-bounds checks.\n\nIn terms of MIR statements, \"accessed or copied\" means whenever an assignment statement is executed.\nThat statement has a type (LHS and RHS must have the same type), and the data being assigned must be valid at that type.\nMoreover, arguments passed to a function must be valid at the type given in the callee signature, and the return value of a function must be valid at the type given in the caller signature.\nOPEN QUESTION: Are there more cases where data must be valid?\n\nIn terms of code, some data computed by `TERM` is valid at type `T` if and only if the following program does not have UB:\n,ignore\nfn main() { unsafe {\n  let t: T = std::mem::transmute(TERM);\n} }\n\nThe *safety* invariant is an invariant that safe code may assume all data to uphold.\nThis invariant is used to justify which operations safe code can perform.\nThe safety invariant can be temporarily violated by unsafe code, but must always be upheld when interfacing with unknown safe code.\nIt is not relevant when arguing whether some *program* has UB, but it is relevant when arguing whether some code safely encapsulates its unsafety -- in other words, it is relevant when arguing whether some *library* is sound.\n\nIn terms of code, some data computed by `TERM` (possibly constructed from some `arguments` that can be *assumed* to satisfy the safety invariant) is valid at type `T` if and only if the following library function can be safely exposed to arbitrary (safe) code as part of the public library interface:\n,ignore\npub fn make_something(arguments: U) -> T { unsafe {\n  std::mem::transmute(TERM)\n} }\n\nOne example of valid-but-unsafe data is a `&str` or `String` that's not well-formed UTF-8: the compiler will not run its own optimizations that would cause any trouble here, so unsafe code may temporarily violate the invariant that strings are `UTF-8`.\nHowever, functions on `&str`/`String` may assume the string to be `UTF-8`, meaning they may cause UB if the string is *not* `UTF-8`.\nThis means that unsafe code violating the UTF-8 invariant must not perform string operations (it may operate on the data as a byte slice though), or else it risks UB.\nMoreover, such unsafe code must not return a non-UTF-8 string to the \"outside\" of its safe abstraction boundary, because that would mean safe code could cause UB by doing `bad_function().chars().count()`.\n\nTo summarize: *Data must always be valid, but it only must be safe in safe code.*\nFor some more information, see this blog post.",
      "parent_id": null,
      "paragraphs": {
        "ucg_validity_and_safety_invariant_p1": "The *validity invariant* is an invariant that all data must uphold any time it is accessed or copied in a typed manner.\nThis invariant is known to the compiler and exploited by optimizations such as improved enum layout or eliding in-bounds checks.",
        "ucg_validity_and_safety_invariant_p2": "In terms of MIR statements, \"accessed or copied\" means whenever an assignment statement is executed.\nThat statement has a type (LHS and RHS must have the same type), and the data being assigned must be valid at that type.\nMoreover, arguments passed to a function must be valid at the type given in the callee signature, and the return value of a function must be valid at the type given in the caller signature.\nOPEN QUESTION: Are there more cases where data must be valid?",
        "ucg_validity_and_safety_invariant_p3": "In terms of code, some data computed by `TERM` is valid at type `T` if and only if the following program does not have UB:\n,ignore\nfn main() { unsafe {\n  let t: T = std::mem::transmute(TERM);\n} }",
        "ucg_validity_and_safety_invariant_p4": "The *safety* invariant is an invariant that safe code may assume all data to uphold.\nThis invariant is used to justify which operations safe code can perform.\nThe safety invariant can be temporarily violated by unsafe code, but must always be upheld when interfacing with unknown safe code.\nIt is not relevant when arguing whether some *program* has UB, but it is relevant when arguing whether some code safely encapsulates its unsafety -- in other words, it is relevant when arguing whether some *library* is sound.",
        "ucg_validity_and_safety_invariant_p5": "In terms of code, some data computed by `TERM` (possibly constructed from some `arguments` that can be *assumed* to satisfy the safety invariant) is valid at type `T` if and only if the following library function can be safely exposed to arbitrary (safe) code as part of the public library interface:\n,ignore\npub fn make_something(arguments: U) -> T { unsafe {\n  std::mem::transmute(TERM)\n} }",
        "ucg_validity_and_safety_invariant_p6": "One example of valid-but-unsafe data is a `&str` or `String` that's not well-formed UTF-8: the compiler will not run its own optimizations that would cause any trouble here, so unsafe code may temporarily violate the invariant that strings are `UTF-8`.\nHowever, functions on `&str`/`String` may assume the string to be `UTF-8`, meaning they may cause UB if the string is *not* `UTF-8`.\nThis means that unsafe code violating the UTF-8 invariant must not perform string operations (it may operate on the data as a byte slice though), or else it risks UB.\nMoreover, such unsafe code must not return a non-UTF-8 string to the \"outside\" of its safe abstraction boundary, because that would mean safe code could cause UB by doing `bad_function().chars().count()`.",
        "ucg_validity_and_safety_invariant_p7": "To summarize: *Data must always be valid, but it only must be safe in safe code.*\nFor some more information, see this blog post."
      }
    },
    {
      "id": "ucg_value",
      "title": "Value",
      "level": 3,
      "content": "A *value* (called \"value of the expression\" or \"rvalue\" in C and \"prvalue\" in C++) is what gets stored in a [place], and also the result of computing a *value expression*.\nA value has a type, and it denotes the abstract mathematical concept that is represented by data in our programs.\n\nFor example, a value of type `u8` is a mathematical integer in the range `0..256`.\nValues can be (according to their type) turned into a list of (abstract) bytes, which is called a representation of the value.\nValues are ephemeral; they arise during the computation of an instruction but are only ever persisted in memory through their representation.\n(This is comparable to how run-time data in a program is ephemeral and is only ever persisted in serialized form.)",
      "parent_id": null,
      "paragraphs": {
        "ucg_value_p1": "",
        "ucg_value_p2": "A *value* (called \"value of the expression\" or \"rvalue\" in C and \"prvalue\" in C++) is what gets stored in a [place], and also the result of computing a *value expression*.\nA value has a type, and it denotes the abstract mathematical concept that is represented by data in our programs.",
        "ucg_value_p3": "For example, a value of type `u8` is a mathematical integer in the range `0..256`.\nValues can be (according to their type) turned into a list of (abstract) bytes, which is called a representation of the value.\nValues are ephemeral; they arise during the computation of an instruction but are only ever persisted in memory through their representation.\n(This is comparable to how run-time data in a program is ephemeral and is only ever persisted in serialized form.)"
      }
    },
    {
      "id": "ucg_zero_sized_type_zst",
      "title": "Zero-sized type / ZST",
      "level": 3,
      "content": "Types with zero size are called zero-sized types, which is abbreviated as \"ZST\".\nThis document also uses the \"1-ZST\" abbreviation, which stands for \"one-aligned\nzero-sized type\", to refer to zero-sized types with an alignment requirement of 1.\n\nFor example, `()` is a \"1-ZST\" but `[u16; 0]` is not because it has an alignment\nrequirement of 2.\n\n[stacked-borrows]: https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md\n[value-domain]: https://github.com/rust-lang/unsafe-code-guidelines/tree/master/wip/value-domain.md\n[place-value-expr]: https://doc.rust-lang.org/reference/expressions.html#place-expressions-and-value-expressions",
      "parent_id": null,
      "paragraphs": {
        "ucg_zero_sized_type_zst_p1": "Types with zero size are called zero-sized types, which is abbreviated as \"ZST\".\nThis document also uses the \"1-ZST\" abbreviation, which stands for \"one-aligned\nzero-sized type\", to refer to zero-sized types with an alignment requirement of 1.",
        "ucg_zero_sized_type_zst_p2": "For example, `()` is a \"1-ZST\" but `[u16; 0]` is not because it has an alignment\nrequirement of 2.",
        "ucg_zero_sized_type_zst_p3": "[stacked-borrows]: https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md\n[value-domain]: https://github.com/rust-lang/unsafe-code-guidelines/tree/master/wip/value-domain.md\n[place-value-expr]: https://doc.rust-lang.org/reference/expressions.html#place-expressions-and-value-expressions"
      }
    }
  ],
  "ids": [
    "ucg_memory_address_p3",
    "ucg_aliasing_p3",
    "ucg_validity_and_safety_invariant_p4",
    "ucg_memory_address_p1",
    "ucg_representation_relation_p3",
    "ucg_aliasing_p9",
    "ucg_representation_relation",
    "ucg_abstract_byte",
    "ucg_soundness_of_code_of_a_library",
    "ucg_place_p2",
    "ucg_soundness_of_code_of_a_library_p2",
    "ucg_interior_mutability",
    "ucg_niche_p3",
    "ucg_value_p1",
    "ucg_interior_mutability_p2",
    "ucg_padding_p2",
    "ucg_zero_sized_type_zst_p1",
    "ucg_validity_and_safety_invariant_p2",
    "ucg_aliasing_p11",
    "ucg_representation_relation_p5",
    "ucg_pointer_provenance_p5",
    "ucg_layout_p1",
    "ucg_abi_of_a_type_p1",
    "ucg_padding_p1",
    "ucg_padding_p4",
    "ucg_value_p3",
    "ucg_pointer_provenance_p2",
    "ucg_layout_p2",
    "ucg_undefined_behavior_p1",
    "ucg_pointer_provenance_p6",
    "ucg_pointer_provenance_p7",
    "ucg_abstract_byte_p6",
    "ucg_padding_p5",
    "ucg_pointer_provenance_p3",
    "ucg_glossary",
    "ucg_allocation_p4",
    "ucg_layout",
    "ucg_value_p2",
    "ucg_padding",
    "ucg_place_p1",
    "ucg_abstract_byte_p4",
    "ucg_allocation_p1",
    "ucg_validity_and_safety_invariant_p3",
    "ucg_abstract_byte_p5",
    "ucg_memory_address",
    "ucg_zero_sized_type_zst_p3",
    "ucg_aliasing",
    "ucg_abstract_byte_p3",
    "ucg_place_p3",
    "ucg_undefined_behavior",
    "ucg_validity_and_safety_invariant_p1",
    "ucg_aliasing_p7",
    "ucg_validity_and_safety_invariant_p6",
    "ucg_validity_and_safety_invariant_p7",
    "ucg_validity_and_safety_invariant_p5",
    "ucg_niche_p1",
    "ucg_representation_relation_p4",
    "ucg_soundness_of_code_of_a_library_p1",
    "ucg_abi_of_a_type_p2",
    "ucg_niche_p4",
    "ucg_aliasing_p2",
    "ucg_undefined_behavior_p3",
    "ucg_abstract_byte_p2",
    "ucg_aliasing_p6",
    "ucg_interior_mutability_p3",
    "ucg_undefined_behavior_p2",
    "ucg_aliasing_p5",
    "ucg_allocation_p3",
    "ucg_layout_p3",
    "ucg_pointer_provenance_p1",
    "ucg_zero_sized_type_zst_p2",
    "ucg_interior_mutability_p1",
    "ucg_aliasing_p1",
    "ucg_place",
    "ucg_representation_relation_p1",
    "ucg_niche_p2",
    "ucg_aliasing_p8",
    "ucg_pointer_provenance_p4",
    "ucg_layout_p4",
    "ucg_value",
    "ucg_aliasing_p10",
    "ucg_soundness_of_code_of_a_library_p3",
    "ucg_abstract_byte_p1",
    "ucg_allocation_p2",
    "ucg_memory_address_p2",
    "ucg_padding_p6",
    "ucg_validity_and_safety_invariant",
    "ucg_niche",
    "ucg_representation_relation_p2",
    "ucg_zero_sized_type_zst",
    "ucg_undefined_behavior_p4",
    "ucg_aliasing_p4",
    "ucg_pointer_provenance",
    "ucg_abi_of_a_type",
    "ucg_abi_of_a_type_p3",
    "ucg_padding_p3",
    "ucg_allocation"
  ]
}
