{
  "source": "Clippy",
  "source_repo": "https://github.com/rust-lang/rust-clippy",
  "extraction_date": "2026-01-03",
  "total_lints": 793,
  "categories": {
    "restriction": 127,
    "suspicious": 82,
    "correctness": 68,
    "style": 152,
    "pedantic": 138,
    "complexity": 133,
    "cargo": 5,
    "nursery": 52,
    "perf": 36
  },
  "category_weights": {
    "correctness": 1.2,
    "suspicious": 1.15,
    "restriction": 1.0,
    "pedantic": 1.0,
    "style": 0.95,
    "complexity": 1.0,
    "perf": 1.0,
    "cargo": 0.9,
    "nursery": 0.9
  },
  "lints": [
    {
      "id": "clippy::absolute_paths",
      "name": "ABSOLUTE_PATHS",
      "snake_name": "absolute_paths",
      "category": "restriction",
      "weight": 1.0,
      "brief": "checks for usage of an item without a `use` statement",
      "what_it_does": "Checks for usage of items through absolute paths, like `std::env::current_dir`.",
      "why_bad": "Many codebases have their own style when it comes to importing, but one that is seldom used\nis using absolute paths *everywhere*. This is generally considered unidiomatic, and you\nshould add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in\n`clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as\nusing absolute paths is the proper way of referencing items in one.",
      "example": "```no_run\nlet x = std::f64::consts::PI;\n```\nUse any of the below instead, or anything else:\n```no_run\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```",
      "version": "1.73.0",
      "source_file": "absolute_paths.rs",
      "embedding_text": "checks for usage of an item without a `use` statement\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\nMany codebases have their own style when it comes to importing, but one that is seldom used\nis using absolute paths *everywhere*. This is generally considered unidiomatic, and you\nshould add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in\n`clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as\nusing absolute paths is the proper way of referencing items in one."
    },
    {
      "id": "clippy::almost_complete_range",
      "name": "ALMOST_COMPLETE_RANGE",
      "snake_name": "almost_complete_range",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "almost complete range",
      "what_it_does": "Checks for ranges which almost include the entire range of letters from 'a' to 'z'\nor digits from '0' to '9', but don't because they're a half open range.",
      "why_bad": "This (`'a'..'z'`) is almost certainly a typo meant to include all letters.",
      "example": "```no_run\nlet _ = 'a'..'z';\n```\nUse instead:\n```no_run\nlet _ = 'a'..='z';\n```",
      "version": "1.68.0",
      "source_file": "almost_complete_range.rs",
      "embedding_text": "almost complete range\n\nChecks for ranges which almost include the entire range of letters from 'a' to 'z'\nor digits from '0' to '9', but don't because they're a half open range.\n\nThis (`'a'..'z'`) is almost certainly a typo meant to include all letters."
    },
    {
      "id": "clippy::approx_constant",
      "name": "APPROX_CONSTANT",
      "snake_name": "approx_constant",
      "category": "correctness",
      "weight": 1.2,
      "brief": "the approximate of a known float constant (in `std::fXX::consts`)",
      "what_it_does": "Checks for floating point literals that approximate\nconstants which are defined in\n[`std::f32::consts`](https://doc.rust-lang.org/stable/std/f32/consts/#constants)\nor\n[`std::f64::consts`](https://doc.rust-lang.org/stable/std/f64/consts/#constants),\nrespectively, suggesting to use the predefined constant.",
      "why_bad": "Usually, the definition in the standard library is more\nprecise than what people come up with. If you find that your definition is\nactually more precise, please [file a Rust\nissue](https://github.com/rust-lang/rust/issues).",
      "example": "```no_run\nlet x = 3.14;\nlet y = 1_f64 / x;\n```\nUse instead:\n```no_run\nlet x = std::f32::consts::PI;\nlet y = std::f64::consts::FRAC_1_PI;\n```",
      "version": "pre 1.29.0",
      "source_file": "approx_const.rs",
      "embedding_text": "the approximate of a known float constant (in `std::fXX::consts`)\n\nChecks for floating point literals that approximate\nconstants which are defined in\n[`std::f32::consts`](https://doc.rust-lang.org/stable/std/f32/consts/#constants)\nor\n[`std::f64::consts`](https://doc.rust-lang.org/stable/std/f64/consts/#constants),\nrespectively, suggesting to use the predefined constant.\n\nUsually, the definition in the standard library is more\nprecise than what people come up with. If you find that your definition is\nactually more precise, please [file a Rust\nissue](https://github.com/rust-lang/rust/issues)."
    },
    {
      "id": "clippy::arbitrary_source_item_ordering",
      "name": "ARBITRARY_SOURCE_ITEM_ORDERING",
      "snake_name": "arbitrary_source_item_ordering",
      "category": "restriction",
      "weight": 1.0,
      "brief": "arbitrary source item ordering",
      "what_it_does": "Confirms that items are sorted in source files as per configuration.",
      "why_bad": "Keeping a consistent ordering throughout the codebase helps with working\nas a team, and possibly improves maintainability of the codebase. The\nidea is that by defining a consistent and enforceable rule for how\nsource files are structured, less time will be wasted during reviews on\na topic that is (under most circumstances) not relevant to the logic\nimplemented in the code. Sometimes this will be referred to as\n\"bikeshedding\".\n\nThe content of items with a representation clause attribute, such as\n`#[repr(C)]` will not be checked, as the order of their fields or\nvariants might be dictated by an external API (application binary\ninterface).",
      "example": "```no_run\ntrait TraitUnordered {\nconst A: bool;\nconst C: bool;\nconst B: bool;\n\ntype SomeType;\n\nfn a();\nfn c();\nfn b();\n}\n```\n\nUse instead:\n```no_run\ntrait TraitOrdered {\nconst A: bool;\nconst B: bool;\nconst C: bool;\n\ntype SomeType;\n\nfn a();\nfn b();\nfn c();\n}\n```\n\n[cargo-pgo]: https://github.com/Kobzol/cargo-pgo/blob/main/README.md",
      "version": "1.84.0",
      "source_file": "arbitrary_source_item_ordering.rs",
      "embedding_text": "arbitrary source item ordering\n\nConfirms that items are sorted in source files as per configuration.\n\nKeeping a consistent ordering throughout the codebase helps with working\nas a team, and possibly improves maintainability of the codebase. The\nidea is that by defining a consistent and enforceable rule for how\nsource files are structured, less time will be wasted during reviews on\na topic that is (under most circumstances) not relevant to the logic\nimplemented in the code. Sometimes this will be referred to as\n\"bikeshedding\".\n\nThe content of items with a representation clause attribute, such as\n`#[repr(C)]` will not be checked, as the order of their fields or\nvariants might be dictated by an external API (application binary\ninterface)."
    },
    {
      "id": "clippy::arc_with_non_send_sync",
      "name": "ARC_WITH_NON_SEND_SYNC",
      "snake_name": "arc_with_non_send_sync",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "using `Arc` with a type that does not implement `Send` and `Sync`",
      "what_it_does": "This lint warns when you use `Arc` with a type that does not implement `Send` or `Sync`.",
      "why_bad": "`Arc<T>` is a thread-safe `Rc<T>` and guarantees that updates to the reference counter\nuse atomic operations. To send an `Arc<T>` across thread boundaries and\nshare ownership between multiple threads, `T` must be [both `Send` and `Sync`](https://doc.rust-lang.org/std/sync/struct.Arc.html#thread-safety),\nso either `T` should be made `Send + Sync` or an `Rc` should be used instead of an `Arc`.",
      "example": "```no_run\n# use std::cell::RefCell;\n# use std::sync::Arc;\n\nfn main() {\n// This is fine, as `i32` implements `Send` and `Sync`.\nlet a = Arc::new(42);\n\n// `RefCell` is `!Sync`, so either the `Arc` should be replaced with an `Rc`\n// or the `RefCell` replaced with something like a `RwLock`\nlet b = Arc::new(RefCell::new(42));\n}\n```",
      "version": "1.72.0",
      "source_file": "arc_with_non_send_sync.rs",
      "embedding_text": "using `Arc` with a type that does not implement `Send` and `Sync`\n\nThis lint warns when you use `Arc` with a type that does not implement `Send` or `Sync`.\n\n`Arc<T>` is a thread-safe `Rc<T>` and guarantees that updates to the reference counter\nuse atomic operations. To send an `Arc<T>` across thread boundaries and\nshare ownership between multiple threads, `T` must be [both `Send` and `Sync`](https://doc.rust-lang.org/std/sync/struct.Arc.html#thread-safety),\nso either `T` should be made `Send + Sync` or an `Rc` should be used instead of an `Arc`."
    },
    {
      "id": "clippy::as_conversions",
      "name": "AS_CONVERSIONS",
      "snake_name": "as_conversions",
      "category": "restriction",
      "weight": 1.0,
      "brief": "using a potentially dangerous silent `as` conversion",
      "what_it_does": "Checks for usage of `as` conversions.\n\nNote that this lint is specialized in linting *every single* use of `as`\nregardless of whether good alternatives exist or not. If you want more\nprecise lints for `as`, please consider using these separate lints:\n\n- `clippy::cast_lossless`\n- `clippy::cast_possible_truncation`\n- `clippy::cast_possible_wrap`\n- `clippy::cast_precision_loss`\n- `clippy::cast_sign_loss`\n- `clippy::char_lit_as_u8`\n- `clippy::fn_to_numeric_cast`\n- `clippy::fn_to_numeric_cast_with_truncation`\n- `clippy::ptr_as_ptr`\n- `clippy::unnecessary_cast`\n- `invalid_reference_casting`\n\nThere is a good explanation the reason why this lint should work in this\nway and how it is useful [in this\nissue](https://github.com/rust-lang/rust-clippy/issues/5122).",
      "why_bad": "`as` conversions will perform many kinds of\nconversions, including silently lossy conversions and dangerous coercions.\nThere are cases when it makes sense to use `as`, so the lint is\nAllow by default.",
      "example": "```rust,ignore\nlet a: u32;\n...\nf(a as u16);\n```\n\nUse instead:\n```rust,ignore\nf(a.try_into()?);\n\n// or\n\nf(a.try_into().expect(\"Unexpected u16 overflow in f\"));\n```",
      "version": "1.41.0",
      "source_file": "as_conversions.rs",
      "embedding_text": "using a potentially dangerous silent `as` conversion\n\nChecks for usage of `as` conversions.\n\nNote that this lint is specialized in linting *every single* use of `as`\nregardless of whether good alternatives exist or not. If you want more\nprecise lints for `as`, please consider using these separate lints:\n\n- `clippy::cast_lossless`\n- `clippy::cast_possible_truncation`\n- `clippy::cast_possible_wrap`\n- `clippy::cast_precision_loss`\n- `clippy::cast_sign_loss`\n- `clippy::char_lit_as_u8`\n- `clippy::fn_to_numeric_cast`\n- `clippy::fn_to_numeric_cast_with_truncation`\n- `clippy::ptr_as_ptr`\n- `clippy::unnecessary_cast`\n- `invalid_reference_casting`\n\nThere is a good explanation the reason why this lint should work in this\nway and how it is useful [in this\nissue](https://github.com/rust-lang/rust-clippy/issues/5122).\n\n`as` conversions will perform many kinds of\nconversions, including silently lossy conversions and dangerous coercions.\nThere are cases when it makes sense to use `as`, so the lint is\nAllow by default."
    },
    {
      "id": "clippy::inline_asm_x86_intel_syntax",
      "name": "INLINE_ASM_X86_INTEL_SYNTAX",
      "snake_name": "inline_asm_x86_intel_syntax",
      "category": "restriction",
      "weight": 1.0,
      "brief": "prefer AT&T x86 assembly syntax",
      "what_it_does": "Checks for usage of Intel x86 assembly syntax.",
      "why_bad": "To enforce consistent use of AT&T x86 assembly syntax.",
      "example": "```rust,no_run\n# #![feature(asm)]\n# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n# unsafe { let ptr = \"\".as_ptr();\n# use std::arch::asm;\nasm!(\"lea {}, [{}]\", lateout(reg) _, in(reg) ptr);\n# }\n```\nUse instead:\n```rust,no_run\n# #![feature(asm)]\n# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n# unsafe { let ptr = \"\".as_ptr();\n# use std::arch::asm;\nasm!(\"lea ({}), {}\", in(reg) ptr, lateout(reg) _, options(att_syntax));\n# }\n```",
      "version": "1.49.0",
      "source_file": "asm_syntax.rs",
      "embedding_text": "prefer AT&T x86 assembly syntax\n\nChecks for usage of Intel x86 assembly syntax.\n\nTo enforce consistent use of AT&T x86 assembly syntax."
    },
    {
      "id": "clippy::inline_asm_x86_att_syntax",
      "name": "INLINE_ASM_X86_ATT_SYNTAX",
      "snake_name": "inline_asm_x86_att_syntax",
      "category": "restriction",
      "weight": 1.0,
      "brief": "prefer Intel x86 assembly syntax",
      "what_it_does": "Checks for usage of AT&T x86 assembly syntax.",
      "why_bad": "To enforce consistent use of Intel x86 assembly syntax.",
      "example": "```rust,no_run\n# #![feature(asm)]\n# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n# unsafe { let ptr = \"\".as_ptr();\n# use std::arch::asm;\nasm!(\"lea ({}), {}\", in(reg) ptr, lateout(reg) _, options(att_syntax));\n# }\n```\nUse instead:\n```rust,no_run\n# #![feature(asm)]\n# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n# unsafe { let ptr = \"\".as_ptr();\n# use std::arch::asm;\nasm!(\"lea {}, [{}]\", lateout(reg) _, in(reg) ptr);\n# }\n```",
      "version": "1.49.0",
      "source_file": "asm_syntax.rs",
      "embedding_text": "prefer Intel x86 assembly syntax\n\nChecks for usage of AT&T x86 assembly syntax.\n\nTo enforce consistent use of Intel x86 assembly syntax."
    },
    {
      "id": "clippy::assertions_on_constants",
      "name": "ASSERTIONS_ON_CONSTANTS",
      "snake_name": "assertions_on_constants",
      "category": "style",
      "weight": 0.95,
      "brief": "`assert!(true)` / `assert!(false)` will be optimized out by the compiler, and should probably be replaced by a `panic!()` or `unreachable!()`",
      "what_it_does": "Checks for `assert!(true)` and `assert!(false)` calls.",
      "why_bad": "Will be optimized out by the compiler or should probably be replaced by a\n`panic!()` or `unreachable!()`",
      "example": "```rust,ignore\nassert!(false)\nassert!(true)\nconst B: bool = false;\nassert!(B)\n```",
      "version": "1.34.0",
      "source_file": "assertions_on_constants.rs",
      "embedding_text": "`assert!(true)` / `assert!(false)` will be optimized out by the compiler, and should probably be replaced by a `panic!()` or `unreachable!()`\n\nChecks for `assert!(true)` and `assert!(false)` calls.\n\nWill be optimized out by the compiler or should probably be replaced by a\n`panic!()` or `unreachable!()`"
    },
    {
      "id": "clippy::assertions_on_result_states",
      "name": "ASSERTIONS_ON_RESULT_STATES",
      "snake_name": "assertions_on_result_states",
      "category": "restriction",
      "weight": 1.0,
      "brief": "`assert!(r.is_ok())` or `assert!(r.is_err())` gives worse panic messages than directly calling `r.unwrap()` or `r.unwrap_err()`",
      "what_it_does": "Checks for `assert!(r.is_ok())` or `assert!(r.is_err())` calls.",
      "why_bad": "This form of assertion does not show any of the information present in the `Result`\nother than which variant it isn\u2019t.",
      "example": "```rust,no_run\n# let r = Ok::<_, ()>(());\nassert!(r.is_ok());\n# let r = Err::<(), _>(());\nassert!(r.is_err());\n```\n\nUse instead:\n\n```rust,no_run\n# let r = Ok::<_, ()>(());\nr.unwrap();\n# let r = Err::<(), _>(());\nr.unwrap_err();\n```",
      "version": "1.64.0",
      "source_file": "assertions_on_result_states.rs",
      "embedding_text": "`assert!(r.is_ok())` or `assert!(r.is_err())` gives worse panic messages than directly calling `r.unwrap()` or `r.unwrap_err()`\n\nChecks for `assert!(r.is_ok())` or `assert!(r.is_err())` calls.\n\nThis form of assertion does not show any of the information present in the `Result`\nother than which variant it isn\u2019t."
    },
    {
      "id": "clippy::assigning_clones",
      "name": "ASSIGNING_CLONES",
      "snake_name": "assigning_clones",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "assigning the result of cloning may be inefficient",
      "what_it_does": "Checks for code like `foo = bar.clone();`",
      "why_bad": "Custom `Clone::clone_from()` or `ToOwned::clone_into` implementations allow the objects\nto share resources and therefore avoid allocations.",
      "example": "```rust\nstruct Thing;\n\nimpl Clone for Thing {\nfn clone(&self) -> Self { todo!() }\nfn clone_from(&mut self, other: &Self) { todo!() }\n}\n\npub fn assign_to_ref(a: &mut Thing, b: Thing) {\n*a = b.clone();\n}\n```\nUse instead:\n```rust\nstruct Thing;\n\nimpl Clone for Thing {\nfn clone(&self) -> Self { todo!() }\nfn clone_from(&mut self, other: &Self) { todo!() }\n}\n\npub fn assign_to_ref(a: &mut Thing, b: Thing) {\na.clone_from(&b);\n}\n```",
      "version": "1.78.0",
      "source_file": "assigning_clones.rs",
      "embedding_text": "assigning the result of cloning may be inefficient\n\nChecks for code like `foo = bar.clone();`\n\nCustom `Clone::clone_from()` or `ToOwned::clone_into` implementations allow the objects\nto share resources and therefore avoid allocations."
    },
    {
      "id": "clippy::async_yields_async",
      "name": "ASYNC_YIELDS_ASYNC",
      "snake_name": "async_yields_async",
      "category": "correctness",
      "weight": 1.2,
      "brief": "async blocks that return a type that can be awaited",
      "what_it_does": "Checks for async blocks that yield values of types\nthat can themselves be awaited.",
      "why_bad": "An await is likely missing.",
      "example": "```no_run\nasync fn foo() {}\n\nfn bar() {\nlet x = async {\nfoo()\n};\n}\n```\n\nUse instead:\n```no_run\nasync fn foo() {}\n\nfn bar() {\nlet x = async {\nfoo().await\n};\n}\n```",
      "version": "1.48.0",
      "source_file": "async_yields_async.rs",
      "embedding_text": "async blocks that return a type that can be awaited\n\nChecks for async blocks that yield values of types\nthat can themselves be awaited.\n\nAn await is likely missing."
    },
    {
      "id": "clippy::inline_always",
      "name": "INLINE_ALWAYS",
      "snake_name": "inline_always",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "use of `#[inline(always)]`",
      "what_it_does": "Checks for items annotated with `#[inline(always)]`,\nunless the annotated function is empty or simply panics.",
      "why_bad": "While there are valid uses of this annotation (and once\nyou know when to use it, by all means `allow` this lint), it's a common\nnewbie-mistake to pepper one's code with it.\n\nAs a rule of thumb, before slapping `#[inline(always)]` on a function,\nmeasure if that additional function call really affects your runtime profile\nsufficiently to make up for the increase in compile time.",
      "example": "```ignore\n#[inline(always)]\nfn not_quite_hot_code(..) { ... }\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "use of `#[inline(always)]`\n\nChecks for items annotated with `#[inline(always)]`,\nunless the annotated function is empty or simply panics.\n\nWhile there are valid uses of this annotation (and once\nyou know when to use it, by all means `allow` this lint), it's a common\nnewbie-mistake to pepper one's code with it.\n\nAs a rule of thumb, before slapping `#[inline(always)]` on a function,\nmeasure if that additional function call really affects your runtime profile\nsufficiently to make up for the increase in compile time."
    },
    {
      "id": "clippy::useless_attribute",
      "name": "USELESS_ATTRIBUTE",
      "snake_name": "useless_attribute",
      "category": "correctness",
      "weight": 1.2,
      "brief": "use of lint attributes on `extern crate` items",
      "what_it_does": "Checks for `extern crate` and `use` items annotated with\nlint attributes.\n\nThis lint permits lint attributes for lints emitted on the items themself.\nFor `use` items these lints are:\n* ambiguous_glob_reexports\n* dead_code\n* deprecated\n* hidden_glob_reexports\n* unreachable_pub\n* unused\n* unused_braces\n* unused_import_braces\n* clippy::disallowed_types\n* clippy::enum_glob_use\n* clippy::macro_use_imports\n* clippy::module_name_repetitions\n* clippy::redundant_pub_crate\n* clippy::single_component_path_imports\n* clippy::unsafe_removed_from_name\n* clippy::wildcard_imports\n\nFor `extern crate` items these lints are:\n* `unused_imports` on items with `#[macro_use]`",
      "why_bad": "Lint attributes have no effect on crate imports. Most\nlikely a `!` was forgotten.",
      "example": "```ignore\n#[deny(dead_code)]\nextern crate foo;\n#[forbid(dead_code)]\nuse foo::bar;\n```\n\nUse instead:\n```rust,ignore\n#[allow(unused_imports)]\nuse foo::baz;\n#[allow(unused_imports)]\n#[macro_use]\nextern crate baz;\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "use of lint attributes on `extern crate` items\n\nChecks for `extern crate` and `use` items annotated with\nlint attributes.\n\nThis lint permits lint attributes for lints emitted on the items themself.\nFor `use` items these lints are:\n* ambiguous_glob_reexports\n* dead_code\n* deprecated\n* hidden_glob_reexports\n* unreachable_pub\n* unused\n* unused_braces\n* unused_import_braces\n* clippy::disallowed_types\n* clippy::enum_glob_use\n* clippy::macro_use_imports\n* clippy::module_name_repetitions\n* clippy::redundant_pub_crate\n* clippy::single_component_path_imports\n* clippy::unsafe_removed_from_name\n* clippy::wildcard_imports\n\nFor `extern crate` items these lints are:\n* `unused_imports` on items with `#[macro_use]`\n\nLint attributes have no effect on crate imports. Most\nlikely a `!` was forgotten."
    },
    {
      "id": "clippy::deprecated_semver",
      "name": "DEPRECATED_SEMVER",
      "snake_name": "deprecated_semver",
      "category": "correctness",
      "weight": 1.2,
      "brief": "use of `#[deprecated(since = \\",
      "what_it_does": "Checks for `#[deprecated]` annotations with a `since`\nfield that is not a valid semantic version. Also allows \"TBD\" to signal\nfuture deprecation.",
      "why_bad": "For checking the version of the deprecation, it must be\na valid semver. Failing that, the contained information is useless.",
      "example": "```no_run\n#[deprecated(since = \"forever\")]\nfn something_else() { /* ... */ }\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "use of `#[deprecated(since = \\\n\nChecks for `#[deprecated]` annotations with a `since`\nfield that is not a valid semantic version. Also allows \"TBD\" to signal\nfuture deprecation.\n\nFor checking the version of the deprecation, it must be\na valid semver. Failing that, the contained information is useless."
    },
    {
      "id": "clippy::blanket_clippy_restriction_lints",
      "name": "BLANKET_CLIPPY_RESTRICTION_LINTS",
      "snake_name": "blanket_clippy_restriction_lints",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "enabling the complete restriction group",
      "what_it_does": "Checks for `warn`/`deny`/`forbid` attributes targeting the whole clippy::restriction category.",
      "why_bad": "Restriction lints sometimes are in contrast with other lints or even go against idiomatic rust.\nThese lints should only be enabled on a lint-by-lint basis and with careful consideration.",
      "example": "```no_run\n#![deny(clippy::restriction)]\n```\n\nUse instead:\n```no_run\n#![deny(clippy::as_conversions)]\n```",
      "version": "1.47.0",
      "source_file": "mod.rs",
      "embedding_text": "enabling the complete restriction group\n\nChecks for `warn`/`deny`/`forbid` attributes targeting the whole clippy::restriction category.\n\nRestriction lints sometimes are in contrast with other lints or even go against idiomatic rust.\nThese lints should only be enabled on a lint-by-lint basis and with careful consideration."
    },
    {
      "id": "clippy::deprecated_cfg_attr",
      "name": "DEPRECATED_CFG_ATTR",
      "snake_name": "deprecated_cfg_attr",
      "category": "complexity",
      "weight": 1.0,
      "brief": "usage of `cfg_attr(rustfmt)` instead of tool attributes",
      "what_it_does": "Checks for `#[cfg_attr(rustfmt, rustfmt_skip)]` and suggests to replace it\nwith `#[rustfmt::skip]`.",
      "why_bad": "Since tool_attributes ([rust-lang/rust#44690](https://github.com/rust-lang/rust/issues/44690))\nare stable now, they should be used instead of the old `cfg_attr(rustfmt)` attributes.",
      "example": "```no_run\n#[cfg_attr(rustfmt, rustfmt_skip)]\nfn main() { }\n```\n\nUse instead:\n```no_run\n#[rustfmt::skip]\nfn main() { }\n```",
      "version": "1.32.0",
      "source_file": "mod.rs",
      "embedding_text": "usage of `cfg_attr(rustfmt)` instead of tool attributes\n\nChecks for `#[cfg_attr(rustfmt, rustfmt_skip)]` and suggests to replace it\nwith `#[rustfmt::skip]`.\n\nSince tool_attributes ([rust-lang/rust#44690](https://github.com/rust-lang/rust/issues/44690))\nare stable now, they should be used instead of the old `cfg_attr(rustfmt)` attributes."
    },
    {
      "id": "clippy::allow_attributes_without_reason",
      "name": "ALLOW_ATTRIBUTES_WITHOUT_REASON",
      "snake_name": "allow_attributes_without_reason",
      "category": "restriction",
      "weight": 1.0,
      "brief": "ensures that all `allow` and `expect` attributes have a reason",
      "what_it_does": "Checks for attributes that allow lints without a reason.",
      "why_bad": "Justifying each `allow` helps readers understand the reasoning,\nand may allow removing `allow` attributes if their purpose is obsolete.",
      "example": "```no_run\n#![allow(clippy::some_lint)]\n```\n\nUse instead:\n```no_run\n#![allow(clippy::some_lint, reason = \"False positive rust-lang/rust-clippy#1002020\")]\n```",
      "version": "1.61.0",
      "source_file": "mod.rs",
      "embedding_text": "ensures that all `allow` and `expect` attributes have a reason\n\nChecks for attributes that allow lints without a reason.\n\nJustifying each `allow` helps readers understand the reasoning,\nand may allow removing `allow` attributes if their purpose is obsolete."
    },
    {
      "id": "clippy::allow_attributes",
      "name": "ALLOW_ATTRIBUTES",
      "snake_name": "allow_attributes",
      "category": "restriction",
      "weight": 1.0,
      "brief": "`#[allow]` will not trigger if a warning isn't found. `#[expect]` triggers if there are no warnings.",
      "what_it_does": "Checks for usage of the `#[allow]` attribute and suggests replacing it with\nthe `#[expect]` attribute (See [RFC 2383](https://rust-lang.github.io/rfcs/2383-lint-reasons.html))\n\nThis lint only warns outer attributes (`#[allow]`), as inner attributes\n(`#![allow]`) are usually used to enable or disable lints on a global scale.",
      "why_bad": "`#[expect]` attributes suppress the lint emission, but emit a warning, if\nthe expectation is unfulfilled. This can be useful to be notified when the\nlint is no longer triggered.",
      "example": "```rust,ignore\n#[allow(unused_mut)]\nfn foo() -> usize {\nlet mut a = Vec::new();\na.len()\n}\n```\nUse instead:\n```rust,ignore\n#[expect(unused_mut)]\nfn foo() -> usize {\nlet mut a = Vec::new();\na.len()\n}\n```",
      "version": "1.70.0",
      "source_file": "mod.rs",
      "embedding_text": "`#[allow]` will not trigger if a warning isn't found. `#[expect]` triggers if there are no warnings.\n\nChecks for usage of the `#[allow]` attribute and suggests replacing it with\nthe `#[expect]` attribute (See [RFC 2383](https://rust-lang.github.io/rfcs/2383-lint-reasons.html))\n\nThis lint only warns outer attributes (`#[allow]`), as inner attributes\n(`#![allow]`) are usually used to enable or disable lints on a global scale.\n\n`#[expect]` attributes suppress the lint emission, but emit a warning, if\nthe expectation is unfulfilled. This can be useful to be notified when the\nlint is no longer triggered."
    },
    {
      "id": "clippy::should_panic_without_expect",
      "name": "SHOULD_PANIC_WITHOUT_EXPECT",
      "snake_name": "should_panic_without_expect",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "ensures that all `should_panic` attributes specify its expected panic message",
      "what_it_does": "Checks for `#[should_panic]` attributes without specifying the expected panic message.",
      "why_bad": "The expected panic message should be specified to ensure that the test is actually\npanicking with the expected message, and not another unrelated panic.",
      "example": "```no_run\nfn random() -> i32 { 0 }\n\n#[should_panic]\n#[test]\nfn my_test() {\nlet _ = 1 / random();\n}\n```\n\nUse instead:\n```no_run\nfn random() -> i32 { 0 }\n\n#[should_panic = \"attempt to divide by zero\"]\n#[test]\nfn my_test() {\nlet _ = 1 / random();\n}\n```",
      "version": "1.74.0",
      "source_file": "mod.rs",
      "embedding_text": "ensures that all `should_panic` attributes specify its expected panic message\n\nChecks for `#[should_panic]` attributes without specifying the expected panic message.\n\nThe expected panic message should be specified to ensure that the test is actually\npanicking with the expected message, and not another unrelated panic."
    },
    {
      "id": "clippy::repr_packed_without_abi",
      "name": "REPR_PACKED_WITHOUT_ABI",
      "snake_name": "repr_packed_without_abi",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "ensures that `repr(packed)` always comes with a qualified ABI",
      "what_it_does": "Checks for items with `#[repr(packed)]`-attribute without ABI qualification",
      "why_bad": "Without qualification, `repr(packed)` implies `repr(Rust)`. The Rust-ABI is inherently unstable.\nWhile this is fine as long as the type is accessed correctly within Rust-code, most uses\nof `#[repr(packed)]` involve FFI and/or data structures specified by network-protocols or\nother external specifications. In such situations, the unstable Rust-ABI implied in\n`#[repr(packed)]` may lead to future bugs should the Rust-ABI change.\n\nIn case you are relying on a well defined and stable memory layout, qualify the type's\nrepresentation using the `C`-ABI. Otherwise, if the type in question is only ever\naccessed from Rust-code according to Rust's rules, use the `Rust`-ABI explicitly.",
      "example": "```no_run\n#[repr(packed)]\nstruct NetworkPacketHeader {\nheader_length: u8,\nheader_version: u16\n}\n```\n\nUse instead:\n```no_run\n#[repr(C, packed)]\nstruct NetworkPacketHeader {\nheader_length: u8,\nheader_version: u16\n}\n```",
      "version": "1.85.0",
      "source_file": "mod.rs",
      "embedding_text": "ensures that `repr(packed)` always comes with a qualified ABI\n\nChecks for items with `#[repr(packed)]`-attribute without ABI qualification\n\nWithout qualification, `repr(packed)` implies `repr(Rust)`. The Rust-ABI is inherently unstable.\nWhile this is fine as long as the type is accessed correctly within Rust-code, most uses\nof `#[repr(packed)]` involve FFI and/or data structures specified by network-protocols or\nother external specifications. In such situations, the unstable Rust-ABI implied in\n`#[repr(packed)]` may lead to future bugs should the Rust-ABI change.\n\nIn case you are relying on a well defined and stable memory layout, qualify the type's\nrepresentation using the `C`-ABI. Otherwise, if the type in question is only ever\naccessed from Rust-code according to Rust's rules, use the `Rust`-ABI explicitly."
    },
    {
      "id": "clippy::non_minimal_cfg",
      "name": "NON_MINIMAL_CFG",
      "snake_name": "non_minimal_cfg",
      "category": "style",
      "weight": 0.95,
      "brief": "ensure that all `cfg(any())` and `cfg(all())` have more than one condition",
      "what_it_does": "Checks for `any` and `all` combinators in `cfg` with only one condition.",
      "why_bad": "If there is only one condition, no need to wrap it into `any` or `all` combinators.",
      "example": "```no_run\n#[cfg(any(unix))]\npub struct Bar;\n```\n\nUse instead:\n```no_run\n#[cfg(unix)]\npub struct Bar;\n```",
      "version": "1.71.0",
      "source_file": "mod.rs",
      "embedding_text": "ensure that all `cfg(any())` and `cfg(all())` have more than one condition\n\nChecks for `any` and `all` combinators in `cfg` with only one condition.\n\nIf there is only one condition, no need to wrap it into `any` or `all` combinators."
    },
    {
      "id": "clippy::deprecated_clippy_cfg_attr",
      "name": "DEPRECATED_CLIPPY_CFG_ATTR",
      "snake_name": "deprecated_clippy_cfg_attr",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "usage of `cfg(feature = \\",
      "what_it_does": "Checks for `#[cfg_attr(feature = \"cargo-clippy\", ...)]` and for\n`#[cfg(feature = \"cargo-clippy\")]` and suggests to replace it with\n`#[cfg_attr(clippy, ...)]` or `#[cfg(clippy)]`.",
      "why_bad": "This feature has been deprecated for years and shouldn't be used anymore.",
      "example": "```no_run\n#[cfg(feature = \"cargo-clippy\")]\nstruct Bar;\n```\n\nUse instead:\n```no_run\n#[cfg(clippy)]\nstruct Bar;\n```",
      "version": "1.78.0",
      "source_file": "mod.rs",
      "embedding_text": "usage of `cfg(feature = \\\n\nChecks for `#[cfg_attr(feature = \"cargo-clippy\", ...)]` and for\n`#[cfg(feature = \"cargo-clippy\")]` and suggests to replace it with\n`#[cfg_attr(clippy, ...)]` or `#[cfg(clippy)]`.\n\nThis feature has been deprecated for years and shouldn't be used anymore."
    },
    {
      "id": "clippy::unnecessary_clippy_cfg",
      "name": "UNNECESSARY_CLIPPY_CFG",
      "snake_name": "unnecessary_clippy_cfg",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "usage of `cfg_attr(clippy, allow(clippy::lint))` instead of `allow(clippy::lint)`",
      "what_it_does": "Checks for `#[cfg_attr(clippy, allow(clippy::lint))]`\nand suggests to replace it with `#[allow(clippy::lint)]`.",
      "why_bad": "There is no reason to put clippy attributes behind a clippy `cfg` as they are not\nrun by anything else than clippy.",
      "example": "```no_run\n#![cfg_attr(clippy, allow(clippy::deprecated_cfg_attr))]\n```\n\nUse instead:\n```no_run\n#![allow(clippy::deprecated_cfg_attr)]\n```",
      "version": "1.78.0",
      "source_file": "mod.rs",
      "embedding_text": "usage of `cfg_attr(clippy, allow(clippy::lint))` instead of `allow(clippy::lint)`\n\nChecks for `#[cfg_attr(clippy, allow(clippy::lint))]`\nand suggests to replace it with `#[allow(clippy::lint)]`.\n\nThere is no reason to put clippy attributes behind a clippy `cfg` as they are not\nrun by anything else than clippy."
    },
    {
      "id": "clippy::mixed_attributes_style",
      "name": "MIXED_ATTRIBUTES_STYLE",
      "snake_name": "mixed_attributes_style",
      "category": "style",
      "weight": 0.95,
      "brief": "item has both inner and outer attributes",
      "what_it_does": "Checks for items that have the same kind of attributes with mixed styles (inner/outer).",
      "why_bad": "Having both style of said attributes makes it more complicated to read code.",
      "example": "```no_run\n#[cfg(linux)]\npub fn foo() {\n#![cfg(windows)]\n}\n```\nUse instead:\n```no_run\n#[cfg(linux)]\n#[cfg(windows)]\npub fn foo() {\n}\n```",
      "version": "1.78.0",
      "source_file": "mod.rs",
      "embedding_text": "item has both inner and outer attributes\n\nChecks for items that have the same kind of attributes with mixed styles (inner/outer).\n\nHaving both style of said attributes makes it more complicated to read code."
    },
    {
      "id": "clippy::duplicated_attributes",
      "name": "DUPLICATED_ATTRIBUTES",
      "snake_name": "duplicated_attributes",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "duplicated attribute",
      "what_it_does": "Checks for attributes that appear two or more times.",
      "why_bad": "Repeating an attribute on the same item (or globally on the same crate)\nis unnecessary and doesn't have an effect.",
      "example": "```no_run\n#[allow(dead_code)]\n#[allow(dead_code)]\nfn foo() {}\n```\n\nUse instead:\n```no_run\n#[allow(dead_code)]\nfn foo() {}\n```",
      "version": "1.79.0",
      "source_file": "mod.rs",
      "embedding_text": "duplicated attribute\n\nChecks for attributes that appear two or more times.\n\nRepeating an attribute on the same item (or globally on the same crate)\nis unnecessary and doesn't have an effect."
    },
    {
      "id": "clippy::ignore_without_reason",
      "name": "IGNORE_WITHOUT_REASON",
      "snake_name": "ignore_without_reason",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "ignored tests without messages",
      "what_it_does": "Checks for ignored tests without messages.",
      "why_bad": "The reason for ignoring the test may not be obvious.",
      "example": "```no_run\n#[test]\n#[ignore]\nfn test() {}\n```\nUse instead:\n```no_run\n#[test]\n#[ignore = \"Some good reason\"]\nfn test() {}\n```",
      "version": "1.88.0",
      "source_file": "mod.rs",
      "embedding_text": "ignored tests without messages\n\nChecks for ignored tests without messages.\n\nThe reason for ignoring the test may not be obvious."
    },
    {
      "id": "clippy::await_holding_lock",
      "name": "AWAIT_HOLDING_LOCK",
      "snake_name": "await_holding_lock",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "inside an async function, holding a `MutexGuard` while calling `await`",
      "what_it_does": "Checks for calls to `await` while holding a non-async-aware\n`MutexGuard`.",
      "why_bad": "The Mutex types found in [`std::sync`](https://doc.rust-lang.org/stable/std/sync/) and\n[`parking_lot`](https://docs.rs/parking_lot/latest/parking_lot/) are\nnot designed to operate in an async context across await points.\n\nThere are two potential solutions. One is to use an async-aware `Mutex`\ntype. Many asynchronous foundation crates provide such a `Mutex` type.\nThe other solution is to ensure the mutex is unlocked before calling\n`await`, either by introducing a scope or an explicit call to\n[`Drop::drop`](https://doc.rust-lang.org/std/ops/trait.Drop.html).",
      "example": "```no_run\n# use std::sync::Mutex;\n# async fn baz() {}\nasync fn foo(x: &Mutex<u32>) {\nlet mut guard = x.lock().unwrap();\n*guard += 1;\nbaz().await;\n}\n\nasync fn bar(x: &Mutex<u32>) {\nlet mut guard = x.lock().unwrap();\n*guard += 1;\ndrop(guard); // explicit drop\nbaz().await;\n}\n```\n\nUse instead:\n```no_run\n# use std::sync::Mutex;\n# async fn baz() {}\nasync fn foo(x: &Mutex<u32>) {\n{\nlet mut guard = x.lock().unwrap();\n*guard += 1;\n}\nbaz().await;\n}\n\nasync fn bar(x: &Mutex<u32>) {\n{\nlet mut guard = x.lock().unwrap();\n*guard += 1;\n} // guard dropped here at end of scope\nbaz().await;\n}\n```",
      "version": "1.45.0",
      "source_file": "await_holding_invalid.rs",
      "embedding_text": "inside an async function, holding a `MutexGuard` while calling `await`\n\nChecks for calls to `await` while holding a non-async-aware\n`MutexGuard`.\n\nThe Mutex types found in [`std::sync`](https://doc.rust-lang.org/stable/std/sync/) and\n[`parking_lot`](https://docs.rs/parking_lot/latest/parking_lot/) are\nnot designed to operate in an async context across await points.\n\nThere are two potential solutions. One is to use an async-aware `Mutex`\ntype. Many asynchronous foundation crates provide such a `Mutex` type.\nThe other solution is to ensure the mutex is unlocked before calling\n`await`, either by introducing a scope or an explicit call to\n[`Drop::drop`](https://doc.rust-lang.org/std/ops/trait.Drop.html)."
    },
    {
      "id": "clippy::await_holding_refcell_ref",
      "name": "AWAIT_HOLDING_REFCELL_REF",
      "snake_name": "await_holding_refcell_ref",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "inside an async function, holding a `RefCell` ref while calling `await`",
      "what_it_does": "Checks for calls to `await` while holding a `RefCell`, `Ref`, or `RefMut`.",
      "why_bad": "`RefCell` refs only check for exclusive mutable access\nat runtime. Holding a `RefCell` ref across an await suspension point\nrisks panics from a mutable ref shared while other refs are outstanding.",
      "example": "```no_run\n# use std::cell::RefCell;\n# async fn baz() {}\nasync fn foo(x: &RefCell<u32>) {\nlet mut y = x.borrow_mut();\n*y += 1;\nbaz().await;\n}\n\nasync fn bar(x: &RefCell<u32>) {\nlet mut y = x.borrow_mut();\n*y += 1;\ndrop(y); // explicit drop\nbaz().await;\n}\n```\n\nUse instead:\n```no_run\n# use std::cell::RefCell;\n# async fn baz() {}\nasync fn foo(x: &RefCell<u32>) {\n{\nlet mut y = x.borrow_mut();\n*y += 1;\n}\nbaz().await;\n}\n\nasync fn bar(x: &RefCell<u32>) {\n{\nlet mut y = x.borrow_mut();\n*y += 1;\n} // y dropped here at end of scope\nbaz().await;\n}\n```",
      "version": "1.49.0",
      "source_file": "await_holding_invalid.rs",
      "embedding_text": "inside an async function, holding a `RefCell` ref while calling `await`\n\nChecks for calls to `await` while holding a `RefCell`, `Ref`, or `RefMut`.\n\n`RefCell` refs only check for exclusive mutable access\nat runtime. Holding a `RefCell` ref across an await suspension point\nrisks panics from a mutable ref shared while other refs are outstanding."
    },
    {
      "id": "clippy::await_holding_invalid_type",
      "name": "AWAIT_HOLDING_INVALID_TYPE",
      "snake_name": "await_holding_invalid_type",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "holding a type across an await point which is not allowed to be held as per the configuration",
      "what_it_does": "Allows users to configure types which should not be held across await\nsuspension points.",
      "why_bad": "There are some types which are perfectly safe to use concurrently from\na memory access perspective, but that will cause bugs at runtime if\nthey are held in such a way.",
      "example": "```toml\nawait-holding-invalid-types = [\n# You can specify a type name\n\"CustomLockType\",\n# You can (optionally) specify a reason\n{ path = \"OtherCustomLockType\", reason = \"Relies on a thread local\" }\n]\n```\n\n```no_run\n# async fn baz() {}\nstruct CustomLockType;\nstruct OtherCustomLockType;\nasync fn foo() {\nlet _x = CustomLockType;\nlet _y = OtherCustomLockType;\nbaz().await; // Lint violation\n}\n```",
      "version": "1.62.0",
      "source_file": "await_holding_invalid.rs",
      "embedding_text": "holding a type across an await point which is not allowed to be held as per the configuration\n\nAllows users to configure types which should not be held across await\nsuspension points.\n\nThere are some types which are perfectly safe to use concurrently from\na memory access perspective, but that will cause bugs at runtime if\nthey are held in such a way."
    },
    {
      "id": "clippy::blocks_in_conditions",
      "name": "BLOCKS_IN_CONDITIONS",
      "snake_name": "blocks_in_conditions",
      "category": "style",
      "weight": 0.95,
      "brief": "useless or complex blocks that can be eliminated in conditions",
      "what_it_does": "Checks for `if` and `match` conditions that use blocks containing an\nexpression, statements or conditions that use closures with blocks.",
      "why_bad": "Style, using blocks in the condition makes it hard to read.",
      "example": "```no_run\n# fn somefunc() -> bool { true };\nif { true } { /* ... */ }\n\nif { let x = somefunc(); x } { /* ... */ }\n\nmatch { let e = somefunc(); e } {\n// ...\n#   _ => {}\n}\n```\n\nUse instead:\n```no_run\n# fn somefunc() -> bool { true };\nif true { /* ... */ }\n\nlet res = { let x = somefunc(); x };\nif res { /* ... */ }\n\nlet res = { let e = somefunc(); e };\nmatch res {\n// ...\n#   _ => {}\n}\n```",
      "version": "1.45.0",
      "source_file": "blocks_in_conditions.rs",
      "embedding_text": "useless or complex blocks that can be eliminated in conditions\n\nChecks for `if` and `match` conditions that use blocks containing an\nexpression, statements or conditions that use closures with blocks.\n\nStyle, using blocks in the condition makes it hard to read."
    },
    {
      "id": "clippy::bool_assert_comparison",
      "name": "BOOL_ASSERT_COMPARISON",
      "snake_name": "bool_assert_comparison",
      "category": "style",
      "weight": 0.95,
      "brief": "Using a boolean as comparison value in an assert_* macro when there is no need",
      "what_it_does": "This lint warns about boolean comparisons in assert-like macros.",
      "why_bad": "It is shorter to use the equivalent.",
      "example": "```no_run\nassert_eq!(\"a\".is_empty(), false);\nassert_ne!(\"a\".is_empty(), true);\n```\n\nUse instead:\n```no_run\nassert!(!\"a\".is_empty());\n```",
      "version": "1.53.0",
      "source_file": "bool_assert_comparison.rs",
      "embedding_text": "Using a boolean as comparison value in an assert_* macro when there is no need\n\nThis lint warns about boolean comparisons in assert-like macros.\n\nIt is shorter to use the equivalent."
    },
    {
      "id": "clippy::bool_comparison",
      "name": "BOOL_COMPARISON",
      "snake_name": "bool_comparison",
      "category": "complexity",
      "weight": 1.0,
      "brief": "comparing a variable to a boolean, e.g., `if x == true` or `if x != true`",
      "what_it_does": "Checks for expressions of the form `x == true`,\n`x != true` and order comparisons such as `x < true` (or vice versa) and\nsuggest using the variable directly.",
      "why_bad": "Unnecessary code.",
      "example": "```rust,ignore\nif x == true {}\nif y == false {}\n```\nuse `x` directly:\n```rust,ignore\nif x {}\nif !y {}\n```",
      "version": "pre 1.29.0",
      "source_file": "bool_comparison.rs",
      "embedding_text": "comparing a variable to a boolean, e.g., `if x == true` or `if x != true`\n\nChecks for expressions of the form `x == true`,\n`x != true` and order comparisons such as `x < true` (or vice versa) and\nsuggest using the variable directly.\n\nUnnecessary code."
    },
    {
      "id": "clippy::bool_to_int_with_if",
      "name": "BOOL_TO_INT_WITH_IF",
      "snake_name": "bool_to_int_with_if",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "using if to convert bool to int",
      "what_it_does": "Instead of using an if statement to convert a bool to an int,\nthis lint suggests using a `from()` function or an `as` coercion.",
      "why_bad": "Coercion or `from()` is another way to convert bool to a number.\nBoth methods are guaranteed to return 1 for true, and 0 for false.\n\nSee https://doc.rust-lang.org/std/primitive.bool.html#impl-From%3Cbool%3E",
      "example": "```no_run\n# let condition = false;\nif condition {\n1_i64\n} else {\n0\n};\n```\nUse instead:\n```no_run\n# let condition = false;\ni64::from(condition);\n```\nor\n```no_run\n# let condition = false;\ncondition as i64;\n```",
      "version": "1.65.0",
      "source_file": "bool_to_int_with_if.rs",
      "embedding_text": "using if to convert bool to int\n\nInstead of using an if statement to convert a bool to an int,\nthis lint suggests using a `from()` function or an `as` coercion.\n\nCoercion or `from()` is another way to convert bool to a number.\nBoth methods are guaranteed to return 1 for true, and 0 for false.\n\nSee https://doc.rust-lang.org/std/primitive.bool.html#impl-From%3Cbool%3E"
    },
    {
      "id": "clippy::nonminimal_bool",
      "name": "NONMINIMAL_BOOL",
      "snake_name": "nonminimal_bool",
      "category": "complexity",
      "weight": 1.0,
      "brief": "boolean expressions that can be written more concisely",
      "what_it_does": "Checks for boolean expressions that can be written more\nconcisely.",
      "why_bad": "Readability of boolean expressions suffers from\nunnecessary duplication.",
      "example": "```ignore\nif a && true {}\nif !(a == b) {}\n```\n\nUse instead:\n```rust,ignore\nif a {}\nif a != b {}\n```",
      "version": "pre 1.29.0",
      "source_file": "booleans.rs",
      "embedding_text": "boolean expressions that can be written more concisely\n\nChecks for boolean expressions that can be written more\nconcisely.\n\nReadability of boolean expressions suffers from\nunnecessary duplication."
    },
    {
      "id": "clippy::overly_complex_bool_expr",
      "name": "OVERLY_COMPLEX_BOOL_EXPR",
      "snake_name": "overly_complex_bool_expr",
      "category": "correctness",
      "weight": 1.2,
      "brief": "boolean expressions that contain terminals which can be eliminated",
      "what_it_does": "Checks for boolean expressions that contain terminals that\ncan be eliminated.",
      "why_bad": "This is most likely a logic bug.",
      "example": "```rust,ignore\n// The `b` is unnecessary, the expression is equivalent to `if a`.\nif a && b || a { ... }\n```\n\nUse instead:\n```rust,ignore\nif a {}\n```",
      "version": "pre 1.29.0",
      "source_file": "booleans.rs",
      "embedding_text": "boolean expressions that contain terminals which can be eliminated\n\nChecks for boolean expressions that contain terminals that\ncan be eliminated.\n\nThis is most likely a logic bug."
    },
    {
      "id": "clippy::borrow_deref_ref",
      "name": "BORROW_DEREF_REF",
      "snake_name": "borrow_deref_ref",
      "category": "complexity",
      "weight": 1.0,
      "brief": "deref on an immutable reference returns the same type as itself",
      "what_it_does": "Checks for `&*(&T)`.",
      "why_bad": "Dereferencing and then borrowing a reference value has no effect in most cases.",
      "example": "```no_run\nlet s = &String::new();\n\nlet a: &String = &* s;\n```\n\nUse instead:\n```no_run\n# let s = &String::new();\nlet a: &String = s;\n```",
      "version": "1.63.0",
      "source_file": "borrow_deref_ref.rs",
      "embedding_text": "deref on an immutable reference returns the same type as itself\n\nChecks for `&*(&T)`.\n\nDereferencing and then borrowing a reference value has no effect in most cases."
    },
    {
      "id": "clippy::box_default",
      "name": "BOX_DEFAULT",
      "snake_name": "box_default",
      "category": "style",
      "weight": 0.95,
      "brief": "Using Box::new(T::default()) instead of Box::default()",
      "what_it_does": "checks for `Box::new(Default::default())`, which can be written as\n`Box::default()`.",
      "why_bad": "`Box::default()` is equivalent and more concise.",
      "example": "```no_run\nlet x: Box<String> = Box::new(Default::default());\n```\nUse instead:\n```no_run\nlet x: Box<String> = Box::default();\n```",
      "version": "1.66.0",
      "source_file": "box_default.rs",
      "embedding_text": "Using Box::new(T::default()) instead of Box::default()\n\nchecks for `Box::new(Default::default())`, which can be written as\n`Box::default()`.\n\n`Box::default()` is equivalent and more concise."
    },
    {
      "id": "clippy::byte_char_slices",
      "name": "BYTE_CHAR_SLICES",
      "snake_name": "byte_char_slices",
      "category": "style",
      "weight": 0.95,
      "brief": "hard to read byte char slice",
      "what_it_does": "Checks for hard to read slices of byte characters, that could be more easily expressed as a\nbyte string.",
      "why_bad": "Potentially makes the string harder to read.",
      "example": "```ignore\n&[b'H', b'e', b'l', b'l', b'o'];\n```\nUse instead:\n```ignore\nb\"Hello\"\n```",
      "version": "1.81.0",
      "source_file": "byte_char_slices.rs",
      "embedding_text": "hard to read byte char slice\n\nChecks for hard to read slices of byte characters, that could be more easily expressed as a\nbyte string.\n\nPotentially makes the string harder to read."
    },
    {
      "id": "clippy::cargo_common_metadata",
      "name": "CARGO_COMMON_METADATA",
      "snake_name": "cargo_common_metadata",
      "category": "cargo",
      "weight": 0.9,
      "brief": "common metadata is defined in `Cargo.toml`",
      "what_it_does": "Checks to see if all common metadata is defined in\n`Cargo.toml`. See: https://rust-lang-nursery.github.io/api-guidelines/documentation.html#cargotoml-includes-all-common-metadata-c-metadata",
      "why_bad": "It will be more difficult for users to discover the\npurpose of the crate, and key information related to it.",
      "example": "```toml\n# This `Cargo.toml` is missing a description field:\n[package]\nname = \"clippy\"\nversion = \"0.0.212\"\nrepository = \"https://github.com/rust-lang/rust-clippy\"\nreadme = \"README.md\"\nlicense = \"MIT OR Apache-2.0\"\nkeywords = [\"clippy\", \"lint\", \"plugin\"]\ncategories = [\"development-tools\", \"development-tools::cargo-plugins\"]\n```\n\nShould include a description field like:\n\n```toml\n# This `Cargo.toml` includes all common metadata\n[package]\nname = \"clippy\"\nversion = \"0.0.212\"\ndescription = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\nrepository = \"https://github.com/rust-lang/rust-clippy\"\nreadme = \"README.md\"\nlicense = \"MIT OR Apache-2.0\"\nkeywords = [\"clippy\", \"lint\", \"plugin\"]\ncategories = [\"development-tools\", \"development-tools::cargo-plugins\"]\n```",
      "version": "1.32.0",
      "source_file": "mod.rs",
      "embedding_text": "common metadata is defined in `Cargo.toml`\n\nChecks to see if all common metadata is defined in\n`Cargo.toml`. See: https://rust-lang-nursery.github.io/api-guidelines/documentation.html#cargotoml-includes-all-common-metadata-c-metadata\n\nIt will be more difficult for users to discover the\npurpose of the crate, and key information related to it."
    },
    {
      "id": "clippy::redundant_feature_names",
      "name": "REDUNDANT_FEATURE_NAMES",
      "snake_name": "redundant_feature_names",
      "category": "cargo",
      "weight": 0.9,
      "brief": "usage of a redundant feature name",
      "what_it_does": "Checks for feature names with prefix `use-`, `with-` or suffix `-support`",
      "why_bad": "These prefixes and suffixes have no significant meaning.",
      "example": "```toml\n# The `Cargo.toml` with feature name redundancy\n[features]\ndefault = [\"use-abc\", \"with-def\", \"ghi-support\"]\nuse-abc = []  // redundant\nwith-def = []   // redundant\nghi-support = []   // redundant\n```\n\nUse instead:\n```toml\n[features]\ndefault = [\"abc\", \"def\", \"ghi\"]\nabc = []\ndef = []\nghi = []\n```",
      "version": "1.57.0",
      "source_file": "mod.rs",
      "embedding_text": "usage of a redundant feature name\n\nChecks for feature names with prefix `use-`, `with-` or suffix `-support`\n\nThese prefixes and suffixes have no significant meaning."
    },
    {
      "id": "clippy::negative_feature_names",
      "name": "NEGATIVE_FEATURE_NAMES",
      "snake_name": "negative_feature_names",
      "category": "cargo",
      "weight": 0.9,
      "brief": "usage of a negative feature name",
      "what_it_does": "Checks for negative feature names with prefix `no-` or `not-`",
      "why_bad": "Features are supposed to be additive, and negatively-named features violate it.",
      "example": "```toml\n# The `Cargo.toml` with negative feature names\n[features]\ndefault = []\nno-abc = []\nnot-def = []\n\n```\nUse instead:\n```toml\n[features]\ndefault = [\"abc\", \"def\"]\nabc = []\ndef = []\n\n```",
      "version": "1.57.0",
      "source_file": "mod.rs",
      "embedding_text": "usage of a negative feature name\n\nChecks for negative feature names with prefix `no-` or `not-`\n\nFeatures are supposed to be additive, and negatively-named features violate it."
    },
    {
      "id": "clippy::multiple_crate_versions",
      "name": "MULTIPLE_CRATE_VERSIONS",
      "snake_name": "multiple_crate_versions",
      "category": "cargo",
      "weight": 0.9,
      "brief": "multiple versions of the same crate being used",
      "what_it_does": "Checks to see if multiple versions of a crate are being\nused.",
      "why_bad": "This bloats the size of targets, and can lead to\nconfusing error messages when structs or traits are used interchangeably\nbetween different versions of a crate.",
      "example": "```toml\n# This will pull in both winapi v0.3.x and v0.2.x, triggering a warning.\n[dependencies]\nctrlc = \"=3.1.0\"\nansi_term = \"=0.11.0\"\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "multiple versions of the same crate being used\n\nChecks to see if multiple versions of a crate are being\nused.\n\nThis bloats the size of targets, and can lead to\nconfusing error messages when structs or traits are used interchangeably\nbetween different versions of a crate."
    },
    {
      "id": "clippy::wildcard_dependencies",
      "name": "WILDCARD_DEPENDENCIES",
      "snake_name": "wildcard_dependencies",
      "category": "cargo",
      "weight": 0.9,
      "brief": "wildcard dependencies being used",
      "what_it_does": "Checks for wildcard dependencies in the `Cargo.toml`.",
      "why_bad": "[As the edition guide says](https://rust-lang-nursery.github.io/edition-guide/rust-2018/cargo-and-crates-io/crates-io-disallows-wildcard-dependencies.html),\nit is highly unlikely that you work with any possible version of your dependency,\nand wildcard dependencies would cause unnecessary breakage in the ecosystem.",
      "example": "```toml\n[dependencies]\nregex = \"*\"\n```\nUse instead:\n```toml\n[dependencies]\n# allow patch updates, but not minor or major version changes\nsome_crate_1 = \"~1.2.3\"\n\n# pin the version to a specific version\nsome_crate_2 = \"=1.2.3\"\n```",
      "version": "1.32.0",
      "source_file": "mod.rs",
      "embedding_text": "wildcard dependencies being used\n\nChecks for wildcard dependencies in the `Cargo.toml`.\n\n[As the edition guide says](https://rust-lang-nursery.github.io/edition-guide/rust-2018/cargo-and-crates-io/crates-io-disallows-wildcard-dependencies.html),\nit is highly unlikely that you work with any possible version of your dependency,\nand wildcard dependencies would cause unnecessary breakage in the ecosystem."
    },
    {
      "id": "clippy::lint_groups_priority",
      "name": "LINT_GROUPS_PRIORITY",
      "snake_name": "lint_groups_priority",
      "category": "correctness",
      "weight": 1.2,
      "brief": "a lint group in `Cargo.toml` at the same priority as a lint",
      "what_it_does": "Checks for lint groups with the same priority as lints in the `Cargo.toml`\n[`[lints]` table](https://doc.rust-lang.org/cargo/reference/manifest.html#the-lints-section).\n\nThis lint will be removed once [cargo#12918](https://github.com/rust-lang/cargo/issues/12918)\nis resolved.",
      "why_bad": "The order of lints in the `[lints]` is ignored, to have a lint override a group the\n`priority` field needs to be used, otherwise the sort order is undefined.",
      "example": "```toml\n# Passed as `--allow=clippy::similar_names --warn=clippy::pedantic`\n# which results in `similar_names` being `warn`\n[lints.clippy]\npedantic = \"warn\"\nsimilar_names = \"allow\"\n```\nUse instead:\n```toml\n# Passed as `--warn=clippy::pedantic --allow=clippy::similar_names`\n# which results in `similar_names` being `allow`\n[lints.clippy]\npedantic = { level = \"warn\", priority = -1 }\nsimilar_names = \"allow\"\n```",
      "version": "1.78.0",
      "source_file": "mod.rs",
      "embedding_text": "a lint group in `Cargo.toml` at the same priority as a lint\n\nChecks for lint groups with the same priority as lints in the `Cargo.toml`\n[`[lints]` table](https://doc.rust-lang.org/cargo/reference/manifest.html#the-lints-section).\n\nThis lint will be removed once [cargo#12918](https://github.com/rust-lang/cargo/issues/12918)\nis resolved.\n\nThe order of lints in the `[lints]` is ignored, to have a lint override a group the\n`priority` field needs to be used, otherwise the sort order is undefined."
    },
    {
      "id": "clippy::cast_precision_loss",
      "name": "CAST_PRECISION_LOSS",
      "snake_name": "cast_precision_loss",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "casts that cause loss of precision, e.g., `x as f32` where `x: u64`",
      "what_it_does": "Checks for casts from any numeric type to a float type where\nthe receiving type cannot store all values from the original type without\nrounding errors. This possible rounding is to be expected, so this lint is\n`Allow` by default.\n\nBasically, this warns on casting any integer with 32 or more bits to `f32`\nor any 64-bit integer to `f64`.",
      "why_bad": "It's not bad at all. But in some applications it can be\nhelpful to know where precision loss can take place. This lint can help find\nthose places in the code.",
      "example": "```no_run\nlet x = u64::MAX;\nx as f64;\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "casts that cause loss of precision, e.g., `x as f32` where `x: u64`\n\nChecks for casts from any numeric type to a float type where\nthe receiving type cannot store all values from the original type without\nrounding errors. This possible rounding is to be expected, so this lint is\n`Allow` by default.\n\nBasically, this warns on casting any integer with 32 or more bits to `f32`\nor any 64-bit integer to `f64`.\n\nIt's not bad at all. But in some applications it can be\nhelpful to know where precision loss can take place. This lint can help find\nthose places in the code."
    },
    {
      "id": "clippy::cast_sign_loss",
      "name": "CAST_SIGN_LOSS",
      "snake_name": "cast_sign_loss",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "casts from signed types to unsigned types, e.g., `x as u32` where `x: i32`",
      "what_it_does": "Checks for casts from a signed to an unsigned numeric\ntype. In this case, negative values wrap around to large positive values,\nwhich can be quite surprising in practice. However, since the cast works as\ndefined, this lint is `Allow` by default.",
      "why_bad": "Possibly surprising results. You can activate this lint\nas a one-time check to see where numeric wrapping can arise.",
      "example": "```no_run\nlet y: i8 = -1;\ny as u64; // will return 18446744073709551615\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "casts from signed types to unsigned types, e.g., `x as u32` where `x: i32`\n\nChecks for casts from a signed to an unsigned numeric\ntype. In this case, negative values wrap around to large positive values,\nwhich can be quite surprising in practice. However, since the cast works as\ndefined, this lint is `Allow` by default.\n\nPossibly surprising results. You can activate this lint\nas a one-time check to see where numeric wrapping can arise."
    },
    {
      "id": "clippy::cast_possible_truncation",
      "name": "CAST_POSSIBLE_TRUNCATION",
      "snake_name": "cast_possible_truncation",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "casts that may cause truncation of the value, e.g., `x as u8` where `x: u32`, or `x as i32` where `x: f32`",
      "what_it_does": "Checks for casts between numeric types that may\ntruncate large values. This is expected behavior, so the cast is `Allow` by\ndefault. It suggests user either explicitly ignore the lint,\nor use `try_from()` and handle the truncation, default, or panic explicitly.",
      "why_bad": "In some problem domains, it is good practice to avoid\ntruncation. This lint can be activated to help assess where additional\nchecks could be beneficial.",
      "example": "```no_run\nfn as_u8(x: u64) -> u8 {\nx as u8\n}\n```\nUse instead:\n```no_run\nfn as_u8(x: u64) -> u8 {\nif let Ok(x) = u8::try_from(x) {\nx\n} else {\ntodo!();\n}\n}\n// Or\n#[allow(clippy::cast_possible_truncation)]\nfn as_u16(x: u64) -> u16 {\nx as u16\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "casts that may cause truncation of the value, e.g., `x as u8` where `x: u32`, or `x as i32` where `x: f32`\n\nChecks for casts between numeric types that may\ntruncate large values. This is expected behavior, so the cast is `Allow` by\ndefault. It suggests user either explicitly ignore the lint,\nor use `try_from()` and handle the truncation, default, or panic explicitly.\n\nIn some problem domains, it is good practice to avoid\ntruncation. This lint can be activated to help assess where additional\nchecks could be beneficial."
    },
    {
      "id": "clippy::cast_possible_wrap",
      "name": "CAST_POSSIBLE_WRAP",
      "snake_name": "cast_possible_wrap",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "casts that may cause wrapping around the value, e.g., `x as i32` where `x: u32` and `x > i32::MAX`",
      "what_it_does": "Checks for casts from an unsigned type to a signed type of\nthe same size, or possibly smaller due to target-dependent integers.\nPerforming such a cast is a no-op for the compiler (that is, nothing is\nchanged at the bit level), and the binary representation of the value is\nreinterpreted. This can cause wrapping if the value is too big\nfor the target signed type. However, the cast works as defined, so this lint\nis `Allow` by default.",
      "why_bad": "While such a cast is not bad in itself, the results can\nbe surprising when this is not the intended behavior:",
      "example": "```no_run\nlet _ = u32::MAX as i32; // will yield a value of `-1`\n```\n\nUse instead:\n```no_run\nlet _ = i32::try_from(u32::MAX).ok();\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "casts that may cause wrapping around the value, e.g., `x as i32` where `x: u32` and `x > i32::MAX`\n\nChecks for casts from an unsigned type to a signed type of\nthe same size, or possibly smaller due to target-dependent integers.\nPerforming such a cast is a no-op for the compiler (that is, nothing is\nchanged at the bit level), and the binary representation of the value is\nreinterpreted. This can cause wrapping if the value is too big\nfor the target signed type. However, the cast works as defined, so this lint\nis `Allow` by default.\n\nWhile such a cast is not bad in itself, the results can\nbe surprising when this is not the intended behavior:"
    },
    {
      "id": "clippy::cast_lossless",
      "name": "CAST_LOSSLESS",
      "snake_name": "cast_lossless",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "casts using `as` that are known to be lossless, e.g., `x as u64` where `x: u8`",
      "what_it_does": "Checks for casts between numeric types that can be replaced by safe\nconversion functions.",
      "why_bad": "Rust's `as` keyword will perform many kinds of conversions, including\nsilently lossy conversions. Conversion functions such as `i32::from`\nwill only perform lossless conversions. Using the conversion functions\nprevents conversions from becoming silently lossy if the input types\never change, and makes it clear for people reading the code that the\nconversion is lossless.",
      "example": "```no_run\nfn as_u64(x: u8) -> u64 {\nx as u64\n}\n```\n\nUsing `::from` would look like this:\n\n```no_run\nfn as_u64(x: u8) -> u64 {\nu64::from(x)\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "casts using `as` that are known to be lossless, e.g., `x as u64` where `x: u8`\n\nChecks for casts between numeric types that can be replaced by safe\nconversion functions.\n\nRust's `as` keyword will perform many kinds of conversions, including\nsilently lossy conversions. Conversion functions such as `i32::from`\nwill only perform lossless conversions. Using the conversion functions\nprevents conversions from becoming silently lossy if the input types\never change, and makes it clear for people reading the code that the\nconversion is lossless."
    },
    {
      "id": "clippy::unnecessary_cast",
      "name": "UNNECESSARY_CAST",
      "snake_name": "unnecessary_cast",
      "category": "complexity",
      "weight": 1.0,
      "brief": "cast to the same type, e.g., `x as i32` where `x: i32`",
      "what_it_does": "Checks for casts to the same type, casts of int literals to integer\ntypes, casts of float literals to float types, and casts between raw\npointers that don't change type or constness.",
      "why_bad": "It's just unnecessary.",
      "example": "```no_run\nlet _ = 2i32 as i32;\nlet _ = 0.5 as f32;\n```\n\nBetter:\n\n```no_run\nlet _ = 2_i32;\nlet _ = 0.5_f32;\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "cast to the same type, e.g., `x as i32` where `x: i32`\n\nChecks for casts to the same type, casts of int literals to integer\ntypes, casts of float literals to float types, and casts between raw\npointers that don't change type or constness.\n\nIt's just unnecessary."
    },
    {
      "id": "clippy::cast_ptr_alignment",
      "name": "CAST_PTR_ALIGNMENT",
      "snake_name": "cast_ptr_alignment",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "cast from a pointer to a more strictly aligned pointer",
      "what_it_does": "Checks for casts, using `as` or `pointer::cast`, from a\nless strictly aligned pointer to a more strictly aligned pointer.",
      "why_bad": "Dereferencing the resulting pointer may be undefined behavior.",
      "example": "```no_run\nlet _ = (&1u8 as *const u8) as *const u16;\nlet _ = (&mut 1u8 as *mut u8) as *mut u16;\n\n(&1u8 as *const u8).cast::<u16>();\n(&mut 1u8 as *mut u8).cast::<u16>();\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "cast from a pointer to a more strictly aligned pointer\n\nChecks for casts, using `as` or `pointer::cast`, from a\nless strictly aligned pointer to a more strictly aligned pointer.\n\nDereferencing the resulting pointer may be undefined behavior."
    },
    {
      "id": "clippy::fn_to_numeric_cast",
      "name": "FN_TO_NUMERIC_CAST",
      "snake_name": "fn_to_numeric_cast",
      "category": "style",
      "weight": 0.95,
      "brief": "casting a function pointer to a numeric type other than `usize`",
      "what_it_does": "Checks for casts of function pointers to something other than `usize`.",
      "why_bad": "Casting a function pointer to anything other than `usize`/`isize` is\nnot portable across architectures. If the target type is too small the\naddress would be truncated, and target types larger than `usize` are\nunnecessary.\n\nCasting to `isize` also doesn't make sense, since addresses are never\nsigned.",
      "example": "```no_run\nfn fun() -> i32 { 1 }\nlet _ = fun as i64;\n```\n\nUse instead:\n```no_run\n# fn fun() -> i32 { 1 }\nlet _ = fun as usize;\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "casting a function pointer to a numeric type other than `usize`\n\nChecks for casts of function pointers to something other than `usize`.\n\nCasting a function pointer to anything other than `usize`/`isize` is\nnot portable across architectures. If the target type is too small the\naddress would be truncated, and target types larger than `usize` are\nunnecessary.\n\nCasting to `isize` also doesn't make sense, since addresses are never\nsigned."
    },
    {
      "id": "clippy::fn_to_numeric_cast_with_truncation",
      "name": "FN_TO_NUMERIC_CAST_WITH_TRUNCATION",
      "snake_name": "fn_to_numeric_cast_with_truncation",
      "category": "style",
      "weight": 0.95,
      "brief": "casting a function pointer to a numeric type not wide enough to store the address",
      "what_it_does": "Checks for casts of a function pointer to a numeric type not wide enough to\nstore an address.",
      "why_bad": "Such a cast discards some bits of the function's address. If this is intended, it would be more\nclearly expressed by casting to `usize` first, then casting the `usize` to the intended type (with\na comment) to perform the truncation.",
      "example": "```no_run\nfn fn1() -> i16 {\n1\n};\nlet _ = fn1 as i32;\n```\n\nUse instead:\n```no_run\n// Cast to usize first, then comment with the reason for the truncation\nfn fn1() -> i16 {\n1\n};\nlet fn_ptr = fn1 as usize;\nlet fn_ptr_truncated = fn_ptr as i32;\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "casting a function pointer to a numeric type not wide enough to store the address\n\nChecks for casts of a function pointer to a numeric type not wide enough to\nstore an address.\n\nSuch a cast discards some bits of the function's address. If this is intended, it would be more\nclearly expressed by casting to `usize` first, then casting the `usize` to the intended type (with\na comment) to perform the truncation."
    },
    {
      "id": "clippy::fn_to_numeric_cast_any",
      "name": "FN_TO_NUMERIC_CAST_ANY",
      "snake_name": "fn_to_numeric_cast_any",
      "category": "restriction",
      "weight": 1.0,
      "brief": "casting a function pointer to any integer type",
      "what_it_does": "Checks for casts of a function pointer to any integer type.",
      "why_bad": "Casting a function pointer to an integer can have surprising results and can occur\naccidentally if parentheses are omitted from a function call. If you aren't doing anything\nlow-level with function pointers then you can opt out of casting functions to integers in\norder to avoid mistakes. Alternatively, you can use this lint to audit all uses of function\npointer casts in your code.",
      "example": "```no_run\n// fn1 is cast as `usize`\nfn fn1() -> u16 {\n1\n};\nlet _ = fn1 as usize;\n```\n\nUse instead:\n```no_run\n// maybe you intended to call the function?\nfn fn2() -> u16 {\n1\n};\nlet _ = fn2() as usize;\n\n// or\n\n// maybe you intended to cast it to a function type?\nfn fn3() -> u16 {\n1\n}\nlet _ = fn3 as fn() -> u16;\n```",
      "version": "1.58.0",
      "source_file": "mod.rs",
      "embedding_text": "casting a function pointer to any integer type\n\nChecks for casts of a function pointer to any integer type.\n\nCasting a function pointer to an integer can have surprising results and can occur\naccidentally if parentheses are omitted from a function call. If you aren't doing anything\nlow-level with function pointers then you can opt out of casting functions to integers in\norder to avoid mistakes. Alternatively, you can use this lint to audit all uses of function\npointer casts in your code."
    },
    {
      "id": "clippy::char_lit_as_u8",
      "name": "CHAR_LIT_AS_U8",
      "snake_name": "char_lit_as_u8",
      "category": "complexity",
      "weight": 1.0,
      "brief": "casting a character literal to `u8` truncates",
      "what_it_does": "Checks for expressions where a character literal is cast\nto `u8` and suggests using a byte literal instead.",
      "why_bad": "In general, casting values to smaller types is\nerror-prone and should be avoided where possible. In the particular case of\nconverting a character literal to `u8`, it is easy to avoid by just using a\nbyte literal instead. As an added bonus, `b'a'` is also slightly shorter\nthan `'a' as u8`.",
      "example": "```rust,ignore\n'x' as u8\n```\n\nA better version, using the byte literal:\n\n```rust,ignore\nb'x'\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "casting a character literal to `u8` truncates\n\nChecks for expressions where a character literal is cast\nto `u8` and suggests using a byte literal instead.\n\nIn general, casting values to smaller types is\nerror-prone and should be avoided where possible. In the particular case of\nconverting a character literal to `u8`, it is easy to avoid by just using a\nbyte literal instead. As an added bonus, `b'a'` is also slightly shorter\nthan `'a' as u8`."
    },
    {
      "id": "clippy::ptr_as_ptr",
      "name": "PTR_AS_PTR",
      "snake_name": "ptr_as_ptr",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "casting using `as` between raw pointers that doesn't change their constness, where `pointer::cast` could take the place of `as`",
      "what_it_does": "Checks for `as` casts between raw pointers that don't change their\nconstness, namely `*const T` to `*const U` and `*mut T` to `*mut U`.",
      "why_bad": "Though `as` casts between raw pointers are not terrible,\n`pointer::cast` is safer because it cannot accidentally change the\npointer's mutability, nor cast the pointer to other types like `usize`.",
      "example": "```no_run\nlet ptr: *const u32 = &42_u32;\nlet mut_ptr: *mut u32 = &mut 42_u32;\nlet _ = ptr as *const i32;\nlet _ = mut_ptr as *mut i32;\n```\nUse instead:\n```no_run\nlet ptr: *const u32 = &42_u32;\nlet mut_ptr: *mut u32 = &mut 42_u32;\nlet _ = ptr.cast::<i32>();\nlet _ = mut_ptr.cast::<i32>();\n```",
      "version": "1.51.0",
      "source_file": "mod.rs",
      "embedding_text": "casting using `as` between raw pointers that doesn't change their constness, where `pointer::cast` could take the place of `as`\n\nChecks for `as` casts between raw pointers that don't change their\nconstness, namely `*const T` to `*const U` and `*mut T` to `*mut U`.\n\nThough `as` casts between raw pointers are not terrible,\n`pointer::cast` is safer because it cannot accidentally change the\npointer's mutability, nor cast the pointer to other types like `usize`."
    },
    {
      "id": "clippy::ptr_cast_constness",
      "name": "PTR_CAST_CONSTNESS",
      "snake_name": "ptr_cast_constness",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "casting using `as` on raw pointers to change constness when specialized methods apply",
      "what_it_does": "Checks for `as` casts between raw pointers that change their constness, namely `*const T` to\n`*mut T` and `*mut T` to `*const T`.",
      "why_bad": "Though `as` casts between raw pointers are not terrible, `pointer::cast_mut` and\n`pointer::cast_const` are safer because they cannot accidentally cast the pointer to another\ntype. Or, when null pointers are involved, `null()` and `null_mut()` can be used directly.",
      "example": "```no_run\nlet ptr: *const u32 = &42_u32;\nlet mut_ptr = ptr as *mut u32;\nlet ptr = mut_ptr as *const u32;\nlet ptr1 = std::ptr::null::<u32>() as *mut u32;\nlet ptr2 = std::ptr::null_mut::<u32>() as *const u32;\nlet ptr3 = std::ptr::null::<u32>().cast_mut();\nlet ptr4 = std::ptr::null_mut::<u32>().cast_const();\n```\nUse instead:\n```no_run\nlet ptr: *const u32 = &42_u32;\nlet mut_ptr = ptr.cast_mut();\nlet ptr = mut_ptr.cast_const();\nlet ptr1 = std::ptr::null_mut::<u32>();\nlet ptr2 = std::ptr::null::<u32>();\nlet ptr3 = std::ptr::null_mut::<u32>();\nlet ptr4 = std::ptr::null::<u32>();\n```",
      "version": "1.72.0",
      "source_file": "mod.rs",
      "embedding_text": "casting using `as` on raw pointers to change constness when specialized methods apply\n\nChecks for `as` casts between raw pointers that change their constness, namely `*const T` to\n`*mut T` and `*mut T` to `*const T`.\n\nThough `as` casts between raw pointers are not terrible, `pointer::cast_mut` and\n`pointer::cast_const` are safer because they cannot accidentally cast the pointer to another\ntype. Or, when null pointers are involved, `null()` and `null_mut()` can be used directly."
    },
    {
      "id": "clippy::cast_enum_truncation",
      "name": "CAST_ENUM_TRUNCATION",
      "snake_name": "cast_enum_truncation",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "casts from an enum type to an integral type that will truncate the value",
      "what_it_does": "Checks for casts from an enum type to an integral type that will definitely truncate the\nvalue.",
      "why_bad": "The resulting integral value will not match the value of the variant it came from.",
      "example": "```no_run\nenum E { X = 256 };\nlet _ = E::X as u8;\n```",
      "version": "1.61.0",
      "source_file": "mod.rs",
      "embedding_text": "casts from an enum type to an integral type that will truncate the value\n\nChecks for casts from an enum type to an integral type that will definitely truncate the\nvalue.\n\nThe resulting integral value will not match the value of the variant it came from."
    },
    {
      "id": "clippy::cast_slice_different_sizes",
      "name": "CAST_SLICE_DIFFERENT_SIZES",
      "snake_name": "cast_slice_different_sizes",
      "category": "correctness",
      "weight": 1.2,
      "brief": "casting using `as` between raw pointers to slices of types with different sizes",
      "what_it_does": "Checks for `as` casts between raw pointers to slices with differently sized elements.",
      "why_bad": "The produced raw pointer to a slice does not update its length metadata. The produced\npointer will point to a different number of bytes than the original pointer because the\nlength metadata of a raw slice pointer is in elements rather than bytes.\nProducing a slice reference from the raw pointer will either create a slice with\nless data (which can be surprising) or create a slice with more data and cause Undefined Behavior.",
      "example": "// Missing data\n```no_run\nlet a = [1_i32, 2, 3, 4];\nlet p = &a as *const [i32] as *const [u8];\nunsafe {\nprintln!(\"{:?}\", &*p);\n}\n```\n// Undefined Behavior (note: also potential alignment issues)\n```no_run\nlet a = [1_u8, 2, 3, 4];\nlet p = &a as *const [u8] as *const [u32];\nunsafe {\nprintln!(\"{:?}\", &*p);\n}\n```\nInstead use `ptr::slice_from_raw_parts` to construct a slice from a data pointer and the correct length\n```no_run\nlet a = [1_i32, 2, 3, 4];\nlet old_ptr = &a as *const [i32];\n// The data pointer is cast to a pointer to the target `u8` not `[u8]`\n// The length comes from the known length of 4 i32s times the 4 bytes per i32\nlet new_ptr = core::ptr::slice_from_raw_parts(old_ptr as *const u8, 16);\nunsafe {\nprintln!(\"{:?}\", &*new_ptr);\n}\n```",
      "version": "1.61.0",
      "source_file": "mod.rs",
      "embedding_text": "casting using `as` between raw pointers to slices of types with different sizes\n\nChecks for `as` casts between raw pointers to slices with differently sized elements.\n\nThe produced raw pointer to a slice does not update its length metadata. The produced\npointer will point to a different number of bytes than the original pointer because the\nlength metadata of a raw slice pointer is in elements rather than bytes.\nProducing a slice reference from the raw pointer will either create a slice with\nless data (which can be surprising) or create a slice with more data and cause Undefined Behavior."
    },
    {
      "id": "clippy::cast_enum_constructor",
      "name": "CAST_ENUM_CONSTRUCTOR",
      "snake_name": "cast_enum_constructor",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "casts from an enum tuple constructor to an integer",
      "what_it_does": "Checks for casts from an enum tuple constructor to an integer.",
      "why_bad": "The cast is easily confused with casting a c-like enum value to an integer.",
      "example": "```no_run\nenum E { X(i32) };\nlet _ = E::X as usize;\n```",
      "version": "1.61.0",
      "source_file": "mod.rs",
      "embedding_text": "casts from an enum tuple constructor to an integer\n\nChecks for casts from an enum tuple constructor to an integer.\n\nThe cast is easily confused with casting a c-like enum value to an integer."
    },
    {
      "id": "clippy::cast_abs_to_unsigned",
      "name": "CAST_ABS_TO_UNSIGNED",
      "snake_name": "cast_abs_to_unsigned",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "casting the result of `abs()` to an unsigned integer can panic",
      "what_it_does": "Checks for usage of the `abs()` method that cast the result to unsigned.",
      "why_bad": "The `unsigned_abs()` method avoids panic when called on the MIN value.",
      "example": "```no_run\nlet x: i32 = -42;\nlet y: u32 = x.abs() as u32;\n```\nUse instead:\n```no_run\nlet x: i32 = -42;\nlet y: u32 = x.unsigned_abs();\n```",
      "version": "1.62.0",
      "source_file": "mod.rs",
      "embedding_text": "casting the result of `abs()` to an unsigned integer can panic\n\nChecks for usage of the `abs()` method that cast the result to unsigned.\n\nThe `unsigned_abs()` method avoids panic when called on the MIN value."
    },
    {
      "id": "clippy::as_underscore",
      "name": "AS_UNDERSCORE",
      "snake_name": "as_underscore",
      "category": "restriction",
      "weight": 1.0,
      "brief": "detects `as _` conversion",
      "what_it_does": "Checks for the usage of `as _` conversion using inferred type.",
      "why_bad": "The conversion might include lossy conversion or a dangerous cast that might go\nundetected due to the type being inferred.\n\nThe lint is allowed by default as using `_` is less wordy than always specifying the type.",
      "example": "```no_run\nfn foo(n: usize) {}\nlet n: u16 = 256;\nfoo(n as _);\n```\nUse instead:\n```no_run\nfn foo(n: usize) {}\nlet n: u16 = 256;\nfoo(n as usize);\n```",
      "version": "1.63.0",
      "source_file": "mod.rs",
      "embedding_text": "detects `as _` conversion\n\nChecks for the usage of `as _` conversion using inferred type.\n\nThe conversion might include lossy conversion or a dangerous cast that might go\nundetected due to the type being inferred.\n\nThe lint is allowed by default as using `_` is less wordy than always specifying the type."
    },
    {
      "id": "clippy::borrow_as_ptr",
      "name": "BORROW_AS_PTR",
      "snake_name": "borrow_as_ptr",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "borrowing just to cast to a raw pointer",
      "what_it_does": "Checks for the usage of `&expr as *const T` or\n`&mut expr as *mut T`, and suggest using `&raw const` or\n`&raw mut` instead.",
      "why_bad": "This would improve readability and avoid creating a reference\nthat points to an uninitialized value or unaligned place.\nRead the `&raw` explanation in the Reference for more information.",
      "example": "```no_run\nlet val = 1;\nlet p = &val as *const i32;\n\nlet mut val_mut = 1;\nlet p_mut = &mut val_mut as *mut i32;\n```\nUse instead:\n```no_run\nlet val = 1;\nlet p = &raw const val;\n\nlet mut val_mut = 1;\nlet p_mut = &raw mut val_mut;\n```",
      "version": "1.60.0",
      "source_file": "mod.rs",
      "embedding_text": "borrowing just to cast to a raw pointer\n\nChecks for the usage of `&expr as *const T` or\n`&mut expr as *mut T`, and suggest using `&raw const` or\n`&raw mut` instead.\n\nThis would improve readability and avoid creating a reference\nthat points to an uninitialized value or unaligned place.\nRead the `&raw` explanation in the Reference for more information."
    },
    {
      "id": "clippy::cast_slice_from_raw_parts",
      "name": "CAST_SLICE_FROM_RAW_PARTS",
      "snake_name": "cast_slice_from_raw_parts",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "casting a slice created from a pointer and length to a slice pointer",
      "what_it_does": "Checks for a raw slice being cast to a slice pointer",
      "why_bad": "This can result in multiple `&mut` references to the same location when only a pointer is\nrequired.\n`ptr::slice_from_raw_parts` is a safe alternative that doesn't require\nthe same [safety requirements] to be upheld.",
      "example": "```rust,ignore\nlet _: *const [u8] = std::slice::from_raw_parts(ptr, len) as *const _;\nlet _: *mut [u8] = std::slice::from_raw_parts_mut(ptr, len) as *mut _;\n```\nUse instead:\n```rust,ignore\nlet _: *const [u8] = std::ptr::slice_from_raw_parts(ptr, len);\nlet _: *mut [u8] = std::ptr::slice_from_raw_parts_mut(ptr, len);\n```\n[safety requirements]: https://doc.rust-lang.org/std/slice/fn.from_raw_parts.html#safety",
      "version": "1.65.0",
      "source_file": "mod.rs",
      "embedding_text": "casting a slice created from a pointer and length to a slice pointer\n\nChecks for a raw slice being cast to a slice pointer\n\nThis can result in multiple `&mut` references to the same location when only a pointer is\nrequired.\n`ptr::slice_from_raw_parts` is a safe alternative that doesn't require\nthe same [safety requirements] to be upheld."
    },
    {
      "id": "clippy::as_ptr_cast_mut",
      "name": "AS_PTR_CAST_MUT",
      "snake_name": "as_ptr_cast_mut",
      "category": "nursery",
      "weight": 0.9,
      "brief": "casting the result of the `&self`-taking `as_ptr` to a mutable pointer",
      "what_it_does": "Checks for the result of a `&self`-taking `as_ptr` being cast to a mutable pointer.",
      "why_bad": "Since `as_ptr` takes a `&self`, the pointer won't have write permissions unless interior\nmutability is used, making it unlikely that having it as a mutable pointer is correct.",
      "example": "```no_run\nlet mut vec = Vec::<u8>::with_capacity(1);\nlet ptr = vec.as_ptr() as *mut u8;\nunsafe { ptr.write(4) }; // UNDEFINED BEHAVIOUR\n```\nUse instead:\n```no_run\nlet mut vec = Vec::<u8>::with_capacity(1);\nlet ptr = vec.as_mut_ptr();\nunsafe { ptr.write(4) };\n```",
      "version": "1.66.0",
      "source_file": "mod.rs",
      "embedding_text": "casting the result of the `&self`-taking `as_ptr` to a mutable pointer\n\nChecks for the result of a `&self`-taking `as_ptr` being cast to a mutable pointer.\n\nSince `as_ptr` takes a `&self`, the pointer won't have write permissions unless interior\nmutability is used, making it unlikely that having it as a mutable pointer is correct."
    },
    {
      "id": "clippy::cast_nan_to_int",
      "name": "CAST_NAN_TO_INT",
      "snake_name": "cast_nan_to_int",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "casting a known floating-point NaN into an integer",
      "what_it_does": "Checks for a known NaN float being cast to an integer",
      "why_bad": "NaNs are cast into zero, so one could simply use this and make the\ncode more readable. The lint could also hint at a programmer error.",
      "example": "```rust,ignore\nlet _ = (0.0_f32 / 0.0) as u64;\n```\nUse instead:\n```rust,ignore\nlet _ = 0_u64;\n```",
      "version": "1.66.0",
      "source_file": "mod.rs",
      "embedding_text": "casting a known floating-point NaN into an integer\n\nChecks for a known NaN float being cast to an integer\n\nNaNs are cast into zero, so one could simply use this and make the\ncode more readable. The lint could also hint at a programmer error."
    },
    {
      "id": "clippy::zero_ptr",
      "name": "ZERO_PTR",
      "snake_name": "zero_ptr",
      "category": "style",
      "weight": 0.95,
      "brief": "using `0 as *{const, mut} T`",
      "what_it_does": "Catch casts from `0` to some pointer type",
      "why_bad": "This generally means `null` and is better expressed as\n{`std`, `core`}`::ptr::`{`null`, `null_mut`}.",
      "example": "```no_run\nlet a = 0 as *const u32;\n```\n\nUse instead:\n```no_run\nlet a = std::ptr::null::<u32>();\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "using `0 as *{const, mut} T`\n\nCatch casts from `0` to some pointer type\n\nThis generally means `null` and is better expressed as\n{`std`, `core`}`::ptr::`{`null`, `null_mut`}."
    },
    {
      "id": "clippy::ref_as_ptr",
      "name": "REF_AS_PTR",
      "snake_name": "ref_as_ptr",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "using `as` to cast a reference to pointer",
      "what_it_does": "Checks for casts of references to pointer using `as`\nand suggests `std::ptr::from_ref` and `std::ptr::from_mut` instead.",
      "why_bad": "Using `as` casts may result in silently changing mutability or type.",
      "example": "```no_run\nlet a_ref = &1;\nlet a_ptr = a_ref as *const _;\n```\nUse instead:\n```no_run\nlet a_ref = &1;\nlet a_ptr = std::ptr::from_ref(a_ref);\n```",
      "version": "1.78.0",
      "source_file": "mod.rs",
      "embedding_text": "using `as` to cast a reference to pointer\n\nChecks for casts of references to pointer using `as`\nand suggests `std::ptr::from_ref` and `std::ptr::from_mut` instead.\n\nUsing `as` casts may result in silently changing mutability or type."
    },
    {
      "id": "clippy::as_pointer_underscore",
      "name": "AS_POINTER_UNDERSCORE",
      "snake_name": "as_pointer_underscore",
      "category": "restriction",
      "weight": 1.0,
      "brief": "detects `as *mut _` and `as *const _` conversion",
      "what_it_does": "Checks for the usage of `as *const _` or `as *mut _` conversion using inferred type.",
      "why_bad": "The conversion might include a dangerous cast that might go undetected due to the type being inferred.",
      "example": "```no_run\nfn as_usize<T>(t: &T) -> usize {\n// BUG: `t` is already a reference, so we will here\n// return a dangling pointer to a temporary value instead\n&t as *const _ as usize\n}\n```\nUse instead:\n```no_run\nfn as_usize<T>(t: &T) -> usize {\nt as *const T as usize\n}\n```",
      "version": "1.85.0",
      "source_file": "mod.rs",
      "embedding_text": "detects `as *mut _` and `as *const _` conversion\n\nChecks for the usage of `as *const _` or `as *mut _` conversion using inferred type.\n\nThe conversion might include a dangerous cast that might go undetected due to the type being inferred."
    },
    {
      "id": "clippy::manual_dangling_ptr",
      "name": "MANUAL_DANGLING_PTR",
      "snake_name": "manual_dangling_ptr",
      "category": "style",
      "weight": 0.95,
      "brief": "casting small constant literals to pointers to create dangling pointers",
      "what_it_does": "Checks for casts of small constant literals or `mem::align_of` results to raw pointers.",
      "why_bad": "This creates a dangling pointer and is better expressed as\n{`std`, `core`}`::ptr::`{`dangling`, `dangling_mut`}.",
      "example": "```no_run\nlet ptr = 4 as *const u32;\nlet aligned = std::mem::align_of::<u32>() as *const u32;\nlet mut_ptr: *mut i64 = 8 as *mut _;\n```\nUse instead:\n```no_run\nlet ptr = std::ptr::dangling::<u32>();\nlet aligned = std::ptr::dangling::<u32>();\nlet mut_ptr: *mut i64 = std::ptr::dangling_mut();\n```",
      "version": "1.88.0",
      "source_file": "mod.rs",
      "embedding_text": "casting small constant literals to pointers to create dangling pointers\n\nChecks for casts of small constant literals or `mem::align_of` results to raw pointers.\n\nThis creates a dangling pointer and is better expressed as\n{`std`, `core`}`::ptr::`{`dangling`, `dangling_mut`}."
    },
    {
      "id": "clippy::confusing_method_to_numeric_cast",
      "name": "CONFUSING_METHOD_TO_NUMERIC_CAST",
      "snake_name": "confusing_method_to_numeric_cast",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "casting a primitive method pointer to any integer type",
      "what_it_does": "Checks for casts of a primitive method pointer like `max`/`min` to any integer type.",
      "why_bad": "Casting a function pointer to an integer can have surprising results and can occur\naccidentally if parentheses are omitted from a function call. If you aren't doing anything\nlow-level with function pointers then you can opt out of casting functions to integers in\norder to avoid mistakes. Alternatively, you can use this lint to audit all uses of function\npointer casts in your code.",
      "example": "```no_run\nlet _ = u16::max as usize;\n```\n\nUse instead:\n```no_run\nlet _ = u16::MAX as usize;\n```",
      "version": "1.89.0",
      "source_file": "mod.rs",
      "embedding_text": "casting a primitive method pointer to any integer type\n\nChecks for casts of a primitive method pointer like `max`/`min` to any integer type.\n\nCasting a function pointer to an integer can have surprising results and can occur\naccidentally if parentheses are omitted from a function call. If you aren't doing anything\nlow-level with function pointers then you can opt out of casting functions to integers in\norder to avoid mistakes. Alternatively, you can use this lint to audit all uses of function\npointer casts in your code."
    },
    {
      "id": "clippy::needless_type_cast",
      "name": "NEEDLESS_TYPE_CAST",
      "snake_name": "needless_type_cast",
      "category": "nursery",
      "weight": 0.9,
      "brief": "binding defined with one type but always cast to another",
      "what_it_does": "Checks for bindings (constants, statics, or let bindings) that are defined\nwith one numeric type but are consistently cast to a different type in all usages.",
      "why_bad": "If a binding is always cast to a different type when used, it would be clearer\nand more efficient to define it with the target type from the start.",
      "example": "```no_run\nconst SIZE: u16 = 15;\nlet arr: [u8; SIZE as usize] = [0; SIZE as usize];\n```\n\nUse instead:\n```no_run\nconst SIZE: usize = 15;\nlet arr: [u8; SIZE] = [0; SIZE];\n```",
      "version": "1.93.0",
      "source_file": "mod.rs",
      "embedding_text": "binding defined with one type but always cast to another\n\nChecks for bindings (constants, statics, or let bindings) that are defined\nwith one numeric type but are consistently cast to a different type in all usages.\n\nIf a binding is always cast to a different type when used, it would be clearer\nand more efficient to define it with the target type from the start."
    },
    {
      "id": "clippy::checked_conversions",
      "name": "CHECKED_CONVERSIONS",
      "snake_name": "checked_conversions",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "`try_from` could replace manual bounds checking when casting",
      "what_it_does": "Checks for explicit bounds checking when casting.",
      "why_bad": "Reduces the readability of statements & is error prone.",
      "example": "```no_run\n# let foo: u32 = 5;\nfoo <= i32::MAX as u32;\n```\n\nUse instead:\n```no_run\n# let foo = 1;\n# #[allow(unused)]\ni32::try_from(foo).is_ok();\n```",
      "version": "1.37.0",
      "source_file": "checked_conversions.rs",
      "embedding_text": "`try_from` could replace manual bounds checking when casting\n\nChecks for explicit bounds checking when casting.\n\nReduces the readability of statements & is error prone."
    },
    {
      "id": "clippy::cloned_ref_to_slice_refs",
      "name": "CLONED_REF_TO_SLICE_REFS",
      "snake_name": "cloned_ref_to_slice_refs",
      "category": "perf",
      "weight": 1.0,
      "brief": "cloning a reference for slice references",
      "what_it_does": "Checks for slice references with cloned references such as `&[f.clone()]`.",
      "why_bad": "A reference does not need to be owned in order to be used as a slice.",
      "example": "```ignore\nlet data = 10;\nlet data_ref = &data;\ntake_slice(&[data_ref.clone()]);\n```\nUse instead:\n```ignore\nuse std::slice;\nlet data = 10;\nlet data_ref = &data;\ntake_slice(slice::from_ref(data_ref));\n```",
      "version": "1.89.0",
      "source_file": "cloned_ref_to_slice_refs.rs",
      "embedding_text": "cloning a reference for slice references\n\nChecks for slice references with cloned references such as `&[f.clone()]`.\n\nA reference does not need to be owned in order to be used as a slice."
    },
    {
      "id": "clippy::coerce_container_to_any",
      "name": "COERCE_CONTAINER_TO_ANY",
      "snake_name": "coerce_container_to_any",
      "category": "nursery",
      "weight": 0.9,
      "brief": "coercing to `&dyn Any` when dereferencing could produce a `dyn Any` without coercion is usually not intended",
      "what_it_does": "Protects against unintended coercion of references to container types to `&dyn Any` when the\ncontainer type dereferences to a `dyn Any` which could be directly referenced instead.",
      "why_bad": "The intention is usually to get a reference to the `dyn Any` the value dereferences to,\nrather than coercing a reference to the container itself to `&dyn Any`.",
      "example": "Because `Box<dyn Any>` itself implements `Any`, `&Box<dyn Any>`\ncan be coerced to an `&dyn Any` which refers to *the `Box` itself*, rather than the\ninner `dyn Any`.\n```no_run\n# use std::any::Any;\nlet x: Box<dyn Any> = Box::new(0u32);\nlet dyn_any_of_box: &dyn Any = &x;\n\n// Fails as we have a &dyn Any to the Box, not the u32\nassert_eq!(dyn_any_of_box.downcast_ref::<u32>(), None);\n```\nUse instead:\n```no_run\n# use std::any::Any;\nlet x: Box<dyn Any> = Box::new(0u32);\nlet dyn_any_of_u32: &dyn Any = &*x;\n\n// Succeeds since we have a &dyn Any to the inner u32!\nassert_eq!(dyn_any_of_u32.downcast_ref::<u32>(), Some(&0u32));\n```",
      "version": "1.89.0",
      "source_file": "coerce_container_to_any.rs",
      "embedding_text": "coercing to `&dyn Any` when dereferencing could produce a `dyn Any` without coercion is usually not intended\n\nProtects against unintended coercion of references to container types to `&dyn Any` when the\ncontainer type dereferences to a `dyn Any` which could be directly referenced instead.\n\nThe intention is usually to get a reference to the `dyn Any` the value dereferences to,\nrather than coercing a reference to the container itself to `&dyn Any`."
    },
    {
      "id": "clippy::cognitive_complexity",
      "name": "COGNITIVE_COMPLEXITY",
      "snake_name": "cognitive_complexity",
      "category": "restriction",
      "weight": 1.0,
      "brief": "functions that should be split up into multiple functions",
      "what_it_does": "We used to think it measured how hard a method is to understand.",
      "why_bad": "Ideally, we would like to be able to measure how hard a function is\nto understand given its context (what we call its Cognitive Complexity).\nBut that's not what this lint does. See \"Known problems\"",
      "example": "",
      "version": "1.35.0",
      "source_file": "cognitive_complexity.rs",
      "embedding_text": "functions that should be split up into multiple functions\n\nWe used to think it measured how hard a method is to understand.\n\nIdeally, we would like to be able to measure how hard a function is\nto understand given its context (what we call its Cognitive Complexity).\nBut that's not what this lint does. See \"Known problems\""
    },
    {
      "id": "clippy::collapsible_if",
      "name": "COLLAPSIBLE_IF",
      "snake_name": "collapsible_if",
      "category": "style",
      "weight": 0.95,
      "brief": "nested `if`s that can be collapsed (e.g., `if x { if y { ... } }`",
      "what_it_does": "Checks for nested `if` statements which can be collapsed\nby `&&`-combining their conditions.",
      "why_bad": "Each `if`-statement adds one level of nesting, which\nmakes code look more complex than it really is.",
      "example": "```no_run\n# let (x, y) = (true, true);\nif x {\nif y {\n// \u2026\n}\n}\n```\n\nUse instead:\n```no_run\n# let (x, y) = (true, true);\nif x && y {\n// \u2026\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "collapsible_if.rs",
      "embedding_text": "nested `if`s that can be collapsed (e.g., `if x { if y { ... } }`\n\nChecks for nested `if` statements which can be collapsed\nby `&&`-combining their conditions.\n\nEach `if`-statement adds one level of nesting, which\nmakes code look more complex than it really is."
    },
    {
      "id": "clippy::collapsible_else_if",
      "name": "COLLAPSIBLE_ELSE_IF",
      "snake_name": "collapsible_else_if",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "nested `else`-`if` expressions that can be collapsed (e.g., `else { if x { ... } }`)",
      "what_it_does": "Checks for collapsible `else { if ... }` expressions\nthat can be collapsed to `else if ...`.",
      "why_bad": "Each `if`-statement adds one level of nesting, which\nmakes code look more complex than it really is.",
      "example": "```rust,ignore\n\nif x {\n\u2026\n} else {\nif y {\n\u2026\n}\n}\n```\n\nShould be written:\n\n```rust,ignore\nif x {\n\u2026\n} else if y {\n\u2026\n}\n```",
      "version": "1.51.0",
      "source_file": "collapsible_if.rs",
      "embedding_text": "nested `else`-`if` expressions that can be collapsed (e.g., `else { if x { ... } }`)\n\nChecks for collapsible `else { if ... }` expressions\nthat can be collapsed to `else if ...`.\n\nEach `if`-statement adds one level of nesting, which\nmakes code look more complex than it really is."
    },
    {
      "id": "clippy::collection_is_never_read",
      "name": "COLLECTION_IS_NEVER_READ",
      "snake_name": "collection_is_never_read",
      "category": "nursery",
      "weight": 0.9,
      "brief": "a collection is never queried",
      "what_it_does": "Checks for collections that are never queried.",
      "why_bad": "Putting effort into constructing a collection but then never querying it might indicate that\nthe author forgot to do whatever they intended to do with the collection. Example: Clone\na vector, sort it for iteration, but then mistakenly iterate the original vector\ninstead.",
      "example": "```no_run\n# let samples = vec![3, 1, 2];\nlet mut sorted_samples = samples.clone();\nsorted_samples.sort();\nfor sample in &samples { // Oops, meant to use `sorted_samples`.\nprintln!(\"{sample}\");\n}\n```\nUse instead:\n```no_run\n# let samples = vec![3, 1, 2];\nlet mut sorted_samples = samples.clone();\nsorted_samples.sort();\nfor sample in &sorted_samples {\nprintln!(\"{sample}\");\n}\n```",
      "version": "1.70.0",
      "source_file": "collection_is_never_read.rs",
      "embedding_text": "a collection is never queried\n\nChecks for collections that are never queried.\n\nPutting effort into constructing a collection but then never querying it might indicate that\nthe author forgot to do whatever they intended to do with the collection. Example: Clone\na vector, sort it for iteration, but then mistakenly iterate the original vector\ninstead."
    },
    {
      "id": "clippy::comparison_chain",
      "name": "COMPARISON_CHAIN",
      "snake_name": "comparison_chain",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "`if`s that can be rewritten with `match` and `cmp`",
      "what_it_does": "Checks comparison chains written with `if` that can be\nrewritten with `match` and `cmp`.",
      "why_bad": "`if` is not guaranteed to be exhaustive and conditionals can get\nrepetitive",
      "example": "```rust,ignore\n# fn a() {}\n# fn b() {}\n# fn c() {}\nfn f(x: u8, y: u8) {\nif x > y {\na()\n} else if x < y {\nb()\n} else {\nc()\n}\n}\n```\n\nUse instead:\n```rust,ignore\nuse std::cmp::Ordering;\n# fn a() {}\n# fn b() {}\n# fn c() {}\nfn f(x: u8, y: u8) {\nmatch x.cmp(&y) {\nOrdering::Greater => a(),\nOrdering::Less => b(),\nOrdering::Equal => c()\n}\n}\n```",
      "version": "1.40.0",
      "source_file": "comparison_chain.rs",
      "embedding_text": "`if`s that can be rewritten with `match` and `cmp`\n\nChecks comparison chains written with `if` that can be\nrewritten with `match` and `cmp`.\n\n`if` is not guaranteed to be exhaustive and conditionals can get\nrepetitive"
    },
    {
      "id": "clippy::copy_iterator",
      "name": "COPY_ITERATOR",
      "snake_name": "copy_iterator",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "implementing `Iterator` on a `Copy` type",
      "what_it_does": "Checks for types that implement `Copy` as well as\n`Iterator`.",
      "why_bad": "Implicit copies can be confusing when working with\niterator combinators.",
      "example": "```rust,ignore\n#[derive(Copy, Clone)]\nstruct Countdown(u8);\n\nimpl Iterator for Countdown {\n// ...\n}\n\nlet a: Vec<_> = my_iterator.take(1).collect();\nlet b: Vec<_> = my_iterator.collect();\n```",
      "version": "1.30.0",
      "source_file": "copy_iterator.rs",
      "embedding_text": "implementing `Iterator` on a `Copy` type\n\nChecks for types that implement `Copy` as well as\n`Iterator`.\n\nImplicit copies can be confusing when working with\niterator combinators."
    },
    {
      "id": "clippy::crate_in_macro_def",
      "name": "CRATE_IN_MACRO_DEF",
      "snake_name": "crate_in_macro_def",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "using `crate` in a macro definition",
      "what_it_does": "Checks for usage of `crate` as opposed to `$crate` in a macro definition.",
      "why_bad": "`crate` refers to the macro call's crate, whereas `$crate` refers to the macro definition's\ncrate. Rarely is the former intended. See:\nhttps://doc.rust-lang.org/reference/macros-by-example.html#hygiene",
      "example": "```no_run\n#[macro_export]\nmacro_rules! print_message {\n() => {\nprintln!(\"{}\", crate::MESSAGE);\n};\n}\npub const MESSAGE: &str = \"Hello!\";\n```\nUse instead:\n```no_run\n#[macro_export]\nmacro_rules! print_message {\n() => {\nprintln!(\"{}\", $crate::MESSAGE);\n};\n}\npub const MESSAGE: &str = \"Hello!\";\n```\n\nNote that if the use of `crate` is intentional, an `allow` attribute can be applied to the\nmacro definition, e.g.:\n```rust,ignore\n#[allow(clippy::crate_in_macro_def)]\nmacro_rules! ok { ... crate::foo ... }\n```",
      "version": "1.62.0",
      "source_file": "crate_in_macro_def.rs",
      "embedding_text": "using `crate` in a macro definition\n\nChecks for usage of `crate` as opposed to `$crate` in a macro definition.\n\n`crate` refers to the macro call's crate, whereas `$crate` refers to the macro definition's\ncrate. Rarely is the former intended. See:\nhttps://doc.rust-lang.org/reference/macros-by-example.html#hygiene"
    },
    {
      "id": "clippy::create_dir",
      "name": "CREATE_DIR",
      "snake_name": "create_dir",
      "category": "restriction",
      "weight": 1.0,
      "brief": "calling `std::fs::create_dir` instead of `std::fs::create_dir_all`",
      "what_it_does": "Checks usage of `std::fs::create_dir` and suggest using `std::fs::create_dir_all` instead.",
      "why_bad": "Sometimes `std::fs::create_dir` is mistakenly chosen over `std::fs::create_dir_all`,\nresulting in failure when more than one directory needs to be created or when the directory already exists.\nCrates which never need to specifically create a single directory may wish to prevent this mistake.",
      "example": "```rust,ignore\nstd::fs::create_dir(\"foo\");\n```\n\nUse instead:\n```rust,ignore\nstd::fs::create_dir_all(\"foo\");\n```",
      "version": "1.48.0",
      "source_file": "create_dir.rs",
      "embedding_text": "calling `std::fs::create_dir` instead of `std::fs::create_dir_all`\n\nChecks usage of `std::fs::create_dir` and suggest using `std::fs::create_dir_all` instead.\n\nSometimes `std::fs::create_dir` is mistakenly chosen over `std::fs::create_dir_all`,\nresulting in failure when more than one directory needs to be created or when the directory already exists.\nCrates which never need to specifically create a single directory may wish to prevent this mistake."
    },
    {
      "id": "clippy::dbg_macro",
      "name": "DBG_MACRO",
      "snake_name": "dbg_macro",
      "category": "restriction",
      "weight": 1.0,
      "brief": "`dbg!` macro is intended as a debugging tool",
      "what_it_does": "Checks for usage of the [`dbg!`](https://doc.rust-lang.org/std/macro.dbg.html) macro.",
      "why_bad": "The `dbg!` macro is intended as a debugging tool. It should not be present in released\nsoftware or committed to a version control system.",
      "example": "```rust,ignore\ndbg!(true)\n```\n\nUse instead:\n```rust,ignore\ntrue\n```",
      "version": "1.34.0",
      "source_file": "dbg_macro.rs",
      "embedding_text": "`dbg!` macro is intended as a debugging tool\n\nChecks for usage of the [`dbg!`](https://doc.rust-lang.org/std/macro.dbg.html) macro.\n\nThe `dbg!` macro is intended as a debugging tool. It should not be present in released\nsoftware or committed to a version control system."
    },
    {
      "id": "clippy::default_trait_access",
      "name": "DEFAULT_TRAIT_ACCESS",
      "snake_name": "default_trait_access",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "checks for literal calls to `Default::default()`",
      "what_it_does": "Checks for literal calls to `Default::default()`.",
      "why_bad": "It's easier for the reader if the name of the type is used, rather than the\ngeneric `Default`.",
      "example": "```no_run\nlet s: String = Default::default();\n```\n\nUse instead:\n```no_run\nlet s = String::default();\n```",
      "version": "pre 1.29.0",
      "source_file": "default.rs",
      "embedding_text": "checks for literal calls to `Default::default()`\n\nChecks for literal calls to `Default::default()`.\n\nIt's easier for the reader if the name of the type is used, rather than the\ngeneric `Default`."
    },
    {
      "id": "clippy::field_reassign_with_default",
      "name": "FIELD_REASSIGN_WITH_DEFAULT",
      "snake_name": "field_reassign_with_default",
      "category": "style",
      "weight": 0.95,
      "brief": "binding initialized with Default should have its fields set in the initializer",
      "what_it_does": "Checks for immediate reassignment of fields initialized\nwith Default::default().",
      "why_bad": "It's more idiomatic to use the [functional update syntax](https://doc.rust-lang.org/reference/expressions/struct-expr.html#functional-update-syntax).",
      "example": "```no_run\n# #[derive(Default)]\n# struct A { i: i32 }\nlet mut a: A = Default::default();\na.i = 42;\n```\n\nUse instead:\n```no_run\n# #[derive(Default)]\n# struct A { i: i32 }\nlet a = A {\ni: 42,\n.. Default::default()\n};\n```",
      "version": "1.49.0",
      "source_file": "default.rs",
      "embedding_text": "binding initialized with Default should have its fields set in the initializer\n\nChecks for immediate reassignment of fields initialized\nwith Default::default().\n\nIt's more idiomatic to use the [functional update syntax](https://doc.rust-lang.org/reference/expressions/struct-expr.html#functional-update-syntax)."
    },
    {
      "id": "clippy::default_constructed_unit_structs",
      "name": "DEFAULT_CONSTRUCTED_UNIT_STRUCTS",
      "snake_name": "default_constructed_unit_structs",
      "category": "complexity",
      "weight": 1.0,
      "brief": "unit structs can be constructed without calling `default`",
      "what_it_does": "Checks for construction on unit struct using `default`.",
      "why_bad": "This adds code complexity and an unnecessary function call.",
      "example": "```no_run\n# use std::marker::PhantomData;\n#[derive(Default)]\nstruct S<T> {\n_marker: PhantomData<T>\n}\n\nlet _: S<i32> = S {\n_marker: PhantomData::default()\n};\n```\nUse instead:\n```no_run\n# use std::marker::PhantomData;\nstruct S<T> {\n_marker: PhantomData<T>\n}\n\nlet _: S<i32> = S {\n_marker: PhantomData\n};\n```",
      "version": "1.71.0",
      "source_file": "default_constructed_unit_structs.rs",
      "embedding_text": "unit structs can be constructed without calling `default`\n\nChecks for construction on unit struct using `default`.\n\nThis adds code complexity and an unnecessary function call."
    },
    {
      "id": "clippy::default_instead_of_iter_empty",
      "name": "DEFAULT_INSTEAD_OF_ITER_EMPTY",
      "snake_name": "default_instead_of_iter_empty",
      "category": "style",
      "weight": 0.95,
      "brief": "check `std::iter::Empty::default()` and replace with `std::iter::empty()`",
      "what_it_does": "It checks for `std::iter::Empty::default()` and suggests replacing it with\n`std::iter::empty()`.",
      "why_bad": "`std::iter::empty()` is the more idiomatic way.",
      "example": "```no_run\nlet _ = std::iter::Empty::<usize>::default();\nlet iter: std::iter::Empty<usize> = std::iter::Empty::default();\n```\nUse instead:\n```no_run\nlet _ = std::iter::empty::<usize>();\nlet iter: std::iter::Empty<usize> = std::iter::empty();\n```",
      "version": "1.64.0",
      "source_file": "default_instead_of_iter_empty.rs",
      "embedding_text": "check `std::iter::Empty::default()` and replace with `std::iter::empty()`\n\nIt checks for `std::iter::Empty::default()` and suggests replacing it with\n`std::iter::empty()`.\n\n`std::iter::empty()` is the more idiomatic way."
    },
    {
      "id": "clippy::default_numeric_fallback",
      "name": "DEFAULT_NUMERIC_FALLBACK",
      "snake_name": "default_numeric_fallback",
      "category": "restriction",
      "weight": 1.0,
      "brief": "usage of unconstrained numeric literals which may cause default numeric fallback.",
      "what_it_does": "Checks for usage of unconstrained numeric literals which may cause default numeric fallback in type\ninference.\n\nDefault numeric fallback means that if numeric types have not yet been bound to concrete\ntypes at the end of type inference, then integer type is bound to `i32`, and similarly\nfloating type is bound to `f64`.\n\nSee [RFC0212](https://github.com/rust-lang/rfcs/blob/master/text/0212-restore-int-fallback.md) for more information about the fallback.",
      "why_bad": "To ensure that every numeric type is chosen explicitly rather than implicitly.",
      "example": "```no_run\nlet i = 10;\nlet f = 1.23;\n```\n\nUse instead:\n```no_run\nlet i = 10_i32;\nlet f = 1.23_f64;\n```",
      "version": "1.52.0",
      "source_file": "default_numeric_fallback.rs",
      "embedding_text": "usage of unconstrained numeric literals which may cause default numeric fallback.\n\nChecks for usage of unconstrained numeric literals which may cause default numeric fallback in type\ninference.\n\nDefault numeric fallback means that if numeric types have not yet been bound to concrete\ntypes at the end of type inference, then integer type is bound to `i32`, and similarly\nfloating type is bound to `f64`.\n\nSee [RFC0212](https://github.com/rust-lang/rfcs/blob/master/text/0212-restore-int-fallback.md) for more information about the fallback.\n\nTo ensure that every numeric type is chosen explicitly rather than implicitly."
    },
    {
      "id": "clippy::default_union_representation",
      "name": "DEFAULT_UNION_REPRESENTATION",
      "snake_name": "default_union_representation",
      "category": "restriction",
      "weight": 1.0,
      "brief": "unions without a `#[repr(C)]` attribute",
      "what_it_does": "Displays a warning when a union is declared with the default representation (without a `#[repr(C)]` attribute).",
      "why_bad": "Unions in Rust have unspecified layout by default, despite many people thinking that they\nlay out each field at the start of the union (like C does). That is, there are no guarantees\nabout the offset of the fields for unions with multiple non-ZST fields without an explicitly\nspecified layout. These cases may lead to undefined behavior in unsafe blocks.",
      "example": "```no_run\nunion Foo {\na: i32,\nb: u32,\n}\n\nfn main() {\nlet _x: u32 = unsafe {\nFoo { a: 0_i32 }.b // Undefined behavior: `b` is allowed to be padding\n};\n}\n```\nUse instead:\n```no_run\n#[repr(C)]\nunion Foo {\na: i32,\nb: u32,\n}\n\nfn main() {\nlet _x: u32 = unsafe {\nFoo { a: 0_i32 }.b // Now defined behavior, this is just an i32 -> u32 transmute\n};\n}\n```",
      "version": "1.60.0",
      "source_file": "default_union_representation.rs",
      "embedding_text": "unions without a `#[repr(C)]` attribute\n\nDisplays a warning when a union is declared with the default representation (without a `#[repr(C)]` attribute).\n\nUnions in Rust have unspecified layout by default, despite many people thinking that they\nlay out each field at the start of the union (like C does). That is, there are no guarantees\nabout the offset of the fields for unions with multiple non-ZST fields without an explicitly\nspecified layout. These cases may lead to undefined behavior in unsafe blocks."
    },
    {
      "id": "clippy::explicit_deref_methods",
      "name": "EXPLICIT_DEREF_METHODS",
      "snake_name": "explicit_deref_methods",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "Explicit use of deref or deref_mut method while not in a method chain.",
      "what_it_does": "Checks for explicit `deref()` or `deref_mut()` method calls.\n\nDoesn't lint inside the implementation of the `Deref` or `DerefMut` traits.",
      "why_bad": "Dereferencing by `&*x` or `&mut *x` is clearer and more concise,\nwhen not part of a method chain.",
      "example": "```no_run\nuse std::ops::Deref;\nlet a: &mut String = &mut String::from(\"foo\");\nlet b: &str = a.deref();\n```\n\nUse instead:\n```no_run\nlet a: &mut String = &mut String::from(\"foo\");\nlet b = &*a;\n```\n\nThis lint excludes all of:\n```rust,ignore\nlet _ = d.unwrap().deref();\nlet _ = Foo::deref(&foo);\nlet _ = <Foo as Deref>::deref(&foo);\n```",
      "version": "1.44.0",
      "source_file": "dereference.rs",
      "embedding_text": "Explicit use of deref or deref_mut method while not in a method chain.\n\nChecks for explicit `deref()` or `deref_mut()` method calls.\n\nDoesn't lint inside the implementation of the `Deref` or `DerefMut` traits.\n\nDereferencing by `&*x` or `&mut *x` is clearer and more concise,\nwhen not part of a method chain."
    },
    {
      "id": "clippy::needless_borrow",
      "name": "NEEDLESS_BORROW",
      "snake_name": "needless_borrow",
      "category": "style",
      "weight": 0.95,
      "brief": "taking a reference that is going to be automatically dereferenced",
      "what_it_does": "Checks for address of operations (`&`) that are going to\nbe dereferenced immediately by the compiler.",
      "why_bad": "Suggests that the receiver of the expression borrows\nthe expression.",
      "example": "```no_run\nfn fun(_a: &i32) {}\n\nlet x: &i32 = &&&&&&5;\nfun(&x);\n```\n\nUse instead:\n```no_run\n# fn fun(_a: &i32) {}\nlet x: &i32 = &5;\nfun(x);\n```",
      "version": "pre 1.29.0",
      "source_file": "dereference.rs",
      "embedding_text": "taking a reference that is going to be automatically dereferenced\n\nChecks for address of operations (`&`) that are going to\nbe dereferenced immediately by the compiler.\n\nSuggests that the receiver of the expression borrows\nthe expression."
    },
    {
      "id": "clippy::ref_binding_to_reference",
      "name": "REF_BINDING_TO_REFERENCE",
      "snake_name": "ref_binding_to_reference",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "`ref` binding to a reference",
      "what_it_does": "Checks for `ref` bindings which create a reference to a reference.",
      "why_bad": "The address-of operator at the use site is clearer about the need for a reference.",
      "example": "```no_run\nlet x = Some(\"\");\nif let Some(ref x) = x {\n// use `x` here\n}\n```\n\nUse instead:\n```no_run\nlet x = Some(\"\");\nif let Some(x) = x {\n// use `&x` here\n}\n```",
      "version": "1.54.0",
      "source_file": "dereference.rs",
      "embedding_text": "`ref` binding to a reference\n\nChecks for `ref` bindings which create a reference to a reference.\n\nThe address-of operator at the use site is clearer about the need for a reference."
    },
    {
      "id": "clippy::explicit_auto_deref",
      "name": "EXPLICIT_AUTO_DEREF",
      "snake_name": "explicit_auto_deref",
      "category": "complexity",
      "weight": 1.0,
      "brief": "dereferencing when the compiler would automatically dereference",
      "what_it_does": "Checks for dereferencing expressions which would be covered by auto-deref.",
      "why_bad": "This unnecessarily complicates the code.",
      "example": "```no_run\nlet x = String::new();\nlet y: &str = &*x;\n```\nUse instead:\n```no_run\nlet x = String::new();\nlet y: &str = &x;\n```",
      "version": "1.64.0",
      "source_file": "dereference.rs",
      "embedding_text": "dereferencing when the compiler would automatically dereference\n\nChecks for dereferencing expressions which would be covered by auto-deref.\n\nThis unnecessarily complicates the code."
    },
    {
      "id": "clippy::derivable_impls",
      "name": "DERIVABLE_IMPLS",
      "snake_name": "derivable_impls",
      "category": "complexity",
      "weight": 1.0,
      "brief": "manual implementation of the `Default` trait which is equal to a derive",
      "what_it_does": "Detects manual `std::default::Default` implementations that are identical to a derived implementation.",
      "why_bad": "It is less concise.",
      "example": "```no_run\nstruct Foo {\nbar: bool\n}\n\nimpl Default for Foo {\nfn default() -> Self {\nSelf {\nbar: false\n}\n}\n}\n```\n\nUse instead:\n```no_run\n#[derive(Default)]\nstruct Foo {\nbar: bool\n}\n```",
      "version": "1.57.0",
      "source_file": "derivable_impls.rs",
      "embedding_text": "manual implementation of the `Default` trait which is equal to a derive\n\nDetects manual `std::default::Default` implementations that are identical to a derived implementation.\n\nIt is less concise."
    },
    {
      "id": "clippy::derived_hash_with_manual_eq",
      "name": "DERIVED_HASH_WITH_MANUAL_EQ",
      "snake_name": "derived_hash_with_manual_eq",
      "category": "correctness",
      "weight": 1.2,
      "brief": "deriving `Hash` but implementing `PartialEq` explicitly",
      "what_it_does": "Lints against manual `PartialEq` implementations for types with a derived `Hash`\nimplementation.",
      "why_bad": "The implementation of these traits must agree (for\nexample for use with `HashMap`) so it\u2019s probably a bad idea to use a\ndefault-generated `Hash` implementation with an explicitly defined\n`PartialEq`. In particular, the following must hold for any type:\n\n```text\nk1 == k2 \u21d2 hash(k1) == hash(k2)\n```",
      "example": "```ignore\n#[derive(Hash)]\nstruct Foo;\n\nimpl PartialEq for Foo {\n...\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "deriving `Hash` but implementing `PartialEq` explicitly\n\nLints against manual `PartialEq` implementations for types with a derived `Hash`\nimplementation.\n\nThe implementation of these traits must agree (for\nexample for use with `HashMap`) so it\u2019s probably a bad idea to use a\ndefault-generated `Hash` implementation with an explicitly defined\n`PartialEq`. In particular, the following must hold for any type:\n\n```text\nk1 == k2 \u21d2 hash(k1) == hash(k2)\n```"
    },
    {
      "id": "clippy::derive_ord_xor_partial_ord",
      "name": "DERIVE_ORD_XOR_PARTIAL_ORD",
      "snake_name": "derive_ord_xor_partial_ord",
      "category": "correctness",
      "weight": 1.2,
      "brief": "deriving `Ord` but implementing `PartialOrd` explicitly",
      "what_it_does": "Lints against manual `PartialOrd` and `Ord` implementations for types with a derived `Ord`\nor `PartialOrd` implementation.",
      "why_bad": "The implementation of these traits must agree (for\nexample for use with `sort`) so it\u2019s probably a bad idea to use a\ndefault-generated `Ord` implementation with an explicitly defined\n`PartialOrd`. In particular, the following must hold for any type\nimplementing `Ord`:\n\n```text\nk1.cmp(&k2) == k1.partial_cmp(&k2).unwrap()\n```",
      "example": "```rust,ignore\n#[derive(Ord, PartialEq, Eq)]\nstruct Foo;\n\nimpl PartialOrd for Foo {\n...\n}\n```\nUse instead:\n```rust,ignore\n#[derive(PartialEq, Eq)]\nstruct Foo;\n\nimpl PartialOrd for Foo {\nfn partial_cmp(&self, other: &Foo) -> Option<Ordering> {\nSome(self.cmp(other))\n}\n}\n\nimpl Ord for Foo {\n...\n}\n```\nor, if you don't need a custom ordering:\n```rust,ignore\n#[derive(Ord, PartialOrd, PartialEq, Eq)]\nstruct Foo;\n```",
      "version": "1.47.0",
      "source_file": "mod.rs",
      "embedding_text": "deriving `Ord` but implementing `PartialOrd` explicitly\n\nLints against manual `PartialOrd` and `Ord` implementations for types with a derived `Ord`\nor `PartialOrd` implementation.\n\nThe implementation of these traits must agree (for\nexample for use with `sort`) so it\u2019s probably a bad idea to use a\ndefault-generated `Ord` implementation with an explicitly defined\n`PartialOrd`. In particular, the following must hold for any type\nimplementing `Ord`:\n\n```text\nk1.cmp(&k2) == k1.partial_cmp(&k2).unwrap()\n```"
    },
    {
      "id": "clippy::expl_impl_clone_on_copy",
      "name": "EXPL_IMPL_CLONE_ON_COPY",
      "snake_name": "expl_impl_clone_on_copy",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "implementing `Clone` explicitly on `Copy` types",
      "what_it_does": "Checks for explicit `Clone` implementations for `Copy`\ntypes.",
      "why_bad": "To avoid surprising behavior, these traits should\nagree and the behavior of `Copy` cannot be overridden. In almost all\nsituations a `Copy` type should have a `Clone` implementation that does\nnothing more than copy the object, which is what `#[derive(Copy, Clone)]`\ngets you.",
      "example": "```rust,ignore\n#[derive(Copy)]\nstruct Foo;\n\nimpl Clone for Foo {\n// ..\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "implementing `Clone` explicitly on `Copy` types\n\nChecks for explicit `Clone` implementations for `Copy`\ntypes.\n\nTo avoid surprising behavior, these traits should\nagree and the behavior of `Copy` cannot be overridden. In almost all\nsituations a `Copy` type should have a `Clone` implementation that does\nnothing more than copy the object, which is what `#[derive(Copy, Clone)]`\ngets you."
    },
    {
      "id": "clippy::unsafe_derive_deserialize",
      "name": "UNSAFE_DERIVE_DESERIALIZE",
      "snake_name": "unsafe_derive_deserialize",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "deriving `serde::Deserialize` on a type that has methods using `unsafe`",
      "what_it_does": "Checks for deriving `serde::Deserialize` on a type that\nhas methods using `unsafe`.",
      "why_bad": "Deriving `serde::Deserialize` will create a constructor\nthat may violate invariants held by another constructor.",
      "example": "```rust,ignore\nuse serde::Deserialize;\n\n#[derive(Deserialize)]\npub struct Foo {\n// ..\n}\n\nimpl Foo {\npub fn new() -> Self {\n// setup here ..\n}\n\npub unsafe fn parts() -> (&str, &str) {\n// assumes invariants hold\n}\n}\n```",
      "version": "1.45.0",
      "source_file": "mod.rs",
      "embedding_text": "deriving `serde::Deserialize` on a type that has methods using `unsafe`\n\nChecks for deriving `serde::Deserialize` on a type that\nhas methods using `unsafe`.\n\nDeriving `serde::Deserialize` will create a constructor\nthat may violate invariants held by another constructor."
    },
    {
      "id": "clippy::derive_partial_eq_without_eq",
      "name": "DERIVE_PARTIAL_EQ_WITHOUT_EQ",
      "snake_name": "derive_partial_eq_without_eq",
      "category": "nursery",
      "weight": 0.9,
      "brief": "deriving `PartialEq` on a type that can implement `Eq`, without implementing `Eq`",
      "what_it_does": "Checks for types that derive `PartialEq` and could implement `Eq`.",
      "why_bad": "If a type `T` derives `PartialEq` and all of its members implement `Eq`,\nthen `T` can always implement `Eq`. Implementing `Eq` allows `T` to be used\nin APIs that require `Eq` types. It also allows structs containing `T` to derive\n`Eq` themselves.",
      "example": "```no_run\n#[derive(PartialEq)]\nstruct Foo {\ni_am_eq: i32,\ni_am_eq_too: Vec<String>,\n}\n```\nUse instead:\n```no_run\n#[derive(PartialEq, Eq)]\nstruct Foo {\ni_am_eq: i32,\ni_am_eq_too: Vec<String>,\n}\n```",
      "version": "1.63.0",
      "source_file": "mod.rs",
      "embedding_text": "deriving `PartialEq` on a type that can implement `Eq`, without implementing `Eq`\n\nChecks for types that derive `PartialEq` and could implement `Eq`.\n\nIf a type `T` derives `PartialEq` and all of its members implement `Eq`,\nthen `T` can always implement `Eq`. Implementing `Eq` allows `T` to be used\nin APIs that require `Eq` types. It also allows structs containing `T` to derive\n`Eq` themselves."
    },
    {
      "id": "clippy::disallowed_macros",
      "name": "DISALLOWED_MACROS",
      "snake_name": "disallowed_macros",
      "category": "style",
      "weight": 0.95,
      "brief": "use of a disallowed macro",
      "what_it_does": "Denies the configured macros in clippy.toml\n\nNote: Even though this lint is warn-by-default, it will only trigger if\nmacros are defined in the clippy.toml file.",
      "why_bad": "Some macros are undesirable in certain contexts, and it's beneficial to\nlint for them as needed.",
      "example": "An example clippy.toml configuration:\n```toml\n# clippy.toml\ndisallowed-macros = [\n# Can use a string as the path of the disallowed macro.\n\"std::print\",\n# Can also use an inline table with a `path` key.\n{ path = \"std::println\" },\n# When using an inline table, can add a `reason` for why the macro\n# is disallowed.\n{ path = \"serde::Serialize\", reason = \"no serializing\" },\n# This would normally error if the path is incorrect, but with `allow-invalid` = `true`,\n# it will be silently ignored\n{ path = \"std::invalid_macro\", reason = \"use alternative instead\", allow-invalid = true }\n]\n```\n```no_run\nuse serde::Serialize;\n\nprintln!(\"warns\");\n\n// The diagnostic will contain the message \"no serializing\"\n#[derive(Serialize)]\nstruct Data {\nname: String,\nvalue: usize,\n}\n```",
      "version": "1.66.0",
      "source_file": "disallowed_macros.rs",
      "embedding_text": "use of a disallowed macro\n\nDenies the configured macros in clippy.toml\n\nNote: Even though this lint is warn-by-default, it will only trigger if\nmacros are defined in the clippy.toml file.\n\nSome macros are undesirable in certain contexts, and it's beneficial to\nlint for them as needed."
    },
    {
      "id": "clippy::disallowed_methods",
      "name": "DISALLOWED_METHODS",
      "snake_name": "disallowed_methods",
      "category": "style",
      "weight": 0.95,
      "brief": "use of a disallowed method call",
      "what_it_does": "Denies the configured methods and functions in clippy.toml\n\nNote: Even though this lint is warn-by-default, it will only trigger if\nmethods are defined in the clippy.toml file.",
      "why_bad": "Some methods are undesirable in certain contexts, and it's beneficial to\nlint for them as needed.",
      "example": "An example clippy.toml configuration:\n```toml\n# clippy.toml\ndisallowed-methods = [\n# Can use a string as the path of the disallowed method.\n\"std::boxed::Box::new\",\n# Can also use an inline table with a `path` key.\n{ path = \"std::time::Instant::now\" },\n# When using an inline table, can add a `reason` for why the method\n# is disallowed.\n{ path = \"std::vec::Vec::leak\", reason = \"no leaking memory\" },\n# Can also add a `replacement` that will be offered as a suggestion.\n{ path = \"std::sync::Mutex::new\", reason = \"prefer faster & simpler non-poisonable mutex\", replacement = \"parking_lot::Mutex::new\" },\n# This would normally error if the path is incorrect, but with `allow-invalid` = `true`,\n# it will be silently ignored\n{ path = \"std::fs::InvalidPath\", reason = \"use alternative instead\", allow-invalid = true },\n]\n```\n\n```rust,ignore\nlet xs = vec![1, 2, 3, 4];\nxs.leak(); // Vec::leak is disallowed in the config.\n// The diagnostic contains the message \"no leaking memory\".\n\nlet _now = Instant::now(); // Instant::now is disallowed in the config.\n\nlet _box = Box::new(3); // Box::new is disallowed in the config.\n```\n\nUse instead:\n```rust,ignore\nlet mut xs = Vec::new(); // Vec::new is _not_ disallowed in the config.\nxs.push(123); // Vec::push is _not_ disallowed in the config.\n```",
      "version": "1.49.0",
      "source_file": "disallowed_methods.rs",
      "embedding_text": "use of a disallowed method call\n\nDenies the configured methods and functions in clippy.toml\n\nNote: Even though this lint is warn-by-default, it will only trigger if\nmethods are defined in the clippy.toml file.\n\nSome methods are undesirable in certain contexts, and it's beneficial to\nlint for them as needed."
    },
    {
      "id": "clippy::disallowed_names",
      "name": "DISALLOWED_NAMES",
      "snake_name": "disallowed_names",
      "category": "style",
      "weight": 0.95,
      "brief": "usage of a disallowed/placeholder name",
      "what_it_does": "Checks for usage of disallowed names for variables, such\nas `foo`.",
      "why_bad": "These names are usually placeholder names and should be\navoided.",
      "example": "```no_run\nlet foo = 3.14;\n```",
      "version": "pre 1.29.0",
      "source_file": "disallowed_names.rs",
      "embedding_text": "usage of a disallowed/placeholder name\n\nChecks for usage of disallowed names for variables, such\nas `foo`.\n\nThese names are usually placeholder names and should be\navoided."
    },
    {
      "id": "clippy::disallowed_script_idents",
      "name": "DISALLOWED_SCRIPT_IDENTS",
      "snake_name": "disallowed_script_idents",
      "category": "restriction",
      "weight": 1.0,
      "brief": "usage of non-allowed Unicode scripts",
      "what_it_does": "Checks for usage of unicode scripts other than those explicitly allowed\nby the lint config.\n\nThis lint doesn't take into account non-text scripts such as `Unknown` and `Linear_A`.\nIt also ignores the `Common` script type.\nWhile configuring, be sure to use official script name [aliases] from\n[the list of supported scripts][supported_scripts].\n\nSee also: [`non_ascii_idents`].\n\n[aliases]: http://www.unicode.org/reports/tr24/tr24-31.html#Script_Value_Aliases\n[supported_scripts]: https://www.unicode.org/iso15924/iso15924-codes.html",
      "why_bad": "It may be not desired to have many different scripts for\nidentifiers in the codebase.\n\nNote that if you only want to allow typical English, you might want to use\nbuilt-in [`non_ascii_idents`] lint instead.\n\n[`non_ascii_idents`]: https://doc.rust-lang.org/rustc/lints/listing/allowed-by-default.html#non-ascii-idents",
      "example": "```no_run\n// Assuming that `clippy.toml` contains the following line:\n// allowed-scripts = [\"Latin\", \"Cyrillic\"]\nlet counter = 10; // OK, latin is allowed.\nlet \u0441\u0447\u0451\u0442\u0447\u0438\u043a = 10; // OK, cyrillic is allowed.\nlet z\u00e4hler = 10; // OK, it's still latin.\nlet \u30ab\u30a6\u30f3\u30bf = 10; // Will spawn the lint.\n```",
      "version": "1.55.0",
      "source_file": "disallowed_script_idents.rs",
      "embedding_text": "usage of non-allowed Unicode scripts\n\nChecks for usage of unicode scripts other than those explicitly allowed\nby the lint config.\n\nThis lint doesn't take into account non-text scripts such as `Unknown` and `Linear_A`.\nIt also ignores the `Common` script type.\nWhile configuring, be sure to use official script name [aliases] from\n[the list of supported scripts][supported_scripts].\n\nSee also: [`non_ascii_idents`].\n\n[aliases]: http://www.unicode.org/reports/tr24/tr24-31.html#Script_Value_Aliases\n[supported_scripts]: https://www.unicode.org/iso15924/iso15924-codes.html\n\nIt may be not desired to have many different scripts for\nidentifiers in the codebase.\n\nNote that if you only want to allow typical English, you might want to use\nbuilt-in [`non_ascii_idents`] lint instead.\n\n[`non_ascii_idents`]: https://doc.rust-lang.org/rustc/lints/listing/allowed-by-default.html#non-ascii-idents"
    },
    {
      "id": "clippy::disallowed_types",
      "name": "DISALLOWED_TYPES",
      "snake_name": "disallowed_types",
      "category": "style",
      "weight": 0.95,
      "brief": "use of disallowed types",
      "what_it_does": "Denies the configured types in clippy.toml.\n\nNote: Even though this lint is warn-by-default, it will only trigger if\ntypes are defined in the clippy.toml file.",
      "why_bad": "Some types are undesirable in certain contexts.",
      "example": "An example clippy.toml configuration:\n```toml\n# clippy.toml\ndisallowed-types = [\n# Can use a string as the path of the disallowed type.\n\"std::collections::BTreeMap\",\n# Can also use an inline table with a `path` key.\n{ path = \"std::net::TcpListener\" },\n# When using an inline table, can add a `reason` for why the type\n# is disallowed.\n{ path = \"std::net::Ipv4Addr\", reason = \"no IPv4 allowed\" },\n# Can also add a `replacement` that will be offered as a suggestion.\n{ path = \"std::sync::Mutex\", reason = \"prefer faster & simpler non-poisonable mutex\", replacement = \"parking_lot::Mutex\" },\n# This would normally error if the path is incorrect, but with `allow-invalid` = `true`,\n# it will be silently ignored\n{ path = \"std::invalid::Type\", reason = \"use alternative instead\", allow-invalid = true }\n]\n```\n\n```rust,ignore\nuse std::collections::BTreeMap;\n// or its use\nlet x = std::collections::BTreeMap::new();\n```\nUse instead:\n```rust,ignore\n// A similar type that is allowed by the config\nuse std::collections::HashMap;\n```",
      "version": "1.55.0",
      "source_file": "disallowed_types.rs",
      "embedding_text": "use of disallowed types\n\nDenies the configured types in clippy.toml.\n\nNote: Even though this lint is warn-by-default, it will only trigger if\ntypes are defined in the clippy.toml file.\n\nSome types are undesirable in certain contexts."
    },
    {
      "id": "clippy::doc_markdown",
      "name": "DOC_MARKDOWN",
      "snake_name": "doc_markdown",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "presence of `_`, `::` or camel-case outside backticks in documentation",
      "what_it_does": "Checks for the presence of `_`, `::` or camel-case words\noutside ticks in documentation.",
      "why_bad": "*Rustdoc* supports markdown formatting, `_`, `::` and\ncamel-case probably indicates some code which should be included between\nticks. `_` can also be used for emphasis in markdown, this lint tries to\nconsider that.",
      "example": "```no_run\n/// Do something with the foo_bar parameter. See also\n/// that::other::module::foo.\n// ^ `foo_bar` and `that::other::module::foo` should be ticked.\nfn doit(foo_bar: usize) {}\n```\n\n```no_run\n// Link text with `[]` brackets should be written as following:\n/// Consume the array and return the inner\n/// [`SmallVec<[T; INLINE_CAPACITY]>`][SmallVec].\n/// [SmallVec]: SmallVec\nfn main() {}\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "presence of `_`, `::` or camel-case outside backticks in documentation\n\nChecks for the presence of `_`, `::` or camel-case words\noutside ticks in documentation.\n\n*Rustdoc* supports markdown formatting, `_`, `::` and\ncamel-case probably indicates some code which should be included between\nticks. `_` can also be used for emphasis in markdown, this lint tries to\nconsider that."
    },
    {
      "id": "clippy::doc_link_code",
      "name": "DOC_LINK_CODE",
      "snake_name": "doc_link_code",
      "category": "nursery",
      "weight": 0.9,
      "brief": "link with code back-to-back with other code",
      "what_it_does": "Checks for links with code directly adjacent to code text:\n`` [`MyItem`]`<`[`u32`]`>` ``.",
      "why_bad": "It can be written more simply using HTML-style `<code>` tags.",
      "example": "```no_run\n//! [`first`](x)`second`\n```\nUse instead:\n```no_run\n//! <code>[first](x)second</code>\n```",
      "version": "1.87.0",
      "source_file": "mod.rs",
      "embedding_text": "link with code back-to-back with other code\n\nChecks for links with code directly adjacent to code text:\n`` [`MyItem`]`<`[`u32`]`>` ``.\n\nIt can be written more simply using HTML-style `<code>` tags."
    },
    {
      "id": "clippy::missing_safety_doc",
      "name": "MISSING_SAFETY_DOC",
      "snake_name": "missing_safety_doc",
      "category": "style",
      "weight": 0.95,
      "brief": "`pub unsafe fn` without `# Safety` docs",
      "what_it_does": "Checks for the doc comments of publicly visible\nunsafe functions and warns if there is no `# Safety` section.",
      "why_bad": "Unsafe functions should document their safety\npreconditions, so that users can be sure they are using them safely.",
      "example": "```no_run\n# type Universe = ();\n/// This function should really be documented\npub unsafe fn start_apocalypse(u: &mut Universe) {\nunimplemented!();\n}\n```\n\nAt least write a line about safety:\n\n```no_run\n# type Universe = ();\n/// # Safety\n///\n/// This function should not be called before the horsemen are ready.\npub unsafe fn start_apocalypse(u: &mut Universe) {\nunimplemented!();\n}\n```",
      "version": "1.39.0",
      "source_file": "mod.rs",
      "embedding_text": "`pub unsafe fn` without `# Safety` docs\n\nChecks for the doc comments of publicly visible\nunsafe functions and warns if there is no `# Safety` section.\n\nUnsafe functions should document their safety\npreconditions, so that users can be sure they are using them safely."
    },
    {
      "id": "clippy::missing_errors_doc",
      "name": "MISSING_ERRORS_DOC",
      "snake_name": "missing_errors_doc",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "`pub fn` returns `Result` without `# Errors` in doc comment",
      "what_it_does": "Checks the doc comments of publicly visible functions that\nreturn a `Result` type and warns if there is no `# Errors` section.",
      "why_bad": "Documenting the type of errors that can be returned from a\nfunction can help callers write code to handle the errors appropriately.",
      "example": "Since the following function returns a `Result` it has an `# Errors` section in\nits doc comment:\n\n```no_run\n# use std::io;\n/// # Errors\n///\n/// Will return `Err` if `filename` does not exist or the user does not have\n/// permission to read it.\npub fn read(filename: String) -> io::Result<String> {\nunimplemented!();\n}\n```",
      "version": "1.41.0",
      "source_file": "mod.rs",
      "embedding_text": "`pub fn` returns `Result` without `# Errors` in doc comment\n\nChecks the doc comments of publicly visible functions that\nreturn a `Result` type and warns if there is no `# Errors` section.\n\nDocumenting the type of errors that can be returned from a\nfunction can help callers write code to handle the errors appropriately."
    },
    {
      "id": "clippy::missing_panics_doc",
      "name": "MISSING_PANICS_DOC",
      "snake_name": "missing_panics_doc",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "`pub fn` may panic without `# Panics` in doc comment",
      "what_it_does": "Checks the doc comments of publicly visible functions that\nmay panic and warns if there is no `# Panics` section.",
      "why_bad": "Documenting the scenarios in which panicking occurs\ncan help callers who do not want to panic to avoid those situations.",
      "example": "Since the following function may panic it has a `# Panics` section in\nits doc comment:\n\n```no_run\n/// # Panics\n///\n/// Will panic if y is 0\npub fn divide_by(x: i32, y: i32) -> i32 {\nif y == 0 {\npanic!(\"Cannot divide by 0\")\n} else {\nx / y\n}\n}\n```\n\nIndividual panics within a function can be ignored with `#[expect]` or\n`#[allow]`:\n\n```no_run\n# use std::num::NonZeroUsize;\npub fn will_not_panic(x: usize) {\n#[expect(clippy::missing_panics_doc, reason = \"infallible\")]\nlet y = NonZeroUsize::new(1).unwrap();\n\n// If any panics are added in the future the lint will still catch them\n}\n```",
      "version": "1.51.0",
      "source_file": "mod.rs",
      "embedding_text": "`pub fn` may panic without `# Panics` in doc comment\n\nChecks the doc comments of publicly visible functions that\nmay panic and warns if there is no `# Panics` section.\n\nDocumenting the scenarios in which panicking occurs\ncan help callers who do not want to panic to avoid those situations."
    },
    {
      "id": "clippy::test_attr_in_doctest",
      "name": "TEST_ATTR_IN_DOCTEST",
      "snake_name": "test_attr_in_doctest",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "presence of `#[test]` in code examples",
      "what_it_does": "Checks for `#[test]` in doctests unless they are marked with\neither `ignore`, `no_run` or `compile_fail`.",
      "why_bad": "Code in examples marked as `#[test]` will somewhat\nsurprisingly not be run by `cargo test`. If you really want\nto show how to test stuff in an example, mark it `no_run` to\nmake the intent clear.",
      "example": "```no_run\n/// An example of a doctest with a `main()` function\n///\n/// # Examples\n///\n/// ```\n/// #[test]\n/// fn equality_works() {\n///     assert_eq!(1_u8, 1);\n/// }\n/// ```\nfn test_attr_in_doctest() {\nunimplemented!();\n}\n```",
      "version": "1.76.0",
      "source_file": "mod.rs",
      "embedding_text": "presence of `#[test]` in code examples\n\nChecks for `#[test]` in doctests unless they are marked with\neither `ignore`, `no_run` or `compile_fail`.\n\nCode in examples marked as `#[test]` will somewhat\nsurprisingly not be run by `cargo test`. If you really want\nto show how to test stuff in an example, mark it `no_run` to\nmake the intent clear."
    },
    {
      "id": "clippy::doc_link_with_quotes",
      "name": "DOC_LINK_WITH_QUOTES",
      "snake_name": "doc_link_with_quotes",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "possible typo for an intra-doc link",
      "what_it_does": "Detects the syntax `['foo']` in documentation comments (notice quotes instead of backticks)\noutside of code blocks",
      "why_bad": "It is likely a typo when defining an intra-doc link",
      "example": "```no_run\n/// See also: ['foo']\nfn bar() {}\n```\nUse instead:\n```no_run\n/// See also: [`foo`]\nfn bar() {}\n```",
      "version": "1.63.0",
      "source_file": "mod.rs",
      "embedding_text": "possible typo for an intra-doc link\n\nDetects the syntax `['foo']` in documentation comments (notice quotes instead of backticks)\noutside of code blocks\n\nIt is likely a typo when defining an intra-doc link"
    },
    {
      "id": "clippy::doc_broken_link",
      "name": "DOC_BROKEN_LINK",
      "snake_name": "doc_broken_link",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "broken document link",
      "what_it_does": "Checks the doc comments have unbroken links, mostly caused\nby bad formatted links such as broken across multiple lines.",
      "why_bad": "Because documentation generated by rustdoc will be broken\nsince expected links won't be links and just text.",
      "example": "This link is broken:\n```no_run\n/// [example of a bad link](https://\n/// github.com/rust-lang/rust-clippy/)\npub fn do_something() {}\n```\n\nIt shouldn't be broken across multiple lines to work:\n```no_run\n/// [example of a good link](https://github.com/rust-lang/rust-clippy/)\npub fn do_something() {}\n```",
      "version": "1.90.0",
      "source_file": "mod.rs",
      "embedding_text": "broken document link\n\nChecks the doc comments have unbroken links, mostly caused\nby bad formatted links such as broken across multiple lines.\n\nBecause documentation generated by rustdoc will be broken\nsince expected links won't be links and just text."
    },
    {
      "id": "clippy::unnecessary_safety_doc",
      "name": "UNNECESSARY_SAFETY_DOC",
      "snake_name": "unnecessary_safety_doc",
      "category": "restriction",
      "weight": 1.0,
      "brief": "`pub fn` or `pub trait` with `# Safety` docs",
      "what_it_does": "Checks for the doc comments of publicly visible\nsafe functions and traits and warns if there is a `# Safety` section.",
      "why_bad": "Safe functions and traits are safe to implement and therefore do not\nneed to describe safety preconditions that users are required to uphold.",
      "example": "```no_run\n# type Universe = ();\n/// # Safety\n///\n/// This function should not be called before the horsemen are ready.\npub fn start_apocalypse_but_safely(u: &mut Universe) {\nunimplemented!();\n}\n```\n\nThe function is safe, so there shouldn't be any preconditions\nthat have to be explained for safety reasons.\n\n```no_run\n# type Universe = ();\n/// This function should really be documented\npub fn start_apocalypse(u: &mut Universe) {\nunimplemented!();\n}\n```",
      "version": "1.67.0",
      "source_file": "mod.rs",
      "embedding_text": "`pub fn` or `pub trait` with `# Safety` docs\n\nChecks for the doc comments of publicly visible\nsafe functions and traits and warns if there is a `# Safety` section.\n\nSafe functions and traits are safe to implement and therefore do not\nneed to describe safety preconditions that users are required to uphold."
    },
    {
      "id": "clippy::suspicious_doc_comments",
      "name": "SUSPICIOUS_DOC_COMMENTS",
      "snake_name": "suspicious_doc_comments",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "suspicious usage of (outer) doc comments",
      "what_it_does": "Detects the use of outer doc comments (`///`, `/**`) followed by a bang (`!`): `///!`",
      "why_bad": "Triple-slash comments (known as \"outer doc comments\") apply to items that follow it.\nAn outer doc comment followed by a bang (i.e. `///!`) has no specific meaning.\n\nThe user most likely meant to write an inner doc comment (`//!`, `/*!`), which\napplies to the parent item (i.e. the item that the comment is contained in,\nusually a module or crate).",
      "example": "In this example, the doc comment is attached to the *function*, rather than the *module*.\n```no_run\npub mod util {\n///! This module contains utility functions.\n\npub fn dummy() {}\n}\n```\n\nUse instead:\n```no_run\npub mod util {\n//! This module contains utility functions.\n\npub fn dummy() {}\n}\n```",
      "version": "1.70.0",
      "source_file": "mod.rs",
      "embedding_text": "suspicious usage of (outer) doc comments\n\nDetects the use of outer doc comments (`///`, `/**`) followed by a bang (`!`): `///!`\n\nTriple-slash comments (known as \"outer doc comments\") apply to items that follow it.\nAn outer doc comment followed by a bang (i.e. `///!`) has no specific meaning.\n\nThe user most likely meant to write an inner doc comment (`//!`, `/*!`), which\napplies to the parent item (i.e. the item that the comment is contained in,\nusually a module or crate)."
    },
    {
      "id": "clippy::empty_docs",
      "name": "EMPTY_DOCS",
      "snake_name": "empty_docs",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "docstrings exist but documentation is empty",
      "what_it_does": "Detects documentation that is empty.",
      "why_bad": "Empty docs clutter code without adding value, reducing readability and maintainability.",
      "example": "```no_run\n///\nfn returns_true() -> bool {\ntrue\n}\n```\nUse instead:\n```no_run\nfn returns_true() -> bool {\ntrue\n}\n```",
      "version": "1.78.0",
      "source_file": "mod.rs",
      "embedding_text": "docstrings exist but documentation is empty\n\nDetects documentation that is empty.\n\nEmpty docs clutter code without adding value, reducing readability and maintainability."
    },
    {
      "id": "clippy::doc_lazy_continuation",
      "name": "DOC_LAZY_CONTINUATION",
      "snake_name": "doc_lazy_continuation",
      "category": "style",
      "weight": 0.95,
      "brief": "require every line of a paragraph to be indented and marked",
      "what_it_does": "In CommonMark Markdown, the language used to write doc comments, a\nparagraph nested within a list or block quote does not need any line\nafter the first one to be indented or marked. The specification calls\nthis a \"lazy paragraph continuation.\"",
      "why_bad": "This is easy to write but hard to read. Lazy continuations makes\nunintended markers hard to see, and make it harder to deduce the\ndocument's intended structure.",
      "example": "This table is probably intended to have two rows,\nbut it does not. It has zero rows, and is followed by\na block quote.\n```no_run\n/// Range | Description\n/// ----- | -----------\n/// >= 1  | fully opaque\n/// < 1   | partially see-through\nfn set_opacity(opacity: f32) {}\n```\n\nFix it by escaping the marker:\n```no_run\n/// Range | Description\n/// ----- | -----------\n/// \\>= 1 | fully opaque\n/// < 1   | partially see-through\nfn set_opacity(opacity: f32) {}\n```\n\nThis example is actually intended to be a list:\n```no_run\n/// * Do nothing.\n/// * Then do something. Whatever it is needs done,\n/// it should be done right now.\n# fn do_stuff() {}\n```\n\nFix it by indenting the list contents:\n```no_run\n/// * Do nothing.\n/// * Then do something. Whatever it is needs done,\n///   it should be done right now.\n# fn do_stuff() {}\n```",
      "version": "1.80.0",
      "source_file": "mod.rs",
      "embedding_text": "require every line of a paragraph to be indented and marked\n\nIn CommonMark Markdown, the language used to write doc comments, a\nparagraph nested within a list or block quote does not need any line\nafter the first one to be indented or marked. The specification calls\nthis a \"lazy paragraph continuation.\"\n\nThis is easy to write but hard to read. Lazy continuations makes\nunintended markers hard to see, and make it harder to deduce the\ndocument's intended structure."
    },
    {
      "id": "clippy::doc_overindented_list_items",
      "name": "DOC_OVERINDENTED_LIST_ITEMS",
      "snake_name": "doc_overindented_list_items",
      "category": "style",
      "weight": 0.95,
      "brief": "ensure list items are not overindented",
      "what_it_does": "Detects overindented list items in doc comments where the continuation\nlines are indented more than necessary.",
      "why_bad": "Overindented list items in doc comments can lead to inconsistent and\npoorly formatted documentation when rendered. Excessive indentation may\ncause the text to be misinterpreted as a nested list item or code block,\naffecting readability and the overall structure of the documentation.",
      "example": "```no_run\n/// - This is the first item in a list\n///      and this line is overindented.\n# fn foo() {}\n```\n\nFixes this into:\n```no_run\n/// - This is the first item in a list\n///   and this line is overindented.\n# fn foo() {}\n```",
      "version": "1.86.0",
      "source_file": "mod.rs",
      "embedding_text": "ensure list items are not overindented\n\nDetects overindented list items in doc comments where the continuation\nlines are indented more than necessary.\n\nOverindented list items in doc comments can lead to inconsistent and\npoorly formatted documentation when rendered. Excessive indentation may\ncause the text to be misinterpreted as a nested list item or code block,\naffecting readability and the overall structure of the documentation."
    },
    {
      "id": "clippy::too_long_first_doc_paragraph",
      "name": "TOO_LONG_FIRST_DOC_PARAGRAPH",
      "snake_name": "too_long_first_doc_paragraph",
      "category": "nursery",
      "weight": 0.9,
      "brief": "ensure the first documentation paragraph is short",
      "what_it_does": "Checks if the first paragraph in the documentation of items listed in the module page is too long.",
      "why_bad": "Documentation will show the first paragraph of the docstring in the summary page of a\nmodule. Having a nice, short summary in the first paragraph is part of writing good docs.",
      "example": "```no_run\n/// A very short summary.\n/// A much longer explanation that goes into a lot more detail about\n/// how the thing works, possibly with doclinks and so one,\n/// and probably spanning a many rows.\nstruct Foo {}\n```\nUse instead:\n```no_run\n/// A very short summary.\n///\n/// A much longer explanation that goes into a lot more detail about\n/// how the thing works, possibly with doclinks and so one,\n/// and probably spanning a many rows.\nstruct Foo {}\n```",
      "version": "1.82.0",
      "source_file": "mod.rs",
      "embedding_text": "ensure the first documentation paragraph is short\n\nChecks if the first paragraph in the documentation of items listed in the module page is too long.\n\nDocumentation will show the first paragraph of the docstring in the summary page of a\nmodule. Having a nice, short summary in the first paragraph is part of writing good docs."
    },
    {
      "id": "clippy::doc_include_without_cfg",
      "name": "DOC_INCLUDE_WITHOUT_CFG",
      "snake_name": "doc_include_without_cfg",
      "category": "restriction",
      "weight": 1.0,
      "brief": "check if files included in documentation are behind `cfg(doc)`",
      "what_it_does": "Checks if included files in doc comments are included only for `cfg(doc)`.",
      "why_bad": "These files are not useful for compilation but will still be included.\nAlso, if any of these non-source code file is updated, it will trigger a\nrecompilation.",
      "example": "```ignore\n#![doc = include_str!(\"some_file.md\")]\n```\nUse instead:\n```no_run\n#![cfg_attr(doc, doc = include_str!(\"some_file.md\"))]\n```",
      "version": "1.85.0",
      "source_file": "mod.rs",
      "embedding_text": "check if files included in documentation are behind `cfg(doc)`\n\nChecks if included files in doc comments are included only for `cfg(doc)`.\n\nThese files are not useful for compilation but will still be included.\nAlso, if any of these non-source code file is updated, it will trigger a\nrecompilation."
    },
    {
      "id": "clippy::doc_nested_refdefs",
      "name": "DOC_NESTED_REFDEFS",
      "snake_name": "doc_nested_refdefs",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "link reference defined in list item or quote",
      "what_it_does": "Warns if a link reference definition appears at the start of a\nlist item or quote.",
      "why_bad": "This is probably intended as an intra-doc link. If it is really\nsupposed to be a reference definition, it can be written outside\nof the list item or quote.",
      "example": "```no_run\n//! - [link]: description\n```\nUse instead:\n```no_run\n//! - [link][]: description (for intra-doc link)\n//!\n//! [link]: destination (for link reference definition)\n```",
      "version": "1.85.0",
      "source_file": "mod.rs",
      "embedding_text": "link reference defined in list item or quote\n\nWarns if a link reference definition appears at the start of a\nlist item or quote.\n\nThis is probably intended as an intra-doc link. If it is really\nsupposed to be a reference definition, it can be written outside\nof the list item or quote."
    },
    {
      "id": "clippy::doc_comment_double_space_linebreaks",
      "name": "DOC_COMMENT_DOUBLE_SPACE_LINEBREAKS",
      "snake_name": "doc_comment_double_space_linebreaks",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "double-space used for doc comment linebreak instead of `\\\\`",
      "what_it_does": "Detects doc comment linebreaks that use double spaces to separate lines, instead of back-slash (`\\`).",
      "why_bad": "Double spaces, when used as doc comment linebreaks, can be difficult to see, and may\naccidentally be removed during automatic formatting or manual refactoring. The use of a back-slash (`\\`)\nis clearer in this regard.",
      "example": "The two replacement dots in this example represent a double space.\n```no_run\n/// This command takes two numbers as inputs and\u00b7\u00b7\n/// adds them together, and then returns the result.\nfn add(l: i32, r: i32) -> i32 {\nl + r\n}\n```\n\nUse instead:\n```no_run\n/// This command takes two numbers as inputs and\\\n/// adds them together, and then returns the result.\nfn add(l: i32, r: i32) -> i32 {\nl + r\n}\n```",
      "version": "1.87.0",
      "source_file": "mod.rs",
      "embedding_text": "double-space used for doc comment linebreak instead of `\\\\`\n\nDetects doc comment linebreaks that use double spaces to separate lines, instead of back-slash (`\\`).\n\nDouble spaces, when used as doc comment linebreaks, can be difficult to see, and may\naccidentally be removed during automatic formatting or manual refactoring. The use of a back-slash (`\\`)\nis clearer in this regard."
    },
    {
      "id": "clippy::doc_suspicious_footnotes",
      "name": "DOC_SUSPICIOUS_FOOTNOTES",
      "snake_name": "doc_suspicious_footnotes",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "looks like a link or footnote ref, but with no definition",
      "what_it_does": "Detects syntax that looks like a footnote reference.\n\nRustdoc footnotes are compatible with GitHub-Flavored Markdown (GFM).\nGFM does not parse a footnote reference unless its definition also\nexists. This lint checks for footnote references with missing\ndefinitions, unless it thinks you're writing a regex.",
      "why_bad": "This probably means that a footnote was meant to exist,\nbut was not written.",
      "example": "```no_run\n/// This is not a footnote[^1], because no definition exists.\nfn my_fn() {}\n```\nUse instead:\n```no_run\n/// This is a footnote[^1].\n///\n/// [^1]: defined here\nfn my_fn() {}\n```",
      "version": "1.89.0",
      "source_file": "mod.rs",
      "embedding_text": "looks like a link or footnote ref, but with no definition\n\nDetects syntax that looks like a footnote reference.\n\nRustdoc footnotes are compatible with GitHub-Flavored Markdown (GFM).\nGFM does not parse a footnote reference unless its definition also\nexists. This lint checks for footnote references with missing\ndefinitions, unless it thinks you're writing a regex.\n\nThis probably means that a footnote was meant to exist,\nbut was not written."
    },
    {
      "id": "clippy::doc_paragraphs_missing_punctuation",
      "name": "DOC_PARAGRAPHS_MISSING_PUNCTUATION",
      "snake_name": "doc_paragraphs_missing_punctuation",
      "category": "restriction",
      "weight": 1.0,
      "brief": "missing terminal punctuation in doc comments",
      "what_it_does": "Checks for doc comments whose paragraphs do not end with a period or another punctuation mark.\nVarious Markdowns constructs are taken into account to avoid false positives.",
      "why_bad": "A project may wish to enforce consistent doc comments by making sure paragraphs end with a\npunctuation mark.",
      "example": "```no_run\n/// Returns a random number\n///\n/// It was chosen by a fair dice roll\n```\nUse instead:\n```no_run\n/// Returns a random number.\n///\n/// It was chosen by a fair dice roll.\n```",
      "version": "1.93.0",
      "source_file": "mod.rs",
      "embedding_text": "missing terminal punctuation in doc comments\n\nChecks for doc comments whose paragraphs do not end with a period or another punctuation mark.\nVarious Markdowns constructs are taken into account to avoid false positives.\n\nA project may wish to enforce consistent doc comments by making sure paragraphs end with a\npunctuation mark."
    },
    {
      "id": "clippy::double_parens",
      "name": "DOUBLE_PARENS",
      "snake_name": "double_parens",
      "category": "complexity",
      "weight": 1.0,
      "brief": "Warn on unnecessary double parentheses",
      "what_it_does": "Checks for unnecessary double parentheses.",
      "why_bad": "This makes code harder to read and might indicate a\nmistake.",
      "example": "```no_run\nfn simple_double_parens() -> i32 {\n((0))\n}\n\n# fn foo(bar: usize) {}\nfoo((0));\n```\n\nUse instead:\n```no_run\nfn simple_no_parens() -> i32 {\n(0)\n}\n\n# fn foo(bar: usize) {}\nfoo(0);\n```",
      "version": "pre 1.29.0",
      "source_file": "double_parens.rs",
      "embedding_text": "Warn on unnecessary double parentheses\n\nChecks for unnecessary double parentheses.\n\nThis makes code harder to read and might indicate a\nmistake."
    },
    {
      "id": "clippy::drop_non_drop",
      "name": "DROP_NON_DROP",
      "snake_name": "drop_non_drop",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "call to `std::mem::drop` with a value which does not implement `Drop`",
      "what_it_does": "Checks for calls to `std::mem::drop` with a value that does not implement `Drop`.",
      "why_bad": "Calling `std::mem::drop` is no different than dropping such a type. A different value may\nhave been intended.",
      "example": "```no_run\nstruct Foo;\nlet x = Foo;\nstd::mem::drop(x);\n```",
      "version": "1.62.0",
      "source_file": "drop_forget_ref.rs",
      "embedding_text": "call to `std::mem::drop` with a value which does not implement `Drop`\n\nChecks for calls to `std::mem::drop` with a value that does not implement `Drop`.\n\nCalling `std::mem::drop` is no different than dropping such a type. A different value may\nhave been intended."
    },
    {
      "id": "clippy::forget_non_drop",
      "name": "FORGET_NON_DROP",
      "snake_name": "forget_non_drop",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "call to `std::mem::forget` with a value which does not implement `Drop`",
      "what_it_does": "Checks for calls to `std::mem::forget` with a value that does not implement `Drop`.",
      "why_bad": "Calling `std::mem::forget` is no different than dropping such a type. A different value may\nhave been intended.",
      "example": "```no_run\nstruct Foo;\nlet x = Foo;\nstd::mem::forget(x);\n```",
      "version": "1.62.0",
      "source_file": "drop_forget_ref.rs",
      "embedding_text": "call to `std::mem::forget` with a value which does not implement `Drop`\n\nChecks for calls to `std::mem::forget` with a value that does not implement `Drop`.\n\nCalling `std::mem::forget` is no different than dropping such a type. A different value may\nhave been intended."
    },
    {
      "id": "clippy::mem_forget",
      "name": "MEM_FORGET",
      "snake_name": "mem_forget",
      "category": "restriction",
      "weight": 1.0,
      "brief": "`mem::forget` usage on `Drop` types, likely to cause memory leaks",
      "what_it_does": "Checks for usage of `std::mem::forget(t)` where `t` is\n`Drop` or has a field that implements `Drop`.",
      "why_bad": "`std::mem::forget(t)` prevents `t` from running its destructor, possibly causing leaks.\nIt is not possible to detect all means of creating leaks, but it may be desirable to\nprohibit the simple ones.",
      "example": "```no_run\n# use std::mem;\n# use std::rc::Rc;\nmem::forget(Rc::new(55))\n```",
      "version": "pre 1.29.0",
      "source_file": "drop_forget_ref.rs",
      "embedding_text": "`mem::forget` usage on `Drop` types, likely to cause memory leaks\n\nChecks for usage of `std::mem::forget(t)` where `t` is\n`Drop` or has a field that implements `Drop`.\n\n`std::mem::forget(t)` prevents `t` from running its destructor, possibly causing leaks.\nIt is not possible to detect all means of creating leaks, but it may be desirable to\nprohibit the simple ones."
    },
    {
      "id": "clippy::duplicate_mod",
      "name": "DUPLICATE_MOD",
      "snake_name": "duplicate_mod",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "file loaded as module multiple times",
      "what_it_does": "Checks for files that are included as modules multiple times.",
      "why_bad": "Loading a file as a module more than once causes it to be compiled\nmultiple times, taking longer and putting duplicate content into the\nmodule tree.",
      "example": "```rust,ignore\n// lib.rs\nmod a;\nmod b;\n```\n```rust,ignore\n// a.rs\n#[path = \"./b.rs\"]\nmod b;\n```\n\nUse instead:\n\n```rust,ignore\n// lib.rs\nmod a;\nmod b;\n```\n```rust,ignore\n// a.rs\nuse crate::b;\n```",
      "version": "1.63.0",
      "source_file": "duplicate_mod.rs",
      "embedding_text": "file loaded as module multiple times\n\nChecks for files that are included as modules multiple times.\n\nLoading a file as a module more than once causes it to be compiled\nmultiple times, taking longer and putting duplicate content into the\nmodule tree."
    },
    {
      "id": "clippy::else_if_without_else",
      "name": "ELSE_IF_WITHOUT_ELSE",
      "snake_name": "else_if_without_else",
      "category": "restriction",
      "weight": 1.0,
      "brief": "`if` expression with an `else if`, but without a final `else` branch",
      "what_it_does": "Checks for usage of if expressions with an `else if` branch,\nbut without a final `else` branch.",
      "why_bad": "Some coding guidelines require this (e.g., MISRA-C:2004 Rule 14.10).",
      "example": "```no_run\n# fn a() {}\n# fn b() {}\n# let x: i32 = 1;\nif x.is_positive() {\na();\n} else if x.is_negative() {\nb();\n}\n```\n\nUse instead:\n\n```no_run\n# fn a() {}\n# fn b() {}\n# let x: i32 = 1;\nif x.is_positive() {\na();\n} else if x.is_negative() {\nb();\n} else {\n// We don't care about zero.\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "else_if_without_else.rs",
      "embedding_text": "`if` expression with an `else if`, but without a final `else` branch\n\nChecks for usage of if expressions with an `else if` branch,\nbut without a final `else` branch.\n\nSome coding guidelines require this (e.g., MISRA-C:2004 Rule 14.10)."
    },
    {
      "id": "clippy::empty_drop",
      "name": "EMPTY_DROP",
      "snake_name": "empty_drop",
      "category": "restriction",
      "weight": 1.0,
      "brief": "empty `Drop` implementations",
      "what_it_does": "Checks for empty `Drop` implementations.",
      "why_bad": "Empty `Drop` implementations have no effect when dropping an instance of the type. They are\nmost likely useless. However, an empty `Drop` implementation prevents a type from being\ndestructured, which might be the intention behind adding the implementation as a marker.",
      "example": "```no_run\nstruct S;\n\nimpl Drop for S {\nfn drop(&mut self) {}\n}\n```\nUse instead:\n```no_run\nstruct S;\n```",
      "version": "1.62.0",
      "source_file": "empty_drop.rs",
      "embedding_text": "empty `Drop` implementations\n\nChecks for empty `Drop` implementations.\n\nEmpty `Drop` implementations have no effect when dropping an instance of the type. They are\nmost likely useless. However, an empty `Drop` implementation prevents a type from being\ndestructured, which might be the intention behind adding the implementation as a marker."
    },
    {
      "id": "clippy::empty_enums",
      "name": "EMPTY_ENUMS",
      "snake_name": "empty_enums",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "enum with no variants",
      "what_it_does": "Checks for `enum`s with no variants, which therefore are uninhabited types\n(cannot be instantiated).\n\nAs of this writing, the `never_type` is still a nightly-only experimental API.\nTherefore, this lint is only triggered if `#![feature(never_type)]` is enabled.",
      "why_bad": "* If you only want a type which can\u2019t be instantiated, you should use [`!`]\n(the primitive type \"never\"), because [`!`] has more extensive compiler support\n(type inference, etc.) and implementations of common traits.\n\n* If you need to introduce a distinct type, consider using a [newtype] `struct`\ncontaining [`!`] instead (`struct MyType(pub !)`), because it is more idiomatic\nto use a `struct` rather than an `enum` when an `enum` is unnecessary.\n\nIf you do this, note that the [visibility] of the [`!`] field determines whether\nthe uninhabitedness is visible in documentation, and whether it can be pattern\nmatched to mark code unreachable. If the field is not visible, then the struct\nacts like any other struct with private fields.\n\nFor further information, visit\n[the never type\u2019s documentation][`!`].",
      "example": "```no_run\nenum CannotExist {}\n```\n\nUse instead:\n```no_run\n#![feature(never_type)]\n\n/// Use the `!` type directly...\ntype CannotExist = !;\n\n/// ...or define a newtype which is distinct.\nstruct CannotExist2(pub !);\n```\n\n[`!`]: https://doc.rust-lang.org/std/primitive.never.html\n[cfg]: https://doc.rust-lang.org/reference/conditional-compilation.html\n[newtype]: https://doc.rust-lang.org/book/ch19-04-advanced-types.html#using-the-newtype-pattern-for-type-safety-and-abstraction\n[visibility]: https://doc.rust-lang.org/reference/visibility-and-privacy.html",
      "version": "pre 1.29.0",
      "source_file": "empty_enums.rs",
      "embedding_text": "enum with no variants\n\nChecks for `enum`s with no variants, which therefore are uninhabited types\n(cannot be instantiated).\n\nAs of this writing, the `never_type` is still a nightly-only experimental API.\nTherefore, this lint is only triggered if `#![feature(never_type)]` is enabled.\n\n* If you only want a type which can\u2019t be instantiated, you should use [`!`]\n(the primitive type \"never\"), because [`!`] has more extensive compiler support\n(type inference, etc.) and implementations of common traits.\n\n* If you need to introduce a distinct type, consider using a [newtype] `struct`\ncontaining [`!`] instead (`struct MyType(pub !)`), because it is more idiomatic\nto use a `struct` rather than an `enum` when an `enum` is unnecessary.\n\nIf you do this, note that the [visibility] of the [`!`] field determines whether\nthe uninhabitedness is visible in documentation, and whether it can be pattern\nmatched to mark code unreachable. If the field is not visible, then the struct\nacts like any other struct with private fields.\n\nFor further information, visit\n[the never type\u2019s documentation][`!`]."
    },
    {
      "id": "clippy::empty_line_after_outer_attr",
      "name": "EMPTY_LINE_AFTER_OUTER_ATTR",
      "snake_name": "empty_line_after_outer_attr",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "empty line after outer attribute",
      "what_it_does": "Checks for empty lines after outer attributes",
      "why_bad": "The attribute may have meant to be an inner attribute (`#![attr]`). If\nit was meant to be an outer attribute (`#[attr]`) then the empty line\nshould be removed",
      "example": "```no_run\n#[allow(dead_code)]\n\nfn not_quite_good_code() {}\n```\n\nUse instead:\n```no_run\n// Good (as inner attribute)\n#![allow(dead_code)]\n\nfn this_is_fine() {}\n\n// or\n\n// Good (as outer attribute)\n#[allow(dead_code)]\nfn this_is_fine_too() {}\n```",
      "version": "pre 1.29.0",
      "source_file": "empty_line_after.rs",
      "embedding_text": "empty line after outer attribute\n\nChecks for empty lines after outer attributes\n\nThe attribute may have meant to be an inner attribute (`#![attr]`). If\nit was meant to be an outer attribute (`#[attr]`) then the empty line\nshould be removed"
    },
    {
      "id": "clippy::empty_line_after_doc_comments",
      "name": "EMPTY_LINE_AFTER_DOC_COMMENTS",
      "snake_name": "empty_line_after_doc_comments",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "empty line after doc comments",
      "what_it_does": "Checks for empty lines after doc comments.",
      "why_bad": "The doc comment may have meant to be an inner doc comment, regular\ncomment or applied to some old code that is now commented out. If it was\nintended to be a doc comment, then the empty line should be removed.",
      "example": "```no_run\n/// Some doc comment with a blank line after it.\n\nfn f() {}\n\n/// Docs for `old_code`\n// fn old_code() {}\n\nfn new_code() {}\n```\n\nUse instead:\n```no_run\n//! Convert it to an inner doc comment\n\n// Or a regular comment\n\n/// Or remove the empty line\nfn f() {}\n\n// /// Docs for `old_code`\n// fn old_code() {}\n\nfn new_code() {}\n```",
      "version": "1.70.0",
      "source_file": "empty_line_after.rs",
      "embedding_text": "empty line after doc comments\n\nChecks for empty lines after doc comments.\n\nThe doc comment may have meant to be an inner doc comment, regular\ncomment or applied to some old code that is now commented out. If it was\nintended to be a doc comment, then the empty line should be removed."
    },
    {
      "id": "clippy::empty_structs_with_brackets",
      "name": "EMPTY_STRUCTS_WITH_BRACKETS",
      "snake_name": "empty_structs_with_brackets",
      "category": "restriction",
      "weight": 1.0,
      "brief": "finds struct declarations with empty brackets",
      "what_it_does": "Finds structs without fields (a so-called \"empty struct\") that are declared with brackets.",
      "why_bad": "Empty brackets after a struct declaration can be omitted,\nand it may be desirable to do so consistently for style.\n\nHowever, removing the brackets also introduces a public constant named after the struct,\nso this is not just a syntactic simplification but an API change, and adding them back\nis a *breaking* API change.",
      "example": "```no_run\nstruct Cookie {}\nstruct Biscuit();\n```\nUse instead:\n```no_run\nstruct Cookie;\nstruct Biscuit;\n```",
      "version": "1.62.0",
      "source_file": "empty_with_brackets.rs",
      "embedding_text": "finds struct declarations with empty brackets\n\nFinds structs without fields (a so-called \"empty struct\") that are declared with brackets.\n\nEmpty brackets after a struct declaration can be omitted,\nand it may be desirable to do so consistently for style.\n\nHowever, removing the brackets also introduces a public constant named after the struct,\nso this is not just a syntactic simplification but an API change, and adding them back\nis a *breaking* API change."
    },
    {
      "id": "clippy::empty_enum_variants_with_brackets",
      "name": "EMPTY_ENUM_VARIANTS_WITH_BRACKETS",
      "snake_name": "empty_enum_variants_with_brackets",
      "category": "restriction",
      "weight": 1.0,
      "brief": "finds enum variants with empty brackets",
      "what_it_does": "Finds enum variants without fields that are declared with empty brackets.",
      "why_bad": "Empty brackets after a enum variant declaration are redundant and can be omitted,\nand it may be desirable to do so consistently for style.\n\nHowever, removing the brackets also introduces a public constant named after the variant,\nso this is not just a syntactic simplification but an API change, and adding them back\nis a *breaking* API change.",
      "example": "```no_run\nenum MyEnum {\nHasData(u8),\nHasNoData(),       // redundant parentheses\nNoneHereEither {}, // redundant braces\n}\n```\n\nUse instead:\n```no_run\nenum MyEnum {\nHasData(u8),\nHasNoData,\nNoneHereEither,\n}\n```",
      "version": "1.77.0",
      "source_file": "empty_with_brackets.rs",
      "embedding_text": "finds enum variants with empty brackets\n\nFinds enum variants without fields that are declared with empty brackets.\n\nEmpty brackets after a enum variant declaration are redundant and can be omitted,\nand it may be desirable to do so consistently for style.\n\nHowever, removing the brackets also introduces a public constant named after the variant,\nso this is not just a syntactic simplification but an API change, and adding them back\nis a *breaking* API change."
    },
    {
      "id": "clippy::host_endian_bytes",
      "name": "HOST_ENDIAN_BYTES",
      "snake_name": "host_endian_bytes",
      "category": "restriction",
      "weight": 1.0,
      "brief": "disallows usage of the `to_ne_bytes` method",
      "what_it_does": "Checks for the usage of the `to_ne_bytes` method and/or the function `from_ne_bytes`.",
      "why_bad": "To ensure use of explicitly chosen endianness rather than the target\u2019s endianness,\nsuch as when implementing network protocols or file formats rather than FFI.",
      "example": "```rust,ignore\nlet _x = 2i32.to_ne_bytes();\nlet _y = 2i64.to_ne_bytes();\n```",
      "version": "1.72.0",
      "source_file": "endian_bytes.rs",
      "embedding_text": "disallows usage of the `to_ne_bytes` method\n\nChecks for the usage of the `to_ne_bytes` method and/or the function `from_ne_bytes`.\n\nTo ensure use of explicitly chosen endianness rather than the target\u2019s endianness,\nsuch as when implementing network protocols or file formats rather than FFI."
    },
    {
      "id": "clippy::little_endian_bytes",
      "name": "LITTLE_ENDIAN_BYTES",
      "snake_name": "little_endian_bytes",
      "category": "restriction",
      "weight": 1.0,
      "brief": "disallows usage of the `to_le_bytes` method",
      "what_it_does": "Checks for the usage of the `to_le_bytes` method and/or the function `from_le_bytes`.",
      "why_bad": "To ensure use of big-endian or the target\u2019s endianness rather than little-endian.",
      "example": "```rust,ignore\nlet _x = 2i32.to_le_bytes();\nlet _y = 2i64.to_le_bytes();\n```",
      "version": "1.72.0",
      "source_file": "endian_bytes.rs",
      "embedding_text": "disallows usage of the `to_le_bytes` method\n\nChecks for the usage of the `to_le_bytes` method and/or the function `from_le_bytes`.\n\nTo ensure use of big-endian or the target\u2019s endianness rather than little-endian."
    },
    {
      "id": "clippy::big_endian_bytes",
      "name": "BIG_ENDIAN_BYTES",
      "snake_name": "big_endian_bytes",
      "category": "restriction",
      "weight": 1.0,
      "brief": "disallows usage of the `to_be_bytes` method",
      "what_it_does": "Checks for the usage of the `to_be_bytes` method and/or the function `from_be_bytes`.",
      "why_bad": "To ensure use of little-endian or the target\u2019s endianness rather than big-endian.",
      "example": "```rust,ignore\nlet _x = 2i32.to_be_bytes();\nlet _y = 2i64.to_be_bytes();\n```",
      "version": "1.72.0",
      "source_file": "endian_bytes.rs",
      "embedding_text": "disallows usage of the `to_be_bytes` method\n\nChecks for the usage of the `to_be_bytes` method and/or the function `from_be_bytes`.\n\nTo ensure use of little-endian or the target\u2019s endianness rather than big-endian."
    },
    {
      "id": "clippy::map_entry",
      "name": "MAP_ENTRY",
      "snake_name": "map_entry",
      "category": "perf",
      "weight": 1.0,
      "brief": "use of `contains_key` followed by `insert` on a `HashMap` or `BTreeMap`",
      "what_it_does": "Checks for usage of `contains_key` + `insert` on `HashMap`\nor `BTreeMap`.",
      "why_bad": "Using `entry` is more efficient.",
      "example": "```no_run\n# use std::collections::HashMap;\n# let mut map = HashMap::new();\n# let k = 1;\n# let v = 1;\nif !map.contains_key(&k) {\nmap.insert(k, v);\n}\n```\nUse instead:\n```no_run\n# use std::collections::HashMap;\n# let mut map = HashMap::new();\n# let k = 1;\n# let v = 1;\nmap.entry(k).or_insert(v);\n```",
      "version": "pre 1.29.0",
      "source_file": "entry.rs",
      "embedding_text": "use of `contains_key` followed by `insert` on a `HashMap` or `BTreeMap`\n\nChecks for usage of `contains_key` + `insert` on `HashMap`\nor `BTreeMap`.\n\nUsing `entry` is more efficient."
    },
    {
      "id": "clippy::enum_clike_unportable_variant",
      "name": "ENUM_CLIKE_UNPORTABLE_VARIANT",
      "snake_name": "enum_clike_unportable_variant",
      "category": "correctness",
      "weight": 1.2,
      "brief": "C-like enums that are `repr(isize/usize)` and have values that don't fit into an `i32`",
      "what_it_does": "Checks for C-like enumerations that are\n`repr(isize/usize)` and have values that don't fit into an `i32`.",
      "why_bad": "This will truncate the variant value on 32 bit\narchitectures, but works fine on 64 bit.",
      "example": "```no_run\n# #[cfg(target_pointer_width = \"64\")]\n#[repr(usize)]\nenum NonPortable {\nX = 0x1_0000_0000,\nY = 0,\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "enum_clike.rs",
      "embedding_text": "C-like enums that are `repr(isize/usize)` and have values that don't fit into an `i32`\n\nChecks for C-like enumerations that are\n`repr(isize/usize)` and have values that don't fit into an `i32`.\n\nThis will truncate the variant value on 32 bit\narchitectures, but works fine on 64 bit."
    },
    {
      "id": "clippy::equatable_if_let",
      "name": "EQUATABLE_IF_LET",
      "snake_name": "equatable_if_let",
      "category": "nursery",
      "weight": 0.9,
      "brief": "using pattern matching instead of equality",
      "what_it_does": "Checks for pattern matchings that can be expressed using equality.",
      "why_bad": "* It reads better and has less cognitive load because equality won't cause binding.\n* It is a [Yoda condition](https://en.wikipedia.org/wiki/Yoda_conditions). Yoda conditions are widely\ncriticized for increasing the cognitive load of reading the code.\n* Equality is a simple bool expression and can be merged with `&&` and `||` and\nreuse if blocks",
      "example": "```rust,ignore\nif let Some(2) = x {\ndo_thing();\n}\n```\nUse instead:\n```rust,ignore\nif x == Some(2) {\ndo_thing();\n}\n```",
      "version": "1.57.0",
      "source_file": "equatable_if_let.rs",
      "embedding_text": "using pattern matching instead of equality\n\nChecks for pattern matchings that can be expressed using equality.\n\n* It reads better and has less cognitive load because equality won't cause binding.\n* It is a [Yoda condition](https://en.wikipedia.org/wiki/Yoda_conditions). Yoda conditions are widely\ncriticized for increasing the cognitive load of reading the code.\n* Equality is a simple bool expression and can be merged with `&&` and `||` and\nreuse if blocks"
    },
    {
      "id": "clippy::error_impl_error",
      "name": "ERROR_IMPL_ERROR",
      "snake_name": "error_impl_error",
      "category": "restriction",
      "weight": 1.0,
      "brief": "exported types named `Error` that implement `Error`",
      "what_it_does": "Checks for types named `Error` that implement `Error`.",
      "why_bad": "It can become confusing when a codebase has 20 types all named `Error`, requiring either\naliasing them in the `use` statement or qualifying them like `my_module::Error`. This\nhinders comprehension, as it requires you to memorize every variation of importing `Error`\nused across a codebase.",
      "example": "```rust,ignore\n#[derive(Debug)]\npub enum Error { ... }\n\nimpl std::fmt::Display for Error { ... }\n\nimpl std::error::Error for Error { ... }\n```",
      "version": "1.73.0",
      "source_file": "error_impl_error.rs",
      "embedding_text": "exported types named `Error` that implement `Error`\n\nChecks for types named `Error` that implement `Error`.\n\nIt can become confusing when a codebase has 20 types all named `Error`, requiring either\naliasing them in the `use` statement or qualifying them like `my_module::Error`. This\nhinders comprehension, as it requires you to memorize every variation of importing `Error`\nused across a codebase."
    },
    {
      "id": "clippy::boxed_local",
      "name": "BOXED_LOCAL",
      "snake_name": "boxed_local",
      "category": "perf",
      "weight": 1.0,
      "brief": "using `Box<T>` where unnecessary",
      "what_it_does": "Checks for usage of `Box<T>` where an unboxed `T` would\nwork fine.",
      "why_bad": "This is an unnecessary allocation, and bad for\nperformance. It is only necessary to allocate if you wish to move the box\ninto something.",
      "example": "```no_run\nfn foo(x: Box<u32>) {}\n```\n\nUse instead:\n```no_run\nfn foo(x: u32) {}\n```",
      "version": "pre 1.29.0",
      "source_file": "escape.rs",
      "embedding_text": "using `Box<T>` where unnecessary\n\nChecks for usage of `Box<T>` where an unboxed `T` would\nwork fine.\n\nThis is an unnecessary allocation, and bad for\nperformance. It is only necessary to allocate if you wish to move the box\ninto something."
    },
    {
      "id": "clippy::redundant_closure",
      "name": "REDUNDANT_CLOSURE",
      "snake_name": "redundant_closure",
      "category": "style",
      "weight": 0.95,
      "brief": "redundant closures, i.e., `|a| foo(a)` (which can be written as just `foo`)",
      "what_it_does": "Checks for closures which just call another function where\nthe function can be called directly. `unsafe` functions, calls where types\nget adjusted or where the callee is marked `#[track_caller]` are ignored.",
      "why_bad": "Needlessly creating a closure adds code for no benefit\nand gives the optimizer more work.",
      "example": "```rust,ignore\nxs.map(|x| foo(x))\n```\n\nUse instead:\n```rust,ignore\n// where `foo(_)` is a plain function that takes the exact argument type of `x`.\nxs.map(foo)\n```",
      "version": "pre 1.29.0",
      "source_file": "eta_reduction.rs",
      "embedding_text": "redundant closures, i.e., `|a| foo(a)` (which can be written as just `foo`)\n\nChecks for closures which just call another function where\nthe function can be called directly. `unsafe` functions, calls where types\nget adjusted or where the callee is marked `#[track_caller]` are ignored.\n\nNeedlessly creating a closure adds code for no benefit\nand gives the optimizer more work."
    },
    {
      "id": "clippy::redundant_closure_for_method_calls",
      "name": "REDUNDANT_CLOSURE_FOR_METHOD_CALLS",
      "snake_name": "redundant_closure_for_method_calls",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "redundant closures for method calls",
      "what_it_does": "Checks for closures which only invoke a method on the closure\nargument and can be replaced by referencing the method directly.",
      "why_bad": "It's unnecessary to create the closure.",
      "example": "```rust,ignore\nSome('a').map(|s| s.to_uppercase());\n```\nmay be rewritten as\n```rust,ignore\nSome('a').map(char::to_uppercase);\n```",
      "version": "1.35.0",
      "source_file": "eta_reduction.rs",
      "embedding_text": "redundant closures for method calls\n\nChecks for closures which only invoke a method on the closure\nargument and can be replaced by referencing the method directly.\n\nIt's unnecessary to create the closure."
    },
    {
      "id": "clippy::struct_excessive_bools",
      "name": "STRUCT_EXCESSIVE_BOOLS",
      "snake_name": "struct_excessive_bools",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "using too many bools in a struct",
      "what_it_does": "Checks for excessive\nuse of bools in structs.",
      "why_bad": "Excessive bools in a struct is often a sign that\nthe type is being used to represent a state\nmachine, which is much better implemented as an\nenum.\n\nThe reason an enum is better for state machines\nover structs is that enums more easily forbid\ninvalid states.\n\nStructs with too many booleans may benefit from refactoring\ninto multi variant enums for better readability and API.",
      "example": "```no_run\nstruct S {\nis_pending: bool,\nis_processing: bool,\nis_finished: bool,\n}\n```\n\nUse instead:\n```no_run\nenum S {\nPending,\nProcessing,\nFinished,\n}\n```",
      "version": "1.43.0",
      "source_file": "excessive_bools.rs",
      "embedding_text": "using too many bools in a struct\n\nChecks for excessive\nuse of bools in structs.\n\nExcessive bools in a struct is often a sign that\nthe type is being used to represent a state\nmachine, which is much better implemented as an\nenum.\n\nThe reason an enum is better for state machines\nover structs is that enums more easily forbid\ninvalid states.\n\nStructs with too many booleans may benefit from refactoring\ninto multi variant enums for better readability and API."
    },
    {
      "id": "clippy::fn_params_excessive_bools",
      "name": "FN_PARAMS_EXCESSIVE_BOOLS",
      "snake_name": "fn_params_excessive_bools",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "using too many bools in function parameters",
      "what_it_does": "Checks for excessive use of\nbools in function definitions.",
      "why_bad": "Calls to such functions\nare confusing and error prone, because it's\nhard to remember argument order and you have\nno type system support to back you up. Using\ntwo-variant enums instead of bools often makes\nAPI easier to use.",
      "example": "```rust,ignore\nfn f(is_round: bool, is_hot: bool) { ... }\n```\n\nUse instead:\n```rust,ignore\nenum Shape {\nRound,\nSpiky,\n}\n\nenum Temperature {\nHot,\nIceCold,\n}\n\nfn f(shape: Shape, temperature: Temperature) { ... }\n```",
      "version": "1.43.0",
      "source_file": "excessive_bools.rs",
      "embedding_text": "using too many bools in function parameters\n\nChecks for excessive use of\nbools in function definitions.\n\nCalls to such functions\nare confusing and error prone, because it's\nhard to remember argument order and you have\nno type system support to back you up. Using\ntwo-variant enums instead of bools often makes\nAPI easier to use."
    },
    {
      "id": "clippy::excessive_nesting",
      "name": "EXCESSIVE_NESTING",
      "snake_name": "excessive_nesting",
      "category": "complexity",
      "weight": 1.0,
      "brief": "checks for blocks nested beyond a certain threshold",
      "what_it_does": "Checks for blocks which are nested beyond a certain threshold.\n\nNote: Even though this lint is warn-by-default, it will only trigger if a maximum nesting level is defined in the clippy.toml file.",
      "why_bad": "It can severely hinder readability.",
      "example": "An example clippy.toml configuration:\n```toml\n# clippy.toml\nexcessive-nesting-threshold = 3\n```\n```rust,ignore\n// lib.rs\npub mod a {\npub struct X;\nimpl X {\npub fn run(&self) {\nif true {\n// etc...\n}\n}\n}\n}\n```\nUse instead:\n```rust,ignore\n// a.rs\nfn private_run(x: &X) {\nif true {\n// etc...\n}\n}\n\npub struct X;\nimpl X {\npub fn run(&self) {\nprivate_run(self);\n}\n}\n```\n```rust,ignore\n// lib.rs\npub mod a;\n```",
      "version": "1.72.0",
      "source_file": "excessive_nesting.rs",
      "embedding_text": "checks for blocks nested beyond a certain threshold\n\nChecks for blocks which are nested beyond a certain threshold.\n\nNote: Even though this lint is warn-by-default, it will only trigger if a maximum nesting level is defined in the clippy.toml file.\n\nIt can severely hinder readability."
    },
    {
      "id": "clippy::exhaustive_enums",
      "name": "EXHAUSTIVE_ENUMS",
      "snake_name": "exhaustive_enums",
      "category": "restriction",
      "weight": 1.0,
      "brief": "detects exported enums that have not been marked #[non_exhaustive]",
      "what_it_does": "Warns on any exported `enum`s that are not tagged `#[non_exhaustive]`",
      "why_bad": "Making an `enum` exhaustive is a stability commitment: adding a variant is a breaking change.\nA project may wish to ensure that there are no exhaustive enums or that every exhaustive\n`enum` is explicitly `#[allow]`ed.",
      "example": "```no_run\nenum Foo {\nBar,\nBaz\n}\n```\nUse instead:\n```no_run\n#[non_exhaustive]\nenum Foo {\nBar,\nBaz\n}\n```",
      "version": "1.51.0",
      "source_file": "exhaustive_items.rs",
      "embedding_text": "detects exported enums that have not been marked #[non_exhaustive]\n\nWarns on any exported `enum`s that are not tagged `#[non_exhaustive]`\n\nMaking an `enum` exhaustive is a stability commitment: adding a variant is a breaking change.\nA project may wish to ensure that there are no exhaustive enums or that every exhaustive\n`enum` is explicitly `#[allow]`ed."
    },
    {
      "id": "clippy::exhaustive_structs",
      "name": "EXHAUSTIVE_STRUCTS",
      "snake_name": "exhaustive_structs",
      "category": "restriction",
      "weight": 1.0,
      "brief": "detects exported structs that have not been marked #[non_exhaustive]",
      "what_it_does": "Warns on any exported `struct`s that are not tagged `#[non_exhaustive]`",
      "why_bad": "Making a `struct` exhaustive is a stability commitment: adding a field is a breaking change.\nA project may wish to ensure that there are no exhaustive structs or that every exhaustive\n`struct` is explicitly `#[allow]`ed.",
      "example": "```no_run\nstruct Foo {\nbar: u8,\nbaz: String,\n}\n```\nUse instead:\n```no_run\n#[non_exhaustive]\nstruct Foo {\nbar: u8,\nbaz: String,\n}\n```",
      "version": "1.51.0",
      "source_file": "exhaustive_items.rs",
      "embedding_text": "detects exported structs that have not been marked #[non_exhaustive]\n\nWarns on any exported `struct`s that are not tagged `#[non_exhaustive]`\n\nMaking a `struct` exhaustive is a stability commitment: adding a field is a breaking change.\nA project may wish to ensure that there are no exhaustive structs or that every exhaustive\n`struct` is explicitly `#[allow]`ed."
    },
    {
      "id": "clippy::exit",
      "name": "EXIT",
      "snake_name": "exit",
      "category": "restriction",
      "weight": 1.0,
      "brief": "detects `std::process::exit` calls outside of `main`",
      "what_it_does": "Detects calls to the `exit()` function that are not in the `main` function. Calls to `exit()`\nimmediately terminate the program.",
      "why_bad": "`exit()` immediately terminates the program with no information other than an exit code.\nThis provides no means to troubleshoot a problem, and may be an unexpected side effect.\n\nCodebases may use this lint to require that all exits are performed either by panicking\n(which produces a message, a code location, and optionally a backtrace)\nor by calling `exit()` from `main()` (which is a single place to look).",
      "example": "",
      "version": "1.41.0",
      "source_file": "exit.rs",
      "embedding_text": "detects `std::process::exit` calls outside of `main`\n\nDetects calls to the `exit()` function that are not in the `main` function. Calls to `exit()`\nimmediately terminate the program.\n\n`exit()` immediately terminates the program with no information other than an exit code.\nThis provides no means to troubleshoot a problem, and may be an unexpected side effect.\n\nCodebases may use this lint to require that all exits are performed either by panicking\n(which produces a message, a code location, and optionally a backtrace)\nor by calling `exit()` from `main()` (which is a single place to look)."
    },
    {
      "id": "clippy::explicit_write",
      "name": "EXPLICIT_WRITE",
      "snake_name": "explicit_write",
      "category": "complexity",
      "weight": 1.0,
      "brief": "using the `write!()` family of functions instead of the `print!()` family of functions, when using the latter would work",
      "what_it_does": "Checks for usage of `write!()` / `writeln()!` which can be\nreplaced with `(e)print!()` / `(e)println!()`",
      "why_bad": "Using `(e)println!` is clearer and more concise",
      "example": "```no_run\n# use std::io::Write;\n# let bar = \"furchtbar\";\nwriteln!(&mut std::io::stderr(), \"foo: {:?}\", bar).unwrap();\nwriteln!(&mut std::io::stdout(), \"foo: {:?}\", bar).unwrap();\n```\n\nUse instead:\n```no_run\n# use std::io::Write;\n# let bar = \"furchtbar\";\neprintln!(\"foo: {:?}\", bar);\nprintln!(\"foo: {:?}\", bar);\n```",
      "version": "pre 1.29.0",
      "source_file": "explicit_write.rs",
      "embedding_text": "using the `write!()` family of functions instead of the `print!()` family of functions, when using the latter would work\n\nChecks for usage of `write!()` / `writeln()!` which can be\nreplaced with `(e)print!()` / `(e)println!()`\n\nUsing `(e)println!` is clearer and more concise"
    },
    {
      "id": "clippy::extra_unused_type_parameters",
      "name": "EXTRA_UNUSED_TYPE_PARAMETERS",
      "snake_name": "extra_unused_type_parameters",
      "category": "complexity",
      "weight": 1.0,
      "brief": "unused type parameters in function definitions",
      "what_it_does": "Checks for type parameters in generics that are never used anywhere else.",
      "why_bad": "Functions cannot infer the value of unused type parameters; therefore, calling them\nrequires using a turbofish, which serves no purpose but to satisfy the compiler.",
      "example": "```no_run\nfn unused_ty<T>(x: u8) {\n// ..\n}\n```\nUse instead:\n```no_run\nfn no_unused_ty(x: u8) {\n// ..\n}\n```",
      "version": "1.69.0",
      "source_file": "extra_unused_type_parameters.rs",
      "embedding_text": "unused type parameters in function definitions\n\nChecks for type parameters in generics that are never used anywhere else.\n\nFunctions cannot infer the value of unused type parameters; therefore, calling them\nrequires using a turbofish, which serves no purpose but to satisfy the compiler."
    },
    {
      "id": "clippy::fallible_impl_from",
      "name": "FALLIBLE_IMPL_FROM",
      "snake_name": "fallible_impl_from",
      "category": "nursery",
      "weight": 0.9,
      "brief": "Warn on impls of `From<..>` that contain `panic!()` or `unwrap()`",
      "what_it_does": "Checks for impls of `From<..>` that contain `panic!()` or `unwrap()`",
      "why_bad": "`TryFrom` should be used if there's a possibility of failure.",
      "example": "```no_run\nstruct Foo(i32);\n\nimpl From<String> for Foo {\nfn from(s: String) -> Self {\nFoo(s.parse().unwrap())\n}\n}\n```\n\nUse instead:\n```no_run\nstruct Foo(i32);\n\nimpl TryFrom<String> for Foo {\ntype Error = ();\nfn try_from(s: String) -> Result<Self, Self::Error> {\nif let Ok(parsed) = s.parse() {\nOk(Foo(parsed))\n} else {\nErr(())\n}\n}\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "fallible_impl_from.rs",
      "embedding_text": "Warn on impls of `From<..>` that contain `panic!()` or `unwrap()`\n\nChecks for impls of `From<..>` that contain `panic!()` or `unwrap()`\n\n`TryFrom` should be used if there's a possibility of failure."
    },
    {
      "id": "clippy::field_scoped_visibility_modifiers",
      "name": "FIELD_SCOPED_VISIBILITY_MODIFIERS",
      "snake_name": "field_scoped_visibility_modifiers",
      "category": "restriction",
      "weight": 1.0,
      "brief": "checks for usage of a scoped visibility modifier, like `pub(crate)`, on fields",
      "what_it_does": "Checks for usage of scoped visibility modifiers, like `pub(crate)`, on fields. These\nmake a field visible within a scope between public and private.",
      "why_bad": "Scoped visibility modifiers cause a field to be accessible within some scope between\npublic and private, potentially within an entire crate. This allows for fields to be\nnon-private while upholding internal invariants, but can be a code smell. Scoped visibility\nrequires checking a greater area, potentially an entire crate, to verify that an invariant\nis upheld, and global analysis requires a lot of effort.",
      "example": "```no_run\npub mod public_module {\nstruct MyStruct {\npub(crate) first_field: bool,\npub(super) second_field: bool\n}\n}\n```\nUse instead:\n```no_run\npub mod public_module {\nstruct MyStruct {\nfirst_field: bool,\nsecond_field: bool\n}\nimpl MyStruct {\npub(crate) fn get_first_field(&self) -> bool {\nself.first_field\n}\npub(super) fn get_second_field(&self) -> bool {\nself.second_field\n}\n}\n}\n```",
      "version": "1.81.0",
      "source_file": "field_scoped_visibility_modifiers.rs",
      "embedding_text": "checks for usage of a scoped visibility modifier, like `pub(crate)`, on fields\n\nChecks for usage of scoped visibility modifiers, like `pub(crate)`, on fields. These\nmake a field visible within a scope between public and private.\n\nScoped visibility modifiers cause a field to be accessible within some scope between\npublic and private, potentially within an entire crate. This allows for fields to be\nnon-private while upholding internal invariants, but can be a code smell. Scoped visibility\nrequires checking a greater area, potentially an entire crate, to verify that an invariant\nis upheld, and global analysis requires a lot of effort."
    },
    {
      "id": "clippy::excessive_precision",
      "name": "EXCESSIVE_PRECISION",
      "snake_name": "excessive_precision",
      "category": "style",
      "weight": 0.95,
      "brief": "excessive precision for float literal",
      "what_it_does": "Checks for float literals with a precision greater\nthan that supported by the underlying type.\n\nThe lint is suppressed for literals with over `const_literal_digits_threshold` digits.",
      "why_bad": "Rust will truncate the literal silently.",
      "example": "```no_run\nlet v: f32 = 0.123_456_789_9;\nprintln!(\"{}\", v); //  0.123_456_789\n```\n\nUse instead:\n```no_run\nlet v: f64 = 0.123_456_789_9;\nprintln!(\"{}\", v); //  0.123_456_789_9\n```",
      "version": "pre 1.29.0",
      "source_file": "float_literal.rs",
      "embedding_text": "excessive precision for float literal\n\nChecks for float literals with a precision greater\nthan that supported by the underlying type.\n\nThe lint is suppressed for literals with over `const_literal_digits_threshold` digits.\n\nRust will truncate the literal silently."
    },
    {
      "id": "clippy::lossy_float_literal",
      "name": "LOSSY_FLOAT_LITERAL",
      "snake_name": "lossy_float_literal",
      "category": "restriction",
      "weight": 1.0,
      "brief": "lossy whole number float literals",
      "what_it_does": "Checks for whole number float literals that\ncannot be represented as the underlying type without loss.",
      "why_bad": "If the value was intended to be exact, it will not be.\nThis may be especially surprising when the lost precision is to the left of the decimal point.",
      "example": "```no_run\nlet _: f32 = 16_777_217.0; // 16_777_216.0\n```\n\nUse instead:\n```no_run\nlet _: f32 = 16_777_216.0;\nlet _: f64 = 16_777_217.0;\n```",
      "version": "1.43.0",
      "source_file": "float_literal.rs",
      "embedding_text": "lossy whole number float literals\n\nChecks for whole number float literals that\ncannot be represented as the underlying type without loss.\n\nIf the value was intended to be exact, it will not be.\nThis may be especially surprising when the lost precision is to the left of the decimal point."
    },
    {
      "id": "clippy::imprecise_flops",
      "name": "IMPRECISE_FLOPS",
      "snake_name": "imprecise_flops",
      "category": "nursery",
      "weight": 0.9,
      "brief": "usage of imprecise floating point operations",
      "what_it_does": "Looks for floating-point expressions that\ncan be expressed using built-in methods to improve accuracy\nat the cost of performance.",
      "why_bad": "Negatively impacts accuracy.",
      "example": "```no_run\nlet a = 3f32;\nlet _ = a.powf(1.0 / 3.0);\nlet _ = (1.0 + a).ln();\nlet _ = a.exp() - 1.0;\n```\n\nUse instead:\n```no_run\nlet a = 3f32;\nlet _ = a.cbrt();\nlet _ = a.ln_1p();\nlet _ = a.exp_m1();\n```",
      "version": "1.43.0",
      "source_file": "floating_point_arithmetic.rs",
      "embedding_text": "usage of imprecise floating point operations\n\nLooks for floating-point expressions that\ncan be expressed using built-in methods to improve accuracy\nat the cost of performance.\n\nNegatively impacts accuracy."
    },
    {
      "id": "clippy::suboptimal_flops",
      "name": "SUBOPTIMAL_FLOPS",
      "snake_name": "suboptimal_flops",
      "category": "nursery",
      "weight": 0.9,
      "brief": "usage of sub-optimal floating point operations",
      "what_it_does": "Looks for floating-point expressions that\ncan be expressed using built-in methods to improve both\naccuracy and performance.",
      "why_bad": "Negatively impacts accuracy and performance.",
      "example": "```no_run\nuse std::f32::consts::E;\n\nlet a = 3f32;\nlet _ = (2f32).powf(a);\nlet _ = E.powf(a);\nlet _ = a.powf(1.0 / 2.0);\nlet _ = a.log(2.0);\nlet _ = a.log(10.0);\nlet _ = a.log(E);\nlet _ = a.powf(2.0);\nlet _ = a * 2.0 + 4.0;\nlet _ = if a < 0.0 {\n-a\n} else {\na\n};\nlet _ = if a < 0.0 {\na\n} else {\n-a\n};\n```\n\nis better expressed as\n\n```no_run\nuse std::f32::consts::E;\n\nlet a = 3f32;\nlet _ = a.exp2();\nlet _ = a.exp();\nlet _ = a.sqrt();\nlet _ = a.log2();\nlet _ = a.log10();\nlet _ = a.ln();\nlet _ = a.powi(2);\nlet _ = a.mul_add(2.0, 4.0);\nlet _ = a.abs();\nlet _ = -a.abs();\n```",
      "version": "1.43.0",
      "source_file": "floating_point_arithmetic.rs",
      "embedding_text": "usage of sub-optimal floating point operations\n\nLooks for floating-point expressions that\ncan be expressed using built-in methods to improve both\naccuracy and performance.\n\nNegatively impacts accuracy and performance."
    },
    {
      "id": "clippy::useless_format",
      "name": "USELESS_FORMAT",
      "snake_name": "useless_format",
      "category": "complexity",
      "weight": 1.0,
      "brief": "useless use of `format!`",
      "what_it_does": "Checks for the use of `format!(\"string literal with no\nargument\")` and `format!(\"{}\", foo)` where `foo` is a string.",
      "why_bad": "There is no point of doing that. `format!(\"foo\")` can\nbe replaced by `\"foo\".to_owned()` if you really need a `String`. The even\nworse `&format!(\"foo\")` is often encountered in the wild. `format!(\"{}\",\nfoo)` can be replaced by `foo.clone()` if `foo: String` or `foo.to_owned()`\nif `foo: &str`.",
      "example": "```no_run\nlet foo = \"foo\";\nformat!(\"{}\", foo);\n```\n\nUse instead:\n```no_run\nlet foo = \"foo\";\nfoo.to_owned();\n```",
      "version": "pre 1.29.0",
      "source_file": "format.rs",
      "embedding_text": "useless use of `format!`\n\nChecks for the use of `format!(\"string literal with no\nargument\")` and `format!(\"{}\", foo)` where `foo` is a string.\n\nThere is no point of doing that. `format!(\"foo\")` can\nbe replaced by `\"foo\".to_owned()` if you really need a `String`. The even\nworse `&format!(\"foo\")` is often encountered in the wild. `format!(\"{}\",\nfoo)` can be replaced by `foo.clone()` if `foo: String` or `foo.to_owned()`\nif `foo: &str`."
    },
    {
      "id": "clippy::format_in_format_args",
      "name": "FORMAT_IN_FORMAT_ARGS",
      "snake_name": "format_in_format_args",
      "category": "perf",
      "weight": 1.0,
      "brief": "`format!` used in a macro that does formatting",
      "what_it_does": "Detects `format!` within the arguments of another macro that does\nformatting such as `format!` itself, `write!` or `println!`. Suggests\ninlining the `format!` call.",
      "why_bad": "The recommended code is both shorter and avoids a temporary allocation.",
      "example": "```no_run\n# use std::panic::Location;\nprintln!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n```\nUse instead:\n```no_run\n# use std::panic::Location;\nprintln!(\"error: something failed at {}\", Location::caller());\n```",
      "version": "1.58.0",
      "source_file": "format_args.rs",
      "embedding_text": "`format!` used in a macro that does formatting\n\nDetects `format!` within the arguments of another macro that does\nformatting such as `format!` itself, `write!` or `println!`. Suggests\ninlining the `format!` call.\n\nThe recommended code is both shorter and avoids a temporary allocation."
    },
    {
      "id": "clippy::unnecessary_debug_formatting",
      "name": "UNNECESSARY_DEBUG_FORMATTING",
      "snake_name": "unnecessary_debug_formatting",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "`Debug` formatting applied to an `OsStr` or `Path` when `.display()` is available",
      "what_it_does": "Checks for `Debug` formatting (`{:?}`) applied to an `OsStr` or `Path`.",
      "why_bad": "Rust doesn't guarantee what `Debug` formatting looks like, and it could\nchange in the future. `OsStr`s and `Path`s can be `Display` formatted\nusing their `display` methods.\n\nFurthermore, with `Debug` formatting, certain characters are escaped.\nThus, a `Debug` formatted `Path` is less likely to be clickable.",
      "example": "```no_run\n# use std::path::Path;\nlet path = Path::new(\"...\");\nprintln!(\"The path is {:?}\", path);\n```\nUse instead:\n```no_run\n# use std::path::Path;\nlet path = Path::new(\"\u2026\");\nprintln!(\"The path is {}\", path.display());\n```",
      "version": "1.87.0",
      "source_file": "format_args.rs",
      "embedding_text": "`Debug` formatting applied to an `OsStr` or `Path` when `.display()` is available\n\nChecks for `Debug` formatting (`{:?}`) applied to an `OsStr` or `Path`.\n\nRust doesn't guarantee what `Debug` formatting looks like, and it could\nchange in the future. `OsStr`s and `Path`s can be `Display` formatted\nusing their `display` methods.\n\nFurthermore, with `Debug` formatting, certain characters are escaped.\nThus, a `Debug` formatted `Path` is less likely to be clickable."
    },
    {
      "id": "clippy::to_string_in_format_args",
      "name": "TO_STRING_IN_FORMAT_ARGS",
      "snake_name": "to_string_in_format_args",
      "category": "perf",
      "weight": 1.0,
      "brief": "`to_string` applied to a type that implements `Display` in format args",
      "what_it_does": "Checks for [`ToString::to_string`](https://doc.rust-lang.org/std/string/trait.ToString.html#tymethod.to_string)\napplied to a type that implements [`Display`](https://doc.rust-lang.org/std/fmt/trait.Display.html)\nin a macro that does formatting.",
      "why_bad": "Since the type implements `Display`, the use of `to_string` is\nunnecessary.",
      "example": "```no_run\n# use std::panic::Location;\nprintln!(\"error: something failed at {}\", Location::caller().to_string());\n```\nUse instead:\n```no_run\n# use std::panic::Location;\nprintln!(\"error: something failed at {}\", Location::caller());\n```",
      "version": "1.58.0",
      "source_file": "format_args.rs",
      "embedding_text": "`to_string` applied to a type that implements `Display` in format args\n\nChecks for [`ToString::to_string`](https://doc.rust-lang.org/std/string/trait.ToString.html#tymethod.to_string)\napplied to a type that implements [`Display`](https://doc.rust-lang.org/std/fmt/trait.Display.html)\nin a macro that does formatting.\n\nSince the type implements `Display`, the use of `to_string` is\nunnecessary."
    },
    {
      "id": "clippy::uninlined_format_args",
      "name": "UNINLINED_FORMAT_ARGS",
      "snake_name": "uninlined_format_args",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "using non-inlined variables in `format!` calls",
      "what_it_does": "Detect when a variable is not inlined in a format string,\nand suggests to inline it.",
      "why_bad": "Non-inlined code is slightly more difficult to read and understand,\nas it requires arguments to be matched against the format string.\nThe inlined syntax, where allowed, is simpler.",
      "example": "```no_run\n# let var = 42;\n# let width = 1;\n# let prec = 2;\nformat!(\"{}\", var);\nformat!(\"{:?}\", var);\nformat!(\"{v:?}\", v = var);\nformat!(\"{0} {0}\", var);\nformat!(\"{0:1$}\", var, width);\nformat!(\"{:.*}\", prec, var);\n```\nUse instead:\n```no_run\n# let var = 42;\n# let width = 1;\n# let prec = 2;\nformat!(\"{var}\");\nformat!(\"{var:?}\");\nformat!(\"{var:?}\");\nformat!(\"{var} {var}\");\nformat!(\"{var:width$}\");\nformat!(\"{var:.prec$}\");\n```\n\nIf `allow-mixed-uninlined-format-args` is set to `false` in clippy.toml,\nthe following code will also trigger the lint:\n```no_run\n# let var = 42;\nformat!(\"{} {}\", var, 1+2);\n```\nUse instead:\n```no_run\n# let var = 42;\nformat!(\"{var} {}\", 1+2);\n```",
      "version": "1.66.0",
      "source_file": "format_args.rs",
      "embedding_text": "using non-inlined variables in `format!` calls\n\nDetect when a variable is not inlined in a format string,\nand suggests to inline it.\n\nNon-inlined code is slightly more difficult to read and understand,\nas it requires arguments to be matched against the format string.\nThe inlined syntax, where allowed, is simpler."
    },
    {
      "id": "clippy::unused_format_specs",
      "name": "UNUSED_FORMAT_SPECS",
      "snake_name": "unused_format_specs",
      "category": "complexity",
      "weight": 1.0,
      "brief": "use of a format specifier that has no effect",
      "what_it_does": "Detects [formatting parameters] that have no effect on the output of\n`format!()`, `println!()` or similar macros.",
      "why_bad": "Shorter format specifiers are easier to read, it may also indicate that\nan expected formatting operation such as adding padding isn't happening.",
      "example": "```no_run\nprintln!(\"{:.}\", 1.0);\n\nprintln!(\"not padded: {:5}\", format_args!(\"...\"));\n```\nUse instead:\n```no_run\nprintln!(\"{}\", 1.0);\n\nprintln!(\"not padded: {}\", format_args!(\"...\"));\n// OR\nprintln!(\"padded: {:5}\", format!(\"...\"));\n```\n\n[formatting parameters]: https://doc.rust-lang.org/std/fmt/index.html#formatting-parameters",
      "version": "1.66.0",
      "source_file": "format_args.rs",
      "embedding_text": "use of a format specifier that has no effect\n\nDetects [formatting parameters] that have no effect on the output of\n`format!()`, `println!()` or similar macros.\n\nShorter format specifiers are easier to read, it may also indicate that\nan expected formatting operation such as adding padding isn't happening."
    },
    {
      "id": "clippy::pointer_format",
      "name": "POINTER_FORMAT",
      "snake_name": "pointer_format",
      "category": "restriction",
      "weight": 1.0,
      "brief": "formatting a pointer",
      "what_it_does": "Detects [pointer format] as well as `Debug` formatting of raw pointers or function pointers\nor any types that have a derived `Debug` impl that recursively contains them.",
      "why_bad": "The addresses are only useful in very specific contexts, and certain projects may want to keep addresses of\ncertain data structures or functions from prying hacker eyes as an additional line of security.",
      "example": "```no_run\nlet foo = &0_u32;\nfn bar() {}\nprintln!(\"{:p}\", foo);\nlet _ = format!(\"{:?}\", &(bar as fn()));\n```\n\n[pointer format]: https://doc.rust-lang.org/std/fmt/index.html#formatting-traits",
      "version": "1.89.0",
      "source_file": "format_args.rs",
      "embedding_text": "formatting a pointer\n\nDetects [pointer format] as well as `Debug` formatting of raw pointers or function pointers\nor any types that have a derived `Debug` impl that recursively contains them.\n\nThe addresses are only useful in very specific contexts, and certain projects may want to keep addresses of\ncertain data structures or functions from prying hacker eyes as an additional line of security."
    },
    {
      "id": "clippy::recursive_format_impl",
      "name": "RECURSIVE_FORMAT_IMPL",
      "snake_name": "recursive_format_impl",
      "category": "correctness",
      "weight": 1.2,
      "brief": "Format trait method called while implementing the same Format trait",
      "what_it_does": "Checks for format trait implementations (e.g. `Display`) with a recursive call to itself\nwhich uses `self` as a parameter.\nThis is typically done indirectly with the `write!` macro or with `to_string()`.",
      "why_bad": "This will lead to infinite recursion and a stack overflow.",
      "example": "```no_run\nuse std::fmt;\n\nstruct Structure(i32);\nimpl fmt::Display for Structure {\nfn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\nwrite!(f, \"{}\", self.to_string())\n}\n}\n\n```\nUse instead:\n```no_run\nuse std::fmt;\n\nstruct Structure(i32);\nimpl fmt::Display for Structure {\nfn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\nwrite!(f, \"{}\", self.0)\n}\n}\n```",
      "version": "1.48.0",
      "source_file": "format_impl.rs",
      "embedding_text": "Format trait method called while implementing the same Format trait\n\nChecks for format trait implementations (e.g. `Display`) with a recursive call to itself\nwhich uses `self` as a parameter.\nThis is typically done indirectly with the `write!` macro or with `to_string()`.\n\nThis will lead to infinite recursion and a stack overflow."
    },
    {
      "id": "clippy::print_in_format_impl",
      "name": "PRINT_IN_FORMAT_IMPL",
      "snake_name": "print_in_format_impl",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "use of a print macro in a formatting trait impl",
      "what_it_does": "Checks for usage of `println`, `print`, `eprintln` or `eprint` in an\nimplementation of a formatting trait.",
      "why_bad": "Using a print macro is likely unintentional since formatting traits\nshould write to the `Formatter`, not stdout/stderr.",
      "example": "```no_run\nuse std::fmt::{Display, Error, Formatter};\n\nstruct S;\nimpl Display for S {\nfn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\nprintln!(\"S\");\n\nOk(())\n}\n}\n```\nUse instead:\n```no_run\nuse std::fmt::{Display, Error, Formatter};\n\nstruct S;\nimpl Display for S {\nfn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\nwriteln!(f, \"S\");\n\nOk(())\n}\n}\n```",
      "version": "1.61.0",
      "source_file": "format_impl.rs",
      "embedding_text": "use of a print macro in a formatting trait impl\n\nChecks for usage of `println`, `print`, `eprintln` or `eprint` in an\nimplementation of a formatting trait.\n\nUsing a print macro is likely unintentional since formatting traits\nshould write to the `Formatter`, not stdout/stderr."
    },
    {
      "id": "clippy::format_push_string",
      "name": "FORMAT_PUSH_STRING",
      "snake_name": "format_push_string",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "`format!(..)` appended to existing `String`",
      "what_it_does": "Detects cases where the result of a `format!` call is\nappended to an existing `String`.",
      "why_bad": "Introduces an extra, avoidable heap allocation.",
      "example": "```no_run\nlet mut s = String::new();\ns += &format!(\"0x{:X}\", 1024);\ns.push_str(&format!(\"0x{:X}\", 1024));\n```\nUse instead:\n```no_run\nuse std::fmt::Write as _; // import without risk of name clashing\n\nlet mut s = String::new();\nlet _ = write!(s, \"0x{:X}\", 1024);\n```",
      "version": "1.62.0",
      "source_file": "format_push_string.rs",
      "embedding_text": "`format!(..)` appended to existing `String`\n\nDetects cases where the result of a `format!` call is\nappended to an existing `String`.\n\nIntroduces an extra, avoidable heap allocation."
    },
    {
      "id": "clippy::suspicious_assignment_formatting",
      "name": "SUSPICIOUS_ASSIGNMENT_FORMATTING",
      "snake_name": "suspicious_assignment_formatting",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "suspicious formatting of `*=`, `-=` or `!=`",
      "what_it_does": "Checks for usage of the non-existent `=*`, `=!` and `=-`\noperators.",
      "why_bad": "This is either a typo of `*=`, `!=` or `-=` or\nconfusing.",
      "example": "```rust,ignore\na =- 42; // confusing, should it be `a -= 42` or `a = -42`?\n```",
      "version": "pre 1.29.0",
      "source_file": "formatting.rs",
      "embedding_text": "suspicious formatting of `*=`, `-=` or `!=`\n\nChecks for usage of the non-existent `=*`, `=!` and `=-`\noperators.\n\nThis is either a typo of `*=`, `!=` or `-=` or\nconfusing."
    },
    {
      "id": "clippy::suspicious_unary_op_formatting",
      "name": "SUSPICIOUS_UNARY_OP_FORMATTING",
      "snake_name": "suspicious_unary_op_formatting",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "suspicious formatting of unary `-` or `!` on the RHS of a BinOp",
      "what_it_does": "Checks the formatting of a unary operator on the right hand side\nof a binary operator. It lints if there is no space between the binary and unary operators,\nbut there is a space between the unary and its operand.",
      "why_bad": "This is either a typo in the binary operator or confusing.",
      "example": "```no_run\n# let foo = true;\n# let bar = false;\n// &&! looks like a different operator\nif foo &&! bar {}\n```\n\nUse instead:\n```no_run\n# let foo = true;\n# let bar = false;\nif foo && !bar {}\n```",
      "version": "1.40.0",
      "source_file": "formatting.rs",
      "embedding_text": "suspicious formatting of unary `-` or `!` on the RHS of a BinOp\n\nChecks the formatting of a unary operator on the right hand side\nof a binary operator. It lints if there is no space between the binary and unary operators,\nbut there is a space between the unary and its operand.\n\nThis is either a typo in the binary operator or confusing."
    },
    {
      "id": "clippy::suspicious_else_formatting",
      "name": "SUSPICIOUS_ELSE_FORMATTING",
      "snake_name": "suspicious_else_formatting",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "suspicious formatting of `else`",
      "what_it_does": "Checks for formatting of `else`. It lints if the `else`\nis followed immediately by a newline or the `else` seems to be missing.",
      "why_bad": "This is probably some refactoring remnant, even if the\ncode is correct, it might look confusing.",
      "example": "```rust,ignore\nif foo {\n} { // looks like an `else` is missing here\n}\n\nif foo {\n} if bar { // looks like an `else` is missing here\n}\n\nif foo {\n} else\n\n{ // this is the `else` block of the previous `if`, but should it be?\n}\n\nif foo {\n} else\n\nif bar { // this is the `else` block of the previous `if`, but should it be?\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "formatting.rs",
      "embedding_text": "suspicious formatting of `else`\n\nChecks for formatting of `else`. It lints if the `else`\nis followed immediately by a newline or the `else` seems to be missing.\n\nThis is probably some refactoring remnant, even if the\ncode is correct, it might look confusing."
    },
    {
      "id": "clippy::possible_missing_else",
      "name": "POSSIBLE_MISSING_ELSE",
      "snake_name": "possible_missing_else",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "possibly missing `else`",
      "what_it_does": "Checks for an `if` expression followed by either a block or another `if` that\nlooks like it should have an `else` between them.",
      "why_bad": "This is probably some refactoring remnant, even if the code is correct, it\nmight look confusing.",
      "example": "```rust,ignore\nif foo {\n} { // looks like an `else` is missing here\n}\n\nif foo {\n} if bar { // looks like an `else` is missing here\n}\n```",
      "version": "1.91.0",
      "source_file": "formatting.rs",
      "embedding_text": "possibly missing `else`\n\nChecks for an `if` expression followed by either a block or another `if` that\nlooks like it should have an `else` between them.\n\nThis is probably some refactoring remnant, even if the code is correct, it\nmight look confusing."
    },
    {
      "id": "clippy::possible_missing_comma",
      "name": "POSSIBLE_MISSING_COMMA",
      "snake_name": "possible_missing_comma",
      "category": "correctness",
      "weight": 1.2,
      "brief": "possible missing comma in array",
      "what_it_does": "Checks for possible missing comma in an array. It lints if\nan array element is a binary operator expression and it lies on two lines.",
      "why_bad": "This could lead to unexpected results.",
      "example": "```rust,ignore\nlet a = &[\n-1, -2, -3 // <= no comma here\n-4, -5, -6\n];\n```",
      "version": "pre 1.29.0",
      "source_file": "formatting.rs",
      "embedding_text": "possible missing comma in array\n\nChecks for possible missing comma in an array. It lints if\nan array element is a binary operator expression and it lies on two lines.\n\nThis could lead to unexpected results."
    },
    {
      "id": "clippy::four_forward_slashes",
      "name": "FOUR_FORWARD_SLASHES",
      "snake_name": "four_forward_slashes",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "comments with 4 forward slashes (`////`) likely intended to be doc comments (`///`)",
      "what_it_does": "Checks for outer doc comments written with 4 forward slashes (`////`).",
      "why_bad": "This is (probably) a typo, and results in it not being a doc comment; just a regular\ncomment.",
      "example": "```no_run\n//// My amazing data structure\npub struct Foo {\n// ...\n}\n```\n\nUse instead:\n```no_run\n/// My amazing data structure\npub struct Foo {\n// ...\n}\n```",
      "version": "1.73.0",
      "source_file": "four_forward_slashes.rs",
      "embedding_text": "comments with 4 forward slashes (`////`) likely intended to be doc comments (`///`)\n\nChecks for outer doc comments written with 4 forward slashes (`////`).\n\nThis is (probably) a typo, and results in it not being a doc comment; just a regular\ncomment."
    },
    {
      "id": "clippy::from_over_into",
      "name": "FROM_OVER_INTO",
      "snake_name": "from_over_into",
      "category": "style",
      "weight": 0.95,
      "brief": "Warns on implementations of `Into<..>` to use `From<..>`",
      "what_it_does": "Searches for implementations of the `Into<..>` trait and suggests to implement `From<..>` instead.",
      "why_bad": "According the std docs implementing `From<..>` is preferred since it gives you `Into<..>` for free where the reverse isn't true.",
      "example": "```no_run\nstruct StringWrapper(String);\n\nimpl Into<StringWrapper> for String {\nfn into(self) -> StringWrapper {\nStringWrapper(self)\n}\n}\n```\nUse instead:\n```no_run\nstruct StringWrapper(String);\n\nimpl From<String> for StringWrapper {\nfn from(s: String) -> StringWrapper {\nStringWrapper(s)\n}\n}\n```",
      "version": "1.51.0",
      "source_file": "from_over_into.rs",
      "embedding_text": "Warns on implementations of `Into<..>` to use `From<..>`\n\nSearches for implementations of the `Into<..>` trait and suggests to implement `From<..>` instead.\n\nAccording the std docs implementing `From<..>` is preferred since it gives you `Into<..>` for free where the reverse isn't true."
    },
    {
      "id": "clippy::from_raw_with_void_ptr",
      "name": "FROM_RAW_WITH_VOID_PTR",
      "snake_name": "from_raw_with_void_ptr",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "creating a `Box` from a void raw pointer",
      "what_it_does": "Checks if we're passing a `c_void` raw pointer to `{Box,Rc,Arc,Weak}::from_raw(_)`",
      "why_bad": "When dealing with `c_void` raw pointers in FFI, it is easy to run into the pitfall of calling `from_raw` with the `c_void` pointer.\nThe type signature of `Box::from_raw` is `fn from_raw(raw: *mut T) -> Box<T>`, so if you pass a `*mut c_void` you will get a `Box<c_void>` (and similarly for `Rc`, `Arc` and `Weak`).\nFor this to be safe, `c_void` would need to have the same memory layout as the original type, which is often not the case.",
      "example": "```no_run\n# use std::ffi::c_void;\nlet ptr = Box::into_raw(Box::new(42usize)) as *mut c_void;\nlet _ = unsafe { Box::from_raw(ptr) };\n```\nUse instead:\n```no_run\n# use std::ffi::c_void;\n# let ptr = Box::into_raw(Box::new(42usize)) as *mut c_void;\nlet _ = unsafe { Box::from_raw(ptr as *mut usize) };\n```",
      "version": "1.67.0",
      "source_file": "from_raw_with_void_ptr.rs",
      "embedding_text": "creating a `Box` from a void raw pointer\n\nChecks if we're passing a `c_void` raw pointer to `{Box,Rc,Arc,Weak}::from_raw(_)`\n\nWhen dealing with `c_void` raw pointers in FFI, it is easy to run into the pitfall of calling `from_raw` with the `c_void` pointer.\nThe type signature of `Box::from_raw` is `fn from_raw(raw: *mut T) -> Box<T>`, so if you pass a `*mut c_void` you will get a `Box<c_void>` (and similarly for `Rc`, `Arc` and `Weak`).\nFor this to be safe, `c_void` would need to have the same memory layout as the original type, which is often not the case."
    },
    {
      "id": "clippy::from_str_radix_10",
      "name": "FROM_STR_RADIX_10",
      "snake_name": "from_str_radix_10",
      "category": "style",
      "weight": 0.95,
      "brief": "from_str_radix with radix 10",
      "what_it_does": "Checks for function invocations of the form `primitive::from_str_radix(s, 10)`",
      "why_bad": "This specific common use case can be rewritten as `s.parse::<primitive>()`\n(and in most cases, the turbofish can be removed), which reduces code length\nand complexity.",
      "example": "```ignore\nlet input: &str = get_input();\nlet num = u16::from_str_radix(input, 10)?;\n```\nUse instead:\n```ignore\nlet input: &str = get_input();\nlet num: u16 = input.parse()?;\n```",
      "version": "1.52.0",
      "source_file": "from_str_radix_10.rs",
      "embedding_text": "from_str_radix with radix 10\n\nChecks for function invocations of the form `primitive::from_str_radix(s, 10)`\n\nThis specific common use case can be rewritten as `s.parse::<primitive>()`\n(and in most cases, the turbofish can be removed), which reduces code length\nand complexity."
    },
    {
      "id": "clippy::duplicate_underscore_argument",
      "name": "DUPLICATE_UNDERSCORE_ARGUMENT",
      "snake_name": "duplicate_underscore_argument",
      "category": "style",
      "weight": 0.95,
      "brief": "function arguments having names which only differ by an underscore",
      "what_it_does": "Checks for function arguments having the similar names\ndiffering by an underscore.",
      "why_bad": "It affects code readability.",
      "example": "```no_run\nfn foo(a: i32, _a: i32) {}\n```\n\nUse instead:\n```no_run\nfn bar(a: i32, _b: i32) {}\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "function arguments having names which only differ by an underscore\n\nChecks for function arguments having the similar names\ndiffering by an underscore.\n\nIt affects code readability."
    },
    {
      "id": "clippy::too_many_arguments",
      "name": "TOO_MANY_ARGUMENTS",
      "snake_name": "too_many_arguments",
      "category": "complexity",
      "weight": 1.0,
      "brief": "functions with too many arguments",
      "what_it_does": "Checks for functions with too many parameters.",
      "why_bad": "Functions with lots of parameters are considered bad\nstyle and reduce readability (\u201cwhat does the 5th parameter mean?\u201d). Consider\ngrouping some parameters into a new type.",
      "example": "```no_run\n# struct Color;\nfn foo(x: u32, y: u32, name: &str, c: Color, w: f32, h: f32, a: f32, b: f32) {\n// ..\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "functions with too many arguments\n\nChecks for functions with too many parameters.\n\nFunctions with lots of parameters are considered bad\nstyle and reduce readability (\u201cwhat does the 5th parameter mean?\u201d). Consider\ngrouping some parameters into a new type."
    },
    {
      "id": "clippy::too_many_lines",
      "name": "TOO_MANY_LINES",
      "snake_name": "too_many_lines",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "functions with too many lines",
      "what_it_does": "Checks for functions with a large amount of lines.",
      "why_bad": "Functions with a lot of lines are harder to understand\ndue to having to look at a larger amount of code to understand what the\nfunction is doing. Consider splitting the body of the function into\nmultiple functions.",
      "example": "```no_run\nfn im_too_long() {\nprintln!(\"\");\n// ... 100 more LoC\nprintln!(\"\");\n}\n```",
      "version": "1.34.0",
      "source_file": "mod.rs",
      "embedding_text": "functions with too many lines\n\nChecks for functions with a large amount of lines.\n\nFunctions with a lot of lines are harder to understand\ndue to having to look at a larger amount of code to understand what the\nfunction is doing. Consider splitting the body of the function into\nmultiple functions."
    },
    {
      "id": "clippy::not_unsafe_ptr_arg_deref",
      "name": "NOT_UNSAFE_PTR_ARG_DEREF",
      "snake_name": "not_unsafe_ptr_arg_deref",
      "category": "correctness",
      "weight": 1.2,
      "brief": "public functions dereferencing raw pointer arguments but not marked `unsafe`",
      "what_it_does": "Checks for public functions that dereference raw pointer\narguments but are not marked `unsafe`.",
      "why_bad": "The function should almost definitely be marked `unsafe`, since for an\narbitrary raw pointer, there is no way of telling for sure if it is valid.\n\nIn general, this lint should **never be disabled** unless it is definitely a\nfalse positive (please submit an issue if so) since it breaks Rust's\nsoundness guarantees, directly exposing API users to potentially dangerous\nprogram behavior. This is also true for internal APIs, as it is easy to leak\nunsoundness.",
      "example": "```rust,ignore\npub fn foo(x: *const u8) {\nprintln!(\"{}\", unsafe { *x });\n}\n\n// this call \"looks\" safe but will segfault or worse!\n// foo(invalid_ptr);\n```\n\nUse instead:\n```rust,ignore\npub unsafe fn foo(x: *const u8) {\nprintln!(\"{}\", unsafe { *x });\n}\n\n// this would cause a compiler error for calling without `unsafe`\n// foo(invalid_ptr);\n\n// sound call if the caller knows the pointer is valid\nunsafe { foo(valid_ptr); }\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "public functions dereferencing raw pointer arguments but not marked `unsafe`\n\nChecks for public functions that dereference raw pointer\narguments but are not marked `unsafe`.\n\nThe function should almost definitely be marked `unsafe`, since for an\narbitrary raw pointer, there is no way of telling for sure if it is valid.\n\nIn general, this lint should **never be disabled** unless it is definitely a\nfalse positive (please submit an issue if so) since it breaks Rust's\nsoundness guarantees, directly exposing API users to potentially dangerous\nprogram behavior. This is also true for internal APIs, as it is easy to leak\nunsoundness."
    },
    {
      "id": "clippy::must_use_unit",
      "name": "MUST_USE_UNIT",
      "snake_name": "must_use_unit",
      "category": "style",
      "weight": 0.95,
      "brief": "`#[must_use]` attribute on a unit-returning function / method",
      "what_it_does": "Checks for a `#[must_use]` attribute on\nunit-returning functions and methods.",
      "why_bad": "Unit values are useless. The attribute is likely\na remnant of a refactoring that removed the return type.",
      "example": "```no_run\n#[must_use]\nfn useless() { }\n```",
      "version": "1.40.0",
      "source_file": "mod.rs",
      "embedding_text": "`#[must_use]` attribute on a unit-returning function / method\n\nChecks for a `#[must_use]` attribute on\nunit-returning functions and methods.\n\nUnit values are useless. The attribute is likely\na remnant of a refactoring that removed the return type."
    },
    {
      "id": "clippy::double_must_use",
      "name": "DOUBLE_MUST_USE",
      "snake_name": "double_must_use",
      "category": "style",
      "weight": 0.95,
      "brief": "`#[must_use]` attribute on a `#[must_use]`-returning function / method",
      "what_it_does": "Checks for a `#[must_use]` attribute without\nfurther information on functions and methods that return a type already\nmarked as `#[must_use]`.",
      "why_bad": "The attribute isn't needed. Not using the result\nwill already be reported. Alternatively, one can add some text to the\nattribute to improve the lint message.",
      "example": "```no_run\n#[must_use]\nfn double_must_use() -> Result<(), ()> {\nunimplemented!();\n}\n```",
      "version": "1.40.0",
      "source_file": "mod.rs",
      "embedding_text": "`#[must_use]` attribute on a `#[must_use]`-returning function / method\n\nChecks for a `#[must_use]` attribute without\nfurther information on functions and methods that return a type already\nmarked as `#[must_use]`.\n\nThe attribute isn't needed. Not using the result\nwill already be reported. Alternatively, one can add some text to the\nattribute to improve the lint message."
    },
    {
      "id": "clippy::must_use_candidate",
      "name": "MUST_USE_CANDIDATE",
      "snake_name": "must_use_candidate",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "function or method that could take a `#[must_use]` attribute",
      "what_it_does": "Checks for public functions that have no\n`#[must_use]` attribute, but return something not already marked\nmust-use, have no mutable arg and mutate no statics.",
      "why_bad": "Not bad at all, this lint just shows places where\nyou could add the attribute.",
      "example": "```no_run\n// this could be annotated with `#[must_use]`.\npub fn id<T>(t: T) -> T { t }\n```",
      "version": "1.40.0",
      "source_file": "mod.rs",
      "embedding_text": "function or method that could take a `#[must_use]` attribute\n\nChecks for public functions that have no\n`#[must_use]` attribute, but return something not already marked\nmust-use, have no mutable arg and mutate no statics.\n\nNot bad at all, this lint just shows places where\nyou could add the attribute."
    },
    {
      "id": "clippy::result_unit_err",
      "name": "RESULT_UNIT_ERR",
      "snake_name": "result_unit_err",
      "category": "style",
      "weight": 0.95,
      "brief": "public function returning `Result` with an `Err` type of `()`",
      "what_it_does": "Checks for public functions that return a `Result`\nwith an `Err` type of `()`. It suggests using a custom type that\nimplements `std::error::Error`.",
      "why_bad": "Unit does not implement `Error` and carries no\nfurther information about what went wrong.",
      "example": "```no_run\npub fn read_u8() -> Result<u8, ()> { Err(()) }\n```\nshould become\n```rust,should_panic\nuse std::fmt;\n\n#[derive(Debug)]\npub struct EndOfStream;\n\nimpl fmt::Display for EndOfStream {\nfn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\nwrite!(f, \"End of Stream\")\n}\n}\n\nimpl std::error::Error for EndOfStream { }\n\npub fn read_u8() -> Result<u8, EndOfStream> { Err(EndOfStream) }\n# fn main() {\n#     read_u8().unwrap();\n# }\n```\n\nNote that there are crates that simplify creating the error type, e.g.\n[`thiserror`](https://docs.rs/thiserror).",
      "version": "1.49.0",
      "source_file": "mod.rs",
      "embedding_text": "public function returning `Result` with an `Err` type of `()`\n\nChecks for public functions that return a `Result`\nwith an `Err` type of `()`. It suggests using a custom type that\nimplements `std::error::Error`.\n\nUnit does not implement `Error` and carries no\nfurther information about what went wrong."
    },
    {
      "id": "clippy::result_large_err",
      "name": "RESULT_LARGE_ERR",
      "snake_name": "result_large_err",
      "category": "perf",
      "weight": 1.0,
      "brief": "function returning `Result` with large `Err` type",
      "what_it_does": "Checks for functions that return `Result` with an unusually large\n`Err`-variant.",
      "why_bad": "A `Result` is at least as large as the `Err`-variant. While we\nexpect that variant to be seldom used, the compiler needs to reserve\nand move that much memory every single time.\nFurthermore, errors are often simply passed up the call-stack, making\nuse of the `?`-operator and its type-conversion mechanics. If the\n`Err`-variant further up the call-stack stores the `Err`-variant in\nquestion (as library code often does), it itself needs to be at least\nas large, propagating the problem.",
      "example": "```no_run\npub enum ParseError {\nUnparsedBytes([u8; 512]),\nUnexpectedEof,\n}\n\n// The `Result` has at least 512 bytes, even in the `Ok`-case\npub fn parse() -> Result<(), ParseError> {\nOk(())\n}\n```\nshould be\n```no_run\npub enum ParseError {\nUnparsedBytes(Box<[u8; 512]>),\nUnexpectedEof,\n}\n\n// The `Result` is slightly larger than a pointer\npub fn parse() -> Result<(), ParseError> {\nOk(())\n}\n```",
      "version": "1.65.0",
      "source_file": "mod.rs",
      "embedding_text": "function returning `Result` with large `Err` type\n\nChecks for functions that return `Result` with an unusually large\n`Err`-variant.\n\nA `Result` is at least as large as the `Err`-variant. While we\nexpect that variant to be seldom used, the compiler needs to reserve\nand move that much memory every single time.\nFurthermore, errors are often simply passed up the call-stack, making\nuse of the `?`-operator and its type-conversion mechanics. If the\n`Err`-variant further up the call-stack stores the `Err`-variant in\nquestion (as library code often does), it itself needs to be at least\nas large, propagating the problem."
    },
    {
      "id": "clippy::misnamed_getters",
      "name": "MISNAMED_GETTERS",
      "snake_name": "misnamed_getters",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "getter method returning the wrong field",
      "what_it_does": "Checks for getter methods that return a field that doesn't correspond\nto the name of the method, when there is a field's whose name matches that of the method.",
      "why_bad": "It is most likely that such a method is a bug caused by a typo or by copy-pasting.",
      "example": "```no_run\nstruct A {\na: String,\nb: String,\n}\n\nimpl A {\nfn a(&self) -> &str{\n&self.b\n}\n}\n```\nUse instead:\n```no_run\nstruct A {\na: String,\nb: String,\n}\n\nimpl A {\nfn a(&self) -> &str{\n&self.a\n}\n}\n```",
      "version": "1.67.0",
      "source_file": "mod.rs",
      "embedding_text": "getter method returning the wrong field\n\nChecks for getter methods that return a field that doesn't correspond\nto the name of the method, when there is a field's whose name matches that of the method.\n\nIt is most likely that such a method is a bug caused by a typo or by copy-pasting."
    },
    {
      "id": "clippy::impl_trait_in_params",
      "name": "IMPL_TRAIT_IN_PARAMS",
      "snake_name": "impl_trait_in_params",
      "category": "restriction",
      "weight": 1.0,
      "brief": "`impl Trait` is used in the function's parameters",
      "what_it_does": "Lints when `impl Trait` is being used in a function's parameters.",
      "why_bad": "Turbofish syntax (`::<>`) cannot be used to specify the type of an `impl Trait` parameter,\nmaking `impl Trait` less powerful. Readability may also be a factor.",
      "example": "```no_run\ntrait MyTrait {}\nfn foo(a: impl MyTrait) {\n// [...]\n}\n```\nUse instead:\n```no_run\ntrait MyTrait {}\nfn foo<T: MyTrait>(a: T) {\n// [...]\n}\n```",
      "version": "1.69.0",
      "source_file": "mod.rs",
      "embedding_text": "`impl Trait` is used in the function's parameters\n\nLints when `impl Trait` is being used in a function's parameters.\n\nTurbofish syntax (`::<>`) cannot be used to specify the type of an `impl Trait` parameter,\nmaking `impl Trait` less powerful. Readability may also be a factor."
    },
    {
      "id": "clippy::renamed_function_params",
      "name": "RENAMED_FUNCTION_PARAMS",
      "snake_name": "renamed_function_params",
      "category": "restriction",
      "weight": 1.0,
      "brief": "renamed function parameters in trait implementation",
      "what_it_does": "Lints when the name of function parameters from trait impl is\ndifferent than its default implementation.",
      "why_bad": "Using the default name for parameters of a trait method is more consistent.",
      "example": "```rust\nstruct A(u32);\n\nimpl PartialEq for A {\nfn eq(&self, b: &Self) -> bool {\nself.0 == b.0\n}\n}\n```\nUse instead:\n```rust\nstruct A(u32);\n\nimpl PartialEq for A {\nfn eq(&self, other: &Self) -> bool {\nself.0 == other.0\n}\n}\n```",
      "version": "1.80.0",
      "source_file": "mod.rs",
      "embedding_text": "renamed function parameters in trait implementation\n\nLints when the name of function parameters from trait impl is\ndifferent than its default implementation.\n\nUsing the default name for parameters of a trait method is more consistent."
    },
    {
      "id": "clippy::ref_option",
      "name": "REF_OPTION",
      "snake_name": "ref_option",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "function signature uses `&Option<T>` instead of `Option<&T>`",
      "what_it_does": "Warns when a function signature uses `&Option<T>` instead of `Option<&T>`.",
      "why_bad": "More flexibility, better memory optimization, and more idiomatic Rust code.\n\n`&Option<T>` in a function signature breaks encapsulation because the caller must own T\nand move it into an Option to call with it. When returned, the owner must internally store\nit as `Option<T>` in order to return it.\nAt a lower level, `&Option<T>` points to memory with the `presence` bit flag plus the `T` value,\nwhereas `Option<&T>` is usually [optimized](https://doc.rust-lang.org/1.81.0/std/option/index.html#representation)\nto a single pointer, so it may be more optimal.\n\nSee this [YouTube video](https://www.youtube.com/watch?v=6c7pZYP_iIE) by\nLogan Smith for an in-depth explanation of why this is important.",
      "example": "```no_run\n// caller uses  foo(&opt)\nfn foo(a: &Option<String>) {}\n# struct Unit {}\n# impl Unit {\nfn bar(&self) -> &Option<String> { &None }\n# }\n```\nUse instead:\n```no_run\n// caller should use  `foo1(opt.as_ref())`\nfn foo1(a: Option<&String>) {}\n// better yet, use string slice  `foo2(opt.as_deref())`\nfn foo2(a: Option<&str>) {}\n# struct Unit {}\n# impl Unit {\nfn bar(&self) -> Option<&String> { None }\n# }\n```",
      "version": "1.83.0",
      "source_file": "mod.rs",
      "embedding_text": "function signature uses `&Option<T>` instead of `Option<&T>`\n\nWarns when a function signature uses `&Option<T>` instead of `Option<&T>`.\n\nMore flexibility, better memory optimization, and more idiomatic Rust code.\n\n`&Option<T>` in a function signature breaks encapsulation because the caller must own T\nand move it into an Option to call with it. When returned, the owner must internally store\nit as `Option<T>` in order to return it.\nAt a lower level, `&Option<T>` points to memory with the `presence` bit flag plus the `T` value,\nwhereas `Option<&T>` is usually [optimized](https://doc.rust-lang.org/1.81.0/std/option/index.html#representation)\nto a single pointer, so it may be more optimal.\n\nSee this [YouTube video](https://www.youtube.com/watch?v=6c7pZYP_iIE) by\nLogan Smith for an in-depth explanation of why this is important."
    },
    {
      "id": "clippy::future_not_send",
      "name": "FUTURE_NOT_SEND",
      "snake_name": "future_not_send",
      "category": "nursery",
      "weight": 0.9,
      "brief": "public Futures must be Send",
      "what_it_does": "This lint requires Future implementations returned from\nfunctions and methods to implement the `Send` marker trait,\nignoring type parameters.\n\nIf a function is generic and its Future conditionally implements `Send`\nbased on a generic parameter then it is considered `Send` and no warning is emitted.\n\nThis can be used by library authors (public and internal) to ensure\ntheir functions are compatible with both multi-threaded runtimes that require `Send` futures,\nas well as single-threaded runtimes where callers may choose `!Send` types\nfor generic parameters.",
      "why_bad": "A Future implementation captures some state that it\nneeds to eventually produce its final value. When targeting a multithreaded\nexecutor (which is the norm on non-embedded devices) this means that this\nstate may need to be transported to other threads, in other words the\nwhole Future needs to implement the `Send` marker trait. If it does not,\nthen the resulting Future cannot be submitted to a thread pool in the\nend user\u2019s code.\n\nEspecially for generic functions it can be confusing to leave the\ndiscovery of this problem to the end user: the reported error location\nwill be far from its cause and can in many cases not even be fixed without\nmodifying the library where the offending Future implementation is\nproduced.",
      "example": "```no_run\nasync fn not_send(bytes: std::rc::Rc<[u8]>) {}\n```\nUse instead:\n```no_run\nasync fn is_send(bytes: std::sync::Arc<[u8]>) {}\n```",
      "version": "1.44.0",
      "source_file": "future_not_send.rs",
      "embedding_text": "public Futures must be Send\n\nThis lint requires Future implementations returned from\nfunctions and methods to implement the `Send` marker trait,\nignoring type parameters.\n\nIf a function is generic and its Future conditionally implements `Send`\nbased on a generic parameter then it is considered `Send` and no warning is emitted.\n\nThis can be used by library authors (public and internal) to ensure\ntheir functions are compatible with both multi-threaded runtimes that require `Send` futures,\nas well as single-threaded runtimes where callers may choose `!Send` types\nfor generic parameters.\n\nA Future implementation captures some state that it\nneeds to eventually produce its final value. When targeting a multithreaded\nexecutor (which is the norm on non-embedded devices) this means that this\nstate may need to be transported to other threads, in other words the\nwhole Future needs to implement the `Send` marker trait. If it does not,\nthen the resulting Future cannot be submitted to a thread pool in the\nend user\u2019s code.\n\nEspecially for generic functions it can be confusing to leave the\ndiscovery of this problem to the end user: the reported error location\nwill be far from its cause and can in many cases not even be fixed without\nmodifying the library where the offending Future implementation is\nproduced."
    },
    {
      "id": "clippy::if_let_mutex",
      "name": "IF_LET_MUTEX",
      "snake_name": "if_let_mutex",
      "category": "correctness",
      "weight": 1.2,
      "brief": "locking a `Mutex` in an `if let` block can cause deadlocks",
      "what_it_does": "Checks for `Mutex::lock` calls in `if let` expression\nwith lock calls in any of the else blocks.",
      "why_bad": "The Mutex lock remains held for the whole\n`if let ... else` block and deadlocks.",
      "example": "```rust,ignore\nif let Ok(thing) = mutex.lock() {\ndo_thing();\n} else {\nmutex.lock();\n}\n```\nShould be written\n```rust,ignore\nlet locked = mutex.lock();\nif let Ok(thing) = locked {\ndo_thing(thing);\n} else {\nuse_locked(locked);\n}\n```",
      "version": "1.45.0",
      "source_file": "if_let_mutex.rs",
      "embedding_text": "locking a `Mutex` in an `if let` block can cause deadlocks\n\nChecks for `Mutex::lock` calls in `if let` expression\nwith lock calls in any of the else blocks.\n\nThe Mutex lock remains held for the whole\n`if let ... else` block and deadlocks."
    },
    {
      "id": "clippy::if_not_else",
      "name": "IF_NOT_ELSE",
      "snake_name": "if_not_else",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "`if` branches that could be swapped so no negation operation is necessary on the condition",
      "what_it_does": "Checks for usage of `!` or `!=` in an if condition with an\nelse branch.",
      "why_bad": "Negations reduce the readability of statements.",
      "example": "```no_run\n# let v: Vec<usize> = vec![];\n# fn a() {}\n# fn b() {}\nif !v.is_empty() {\na()\n} else {\nb()\n}\n```\n\nCould be written:\n\n```no_run\n# let v: Vec<usize> = vec![];\n# fn a() {}\n# fn b() {}\nif v.is_empty() {\nb()\n} else {\na()\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "if_not_else.rs",
      "embedding_text": "`if` branches that could be swapped so no negation operation is necessary on the condition\n\nChecks for usage of `!` or `!=` in an if condition with an\nelse branch.\n\nNegations reduce the readability of statements."
    },
    {
      "id": "clippy::if_then_some_else_none",
      "name": "IF_THEN_SOME_ELSE_NONE",
      "snake_name": "if_then_some_else_none",
      "category": "restriction",
      "weight": 1.0,
      "brief": "Finds if-else that could be written using either `bool::then` or `bool::then_some`",
      "what_it_does": "Checks for if-else that could be written using either `bool::then` or `bool::then_some`.",
      "why_bad": "Looks a little redundant. Using `bool::then` is more concise and incurs no loss of clarity.\nFor simple calculations and known values, use `bool::then_some`, which is eagerly evaluated\nin comparison to `bool::then`.",
      "example": "```no_run\n# let v = vec![0];\nlet a = if v.is_empty() {\nprintln!(\"true!\");\nSome(42)\n} else {\nNone\n};\n```\n\nCould be written:\n\n```no_run\n# let v = vec![0];\nlet a = v.is_empty().then(|| {\nprintln!(\"true!\");\n42\n});\n```",
      "version": "1.53.0",
      "source_file": "if_then_some_else_none.rs",
      "embedding_text": "Finds if-else that could be written using either `bool::then` or `bool::then_some`\n\nChecks for if-else that could be written using either `bool::then` or `bool::then_some`.\n\nLooks a little redundant. Using `bool::then` is more concise and incurs no loss of clarity.\nFor simple calculations and known values, use `bool::then_some`, which is eagerly evaluated\nin comparison to `bool::then`."
    },
    {
      "id": "clippy::ifs_same_cond",
      "name": "IFS_SAME_COND",
      "snake_name": "ifs_same_cond",
      "category": "correctness",
      "weight": 1.2,
      "brief": "consecutive `if`s with the same condition",
      "what_it_does": "Checks for consecutive `if`s with the same condition.",
      "why_bad": "This is probably a copy & paste error.",
      "example": "```ignore\nif a == b {\n\u2026\n} else if a == b {\n\u2026\n}\n```\n\nNote that this lint ignores all conditions with a function call as it could\nhave side effects:\n\n```ignore\nif foo() {\n\u2026\n} else if foo() { // not linted\n\u2026\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "consecutive `if`s with the same condition\n\nChecks for consecutive `if`s with the same condition.\n\nThis is probably a copy & paste error."
    },
    {
      "id": "clippy::same_functions_in_if_condition",
      "name": "SAME_FUNCTIONS_IN_IF_CONDITION",
      "snake_name": "same_functions_in_if_condition",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "consecutive `if`s with the same function call",
      "what_it_does": "Checks for consecutive `if`s with the same function call.",
      "why_bad": "This is probably a copy & paste error.\nDespite the fact that function can have side effects and `if` works as\nintended, such an approach is implicit and can be considered a \"code smell\".",
      "example": "```ignore\nif foo() == bar {\n\u2026\n} else if foo() == bar {\n\u2026\n}\n```\n\nThis probably should be:\n```ignore\nif foo() == bar {\n\u2026\n} else if foo() == baz {\n\u2026\n}\n```\n\nor if the original code was not a typo and called function mutates a state,\nconsider move the mutation out of the `if` condition to avoid similarity to\na copy & paste error:\n\n```ignore\nlet first = foo();\nif first == bar {\n\u2026\n} else {\nlet second = foo();\nif second == bar {\n\u2026\n}\n}\n```",
      "version": "1.41.0",
      "source_file": "mod.rs",
      "embedding_text": "consecutive `if`s with the same function call\n\nChecks for consecutive `if`s with the same function call.\n\nThis is probably a copy & paste error.\nDespite the fact that function can have side effects and `if` works as\nintended, such an approach is implicit and can be considered a \"code smell\"."
    },
    {
      "id": "clippy::if_same_then_else",
      "name": "IF_SAME_THEN_ELSE",
      "snake_name": "if_same_then_else",
      "category": "style",
      "weight": 0.95,
      "brief": "`if` with the same `then` and `else` blocks",
      "what_it_does": "Checks for `if/else` with the same body as the *then* part\nand the *else* part.",
      "why_bad": "This is probably a copy & paste error.",
      "example": "```ignore\nlet foo = if \u2026 {\n42\n} else {\n42\n};\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "`if` with the same `then` and `else` blocks\n\nChecks for `if/else` with the same body as the *then* part\nand the *else* part.\n\nThis is probably a copy & paste error."
    },
    {
      "id": "clippy::branches_sharing_code",
      "name": "BRANCHES_SHARING_CODE",
      "snake_name": "branches_sharing_code",
      "category": "nursery",
      "weight": 0.9,
      "brief": "`if` statement with shared code in all blocks",
      "what_it_does": "Checks if the `if` and `else` block contain shared code that can be\nmoved out of the blocks.",
      "why_bad": "Duplicate code is less maintainable.",
      "example": "```ignore\nlet foo = if \u2026 {\nprintln!(\"Hello World\");\n13\n} else {\nprintln!(\"Hello World\");\n42\n};\n```\n\nUse instead:\n```ignore\nprintln!(\"Hello World\");\nlet foo = if \u2026 {\n13\n} else {\n42\n};\n```",
      "version": "1.53.0",
      "source_file": "mod.rs",
      "embedding_text": "`if` statement with shared code in all blocks\n\nChecks if the `if` and `else` block contain shared code that can be\nmoved out of the blocks.\n\nDuplicate code is less maintainable."
    },
    {
      "id": "clippy::ignored_unit_patterns",
      "name": "IGNORED_UNIT_PATTERNS",
      "snake_name": "ignored_unit_patterns",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "suggest replacing `_` by `()` in patterns where appropriate",
      "what_it_does": "Checks for usage of `_` in patterns of type `()`.",
      "why_bad": "Matching with `()` explicitly instead of `_` outlines\nthe fact that the pattern contains no data. Also it\nwould detect a type change that `_` would ignore.",
      "example": "```no_run\nmatch std::fs::create_dir(\"tmp-work-dir\") {\nOk(_) => println!(\"Working directory created\"),\nErr(s) => eprintln!(\"Could not create directory: {s}\"),\n}\n```\nUse instead:\n```no_run\nmatch std::fs::create_dir(\"tmp-work-dir\") {\nOk(()) => println!(\"Working directory created\"),\nErr(s) => eprintln!(\"Could not create directory: {s}\"),\n}\n```",
      "version": "1.73.0",
      "source_file": "ignored_unit_patterns.rs",
      "embedding_text": "suggest replacing `_` by `()` in patterns where appropriate\n\nChecks for usage of `_` in patterns of type `()`.\n\nMatching with `()` explicitly instead of `_` outlines\nthe fact that the pattern contains no data. Also it\nwould detect a type change that `_` would ignore."
    },
    {
      "id": "clippy::impl_hash_borrow_with_str_and_bytes",
      "name": "IMPL_HASH_BORROW_WITH_STR_AND_BYTES",
      "snake_name": "impl_hash_borrow_with_str_and_bytes",
      "category": "correctness",
      "weight": 1.2,
      "brief": "ensures that the semantics of `Borrow` for `Hash` are satisfied when `Borrow<str>` and `Borrow<[u8]>` are implemented",
      "what_it_does": "This lint is concerned with the semantics of `Borrow` and `Hash` for a\ntype that implements all three of `Hash`, `Borrow<str>` and `Borrow<[u8]>`\nas it is impossible to satisfy the semantics of Borrow and `Hash` for\nboth `Borrow<str>` and `Borrow<[u8]>`.",
      "why_bad": "When providing implementations for `Borrow<T>`, one should consider whether the different\nimplementations should act as facets or representations of the underlying type. Generic code\ntypically uses `Borrow<T>` when it relies on the identical behavior of these additional trait\nimplementations. These traits will likely appear as additional trait bounds.\n\nIn particular `Eq`, `Ord` and `Hash` must be equivalent for borrowed and owned values:\n`x.borrow() == y.borrow()` should give the same result as `x == y`.\nIt follows then that the following equivalence must hold:\n`hash(x) == hash((x as Borrow<[u8]>).borrow()) == hash((x as Borrow<str>).borrow())`\n\nUnfortunately it doesn't hold as `hash(\"abc\") != hash(\"abc\".as_bytes())`.\nThis happens because the `Hash` impl for str passes an additional `0xFF` byte to\nthe hasher to avoid collisions. For example, given the tuples `(\"a\", \"bc\")`, and `(\"ab\", \"c\")`,\nthe two tuples would have the same hash value if the `0xFF` byte was not added.",
      "example": "```\nuse std::borrow::Borrow;\nuse std::hash::{Hash, Hasher};\n\nstruct ExampleType {\ndata: String\n}\n\nimpl Hash for ExampleType {\nfn hash<H: Hasher>(&self, state: &mut H) {\nself.data.hash(state);\n}\n}\n\nimpl Borrow<str> for ExampleType {\nfn borrow(&self) -> &str {\n&self.data\n}\n}\n\nimpl Borrow<[u8]> for ExampleType {\nfn borrow(&self) -> &[u8] {\nself.data.as_bytes()\n}\n}\n```\nAs a consequence, hashing a `&ExampleType` and hashing the result of the two\nborrows will result in different values.",
      "version": "1.76.0",
      "source_file": "impl_hash_with_borrow_str_and_bytes.rs",
      "embedding_text": "ensures that the semantics of `Borrow` for `Hash` are satisfied when `Borrow<str>` and `Borrow<[u8]>` are implemented\n\nThis lint is concerned with the semantics of `Borrow` and `Hash` for a\ntype that implements all three of `Hash`, `Borrow<str>` and `Borrow<[u8]>`\nas it is impossible to satisfy the semantics of Borrow and `Hash` for\nboth `Borrow<str>` and `Borrow<[u8]>`.\n\nWhen providing implementations for `Borrow<T>`, one should consider whether the different\nimplementations should act as facets or representations of the underlying type. Generic code\ntypically uses `Borrow<T>` when it relies on the identical behavior of these additional trait\nimplementations. These traits will likely appear as additional trait bounds.\n\nIn particular `Eq`, `Ord` and `Hash` must be equivalent for borrowed and owned values:\n`x.borrow() == y.borrow()` should give the same result as `x == y`.\nIt follows then that the following equivalence must hold:\n`hash(x) == hash((x as Borrow<[u8]>).borrow()) == hash((x as Borrow<str>).borrow())`\n\nUnfortunately it doesn't hold as `hash(\"abc\") != hash(\"abc\".as_bytes())`.\nThis happens because the `Hash` impl for str passes an additional `0xFF` byte to\nthe hasher to avoid collisions. For example, given the tuples `(\"a\", \"bc\")`, and `(\"ab\", \"c\")`,\nthe two tuples would have the same hash value if the `0xFF` byte was not added."
    },
    {
      "id": "clippy::implicit_hasher",
      "name": "IMPLICIT_HASHER",
      "snake_name": "implicit_hasher",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "missing generalization over different hashers",
      "what_it_does": "Checks for public `impl` or `fn` missing generalization\nover different hashers and implicitly defaulting to the default hashing\nalgorithm (`SipHash`).",
      "why_bad": "`HashMap` or `HashSet` with custom hashers cannot be\nused with them.",
      "example": "```no_run\n# use std::collections::HashMap;\n# use std::hash::{Hash, BuildHasher};\n# trait Serialize {};\nimpl<K: Hash + Eq, V> Serialize for HashMap<K, V> { }\n\npub fn foo(map: &mut HashMap<i32, i32>) { }\n```\ncould be rewritten as\n```no_run\n# use std::collections::HashMap;\n# use std::hash::{Hash, BuildHasher};\n# trait Serialize {};\nimpl<K: Hash + Eq, V, S: BuildHasher> Serialize for HashMap<K, V, S> { }\n\npub fn foo<S: BuildHasher>(map: &mut HashMap<i32, i32, S>) { }\n```",
      "version": "pre 1.29.0",
      "source_file": "implicit_hasher.rs",
      "embedding_text": "missing generalization over different hashers\n\nChecks for public `impl` or `fn` missing generalization\nover different hashers and implicitly defaulting to the default hashing\nalgorithm (`SipHash`).\n\n`HashMap` or `HashSet` with custom hashers cannot be\nused with them."
    },
    {
      "id": "clippy::implicit_return",
      "name": "IMPLICIT_RETURN",
      "snake_name": "implicit_return",
      "category": "restriction",
      "weight": 1.0,
      "brief": "use a return statement like `return expr` instead of an expression",
      "what_it_does": "Checks for missing return statements at the end of a block.",
      "why_bad": "Omitting the return keyword whenever possible is idiomatic Rust code, but:\n\n* Programmers coming from other languages might prefer the expressiveness of `return`.\n* It's possible to miss the last returning statement because the only difference is a missing `;`.\n* Especially in bigger code with multiple return paths, having a `return` keyword makes it easier to find the\ncorresponding statements.",
      "example": "```no_run\nfn foo(x: usize) -> usize {\nx\n}\n```\nadd return\n```no_run\nfn foo(x: usize) -> usize {\nreturn x;\n}\n```",
      "version": "1.33.0",
      "source_file": "implicit_return.rs",
      "embedding_text": "use a return statement like `return expr` instead of an expression\n\nChecks for missing return statements at the end of a block.\n\nOmitting the return keyword whenever possible is idiomatic Rust code, but:\n\n* Programmers coming from other languages might prefer the expressiveness of `return`.\n* It's possible to miss the last returning statement because the only difference is a missing `;`.\n* Especially in bigger code with multiple return paths, having a `return` keyword makes it easier to find the\ncorresponding statements."
    },
    {
      "id": "clippy::implicit_saturating_add",
      "name": "IMPLICIT_SATURATING_ADD",
      "snake_name": "implicit_saturating_add",
      "category": "style",
      "weight": 0.95,
      "brief": "Perform saturating addition instead of implicitly checking max bound of data type",
      "what_it_does": "Checks for implicit saturating addition.",
      "why_bad": "The built-in function is more readable and may be faster.",
      "example": "```no_run\nlet mut u:u32 = 7000;\n\nif u != u32::MAX {\nu += 1;\n}\n```\nUse instead:\n```no_run\nlet mut u:u32 = 7000;\n\nu = u.saturating_add(1);\n```",
      "version": "1.66.0",
      "source_file": "implicit_saturating_add.rs",
      "embedding_text": "Perform saturating addition instead of implicitly checking max bound of data type\n\nChecks for implicit saturating addition.\n\nThe built-in function is more readable and may be faster."
    },
    {
      "id": "clippy::implicit_saturating_sub",
      "name": "IMPLICIT_SATURATING_SUB",
      "snake_name": "implicit_saturating_sub",
      "category": "style",
      "weight": 0.95,
      "brief": "Perform saturating subtraction instead of implicitly checking lower bound of data type",
      "what_it_does": "Checks for implicit saturating subtraction.",
      "why_bad": "Simplicity and readability. Instead we can easily use an builtin function.",
      "example": "```no_run\n# let end: u32 = 10;\n# let start: u32 = 5;\nlet mut i: u32 = end - start;\n\nif i != 0 {\ni -= 1;\n}\n```\n\nUse instead:\n```no_run\n# let end: u32 = 10;\n# let start: u32 = 5;\nlet mut i: u32 = end - start;\n\ni = i.saturating_sub(1);\n```",
      "version": "1.44.0",
      "source_file": "implicit_saturating_sub.rs",
      "embedding_text": "Perform saturating subtraction instead of implicitly checking lower bound of data type\n\nChecks for implicit saturating subtraction.\n\nSimplicity and readability. Instead we can easily use an builtin function."
    },
    {
      "id": "clippy::inverted_saturating_sub",
      "name": "INVERTED_SATURATING_SUB",
      "snake_name": "inverted_saturating_sub",
      "category": "correctness",
      "weight": 1.2,
      "brief": "Check if a variable is smaller than another one and still subtract from it even if smaller",
      "what_it_does": "Checks for comparisons between integers, followed by subtracting the greater value from the\nlower one.",
      "why_bad": "This could result in an underflow and is most likely not what the user wants. If this was\nintended to be a saturated subtraction, consider using the `saturating_sub` method directly.",
      "example": "```no_run\nlet a = 12u32;\nlet b = 13u32;\n\nlet result = if a > b { b - a } else { 0 };\n```\n\nUse instead:\n```no_run\nlet a = 12u32;\nlet b = 13u32;\n\nlet result = a.saturating_sub(b);\n```",
      "version": "1.83.0",
      "source_file": "implicit_saturating_sub.rs",
      "embedding_text": "Check if a variable is smaller than another one and still subtract from it even if smaller\n\nChecks for comparisons between integers, followed by subtracting the greater value from the\nlower one.\n\nThis could result in an underflow and is most likely not what the user wants. If this was\nintended to be a saturated subtraction, consider using the `saturating_sub` method directly."
    },
    {
      "id": "clippy::implied_bounds_in_impls",
      "name": "IMPLIED_BOUNDS_IN_IMPLS",
      "snake_name": "implied_bounds_in_impls",
      "category": "complexity",
      "weight": 1.0,
      "brief": "specifying bounds that are implied by other bounds in `impl Trait` type",
      "what_it_does": "Looks for bounds in `impl Trait` in return position that are implied by other bounds.\nThis can happen when a trait is specified that another trait already has as a supertrait\n(e.g. `fn() -> impl Deref + DerefMut<Target = i32>` has an unnecessary `Deref` bound,\nbecause `Deref` is a supertrait of `DerefMut`)",
      "why_bad": "Specifying more bounds than necessary adds needless complexity for the reader.",
      "example": "```no_run\n# use std::ops::{Deref,DerefMut};\nfn f() -> impl Deref<Target = i32> + DerefMut<Target = i32> {\n//             ^^^^^^^^^^^^^^^^^^^ unnecessary bound, already implied by the `DerefMut` trait bound\nBox::new(123)\n}\n```\nUse instead:\n```no_run\n# use std::ops::{Deref,DerefMut};\nfn f() -> impl DerefMut<Target = i32> {\nBox::new(123)\n}\n```",
      "version": "1.74.0",
      "source_file": "implied_bounds_in_impls.rs",
      "embedding_text": "specifying bounds that are implied by other bounds in `impl Trait` type\n\nLooks for bounds in `impl Trait` in return position that are implied by other bounds.\nThis can happen when a trait is specified that another trait already has as a supertrait\n(e.g. `fn() -> impl Deref + DerefMut<Target = i32>` has an unnecessary `Deref` bound,\nbecause `Deref` is a supertrait of `DerefMut`)\n\nSpecifying more bounds than necessary adds needless complexity for the reader."
    },
    {
      "id": "clippy::incompatible_msrv",
      "name": "INCOMPATIBLE_MSRV",
      "snake_name": "incompatible_msrv",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "ensures that all items used in the crate are available for the current MSRV",
      "what_it_does": "This lint checks that no function newer than the defined MSRV (minimum\nsupported rust version) is used in the crate.",
      "why_bad": "It would prevent the crate to be actually used with the specified MSRV.",
      "example": "```no_run\n// MSRV of 1.3.0\nuse std::thread::sleep;\nuse std::time::Duration;\n\n// Sleep was defined in `1.4.0`.\nsleep(Duration::new(1, 0));\n```\n\nTo fix this problem, either increase your MSRV or use another item\navailable in your current MSRV.\n\nYou can also locally change the MSRV that should be checked by Clippy,\nfor example if a feature in your crate (e.g., `modern_compiler`) should\nallow you to use an item:\n\n```no_run\n//! This crate has a MSRV of 1.3.0, but we also have an optional feature\n//! `sleep_well` which requires at least Rust 1.4.0.\n\n// When the `sleep_well` feature is set, do not warn for functions available\n// in Rust 1.4.0 and below.\n#![cfg_attr(feature = \"sleep_well\", clippy::msrv = \"1.4.0\")]\n\nuse std::time::Duration;\n\n#[cfg(feature = \"sleep_well\")]\nfn sleep_for_some_time() {\nstd::thread::sleep(Duration::new(1, 0)); // Will not trigger the lint\n}\n```\n\nYou can also increase the MSRV in tests, by using:\n\n```no_run\n// Use a much higher MSRV for tests while keeping the main one low\n#![cfg_attr(test, clippy::msrv = \"1.85.0\")]\n\n#[test]\nfn my_test() {\n// The tests can use items introduced in Rust 1.85.0 and lower\n// without triggering the `incompatible_msrv` lint.\n}\n```",
      "version": "1.78.0",
      "source_file": "incompatible_msrv.rs",
      "embedding_text": "ensures that all items used in the crate are available for the current MSRV\n\nThis lint checks that no function newer than the defined MSRV (minimum\nsupported rust version) is used in the crate.\n\nIt would prevent the crate to be actually used with the specified MSRV."
    },
    {
      "id": "clippy::inconsistent_struct_constructor",
      "name": "INCONSISTENT_STRUCT_CONSTRUCTOR",
      "snake_name": "inconsistent_struct_constructor",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "the order of the field init is inconsistent with the order in the struct definition",
      "what_it_does": "Checks for struct constructors where the order of the field\ninit in the constructor is inconsistent with the order in the\nstruct definition.",
      "why_bad": "Since the order of fields in a constructor doesn't affect the\nresulted instance as the below example indicates,\n\n```no_run\n#[derive(Debug, PartialEq, Eq)]\nstruct Foo {\nx: i32,\ny: i32,\n}\nlet x = 1;\nlet y = 2;\n\n// This assertion never fails:\nassert_eq!(Foo { x, y }, Foo { y, x });\n```\n\ninconsistent order can be confusing and decreases readability and consistency.",
      "example": "```no_run\nstruct Foo {\nx: i32,\ny: i32,\n}\nlet x = 1;\nlet y = 2;\n\nFoo { y, x };\n```\n\nUse instead:\n```no_run\n# struct Foo {\n#     x: i32,\n#     y: i32,\n# }\n# let x = 1;\n# let y = 2;\nFoo { x, y };\n```",
      "version": "1.52.0",
      "source_file": "inconsistent_struct_constructor.rs",
      "embedding_text": "the order of the field init is inconsistent with the order in the struct definition\n\nChecks for struct constructors where the order of the field\ninit in the constructor is inconsistent with the order in the\nstruct definition.\n\nSince the order of fields in a constructor doesn't affect the\nresulted instance as the below example indicates,\n\n```no_run\n#[derive(Debug, PartialEq, Eq)]\nstruct Foo {\nx: i32,\ny: i32,\n}\nlet x = 1;\nlet y = 2;\n\n// This assertion never fails:\nassert_eq!(Foo { x, y }, Foo { y, x });\n```\n\ninconsistent order can be confusing and decreases readability and consistency."
    },
    {
      "id": "clippy::index_refutable_slice",
      "name": "INDEX_REFUTABLE_SLICE",
      "snake_name": "index_refutable_slice",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "avoid indexing on slices which could be destructed",
      "what_it_does": "The lint checks for slice bindings in patterns that are only used to\naccess individual slice values.",
      "why_bad": "Accessing slice values using indices can lead to panics. Using refutable\npatterns can avoid these. Binding to individual values also improves the\nreadability as they can be named.",
      "example": "```no_run\nlet slice: Option<&[u32]> = Some(&[1, 2, 3]);\n\nif let Some(slice) = slice {\nprintln!(\"{}\", slice[0]);\n}\n```\nUse instead:\n```no_run\nlet slice: Option<&[u32]> = Some(&[1, 2, 3]);\n\nif let Some(&[first, ..]) = slice {\nprintln!(\"{}\", first);\n}\n```",
      "version": "1.59.0",
      "source_file": "index_refutable_slice.rs",
      "embedding_text": "avoid indexing on slices which could be destructed\n\nThe lint checks for slice bindings in patterns that are only used to\naccess individual slice values.\n\nAccessing slice values using indices can lead to panics. Using refutable\npatterns can avoid these. Binding to individual values also improves the\nreadability as they can be named."
    },
    {
      "id": "clippy::out_of_bounds_indexing",
      "name": "OUT_OF_BOUNDS_INDEXING",
      "snake_name": "out_of_bounds_indexing",
      "category": "correctness",
      "weight": 1.2,
      "brief": "out of bounds constant indexing",
      "what_it_does": "Checks for out of bounds array indexing with a constant\nindex.",
      "why_bad": "This will always panic at runtime.",
      "example": "```rust,no_run\nlet x = [1, 2, 3, 4];\n\nx[9];\n&x[2..9];\n```\n\nUse instead:\n```no_run\n# let x = [1, 2, 3, 4];\n// Index within bounds\n\nx[0];\nx[3];\n```",
      "version": "pre 1.29.0",
      "source_file": "indexing_slicing.rs",
      "embedding_text": "out of bounds constant indexing\n\nChecks for out of bounds array indexing with a constant\nindex.\n\nThis will always panic at runtime."
    },
    {
      "id": "clippy::indexing_slicing",
      "name": "INDEXING_SLICING",
      "snake_name": "indexing_slicing",
      "category": "restriction",
      "weight": 1.0,
      "brief": "indexing/slicing usage",
      "what_it_does": "Checks for usage of indexing or slicing that may panic at runtime.\n\nThis lint does not report on indexing or slicing operations\nthat always panic, clippy's `out_of_bound_indexing` already\nhandles those cases.",
      "why_bad": "To avoid implicit panics from indexing and slicing.\n\nThere are \u201cchecked\u201d alternatives which do not panic, and can be used with `unwrap()` to make\nan explicit panic when it is desired.",
      "example": "```rust,no_run\n// Vector\nlet x = vec![0, 1, 2, 3];\n\nx[2];\nx[100];\n&x[2..100];\n\n// Array\nlet y = [0, 1, 2, 3];\n\nlet i = 10; // Could be a runtime value\nlet j = 20;\n&y[i..j];\n```\n\nUse instead:\n```no_run\n# let x = vec![0, 1, 2, 3];\nx.get(2);\nx.get(100);\nx.get(2..100);\n\n# let y = [0, 1, 2, 3];\nlet i = 10;\nlet j = 20;\ny.get(i..j);\n```",
      "version": "pre 1.29.0",
      "source_file": "indexing_slicing.rs",
      "embedding_text": "indexing/slicing usage\n\nChecks for usage of indexing or slicing that may panic at runtime.\n\nThis lint does not report on indexing or slicing operations\nthat always panic, clippy's `out_of_bound_indexing` already\nhandles those cases.\n\nTo avoid implicit panics from indexing and slicing.\n\nThere are \u201cchecked\u201d alternatives which do not panic, and can be used with `unwrap()` to make\nan explicit panic when it is desired."
    },
    {
      "id": "clippy::ineffective_open_options",
      "name": "INEFFECTIVE_OPEN_OPTIONS",
      "snake_name": "ineffective_open_options",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "usage of both `write(true)` and `append(true)` on same `OpenOptions`",
      "what_it_does": "Checks if both `.write(true)` and `.append(true)` methods are called\non a same `OpenOptions`.",
      "why_bad": "`.append(true)` already enables `write(true)`, making this one\nsuperfluous.",
      "example": "```no_run\n# use std::fs::OpenOptions;\nlet _ = OpenOptions::new()\n.write(true)\n.append(true)\n.create(true)\n.open(\"file.json\");\n```\nUse instead:\n```no_run\n# use std::fs::OpenOptions;\nlet _ = OpenOptions::new()\n.append(true)\n.create(true)\n.open(\"file.json\");\n```",
      "version": "1.76.0",
      "source_file": "ineffective_open_options.rs",
      "embedding_text": "usage of both `write(true)` and `append(true)` on same `OpenOptions`\n\nChecks if both `.write(true)` and `.append(true)` methods are called\non a same `OpenOptions`.\n\n`.append(true)` already enables `write(true)`, making this one\nsuperfluous."
    },
    {
      "id": "clippy::infallible_try_from",
      "name": "INFALLIBLE_TRY_FROM",
      "snake_name": "infallible_try_from",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "TryFrom with infallible Error type",
      "what_it_does": "Finds manual impls of `TryFrom` with infallible error types.",
      "why_bad": "Infallible conversions should be implemented via `From` with the blanket conversion.",
      "example": "```no_run\nuse std::convert::Infallible;\nstruct MyStruct(i16);\nimpl TryFrom<i16> for MyStruct {\ntype Error = Infallible;\nfn try_from(other: i16) -> Result<Self, Infallible> {\nOk(Self(other.into()))\n}\n}\n```\nUse instead:\n```no_run\nstruct MyStruct(i16);\nimpl From<i16> for MyStruct {\nfn from(other: i16) -> Self {\nSelf(other)\n}\n}\n```",
      "version": "1.89.0",
      "source_file": "infallible_try_from.rs",
      "embedding_text": "TryFrom with infallible Error type\n\nFinds manual impls of `TryFrom` with infallible error types.\n\nInfallible conversions should be implemented via `From` with the blanket conversion."
    },
    {
      "id": "clippy::infinite_iter",
      "name": "INFINITE_ITER",
      "snake_name": "infinite_iter",
      "category": "correctness",
      "weight": 1.2,
      "brief": "infinite iteration",
      "what_it_does": "Checks for iteration that is guaranteed to be infinite.",
      "why_bad": "While there may be places where this is acceptable\n(e.g., in event streams), in most cases this is simply an error.",
      "example": "```no_run\nuse std::iter;\n\niter::repeat(1_u8).collect::<Vec<_>>();\n```",
      "version": "pre 1.29.0",
      "source_file": "infinite_iter.rs",
      "embedding_text": "infinite iteration\n\nChecks for iteration that is guaranteed to be infinite.\n\nWhile there may be places where this is acceptable\n(e.g., in event streams), in most cases this is simply an error."
    },
    {
      "id": "clippy::maybe_infinite_iter",
      "name": "MAYBE_INFINITE_ITER",
      "snake_name": "maybe_infinite_iter",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "possible infinite iteration",
      "what_it_does": "Checks for iteration that may be infinite.",
      "why_bad": "While there may be places where this is acceptable\n(e.g., in event streams), in most cases this is simply an error.",
      "example": "```no_run\nlet infinite_iter = 0..;\n[0..].iter().zip(infinite_iter.take_while(|x| *x > 5));\n```",
      "version": "pre 1.29.0",
      "source_file": "infinite_iter.rs",
      "embedding_text": "possible infinite iteration\n\nChecks for iteration that may be infinite.\n\nWhile there may be places where this is acceptable\n(e.g., in event streams), in most cases this is simply an error."
    },
    {
      "id": "clippy::multiple_inherent_impl",
      "name": "MULTIPLE_INHERENT_IMPL",
      "snake_name": "multiple_inherent_impl",
      "category": "restriction",
      "weight": 1.0,
      "brief": "Multiple inherent impl that could be grouped",
      "what_it_does": "Checks for multiple inherent implementations of a struct\n\nThe config option controls the scope in which multiple inherent `impl` blocks for the same\nstruct are linted, allowing values of `module` (only within the same module), `file`\n(within the same file), or `crate` (anywhere in the crate, default).",
      "why_bad": "Splitting the implementation of a type makes the code harder to navigate.",
      "example": "```no_run\nstruct X;\nimpl X {\nfn one() {}\n}\nimpl X {\nfn other() {}\n}\n```\n\nCould be written:\n\n```no_run\nstruct X;\nimpl X {\nfn one() {}\nfn other() {}\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "inherent_impl.rs",
      "embedding_text": "Multiple inherent impl that could be grouped\n\nChecks for multiple inherent implementations of a struct\n\nThe config option controls the scope in which multiple inherent `impl` blocks for the same\nstruct are linted, allowing values of `module` (only within the same module), `file`\n(within the same file), or `crate` (anywhere in the crate, default).\n\nSplitting the implementation of a type makes the code harder to navigate."
    },
    {
      "id": "clippy::inherent_to_string",
      "name": "INHERENT_TO_STRING",
      "snake_name": "inherent_to_string",
      "category": "style",
      "weight": 0.95,
      "brief": "type implements inherent method `to_string()`, but should instead implement the `Display` trait",
      "what_it_does": "Checks for the definition of inherent methods with a signature of `to_string(&self) -> String`.",
      "why_bad": "This method is also implicitly defined if a type implements the `Display` trait. As the functionality of `Display` is much more versatile, it should be preferred.",
      "example": "```no_run\npub struct A;\n\nimpl A {\npub fn to_string(&self) -> String {\n\"I am A\".to_string()\n}\n}\n```\n\nUse instead:\n```no_run\nuse std::fmt;\n\npub struct A;\n\nimpl fmt::Display for A {\nfn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\nwrite!(f, \"I am A\")\n}\n}\n```",
      "version": "1.38.0",
      "source_file": "inherent_to_string.rs",
      "embedding_text": "type implements inherent method `to_string()`, but should instead implement the `Display` trait\n\nChecks for the definition of inherent methods with a signature of `to_string(&self) -> String`.\n\nThis method is also implicitly defined if a type implements the `Display` trait. As the functionality of `Display` is much more versatile, it should be preferred."
    },
    {
      "id": "clippy::inherent_to_string_shadow_display",
      "name": "INHERENT_TO_STRING_SHADOW_DISPLAY",
      "snake_name": "inherent_to_string_shadow_display",
      "category": "correctness",
      "weight": 1.2,
      "brief": "type implements inherent method `to_string()`, which gets shadowed by the implementation of the `Display` trait",
      "what_it_does": "Checks for the definition of inherent methods with a signature of `to_string(&self) -> String` and if the type implementing this method also implements the `Display` trait.",
      "why_bad": "This method is also implicitly defined if a type implements the `Display` trait. The less versatile inherent method will then shadow the implementation introduced by `Display`.",
      "example": "```no_run\nuse std::fmt;\n\npub struct A;\n\nimpl A {\npub fn to_string(&self) -> String {\n\"I am A\".to_string()\n}\n}\n\nimpl fmt::Display for A {\nfn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\nwrite!(f, \"I am A, too\")\n}\n}\n```\n\nUse instead:\n```no_run\nuse std::fmt;\n\npub struct A;\n\nimpl fmt::Display for A {\nfn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\nwrite!(f, \"I am A\")\n}\n}\n```",
      "version": "1.38.0",
      "source_file": "inherent_to_string.rs",
      "embedding_text": "type implements inherent method `to_string()`, which gets shadowed by the implementation of the `Display` trait\n\nChecks for the definition of inherent methods with a signature of `to_string(&self) -> String` and if the type implementing this method also implements the `Display` trait.\n\nThis method is also implicitly defined if a type implements the `Display` trait. The less versatile inherent method will then shadow the implementation introduced by `Display`."
    },
    {
      "id": "clippy::init_numbered_fields",
      "name": "INIT_NUMBERED_FIELDS",
      "snake_name": "init_numbered_fields",
      "category": "style",
      "weight": 0.95,
      "brief": "numbered fields in tuple struct initializer",
      "what_it_does": "Checks for tuple structs initialized with field syntax.\nIt will however not lint if a base initializer is present.\nThe lint will also ignore code in macros.",
      "why_bad": "This may be confusing to the uninitiated and adds no\nbenefit as opposed to tuple initializers",
      "example": "```no_run\nstruct TupleStruct(u8, u16);\n\nlet _ = TupleStruct {\n0: 1,\n1: 23,\n};\n\n// should be written as\nlet base = TupleStruct(1, 23);\n\n// This is OK however\nlet _ = TupleStruct { 0: 42, ..base };\n```",
      "version": "1.59.0",
      "source_file": "init_numbered_fields.rs",
      "embedding_text": "numbered fields in tuple struct initializer\n\nChecks for tuple structs initialized with field syntax.\nIt will however not lint if a base initializer is present.\nThe lint will also ignore code in macros.\n\nThis may be confusing to the uninitiated and adds no\nbenefit as opposed to tuple initializers"
    },
    {
      "id": "clippy::inline_fn_without_body",
      "name": "INLINE_FN_WITHOUT_BODY",
      "snake_name": "inline_fn_without_body",
      "category": "correctness",
      "weight": 1.2,
      "brief": "use of `#[inline]` on trait methods without bodies",
      "what_it_does": "Checks for `#[inline]` on trait methods without bodies",
      "why_bad": "Only implementations of trait methods may be inlined.\nThe inline attribute is ignored for trait methods without bodies.",
      "example": "```no_run\ntrait Animal {\n#[inline]\nfn name(&self) -> &'static str;\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "inline_fn_without_body.rs",
      "embedding_text": "use of `#[inline]` on trait methods without bodies\n\nChecks for `#[inline]` on trait methods without bodies\n\nOnly implementations of trait methods may be inlined.\nThe inline attribute is ignored for trait methods without bodies."
    },
    {
      "id": "clippy::int_plus_one",
      "name": "INT_PLUS_ONE",
      "snake_name": "int_plus_one",
      "category": "complexity",
      "weight": 1.0,
      "brief": "instead of using `x >= y + 1`, use `x > y`",
      "what_it_does": "Checks for usage of `x >= y + 1` or `x - 1 >= y` (and `<=`) in a block",
      "why_bad": "Readability -- better to use `> y` instead of `>= y + 1`.",
      "example": "```no_run\n# let x = 1;\n# let y = 1;\nif x >= y + 1 {}\n```\n\nUse instead:\n```no_run\n# let x = 1;\n# let y = 1;\nif x > y {}\n```",
      "version": "pre 1.29.0",
      "source_file": "int_plus_one.rs",
      "embedding_text": "instead of using `x >= y + 1`, use `x > y`\n\nChecks for usage of `x >= y + 1` or `x - 1 >= y` (and `<=`) in a block\n\nReadability -- better to use `> y` instead of `>= y + 1`."
    },
    {
      "id": "clippy::enum_variant_names",
      "name": "ENUM_VARIANT_NAMES",
      "snake_name": "enum_variant_names",
      "category": "style",
      "weight": 0.95,
      "brief": "enums where all variants share a prefix/postfix",
      "what_it_does": "Detects enumeration variants that are prefixed or suffixed\nby the same characters.",
      "why_bad": "Enumeration variant names should specify their variant,\nnot repeat the enumeration name.",
      "example": "```no_run\nenum Cake {\nBlackForestCake,\nHummingbirdCake,\nBattenbergCake,\n}\n```\nUse instead:\n```no_run\nenum Cake {\nBlackForest,\nHummingbird,\nBattenberg,\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "item_name_repetitions.rs",
      "embedding_text": "enums where all variants share a prefix/postfix\n\nDetects enumeration variants that are prefixed or suffixed\nby the same characters.\n\nEnumeration variant names should specify their variant,\nnot repeat the enumeration name."
    },
    {
      "id": "clippy::module_name_repetitions",
      "name": "MODULE_NAME_REPETITIONS",
      "snake_name": "module_name_repetitions",
      "category": "restriction",
      "weight": 1.0,
      "brief": "type names prefixed/postfixed with their containing module's name",
      "what_it_does": "Detects public item names that are prefixed or suffixed by the\ncontaining public module's name.",
      "why_bad": "It requires the user to type the module name twice in each usage,\nespecially if they choose to import the module rather than its contents.\n\nLack of such repetition is also the style used in the Rust standard library;\ne.g. `io::Error` and `fmt::Error` rather than `io::IoError` and `fmt::FmtError`;\nand `array::from_ref` rather than `array::array_from_ref`.",
      "example": "```no_run\nmod cake {\nstruct BlackForestCake;\n}\n```\n\nUse instead:\n```no_run\nmod cake {\nstruct BlackForest;\n}\n```",
      "version": "1.33.0",
      "source_file": "item_name_repetitions.rs",
      "embedding_text": "type names prefixed/postfixed with their containing module's name\n\nDetects public item names that are prefixed or suffixed by the\ncontaining public module's name.\n\nIt requires the user to type the module name twice in each usage,\nespecially if they choose to import the module rather than its contents.\n\nLack of such repetition is also the style used in the Rust standard library;\ne.g. `io::Error` and `fmt::Error` rather than `io::IoError` and `fmt::FmtError`;\nand `array::from_ref` rather than `array::array_from_ref`."
    },
    {
      "id": "clippy::module_inception",
      "name": "MODULE_INCEPTION",
      "snake_name": "module_inception",
      "category": "style",
      "weight": 0.95,
      "brief": "modules that have the same name as their parent module",
      "what_it_does": "Checks for modules that have the same name as their\nparent module",
      "why_bad": "A typical beginner mistake is to have `mod foo;` and\nagain `mod foo { ..\n}` in `foo.rs`.\nThe expectation is that items inside the inner `mod foo { .. }` are then\navailable\nthrough `foo::x`, but they are only available through\n`foo::foo::x`.\nIf this is done on purpose, it would be better to choose a more\nrepresentative module name.",
      "example": "```ignore\n// lib.rs\nmod foo;\n// foo.rs\nmod foo {\n...\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "item_name_repetitions.rs",
      "embedding_text": "modules that have the same name as their parent module\n\nChecks for modules that have the same name as their\nparent module\n\nA typical beginner mistake is to have `mod foo;` and\nagain `mod foo { ..\n}` in `foo.rs`.\nThe expectation is that items inside the inner `mod foo { .. }` are then\navailable\nthrough `foo::x`, but they are only available through\n`foo::foo::x`.\nIf this is done on purpose, it would be better to choose a more\nrepresentative module name."
    },
    {
      "id": "clippy::struct_field_names",
      "name": "STRUCT_FIELD_NAMES",
      "snake_name": "struct_field_names",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "structs where all fields share a prefix/postfix or contain the name of the struct",
      "what_it_does": "Detects struct fields that are prefixed or suffixed\nby the same characters or the name of the struct itself.",
      "why_bad": "Information common to all struct fields is better represented in the struct name.",
      "example": "```no_run\nstruct Cake {\ncake_sugar: u8,\ncake_flour: u8,\ncake_eggs: u8\n}\n```\nUse instead:\n```no_run\nstruct Cake {\nsugar: u8,\nflour: u8,\neggs: u8\n}\n```",
      "version": "1.75.0",
      "source_file": "item_name_repetitions.rs",
      "embedding_text": "structs where all fields share a prefix/postfix or contain the name of the struct\n\nDetects struct fields that are prefixed or suffixed\nby the same characters or the name of the struct itself.\n\nInformation common to all struct fields is better represented in the struct name."
    },
    {
      "id": "clippy::items_after_statements",
      "name": "ITEMS_AFTER_STATEMENTS",
      "snake_name": "items_after_statements",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "blocks where an item comes after a statement",
      "what_it_does": "Checks for items declared after some statement in a block.",
      "why_bad": "Items live for the entire scope they are declared\nin. But statements are processed in order. This might cause confusion as\nit's hard to figure out which item is meant in a statement.",
      "example": "```no_run\nfn foo() {\nprintln!(\"cake\");\n}\n\nfn main() {\nfoo(); // prints \"foo\"\nfn foo() {\nprintln!(\"foo\");\n}\nfoo(); // prints \"foo\"\n}\n```\n\nUse instead:\n```no_run\nfn foo() {\nprintln!(\"cake\");\n}\n\nfn main() {\nfn foo() {\nprintln!(\"foo\");\n}\nfoo(); // prints \"foo\"\nfoo(); // prints \"foo\"\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "items_after_statements.rs",
      "embedding_text": "blocks where an item comes after a statement\n\nChecks for items declared after some statement in a block.\n\nItems live for the entire scope they are declared\nin. But statements are processed in order. This might cause confusion as\nit's hard to figure out which item is meant in a statement."
    },
    {
      "id": "clippy::iter_not_returning_iterator",
      "name": "ITER_NOT_RETURNING_ITERATOR",
      "snake_name": "iter_not_returning_iterator",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "methods named `iter` or `iter_mut` that do not return an `Iterator`",
      "what_it_does": "Detects methods named `iter` or `iter_mut` that do not have a return type that implements `Iterator`.",
      "why_bad": "Methods named `iter` or `iter_mut` conventionally return an `Iterator`.",
      "example": "```no_run\n// `String` does not implement `Iterator`\nstruct Data {}\nimpl Data {\nfn iter(&self) -> String {\ntodo!()\n}\n}\n```\nUse instead:\n```no_run\nuse std::str::Chars;\nstruct Data {}\nimpl Data {\nfn iter(&self) -> Chars<'static> {\ntodo!()\n}\n}\n```",
      "version": "1.57.0",
      "source_file": "iter_not_returning_iterator.rs",
      "embedding_text": "methods named `iter` or `iter_mut` that do not return an `Iterator`\n\nDetects methods named `iter` or `iter_mut` that do not have a return type that implements `Iterator`.\n\nMethods named `iter` or `iter_mut` conventionally return an `Iterator`."
    },
    {
      "id": "clippy::iter_over_hash_type",
      "name": "ITER_OVER_HASH_TYPE",
      "snake_name": "iter_over_hash_type",
      "category": "restriction",
      "weight": 1.0,
      "brief": "iterating over unordered hash-based types (`HashMap` and `HashSet`)",
      "what_it_does": "This is a restriction lint which prevents the use of hash types (i.e., `HashSet` and `HashMap`) in for loops.",
      "why_bad": "Because hash types are unordered, when iterated through such as in a `for` loop, the values are returned in\nan undefined order. As a result, on redundant systems this may cause inconsistencies and anomalies.\nIn addition, the unknown order of the elements may reduce readability or introduce other undesired\nside effects.",
      "example": "```no_run\nlet my_map = std::collections::HashMap::<i32, String>::new();\nfor (key, value) in my_map { /* ... */ }\n```\nUse instead:\n```no_run\nlet my_map = std::collections::HashMap::<i32, String>::new();\nlet mut keys = my_map.keys().clone().collect::<Vec<_>>();\nkeys.sort();\nfor key in keys {\nlet value = &my_map[key];\n}\n```",
      "version": "1.76.0",
      "source_file": "iter_over_hash_type.rs",
      "embedding_text": "iterating over unordered hash-based types (`HashMap` and `HashSet`)\n\nThis is a restriction lint which prevents the use of hash types (i.e., `HashSet` and `HashMap`) in for loops.\n\nBecause hash types are unordered, when iterated through such as in a `for` loop, the values are returned in\nan undefined order. As a result, on redundant systems this may cause inconsistencies and anomalies.\nIn addition, the unknown order of the elements may reduce readability or introduce other undesired\nside effects."
    },
    {
      "id": "clippy::iter_without_into_iter",
      "name": "ITER_WITHOUT_INTO_ITER",
      "snake_name": "iter_without_into_iter",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "implementing `iter(_mut)` without an associated `IntoIterator for (&|&mut) Type` impl",
      "what_it_does": "Looks for `iter` and `iter_mut` methods without an associated `IntoIterator for (&|&mut) Type` implementation.",
      "why_bad": "It's not bad, but having them is idiomatic and allows the type to be used in for loops directly\n(`for val in &iter {}`), without having to first call `iter()` or `iter_mut()`.",
      "example": "```no_run\nstruct MySlice<'a>(&'a [u8]);\nimpl<'a> MySlice<'a> {\npub fn iter(&self) -> std::slice::Iter<'a, u8> {\nself.0.iter()\n}\n}\n```\nUse instead:\n```no_run\nstruct MySlice<'a>(&'a [u8]);\nimpl<'a> MySlice<'a> {\npub fn iter(&self) -> std::slice::Iter<'a, u8> {\nself.0.iter()\n}\n}\nimpl<'a> IntoIterator for &MySlice<'a> {\ntype Item = &'a u8;\ntype IntoIter = std::slice::Iter<'a, u8>;\nfn into_iter(self) -> Self::IntoIter {\nself.iter()\n}\n}\n```",
      "version": "1.75.0",
      "source_file": "iter_without_into_iter.rs",
      "embedding_text": "implementing `iter(_mut)` without an associated `IntoIterator for (&|&mut) Type` impl\n\nLooks for `iter` and `iter_mut` methods without an associated `IntoIterator for (&|&mut) Type` implementation.\n\nIt's not bad, but having them is idiomatic and allows the type to be used in for loops directly\n(`for val in &iter {}`), without having to first call `iter()` or `iter_mut()`."
    },
    {
      "id": "clippy::into_iter_without_iter",
      "name": "INTO_ITER_WITHOUT_ITER",
      "snake_name": "into_iter_without_iter",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "implementing `IntoIterator for (&|&mut) Type` without an inherent `iter(_mut)` method",
      "what_it_does": "This is the opposite of the `iter_without_into_iter` lint.\nIt looks for `IntoIterator for (&|&mut) Type` implementations without an inherent `iter` or `iter_mut` method\non the type or on any of the types in its `Deref` chain.",
      "why_bad": "It's not bad, but having them is idiomatic and allows the type to be used in iterator chains\nby just calling `.iter()`, instead of the more awkward `<&Type>::into_iter` or `(&val).into_iter()` syntax\nin case of ambiguity with another `IntoIterator` impl.",
      "example": "```no_run\nstruct MySlice<'a>(&'a [u8]);\nimpl<'a> IntoIterator for &MySlice<'a> {\ntype Item = &'a u8;\ntype IntoIter = std::slice::Iter<'a, u8>;\nfn into_iter(self) -> Self::IntoIter {\nself.0.iter()\n}\n}\n```\nUse instead:\n```no_run\nstruct MySlice<'a>(&'a [u8]);\nimpl<'a> MySlice<'a> {\npub fn iter(&self) -> std::slice::Iter<'a, u8> {\nself.into_iter()\n}\n}\nimpl<'a> IntoIterator for &MySlice<'a> {\ntype Item = &'a u8;\ntype IntoIter = std::slice::Iter<'a, u8>;\nfn into_iter(self) -> Self::IntoIter {\nself.0.iter()\n}\n}\n```",
      "version": "1.75.0",
      "source_file": "iter_without_into_iter.rs",
      "embedding_text": "implementing `IntoIterator for (&|&mut) Type` without an inherent `iter(_mut)` method\n\nThis is the opposite of the `iter_without_into_iter` lint.\nIt looks for `IntoIterator for (&|&mut) Type` implementations without an inherent `iter` or `iter_mut` method\non the type or on any of the types in its `Deref` chain.\n\nIt's not bad, but having them is idiomatic and allows the type to be used in iterator chains\nby just calling `.iter()`, instead of the more awkward `<&Type>::into_iter` or `(&val).into_iter()` syntax\nin case of ambiguity with another `IntoIterator` impl."
    },
    {
      "id": "clippy::large_const_arrays",
      "name": "LARGE_CONST_ARRAYS",
      "snake_name": "large_const_arrays",
      "category": "perf",
      "weight": 1.0,
      "brief": "large non-scalar const array may cause performance overhead",
      "what_it_does": "Checks for large `const` arrays that should\nbe defined as `static` instead.",
      "why_bad": "Performance: const variables are inlined upon use.\nStatic items result in only one instance and has a fixed location in memory.",
      "example": "```rust,ignore\npub const a = [0u32; 1_000_000];\n```\n\nUse instead:\n```rust,ignore\npub static a = [0u32; 1_000_000];\n```",
      "version": "1.44.0",
      "source_file": "large_const_arrays.rs",
      "embedding_text": "large non-scalar const array may cause performance overhead\n\nChecks for large `const` arrays that should\nbe defined as `static` instead.\n\nPerformance: const variables are inlined upon use.\nStatic items result in only one instance and has a fixed location in memory."
    },
    {
      "id": "clippy::large_enum_variant",
      "name": "LARGE_ENUM_VARIANT",
      "snake_name": "large_enum_variant",
      "category": "perf",
      "weight": 1.0,
      "brief": "large size difference between variants on an enum",
      "what_it_does": "Checks for large size differences between variants on\n`enum`s.",
      "why_bad": "Enum size is bounded by the largest variant. Having one\nlarge variant can penalize the memory layout of that enum.",
      "example": "```no_run\nenum Test {\nA(i32),\nB([i32; 8000]),\n}\n```\n\nUse instead:\n```no_run\n// Possibly better\nenum Test2 {\nA(i32),\nB(Box<[i32; 8000]>),\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "large_enum_variant.rs",
      "embedding_text": "large size difference between variants on an enum\n\nChecks for large size differences between variants on\n`enum`s.\n\nEnum size is bounded by the largest variant. Having one\nlarge variant can penalize the memory layout of that enum."
    },
    {
      "id": "clippy::large_futures",
      "name": "LARGE_FUTURES",
      "snake_name": "large_futures",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "large future may lead to unexpected stack overflows",
      "what_it_does": "It checks for the size of a `Future` created by `async fn` or `async {}`.",
      "why_bad": "Due to the current [unideal implementation](https://github.com/rust-lang/rust/issues/69826) of `Coroutine`,\nlarge size of a `Future` may cause stack overflows.",
      "example": "```no_run\nasync fn large_future(_x: [u8; 16 * 1024]) {}\n\npub async fn trigger() {\nlarge_future([0u8; 16 * 1024]).await;\n}\n```\n\n`Box::pin` the big future instead.\n\n```no_run\nasync fn large_future(_x: [u8; 16 * 1024]) {}\n\npub async fn trigger() {\nBox::pin(large_future([0u8; 16 * 1024])).await;\n}\n```",
      "version": "1.70.0",
      "source_file": "large_futures.rs",
      "embedding_text": "large future may lead to unexpected stack overflows\n\nIt checks for the size of a `Future` created by `async fn` or `async {}`.\n\nDue to the current [unideal implementation](https://github.com/rust-lang/rust/issues/69826) of `Coroutine`,\nlarge size of a `Future` may cause stack overflows."
    },
    {
      "id": "clippy::large_include_file",
      "name": "LARGE_INCLUDE_FILE",
      "snake_name": "large_include_file",
      "category": "restriction",
      "weight": 1.0,
      "brief": "including a large file",
      "what_it_does": "Checks for the inclusion of large files via `include_bytes!()`\nor `include_str!()`.",
      "why_bad": "Including large files can undesirably increase the size of the binary produced by the compiler.\nThis lint may be used to catch mistakes where an unexpectedly large file is included, or\ntemporarily to obtain a list of all large files.",
      "example": "```rust,ignore\nlet included_str = include_str!(\"very_large_file.txt\");\nlet included_bytes = include_bytes!(\"very_large_file.txt\");\n```\n\nUse instead:\n```rust,ignore\nuse std::fs;\n\n// You can load the file at runtime\nlet string = fs::read_to_string(\"very_large_file.txt\")?;\nlet bytes = fs::read(\"very_large_file.txt\")?;\n```",
      "version": "1.62.0",
      "source_file": "large_include_file.rs",
      "embedding_text": "including a large file\n\nChecks for the inclusion of large files via `include_bytes!()`\nor `include_str!()`.\n\nIncluding large files can undesirably increase the size of the binary produced by the compiler.\nThis lint may be used to catch mistakes where an unexpectedly large file is included, or\ntemporarily to obtain a list of all large files."
    },
    {
      "id": "clippy::large_stack_arrays",
      "name": "LARGE_STACK_ARRAYS",
      "snake_name": "large_stack_arrays",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "allocating large arrays on stack may cause stack overflow",
      "what_it_does": "Checks for local arrays that may be too large.",
      "why_bad": "Large local arrays may cause stack overflow.",
      "example": "```rust,ignore\nlet a = [0u32; 1_000_000];\n```",
      "version": "1.41.0",
      "source_file": "large_stack_arrays.rs",
      "embedding_text": "allocating large arrays on stack may cause stack overflow\n\nChecks for local arrays that may be too large.\n\nLarge local arrays may cause stack overflow."
    },
    {
      "id": "clippy::large_stack_frames",
      "name": "LARGE_STACK_FRAMES",
      "snake_name": "large_stack_frames",
      "category": "nursery",
      "weight": 0.9,
      "brief": "checks for functions that allocate a lot of stack space",
      "what_it_does": "Checks for functions that use a lot of stack space.\n\nThis often happens when constructing a large type, such as an array with a lot of elements,\nor constructing *many* smaller-but-still-large structs, or copying around a lot of large types.\n\nThis lint is a more general version of [`large_stack_arrays`](https://rust-lang.github.io/rust-clippy/master/#large_stack_arrays)\nthat is intended to look at functions as a whole instead of only individual array expressions inside of a function.",
      "why_bad": "The stack region of memory is very limited in size (usually *much* smaller than the heap) and attempting to\nuse too much will result in a stack overflow and crash the program.\nTo avoid this, you should consider allocating large types on the heap instead (e.g. by boxing them).\n\nKeep in mind that the code path to construction of large types does not even need to be reachable;\nit purely needs to *exist* inside of the function to contribute to the stack size.\nFor example, this causes a stack overflow even though the branch is unreachable:\n```rust,ignore\nfn main() {\nif false {\nlet x = [0u8; 10000000]; // 10 MB stack array\nblack_box(&x);\n}\n}\n```",
      "example": "This function creates four 500 KB arrays on the stack. Quite big but just small enough to not trigger `large_stack_arrays`.\nHowever, looking at the function as a whole, it's clear that this uses a lot of stack space.\n```no_run\nstruct QuiteLargeType([u8; 500_000]);\nfn foo() {\n// ... some function that uses a lot of stack space ...\nlet _x1 = QuiteLargeType([0; 500_000]);\nlet _x2 = QuiteLargeType([0; 500_000]);\nlet _x3 = QuiteLargeType([0; 500_000]);\nlet _x4 = QuiteLargeType([0; 500_000]);\n}\n```\n\nInstead of doing this, allocate the arrays on the heap.\nThis currently requires going through a `Vec` first and then converting it to a `Box`:\n```no_run\nstruct NotSoLargeType(Box<[u8]>);\n\nfn foo() {\nlet _x1 = NotSoLargeType(vec![0; 500_000].into_boxed_slice());\n//                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  Now heap allocated.\n//                                                                The size of `NotSoLargeType` is 16 bytes.\n//  ...\n}\n```",
      "version": "1.72.0",
      "source_file": "large_stack_frames.rs",
      "embedding_text": "checks for functions that allocate a lot of stack space\n\nChecks for functions that use a lot of stack space.\n\nThis often happens when constructing a large type, such as an array with a lot of elements,\nor constructing *many* smaller-but-still-large structs, or copying around a lot of large types.\n\nThis lint is a more general version of [`large_stack_arrays`](https://rust-lang.github.io/rust-clippy/master/#large_stack_arrays)\nthat is intended to look at functions as a whole instead of only individual array expressions inside of a function.\n\nThe stack region of memory is very limited in size (usually *much* smaller than the heap) and attempting to\nuse too much will result in a stack overflow and crash the program.\nTo avoid this, you should consider allocating large types on the heap instead (e.g. by boxing them).\n\nKeep in mind that the code path to construction of large types does not even need to be reachable;\nit purely needs to *exist* inside of the function to contribute to the stack size.\nFor example, this causes a stack overflow even though the branch is unreachable:\n```rust,ignore\nfn main() {\nif false {\nlet x = [0u8; 10000000]; // 10 MB stack array\nblack_box(&x);\n}\n}\n```"
    },
    {
      "id": "clippy::legacy_numeric_constants",
      "name": "LEGACY_NUMERIC_CONSTANTS",
      "snake_name": "legacy_numeric_constants",
      "category": "style",
      "weight": 0.95,
      "brief": "checks for usage of legacy std numeric constants and methods",
      "what_it_does": "Checks for usage of `<integer>::max_value()`, `std::<integer>::MAX`,\n`std::<float>::EPSILON`, etc.",
      "why_bad": "All of these have been superseded by the associated constants on their respective types,\nsuch as `i128::MAX`. These legacy items may be deprecated in a future version of rust.",
      "example": "```rust\nlet eps = std::f32::EPSILON;\n```\nUse instead:\n```rust\nlet eps = f32::EPSILON;\n```",
      "version": "1.79.0",
      "source_file": "legacy_numeric_constants.rs",
      "embedding_text": "checks for usage of legacy std numeric constants and methods\n\nChecks for usage of `<integer>::max_value()`, `std::<integer>::MAX`,\n`std::<float>::EPSILON`, etc.\n\nAll of these have been superseded by the associated constants on their respective types,\nsuch as `i128::MAX`. These legacy items may be deprecated in a future version of rust."
    },
    {
      "id": "clippy::len_without_is_empty",
      "name": "LEN_WITHOUT_IS_EMPTY",
      "snake_name": "len_without_is_empty",
      "category": "style",
      "weight": 0.95,
      "brief": "traits or impls with a public `len` method but no corresponding `is_empty` method",
      "what_it_does": "Checks for items that implement `.len()` but not\n`.is_empty()`.",
      "why_bad": "It is good custom to have both methods, because for\nsome data structures, asking about the length will be a costly operation,\nwhereas `.is_empty()` can usually answer in constant time. Also it used to\nlead to false positives on the [`len_zero`](#len_zero) lint \u2013 currently that\nlint will ignore such entities.",
      "example": "```ignore\nimpl X {\npub fn len(&self) -> usize {\n..\n}\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "len_without_is_empty.rs",
      "embedding_text": "traits or impls with a public `len` method but no corresponding `is_empty` method\n\nChecks for items that implement `.len()` but not\n`.is_empty()`.\n\nIt is good custom to have both methods, because for\nsome data structures, asking about the length will be a costly operation,\nwhereas `.is_empty()` can usually answer in constant time. Also it used to\nlead to false positives on the [`len_zero`](#len_zero) lint \u2013 currently that\nlint will ignore such entities."
    },
    {
      "id": "clippy::len_zero",
      "name": "LEN_ZERO",
      "snake_name": "len_zero",
      "category": "style",
      "weight": 0.95,
      "brief": "checking `.len() == 0` or `.len() > 0` (or similar) when `.is_empty()` could be used instead",
      "what_it_does": "Checks for getting the length of something via `.len()`\njust to compare to zero, and suggests using `.is_empty()` where applicable.",
      "why_bad": "Some structures can answer `.is_empty()` much faster\nthan calculating their length. So it is good to get into the habit of using\n`.is_empty()`, and having it is cheap.\nBesides, it makes the intent clearer than a manual comparison in some contexts.",
      "example": "```ignore\nif x.len() == 0 {\n..\n}\nif y.len() != 0 {\n..\n}\n```\ninstead use\n```ignore\nif x.is_empty() {\n..\n}\nif !y.is_empty() {\n..\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "len_zero.rs",
      "embedding_text": "checking `.len() == 0` or `.len() > 0` (or similar) when `.is_empty()` could be used instead\n\nChecks for getting the length of something via `.len()`\njust to compare to zero, and suggests using `.is_empty()` where applicable.\n\nSome structures can answer `.is_empty()` much faster\nthan calculating their length. So it is good to get into the habit of using\n`.is_empty()`, and having it is cheap.\nBesides, it makes the intent clearer than a manual comparison in some contexts."
    },
    {
      "id": "clippy::comparison_to_empty",
      "name": "COMPARISON_TO_EMPTY",
      "snake_name": "comparison_to_empty",
      "category": "style",
      "weight": 0.95,
      "brief": "checking `x == \\",
      "what_it_does": "Checks for comparing to an empty slice such as `\"\"` or `[]`,\nand suggests using `.is_empty()` where applicable.",
      "why_bad": "Some structures can answer `.is_empty()` much faster\nthan checking for equality. So it is good to get into the habit of using\n`.is_empty()`, and having it is cheap.\nBesides, it makes the intent clearer than a manual comparison in some contexts.",
      "example": "```ignore\nif s == \"\" {\n..\n}\n\nif arr == [] {\n..\n}\n```\nUse instead:\n```ignore\nif s.is_empty() {\n..\n}\n\nif arr.is_empty() {\n..\n}\n```",
      "version": "1.49.0",
      "source_file": "len_zero.rs",
      "embedding_text": "checking `x == \\\n\nChecks for comparing to an empty slice such as `\"\"` or `[]`,\nand suggests using `.is_empty()` where applicable.\n\nSome structures can answer `.is_empty()` much faster\nthan checking for equality. So it is good to get into the habit of using\n`.is_empty()`, and having it is cheap.\nBesides, it makes the intent clearer than a manual comparison in some contexts."
    },
    {
      "id": "clippy::useless_let_if_seq",
      "name": "USELESS_LET_IF_SEQ",
      "snake_name": "useless_let_if_seq",
      "category": "nursery",
      "weight": 0.9,
      "brief": "unidiomatic `let mut` declaration followed by initialization in `if`",
      "what_it_does": "Checks for variable declarations immediately followed by a\nconditional affectation.",
      "why_bad": "This is not idiomatic Rust.",
      "example": "```rust,ignore\nlet foo;\n\nif bar() {\nfoo = 42;\n} else {\nfoo = 0;\n}\n\nlet mut baz = None;\n\nif bar() {\nbaz = Some(42);\n}\n```\n\nshould be written\n\n```rust,ignore\nlet foo = if bar() {\n42\n} else {\n0\n};\n\nlet baz = if bar() {\nSome(42)\n} else {\nNone\n};\n```",
      "version": "pre 1.29.0",
      "source_file": "let_if_seq.rs",
      "embedding_text": "unidiomatic `let mut` declaration followed by initialization in `if`\n\nChecks for variable declarations immediately followed by a\nconditional affectation.\n\nThis is not idiomatic Rust."
    },
    {
      "id": "clippy::let_underscore_must_use",
      "name": "LET_UNDERSCORE_MUST_USE",
      "snake_name": "let_underscore_must_use",
      "category": "restriction",
      "weight": 1.0,
      "brief": "non-binding `let` on a `#[must_use]` expression",
      "what_it_does": "Checks for `let _ = <expr>` where expr is `#[must_use]`",
      "why_bad": "To ensure that all `#[must_use]` types are used rather than ignored.",
      "example": "```no_run\nfn f() -> Result<u32, u32> {\nOk(0)\n}\n\nlet _ = f();\n// is_ok() is marked #[must_use]\nlet _ = f().is_ok();\n```",
      "version": "1.42.0",
      "source_file": "let_underscore.rs",
      "embedding_text": "non-binding `let` on a `#[must_use]` expression\n\nChecks for `let _ = <expr>` where expr is `#[must_use]`\n\nTo ensure that all `#[must_use]` types are used rather than ignored."
    },
    {
      "id": "clippy::let_underscore_lock",
      "name": "LET_UNDERSCORE_LOCK",
      "snake_name": "let_underscore_lock",
      "category": "correctness",
      "weight": 1.2,
      "brief": "non-binding `let` on a synchronization lock",
      "what_it_does": "Checks for `let _ = sync_lock`. This supports `mutex` and `rwlock` in\n`parking_lot`. For `std` locks see the `rustc` lint\n[`let_underscore_lock`](https://doc.rust-lang.org/nightly/rustc/lints/listing/deny-by-default.html#let-underscore-lock)",
      "why_bad": "This statement immediately drops the lock instead of\nextending its lifetime to the end of the scope, which is often not intended.\nTo extend lock lifetime to the end of the scope, use an underscore-prefixed\nname instead (i.e. _lock). If you want to explicitly drop the lock,\n`std::mem::drop` conveys your intention better and is less error-prone.",
      "example": "```rust,ignore\nlet _ = mutex.lock();\n```\n\nUse instead:\n```rust,ignore\nlet _lock = mutex.lock();\n```",
      "version": "1.43.0",
      "source_file": "let_underscore.rs",
      "embedding_text": "non-binding `let` on a synchronization lock\n\nChecks for `let _ = sync_lock`. This supports `mutex` and `rwlock` in\n`parking_lot`. For `std` locks see the `rustc` lint\n[`let_underscore_lock`](https://doc.rust-lang.org/nightly/rustc/lints/listing/deny-by-default.html#let-underscore-lock)\n\nThis statement immediately drops the lock instead of\nextending its lifetime to the end of the scope, which is often not intended.\nTo extend lock lifetime to the end of the scope, use an underscore-prefixed\nname instead (i.e. _lock). If you want to explicitly drop the lock,\n`std::mem::drop` conveys your intention better and is less error-prone."
    },
    {
      "id": "clippy::let_underscore_future",
      "name": "LET_UNDERSCORE_FUTURE",
      "snake_name": "let_underscore_future",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "non-binding `let` on a future",
      "what_it_does": "Checks for `let _ = <expr>` where the resulting type of expr implements `Future`",
      "why_bad": "Futures must be polled for work to be done. The original intention was most likely to await the future\nand ignore the resulting value.",
      "example": "```no_run\nasync fn foo() -> Result<(), ()> {\nOk(())\n}\nlet _ = foo();\n```\n\nUse instead:\n```no_run\n# async fn context() {\nasync fn foo() -> Result<(), ()> {\nOk(())\n}\nlet _ = foo().await;\n# }\n```",
      "version": "1.67.0",
      "source_file": "let_underscore.rs",
      "embedding_text": "non-binding `let` on a future\n\nChecks for `let _ = <expr>` where the resulting type of expr implements `Future`\n\nFutures must be polled for work to be done. The original intention was most likely to await the future\nand ignore the resulting value."
    },
    {
      "id": "clippy::let_underscore_untyped",
      "name": "LET_UNDERSCORE_UNTYPED",
      "snake_name": "let_underscore_untyped",
      "category": "restriction",
      "weight": 1.0,
      "brief": "non-binding `let` without a type annotation",
      "what_it_does": "Checks for `let _ = <expr>` without a type annotation, and suggests to either provide one,\nor remove the `let` keyword altogether.",
      "why_bad": "The `let _ = <expr>` expression ignores the value of `<expr>`, but will continue to do so even\nif the type were to change, thus potentially introducing subtle bugs. By supplying a type\nannotation, one will be forced to re-visit the decision to ignore the value in such cases.",
      "example": "```no_run\nfn foo() -> Result<u32, ()> {\nOk(123)\n}\nlet _ = foo();\n```\nUse instead:\n```no_run\nfn foo() -> Result<u32, ()> {\nOk(123)\n}\n// Either provide a type annotation:\nlet _: Result<u32, ()> = foo();\n// \u2026or drop the let keyword:\n_ = foo();\n```",
      "version": "1.69.0",
      "source_file": "let_underscore.rs",
      "embedding_text": "non-binding `let` without a type annotation\n\nChecks for `let _ = <expr>` without a type annotation, and suggests to either provide one,\nor remove the `let` keyword altogether.\n\nThe `let _ = <expr>` expression ignores the value of `<expr>`, but will continue to do so even\nif the type were to change, thus potentially introducing subtle bugs. By supplying a type\nannotation, one will be forced to re-visit the decision to ignore the value in such cases."
    },
    {
      "id": "clippy::let_with_type_underscore",
      "name": "LET_WITH_TYPE_UNDERSCORE",
      "snake_name": "let_with_type_underscore",
      "category": "complexity",
      "weight": 1.0,
      "brief": "unneeded underscore type (`_`) in a variable declaration",
      "what_it_does": "Detects when a variable is declared with an explicit type of `_`.",
      "why_bad": "It adds noise, `: _` provides zero clarity or utility.",
      "example": "```rust,ignore\nlet my_number: _ = 1;\n```\nUse instead:\n```rust,ignore\nlet my_number = 1;\n```",
      "version": "1.70.0",
      "source_file": "let_with_type_underscore.rs",
      "embedding_text": "unneeded underscore type (`_`) in a variable declaration\n\nDetects when a variable is declared with an explicit type of `_`.\n\nIt adds noise, `: _` provides zero clarity or utility."
    },
    {
      "id": "clippy::needless_lifetimes",
      "name": "NEEDLESS_LIFETIMES",
      "snake_name": "needless_lifetimes",
      "category": "complexity",
      "weight": 1.0,
      "brief": "using explicit lifetimes for references in function arguments when elision rules \\\n     would allow omitting them",
      "what_it_does": "Checks for lifetime annotations which can be removed by\nrelying on lifetime elision.",
      "why_bad": "The additional lifetimes make the code look more\ncomplicated, while there is nothing out of the ordinary going on. Removing\nthem leads to more readable code.",
      "example": "```no_run\n// Unnecessary lifetime annotations\nfn in_and_out<'a>(x: &'a u8, y: u8) -> &'a u8 {\nx\n}\n```\n\nUse instead:\n```no_run\nfn elided(x: &u8, y: u8) -> &u8 {\nx\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "lifetimes.rs",
      "embedding_text": "using explicit lifetimes for references in function arguments when elision rules \\\n     would allow omitting them\n\nChecks for lifetime annotations which can be removed by\nrelying on lifetime elision.\n\nThe additional lifetimes make the code look more\ncomplicated, while there is nothing out of the ordinary going on. Removing\nthem leads to more readable code."
    },
    {
      "id": "clippy::elidable_lifetime_names",
      "name": "ELIDABLE_LIFETIME_NAMES",
      "snake_name": "elidable_lifetime_names",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "lifetime name that can be replaced with the anonymous lifetime",
      "what_it_does": "Checks for lifetime annotations which can be replaced with anonymous lifetimes (`'_`).",
      "why_bad": "The additional lifetimes can make the code look more complicated.",
      "example": "```no_run\n# use std::str::Chars;\nfn f<'a>(x: &'a str) -> Chars<'a> {\nx.chars()\n}\n```\n\nUse instead:\n```no_run\n# use std::str::Chars;\nfn f(x: &str) -> Chars<'_> {\nx.chars()\n}\n```",
      "version": "1.87.0",
      "source_file": "lifetimes.rs",
      "embedding_text": "lifetime name that can be replaced with the anonymous lifetime\n\nChecks for lifetime annotations which can be replaced with anonymous lifetimes (`'_`).\n\nThe additional lifetimes can make the code look more complicated."
    },
    {
      "id": "clippy::extra_unused_lifetimes",
      "name": "EXTRA_UNUSED_LIFETIMES",
      "snake_name": "extra_unused_lifetimes",
      "category": "complexity",
      "weight": 1.0,
      "brief": "unused lifetimes in function definitions",
      "what_it_does": "Checks for lifetimes in generics that are never used\nanywhere else.",
      "why_bad": "The additional lifetimes make the code look more\ncomplicated, while there is nothing out of the ordinary going on. Removing\nthem leads to more readable code.",
      "example": "```no_run\n// unnecessary lifetimes\nfn unused_lifetime<'a>(x: u8) {\n// ..\n}\n```\n\nUse instead:\n```no_run\nfn no_lifetime(x: u8) {\n// ...\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "lifetimes.rs",
      "embedding_text": "unused lifetimes in function definitions\n\nChecks for lifetimes in generics that are never used\nanywhere else.\n\nThe additional lifetimes make the code look more\ncomplicated, while there is nothing out of the ordinary going on. Removing\nthem leads to more readable code."
    },
    {
      "id": "clippy::unreadable_literal",
      "name": "UNREADABLE_LITERAL",
      "snake_name": "unreadable_literal",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "long literal without underscores",
      "what_it_does": "Warns if a long integral or floating-point constant does\nnot contain underscores.",
      "why_bad": "Reading long numbers is difficult without separators.",
      "example": "```no_run\n# let _: u64 =\n61864918973511\n# ;\n```\n\nUse instead:\n```no_run\n# let _: u64 =\n61_864_918_973_511\n# ;\n```",
      "version": "pre 1.29.0",
      "source_file": "literal_representation.rs",
      "embedding_text": "long literal without underscores\n\nWarns if a long integral or floating-point constant does\nnot contain underscores.\n\nReading long numbers is difficult without separators."
    },
    {
      "id": "clippy::mistyped_literal_suffixes",
      "name": "MISTYPED_LITERAL_SUFFIXES",
      "snake_name": "mistyped_literal_suffixes",
      "category": "correctness",
      "weight": 1.2,
      "brief": "mistyped literal suffix",
      "what_it_does": "Warns for mistyped suffix in literals",
      "why_bad": "This is most probably a typo",
      "example": "```ignore\n`2_32` => `2_i32`\n`250_8 => `250_u8`\n```",
      "version": "1.30.0",
      "source_file": "literal_representation.rs",
      "embedding_text": "mistyped literal suffix\n\nWarns for mistyped suffix in literals\n\nThis is most probably a typo"
    },
    {
      "id": "clippy::inconsistent_digit_grouping",
      "name": "INCONSISTENT_DIGIT_GROUPING",
      "snake_name": "inconsistent_digit_grouping",
      "category": "style",
      "weight": 0.95,
      "brief": "integer literals with digits grouped inconsistently",
      "what_it_does": "Warns if an integral or floating-point constant is\ngrouped inconsistently with underscores.",
      "why_bad": "Readers may incorrectly interpret inconsistently\ngrouped digits.",
      "example": "```no_run\n# let _: u64 =\n618_64_9189_73_511\n# ;\n```\n\nUse instead:\n```no_run\n# let _: u64 =\n61_864_918_973_511\n# ;\n```",
      "version": "pre 1.29.0",
      "source_file": "literal_representation.rs",
      "embedding_text": "integer literals with digits grouped inconsistently\n\nWarns if an integral or floating-point constant is\ngrouped inconsistently with underscores.\n\nReaders may incorrectly interpret inconsistently\ngrouped digits."
    },
    {
      "id": "clippy::unusual_byte_groupings",
      "name": "UNUSUAL_BYTE_GROUPINGS",
      "snake_name": "unusual_byte_groupings",
      "category": "style",
      "weight": 0.95,
      "brief": "binary or hex literals that aren't grouped by four",
      "what_it_does": "Warns if hexadecimal or binary literals are not grouped\nby nibble or byte.",
      "why_bad": "Negatively impacts readability.",
      "example": "```no_run\nlet x: u32 = 0xFFF_FFF;\nlet y: u8 = 0b01_011_101;\n```",
      "version": "1.49.0",
      "source_file": "literal_representation.rs",
      "embedding_text": "binary or hex literals that aren't grouped by four\n\nWarns if hexadecimal or binary literals are not grouped\nby nibble or byte.\n\nNegatively impacts readability."
    },
    {
      "id": "clippy::large_digit_groups",
      "name": "LARGE_DIGIT_GROUPS",
      "snake_name": "large_digit_groups",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "grouping digits into groups that are too large",
      "what_it_does": "Warns if the digits of an integral or floating-point\nconstant are grouped into groups that\nare too large.",
      "why_bad": "Negatively impacts readability.",
      "example": "```no_run\nlet x: u64 = 6186491_8973511;\n```",
      "version": "pre 1.29.0",
      "source_file": "literal_representation.rs",
      "embedding_text": "grouping digits into groups that are too large\n\nWarns if the digits of an integral or floating-point\nconstant are grouped into groups that\nare too large.\n\nNegatively impacts readability."
    },
    {
      "id": "clippy::decimal_literal_representation",
      "name": "DECIMAL_LITERAL_REPRESENTATION",
      "snake_name": "decimal_literal_representation",
      "category": "restriction",
      "weight": 1.0,
      "brief": "using decimal representation when hexadecimal would be better",
      "what_it_does": "Warns if there is a better representation for a numeric literal.",
      "why_bad": "Especially for big powers of 2, a hexadecimal representation is usually more\nreadable than a decimal representation.",
      "example": "```text\n`255` => `0xFF`\n`65_535` => `0xFFFF`\n`4_042_322_160` => `0xF0F0_F0F0`\n```",
      "version": "pre 1.29.0",
      "source_file": "literal_representation.rs",
      "embedding_text": "using decimal representation when hexadecimal would be better\n\nWarns if there is a better representation for a numeric literal.\n\nEspecially for big powers of 2, a hexadecimal representation is usually more\nreadable than a decimal representation."
    },
    {
      "id": "clippy::literal_string_with_formatting_args",
      "name": "LITERAL_STRING_WITH_FORMATTING_ARGS",
      "snake_name": "literal_string_with_formatting_args",
      "category": "nursery",
      "weight": 0.9,
      "brief": "Checks if string literals have formatting arguments",
      "what_it_does": "Checks if string literals have formatting arguments outside of macros\nusing them (like `format!`).",
      "why_bad": "It will likely not generate the expected content.",
      "example": "```no_run\nlet x: Option<usize> = None;\nlet y = \"hello\";\nx.expect(\"{y:?}\");\n```\nUse instead:\n```no_run\nlet x: Option<usize> = None;\nlet y = \"hello\";\nx.expect(&format!(\"{y:?}\"));\n```",
      "version": "1.85.0",
      "source_file": "literal_string_with_formatting_args.rs",
      "embedding_text": "Checks if string literals have formatting arguments\n\nChecks if string literals have formatting arguments outside of macros\nusing them (like `format!`).\n\nIt will likely not generate the expected content."
    },
    {
      "id": "clippy::manual_memcpy",
      "name": "MANUAL_MEMCPY",
      "snake_name": "manual_memcpy",
      "category": "perf",
      "weight": 1.0,
      "brief": "manually copying items between slices",
      "what_it_does": "Checks for for-loops that manually copy items between\nslices that could be optimized by having a memcpy.",
      "why_bad": "It is not as fast as a memcpy.",
      "example": "```no_run\n# let src = vec![1];\n# let mut dst = vec![0; 65];\nfor i in 0..src.len() {\ndst[i + 64] = src[i];\n}\n```\n\nUse instead:\n```no_run\n# let src = vec![1];\n# let mut dst = vec![0; 65];\ndst[64..(src.len() + 64)].clone_from_slice(&src[..]);\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "manually copying items between slices\n\nChecks for for-loops that manually copy items between\nslices that could be optimized by having a memcpy.\n\nIt is not as fast as a memcpy."
    },
    {
      "id": "clippy::needless_range_loop",
      "name": "NEEDLESS_RANGE_LOOP",
      "snake_name": "needless_range_loop",
      "category": "style",
      "weight": 0.95,
      "brief": "for-looping over a range of indices where an iterator over items would do",
      "what_it_does": "Checks for looping over the range of `0..len` of some\ncollection just to get the values by index.",
      "why_bad": "Just iterating the collection itself makes the intent\nmore clear and is probably faster because it eliminates\nthe bounds check that is done when indexing.",
      "example": "```no_run\nlet vec = vec!['a', 'b', 'c'];\nfor i in 0..vec.len() {\nprintln!(\"{}\", vec[i]);\n}\n```\n\nUse instead:\n```no_run\nlet vec = vec!['a', 'b', 'c'];\nfor i in vec {\nprintln!(\"{}\", i);\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "for-looping over a range of indices where an iterator over items would do\n\nChecks for looping over the range of `0..len` of some\ncollection just to get the values by index.\n\nJust iterating the collection itself makes the intent\nmore clear and is probably faster because it eliminates\nthe bounds check that is done when indexing."
    },
    {
      "id": "clippy::explicit_iter_loop",
      "name": "EXPLICIT_ITER_LOOP",
      "snake_name": "explicit_iter_loop",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "for-looping over `_.iter()` or `_.iter_mut()` when `&_` or `&mut _` would do",
      "what_it_does": "Checks for loops on `x.iter()` where `&x` will do, and\nsuggests the latter.",
      "why_bad": "Readability.",
      "example": "```no_run\n// with `y` a `Vec` or slice:\n# let y = vec![1];\nfor x in y.iter() {\n// ..\n}\n```\n\nUse instead:\n```no_run\n# let y = vec![1];\nfor x in &y {\n// ..\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "for-looping over `_.iter()` or `_.iter_mut()` when `&_` or `&mut _` would do\n\nChecks for loops on `x.iter()` where `&x` will do, and\nsuggests the latter.\n\nReadability."
    },
    {
      "id": "clippy::explicit_into_iter_loop",
      "name": "EXPLICIT_INTO_ITER_LOOP",
      "snake_name": "explicit_into_iter_loop",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "for-looping over `_.into_iter()` when `_` would do",
      "what_it_does": "Checks for loops on `y.into_iter()` where `y` will do, and\nsuggests the latter.",
      "why_bad": "Readability.",
      "example": "```no_run\n# let y = vec![1];\n// with `y` a `Vec` or slice:\nfor x in y.into_iter() {\n// ..\n}\n```\ncan be rewritten to\n```no_run\n# let y = vec![1];\nfor x in y {\n// ..\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "for-looping over `_.into_iter()` when `_` would do\n\nChecks for loops on `y.into_iter()` where `y` will do, and\nsuggests the latter.\n\nReadability."
    },
    {
      "id": "clippy::iter_next_loop",
      "name": "ITER_NEXT_LOOP",
      "snake_name": "iter_next_loop",
      "category": "correctness",
      "weight": 1.2,
      "brief": "for-looping over `_.next()` which is probably not intended",
      "what_it_does": "Checks for loops on `x.next()`.",
      "why_bad": "`next()` returns either `Some(value)` if there was a\nvalue, or `None` otherwise. The insidious thing is that `Option<_>`\nimplements `IntoIterator`, so that possibly one value will be iterated,\nleading to some hard to find bugs. No one will want to write such code\n[except to win an Underhanded Rust\nContest](https://www.reddit.com/r/rust/comments/3hb0wm/underhanded_rust_contest/cu5yuhr).",
      "example": "```ignore\nfor x in y.next() {\n..\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "for-looping over `_.next()` which is probably not intended\n\nChecks for loops on `x.next()`.\n\n`next()` returns either `Some(value)` if there was a\nvalue, or `None` otherwise. The insidious thing is that `Option<_>`\nimplements `IntoIterator`, so that possibly one value will be iterated,\nleading to some hard to find bugs. No one will want to write such code\n[except to win an Underhanded Rust\nContest](https://www.reddit.com/r/rust/comments/3hb0wm/underhanded_rust_contest/cu5yuhr)."
    },
    {
      "id": "clippy::while_let_loop",
      "name": "WHILE_LET_LOOP",
      "snake_name": "while_let_loop",
      "category": "complexity",
      "weight": 1.0,
      "brief": "`loop { if let { ... } else break }`, which can be written as a `while let` loop",
      "what_it_does": "Detects `loop + match` combinations that are easier\nwritten as a `while let` loop.",
      "why_bad": "The `while let` loop is usually shorter and more\nreadable.",
      "example": "```rust,no_run\nlet y = Some(1);\nloop {\nlet x = match y {\nSome(x) => x,\nNone => break,\n};\n// ..\n}\n```\nUse instead:\n```rust,no_run\nlet y = Some(1);\nwhile let Some(x) = y {\n// ..\n};\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "`loop { if let { ... } else break }`, which can be written as a `while let` loop\n\nDetects `loop + match` combinations that are easier\nwritten as a `while let` loop.\n\nThe `while let` loop is usually shorter and more\nreadable."
    },
    {
      "id": "clippy::explicit_counter_loop",
      "name": "EXPLICIT_COUNTER_LOOP",
      "snake_name": "explicit_counter_loop",
      "category": "complexity",
      "weight": 1.0,
      "brief": "for-looping with an explicit counter when `_.enumerate()` would do",
      "what_it_does": "Checks `for` loops over slices with an explicit counter\nand suggests the use of `.enumerate()`.",
      "why_bad": "Using `.enumerate()` makes the intent more clear,\ndeclutters the code and may be faster in some instances.",
      "example": "```no_run\n# let v = vec![1];\n# fn bar(bar: usize, baz: usize) {}\nlet mut i = 0;\nfor item in &v {\nbar(i, *item);\ni += 1;\n}\n```\n\nUse instead:\n```no_run\n# let v = vec![1];\n# fn bar(bar: usize, baz: usize) {}\nfor (i, item) in v.iter().enumerate() { bar(i, *item); }\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "for-looping with an explicit counter when `_.enumerate()` would do\n\nChecks `for` loops over slices with an explicit counter\nand suggests the use of `.enumerate()`.\n\nUsing `.enumerate()` makes the intent more clear,\ndeclutters the code and may be faster in some instances."
    },
    {
      "id": "clippy::empty_loop",
      "name": "EMPTY_LOOP",
      "snake_name": "empty_loop",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "empty `loop {}`, which should block or sleep",
      "what_it_does": "Checks for empty `loop` expressions.",
      "why_bad": "These busy loops burn CPU cycles without doing\nanything. It is _almost always_ a better idea to `panic!` than to have\na busy loop.\n\nIf panicking isn't possible, think of the environment and either:\n- block on something\n- sleep the thread for some microseconds\n- yield or pause the thread\n\nFor `std` targets, this can be done with\n[`std::thread::sleep`](https://doc.rust-lang.org/std/thread/fn.sleep.html)\nor [`std::thread::yield_now`](https://doc.rust-lang.org/std/thread/fn.yield_now.html).\n\nFor `no_std` targets, doing this is more complicated, especially because\n`#[panic_handler]`s can't panic. To stop/pause the thread, you will\nprobably need to invoke some target-specific intrinsic. Examples include:\n- [`x86_64::instructions::hlt`](https://docs.rs/x86_64/0.12.2/x86_64/instructions/fn.hlt.html)\n- [`cortex_m::asm::wfi`](https://docs.rs/cortex-m/0.6.3/cortex_m/asm/fn.wfi.html)",
      "example": "```no_run\nloop {}\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "empty `loop {}`, which should block or sleep\n\nChecks for empty `loop` expressions.\n\nThese busy loops burn CPU cycles without doing\nanything. It is _almost always_ a better idea to `panic!` than to have\na busy loop.\n\nIf panicking isn't possible, think of the environment and either:\n- block on something\n- sleep the thread for some microseconds\n- yield or pause the thread\n\nFor `std` targets, this can be done with\n[`std::thread::sleep`](https://doc.rust-lang.org/std/thread/fn.sleep.html)\nor [`std::thread::yield_now`](https://doc.rust-lang.org/std/thread/fn.yield_now.html).\n\nFor `no_std` targets, doing this is more complicated, especially because\n`#[panic_handler]`s can't panic. To stop/pause the thread, you will\nprobably need to invoke some target-specific intrinsic. Examples include:\n- [`x86_64::instructions::hlt`](https://docs.rs/x86_64/0.12.2/x86_64/instructions/fn.hlt.html)\n- [`cortex_m::asm::wfi`](https://docs.rs/cortex-m/0.6.3/cortex_m/asm/fn.wfi.html)"
    },
    {
      "id": "clippy::while_let_on_iterator",
      "name": "WHILE_LET_ON_ITERATOR",
      "snake_name": "while_let_on_iterator",
      "category": "style",
      "weight": 0.95,
      "brief": "using a `while let` loop instead of a for loop on an iterator",
      "what_it_does": "Checks for `while let` expressions on iterators.",
      "why_bad": "Readability. A simple `for` loop is shorter and conveys\nthe intent better.",
      "example": "```ignore\nwhile let Some(val) = iter.next() {\n..\n}\n```\n\nUse instead:\n```ignore\nfor val in &mut iter {\n..\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "using a `while let` loop instead of a for loop on an iterator\n\nChecks for `while let` expressions on iterators.\n\nReadability. A simple `for` loop is shorter and conveys\nthe intent better."
    },
    {
      "id": "clippy::for_kv_map",
      "name": "FOR_KV_MAP",
      "snake_name": "for_kv_map",
      "category": "style",
      "weight": 0.95,
      "brief": "looping on a map using `iter` when `keys` or `values` would do",
      "what_it_does": "Checks for iterating a map (`HashMap` or `BTreeMap`) and\nignoring either the keys or values.",
      "why_bad": "Readability. There are `keys` and `values` methods that\ncan be used to express that don't need the values or keys.",
      "example": "```ignore\nfor (k, _) in &map {\n..\n}\n```\n\ncould be replaced by\n\n```ignore\nfor k in map.keys() {\n..\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "looping on a map using `iter` when `keys` or `values` would do\n\nChecks for iterating a map (`HashMap` or `BTreeMap`) and\nignoring either the keys or values.\n\nReadability. There are `keys` and `values` methods that\ncan be used to express that don't need the values or keys."
    },
    {
      "id": "clippy::never_loop",
      "name": "NEVER_LOOP",
      "snake_name": "never_loop",
      "category": "correctness",
      "weight": 1.2,
      "brief": "any loop that will always `break` or `return`",
      "what_it_does": "Checks for loops that will always `break`, `return` or\n`continue` an outer loop.",
      "why_bad": "This loop never loops, all it does is obfuscating the\ncode.",
      "example": "```no_run\nloop {\n..;\nbreak;\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "any loop that will always `break` or `return`\n\nChecks for loops that will always `break`, `return` or\n`continue` an outer loop.\n\nThis loop never loops, all it does is obfuscating the\ncode."
    },
    {
      "id": "clippy::mut_range_bound",
      "name": "MUT_RANGE_BOUND",
      "snake_name": "mut_range_bound",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "for loop over a range where one of the bounds is a mutable variable",
      "what_it_does": "Checks for loops with a range bound that is a mutable variable.",
      "why_bad": "One might think that modifying the mutable variable changes the loop bounds. It doesn't.",
      "example": "```no_run\nlet mut foo = 42;\nfor i in 0..foo {\nfoo -= 1;\nprintln!(\"{i}\"); // prints numbers from 0 to 41, not 0 to 21\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "for loop over a range where one of the bounds is a mutable variable\n\nChecks for loops with a range bound that is a mutable variable.\n\nOne might think that modifying the mutable variable changes the loop bounds. It doesn't."
    },
    {
      "id": "clippy::while_immutable_condition",
      "name": "WHILE_IMMUTABLE_CONDITION",
      "snake_name": "while_immutable_condition",
      "category": "correctness",
      "weight": 1.2,
      "brief": "variables used within while expression are not mutated in the body",
      "what_it_does": "Checks whether variables used within while loop condition\ncan be (and are) mutated in the body.",
      "why_bad": "If the condition is unchanged, entering the body of the loop\nwill lead to an infinite loop.",
      "example": "```no_run\nlet i = 0;\nwhile i > 10 {\nprintln!(\"let me loop forever!\");\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "variables used within while expression are not mutated in the body\n\nChecks whether variables used within while loop condition\ncan be (and are) mutated in the body.\n\nIf the condition is unchanged, entering the body of the loop\nwill lead to an infinite loop."
    },
    {
      "id": "clippy::while_float",
      "name": "WHILE_FLOAT",
      "snake_name": "while_float",
      "category": "nursery",
      "weight": 0.9,
      "brief": "while loops comparing floating point values",
      "what_it_does": "Checks for while loops comparing floating point values.",
      "why_bad": "If you increment floating point values, errors can compound,\nso, use integers instead if possible.",
      "example": "```no_run\nlet mut x = 0.0;\nwhile x < 42.0 {\nx += 1.0;\n}\n```\n\nUse instead:\n```no_run\nlet mut x = 0;\nwhile x < 42 {\nx += 1;\n}\n```",
      "version": "1.80.0",
      "source_file": "mod.rs",
      "embedding_text": "while loops comparing floating point values\n\nChecks for while loops comparing floating point values.\n\nIf you increment floating point values, errors can compound,\nso, use integers instead if possible."
    },
    {
      "id": "clippy::same_item_push",
      "name": "SAME_ITEM_PUSH",
      "snake_name": "same_item_push",
      "category": "style",
      "weight": 0.95,
      "brief": "the same item is pushed inside of a for loop",
      "what_it_does": "Checks whether a for loop is being used to push a constant\nvalue into a Vec.",
      "why_bad": "This kind of operation can be expressed more succinctly with\n`vec![item; SIZE]` or `vec.resize(NEW_SIZE, item)` and using these alternatives may also\nhave better performance.",
      "example": "```no_run\nlet item1 = 2;\nlet item2 = 3;\nlet mut vec: Vec<u8> = Vec::new();\nfor _ in 0..20 {\nvec.push(item1);\n}\nfor _ in 0..30 {\nvec.push(item2);\n}\n```\n\nUse instead:\n```no_run\nlet item1 = 2;\nlet item2 = 3;\nlet mut vec: Vec<u8> = vec![item1; 20];\nvec.resize(20 + 30, item2);\n```",
      "version": "1.47.0",
      "source_file": "mod.rs",
      "embedding_text": "the same item is pushed inside of a for loop\n\nChecks whether a for loop is being used to push a constant\nvalue into a Vec.\n\nThis kind of operation can be expressed more succinctly with\n`vec![item; SIZE]` or `vec.resize(NEW_SIZE, item)` and using these alternatives may also\nhave better performance."
    },
    {
      "id": "clippy::single_element_loop",
      "name": "SINGLE_ELEMENT_LOOP",
      "snake_name": "single_element_loop",
      "category": "complexity",
      "weight": 1.0,
      "brief": "there is no reason to have a single element loop",
      "what_it_does": "Checks whether a for loop has a single element.",
      "why_bad": "There is no reason to have a loop of a\nsingle element.",
      "example": "```no_run\nlet item1 = 2;\nfor item in &[item1] {\nprintln!(\"{}\", item);\n}\n```\n\nUse instead:\n```no_run\nlet item1 = 2;\nlet item = &item1;\nprintln!(\"{}\", item);\n```",
      "version": "1.49.0",
      "source_file": "mod.rs",
      "embedding_text": "there is no reason to have a single element loop\n\nChecks whether a for loop has a single element.\n\nThere is no reason to have a loop of a\nsingle element."
    },
    {
      "id": "clippy::manual_flatten",
      "name": "MANUAL_FLATTEN",
      "snake_name": "manual_flatten",
      "category": "complexity",
      "weight": 1.0,
      "brief": "for loops over `Option`s or `Result`s with a single expression can be simplified",
      "what_it_does": "Checks for unnecessary `if let` usage in a for loop\nwhere only the `Some` or `Ok` variant of the iterator element is used.",
      "why_bad": "It is verbose and can be simplified\nby first calling the `flatten` method on the `Iterator`.",
      "example": "```no_run\nlet x = vec![Some(1), Some(2), Some(3)];\nfor n in x {\nif let Some(n) = n {\nprintln!(\"{}\", n);\n}\n}\n```\nUse instead:\n```no_run\nlet x = vec![Some(1), Some(2), Some(3)];\nfor n in x.into_iter().flatten() {\nprintln!(\"{}\", n);\n}\n```",
      "version": "1.52.0",
      "source_file": "mod.rs",
      "embedding_text": "for loops over `Option`s or `Result`s with a single expression can be simplified\n\nChecks for unnecessary `if let` usage in a for loop\nwhere only the `Some` or `Ok` variant of the iterator element is used.\n\nIt is verbose and can be simplified\nby first calling the `flatten` method on the `Iterator`."
    },
    {
      "id": "clippy::missing_spin_loop",
      "name": "MISSING_SPIN_LOOP",
      "snake_name": "missing_spin_loop",
      "category": "perf",
      "weight": 1.0,
      "brief": "An empty busy waiting loop",
      "what_it_does": "Checks for empty spin loops",
      "why_bad": "The loop body should have something like `thread::park()` or at least\n`std::hint::spin_loop()` to avoid needlessly burning cycles and conserve\nenergy. Perhaps even better use an actual lock, if possible.",
      "example": "```ignore\nuse core::sync::atomic::{AtomicBool, Ordering};\nlet b = AtomicBool::new(true);\n// give a ref to `b` to another thread,wait for it to become false\nwhile b.load(Ordering::Acquire) {};\n```\nUse instead:\n```rust,no_run\n# use core::sync::atomic::{AtomicBool, Ordering};\n# let b = AtomicBool::new(true);\nwhile b.load(Ordering::Acquire) {\nstd::hint::spin_loop()\n}\n```",
      "version": "1.61.0",
      "source_file": "mod.rs",
      "embedding_text": "An empty busy waiting loop\n\nChecks for empty spin loops\n\nThe loop body should have something like `thread::park()` or at least\n`std::hint::spin_loop()` to avoid needlessly burning cycles and conserve\nenergy. Perhaps even better use an actual lock, if possible."
    },
    {
      "id": "clippy::manual_find",
      "name": "MANUAL_FIND",
      "snake_name": "manual_find",
      "category": "complexity",
      "weight": 1.0,
      "brief": "manual implementation of `Iterator::find`",
      "what_it_does": "Checks for manual implementations of Iterator::find",
      "why_bad": "It doesn't affect performance, but using `find` is shorter and easier to read.",
      "example": "```no_run\nfn example(arr: Vec<i32>) -> Option<i32> {\nfor el in arr {\nif el == 1 {\nreturn Some(el);\n}\n}\nNone\n}\n```\nUse instead:\n```no_run\nfn example(arr: Vec<i32>) -> Option<i32> {\narr.into_iter().find(|&el| el == 1)\n}\n```",
      "version": "1.64.0",
      "source_file": "mod.rs",
      "embedding_text": "manual implementation of `Iterator::find`\n\nChecks for manual implementations of Iterator::find\n\nIt doesn't affect performance, but using `find` is shorter and easier to read."
    },
    {
      "id": "clippy::unused_enumerate_index",
      "name": "UNUSED_ENUMERATE_INDEX",
      "snake_name": "unused_enumerate_index",
      "category": "style",
      "weight": 0.95,
      "brief": "using `.enumerate()` and immediately dropping the index",
      "what_it_does": "Checks for uses of the `enumerate` method where the index is unused (`_`)",
      "why_bad": "The index from `.enumerate()` is immediately dropped.",
      "example": "```rust\nlet v = vec![1, 2, 3, 4];\nfor (_, x) in v.iter().enumerate() {\nprintln!(\"{x}\");\n}\n```\nUse instead:\n```rust\nlet v = vec![1, 2, 3, 4];\nfor x in v.iter() {\nprintln!(\"{x}\");\n}\n```",
      "version": "1.75.0",
      "source_file": "mod.rs",
      "embedding_text": "using `.enumerate()` and immediately dropping the index\n\nChecks for uses of the `enumerate` method where the index is unused (`_`)\n\nThe index from `.enumerate()` is immediately dropped."
    },
    {
      "id": "clippy::manual_while_let_some",
      "name": "MANUAL_WHILE_LET_SOME",
      "snake_name": "manual_while_let_some",
      "category": "style",
      "weight": 0.95,
      "brief": "checking for emptiness of a `Vec` in the loop condition and popping an element in the body",
      "what_it_does": "Looks for loops that check for emptiness of a `Vec` in the condition and pop an element\nin the body as a separate operation.",
      "why_bad": "Such loops can be written in a more idiomatic way by using a while-let loop and directly\npattern matching on the return value of `Vec::pop()`.",
      "example": "```no_run\nlet mut numbers = vec![1, 2, 3, 4, 5];\nwhile !numbers.is_empty() {\nlet number = numbers.pop().unwrap();\n// use `number`\n}\n```\nUse instead:\n```no_run\nlet mut numbers = vec![1, 2, 3, 4, 5];\nwhile let Some(number) = numbers.pop() {\n// use `number`\n}\n```",
      "version": "1.71.0",
      "source_file": "mod.rs",
      "embedding_text": "checking for emptiness of a `Vec` in the loop condition and popping an element in the body\n\nLooks for loops that check for emptiness of a `Vec` in the condition and pop an element\nin the body as a separate operation.\n\nSuch loops can be written in a more idiomatic way by using a while-let loop and directly\npattern matching on the return value of `Vec::pop()`."
    },
    {
      "id": "clippy::infinite_loop",
      "name": "INFINITE_LOOP",
      "snake_name": "infinite_loop",
      "category": "restriction",
      "weight": 1.0,
      "brief": "possibly unintended infinite loop",
      "what_it_does": "Checks for infinite loops in a function where the return type is not `!`\nand lint accordingly.",
      "why_bad": "Making the return type `!` serves as documentation that the function does not return.\nIf the function is not intended to loop infinitely, then this lint may detect a bug.",
      "example": "```no_run,ignore\nfn run_forever() {\nloop {\n// do something\n}\n}\n```\nIf infinite loops are as intended:\n```no_run,ignore\nfn run_forever() -> ! {\nloop {\n// do something\n}\n}\n```\nOtherwise add a `break` or `return` condition:\n```no_run,ignore\nfn run_forever() {\nloop {\n// do something\nif condition {\nbreak;\n}\n}\n}\n```",
      "version": "1.76.0",
      "source_file": "mod.rs",
      "embedding_text": "possibly unintended infinite loop\n\nChecks for infinite loops in a function where the return type is not `!`\nand lint accordingly.\n\nMaking the return type `!` serves as documentation that the function does not return.\nIf the function is not intended to loop infinitely, then this lint may detect a bug."
    },
    {
      "id": "clippy::manual_slice_fill",
      "name": "MANUAL_SLICE_FILL",
      "snake_name": "manual_slice_fill",
      "category": "style",
      "weight": 0.95,
      "brief": "manually filling a slice with a value",
      "what_it_does": "Checks for manually filling a slice with a value.",
      "why_bad": "Using the `fill` method is more idiomatic and concise.",
      "example": "```no_run\nlet mut some_slice = [1, 2, 3, 4, 5];\nfor i in 0..some_slice.len() {\nsome_slice[i] = 0;\n}\n```\nUse instead:\n```no_run\nlet mut some_slice = [1, 2, 3, 4, 5];\nsome_slice.fill(0);\n```",
      "version": "1.86.0",
      "source_file": "mod.rs",
      "embedding_text": "manually filling a slice with a value\n\nChecks for manually filling a slice with a value.\n\nUsing the `fill` method is more idiomatic and concise."
    },
    {
      "id": "clippy::char_indices_as_byte_indices",
      "name": "CHAR_INDICES_AS_BYTE_INDICES",
      "snake_name": "char_indices_as_byte_indices",
      "category": "correctness",
      "weight": 1.2,
      "brief": "using the character position yielded by `.chars().enumerate()` in a context where a byte index is expected",
      "what_it_does": "Checks for usage of a character position yielded by `.chars().enumerate()` in a context where a **byte index** is expected,\nsuch as an argument to a specific `str` method or indexing into a `str` or `String`.",
      "why_bad": "A character (more specifically, a Unicode scalar value) that is yielded by `str::chars` can take up multiple bytes,\nso a character position does not necessarily have the same byte index at which the character is stored.\nThus, using the character position where a byte index is expected can unexpectedly return wrong values\nor panic when the string consists of multibyte characters.\n\nFor example, the character `a` in `\u00e4a` is stored at byte index 2 but has the character position 1.\nUsing the character position 1 to index into the string will lead to a panic as it is in the middle of the first character.\n\nInstead of `.chars().enumerate()`, the correct iterator to use is `.char_indices()`, which yields byte indices.\n\nThis pattern is technically fine if the strings are known to only use the ASCII subset,\nthough in those cases it would be better to use `bytes()` directly to make the intent clearer,\nbut there is also no downside to just using `.char_indices()` directly and supporting non-ASCII strings.\n\nYou may also want to read the [chapter on strings in the Rust Book](https://doc.rust-lang.org/book/ch08-02-strings.html)\nwhich goes into this in more detail.",
      "example": "```no_run\n# let s = \"...\";\nfor (idx, c) in s.chars().enumerate() {\nlet _ = s[idx..]; // \u26a0\ufe0f Panics for strings consisting of multibyte characters\n}\n```\nUse instead:\n```no_run\n# let s = \"...\";\nfor (idx, c) in s.char_indices() {\nlet _ = s[idx..];\n}\n```",
      "version": "1.88.0",
      "source_file": "mod.rs",
      "embedding_text": "using the character position yielded by `.chars().enumerate()` in a context where a byte index is expected\n\nChecks for usage of a character position yielded by `.chars().enumerate()` in a context where a **byte index** is expected,\nsuch as an argument to a specific `str` method or indexing into a `str` or `String`.\n\nA character (more specifically, a Unicode scalar value) that is yielded by `str::chars` can take up multiple bytes,\nso a character position does not necessarily have the same byte index at which the character is stored.\nThus, using the character position where a byte index is expected can unexpectedly return wrong values\nor panic when the string consists of multibyte characters.\n\nFor example, the character `a` in `\u00e4a` is stored at byte index 2 but has the character position 1.\nUsing the character position 1 to index into the string will lead to a panic as it is in the middle of the first character.\n\nInstead of `.chars().enumerate()`, the correct iterator to use is `.char_indices()`, which yields byte indices.\n\nThis pattern is technically fine if the strings are known to only use the ASCII subset,\nthough in those cases it would be better to use `bytes()` directly to make the intent clearer,\nbut there is also no downside to just using `.char_indices()` directly and supporting non-ASCII strings.\n\nYou may also want to read the [chapter on strings in the Rust Book](https://doc.rust-lang.org/book/ch08-02-strings.html)\nwhich goes into this in more detail."
    },
    {
      "id": "clippy::macro_metavars_in_unsafe",
      "name": "MACRO_METAVARS_IN_UNSAFE",
      "snake_name": "macro_metavars_in_unsafe",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "expanding macro metavariables in an unsafe block",
      "what_it_does": "Looks for macros that expand metavariables in an unsafe block.",
      "why_bad": "This hides an unsafe block and allows the user of the macro to write unsafe code without an explicit\nunsafe block at callsite, making it possible to perform unsafe operations in seemingly safe code.\n\nThe macro should be restructured so that these metavariables are referenced outside of unsafe blocks\nand that the usual unsafety checks apply to the macro argument.\n\nThis is usually done by binding it to a variable outside of the unsafe block\nand then using that variable inside of the block as shown in the example, or by referencing it a second time\nin a safe context, e.g. `if false { $expr }`.",
      "example": "```no_run\n/// Gets the first element of a slice\nmacro_rules! first {\n($slice:expr) => {\nunsafe {\nlet slice = $slice; // \u26a0\ufe0f expansion inside of `unsafe {}`\n\nassert!(!slice.is_empty());\n// SAFETY: slice is checked to have at least one element\nslice.first().unwrap_unchecked()\n}\n}\n}\n\nassert_eq!(*first!(&[1i32]), 1);\n\n// This will compile as a consequence (note the lack of `unsafe {}`)\nassert_eq!(*first!(std::hint::unreachable_unchecked() as &[i32]), 1);\n```\nUse instead:\n```compile_fail\nmacro_rules! first {\n($slice:expr) => {{\nlet slice = $slice; // \u2705 outside of `unsafe {}`\nunsafe {\nassert!(!slice.is_empty());\n// SAFETY: slice is checked to have at least one element\nslice.first().unwrap_unchecked()\n}\n}}\n}\n\nassert_eq!(*first!(&[1]), 1);\n\n// This won't compile:\nassert_eq!(*first!(std::hint::unreachable_unchecked() as &[i32]), 1);\n```",
      "version": "1.80.0",
      "source_file": "macro_metavars_in_unsafe.rs",
      "embedding_text": "expanding macro metavariables in an unsafe block\n\nLooks for macros that expand metavariables in an unsafe block.\n\nThis hides an unsafe block and allows the user of the macro to write unsafe code without an explicit\nunsafe block at callsite, making it possible to perform unsafe operations in seemingly safe code.\n\nThe macro should be restructured so that these metavariables are referenced outside of unsafe blocks\nand that the usual unsafety checks apply to the macro argument.\n\nThis is usually done by binding it to a variable outside of the unsafe block\nand then using that variable inside of the block as shown in the example, or by referencing it a second time\nin a safe context, e.g. `if false { $expr }`."
    },
    {
      "id": "clippy::macro_use_imports",
      "name": "MACRO_USE_IMPORTS",
      "snake_name": "macro_use_imports",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "#[macro_use] is no longer needed",
      "what_it_does": "Checks for `#[macro_use] use...`.",
      "why_bad": "Since the Rust 2018 edition you can import\nmacro's directly, this is considered idiomatic.",
      "example": "```rust,ignore\n#[macro_use]\nextern crate some_crate;\n\nfn main() {\nsome_macro!();\n}\n```\n\nUse instead:\n\n```rust,ignore\nuse some_crate::some_macro;\n\nfn main() {\nsome_macro!();\n}\n```",
      "version": "1.44.0",
      "source_file": "macro_use.rs",
      "embedding_text": "#[macro_use] is no longer needed\n\nChecks for `#[macro_use] use...`.\n\nSince the Rust 2018 edition you can import\nmacro's directly, this is considered idiomatic."
    },
    {
      "id": "clippy::main_recursion",
      "name": "MAIN_RECURSION",
      "snake_name": "main_recursion",
      "category": "style",
      "weight": 0.95,
      "brief": "recursion using the entrypoint",
      "what_it_does": "Checks for recursion using the entrypoint.",
      "why_bad": "Apart from special setups (which we could detect following attributes like #![no_std]),\nrecursing into main() seems like an unintuitive anti-pattern we should be able to detect.",
      "example": "```no_run\nfn main() {\nmain();\n}\n```",
      "version": "1.38.0",
      "source_file": "main_recursion.rs",
      "embedding_text": "recursion using the entrypoint\n\nChecks for recursion using the entrypoint.\n\nApart from special setups (which we could detect following attributes like #![no_std]),\nrecursing into main() seems like an unintuitive anti-pattern we should be able to detect."
    },
    {
      "id": "clippy::manual_abs_diff",
      "name": "MANUAL_ABS_DIFF",
      "snake_name": "manual_abs_diff",
      "category": "complexity",
      "weight": 1.0,
      "brief": "using an if-else pattern instead of `abs_diff`",
      "what_it_does": "Detects patterns like `if a > b { a - b } else { b - a }` and suggests using `a.abs_diff(b)`.",
      "why_bad": "Using `abs_diff` is shorter, more readable, and avoids control flow.",
      "example": "```no_run\n# let (a, b) = (5_usize, 3_usize);\nif a > b {\na - b\n} else {\nb - a\n}\n# ;\n```\nUse instead:\n```no_run\n# let (a, b) = (5_usize, 3_usize);\na.abs_diff(b)\n# ;\n```",
      "version": "1.88.0",
      "source_file": "manual_abs_diff.rs",
      "embedding_text": "using an if-else pattern instead of `abs_diff`\n\nDetects patterns like `if a > b { a - b } else { b - a }` and suggests using `a.abs_diff(b)`.\n\nUsing `abs_diff` is shorter, more readable, and avoids control flow."
    },
    {
      "id": "clippy::manual_assert",
      "name": "MANUAL_ASSERT",
      "snake_name": "manual_assert",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "`panic!` and only a `panic!` in `if`-then statement",
      "what_it_does": "Detects `if`-then-`panic!` that can be replaced with `assert!`.",
      "why_bad": "`assert!` is simpler than `if`-then-`panic!`.",
      "example": "```no_run\nlet sad_people: Vec<&str> = vec![];\nif !sad_people.is_empty() {\npanic!(\"there are sad people: {:?}\", sad_people);\n}\n```\nUse instead:\n```no_run\nlet sad_people: Vec<&str> = vec![];\nassert!(sad_people.is_empty(), \"there are sad people: {:?}\", sad_people);\n```",
      "version": "1.57.0",
      "source_file": "manual_assert.rs",
      "embedding_text": "`panic!` and only a `panic!` in `if`-then statement\n\nDetects `if`-then-`panic!` that can be replaced with `assert!`.\n\n`assert!` is simpler than `if`-then-`panic!`."
    },
    {
      "id": "clippy::manual_async_fn",
      "name": "MANUAL_ASYNC_FN",
      "snake_name": "manual_async_fn",
      "category": "style",
      "weight": 0.95,
      "brief": "manual implementations of `async` functions can be simplified using the dedicated syntax",
      "what_it_does": "It checks for manual implementations of `async` functions.",
      "why_bad": "It's more idiomatic to use the dedicated syntax.",
      "example": "```no_run\nuse std::future::Future;\n\nfn foo() -> impl Future<Output = i32> { async { 42 } }\n```\nUse instead:\n```no_run\nasync fn foo() -> i32 { 42 }\n```",
      "version": "1.45.0",
      "source_file": "manual_async_fn.rs",
      "embedding_text": "manual implementations of `async` functions can be simplified using the dedicated syntax\n\nIt checks for manual implementations of `async` functions.\n\nIt's more idiomatic to use the dedicated syntax."
    },
    {
      "id": "clippy::manual_bits",
      "name": "MANUAL_BITS",
      "snake_name": "manual_bits",
      "category": "style",
      "weight": 0.95,
      "brief": "manual implementation of `size_of::<T>() * 8` can be simplified with `T::BITS`",
      "what_it_does": "Checks for usage of `size_of::<T>() * 8` when\n`T::BITS` is available.",
      "why_bad": "Can be written as the shorter `T::BITS`.",
      "example": "```no_run\nsize_of::<usize>() * 8;\n```\nUse instead:\n```no_run\nusize::BITS as usize;\n```",
      "version": "1.60.0",
      "source_file": "manual_bits.rs",
      "embedding_text": "manual implementation of `size_of::<T>() * 8` can be simplified with `T::BITS`\n\nChecks for usage of `size_of::<T>() * 8` when\n`T::BITS` is available.\n\nCan be written as the shorter `T::BITS`."
    },
    {
      "id": "clippy::manual_clamp",
      "name": "MANUAL_CLAMP",
      "snake_name": "manual_clamp",
      "category": "complexity",
      "weight": 1.0,
      "brief": "using a clamp pattern instead of the clamp function",
      "what_it_does": "Identifies good opportunities for a clamp function from std or core, and suggests using it.",
      "why_bad": "clamp is much shorter, easier to read, and doesn't use any control flow.",
      "example": "```no_run\n# let (input, min, max) = (0, -2, 1);\nif input > max {\nmax\n} else if input < min {\nmin\n} else {\ninput\n}\n# ;\n```\n\n```no_run\n# let (input, min, max) = (0, -2, 1);\ninput.max(min).min(max)\n# ;\n```\n\n```no_run\n# let (input, min, max) = (0, -2, 1);\nmatch input {\nx if x > max => max,\nx if x < min => min,\nx => x,\n}\n# ;\n```\n\n```no_run\n# let (input, min, max) = (0, -2, 1);\nlet mut x = input;\nif x < min { x = min; }\nif x > max { x = max; }\n```\nUse instead:\n```no_run\n# let (input, min, max) = (0, -2, 1);\ninput.clamp(min, max)\n# ;\n```",
      "version": "1.66.0",
      "source_file": "manual_clamp.rs",
      "embedding_text": "using a clamp pattern instead of the clamp function\n\nIdentifies good opportunities for a clamp function from std or core, and suggests using it.\n\nclamp is much shorter, easier to read, and doesn't use any control flow."
    },
    {
      "id": "clippy::manual_is_infinite",
      "name": "MANUAL_IS_INFINITE",
      "snake_name": "manual_is_infinite",
      "category": "style",
      "weight": 0.95,
      "brief": "use dedicated method to check if a float is infinite",
      "what_it_does": "Checks for manual `is_infinite` reimplementations\n(i.e., `x == <float>::INFINITY || x == <float>::NEG_INFINITY`).",
      "why_bad": "The method `is_infinite` is shorter and more readable.",
      "example": "```no_run\n# let x = 1.0f32;\nif x == f32::INFINITY || x == f32::NEG_INFINITY {}\n```\nUse instead:\n```no_run\n# let x = 1.0f32;\nif x.is_infinite() {}\n```",
      "version": "1.73.0",
      "source_file": "manual_float_methods.rs",
      "embedding_text": "use dedicated method to check if a float is infinite\n\nChecks for manual `is_infinite` reimplementations\n(i.e., `x == <float>::INFINITY || x == <float>::NEG_INFINITY`).\n\nThe method `is_infinite` is shorter and more readable."
    },
    {
      "id": "clippy::manual_is_finite",
      "name": "MANUAL_IS_FINITE",
      "snake_name": "manual_is_finite",
      "category": "style",
      "weight": 0.95,
      "brief": "use dedicated method to check if a float is finite",
      "what_it_does": "Checks for manual `is_finite` reimplementations\n(i.e., `x != <float>::INFINITY && x != <float>::NEG_INFINITY`).",
      "why_bad": "The method `is_finite` is shorter and more readable.",
      "example": "```no_run\n# let x = 1.0f32;\nif x != f32::INFINITY && x != f32::NEG_INFINITY {}\nif x.abs() < f32::INFINITY {}\n```\nUse instead:\n```no_run\n# let x = 1.0f32;\nif x.is_finite() {}\nif x.is_finite() {}\n```",
      "version": "1.73.0",
      "source_file": "manual_float_methods.rs",
      "embedding_text": "use dedicated method to check if a float is finite\n\nChecks for manual `is_finite` reimplementations\n(i.e., `x != <float>::INFINITY && x != <float>::NEG_INFINITY`).\n\nThe method `is_finite` is shorter and more readable."
    },
    {
      "id": "clippy::manual_hash_one",
      "name": "MANUAL_HASH_ONE",
      "snake_name": "manual_hash_one",
      "category": "complexity",
      "weight": 1.0,
      "brief": "manual implementations of `BuildHasher::hash_one`",
      "what_it_does": "Checks for cases where [`BuildHasher::hash_one`] can be used.\n\n[`BuildHasher::hash_one`]: https://doc.rust-lang.org/std/hash/trait.BuildHasher.html#method.hash_one",
      "why_bad": "It is more concise to use the `hash_one` method.",
      "example": "```no_run\nuse std::hash::{BuildHasher, Hash, Hasher};\nuse std::collections::hash_map::RandomState;\n\nlet s = RandomState::new();\nlet value = vec![1, 2, 3];\n\nlet mut hasher = s.build_hasher();\nvalue.hash(&mut hasher);\nlet hash = hasher.finish();\n```\nUse instead:\n```no_run\nuse std::hash::BuildHasher;\nuse std::collections::hash_map::RandomState;\n\nlet s = RandomState::new();\nlet value = vec![1, 2, 3];\n\nlet hash = s.hash_one(&value);\n```",
      "version": "1.75.0",
      "source_file": "manual_hash_one.rs",
      "embedding_text": "manual implementations of `BuildHasher::hash_one`\n\nChecks for cases where [`BuildHasher::hash_one`] can be used.\n\n[`BuildHasher::hash_one`]: https://doc.rust-lang.org/std/hash/trait.BuildHasher.html#method.hash_one\n\nIt is more concise to use the `hash_one` method."
    },
    {
      "id": "clippy::manual_ignore_case_cmp",
      "name": "MANUAL_IGNORE_CASE_CMP",
      "snake_name": "manual_ignore_case_cmp",
      "category": "perf",
      "weight": 1.0,
      "brief": "manual case-insensitive ASCII comparison",
      "what_it_does": "Checks for manual case-insensitive ASCII comparison.",
      "why_bad": "The `eq_ignore_ascii_case` method is faster because it does not allocate\nmemory for the new strings, and it is more readable.",
      "example": "```no_run\nfn compare(a: &str, b: &str) -> bool {\na.to_ascii_lowercase() == b.to_ascii_lowercase() || a.to_ascii_lowercase() == \"abc\"\n}\n```\nUse instead:\n```no_run\nfn compare(a: &str, b: &str) -> bool {\na.eq_ignore_ascii_case(b) || a.eq_ignore_ascii_case(\"abc\")\n}\n```",
      "version": "1.84.0",
      "source_file": "manual_ignore_case_cmp.rs",
      "embedding_text": "manual case-insensitive ASCII comparison\n\nChecks for manual case-insensitive ASCII comparison.\n\nThe `eq_ignore_ascii_case` method is faster because it does not allocate\nmemory for the new strings, and it is more readable."
    },
    {
      "id": "clippy::manual_ilog2",
      "name": "MANUAL_ILOG2",
      "snake_name": "manual_ilog2",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "manually reimplementing `ilog2`",
      "what_it_does": "Checks for expressions like `N - x.leading_zeros()` (where `N` is one less than bit width\nof `x`) or `x.ilog(2)`, which are manual reimplementations of `x.ilog2()`",
      "why_bad": "Manual reimplementations of `ilog2` increase code complexity for little benefit.",
      "example": "```no_run\nlet x: u32 = 5;\nlet log = 31 - x.leading_zeros();\nlet log = x.ilog(2);\n```\nUse instead:\n```no_run\nlet x: u32 = 5;\nlet log = x.ilog2();\nlet log = x.ilog2();\n```",
      "version": "1.93.0",
      "source_file": "manual_ilog2.rs",
      "embedding_text": "manually reimplementing `ilog2`\n\nChecks for expressions like `N - x.leading_zeros()` (where `N` is one less than bit width\nof `x`) or `x.ilog(2)`, which are manual reimplementations of `x.ilog2()`\n\nManual reimplementations of `ilog2` increase code complexity for little benefit."
    },
    {
      "id": "clippy::manual_is_ascii_check",
      "name": "MANUAL_IS_ASCII_CHECK",
      "snake_name": "manual_is_ascii_check",
      "category": "style",
      "weight": 0.95,
      "brief": "use dedicated method to check ascii range",
      "what_it_does": "Suggests to use dedicated built-in methods,\n`is_ascii_(lowercase|uppercase|digit|hexdigit)` for checking on corresponding\nascii range",
      "why_bad": "Using the built-in functions is more readable and makes it\nclear that it's not a specific subset of characters, but all\nASCII (lowercase|uppercase|digit|hexdigit) characters.",
      "example": "```no_run\nfn main() {\nassert!(matches!('x', 'a'..='z'));\nassert!(matches!(b'X', b'A'..=b'Z'));\nassert!(matches!('2', '0'..='9'));\nassert!(matches!('x', 'A'..='Z' | 'a'..='z'));\nassert!(matches!('C', '0'..='9' | 'a'..='f' | 'A'..='F'));\n\n('0'..='9').contains(&'0');\n('a'..='z').contains(&'a');\n('A'..='Z').contains(&'A');\n}\n```\nUse instead:\n```no_run\nfn main() {\nassert!('x'.is_ascii_lowercase());\nassert!(b'X'.is_ascii_uppercase());\nassert!('2'.is_ascii_digit());\nassert!('x'.is_ascii_alphabetic());\nassert!('C'.is_ascii_hexdigit());\n\n'0'.is_ascii_digit();\n'a'.is_ascii_lowercase();\n'A'.is_ascii_uppercase();\n}\n```",
      "version": "1.67.0",
      "source_file": "manual_is_ascii_check.rs",
      "embedding_text": "use dedicated method to check ascii range\n\nSuggests to use dedicated built-in methods,\n`is_ascii_(lowercase|uppercase|digit|hexdigit)` for checking on corresponding\nascii range\n\nUsing the built-in functions is more readable and makes it\nclear that it's not a specific subset of characters, but all\nASCII (lowercase|uppercase|digit|hexdigit) characters."
    },
    {
      "id": "clippy::manual_is_power_of_two",
      "name": "MANUAL_IS_POWER_OF_TWO",
      "snake_name": "manual_is_power_of_two",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "manually reimplementing `is_power_of_two`",
      "what_it_does": "Checks for expressions like `x.count_ones() == 1` or `x & (x - 1) == 0`, with x and unsigned integer, which may be manual\nreimplementations of `x.is_power_of_two()`.",
      "why_bad": "Manual reimplementations of `is_power_of_two` increase code complexity for little benefit.",
      "example": "```no_run\nlet a: u32 = 4;\nlet result = a.count_ones() == 1;\n```\nUse instead:\n```no_run\nlet a: u32 = 4;\nlet result = a.is_power_of_two();\n```",
      "version": "1.83.0",
      "source_file": "manual_is_power_of_two.rs",
      "embedding_text": "manually reimplementing `is_power_of_two`\n\nChecks for expressions like `x.count_ones() == 1` or `x & (x - 1) == 0`, with x and unsigned integer, which may be manual\nreimplementations of `x.is_power_of_two()`.\n\nManual reimplementations of `is_power_of_two` increase code complexity for little benefit."
    },
    {
      "id": "clippy::manual_let_else",
      "name": "MANUAL_LET_ELSE",
      "snake_name": "manual_let_else",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "manual implementation of a let...else statement",
      "what_it_does": "Warn of cases where `let...else` could be used",
      "why_bad": "`let...else` provides a standard construct for this pattern\nthat people can easily recognize. It's also more compact.",
      "example": "```no_run\n# let w = Some(0);\nlet v = if let Some(v) = w { v } else { return };\n```\n\nCould be written:\n\n```no_run\n# fn main () {\n# let w = Some(0);\nlet Some(v) = w else { return };\n# }\n```",
      "version": "1.67.0",
      "source_file": "manual_let_else.rs",
      "embedding_text": "manual implementation of a let...else statement\n\nWarn of cases where `let...else` could be used\n\n`let...else` provides a standard construct for this pattern\nthat people can easily recognize. It's also more compact."
    },
    {
      "id": "clippy::manual_main_separator_str",
      "name": "MANUAL_MAIN_SEPARATOR_STR",
      "snake_name": "manual_main_separator_str",
      "category": "complexity",
      "weight": 1.0,
      "brief": "`&std::path::MAIN_SEPARATOR.to_string()` can be replaced by `std::path::MAIN_SEPARATOR_STR`",
      "what_it_does": "Checks for references on `std::path::MAIN_SEPARATOR.to_string()` used\nto build a `&str`.",
      "why_bad": "There exists a `std::path::MAIN_SEPARATOR_STR` which does not require\nan extra memory allocation.",
      "example": "```no_run\nlet s: &str = &std::path::MAIN_SEPARATOR.to_string();\n```\nUse instead:\n```no_run\nlet s: &str = std::path::MAIN_SEPARATOR_STR;\n```",
      "version": "1.70.0",
      "source_file": "manual_main_separator_str.rs",
      "embedding_text": "`&std::path::MAIN_SEPARATOR.to_string()` can be replaced by `std::path::MAIN_SEPARATOR_STR`\n\nChecks for references on `std::path::MAIN_SEPARATOR.to_string()` used\nto build a `&str`.\n\nThere exists a `std::path::MAIN_SEPARATOR_STR` which does not require\nan extra memory allocation."
    },
    {
      "id": "clippy::manual_non_exhaustive",
      "name": "MANUAL_NON_EXHAUSTIVE",
      "snake_name": "manual_non_exhaustive",
      "category": "style",
      "weight": 0.95,
      "brief": "manual implementations of the non-exhaustive pattern can be simplified using #[non_exhaustive]",
      "what_it_does": "Checks for manual implementations of the non-exhaustive pattern.",
      "why_bad": "Using the #[non_exhaustive] attribute expresses better the intent\nand allows possible optimizations when applied to enums.",
      "example": "```no_run\nstruct S {\npub a: i32,\npub b: i32,\n_c: (),\n}\n\nenum E {\nA,\nB,\n#[doc(hidden)]\n_C,\n}\n\nstruct T(pub i32, pub i32, ());\n```\nUse instead:\n```no_run\n#[non_exhaustive]\nstruct S {\npub a: i32,\npub b: i32,\n}\n\n#[non_exhaustive]\nenum E {\nA,\nB,\n}\n\n#[non_exhaustive]\nstruct T(pub i32, pub i32);\n```",
      "version": "1.45.0",
      "source_file": "manual_non_exhaustive.rs",
      "embedding_text": "manual implementations of the non-exhaustive pattern can be simplified using #[non_exhaustive]\n\nChecks for manual implementations of the non-exhaustive pattern.\n\nUsing the #[non_exhaustive] attribute expresses better the intent\nand allows possible optimizations when applied to enums."
    },
    {
      "id": "clippy::manual_option_as_slice",
      "name": "MANUAL_OPTION_AS_SLICE",
      "snake_name": "manual_option_as_slice",
      "category": "complexity",
      "weight": 1.0,
      "brief": "manual `Option::as_slice`",
      "what_it_does": "This detects various manual reimplementations of `Option::as_slice`.",
      "why_bad": "Those implementations are both more complex than calling `as_slice`\nand unlike that incur a branch, pessimizing performance and leading\nto more generated code.",
      "example": "```no_run\n# let opt = Some(1);\n_ = opt.as_ref().map_or(&[][..], std::slice::from_ref);\n_ = match opt.as_ref() {\nSome(f) => std::slice::from_ref(f),\nNone => &[],\n};\n```\nUse instead:\n```no_run\n# let opt = Some(1);\n_ = opt.as_slice();\n_ = opt.as_slice();\n```",
      "version": "1.86.0",
      "source_file": "manual_option_as_slice.rs",
      "embedding_text": "manual `Option::as_slice`\n\nThis detects various manual reimplementations of `Option::as_slice`.\n\nThose implementations are both more complex than calling `as_slice`\nand unlike that incur a branch, pessimizing performance and leading\nto more generated code."
    },
    {
      "id": "clippy::manual_range_patterns",
      "name": "MANUAL_RANGE_PATTERNS",
      "snake_name": "manual_range_patterns",
      "category": "complexity",
      "weight": 1.0,
      "brief": "manually writing range patterns using a combined OR pattern (`|`)",
      "what_it_does": "Looks for combined OR patterns that are all contained in a specific range,\ne.g. `6 | 4 | 5 | 9 | 7 | 8` can be rewritten as `4..=9`.",
      "why_bad": "Using an explicit range is more concise and easier to read.",
      "example": "```no_run\nlet x = 6;\nlet foo = matches!(x, 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10);\n```\nUse instead:\n```no_run\nlet x = 6;\nlet foo = matches!(x, 1..=10);\n```",
      "version": "1.72.0",
      "source_file": "manual_range_patterns.rs",
      "embedding_text": "manually writing range patterns using a combined OR pattern (`|`)\n\nLooks for combined OR patterns that are all contained in a specific range,\ne.g. `6 | 4 | 5 | 9 | 7 | 8` can be rewritten as `4..=9`.\n\nUsing an explicit range is more concise and easier to read."
    },
    {
      "id": "clippy::manual_rem_euclid",
      "name": "MANUAL_REM_EUCLID",
      "snake_name": "manual_rem_euclid",
      "category": "complexity",
      "weight": 1.0,
      "brief": "manually reimplementing `rem_euclid`",
      "what_it_does": "Checks for an expression like `((x % 4) + 4) % 4` which is a common manual reimplementation\nof `x.rem_euclid(4)`.",
      "why_bad": "It's simpler and more readable.",
      "example": "```no_run\nlet x: i32 = 24;\nlet rem = ((x % 4) + 4) % 4;\n```\nUse instead:\n```no_run\nlet x: i32 = 24;\nlet rem = x.rem_euclid(4);\n```",
      "version": "1.64.0",
      "source_file": "manual_rem_euclid.rs",
      "embedding_text": "manually reimplementing `rem_euclid`\n\nChecks for an expression like `((x % 4) + 4) % 4` which is a common manual reimplementation\nof `x.rem_euclid(4)`.\n\nIt's simpler and more readable."
    },
    {
      "id": "clippy::manual_retain",
      "name": "MANUAL_RETAIN",
      "snake_name": "manual_retain",
      "category": "perf",
      "weight": 1.0,
      "brief": "`retain()` is simpler and the same functionalities",
      "what_it_does": "Checks for code to be replaced by `.retain()`.",
      "why_bad": "`.retain()` is simpler and avoids needless allocation.",
      "example": "```no_run\nlet mut vec = vec![0, 1, 2];\nvec = vec.iter().filter(|&x| x % 2 == 0).copied().collect();\nvec = vec.into_iter().filter(|x| x % 2 == 0).collect();\n```\nUse instead:\n```no_run\nlet mut vec = vec![0, 1, 2];\nvec.retain(|x| x % 2 == 0);\nvec.retain(|x| x % 2 == 0);\n```",
      "version": "1.64.0",
      "source_file": "manual_retain.rs",
      "embedding_text": "`retain()` is simpler and the same functionalities\n\nChecks for code to be replaced by `.retain()`.\n\n`.retain()` is simpler and avoids needless allocation."
    },
    {
      "id": "clippy::manual_rotate",
      "name": "MANUAL_ROTATE",
      "snake_name": "manual_rotate",
      "category": "style",
      "weight": 0.95,
      "brief": "using bit shifts to rotate integers",
      "what_it_does": "It detects manual bit rotations that could be rewritten using standard\nfunctions `rotate_left` or `rotate_right`.",
      "why_bad": "Calling the function better conveys the intent.",
      "example": "```no_run\nlet x = 12345678_u32;\nlet _ = (x >> 8) | (x << 24);\n```\nUse instead:\n```no_run\nlet x = 12345678_u32;\nlet _ = x.rotate_right(8);\n```",
      "version": "1.81.0",
      "source_file": "manual_rotate.rs",
      "embedding_text": "using bit shifts to rotate integers\n\nIt detects manual bit rotations that could be rewritten using standard\nfunctions `rotate_left` or `rotate_right`.\n\nCalling the function better conveys the intent."
    },
    {
      "id": "clippy::manual_slice_size_calculation",
      "name": "MANUAL_SLICE_SIZE_CALCULATION",
      "snake_name": "manual_slice_size_calculation",
      "category": "complexity",
      "weight": 1.0,
      "brief": "manual slice size calculation",
      "what_it_does": "When `a` is `&[T]`, detect `a.len() * size_of::<T>()` and suggest `size_of_val(a)`\ninstead.",
      "why_bad": "",
      "example": "```no_run\n# let data : &[i32] = &[1, 2, 3];\nlet newlen = data.len() * size_of::<i32>();\n```\nUse instead:\n```no_run\n# let data : &[i32] = &[1, 2, 3];\nlet newlen = size_of_val(data);\n```",
      "version": "1.70.0",
      "source_file": "manual_slice_size_calculation.rs",
      "embedding_text": "manual slice size calculation\n\nWhen `a` is `&[T]`, detect `a.len() * size_of::<T>()` and suggest `size_of_val(a)`\ninstead."
    },
    {
      "id": "clippy::manual_string_new",
      "name": "MANUAL_STRING_NEW",
      "snake_name": "manual_string_new",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "empty String is being created manually",
      "what_it_does": "Checks for usage of `\"\"` to create a `String`, such as `\"\".to_string()`, `\"\".to_owned()`,\n`String::from(\"\")` and others.",
      "why_bad": "Different ways of creating an empty string makes your code less standardized, which can\nbe confusing.",
      "example": "```no_run\nlet a = \"\".to_string();\nlet b: String = \"\".into();\n```\nUse instead:\n```no_run\nlet a = String::new();\nlet b = String::new();\n```",
      "version": "1.65.0",
      "source_file": "manual_string_new.rs",
      "embedding_text": "empty String is being created manually\n\nChecks for usage of `\"\"` to create a `String`, such as `\"\".to_string()`, `\"\".to_owned()`,\n`String::from(\"\")` and others.\n\nDifferent ways of creating an empty string makes your code less standardized, which can\nbe confusing."
    },
    {
      "id": "clippy::manual_strip",
      "name": "MANUAL_STRIP",
      "snake_name": "manual_strip",
      "category": "complexity",
      "weight": 1.0,
      "brief": "suggests using `strip_{prefix,suffix}` over `str::{starts,ends}_with` and slicing",
      "what_it_does": "Suggests using `strip_{prefix,suffix}` over `str::{starts,ends}_with` and slicing using\nthe pattern's length.",
      "why_bad": "Using `str:strip_{prefix,suffix}` is safer and may have better performance as there is no\nslicing which may panic and the compiler does not need to insert this panic code. It is\nalso sometimes more readable as it removes the need for duplicating or storing the pattern\nused by `str::{starts,ends}_with` and in the slicing.",
      "example": "```no_run\nlet s = \"hello, world!\";\nif s.starts_with(\"hello, \") {\nassert_eq!(s[\"hello, \".len()..].to_uppercase(), \"WORLD!\");\n}\n```\nUse instead:\n```no_run\nlet s = \"hello, world!\";\nif let Some(end) = s.strip_prefix(\"hello, \") {\nassert_eq!(end.to_uppercase(), \"WORLD!\");\n}\n```",
      "version": "1.48.0",
      "source_file": "manual_strip.rs",
      "embedding_text": "suggests using `strip_{prefix,suffix}` over `str::{starts,ends}_with` and slicing\n\nSuggests using `strip_{prefix,suffix}` over `str::{starts,ends}_with` and slicing using\nthe pattern's length.\n\nUsing `str:strip_{prefix,suffix}` is safer and may have better performance as there is no\nslicing which may panic and the compiler does not need to insert this panic code. It is\nalso sometimes more readable as it removes the need for duplicating or storing the pattern\nused by `str::{starts,ends}_with` and in the slicing."
    },
    {
      "id": "clippy::option_map_unit_fn",
      "name": "OPTION_MAP_UNIT_FN",
      "snake_name": "option_map_unit_fn",
      "category": "complexity",
      "weight": 1.0,
      "brief": "using `option.map(f)`, where `f` is a function or closure that returns `()`",
      "what_it_does": "Checks for usage of `option.map(f)` where f is a function\nor closure that returns the unit type `()`.",
      "why_bad": "Readability, this can be written more clearly with\nan if let statement",
      "example": "```no_run\n# fn do_stuff() -> Option<String> { Some(String::new()) }\n# fn log_err_msg(foo: String) -> Option<String> { Some(foo) }\n# fn format_msg(foo: String) -> String { String::new() }\nlet x: Option<String> = do_stuff();\nx.map(log_err_msg);\n# let x: Option<String> = do_stuff();\nx.map(|msg| log_err_msg(format_msg(msg)));\n```\n\nThe correct use would be:\n\n```no_run\n# fn do_stuff() -> Option<String> { Some(String::new()) }\n# fn log_err_msg(foo: String) -> Option<String> { Some(foo) }\n# fn format_msg(foo: String) -> String { String::new() }\nlet x: Option<String> = do_stuff();\nif let Some(msg) = x {\nlog_err_msg(msg);\n}\n\n# let x: Option<String> = do_stuff();\nif let Some(msg) = x {\nlog_err_msg(format_msg(msg));\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "map_unit_fn.rs",
      "embedding_text": "using `option.map(f)`, where `f` is a function or closure that returns `()`\n\nChecks for usage of `option.map(f)` where f is a function\nor closure that returns the unit type `()`.\n\nReadability, this can be written more clearly with\nan if let statement"
    },
    {
      "id": "clippy::result_map_unit_fn",
      "name": "RESULT_MAP_UNIT_FN",
      "snake_name": "result_map_unit_fn",
      "category": "complexity",
      "weight": 1.0,
      "brief": "using `result.map(f)`, where `f` is a function or closure that returns `()`",
      "what_it_does": "Checks for usage of `result.map(f)` where f is a function\nor closure that returns the unit type `()`.",
      "why_bad": "Readability, this can be written more clearly with\nan if let statement",
      "example": "```no_run\n# fn do_stuff() -> Result<String, String> { Ok(String::new()) }\n# fn log_err_msg(foo: String) -> Result<String, String> { Ok(foo) }\n# fn format_msg(foo: String) -> String { String::new() }\nlet x: Result<String, String> = do_stuff();\nx.map(log_err_msg);\n# let x: Result<String, String> = do_stuff();\nx.map(|msg| log_err_msg(format_msg(msg)));\n```\n\nThe correct use would be:\n\n```no_run\n# fn do_stuff() -> Result<String, String> { Ok(String::new()) }\n# fn log_err_msg(foo: String) -> Result<String, String> { Ok(foo) }\n# fn format_msg(foo: String) -> String { String::new() }\nlet x: Result<String, String> = do_stuff();\nif let Ok(msg) = x {\nlog_err_msg(msg);\n};\n# let x: Result<String, String> = do_stuff();\nif let Ok(msg) = x {\nlog_err_msg(format_msg(msg));\n};\n```",
      "version": "pre 1.29.0",
      "source_file": "map_unit_fn.rs",
      "embedding_text": "using `result.map(f)`, where `f` is a function or closure that returns `()`\n\nChecks for usage of `result.map(f)` where f is a function\nor closure that returns the unit type `()`.\n\nReadability, this can be written more clearly with\nan if let statement"
    },
    {
      "id": "clippy::match_result_ok",
      "name": "MATCH_RESULT_OK",
      "snake_name": "match_result_ok",
      "category": "style",
      "weight": 0.95,
      "brief": "usage of `ok()` in `let Some(pat)` statements is unnecessary, match on `Ok(pat)` instead",
      "what_it_does": "Checks for unnecessary `ok()` in `while let`.",
      "why_bad": "Calling `ok()` in `while let` is unnecessary, instead match\non `Ok(pat)`",
      "example": "```ignore\nwhile let Some(value) = iter.next().ok() {\nvec.push(value)\n}\n\nif let Some(value) = iter.next().ok() {\nvec.push(value)\n}\n```\nUse instead:\n```ignore\nwhile let Ok(value) = iter.next() {\nvec.push(value)\n}\n\nif let Ok(value) = iter.next() {\nvec.push(value)\n}\n```",
      "version": "1.57.0",
      "source_file": "match_result_ok.rs",
      "embedding_text": "usage of `ok()` in `let Some(pat)` statements is unnecessary, match on `Ok(pat)` instead\n\nChecks for unnecessary `ok()` in `while let`.\n\nCalling `ok()` in `while let` is unnecessary, instead match\non `Ok(pat)`"
    },
    {
      "id": "clippy::single_match",
      "name": "SINGLE_MATCH",
      "snake_name": "single_match",
      "category": "style",
      "weight": 0.95,
      "brief": "a `match` statement with a single nontrivial arm (i.e., where the other arm is `_ => {}`) instead of `if let`",
      "what_it_does": "Checks for matches with a single arm where an `if let`\nwill usually suffice.\n\nThis intentionally does not lint if there are comments\ninside of the other arm, so as to allow the user to document\nwhy having another explicit pattern with an empty body is necessary,\nor because the comments need to be preserved for other reasons.",
      "why_bad": "Just readability \u2013 `if let` nests less than a `match`.",
      "example": "```no_run\n# fn bar(stool: &str) {}\n# let x = Some(\"abc\");\nmatch x {\nSome(ref foo) => bar(foo),\n_ => (),\n}\n```\n\nUse instead:\n```no_run\n# fn bar(stool: &str) {}\n# let x = Some(\"abc\");\nif let Some(ref foo) = x {\nbar(foo);\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "a `match` statement with a single nontrivial arm (i.e., where the other arm is `_ => {}`) instead of `if let`\n\nChecks for matches with a single arm where an `if let`\nwill usually suffice.\n\nThis intentionally does not lint if there are comments\ninside of the other arm, so as to allow the user to document\nwhy having another explicit pattern with an empty body is necessary,\nor because the comments need to be preserved for other reasons.\n\nJust readability \u2013 `if let` nests less than a `match`."
    },
    {
      "id": "clippy::single_match_else",
      "name": "SINGLE_MATCH_ELSE",
      "snake_name": "single_match_else",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "a `match` statement with two arms where the second arm's pattern is a placeholder instead of a specific match pattern",
      "what_it_does": "Checks for matches with two arms where an `if let else` will\nusually suffice.",
      "why_bad": "Just readability \u2013 `if let` nests less than a `match`.",
      "example": "Using `match`:\n\n```no_run\n# fn bar(foo: &usize) {}\n# let other_ref: usize = 1;\n# let x: Option<&usize> = Some(&1);\nmatch x {\nSome(ref foo) => bar(foo),\n_ => bar(&other_ref),\n}\n```\n\nUsing `if let` with `else`:\n\n```no_run\n# fn bar(foo: &usize) {}\n# let other_ref: usize = 1;\n# let x: Option<&usize> = Some(&1);\nif let Some(ref foo) = x {\nbar(foo);\n} else {\nbar(&other_ref);\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "a `match` statement with two arms where the second arm's pattern is a placeholder instead of a specific match pattern\n\nChecks for matches with two arms where an `if let else` will\nusually suffice.\n\nJust readability \u2013 `if let` nests less than a `match`."
    },
    {
      "id": "clippy::match_ref_pats",
      "name": "MATCH_REF_PATS",
      "snake_name": "match_ref_pats",
      "category": "style",
      "weight": 0.95,
      "brief": "a `match` or `if let` with all arms prefixed with `&` instead of deref-ing the match expression",
      "what_it_does": "Checks for matches where all arms match a reference,\nsuggesting to remove the reference and deref the matched expression\ninstead. It also checks for `if let &foo = bar` blocks.",
      "why_bad": "It just makes the code less readable. That reference\ndestructuring adds nothing to the code.",
      "example": "```rust,ignore\nmatch x {\n&A(ref y) => foo(y),\n&B => bar(),\n_ => frob(&x),\n}\n```\n\nUse instead:\n```rust,ignore\nmatch *x {\nA(ref y) => foo(y),\nB => bar(),\n_ => frob(x),\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "a `match` or `if let` with all arms prefixed with `&` instead of deref-ing the match expression\n\nChecks for matches where all arms match a reference,\nsuggesting to remove the reference and deref the matched expression\ninstead. It also checks for `if let &foo = bar` blocks.\n\nIt just makes the code less readable. That reference\ndestructuring adds nothing to the code."
    },
    {
      "id": "clippy::match_bool",
      "name": "MATCH_BOOL",
      "snake_name": "match_bool",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "a `match` on a boolean expression instead of an `if..else` block",
      "what_it_does": "Checks for matches where match expression is a `bool`. It\nsuggests to replace the expression with an `if...else` block.",
      "why_bad": "It makes the code less readable.",
      "example": "```no_run\n# fn foo() {}\n# fn bar() {}\nlet condition: bool = true;\nmatch condition {\ntrue => foo(),\nfalse => bar(),\n}\n```\nUse if/else instead:\n```no_run\n# fn foo() {}\n# fn bar() {}\nlet condition: bool = true;\nif condition {\nfoo();\n} else {\nbar();\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "a `match` on a boolean expression instead of an `if..else` block\n\nChecks for matches where match expression is a `bool`. It\nsuggests to replace the expression with an `if...else` block.\n\nIt makes the code less readable."
    },
    {
      "id": "clippy::match_overlapping_arm",
      "name": "MATCH_OVERLAPPING_ARM",
      "snake_name": "match_overlapping_arm",
      "category": "style",
      "weight": 0.95,
      "brief": "a `match` with overlapping arms",
      "what_it_does": "Checks for overlapping match arms.",
      "why_bad": "It is likely to be an error and if not, makes the code\nless obvious.",
      "example": "```no_run\nlet x = 5;\nmatch x {\n1..=10 => println!(\"1 ... 10\"),\n5..=15 => println!(\"5 ... 15\"),\n_ => (),\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "a `match` with overlapping arms\n\nChecks for overlapping match arms.\n\nIt is likely to be an error and if not, makes the code\nless obvious."
    },
    {
      "id": "clippy::match_wild_err_arm",
      "name": "MATCH_WILD_ERR_ARM",
      "snake_name": "match_wild_err_arm",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "a `match` with `Err(_)` arm and take drastic actions",
      "what_it_does": "Checks for arm which matches all errors with `Err(_)`\nand take drastic actions like `panic!`.",
      "why_bad": "It is generally a bad practice, similar to\ncatching all exceptions in java with `catch(Exception)`",
      "example": "```no_run\nlet x: Result<i32, &str> = Ok(3);\nmatch x {\nOk(_) => println!(\"ok\"),\nErr(_) => panic!(\"err\"),\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "a `match` with `Err(_)` arm and take drastic actions\n\nChecks for arm which matches all errors with `Err(_)`\nand take drastic actions like `panic!`.\n\nIt is generally a bad practice, similar to\ncatching all exceptions in java with `catch(Exception)`"
    },
    {
      "id": "clippy::match_as_ref",
      "name": "MATCH_AS_REF",
      "snake_name": "match_as_ref",
      "category": "complexity",
      "weight": 1.0,
      "brief": "a `match` on an Option value instead of using `as_ref()` or `as_mut`",
      "what_it_does": "Checks for match which is used to add a reference to an\n`Option` value.",
      "why_bad": "Using `as_ref()` or `as_mut()` instead is shorter.",
      "example": "```no_run\nlet x: Option<()> = None;\n\nlet r: Option<&()> = match x {\nNone => None,\nSome(ref v) => Some(v),\n};\n```\n\nUse instead:\n```no_run\nlet x: Option<()> = None;\n\nlet r: Option<&()> = x.as_ref();\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "a `match` on an Option value instead of using `as_ref()` or `as_mut`\n\nChecks for match which is used to add a reference to an\n`Option` value.\n\nUsing `as_ref()` or `as_mut()` instead is shorter."
    },
    {
      "id": "clippy::wildcard_enum_match_arm",
      "name": "WILDCARD_ENUM_MATCH_ARM",
      "snake_name": "wildcard_enum_match_arm",
      "category": "restriction",
      "weight": 1.0,
      "brief": "a wildcard enum match arm using `_`",
      "what_it_does": "Checks for wildcard enum matches using `_`.",
      "why_bad": "New enum variants added by library updates can be missed.",
      "example": "```no_run\n# enum Foo { A(usize), B(usize) }\n# let x = Foo::B(1);\nmatch x {\nFoo::A(_) => {},\n_ => {},\n}\n```\n\nUse instead:\n```no_run\n# enum Foo { A(usize), B(usize) }\n# let x = Foo::B(1);\nmatch x {\nFoo::A(_) => {},\nFoo::B(_) => {},\n}\n```",
      "version": "1.34.0",
      "source_file": "mod.rs",
      "embedding_text": "a wildcard enum match arm using `_`\n\nChecks for wildcard enum matches using `_`.\n\nNew enum variants added by library updates can be missed."
    },
    {
      "id": "clippy::match_wildcard_for_single_variants",
      "name": "MATCH_WILDCARD_FOR_SINGLE_VARIANTS",
      "snake_name": "match_wildcard_for_single_variants",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "a wildcard enum match for a single variant",
      "what_it_does": "Checks for wildcard enum matches for a single variant.",
      "why_bad": "New enum variants added by library updates can be missed.",
      "example": "```no_run\n# enum Foo { A, B, C }\n# let x = Foo::B;\nmatch x {\nFoo::A => {},\nFoo::B => {},\n_ => {},\n}\n```\n\nUse instead:\n```no_run\n# enum Foo { A, B, C }\n# let x = Foo::B;\nmatch x {\nFoo::A => {},\nFoo::B => {},\nFoo::C => {},\n}\n```",
      "version": "1.45.0",
      "source_file": "mod.rs",
      "embedding_text": "a wildcard enum match for a single variant\n\nChecks for wildcard enum matches for a single variant.\n\nNew enum variants added by library updates can be missed."
    },
    {
      "id": "clippy::wildcard_in_or_patterns",
      "name": "WILDCARD_IN_OR_PATTERNS",
      "snake_name": "wildcard_in_or_patterns",
      "category": "complexity",
      "weight": 1.0,
      "brief": "a wildcard pattern used with others patterns in same match arm",
      "what_it_does": "Checks for wildcard pattern used with others patterns in same match arm.",
      "why_bad": "Wildcard pattern already covers any other pattern as it will match anyway.\nIt makes the code less readable, especially to spot wildcard pattern use in match arm.",
      "example": "```no_run\n# let s = \"foo\";\nmatch s {\n\"a\" => {},\n\"bar\" | _ => {},\n}\n```\n\nUse instead:\n```no_run\n# let s = \"foo\";\nmatch s {\n\"a\" => {},\n_ => {},\n}\n```",
      "version": "1.42.0",
      "source_file": "mod.rs",
      "embedding_text": "a wildcard pattern used with others patterns in same match arm\n\nChecks for wildcard pattern used with others patterns in same match arm.\n\nWildcard pattern already covers any other pattern as it will match anyway.\nIt makes the code less readable, especially to spot wildcard pattern use in match arm."
    },
    {
      "id": "clippy::infallible_destructuring_match",
      "name": "INFALLIBLE_DESTRUCTURING_MATCH",
      "snake_name": "infallible_destructuring_match",
      "category": "style",
      "weight": 0.95,
      "brief": "a `match` statement with a single infallible arm instead of a `let`",
      "what_it_does": "Checks for matches being used to destructure a single-variant enum\nor tuple struct where a `let` will suffice.",
      "why_bad": "Just readability \u2013 `let` doesn't nest, whereas a `match` does.",
      "example": "```no_run\nenum Wrapper {\nData(i32),\n}\n\nlet wrapper = Wrapper::Data(42);\n\nlet data = match wrapper {\nWrapper::Data(i) => i,\n};\n```\n\nThe correct use would be:\n```no_run\nenum Wrapper {\nData(i32),\n}\n\nlet wrapper = Wrapper::Data(42);\nlet Wrapper::Data(data) = wrapper;\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "a `match` statement with a single infallible arm instead of a `let`\n\nChecks for matches being used to destructure a single-variant enum\nor tuple struct where a `let` will suffice.\n\nJust readability \u2013 `let` doesn't nest, whereas a `match` does."
    },
    {
      "id": "clippy::match_single_binding",
      "name": "MATCH_SINGLE_BINDING",
      "snake_name": "match_single_binding",
      "category": "complexity",
      "weight": 1.0,
      "brief": "a match with a single binding instead of using `let` statement",
      "what_it_does": "Checks for useless match that binds to only one value.",
      "why_bad": "Readability and needless complexity.",
      "example": "```no_run\n# let a = 1;\n# let b = 2;\nmatch (a, b) {\n(c, d) => {\n// useless match\n}\n}\n```\n\nUse instead:\n```no_run\n# let a = 1;\n# let b = 2;\nlet (c, d) = (a, b);\n```",
      "version": "1.43.0",
      "source_file": "mod.rs",
      "embedding_text": "a match with a single binding instead of using `let` statement\n\nChecks for useless match that binds to only one value.\n\nReadability and needless complexity."
    },
    {
      "id": "clippy::rest_pat_in_fully_bound_structs",
      "name": "REST_PAT_IN_FULLY_BOUND_STRUCTS",
      "snake_name": "rest_pat_in_fully_bound_structs",
      "category": "restriction",
      "weight": 1.0,
      "brief": "a match on a struct that binds all fields but still uses the wildcard pattern",
      "what_it_does": "Checks for unnecessary '..' pattern binding on struct when all fields are explicitly matched.",
      "why_bad": "Correctness and readability. It's like having a wildcard pattern after\nmatching all enum variants explicitly.",
      "example": "```no_run\n# struct A { a: i32 }\nlet a = A { a: 5 };\n\nmatch a {\nA { a: 5, .. } => {},\n_ => {},\n}\n```\n\nUse instead:\n```no_run\n# struct A { a: i32 }\n# let a = A { a: 5 };\nmatch a {\nA { a: 5 } => {},\n_ => {},\n}\n```",
      "version": "1.43.0",
      "source_file": "mod.rs",
      "embedding_text": "a match on a struct that binds all fields but still uses the wildcard pattern\n\nChecks for unnecessary '..' pattern binding on struct when all fields are explicitly matched.\n\nCorrectness and readability. It's like having a wildcard pattern after\nmatching all enum variants explicitly."
    },
    {
      "id": "clippy::redundant_pattern_matching",
      "name": "REDUNDANT_PATTERN_MATCHING",
      "snake_name": "redundant_pattern_matching",
      "category": "style",
      "weight": 0.95,
      "brief": "use the proper utility function avoiding an `if let`",
      "what_it_does": "Lint for redundant pattern matching over `Result`, `Option`,\n`std::task::Poll`, `std::net::IpAddr` or `bool`s",
      "why_bad": "It's more concise and clear to just use the proper\nutility function or using the condition directly",
      "example": "```no_run\n# use std::task::Poll;\n# use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\nif let Ok(_) = Ok::<i32, i32>(42) {}\nif let Err(_) = Err::<i32, i32>(42) {}\nif let None = None::<()> {}\nif let Some(_) = Some(42) {}\nif let Poll::Pending = Poll::Pending::<()> {}\nif let Poll::Ready(_) = Poll::Ready(42) {}\nif let IpAddr::V4(_) = IpAddr::V4(Ipv4Addr::LOCALHOST) {}\nif let IpAddr::V6(_) = IpAddr::V6(Ipv6Addr::LOCALHOST) {}\nmatch Ok::<i32, i32>(42) {\nOk(_) => true,\nErr(_) => false,\n};\n\nlet cond = true;\nif let true = cond {}\nmatches!(cond, true);\n```\n\nThe more idiomatic use would be:\n\n```no_run\n# use std::task::Poll;\n# use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\nif Ok::<i32, i32>(42).is_ok() {}\nif Err::<i32, i32>(42).is_err() {}\nif None::<()>.is_none() {}\nif Some(42).is_some() {}\nif Poll::Pending::<()>.is_pending() {}\nif Poll::Ready(42).is_ready() {}\nif IpAddr::V4(Ipv4Addr::LOCALHOST).is_ipv4() {}\nif IpAddr::V6(Ipv6Addr::LOCALHOST).is_ipv6() {}\nOk::<i32, i32>(42).is_ok();\n\nlet cond = true;\nif cond {}\ncond;\n```",
      "version": "1.31.0",
      "source_file": "mod.rs",
      "embedding_text": "use the proper utility function avoiding an `if let`\n\nLint for redundant pattern matching over `Result`, `Option`,\n`std::task::Poll`, `std::net::IpAddr` or `bool`s\n\nIt's more concise and clear to just use the proper\nutility function or using the condition directly"
    },
    {
      "id": "clippy::match_like_matches_macro",
      "name": "MATCH_LIKE_MATCHES_MACRO",
      "snake_name": "match_like_matches_macro",
      "category": "style",
      "weight": 0.95,
      "brief": "a match that could be written with the matches! macro",
      "what_it_does": "Checks for `match`  or `if let` expressions producing a\n`bool` that could be written using `matches!`",
      "why_bad": "Readability and needless complexity.",
      "example": "```no_run\nlet x = Some(5);\n\nlet a = match x {\nSome(0) => true,\n_ => false,\n};\n\nlet a = if let Some(0) = x {\ntrue\n} else {\nfalse\n};\n```\n\nUse instead:\n```no_run\nlet x = Some(5);\nlet a = matches!(x, Some(0));\n```",
      "version": "1.47.0",
      "source_file": "mod.rs",
      "embedding_text": "a match that could be written with the matches! macro\n\nChecks for `match`  or `if let` expressions producing a\n`bool` that could be written using `matches!`\n\nReadability and needless complexity."
    },
    {
      "id": "clippy::match_same_arms",
      "name": "MATCH_SAME_ARMS",
      "snake_name": "match_same_arms",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "`match` with identical arm bodies",
      "what_it_does": "Checks for `match` with identical arm bodies.\n\nNote: Does not lint on wildcards if the `non_exhaustive_omitted_patterns_lint` feature is\nenabled and disallowed.",
      "why_bad": "This is probably a copy & paste error. If arm bodies\nare the same on purpose, you can factor them\n[using `|`](https://doc.rust-lang.org/book/patterns.html#multiple-patterns).",
      "example": "```rust,ignore\nmatch foo {\nBar => bar(),\nQuz => quz(),\nBaz => bar(), // <= oops\n}\n```\n\nThis should probably be\n```rust,ignore\nmatch foo {\nBar => bar(),\nQuz => quz(),\nBaz => baz(), // <= fixed\n}\n```\n\nor if the original code was not a typo:\n```rust,ignore\nmatch foo {\nBar | Baz => bar(), // <= shows the intent better\nQuz => quz(),\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "`match` with identical arm bodies\n\nChecks for `match` with identical arm bodies.\n\nNote: Does not lint on wildcards if the `non_exhaustive_omitted_patterns_lint` feature is\nenabled and disallowed.\n\nThis is probably a copy & paste error. If arm bodies\nare the same on purpose, you can factor them\n[using `|`](https://doc.rust-lang.org/book/patterns.html#multiple-patterns)."
    },
    {
      "id": "clippy::needless_match",
      "name": "NEEDLESS_MATCH",
      "snake_name": "needless_match",
      "category": "complexity",
      "weight": 1.0,
      "brief": "`match` or match-like `if let` that are unnecessary",
      "what_it_does": "Checks for unnecessary `match` or match-like `if let` returns for `Option` and `Result`\nwhen function signatures are the same.",
      "why_bad": "This `match` block does nothing and might not be what the coder intended.",
      "example": "```rust,ignore\nfn foo() -> Result<(), i32> {\nmatch result {\nOk(val) => Ok(val),\nErr(err) => Err(err),\n}\n}\n\nfn bar() -> Option<i32> {\nif let Some(val) = option {\nSome(val)\n} else {\nNone\n}\n}\n```\n\nCould be replaced as\n\n```rust,ignore\nfn foo() -> Result<(), i32> {\nresult\n}\n\nfn bar() -> Option<i32> {\noption\n}\n```",
      "version": "1.61.0",
      "source_file": "mod.rs",
      "embedding_text": "`match` or match-like `if let` that are unnecessary\n\nChecks for unnecessary `match` or match-like `if let` returns for `Option` and `Result`\nwhen function signatures are the same.\n\nThis `match` block does nothing and might not be what the coder intended."
    },
    {
      "id": "clippy::collapsible_match",
      "name": "COLLAPSIBLE_MATCH",
      "snake_name": "collapsible_match",
      "category": "style",
      "weight": 0.95,
      "brief": "Nested `match` or `if let` expressions where the patterns may be \\",
      "what_it_does": "Finds nested `match` or `if let` expressions where the patterns may be \"collapsed\" together\nwithout adding any branches.\n\nNote that this lint is not intended to find _all_ cases where nested match patterns can be merged, but only\ncases where merging would most likely make the code more readable.",
      "why_bad": "It is unnecessarily verbose and complex.",
      "example": "```no_run\nfn func(opt: Option<Result<u64, String>>) {\nlet n = match opt {\nSome(n) => match n {\nOk(n) => n,\n_ => return,\n}\nNone => return,\n};\n}\n```\nUse instead:\n```no_run\nfn func(opt: Option<Result<u64, String>>) {\nlet n = match opt {\nSome(Ok(n)) => n,\n_ => return,\n};\n}\n```",
      "version": "1.50.0",
      "source_file": "mod.rs",
      "embedding_text": "Nested `match` or `if let` expressions where the patterns may be \\\n\nFinds nested `match` or `if let` expressions where the patterns may be \"collapsed\" together\nwithout adding any branches.\n\nNote that this lint is not intended to find _all_ cases where nested match patterns can be merged, but only\ncases where merging would most likely make the code more readable.\n\nIt is unnecessarily verbose and complex."
    },
    {
      "id": "clippy::manual_unwrap_or",
      "name": "MANUAL_UNWRAP_OR",
      "snake_name": "manual_unwrap_or",
      "category": "complexity",
      "weight": 1.0,
      "brief": "finds patterns that can be encoded more concisely with `Option::unwrap_or` or `Result::unwrap_or`",
      "what_it_does": "Finds patterns that reimplement `Option::unwrap_or` or `Result::unwrap_or`.",
      "why_bad": "Concise code helps focusing on behavior instead of boilerplate.",
      "example": "```no_run\nlet foo: Option<i32> = None;\nmatch foo {\nSome(v) => v,\nNone => 1,\n};\n```\n\nUse instead:\n```no_run\nlet foo: Option<i32> = None;\nfoo.unwrap_or(1);\n```",
      "version": "1.49.0",
      "source_file": "mod.rs",
      "embedding_text": "finds patterns that can be encoded more concisely with `Option::unwrap_or` or `Result::unwrap_or`\n\nFinds patterns that reimplement `Option::unwrap_or` or `Result::unwrap_or`.\n\nConcise code helps focusing on behavior instead of boilerplate."
    },
    {
      "id": "clippy::manual_unwrap_or_default",
      "name": "MANUAL_UNWRAP_OR_DEFAULT",
      "snake_name": "manual_unwrap_or_default",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "check if a `match` or `if let` can be simplified with `unwrap_or_default`",
      "what_it_does": "Checks if a `match` or `if let` expression can be simplified using\n`.unwrap_or_default()`.",
      "why_bad": "It can be done in one call with `.unwrap_or_default()`.",
      "example": "```no_run\nlet x: Option<String> = Some(String::new());\nlet y: String = match x {\nSome(v) => v,\nNone => String::new(),\n};\n\nlet x: Option<Vec<String>> = Some(Vec::new());\nlet y: Vec<String> = if let Some(v) = x {\nv\n} else {\nVec::new()\n};\n```\nUse instead:\n```no_run\nlet x: Option<String> = Some(String::new());\nlet y: String = x.unwrap_or_default();\n\nlet x: Option<Vec<String>> = Some(Vec::new());\nlet y: Vec<String> = x.unwrap_or_default();\n```",
      "version": "1.79.0",
      "source_file": "mod.rs",
      "embedding_text": "check if a `match` or `if let` can be simplified with `unwrap_or_default`\n\nChecks if a `match` or `if let` expression can be simplified using\n`.unwrap_or_default()`.\n\nIt can be done in one call with `.unwrap_or_default()`."
    },
    {
      "id": "clippy::match_str_case_mismatch",
      "name": "MATCH_STR_CASE_MISMATCH",
      "snake_name": "match_str_case_mismatch",
      "category": "correctness",
      "weight": 1.2,
      "brief": "creation of a case altering match expression with non-compliant arms",
      "what_it_does": "Checks for `match` expressions modifying the case of a string with non-compliant arms",
      "why_bad": "The arm is unreachable, which is likely a mistake",
      "example": "```no_run\n# let text = \"Foo\";\nmatch &*text.to_ascii_lowercase() {\n\"foo\" => {},\n\"Bar\" => {},\n_ => {},\n}\n```\nUse instead:\n```no_run\n# let text = \"Foo\";\nmatch &*text.to_ascii_lowercase() {\n\"foo\" => {},\n\"bar\" => {},\n_ => {},\n}\n```",
      "version": "1.58.0",
      "source_file": "mod.rs",
      "embedding_text": "creation of a case altering match expression with non-compliant arms\n\nChecks for `match` expressions modifying the case of a string with non-compliant arms\n\nThe arm is unreachable, which is likely a mistake"
    },
    {
      "id": "clippy::significant_drop_in_scrutinee",
      "name": "SIGNIFICANT_DROP_IN_SCRUTINEE",
      "snake_name": "significant_drop_in_scrutinee",
      "category": "nursery",
      "weight": 0.9,
      "brief": "warns when a temporary of a type with a drop with a significant side-effect might have a surprising lifetime",
      "what_it_does": "Checks for temporaries returned from function calls in a match scrutinee that have the\n`clippy::has_significant_drop` attribute.",
      "why_bad": "The `clippy::has_significant_drop` attribute can be added to types whose Drop impls have\nan important side-effect, such as unlocking a mutex, making it important for users to be\nable to accurately understand their lifetimes. When a temporary is returned in a function\ncall in a match scrutinee, its lifetime lasts until the end of the match block, which may\nbe surprising.\n\nFor `Mutex`es this can lead to a deadlock. This happens when the match scrutinee uses a\nfunction call that returns a `MutexGuard` and then tries to lock again in one of the match\narms. In that case the `MutexGuard` in the scrutinee will not be dropped until the end of\nthe match block and thus will not unlock.",
      "example": "```rust,ignore\n# use std::sync::Mutex;\n# struct State {}\n# impl State {\n#     fn foo(&self) -> bool {\n#         true\n#     }\n#     fn bar(&self) {}\n# }\nlet mutex = Mutex::new(State {});\n\nmatch mutex.lock().unwrap().foo() {\ntrue => {\nmutex.lock().unwrap().bar(); // Deadlock!\n}\nfalse => {}\n};\n\nprintln!(\"All done!\");\n```\nUse instead:\n```no_run\n# use std::sync::Mutex;\n# struct State {}\n# impl State {\n#     fn foo(&self) -> bool {\n#         true\n#     }\n#     fn bar(&self) {}\n# }\nlet mutex = Mutex::new(State {});\n\nlet is_foo = mutex.lock().unwrap().foo();\nmatch is_foo {\ntrue => {\nmutex.lock().unwrap().bar();\n}\nfalse => {}\n};\n\nprintln!(\"All done!\");\n```",
      "version": "1.60.0",
      "source_file": "mod.rs",
      "embedding_text": "warns when a temporary of a type with a drop with a significant side-effect might have a surprising lifetime\n\nChecks for temporaries returned from function calls in a match scrutinee that have the\n`clippy::has_significant_drop` attribute.\n\nThe `clippy::has_significant_drop` attribute can be added to types whose Drop impls have\nan important side-effect, such as unlocking a mutex, making it important for users to be\nable to accurately understand their lifetimes. When a temporary is returned in a function\ncall in a match scrutinee, its lifetime lasts until the end of the match block, which may\nbe surprising.\n\nFor `Mutex`es this can lead to a deadlock. This happens when the match scrutinee uses a\nfunction call that returns a `MutexGuard` and then tries to lock again in one of the match\narms. In that case the `MutexGuard` in the scrutinee will not be dropped until the end of\nthe match block and thus will not unlock."
    },
    {
      "id": "clippy::try_err",
      "name": "TRY_ERR",
      "snake_name": "try_err",
      "category": "restriction",
      "weight": 1.0,
      "brief": "return errors explicitly rather than hiding them behind a `?`",
      "what_it_does": "Checks for usage of `Err(x)?`.",
      "why_bad": "The `?` operator is designed to allow calls that\ncan fail to be easily chained. For example, `foo()?.bar()` or\n`foo(bar()?)`. Because `Err(x)?` can't be used that way (it will\nalways return), it is more clear to write `return Err(x)`.",
      "example": "```no_run\nfn foo(fail: bool) -> Result<i32, String> {\nif fail {\nErr(\"failed\")?;\n}\nOk(0)\n}\n```\nCould be written:\n\n```no_run\nfn foo(fail: bool) -> Result<i32, String> {\nif fail {\nreturn Err(\"failed\".into());\n}\nOk(0)\n}\n```",
      "version": "1.38.0",
      "source_file": "mod.rs",
      "embedding_text": "return errors explicitly rather than hiding them behind a `?`\n\nChecks for usage of `Err(x)?`.\n\nThe `?` operator is designed to allow calls that\ncan fail to be easily chained. For example, `foo()?.bar()` or\n`foo(bar()?)`. Because `Err(x)?` can't be used that way (it will\nalways return), it is more clear to write `return Err(x)`."
    },
    {
      "id": "clippy::manual_map",
      "name": "MANUAL_MAP",
      "snake_name": "manual_map",
      "category": "style",
      "weight": 0.95,
      "brief": "reimplementation of `map`",
      "what_it_does": "Checks for usage of `match` which could be implemented using `map`",
      "why_bad": "Using the `map` method is clearer and more concise.",
      "example": "```no_run\nmatch Some(0) {\nSome(x) => Some(x + 1),\nNone => None,\n};\n```\nUse instead:\n```no_run\nSome(0).map(|x| x + 1);\n```",
      "version": "1.52.0",
      "source_file": "mod.rs",
      "embedding_text": "reimplementation of `map`\n\nChecks for usage of `match` which could be implemented using `map`\n\nUsing the `map` method is clearer and more concise."
    },
    {
      "id": "clippy::manual_filter",
      "name": "MANUAL_FILTER",
      "snake_name": "manual_filter",
      "category": "complexity",
      "weight": 1.0,
      "brief": "reimplementation of `filter`",
      "what_it_does": "Checks for usage of `match` which could be implemented using `filter`",
      "why_bad": "Using the `filter` method is clearer and more concise.",
      "example": "```no_run\nmatch Some(0) {\nSome(x) => if x % 2 == 0 {\nSome(x)\n} else {\nNone\n},\nNone => None,\n};\n```\nUse instead:\n```no_run\nSome(0).filter(|&x| x % 2 == 0);\n```",
      "version": "1.66.0",
      "source_file": "mod.rs",
      "embedding_text": "reimplementation of `filter`\n\nChecks for usage of `match` which could be implemented using `filter`\n\nUsing the `filter` method is clearer and more concise."
    },
    {
      "id": "clippy::redundant_guards",
      "name": "REDUNDANT_GUARDS",
      "snake_name": "redundant_guards",
      "category": "complexity",
      "weight": 1.0,
      "brief": "checks for unnecessary guards in match expressions",
      "what_it_does": "Checks for unnecessary guards in match expressions.",
      "why_bad": "It's more complex and much less readable. Making it part of the pattern can improve\nexhaustiveness checking as well.",
      "example": "```rust,ignore\nmatch x {\nSome(x) if matches!(x, Some(1)) => ..,\nSome(x) if x == Some(2) => ..,\n_ => todo!(),\n}\n```\nUse instead:\n```rust,ignore\nmatch x {\nSome(Some(1)) => ..,\nSome(Some(2)) => ..,\n_ => todo!(),\n}\n```",
      "version": "1.73.0",
      "source_file": "mod.rs",
      "embedding_text": "checks for unnecessary guards in match expressions\n\nChecks for unnecessary guards in match expressions.\n\nIt's more complex and much less readable. Making it part of the pattern can improve\nexhaustiveness checking as well."
    },
    {
      "id": "clippy::manual_ok_err",
      "name": "MANUAL_OK_ERR",
      "snake_name": "manual_ok_err",
      "category": "complexity",
      "weight": 1.0,
      "brief": "find manual implementations of `.ok()` or `.err()` on `Result`",
      "what_it_does": "Checks for manual implementation of `.ok()` or `.err()`\non `Result` values.",
      "why_bad": "Using `.ok()` or `.err()` rather than a `match` or\n`if let` is less complex and more readable.",
      "example": "```no_run\n# fn func() -> Result<u32, &'static str> { Ok(0) }\nlet a = match func() {\nOk(v) => Some(v),\nErr(_) => None,\n};\nlet b = if let Err(v) = func() {\nSome(v)\n} else {\nNone\n};\n```\nUse instead:\n```no_run\n# fn func() -> Result<u32, &'static str> { Ok(0) }\nlet a = func().ok();\nlet b = func().err();\n```",
      "version": "1.86.0",
      "source_file": "mod.rs",
      "embedding_text": "find manual implementations of `.ok()` or `.err()` on `Result`\n\nChecks for manual implementation of `.ok()` or `.err()`\non `Result` values.\n\nUsing `.ok()` or `.err()` rather than a `match` or\n`if let` is less complex and more readable."
    },
    {
      "id": "clippy::mem_replace_option_with_none",
      "name": "MEM_REPLACE_OPTION_WITH_NONE",
      "snake_name": "mem_replace_option_with_none",
      "category": "style",
      "weight": 0.95,
      "brief": "replacing an `Option` with `None` instead of `take()`",
      "what_it_does": "Checks for `mem::replace()` on an `Option` with\n`None`.",
      "why_bad": "`Option` already has the method `take()` for\ntaking its current value (Some(..) or None) and replacing it with\n`None`.",
      "example": "```no_run\nuse std::mem;\n\nlet mut an_option = Some(0);\nlet replaced = mem::replace(&mut an_option, None);\n```\nIs better expressed with:\n```no_run\nlet mut an_option = Some(0);\nlet taken = an_option.take();\n```",
      "version": "1.31.0",
      "source_file": "mem_replace.rs",
      "embedding_text": "replacing an `Option` with `None` instead of `take()`\n\nChecks for `mem::replace()` on an `Option` with\n`None`.\n\n`Option` already has the method `take()` for\ntaking its current value (Some(..) or None) and replacing it with\n`None`."
    },
    {
      "id": "clippy::mem_replace_option_with_some",
      "name": "MEM_REPLACE_OPTION_WITH_SOME",
      "snake_name": "mem_replace_option_with_some",
      "category": "style",
      "weight": 0.95,
      "brief": "replacing an `Option` with `Some` instead of `replace()`",
      "what_it_does": "Checks for `mem::replace()` on an `Option` with `Some(\u2026)`.",
      "why_bad": "`Option` already has the method `replace()` for\ntaking its current value (Some(\u2026) or None) and replacing it with\n`Some(\u2026)`.",
      "example": "```no_run\nlet mut an_option = Some(0);\nlet replaced = std::mem::replace(&mut an_option, Some(1));\n```\nIs better expressed with:\n```no_run\nlet mut an_option = Some(0);\nlet taken = an_option.replace(1);\n```",
      "version": "1.87.0",
      "source_file": "mem_replace.rs",
      "embedding_text": "replacing an `Option` with `Some` instead of `replace()`\n\nChecks for `mem::replace()` on an `Option` with `Some(\u2026)`.\n\n`Option` already has the method `replace()` for\ntaking its current value (Some(\u2026) or None) and replacing it with\n`Some(\u2026)`."
    },
    {
      "id": "clippy::mem_replace_with_uninit",
      "name": "MEM_REPLACE_WITH_UNINIT",
      "snake_name": "mem_replace_with_uninit",
      "category": "correctness",
      "weight": 1.2,
      "brief": "`mem::replace(&mut _, mem::uninitialized())` or `mem::replace(&mut _, mem::zeroed())`",
      "what_it_does": "Checks for `mem::replace(&mut _, mem::uninitialized())`\nand `mem::replace(&mut _, mem::zeroed())`.",
      "why_bad": "This will lead to undefined behavior even if the\nvalue is overwritten later, because the uninitialized value may be\nobserved in the case of a panic.",
      "example": "```no_run\nuse std::mem;\n# fn may_panic(v: Vec<i32>) -> Vec<i32> { v }\n\n#[allow(deprecated, invalid_value)]\nfn myfunc (v: &mut Vec<i32>) {\nlet taken_v = unsafe { mem::replace(v, mem::uninitialized()) };\nlet new_v = may_panic(taken_v); // undefined behavior on panic\nmem::forget(mem::replace(v, new_v));\n}\n```\n\nThe [take_mut](https://docs.rs/take_mut) crate offers a sound solution,\nat the cost of either lazily creating a replacement value or aborting\non panic, to ensure that the uninitialized value cannot be observed.",
      "version": "1.39.0",
      "source_file": "mem_replace.rs",
      "embedding_text": "`mem::replace(&mut _, mem::uninitialized())` or `mem::replace(&mut _, mem::zeroed())`\n\nChecks for `mem::replace(&mut _, mem::uninitialized())`\nand `mem::replace(&mut _, mem::zeroed())`.\n\nThis will lead to undefined behavior even if the\nvalue is overwritten later, because the uninitialized value may be\nobserved in the case of a panic."
    },
    {
      "id": "clippy::mem_replace_with_default",
      "name": "MEM_REPLACE_WITH_DEFAULT",
      "snake_name": "mem_replace_with_default",
      "category": "style",
      "weight": 0.95,
      "brief": "replacing a value of type `T` with `T::default()` instead of using `std::mem::take`",
      "what_it_does": "Checks for `std::mem::replace` on a value of type\n`T` with `T::default()`.",
      "why_bad": "`std::mem` module already has the method `take` to\ntake the current value and replace it with the default value of that type.",
      "example": "```no_run\nlet mut text = String::from(\"foo\");\nlet replaced = std::mem::replace(&mut text, String::default());\n```\nIs better expressed with:\n```no_run\nlet mut text = String::from(\"foo\");\nlet taken = std::mem::take(&mut text);\n```",
      "version": "1.42.0",
      "source_file": "mem_replace.rs",
      "embedding_text": "replacing a value of type `T` with `T::default()` instead of using `std::mem::take`\n\nChecks for `std::mem::replace` on a value of type\n`T` with `T::default()`.\n\n`std::mem` module already has the method `take` to\ntake the current value and replace it with the default value of that type."
    },
    {
      "id": "clippy::cloned_instead_of_copied",
      "name": "CLONED_INSTEAD_OF_COPIED",
      "snake_name": "cloned_instead_of_copied",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "used `cloned` where `copied` could be used instead",
      "what_it_does": "Checks for usage of `cloned()` on an `Iterator` or `Option` where\n`copied()` could be used instead.",
      "why_bad": "`copied()` is better because it guarantees that the type being cloned\nimplements `Copy`.",
      "example": "```no_run\n[1, 2, 3].iter().cloned();\n```\nUse instead:\n```no_run\n[1, 2, 3].iter().copied();\n```",
      "version": "1.53.0",
      "source_file": "mod.rs",
      "embedding_text": "used `cloned` where `copied` could be used instead\n\nChecks for usage of `cloned()` on an `Iterator` or `Option` where\n`copied()` could be used instead.\n\n`copied()` is better because it guarantees that the type being cloned\nimplements `Copy`."
    },
    {
      "id": "clippy::collapsible_str_replace",
      "name": "COLLAPSIBLE_STR_REPLACE",
      "snake_name": "collapsible_str_replace",
      "category": "perf",
      "weight": 1.0,
      "brief": "collapse consecutive calls to str::replace (2 or more) into a single call",
      "what_it_does": "Checks for consecutive calls to `str::replace` (2 or more)\nthat can be collapsed into a single call.",
      "why_bad": "Consecutive `str::replace` calls scan the string multiple times\nwith repetitive code.",
      "example": "```no_run\nlet hello = \"hesuo worpd\"\n.replace('s', \"l\")\n.replace(\"u\", \"l\")\n.replace('p', \"l\");\n```\nUse instead:\n```no_run\nlet hello = \"hesuo worpd\".replace(['s', 'u', 'p'], \"l\");\n```",
      "version": "1.65.0",
      "source_file": "mod.rs",
      "embedding_text": "collapse consecutive calls to str::replace (2 or more) into a single call\n\nChecks for consecutive calls to `str::replace` (2 or more)\nthat can be collapsed into a single call.\n\nConsecutive `str::replace` calls scan the string multiple times\nwith repetitive code."
    },
    {
      "id": "clippy::iter_overeager_cloned",
      "name": "ITER_OVEREAGER_CLONED",
      "snake_name": "iter_overeager_cloned",
      "category": "perf",
      "weight": 1.0,
      "brief": "using `cloned()` early with `Iterator::iter()` can lead to some performance inefficiencies",
      "what_it_does": "Checks for usage of `_.cloned().<func>()` where call to `.cloned()` can be postponed.",
      "why_bad": "It's often inefficient to clone all elements of an iterator, when eventually, only some\nof them will be consumed.",
      "example": "```no_run\n# let vec = vec![\"string\".to_string()];\nvec.iter().cloned().take(10);\nvec.iter().cloned().last();\n```\n\nUse instead:\n```no_run\n# let vec = vec![\"string\".to_string()];\nvec.iter().take(10).cloned();\nvec.iter().last().cloned();\n```",
      "version": "1.60.0",
      "source_file": "mod.rs",
      "embedding_text": "using `cloned()` early with `Iterator::iter()` can lead to some performance inefficiencies\n\nChecks for usage of `_.cloned().<func>()` where call to `.cloned()` can be postponed.\n\nIt's often inefficient to clone all elements of an iterator, when eventually, only some\nof them will be consumed."
    },
    {
      "id": "clippy::flat_map_option",
      "name": "FLAT_MAP_OPTION",
      "snake_name": "flat_map_option",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "used `flat_map` where `filter_map` could be used instead",
      "what_it_does": "Checks for usage of `Iterator::flat_map()` where `filter_map()` could be\nused instead.",
      "why_bad": "`filter_map()` is known to always produce 0 or 1 output items per input item,\nrather than however many the inner iterator type produces.\nTherefore, it maintains the upper bound in `Iterator::size_hint()`,\nand communicates to the reader that the input items are not being expanded into\nmultiple output items without their having to notice that the mapping function\nreturns an `Option`.",
      "example": "```no_run\nlet nums: Vec<i32> = [\"1\", \"2\", \"whee!\"].iter().flat_map(|x| x.parse().ok()).collect();\n```\nUse instead:\n```no_run\nlet nums: Vec<i32> = [\"1\", \"2\", \"whee!\"].iter().filter_map(|x| x.parse().ok()).collect();\n```",
      "version": "1.53.0",
      "source_file": "mod.rs",
      "embedding_text": "used `flat_map` where `filter_map` could be used instead\n\nChecks for usage of `Iterator::flat_map()` where `filter_map()` could be\nused instead.\n\n`filter_map()` is known to always produce 0 or 1 output items per input item,\nrather than however many the inner iterator type produces.\nTherefore, it maintains the upper bound in `Iterator::size_hint()`,\nand communicates to the reader that the input items are not being expanded into\nmultiple output items without their having to notice that the mapping function\nreturns an `Option`."
    },
    {
      "id": "clippy::unwrap_used",
      "name": "UNWRAP_USED",
      "snake_name": "unwrap_used",
      "category": "restriction",
      "weight": 1.0,
      "brief": "using `.unwrap()` on `Result` or `Option`, which should at least get a better message using `expect()`",
      "what_it_does": "Checks for `.unwrap()` or `.unwrap_err()` calls on `Result`s and `.unwrap()` call on `Option`s.",
      "why_bad": "It is better to handle the `None` or `Err` case,\nor at least call `.expect(_)` with a more helpful message. Still, for a lot of\nquick-and-dirty code, `unwrap` is a good choice, which is why this lint is\n`Allow` by default.\n\n`result.unwrap()` will let the thread panic on `Err` values.\nNormally, you want to implement more sophisticated error handling,\nand propagate errors upwards with `?` operator.\n\nEven if you want to panic on errors, not all `Error`s implement good\nmessages on display. Therefore, it may be beneficial to look at the places\nwhere they may get displayed. Activate this lint to do just that.",
      "example": "```no_run\n# let option = Some(1);\n# let result: Result<usize, ()> = Ok(1);\noption.unwrap();\nresult.unwrap();\n```\n\nUse instead:\n```no_run\n# let option = Some(1);\n# let result: Result<usize, ()> = Ok(1);\noption.expect(\"more helpful message\");\nresult.expect(\"more helpful message\");\n```\n\nIf [expect_used](#expect_used) is enabled, instead:\n```rust,ignore\n# let option = Some(1);\n# let result: Result<usize, ()> = Ok(1);\noption?;\n\n// or\n\nresult?;\n```",
      "version": "1.45.0",
      "source_file": "mod.rs",
      "embedding_text": "using `.unwrap()` on `Result` or `Option`, which should at least get a better message using `expect()`\n\nChecks for `.unwrap()` or `.unwrap_err()` calls on `Result`s and `.unwrap()` call on `Option`s.\n\nIt is better to handle the `None` or `Err` case,\nor at least call `.expect(_)` with a more helpful message. Still, for a lot of\nquick-and-dirty code, `unwrap` is a good choice, which is why this lint is\n`Allow` by default.\n\n`result.unwrap()` will let the thread panic on `Err` values.\nNormally, you want to implement more sophisticated error handling,\nand propagate errors upwards with `?` operator.\n\nEven if you want to panic on errors, not all `Error`s implement good\nmessages on display. Therefore, it may be beneficial to look at the places\nwhere they may get displayed. Activate this lint to do just that."
    },
    {
      "id": "clippy::unnecessary_literal_unwrap",
      "name": "UNNECESSARY_LITERAL_UNWRAP",
      "snake_name": "unnecessary_literal_unwrap",
      "category": "complexity",
      "weight": 1.0,
      "brief": "using `unwrap()` related calls on `Result` and `Option` constructors",
      "what_it_does": "Checks for `.unwrap()` related calls on `Result`s and `Option`s that are constructed.",
      "why_bad": "It is better to write the value directly without the indirection.",
      "example": "```no_run\nlet val1 = Some(1).unwrap();\nlet val2 = Ok::<_, ()>(1).unwrap();\nlet val3 = Err::<(), _>(1).unwrap_err();\n```\n\nUse instead:\n```no_run\nlet val1 = 1;\nlet val2 = 1;\nlet val3 = 1;\n```",
      "version": "1.72.0",
      "source_file": "mod.rs",
      "embedding_text": "using `unwrap()` related calls on `Result` and `Option` constructors\n\nChecks for `.unwrap()` related calls on `Result`s and `Option`s that are constructed.\n\nIt is better to write the value directly without the indirection."
    },
    {
      "id": "clippy::expect_used",
      "name": "EXPECT_USED",
      "snake_name": "expect_used",
      "category": "restriction",
      "weight": 1.0,
      "brief": "using `.expect()` on `Result` or `Option`, which might be better handled",
      "what_it_does": "Checks for `.expect()` or `.expect_err()` calls on `Result`s and `.expect()` call on `Option`s.",
      "why_bad": "Usually it is better to handle the `None` or `Err` case.\nStill, for a lot of quick-and-dirty code, `expect` is a good choice, which is why\nthis lint is `Allow` by default.\n\n`result.expect()` will let the thread panic on `Err`\nvalues. Normally, you want to implement more sophisticated error handling,\nand propagate errors upwards with `?` operator.",
      "example": "```rust,ignore\n# let option = Some(1);\n# let result: Result<usize, ()> = Ok(1);\noption.expect(\"one\");\nresult.expect(\"one\");\n```\n\nUse instead:\n```rust,ignore\n# let option = Some(1);\n# let result: Result<usize, ()> = Ok(1);\noption?;\n\n// or\n\nresult?;\n```",
      "version": "1.45.0",
      "source_file": "mod.rs",
      "embedding_text": "using `.expect()` on `Result` or `Option`, which might be better handled\n\nChecks for `.expect()` or `.expect_err()` calls on `Result`s and `.expect()` call on `Option`s.\n\nUsually it is better to handle the `None` or `Err` case.\nStill, for a lot of quick-and-dirty code, `expect` is a good choice, which is why\nthis lint is `Allow` by default.\n\n`result.expect()` will let the thread panic on `Err`\nvalues. Normally, you want to implement more sophisticated error handling,\nand propagate errors upwards with `?` operator."
    },
    {
      "id": "clippy::should_implement_trait",
      "name": "SHOULD_IMPLEMENT_TRAIT",
      "snake_name": "should_implement_trait",
      "category": "style",
      "weight": 0.95,
      "brief": "defining a method that should be implementing a std trait",
      "what_it_does": "Checks for methods that should live in a trait\nimplementation of a `std` trait (see [llogiq's blog\npost](http://llogiq.github.io/2015/07/30/traits.html) for further\ninformation) instead of an inherent implementation.",
      "why_bad": "Implementing the traits improve ergonomics for users of\nthe code, often with very little cost. Also people seeing a `mul(...)`\nmethod\nmay expect `*` to work equally, so you should have good reason to disappoint\nthem.",
      "example": "```no_run\nstruct X;\nimpl X {\nfn add(&self, other: &X) -> X {\n// ..\n# X\n}\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "defining a method that should be implementing a std trait\n\nChecks for methods that should live in a trait\nimplementation of a `std` trait (see [llogiq's blog\npost](http://llogiq.github.io/2015/07/30/traits.html) for further\ninformation) instead of an inherent implementation.\n\nImplementing the traits improve ergonomics for users of\nthe code, often with very little cost. Also people seeing a `mul(...)`\nmethod\nmay expect `*` to work equally, so you should have good reason to disappoint\nthem."
    },
    {
      "id": "clippy::wrong_self_convention",
      "name": "WRONG_SELF_CONVENTION",
      "snake_name": "wrong_self_convention",
      "category": "style",
      "weight": 0.95,
      "brief": "defining a method named with an established prefix (like \\",
      "what_it_does": "Checks for methods with certain name prefixes or suffixes, and which\ndo not adhere to standard conventions regarding how `self` is taken.\nThe actual rules are:\n\n|Prefix |Postfix     |`self` taken                   | `self` type  |\n|-------|------------|-------------------------------|--------------|\n|`as_`  | none       |`&self` or `&mut self`         | any          |\n|`from_`| none       | none                          | any          |\n|`into_`| none       |`self`                         | any          |\n|`is_`  | none       |`&mut self` or `&self` or none | any          |\n|`to_`  | `_mut`     |`&mut self`                    | any          |\n|`to_`  | not `_mut` |`self`                         | `Copy`       |\n|`to_`  | not `_mut` |`&self`                        | not `Copy`   |\n\nNote: Clippy doesn't trigger methods with `to_` prefix in:\n- Traits definition.\nClippy can not tell if a type that implements a trait is `Copy` or not.\n- Traits implementation, when `&self` is taken.\nThe method signature is controlled by the trait and often `&self` is required for all types that implement the trait\n(see e.g. the `std::string::ToString` trait).\n\nClippy allows `Pin<&Self>` and `Pin<&mut Self>` if `&self` and `&mut self` is required.\n\nPlease find more info here:\nhttps://rust-lang.github.io/api-guidelines/naming.html#ad-hoc-conversions-follow-as_-to_-into_-conventions-c-conv",
      "why_bad": "Consistency breeds readability. If you follow the\nconventions, your users won't be surprised that they, e.g., need to supply a\nmutable reference to a `as_..` function.",
      "example": "```no_run\n# struct X;\nimpl X {\nfn as_str(self) -> &'static str {\n// ..\n# \"\"\n}\n}\n```\n\nUse instead:\n```no_run\n# struct X;\nimpl X {\nfn as_str(&self) -> &'static str {\n// ..\n# \"\"\n}\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "defining a method named with an established prefix (like \\\n\nChecks for methods with certain name prefixes or suffixes, and which\ndo not adhere to standard conventions regarding how `self` is taken.\nThe actual rules are:\n\n|Prefix |Postfix     |`self` taken                   | `self` type  |\n|-------|------------|-------------------------------|--------------|\n|`as_`  | none       |`&self` or `&mut self`         | any          |\n|`from_`| none       | none                          | any          |\n|`into_`| none       |`self`                         | any          |\n|`is_`  | none       |`&mut self` or `&self` or none | any          |\n|`to_`  | `_mut`     |`&mut self`                    | any          |\n|`to_`  | not `_mut` |`self`                         | `Copy`       |\n|`to_`  | not `_mut` |`&self`                        | not `Copy`   |\n\nNote: Clippy doesn't trigger methods with `to_` prefix in:\n- Traits definition.\nClippy can not tell if a type that implements a trait is `Copy` or not.\n- Traits implementation, when `&self` is taken.\nThe method signature is controlled by the trait and often `&self` is required for all types that implement the trait\n(see e.g. the `std::string::ToString` trait).\n\nClippy allows `Pin<&Self>` and `Pin<&mut Self>` if `&self` and `&mut self` is required.\n\nPlease find more info here:\nhttps://rust-lang.github.io/api-guidelines/naming.html#ad-hoc-conversions-follow-as_-to_-into_-conventions-c-conv\n\nConsistency breeds readability. If you follow the\nconventions, your users won't be surprised that they, e.g., need to supply a\nmutable reference to a `as_..` function."
    },
    {
      "id": "clippy::ok_expect",
      "name": "OK_EXPECT",
      "snake_name": "ok_expect",
      "category": "style",
      "weight": 0.95,
      "brief": "using `ok().expect()`, which gives worse error messages than calling `expect` directly on the Result",
      "what_it_does": "Checks for usage of `ok().expect(..)`.\n\nNote: This lint only triggers for code marked compatible\nwith versions of the compiler older than Rust 1.82.0.",
      "why_bad": "Because you usually call `expect()` on the `Result`\ndirectly to get a better error message.",
      "example": "```no_run\n# let x = Ok::<_, ()>(());\nx.ok().expect(\"why did I do this again?\");\n```\n\nUse instead:\n```no_run\n# let x = Ok::<_, ()>(());\nx.expect(\"why did I do this again?\");\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "using `ok().expect()`, which gives worse error messages than calling `expect` directly on the Result\n\nChecks for usage of `ok().expect(..)`.\n\nNote: This lint only triggers for code marked compatible\nwith versions of the compiler older than Rust 1.82.0.\n\nBecause you usually call `expect()` on the `Result`\ndirectly to get a better error message."
    },
    {
      "id": "clippy::unwrap_or_default",
      "name": "UNWRAP_OR_DEFAULT",
      "snake_name": "unwrap_or_default",
      "category": "style",
      "weight": 0.95,
      "brief": "using `.unwrap_or`, etc. with an argument that constructs a default value",
      "what_it_does": "Checks for usages of the following functions with an argument that constructs a default value\n(e.g., `Default::default` or `String::new`):\n- `unwrap_or`\n- `unwrap_or_else`\n- `or_insert`\n- `or_insert_with`",
      "why_bad": "Readability. Using `unwrap_or_default` in place of `unwrap_or`/`unwrap_or_else`, or `or_default`\nin place of `or_insert`/`or_insert_with`, is simpler and more concise.",
      "example": "```no_run\n# let x = Some(1);\n# let mut map = std::collections::HashMap::<u64, String>::new();\nx.unwrap_or(Default::default());\nmap.entry(42).or_insert_with(String::new);\n```\n\nUse instead:\n```no_run\n# let x = Some(1);\n# let mut map = std::collections::HashMap::<u64, String>::new();\nx.unwrap_or_default();\nmap.entry(42).or_default();\n```",
      "version": "1.56.0",
      "source_file": "mod.rs",
      "embedding_text": "using `.unwrap_or`, etc. with an argument that constructs a default value\n\nChecks for usages of the following functions with an argument that constructs a default value\n(e.g., `Default::default` or `String::new`):\n- `unwrap_or`\n- `unwrap_or_else`\n- `or_insert`\n- `or_insert_with`\n\nReadability. Using `unwrap_or_default` in place of `unwrap_or`/`unwrap_or_else`, or `or_default`\nin place of `or_insert`/`or_insert_with`, is simpler and more concise."
    },
    {
      "id": "clippy::map_unwrap_or",
      "name": "MAP_UNWRAP_OR",
      "snake_name": "map_unwrap_or",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "using `.map(f).unwrap_or(a)` or `.map(f).unwrap_or_else(func)`, which are more succinctly expressed as `map_or(a, f)` or `map_or_else(a, f)`",
      "what_it_does": "Checks for usage of `option.map(_).unwrap_or(_)` or `option.map(_).unwrap_or_else(_)` or\n`result.map(_).unwrap_or_else(_)`.",
      "why_bad": "Readability, these can be written more concisely (resp.) as\n`option.map_or(_, _)`, `option.map_or_else(_, _)` and `result.map_or_else(_, _)`.",
      "example": "```no_run\n# let option = Some(1);\n# let result: Result<usize, ()> = Ok(1);\n# fn some_function(foo: ()) -> usize { 1 }\noption.map(|a| a + 1).unwrap_or(0);\noption.map(|a| a > 10).unwrap_or(false);\nresult.map(|a| a + 1).unwrap_or_else(some_function);\n```\n\nUse instead:\n```no_run\n# let option = Some(1);\n# let result: Result<usize, ()> = Ok(1);\n# fn some_function(foo: ()) -> usize { 1 }\noption.map_or(0, |a| a + 1);\noption.is_some_and(|a| a > 10);\nresult.map_or_else(some_function, |a| a + 1);\n```",
      "version": "1.45.0",
      "source_file": "mod.rs",
      "embedding_text": "using `.map(f).unwrap_or(a)` or `.map(f).unwrap_or_else(func)`, which are more succinctly expressed as `map_or(a, f)` or `map_or_else(a, f)`\n\nChecks for usage of `option.map(_).unwrap_or(_)` or `option.map(_).unwrap_or_else(_)` or\n`result.map(_).unwrap_or_else(_)`.\n\nReadability, these can be written more concisely (resp.) as\n`option.map_or(_, _)`, `option.map_or_else(_, _)` and `result.map_or_else(_, _)`."
    },
    {
      "id": "clippy::option_map_or_none",
      "name": "OPTION_MAP_OR_NONE",
      "snake_name": "option_map_or_none",
      "category": "style",
      "weight": 0.95,
      "brief": "using `Option.map_or(None, f)`, which is more succinctly expressed as `and_then(f)`",
      "what_it_does": "Checks for usage of `_.map_or(None, _)`.",
      "why_bad": "Readability, this can be written more concisely as\n`_.and_then(_)`.",
      "example": "```no_run\n# let opt = Some(1);\nopt.map_or(None, |a| Some(a + 1));\n```\n\nUse instead:\n```no_run\n# let opt = Some(1);\nopt.and_then(|a| Some(a + 1));\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "using `Option.map_or(None, f)`, which is more succinctly expressed as `and_then(f)`\n\nChecks for usage of `_.map_or(None, _)`.\n\nReadability, this can be written more concisely as\n`_.and_then(_)`."
    },
    {
      "id": "clippy::result_map_or_into_option",
      "name": "RESULT_MAP_OR_INTO_OPTION",
      "snake_name": "result_map_or_into_option",
      "category": "style",
      "weight": 0.95,
      "brief": "using `Result.map_or(None, Some)`, which is more succinctly expressed as `ok()`",
      "what_it_does": "Checks for usage of `_.map_or(None, Some)`.",
      "why_bad": "Readability, this can be written more concisely as\n`_.ok()`.",
      "example": "```no_run\n# let r: Result<u32, &str> = Ok(1);\nassert_eq!(Some(1), r.map_or(None, Some));\n```\n\nUse instead:\n```no_run\n# let r: Result<u32, &str> = Ok(1);\nassert_eq!(Some(1), r.ok());\n```",
      "version": "1.44.0",
      "source_file": "mod.rs",
      "embedding_text": "using `Result.map_or(None, Some)`, which is more succinctly expressed as `ok()`\n\nChecks for usage of `_.map_or(None, Some)`.\n\nReadability, this can be written more concisely as\n`_.ok()`."
    },
    {
      "id": "clippy::bind_instead_of_map",
      "name": "BIND_INSTEAD_OF_MAP",
      "snake_name": "bind_instead_of_map",
      "category": "complexity",
      "weight": 1.0,
      "brief": "using `Option.and_then(|x| Some(y))`, which is more succinctly expressed as `map(|x| y)`",
      "what_it_does": "Checks for usage of `_.and_then(|x| Some(y))`, `_.and_then(|x| Ok(y))`\nor `_.or_else(|x| Err(y))`.",
      "why_bad": "This can be written more concisely as `_.map(|x| y)` or `_.map_err(|x| y)`.",
      "example": "```no_run\n# fn opt() -> Option<&'static str> { Some(\"42\") }\n# fn res() -> Result<&'static str, &'static str> { Ok(\"42\") }\nlet _ = opt().and_then(|s| Some(s.len()));\nlet _ = res().and_then(|s| if s.len() == 42 { Ok(10) } else { Ok(20) });\nlet _ = res().or_else(|s| if s.len() == 42 { Err(10) } else { Err(20) });\n```\n\nThe correct use would be:\n\n```no_run\n# fn opt() -> Option<&'static str> { Some(\"42\") }\n# fn res() -> Result<&'static str, &'static str> { Ok(\"42\") }\nlet _ = opt().map(|s| s.len());\nlet _ = res().map(|s| if s.len() == 42 { 10 } else { 20 });\nlet _ = res().map_err(|s| if s.len() == 42 { 10 } else { 20 });\n```",
      "version": "1.45.0",
      "source_file": "mod.rs",
      "embedding_text": "using `Option.and_then(|x| Some(y))`, which is more succinctly expressed as `map(|x| y)`\n\nChecks for usage of `_.and_then(|x| Some(y))`, `_.and_then(|x| Ok(y))`\nor `_.or_else(|x| Err(y))`.\n\nThis can be written more concisely as `_.map(|x| y)` or `_.map_err(|x| y)`."
    },
    {
      "id": "clippy::filter_next",
      "name": "FILTER_NEXT",
      "snake_name": "filter_next",
      "category": "complexity",
      "weight": 1.0,
      "brief": "using `filter(p).next()`, which is more succinctly expressed as `.find(p)`",
      "what_it_does": "Checks for usage of `_.filter(_).next()`.",
      "why_bad": "Readability, this can be written more concisely as\n`_.find(_)`.",
      "example": "```no_run\n# let vec = vec![1];\nvec.iter().filter(|x| **x == 0).next();\n```\n\nUse instead:\n```no_run\n# let vec = vec![1];\nvec.iter().find(|x| **x == 0);\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "using `filter(p).next()`, which is more succinctly expressed as `.find(p)`\n\nChecks for usage of `_.filter(_).next()`.\n\nReadability, this can be written more concisely as\n`_.find(_)`."
    },
    {
      "id": "clippy::skip_while_next",
      "name": "SKIP_WHILE_NEXT",
      "snake_name": "skip_while_next",
      "category": "complexity",
      "weight": 1.0,
      "brief": "using `skip_while(p).next()`, which is more succinctly expressed as `.find(!p)`",
      "what_it_does": "Checks for usage of `_.skip_while(condition).next()`.",
      "why_bad": "Readability, this can be written more concisely as\n`_.find(!condition)`.",
      "example": "```no_run\n# let vec = vec![1];\nvec.iter().skip_while(|x| **x == 0).next();\n```\n\nUse instead:\n```no_run\n# let vec = vec![1];\nvec.iter().find(|x| **x != 0);\n```",
      "version": "1.42.0",
      "source_file": "mod.rs",
      "embedding_text": "using `skip_while(p).next()`, which is more succinctly expressed as `.find(!p)`\n\nChecks for usage of `_.skip_while(condition).next()`.\n\nReadability, this can be written more concisely as\n`_.find(!condition)`."
    },
    {
      "id": "clippy::map_flatten",
      "name": "MAP_FLATTEN",
      "snake_name": "map_flatten",
      "category": "complexity",
      "weight": 1.0,
      "brief": "using combinations of `flatten` and `map` which can usually be written as a single method call",
      "what_it_does": "Checks for usage of `_.map(_).flatten(_)` on `Iterator` and `Option`",
      "why_bad": "Readability, this can be written more concisely as\n`_.flat_map(_)` for `Iterator` or `_.and_then(_)` for `Option`",
      "example": "```no_run\nlet vec = vec![vec![1]];\nlet opt = Some(5);\n\nvec.iter().map(|x| x.iter()).flatten();\nopt.map(|x| Some(x * 2)).flatten();\n```\n\nUse instead:\n```no_run\n# let vec = vec![vec![1]];\n# let opt = Some(5);\nvec.iter().flat_map(|x| x.iter());\nopt.and_then(|x| Some(x * 2));\n```",
      "version": "1.31.0",
      "source_file": "mod.rs",
      "embedding_text": "using combinations of `flatten` and `map` which can usually be written as a single method call\n\nChecks for usage of `_.map(_).flatten(_)` on `Iterator` and `Option`\n\nReadability, this can be written more concisely as\n`_.flat_map(_)` for `Iterator` or `_.and_then(_)` for `Option`"
    },
    {
      "id": "clippy::manual_filter_map",
      "name": "MANUAL_FILTER_MAP",
      "snake_name": "manual_filter_map",
      "category": "complexity",
      "weight": 1.0,
      "brief": "using `_.filter(_).map(_)` in a way that can be written more simply as `filter_map(_)`",
      "what_it_does": "Checks for usage of `_.filter(_).map(_)` that can be written more simply\nas `filter_map(_)`.",
      "why_bad": "Redundant code in the `filter` and `map` operations is poor style and\nless performant.",
      "example": "```no_run\n(0_i32..10)\n.filter(|n| n.checked_add(1).is_some())\n.map(|n| n.checked_add(1).unwrap());\n```\n\nUse instead:\n```no_run\n(0_i32..10).filter_map(|n| n.checked_add(1));\n```",
      "version": "1.51.0",
      "source_file": "mod.rs",
      "embedding_text": "using `_.filter(_).map(_)` in a way that can be written more simply as `filter_map(_)`\n\nChecks for usage of `_.filter(_).map(_)` that can be written more simply\nas `filter_map(_)`.\n\nRedundant code in the `filter` and `map` operations is poor style and\nless performant."
    },
    {
      "id": "clippy::manual_find_map",
      "name": "MANUAL_FIND_MAP",
      "snake_name": "manual_find_map",
      "category": "complexity",
      "weight": 1.0,
      "brief": "using `_.find(_).map(_)` in a way that can be written more simply as `find_map(_)`",
      "what_it_does": "Checks for usage of `_.find(_).map(_)` that can be written more simply\nas `find_map(_)`.",
      "why_bad": "Redundant code in the `find` and `map` operations is poor style and\nless performant.",
      "example": "```no_run\n(0_i32..10)\n.find(|n| n.checked_add(1).is_some())\n.map(|n| n.checked_add(1).unwrap());\n```\n\nUse instead:\n```no_run\n(0_i32..10).find_map(|n| n.checked_add(1));\n```",
      "version": "1.51.0",
      "source_file": "mod.rs",
      "embedding_text": "using `_.find(_).map(_)` in a way that can be written more simply as `find_map(_)`\n\nChecks for usage of `_.find(_).map(_)` that can be written more simply\nas `find_map(_)`.\n\nRedundant code in the `find` and `map` operations is poor style and\nless performant."
    },
    {
      "id": "clippy::filter_map_next",
      "name": "FILTER_MAP_NEXT",
      "snake_name": "filter_map_next",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "using combination of `filter_map` and `next` which can usually be written as a single method call",
      "what_it_does": "Checks for usage of `_.filter_map(_).next()`.",
      "why_bad": "Readability, this can be written more concisely as\n`_.find_map(_)`.",
      "example": "```no_run\n(0..3).filter_map(|x| if x == 2 { Some(x) } else { None }).next();\n```\nCan be written as\n\n```no_run\n(0..3).find_map(|x| if x == 2 { Some(x) } else { None });\n```",
      "version": "1.36.0",
      "source_file": "mod.rs",
      "embedding_text": "using combination of `filter_map` and `next` which can usually be written as a single method call\n\nChecks for usage of `_.filter_map(_).next()`.\n\nReadability, this can be written more concisely as\n`_.find_map(_)`."
    },
    {
      "id": "clippy::flat_map_identity",
      "name": "FLAT_MAP_IDENTITY",
      "snake_name": "flat_map_identity",
      "category": "complexity",
      "weight": 1.0,
      "brief": "call to `flat_map` where `flatten` is sufficient",
      "what_it_does": "Checks for usage of `flat_map(|x| x)`.",
      "why_bad": "Readability, this can be written more concisely by using `flatten`.",
      "example": "```no_run\n# let iter = vec![vec![0]].into_iter();\niter.flat_map(|x| x);\n```\nCan be written as\n```no_run\n# let iter = vec![vec![0]].into_iter();\niter.flatten();\n```",
      "version": "1.39.0",
      "source_file": "mod.rs",
      "embedding_text": "call to `flat_map` where `flatten` is sufficient\n\nChecks for usage of `flat_map(|x| x)`.\n\nReadability, this can be written more concisely by using `flatten`."
    },
    {
      "id": "clippy::search_is_some",
      "name": "SEARCH_IS_SOME",
      "snake_name": "search_is_some",
      "category": "nursery",
      "weight": 0.9,
      "brief": "using an iterator or string search followed by `is_some()` or `is_none()`, which is more succinctly expressed as a call to `any()` or `contains()` (with negation in case of `is_none()`)",
      "what_it_does": "Checks for an iterator or string search (such as `find()`,\n`position()`, or `rposition()`) followed by a call to `is_some()` or `is_none()`.",
      "why_bad": "Readability, this can be written more concisely as:\n* `_.any(_)`, or `_.contains(_)` for `is_some()`,\n* `!_.any(_)`, or `!_.contains(_)` for `is_none()`.",
      "example": "```no_run\nlet vec = vec![1];\nvec.iter().find(|x| **x == 0).is_some();\n\n\"hello world\".find(\"world\").is_none();\n```\n\nUse instead:\n```no_run\nlet vec = vec![1];\nvec.iter().any(|x| *x == 0);\n\n!\"hello world\".contains(\"world\");\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "using an iterator or string search followed by `is_some()` or `is_none()`, which is more succinctly expressed as a call to `any()` or `contains()` (with negation in case of `is_none()`)\n\nChecks for an iterator or string search (such as `find()`,\n`position()`, or `rposition()`) followed by a call to `is_some()` or `is_none()`.\n\nReadability, this can be written more concisely as:\n* `_.any(_)`, or `_.contains(_)` for `is_some()`,\n* `!_.any(_)`, or `!_.contains(_)` for `is_none()`."
    },
    {
      "id": "clippy::chars_next_cmp",
      "name": "CHARS_NEXT_CMP",
      "snake_name": "chars_next_cmp",
      "category": "style",
      "weight": 0.95,
      "brief": "using `.chars().next()` to check if a string starts with a char",
      "what_it_does": "Checks for usage of `.chars().next()` on a `str` to check\nif it starts with a given char.",
      "why_bad": "Readability, this can be written more concisely as\n`_.starts_with(_)`.",
      "example": "```no_run\nlet name = \"foo\";\nif name.chars().next() == Some('_') {};\n```\n\nUse instead:\n```no_run\nlet name = \"foo\";\nif name.starts_with('_') {};\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "using `.chars().next()` to check if a string starts with a char\n\nChecks for usage of `.chars().next()` on a `str` to check\nif it starts with a given char.\n\nReadability, this can be written more concisely as\n`_.starts_with(_)`."
    },
    {
      "id": "clippy::or_fun_call",
      "name": "OR_FUN_CALL",
      "snake_name": "or_fun_call",
      "category": "nursery",
      "weight": 0.9,
      "brief": "using any `*or` method with a function call, which suggests `*or_else`",
      "what_it_does": "Checks for calls to `.or(foo(..))`, `.unwrap_or(foo(..))`,\n`.or_insert(foo(..))` etc., and suggests to use `.or_else(|| foo(..))`,\n`.unwrap_or_else(|| foo(..))`, `.unwrap_or_default()` or `.or_default()`\netc. instead.",
      "why_bad": "The function will always be called. This is only bad if it allocates or\ndoes some non-trivial amount of work.",
      "example": "```no_run\n# let foo = Some(String::new());\nfoo.unwrap_or(String::from(\"empty\"));\n```\n\nUse instead:\n```no_run\n# let foo = Some(String::new());\nfoo.unwrap_or_else(|| String::from(\"empty\"));\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "using any `*or` method with a function call, which suggests `*or_else`\n\nChecks for calls to `.or(foo(..))`, `.unwrap_or(foo(..))`,\n`.or_insert(foo(..))` etc., and suggests to use `.or_else(|| foo(..))`,\n`.unwrap_or_else(|| foo(..))`, `.unwrap_or_default()` or `.or_default()`\netc. instead.\n\nThe function will always be called. This is only bad if it allocates or\ndoes some non-trivial amount of work."
    },
    {
      "id": "clippy::or_then_unwrap",
      "name": "OR_THEN_UNWRAP",
      "snake_name": "or_then_unwrap",
      "category": "complexity",
      "weight": 1.0,
      "brief": "checks for `.or(\u2026).unwrap()` calls to Options and Results.",
      "what_it_does": "Checks for `.or(\u2026).unwrap()` calls to Options and Results.",
      "why_bad": "You should use `.unwrap_or(\u2026)` instead for clarity.",
      "example": "```no_run\n# let fallback = \"fallback\";\n// Result\n# type Error = &'static str;\n# let result: Result<&str, Error> = Err(\"error\");\nlet value = result.or::<Error>(Ok(fallback)).unwrap();\n\n// Option\n# let option: Option<&str> = None;\nlet value = option.or(Some(fallback)).unwrap();\n```\nUse instead:\n```no_run\n# let fallback = \"fallback\";\n// Result\n# let result: Result<&str, &str> = Err(\"error\");\nlet value = result.unwrap_or(fallback);\n\n// Option\n# let option: Option<&str> = None;\nlet value = option.unwrap_or(fallback);\n```",
      "version": "1.61.0",
      "source_file": "mod.rs",
      "embedding_text": "checks for `.or(\u2026).unwrap()` calls to Options and Results.\n\nChecks for `.or(\u2026).unwrap()` calls to Options and Results.\n\nYou should use `.unwrap_or(\u2026)` instead for clarity."
    },
    {
      "id": "clippy::expect_fun_call",
      "name": "EXPECT_FUN_CALL",
      "snake_name": "expect_fun_call",
      "category": "perf",
      "weight": 1.0,
      "brief": "using any `expect` method with a function call",
      "what_it_does": "Checks for calls to `.expect(&format!(...))`, `.expect(foo(..))`,\netc., and suggests to use `unwrap_or_else` instead",
      "why_bad": "The function will always be called.",
      "example": "```no_run\n# let foo = Some(String::new());\n# let err_code = \"418\";\n# let err_msg = \"I'm a teapot\";\nfoo.expect(&format!(\"Err {}: {}\", err_code, err_msg));\n\n// or\n\n# let foo = Some(String::new());\nfoo.expect(format!(\"Err {}: {}\", err_code, err_msg).as_str());\n```\n\nUse instead:\n```no_run\n# let foo = Some(String::new());\n# let err_code = \"418\";\n# let err_msg = \"I'm a teapot\";\nfoo.unwrap_or_else(|| panic!(\"Err {}: {}\", err_code, err_msg));\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "using any `expect` method with a function call\n\nChecks for calls to `.expect(&format!(...))`, `.expect(foo(..))`,\netc., and suggests to use `unwrap_or_else` instead\n\nThe function will always be called."
    },
    {
      "id": "clippy::clone_on_copy",
      "name": "CLONE_ON_COPY",
      "snake_name": "clone_on_copy",
      "category": "complexity",
      "weight": 1.0,
      "brief": "using `clone` on a `Copy` type",
      "what_it_does": "Checks for usage of `.clone()` on a `Copy` type.",
      "why_bad": "The only reason `Copy` types implement `Clone` is for\ngenerics, not for using the `clone` method on a concrete type.",
      "example": "```no_run\n42u64.clone();\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "using `clone` on a `Copy` type\n\nChecks for usage of `.clone()` on a `Copy` type.\n\nThe only reason `Copy` types implement `Clone` is for\ngenerics, not for using the `clone` method on a concrete type."
    },
    {
      "id": "clippy::clone_on_ref_ptr",
      "name": "CLONE_ON_REF_PTR",
      "snake_name": "clone_on_ref_ptr",
      "category": "restriction",
      "weight": 1.0,
      "brief": "using `clone` on a ref-counted pointer",
      "what_it_does": "Checks for usage of `.clone()` on a ref-counted pointer,\n(`Rc`, `Arc`, `rc::Weak`, or `sync::Weak`), and suggests calling Clone via unified\nfunction syntax instead (e.g., `Rc::clone(foo)`).",
      "why_bad": "Calling `.clone()` on an `Rc`, `Arc`, or `Weak`\ncan obscure the fact that only the pointer is being cloned, not the underlying\ndata.",
      "example": "```no_run\n# use std::rc::Rc;\nlet x = Rc::new(1);\n\nx.clone();\n```\n\nUse instead:\n```no_run\n# use std::rc::Rc;\n# let x = Rc::new(1);\nRc::clone(&x);\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "using `clone` on a ref-counted pointer\n\nChecks for usage of `.clone()` on a ref-counted pointer,\n(`Rc`, `Arc`, `rc::Weak`, or `sync::Weak`), and suggests calling Clone via unified\nfunction syntax instead (e.g., `Rc::clone(foo)`).\n\nCalling `.clone()` on an `Rc`, `Arc`, or `Weak`\ncan obscure the fact that only the pointer is being cloned, not the underlying\ndata."
    },
    {
      "id": "clippy::inefficient_to_string",
      "name": "INEFFICIENT_TO_STRING",
      "snake_name": "inefficient_to_string",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "using `to_string` on `&&T` where `T: ToString`",
      "what_it_does": "Checks for usage of `.to_string()` on an `&&T` where\n`T` implements `ToString` directly (like `&&str` or `&&String`).",
      "why_bad": "In versions of the compiler before Rust 1.82.0, this bypasses the specialized\nimplementation of `ToString` and instead goes through the more expensive string\nformatting facilities.",
      "example": "```no_run\n// Generic implementation for `T: Display` is used (slow)\n[\"foo\", \"bar\"].iter().map(|s| s.to_string());\n\n// OK, the specialized impl is used\n[\"foo\", \"bar\"].iter().map(|&s| s.to_string());\n```",
      "version": "1.40.0",
      "source_file": "mod.rs",
      "embedding_text": "using `to_string` on `&&T` where `T: ToString`\n\nChecks for usage of `.to_string()` on an `&&T` where\n`T` implements `ToString` directly (like `&&str` or `&&String`).\n\nIn versions of the compiler before Rust 1.82.0, this bypasses the specialized\nimplementation of `ToString` and instead goes through the more expensive string\nformatting facilities."
    },
    {
      "id": "clippy::new_ret_no_self",
      "name": "NEW_RET_NO_SELF",
      "snake_name": "new_ret_no_self",
      "category": "style",
      "weight": 0.95,
      "brief": "not returning type containing `Self` in a `new` method",
      "what_it_does": "Checks for `new` not returning a type that contains `Self`.",
      "why_bad": "As a convention, `new` methods are used to make a new\ninstance of a type.",
      "example": "In an impl block:\n```no_run\n# struct Foo;\n# struct NotAFoo;\nimpl Foo {\nfn new() -> NotAFoo {\n# NotAFoo\n}\n}\n```\n\n```no_run\n# struct Foo;\nstruct Bar(Foo);\nimpl Foo {\n// Bad. The type name must contain `Self`\nfn new() -> Bar {\n# Bar(Foo)\n}\n}\n```\n\n```no_run\n# struct Foo;\n# struct FooError;\nimpl Foo {\n// Good. Return type contains `Self`\nfn new() -> Result<Foo, FooError> {\n# Ok(Foo)\n}\n}\n```\n\nOr in a trait definition:\n```no_run\npub trait Trait {\n// Bad. The type name must contain `Self`\nfn new();\n}\n```\n\n```no_run\npub trait Trait {\n// Good. Return type contains `Self`\nfn new() -> Self;\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "not returning type containing `Self` in a `new` method\n\nChecks for `new` not returning a type that contains `Self`.\n\nAs a convention, `new` methods are used to make a new\ninstance of a type."
    },
    {
      "id": "clippy::iterator_step_by_zero",
      "name": "ITERATOR_STEP_BY_ZERO",
      "snake_name": "iterator_step_by_zero",
      "category": "correctness",
      "weight": 1.2,
      "brief": "using `Iterator::step_by(0)`, which will panic at runtime",
      "what_it_does": "Checks for calling `.step_by(0)` on iterators which panics.",
      "why_bad": "This very much looks like an oversight. Use `panic!()` instead if you\nactually intend to panic.",
      "example": "```rust,should_panic\nfor x in (0..100).step_by(0) {\n//..\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "using `Iterator::step_by(0)`, which will panic at runtime\n\nChecks for calling `.step_by(0)` on iterators which panics.\n\nThis very much looks like an oversight. Use `panic!()` instead if you\nactually intend to panic."
    },
    {
      "id": "clippy::option_filter_map",
      "name": "OPTION_FILTER_MAP",
      "snake_name": "option_filter_map",
      "category": "complexity",
      "weight": 1.0,
      "brief": "filtering `Option` for `Some` then force-unwrapping, which can be one type-safe operation",
      "what_it_does": "Checks for iterators of `Option`s using `.filter(Option::is_some).map(Option::unwrap)` that may\nbe replaced with a `.flatten()` call.",
      "why_bad": "`Option` is like a collection of 0-1 things, so `flatten`\nautomatically does this without suspicious-looking `unwrap` calls.",
      "example": "```no_run\nlet _ = std::iter::empty::<Option<i32>>().filter(Option::is_some).map(Option::unwrap);\n```\nUse instead:\n```no_run\nlet _ = std::iter::empty::<Option<i32>>().flatten();\n```",
      "version": "1.53.0",
      "source_file": "mod.rs",
      "embedding_text": "filtering `Option` for `Some` then force-unwrapping, which can be one type-safe operation\n\nChecks for iterators of `Option`s using `.filter(Option::is_some).map(Option::unwrap)` that may\nbe replaced with a `.flatten()` call.\n\n`Option` is like a collection of 0-1 things, so `flatten`\nautomatically does this without suspicious-looking `unwrap` calls."
    },
    {
      "id": "clippy::iter_nth_zero",
      "name": "ITER_NTH_ZERO",
      "snake_name": "iter_nth_zero",
      "category": "style",
      "weight": 0.95,
      "brief": "replace `iter.nth(0)` with `iter.next()`",
      "what_it_does": "Checks for the use of `iter.nth(0)`.",
      "why_bad": "`iter.next()` is equivalent to\n`iter.nth(0)`, as they both consume the next element,\nbut is more readable.",
      "example": "```no_run\n# use std::collections::HashSet;\n# let mut s = HashSet::new();\n# s.insert(1);\nlet x = s.iter().nth(0);\n```\n\nUse instead:\n```no_run\n# use std::collections::HashSet;\n# let mut s = HashSet::new();\n# s.insert(1);\nlet x = s.iter().next();\n```",
      "version": "1.42.0",
      "source_file": "mod.rs",
      "embedding_text": "replace `iter.nth(0)` with `iter.next()`\n\nChecks for the use of `iter.nth(0)`.\n\n`iter.next()` is equivalent to\n`iter.nth(0)`, as they both consume the next element,\nbut is more readable."
    },
    {
      "id": "clippy::iter_nth",
      "name": "ITER_NTH",
      "snake_name": "iter_nth",
      "category": "style",
      "weight": 0.95,
      "brief": "using `.iter().nth()` on a standard library type with O(1) element access",
      "what_it_does": "Checks for usage of `.iter().nth()`/`.iter_mut().nth()` on standard library types that have\nequivalent `.get()`/`.get_mut()` methods.",
      "why_bad": "`.get()` and `.get_mut()` are equivalent but more concise.",
      "example": "```no_run\nlet some_vec = vec![0, 1, 2, 3];\nlet bad_vec = some_vec.iter().nth(3);\nlet bad_slice = &some_vec[..].iter().nth(3);\n```\nThe correct use would be:\n```no_run\nlet some_vec = vec![0, 1, 2, 3];\nlet bad_vec = some_vec.get(3);\nlet bad_slice = &some_vec[..].get(3);\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "using `.iter().nth()` on a standard library type with O(1) element access\n\nChecks for usage of `.iter().nth()`/`.iter_mut().nth()` on standard library types that have\nequivalent `.get()`/`.get_mut()` methods.\n\n`.get()` and `.get_mut()` are equivalent but more concise."
    },
    {
      "id": "clippy::iter_skip_next",
      "name": "ITER_SKIP_NEXT",
      "snake_name": "iter_skip_next",
      "category": "style",
      "weight": 0.95,
      "brief": "using `.skip(x).next()` on an iterator",
      "what_it_does": "Checks for usage of `.skip(x).next()` on iterators.",
      "why_bad": "`.nth(x)` is cleaner",
      "example": "```no_run\nlet some_vec = vec![0, 1, 2, 3];\nlet bad_vec = some_vec.iter().skip(3).next();\nlet bad_slice = &some_vec[..].iter().skip(3).next();\n```\nThe correct use would be:\n```no_run\nlet some_vec = vec![0, 1, 2, 3];\nlet bad_vec = some_vec.iter().nth(3);\nlet bad_slice = &some_vec[..].iter().nth(3);\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "using `.skip(x).next()` on an iterator\n\nChecks for usage of `.skip(x).next()` on iterators.\n\n`.nth(x)` is cleaner"
    },
    {
      "id": "clippy::iter_with_drain",
      "name": "ITER_WITH_DRAIN",
      "snake_name": "iter_with_drain",
      "category": "nursery",
      "weight": 0.9,
      "brief": "replace `.drain(..)` with `.into_iter()`",
      "what_it_does": "Checks for usage of `.drain(..)` on `Vec` and `VecDeque` for iteration.",
      "why_bad": "`.into_iter()` is simpler with better performance.",
      "example": "```no_run\n# use std::collections::HashSet;\nlet mut foo = vec![0, 1, 2, 3];\nlet bar: HashSet<usize> = foo.drain(..).collect();\n```\nUse instead:\n```no_run\n# use std::collections::HashSet;\nlet foo = vec![0, 1, 2, 3];\nlet bar: HashSet<usize> = foo.into_iter().collect();\n```",
      "version": "1.61.0",
      "source_file": "mod.rs",
      "embedding_text": "replace `.drain(..)` with `.into_iter()`\n\nChecks for usage of `.drain(..)` on `Vec` and `VecDeque` for iteration.\n\n`.into_iter()` is simpler with better performance."
    },
    {
      "id": "clippy::get_last_with_len",
      "name": "GET_LAST_WITH_LEN",
      "snake_name": "get_last_with_len",
      "category": "complexity",
      "weight": 1.0,
      "brief": "Using `x.get(x.len() - 1)` when `x.last()` is correct and simpler",
      "what_it_does": "Checks for usage of `x.get(x.len() - 1)` instead of\n`x.last()`.",
      "why_bad": "Using `x.last()` is easier to read and has the same\nresult.\n\nNote that using `x[x.len() - 1]` is semantically different from\n`x.last()`.  Indexing into the array will panic on out-of-bounds\naccesses, while `x.get()` and `x.last()` will return `None`.\n\nThere is another lint (get_unwrap) that covers the case of using\n`x.get(index).unwrap()` instead of `x[index]`.",
      "example": "```no_run\nlet x = vec![2, 3, 5];\nlet last_element = x.get(x.len() - 1);\n```\n\nUse instead:\n```no_run\nlet x = vec![2, 3, 5];\nlet last_element = x.last();\n```",
      "version": "1.37.0",
      "source_file": "mod.rs",
      "embedding_text": "Using `x.get(x.len() - 1)` when `x.last()` is correct and simpler\n\nChecks for usage of `x.get(x.len() - 1)` instead of\n`x.last()`.\n\nUsing `x.last()` is easier to read and has the same\nresult.\n\nNote that using `x[x.len() - 1]` is semantically different from\n`x.last()`.  Indexing into the array will panic on out-of-bounds\naccesses, while `x.get()` and `x.last()` will return `None`.\n\nThere is another lint (get_unwrap) that covers the case of using\n`x.get(index).unwrap()` instead of `x[index]`."
    },
    {
      "id": "clippy::get_unwrap",
      "name": "GET_UNWRAP",
      "snake_name": "get_unwrap",
      "category": "restriction",
      "weight": 1.0,
      "brief": "using `.get().unwrap()` or `.get_mut().unwrap()` when using `[]` would work instead",
      "what_it_does": "Checks for usage of `.get().unwrap()` (or\n`.get_mut().unwrap`) on a standard library type which implements `Index`",
      "why_bad": "Using the Index trait (`[]`) is more clear and more\nconcise.",
      "example": "```no_run\nlet mut some_vec = vec![0, 1, 2, 3];\nlet last = some_vec.get(3).unwrap();\n*some_vec.get_mut(0).unwrap() = 1;\n```\nThe correct use would be:\n```no_run\nlet mut some_vec = vec![0, 1, 2, 3];\nlet last = some_vec[3];\nsome_vec[0] = 1;\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "using `.get().unwrap()` or `.get_mut().unwrap()` when using `[]` would work instead\n\nChecks for usage of `.get().unwrap()` (or\n`.get_mut().unwrap`) on a standard library type which implements `Index`\n\nUsing the Index trait (`[]`) is more clear and more\nconcise."
    },
    {
      "id": "clippy::extend_with_drain",
      "name": "EXTEND_WITH_DRAIN",
      "snake_name": "extend_with_drain",
      "category": "perf",
      "weight": 1.0,
      "brief": "using vec.append(&mut vec) to move the full range of a vector to another",
      "what_it_does": "Checks for occurrences where one vector gets extended instead of append",
      "why_bad": "Using `append` instead of `extend` is more concise and faster",
      "example": "```no_run\nlet mut a = vec![1, 2, 3];\nlet mut b = vec![4, 5, 6];\n\na.extend(b.drain(..));\n```\n\nUse instead:\n```no_run\nlet mut a = vec![1, 2, 3];\nlet mut b = vec![4, 5, 6];\n\na.append(&mut b);\n```",
      "version": "1.55.0",
      "source_file": "mod.rs",
      "embedding_text": "using vec.append(&mut vec) to move the full range of a vector to another\n\nChecks for occurrences where one vector gets extended instead of append\n\nUsing `append` instead of `extend` is more concise and faster"
    },
    {
      "id": "clippy::string_extend_chars",
      "name": "STRING_EXTEND_CHARS",
      "snake_name": "string_extend_chars",
      "category": "style",
      "weight": 0.95,
      "brief": "using `x.extend(s.chars())` where s is a `&str` or `String`",
      "what_it_does": "Checks for the use of `.extend(s.chars())` where s is a\n`&str` or `String`.",
      "why_bad": "`.push_str(s)` is clearer",
      "example": "```no_run\nlet abc = \"abc\";\nlet def = String::from(\"def\");\nlet mut s = String::new();\ns.extend(abc.chars());\ns.extend(def.chars());\n```\nThe correct use would be:\n```no_run\nlet abc = \"abc\";\nlet def = String::from(\"def\");\nlet mut s = String::new();\ns.push_str(abc);\ns.push_str(&def);\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "using `x.extend(s.chars())` where s is a `&str` or `String`\n\nChecks for the use of `.extend(s.chars())` where s is a\n`&str` or `String`.\n\n`.push_str(s)` is clearer"
    },
    {
      "id": "clippy::iter_cloned_collect",
      "name": "ITER_CLONED_COLLECT",
      "snake_name": "iter_cloned_collect",
      "category": "style",
      "weight": 0.95,
      "brief": "using `.cloned().collect()` on slice to create a `Vec`",
      "what_it_does": "Checks for the use of `.cloned().collect()` on slice to\ncreate a `Vec`.",
      "why_bad": "`.to_vec()` is clearer",
      "example": "```no_run\nlet s = [1, 2, 3, 4, 5];\nlet s2: Vec<isize> = s[..].iter().cloned().collect();\n```\nThe better use would be:\n```no_run\nlet s = [1, 2, 3, 4, 5];\nlet s2: Vec<isize> = s.to_vec();\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "using `.cloned().collect()` on slice to create a `Vec`\n\nChecks for the use of `.cloned().collect()` on slice to\ncreate a `Vec`.\n\n`.to_vec()` is clearer"
    },
    {
      "id": "clippy::chars_last_cmp",
      "name": "CHARS_LAST_CMP",
      "snake_name": "chars_last_cmp",
      "category": "style",
      "weight": 0.95,
      "brief": "using `.chars().last()` or `.chars().next_back()` to check if a string ends with a char",
      "what_it_does": "Checks for usage of `_.chars().last()` or\n`_.chars().next_back()` on a `str` to check if it ends with a given char.",
      "why_bad": "Readability, this can be written more concisely as\n`_.ends_with(_)`.",
      "example": "```no_run\n# let name = \"_\";\nname.chars().last() == Some('_') || name.chars().next_back() == Some('-');\n```\n\nUse instead:\n```no_run\n# let name = \"_\";\nname.ends_with('_') || name.ends_with('-');\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "using `.chars().last()` or `.chars().next_back()` to check if a string ends with a char\n\nChecks for usage of `_.chars().last()` or\n`_.chars().next_back()` on a `str` to check if it ends with a given char.\n\nReadability, this can be written more concisely as\n`_.ends_with(_)`."
    },
    {
      "id": "clippy::useless_asref",
      "name": "USELESS_ASREF",
      "snake_name": "useless_asref",
      "category": "complexity",
      "weight": 1.0,
      "brief": "using `as_ref` where the types before and after the call are the same",
      "what_it_does": "Checks for usage of `.as_ref()` or `.as_mut()` where the\ntypes before and after the call are the same.",
      "why_bad": "The call is unnecessary.",
      "example": "```no_run\n# fn do_stuff(x: &[i32]) {}\nlet x: &[i32] = &[1, 2, 3, 4, 5];\ndo_stuff(x.as_ref());\n```\nThe correct use would be:\n```no_run\n# fn do_stuff(x: &[i32]) {}\nlet x: &[i32] = &[1, 2, 3, 4, 5];\ndo_stuff(x);\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "using `as_ref` where the types before and after the call are the same\n\nChecks for usage of `.as_ref()` or `.as_mut()` where the\ntypes before and after the call are the same.\n\nThe call is unnecessary."
    },
    {
      "id": "clippy::unnecessary_fold",
      "name": "UNNECESSARY_FOLD",
      "snake_name": "unnecessary_fold",
      "category": "style",
      "weight": 0.95,
      "brief": "using `fold` when a more succinct alternative exists",
      "what_it_does": "Checks for usage of `fold` when a more succinct alternative exists.\nSpecifically, this checks for `fold`s which could be replaced by `any`, `all`,\n`sum` or `product`.",
      "why_bad": "Readability.",
      "example": "```no_run\n(0..3).fold(false, |acc, x| acc || x > 2);\n```\n\nUse instead:\n```no_run\n(0..3).any(|x| x > 2);\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "using `fold` when a more succinct alternative exists\n\nChecks for usage of `fold` when a more succinct alternative exists.\nSpecifically, this checks for `fold`s which could be replaced by `any`, `all`,\n`sum` or `product`.\n\nReadability."
    },
    {
      "id": "clippy::unnecessary_filter_map",
      "name": "UNNECESSARY_FILTER_MAP",
      "snake_name": "unnecessary_filter_map",
      "category": "complexity",
      "weight": 1.0,
      "brief": "using `filter_map` when a more succinct alternative exists",
      "what_it_does": "Checks for `filter_map` calls that could be replaced by `filter` or `map`.\nMore specifically it checks if the closure provided is only performing one of the\nfilter or map operations and suggests the appropriate option.",
      "why_bad": "Complexity. The intent is also clearer if only a single\noperation is being performed.",
      "example": "```no_run\nlet _ = (0..3).filter_map(|x| if x > 2 { Some(x) } else { None });\n\n// As there is no transformation of the argument this could be written as:\nlet _ = (0..3).filter(|&x| x > 2);\n```\n\n```no_run\nlet _ = (0..4).filter_map(|x| Some(x + 1));\n\n// As there is no conditional check on the argument this could be written as:\nlet _ = (0..4).map(|x| x + 1);\n```",
      "version": "1.31.0",
      "source_file": "mod.rs",
      "embedding_text": "using `filter_map` when a more succinct alternative exists\n\nChecks for `filter_map` calls that could be replaced by `filter` or `map`.\nMore specifically it checks if the closure provided is only performing one of the\nfilter or map operations and suggests the appropriate option.\n\nComplexity. The intent is also clearer if only a single\noperation is being performed."
    },
    {
      "id": "clippy::unnecessary_find_map",
      "name": "UNNECESSARY_FIND_MAP",
      "snake_name": "unnecessary_find_map",
      "category": "complexity",
      "weight": 1.0,
      "brief": "using `find_map` when a more succinct alternative exists",
      "what_it_does": "Checks for `find_map` calls that could be replaced by `find` or `map`. More\nspecifically it checks if the closure provided is only performing one of the\nfind or map operations and suggests the appropriate option.",
      "why_bad": "Complexity. The intent is also clearer if only a single\noperation is being performed.",
      "example": "```no_run\nlet _ = (0..3).find_map(|x| if x > 2 { Some(x) } else { None });\n\n// As there is no transformation of the argument this could be written as:\nlet _ = (0..3).find(|&x| x > 2);\n```\n\n```no_run\nlet _ = (0..4).find_map(|x| Some(x + 1));\n\n// As there is no conditional check on the argument this could be written as:\nlet _ = (0..4).map(|x| x + 1).next();\n```",
      "version": "1.61.0",
      "source_file": "mod.rs",
      "embedding_text": "using `find_map` when a more succinct alternative exists\n\nChecks for `find_map` calls that could be replaced by `find` or `map`. More\nspecifically it checks if the closure provided is only performing one of the\nfind or map operations and suggests the appropriate option.\n\nComplexity. The intent is also clearer if only a single\noperation is being performed."
    },
    {
      "id": "clippy::into_iter_on_ref",
      "name": "INTO_ITER_ON_REF",
      "snake_name": "into_iter_on_ref",
      "category": "style",
      "weight": 0.95,
      "brief": "using `.into_iter()` on a reference",
      "what_it_does": "Checks for `into_iter` calls on references which should be replaced by `iter`\nor `iter_mut`.",
      "why_bad": "Readability. Calling `into_iter` on a reference will not move out its\ncontent into the resulting iterator, which is confusing. It is better just call `iter` or\n`iter_mut` directly.",
      "example": "```no_run\n# let vec = vec![3, 4, 5];\n(&vec).into_iter();\n```\n\nUse instead:\n```no_run\n# let vec = vec![3, 4, 5];\n(&vec).iter();\n```",
      "version": "1.32.0",
      "source_file": "mod.rs",
      "embedding_text": "using `.into_iter()` on a reference\n\nChecks for `into_iter` calls on references which should be replaced by `iter`\nor `iter_mut`.\n\nReadability. Calling `into_iter` on a reference will not move out its\ncontent into the resulting iterator, which is confusing. It is better just call `iter` or\n`iter_mut` directly."
    },
    {
      "id": "clippy::suspicious_map",
      "name": "SUSPICIOUS_MAP",
      "snake_name": "suspicious_map",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "suspicious usage of map",
      "what_it_does": "Checks for calls to `map` followed by a `count`.",
      "why_bad": "It looks suspicious. Maybe `map` was confused with `filter`.\nIf the `map` call is intentional, this should be rewritten\nusing `inspect`. Or, if you intend to drive the iterator to\ncompletion, you can just use `for_each` instead.",
      "example": "```no_run\nlet _ = (0..3).map(|x| x + 2).count();\n```",
      "version": "1.39.0",
      "source_file": "mod.rs",
      "embedding_text": "suspicious usage of map\n\nChecks for calls to `map` followed by a `count`.\n\nIt looks suspicious. Maybe `map` was confused with `filter`.\nIf the `map` call is intentional, this should be rewritten\nusing `inspect`. Or, if you intend to drive the iterator to\ncompletion, you can just use `for_each` instead."
    },
    {
      "id": "clippy::uninit_assumed_init",
      "name": "UNINIT_ASSUMED_INIT",
      "snake_name": "uninit_assumed_init",
      "category": "correctness",
      "weight": 1.2,
      "brief": "`MaybeUninit::uninit().assume_init()`",
      "what_it_does": "Checks for `MaybeUninit::uninit().assume_init()`.",
      "why_bad": "For most types, this is undefined behavior.",
      "example": "```no_run\n// Beware the UB\nuse std::mem::MaybeUninit;\n\nlet _: usize = unsafe { MaybeUninit::uninit().assume_init() };\n```\n\nNote that the following is OK:\n\n```no_run\nuse std::mem::MaybeUninit;\n\nlet _: [MaybeUninit<bool>; 5] = unsafe {\nMaybeUninit::uninit().assume_init()\n};\n```",
      "version": "1.39.0",
      "source_file": "mod.rs",
      "embedding_text": "`MaybeUninit::uninit().assume_init()`\n\nChecks for `MaybeUninit::uninit().assume_init()`.\n\nFor most types, this is undefined behavior."
    },
    {
      "id": "clippy::manual_saturating_arithmetic",
      "name": "MANUAL_SATURATING_ARITHMETIC",
      "snake_name": "manual_saturating_arithmetic",
      "category": "style",
      "weight": 0.95,
      "brief": "`.checked_add/sub(x).unwrap_or(MAX/MIN)`",
      "what_it_does": "Checks for `.checked_add/sub(x).unwrap_or(MAX/MIN)`.",
      "why_bad": "These can be written simply with `saturating_add/sub` methods.",
      "example": "```no_run\n# let y: u32 = 0;\n# let x: u32 = 100;\nlet add = x.checked_add(y).unwrap_or(u32::MAX);\nlet sub = x.checked_sub(y).unwrap_or(u32::MIN);\n```\n\ncan be written using dedicated methods for saturating addition/subtraction as:\n\n```no_run\n# let y: u32 = 0;\n# let x: u32 = 100;\nlet add = x.saturating_add(y);\nlet sub = x.saturating_sub(y);\n```",
      "version": "1.39.0",
      "source_file": "mod.rs",
      "embedding_text": "`.checked_add/sub(x).unwrap_or(MAX/MIN)`\n\nChecks for `.checked_add/sub(x).unwrap_or(MAX/MIN)`.\n\nThese can be written simply with `saturating_add/sub` methods."
    },
    {
      "id": "clippy::zst_offset",
      "name": "ZST_OFFSET",
      "snake_name": "zst_offset",
      "category": "correctness",
      "weight": 1.2,
      "brief": "Check for offset calculations on raw pointers to zero-sized types",
      "what_it_does": "Checks for `offset(_)`, `wrapping_`{`add`, `sub`}, etc. on raw pointers to\nzero-sized types",
      "why_bad": "This is a no-op, and likely unintended",
      "example": "```no_run\nunsafe { (&() as *const ()).offset(1) };\n```",
      "version": "1.41.0",
      "source_file": "mod.rs",
      "embedding_text": "Check for offset calculations on raw pointers to zero-sized types\n\nChecks for `offset(_)`, `wrapping_`{`add`, `sub`}, etc. on raw pointers to\nzero-sized types\n\nThis is a no-op, and likely unintended"
    },
    {
      "id": "clippy::ptr_offset_by_literal",
      "name": "PTR_OFFSET_BY_LITERAL",
      "snake_name": "ptr_offset_by_literal",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "unneeded pointer offset",
      "what_it_does": "Checks for usage of the `offset` pointer method with an integer\nliteral.",
      "why_bad": "The `add` and `sub` methods more accurately express the intent.",
      "example": "```no_run\nlet vec = vec![b'a', b'b', b'c'];\nlet ptr = vec.as_ptr();\n\nunsafe {\nptr.offset(-8);\n}\n```\n\nCould be written:\n\n```no_run\nlet vec = vec![b'a', b'b', b'c'];\nlet ptr = vec.as_ptr();\n\nunsafe {\nptr.sub(8);\n}\n```",
      "version": "1.92.0",
      "source_file": "mod.rs",
      "embedding_text": "unneeded pointer offset\n\nChecks for usage of the `offset` pointer method with an integer\nliteral.\n\nThe `add` and `sub` methods more accurately express the intent."
    },
    {
      "id": "clippy::ptr_offset_with_cast",
      "name": "PTR_OFFSET_WITH_CAST",
      "snake_name": "ptr_offset_with_cast",
      "category": "complexity",
      "weight": 1.0,
      "brief": "unneeded pointer offset cast",
      "what_it_does": "Checks for usage of the `offset` pointer method with a `usize` casted to an\n`isize`.",
      "why_bad": "If we\u2019re always increasing the pointer address, we can avoid the numeric\ncast by using the `add` method instead.",
      "example": "```no_run\nlet vec = vec![b'a', b'b', b'c'];\nlet ptr = vec.as_ptr();\nlet offset = 1_usize;\n\nunsafe {\nptr.offset(offset as isize);\n}\n```\n\nCould be written:\n\n```no_run\nlet vec = vec![b'a', b'b', b'c'];\nlet ptr = vec.as_ptr();\nlet offset = 1_usize;\n\nunsafe {\nptr.add(offset);\n}\n```",
      "version": "1.30.0",
      "source_file": "mod.rs",
      "embedding_text": "unneeded pointer offset cast\n\nChecks for usage of the `offset` pointer method with a `usize` casted to an\n`isize`.\n\nIf we\u2019re always increasing the pointer address, we can avoid the numeric\ncast by using the `add` method instead."
    },
    {
      "id": "clippy::filetype_is_file",
      "name": "FILETYPE_IS_FILE",
      "snake_name": "filetype_is_file",
      "category": "restriction",
      "weight": 1.0,
      "brief": "`FileType::is_file` is not recommended to test for readable file type",
      "what_it_does": "Checks for `FileType::is_file()`.",
      "why_bad": "When people testing a file type with `FileType::is_file`\nthey are testing whether a path is something they can get bytes from. But\n`is_file` doesn't cover special file types in unix-like systems, and doesn't cover\nsymlink in windows. Using `!FileType::is_dir()` is a better way to that intention.",
      "example": "```no_run\n# || {\nlet metadata = std::fs::metadata(\"foo.txt\")?;\nlet filetype = metadata.file_type();\n\nif filetype.is_file() {\n// read file\n}\n# Ok::<_, std::io::Error>(())\n# };\n```\n\nshould be written as:\n\n```no_run\n# || {\nlet metadata = std::fs::metadata(\"foo.txt\")?;\nlet filetype = metadata.file_type();\n\nif !filetype.is_dir() {\n// read file\n}\n# Ok::<_, std::io::Error>(())\n# };\n```",
      "version": "1.42.0",
      "source_file": "mod.rs",
      "embedding_text": "`FileType::is_file` is not recommended to test for readable file type\n\nChecks for `FileType::is_file()`.\n\nWhen people testing a file type with `FileType::is_file`\nthey are testing whether a path is something they can get bytes from. But\n`is_file` doesn't cover special file types in unix-like systems, and doesn't cover\nsymlink in windows. Using `!FileType::is_dir()` is a better way to that intention."
    },
    {
      "id": "clippy::option_as_ref_deref",
      "name": "OPTION_AS_REF_DEREF",
      "snake_name": "option_as_ref_deref",
      "category": "complexity",
      "weight": 1.0,
      "brief": "using `as_ref().map(Deref::deref)`, which is more succinctly expressed as `as_deref()`",
      "what_it_does": "Checks for usage of `_.as_ref().map(Deref::deref)` or its aliases (such as String::as_str).",
      "why_bad": "Readability, this can be written more concisely as\n`_.as_deref()`.",
      "example": "```no_run\n# let opt = Some(\"\".to_string());\nopt.as_ref().map(String::as_str)\n# ;\n```\nCan be written as\n```no_run\n# let opt = Some(\"\".to_string());\nopt.as_deref()\n# ;\n```",
      "version": "1.42.0",
      "source_file": "mod.rs",
      "embedding_text": "using `as_ref().map(Deref::deref)`, which is more succinctly expressed as `as_deref()`\n\nChecks for usage of `_.as_ref().map(Deref::deref)` or its aliases (such as String::as_str).\n\nReadability, this can be written more concisely as\n`_.as_deref()`."
    },
    {
      "id": "clippy::iter_next_slice",
      "name": "ITER_NEXT_SLICE",
      "snake_name": "iter_next_slice",
      "category": "style",
      "weight": 0.95,
      "brief": "using `.iter().next()` on a sliced array, which can be shortened to just `.get()`",
      "what_it_does": "Checks for usage of `iter().next()` on a Slice or an Array",
      "why_bad": "These can be shortened into `.get()`",
      "example": "```no_run\n# let a = [1, 2, 3];\n# let b = vec![1, 2, 3];\na[2..].iter().next();\nb.iter().next();\n```\nshould be written as:\n```no_run\n# let a = [1, 2, 3];\n# let b = vec![1, 2, 3];\na.get(2);\nb.get(0);\n```",
      "version": "1.46.0",
      "source_file": "mod.rs",
      "embedding_text": "using `.iter().next()` on a sliced array, which can be shortened to just `.get()`\n\nChecks for usage of `iter().next()` on a Slice or an Array\n\nThese can be shortened into `.get()`"
    },
    {
      "id": "clippy::single_char_add_str",
      "name": "SINGLE_CHAR_ADD_STR",
      "snake_name": "single_char_add_str",
      "category": "style",
      "weight": 0.95,
      "brief": "`push_str()` or `insert_str()` used with a single-character string literal as parameter",
      "what_it_does": "Warns when using `push_str`/`insert_str` with a single-character string literal\nwhere `push`/`insert` with a `char` would work fine.",
      "why_bad": "It's less clear that we are pushing a single character.",
      "example": "```no_run\n# let mut string = String::new();\nstring.insert_str(0, \"R\");\nstring.push_str(\"R\");\n```\n\nUse instead:\n```no_run\n# let mut string = String::new();\nstring.insert(0, 'R');\nstring.push('R');\n```",
      "version": "1.49.0",
      "source_file": "mod.rs",
      "embedding_text": "`push_str()` or `insert_str()` used with a single-character string literal as parameter\n\nWarns when using `push_str`/`insert_str` with a single-character string literal\nwhere `push`/`insert` with a `char` would work fine.\n\nIt's less clear that we are pushing a single character."
    },
    {
      "id": "clippy::unnecessary_lazy_evaluations",
      "name": "UNNECESSARY_LAZY_EVALUATIONS",
      "snake_name": "unnecessary_lazy_evaluations",
      "category": "style",
      "weight": 0.95,
      "brief": "using unnecessary lazy evaluation, which can be replaced with simpler eager evaluation",
      "what_it_does": "As the counterpart to `or_fun_call`, this lint looks for unnecessary\nlazily evaluated closures on `Option` and `Result`.\n\nThis lint suggests changing the following functions, when eager evaluation results in\nsimpler code:\n- `unwrap_or_else` to `unwrap_or`\n- `and_then` to `and`\n- `or_else` to `or`\n- `get_or_insert_with` to `get_or_insert`\n- `ok_or_else` to `ok_or`\n- `then` to `then_some` (for msrv >= 1.62.0)",
      "why_bad": "Using eager evaluation is shorter and simpler in some cases.",
      "example": "```no_run\nlet opt: Option<u32> = None;\n\nopt.unwrap_or_else(|| 42);\n```\nUse instead:\n```no_run\nlet opt: Option<u32> = None;\n\nopt.unwrap_or(42);\n```",
      "version": "1.48.0",
      "source_file": "mod.rs",
      "embedding_text": "using unnecessary lazy evaluation, which can be replaced with simpler eager evaluation\n\nAs the counterpart to `or_fun_call`, this lint looks for unnecessary\nlazily evaluated closures on `Option` and `Result`.\n\nThis lint suggests changing the following functions, when eager evaluation results in\nsimpler code:\n- `unwrap_or_else` to `unwrap_or`\n- `and_then` to `and`\n- `or_else` to `or`\n- `get_or_insert_with` to `get_or_insert`\n- `ok_or_else` to `ok_or`\n- `then` to `then_some` (for msrv >= 1.62.0)\n\nUsing eager evaluation is shorter and simpler in some cases."
    },
    {
      "id": "clippy::map_collect_result_unit",
      "name": "MAP_COLLECT_RESULT_UNIT",
      "snake_name": "map_collect_result_unit",
      "category": "style",
      "weight": 0.95,
      "brief": "using `.map(_).collect::<Result<(),_>()`, which can be replaced with `try_for_each`",
      "what_it_does": "Checks for usage of `_.map(_).collect::<Result<(), _>()`.",
      "why_bad": "Using `try_for_each` instead is more readable and idiomatic.",
      "example": "```no_run\n(0..3).map(|t| Err(t)).collect::<Result<(), _>>();\n```\nUse instead:\n```no_run\n(0..3).try_for_each(|t| Err(t));\n```",
      "version": "1.49.0",
      "source_file": "mod.rs",
      "embedding_text": "using `.map(_).collect::<Result<(),_>()`, which can be replaced with `try_for_each`\n\nChecks for usage of `_.map(_).collect::<Result<(), _>()`.\n\nUsing `try_for_each` instead is more readable and idiomatic."
    },
    {
      "id": "clippy::from_iter_instead_of_collect",
      "name": "FROM_ITER_INSTEAD_OF_COLLECT",
      "snake_name": "from_iter_instead_of_collect",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "use `.collect()` instead of `::from_iter()`",
      "what_it_does": "Checks for `from_iter()` function calls on types that implement the `FromIterator`\ntrait.",
      "why_bad": "If it's needed to create a collection from the contents of an iterator, the `Iterator::collect(_)`\nmethod is preferred. However, when it's needed to specify the container type,\n`Vec::from_iter(_)` can be more readable than using a turbofish (e.g. `_.collect::<Vec<_>>()`). See\n[FromIterator documentation](https://doc.rust-lang.org/std/iter/trait.FromIterator.html)",
      "example": "```no_run\nlet five_fives = std::iter::repeat(5).take(5);\n\nlet v = Vec::from_iter(five_fives);\n\nassert_eq!(v, vec![5, 5, 5, 5, 5]);\n```\nUse instead:\n```no_run\nlet five_fives = std::iter::repeat(5).take(5);\n\nlet v: Vec<i32> = five_fives.collect();\n\nassert_eq!(v, vec![5, 5, 5, 5, 5]);\n```\nbut prefer to use\n```no_run\nlet numbers: Vec<i32> = FromIterator::from_iter(1..=5);\n```\ninstead of\n```no_run\nlet numbers = (1..=5).collect::<Vec<_>>();\n```",
      "version": "1.49.0",
      "source_file": "mod.rs",
      "embedding_text": "use `.collect()` instead of `::from_iter()`\n\nChecks for `from_iter()` function calls on types that implement the `FromIterator`\ntrait.\n\nIf it's needed to create a collection from the contents of an iterator, the `Iterator::collect(_)`\nmethod is preferred. However, when it's needed to specify the container type,\n`Vec::from_iter(_)` can be more readable than using a turbofish (e.g. `_.collect::<Vec<_>>()`). See\n[FromIterator documentation](https://doc.rust-lang.org/std/iter/trait.FromIterator.html)"
    },
    {
      "id": "clippy::inspect_for_each",
      "name": "INSPECT_FOR_EACH",
      "snake_name": "inspect_for_each",
      "category": "complexity",
      "weight": 1.0,
      "brief": "using `.inspect().for_each()`, which can be replaced with `.for_each()`",
      "what_it_does": "Checks for usage of `inspect().for_each()`.",
      "why_bad": "It is the same as performing the computation\ninside `inspect` at the beginning of the closure in `for_each`.",
      "example": "```no_run\n[1,2,3,4,5].iter()\n.inspect(|&x| println!(\"inspect the number: {}\", x))\n.for_each(|&x| {\nassert!(x >= 0);\n});\n```\nCan be written as\n```no_run\n[1,2,3,4,5].iter()\n.for_each(|&x| {\nprintln!(\"inspect the number: {}\", x);\nassert!(x >= 0);\n});\n```",
      "version": "1.51.0",
      "source_file": "mod.rs",
      "embedding_text": "using `.inspect().for_each()`, which can be replaced with `.for_each()`\n\nChecks for usage of `inspect().for_each()`.\n\nIt is the same as performing the computation\ninside `inspect` at the beginning of the closure in `for_each`."
    },
    {
      "id": "clippy::filter_map_identity",
      "name": "FILTER_MAP_IDENTITY",
      "snake_name": "filter_map_identity",
      "category": "complexity",
      "weight": 1.0,
      "brief": "call to `filter_map` where `flatten` is sufficient",
      "what_it_does": "Checks for usage of `filter_map(|x| x)`.",
      "why_bad": "Readability, this can be written more concisely by using `flatten`.",
      "example": "```no_run\n# let iter = vec![Some(1)].into_iter();\niter.filter_map(|x| x);\n```\nUse instead:\n```no_run\n# let iter = vec![Some(1)].into_iter();\niter.flatten();\n```",
      "version": "1.52.0",
      "source_file": "mod.rs",
      "embedding_text": "call to `filter_map` where `flatten` is sufficient\n\nChecks for usage of `filter_map(|x| x)`.\n\nReadability, this can be written more concisely by using `flatten`."
    },
    {
      "id": "clippy::map_identity",
      "name": "MAP_IDENTITY",
      "snake_name": "map_identity",
      "category": "complexity",
      "weight": 1.0,
      "brief": "using iterator.map(|x| x)",
      "what_it_does": "Checks for instances of `map(f)` where `f` is the identity function.",
      "why_bad": "It can be written more concisely without the call to `map`.",
      "example": "```no_run\nlet x = [1, 2, 3];\nlet y: Vec<_> = x.iter().map(|x| x).map(|x| 2*x).collect();\n```\nUse instead:\n```no_run\nlet x = [1, 2, 3];\nlet y: Vec<_> = x.iter().map(|x| 2*x).collect();\n```",
      "version": "1.47.0",
      "source_file": "mod.rs",
      "embedding_text": "using iterator.map(|x| x)\n\nChecks for instances of `map(f)` where `f` is the identity function.\n\nIt can be written more concisely without the call to `map`."
    },
    {
      "id": "clippy::bytes_nth",
      "name": "BYTES_NTH",
      "snake_name": "bytes_nth",
      "category": "style",
      "weight": 0.95,
      "brief": "replace `.bytes().nth()` with `.as_bytes().get()`",
      "what_it_does": "Checks for the use of `.bytes().nth()`.",
      "why_bad": "`.as_bytes().get()` is more efficient and more\nreadable.",
      "example": "```no_run\n\"Hello\".bytes().nth(3);\n```\n\nUse instead:\n```no_run\n\"Hello\".as_bytes().get(3);\n```",
      "version": "1.52.0",
      "source_file": "mod.rs",
      "embedding_text": "replace `.bytes().nth()` with `.as_bytes().get()`\n\nChecks for the use of `.bytes().nth()`.\n\n`.as_bytes().get()` is more efficient and more\nreadable."
    },
    {
      "id": "clippy::implicit_clone",
      "name": "IMPLICIT_CLONE",
      "snake_name": "implicit_clone",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "implicitly cloning a value by invoking a function on its dereferenced type",
      "what_it_does": "Checks for the usage of `_.to_owned()`, `vec.to_vec()`, or similar when calling `_.clone()` would be clearer.",
      "why_bad": "These methods do the same thing as `_.clone()` but may be confusing as\nto why we are calling `to_vec` on something that is already a `Vec` or calling `to_owned` on something that is already owned.",
      "example": "```no_run\nlet a = vec![1, 2, 3];\nlet b = a.to_vec();\nlet c = a.to_owned();\n```\nUse instead:\n```no_run\nlet a = vec![1, 2, 3];\nlet b = a.clone();\nlet c = a.clone();\n```",
      "version": "1.52.0",
      "source_file": "mod.rs",
      "embedding_text": "implicitly cloning a value by invoking a function on its dereferenced type\n\nChecks for the usage of `_.to_owned()`, `vec.to_vec()`, or similar when calling `_.clone()` would be clearer.\n\nThese methods do the same thing as `_.clone()` but may be confusing as\nto why we are calling `to_vec` on something that is already a `Vec` or calling `to_owned` on something that is already owned."
    },
    {
      "id": "clippy::iter_count",
      "name": "ITER_COUNT",
      "snake_name": "iter_count",
      "category": "complexity",
      "weight": 1.0,
      "brief": "replace `.iter().count()` with `.len()`",
      "what_it_does": "Checks for the use of `.iter().count()`.",
      "why_bad": "`.len()` is more efficient and more\nreadable.",
      "example": "```no_run\nlet some_vec = vec![0, 1, 2, 3];\n\nsome_vec.iter().count();\n&some_vec[..].iter().count();\n```\n\nUse instead:\n```no_run\nlet some_vec = vec![0, 1, 2, 3];\n\nsome_vec.len();\n&some_vec[..].len();\n```",
      "version": "1.52.0",
      "source_file": "mod.rs",
      "embedding_text": "replace `.iter().count()` with `.len()`\n\nChecks for the use of `.iter().count()`.\n\n`.len()` is more efficient and more\nreadable."
    },
    {
      "id": "clippy::suspicious_to_owned",
      "name": "SUSPICIOUS_TO_OWNED",
      "snake_name": "suspicious_to_owned",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "calls to `to_owned` on a `Cow<'_, _>` might not do what they are expected",
      "what_it_does": "Checks for the usage of `_.to_owned()`, on a `Cow<'_, _>`.",
      "why_bad": "Calling `to_owned()` on a `Cow` creates a clone of the `Cow`\nitself, without taking ownership of the `Cow` contents (i.e.\nit's equivalent to calling `Cow::clone`).\nThe similarly named `into_owned` method, on the other hand,\nclones the `Cow` contents, effectively turning any `Cow::Borrowed`\ninto a `Cow::Owned`.\n\nGiven the potential ambiguity, consider replacing `to_owned`\nwith `clone` for better readability or, if getting a `Cow::Owned`\nwas the original intent, using `into_owned` instead.",
      "example": "```no_run\n# use std::borrow::Cow;\nlet s = \"Hello world!\";\nlet cow = Cow::Borrowed(s);\n\nlet data = cow.to_owned();\nassert!(matches!(data, Cow::Borrowed(_)))\n```\nUse instead:\n```no_run\n# use std::borrow::Cow;\nlet s = \"Hello world!\";\nlet cow = Cow::Borrowed(s);\n\nlet data = cow.clone();\nassert!(matches!(data, Cow::Borrowed(_)))\n```\nor\n```no_run\n# use std::borrow::Cow;\nlet s = \"Hello world!\";\nlet cow = Cow::Borrowed(s);\n\nlet _data: String = cow.into_owned();\n```",
      "version": "1.65.0",
      "source_file": "mod.rs",
      "embedding_text": "calls to `to_owned` on a `Cow<'_, _>` might not do what they are expected\n\nChecks for the usage of `_.to_owned()`, on a `Cow<'_, _>`.\n\nCalling `to_owned()` on a `Cow` creates a clone of the `Cow`\nitself, without taking ownership of the `Cow` contents (i.e.\nit's equivalent to calling `Cow::clone`).\nThe similarly named `into_owned` method, on the other hand,\nclones the `Cow` contents, effectively turning any `Cow::Borrowed`\ninto a `Cow::Owned`.\n\nGiven the potential ambiguity, consider replacing `to_owned`\nwith `clone` for better readability or, if getting a `Cow::Owned`\nwas the original intent, using `into_owned` instead."
    },
    {
      "id": "clippy::suspicious_splitn",
      "name": "SUSPICIOUS_SPLITN",
      "snake_name": "suspicious_splitn",
      "category": "correctness",
      "weight": 1.2,
      "brief": "checks for `.splitn(0, ..)` and `.splitn(1, ..)`",
      "what_it_does": "Checks for calls to [`splitn`]\n(https://doc.rust-lang.org/std/primitive.str.html#method.splitn) and\nrelated functions with either zero or one splits.",
      "why_bad": "These calls don't actually split the value and are\nlikely to be intended as a different number.",
      "example": "```no_run\n# let s = \"\";\nfor x in s.splitn(1, \":\") {\n// ..\n}\n```\n\nUse instead:\n```no_run\n# let s = \"\";\nfor x in s.splitn(2, \":\") {\n// ..\n}\n```",
      "version": "1.54.0",
      "source_file": "mod.rs",
      "embedding_text": "checks for `.splitn(0, ..)` and `.splitn(1, ..)`\n\nChecks for calls to [`splitn`]\n(https://doc.rust-lang.org/std/primitive.str.html#method.splitn) and\nrelated functions with either zero or one splits.\n\nThese calls don't actually split the value and are\nlikely to be intended as a different number."
    },
    {
      "id": "clippy::manual_str_repeat",
      "name": "MANUAL_STR_REPEAT",
      "snake_name": "manual_str_repeat",
      "category": "perf",
      "weight": 1.0,
      "brief": "manual implementation of `str::repeat`",
      "what_it_does": "Checks for manual implementations of `str::repeat`",
      "why_bad": "These are both harder to read, as well as less performant.",
      "example": "```no_run\nlet x: String = std::iter::repeat('x').take(10).collect();\n```\n\nUse instead:\n```no_run\nlet x: String = \"x\".repeat(10);\n```",
      "version": "1.54.0",
      "source_file": "mod.rs",
      "embedding_text": "manual implementation of `str::repeat`\n\nChecks for manual implementations of `str::repeat`\n\nThese are both harder to read, as well as less performant."
    },
    {
      "id": "clippy::manual_split_once",
      "name": "MANUAL_SPLIT_ONCE",
      "snake_name": "manual_split_once",
      "category": "complexity",
      "weight": 1.0,
      "brief": "replace `.splitn(2, pat)` with `.split_once(pat)`",
      "what_it_does": "Checks for usage of `str::splitn(2, _)`",
      "why_bad": "`split_once` is both clearer in intent and slightly more efficient.",
      "example": "```rust,ignore\nlet s = \"key=value=add\";\nlet (key, value) = s.splitn(2, '=').next_tuple()?;\nlet value = s.splitn(2, '=').nth(1)?;\n\nlet mut parts = s.splitn(2, '=');\nlet key = parts.next()?;\nlet value = parts.next()?;\n```\n\nUse instead:\n```rust,ignore\nlet s = \"key=value=add\";\nlet (key, value) = s.split_once('=')?;\nlet value = s.split_once('=')?.1;\n\nlet (key, value) = s.split_once('=')?;\n```",
      "version": "1.57.0",
      "source_file": "mod.rs",
      "embedding_text": "replace `.splitn(2, pat)` with `.split_once(pat)`\n\nChecks for usage of `str::splitn(2, _)`\n\n`split_once` is both clearer in intent and slightly more efficient."
    },
    {
      "id": "clippy::needless_splitn",
      "name": "NEEDLESS_SPLITN",
      "snake_name": "needless_splitn",
      "category": "complexity",
      "weight": 1.0,
      "brief": "usages of `str::splitn` that can be replaced with `str::split`",
      "what_it_does": "Checks for usage of `str::splitn` (or `str::rsplitn`) where using `str::split` would be the same.",
      "why_bad": "The function `split` is simpler and there is no performance difference in these cases, considering\nthat both functions return a lazy iterator.",
      "example": "```no_run\nlet str = \"key=value=add\";\nlet _ = str.splitn(3, '=').next().unwrap();\n```\n\nUse instead:\n```no_run\nlet str = \"key=value=add\";\nlet _ = str.split('=').next().unwrap();\n```",
      "version": "1.59.0",
      "source_file": "mod.rs",
      "embedding_text": "usages of `str::splitn` that can be replaced with `str::split`\n\nChecks for usage of `str::splitn` (or `str::rsplitn`) where using `str::split` would be the same.\n\nThe function `split` is simpler and there is no performance difference in these cases, considering\nthat both functions return a lazy iterator."
    },
    {
      "id": "clippy::unnecessary_to_owned",
      "name": "UNNECESSARY_TO_OWNED",
      "snake_name": "unnecessary_to_owned",
      "category": "perf",
      "weight": 1.0,
      "brief": "unnecessary calls to `to_owned`-like functions",
      "what_it_does": "Checks for unnecessary calls to [`ToOwned::to_owned`](https://doc.rust-lang.org/std/borrow/trait.ToOwned.html#tymethod.to_owned)\nand other `to_owned`-like functions.",
      "why_bad": "The unnecessary calls result in useless allocations.",
      "example": "```no_run\nlet path = std::path::Path::new(\"x\");\nfoo(&path.to_string_lossy().to_string());\nfn foo(s: &str) {}\n```\nUse instead:\n```no_run\nlet path = std::path::Path::new(\"x\");\nfoo(&path.to_string_lossy());\nfn foo(s: &str) {}\n```",
      "version": "1.59.0",
      "source_file": "mod.rs",
      "embedding_text": "unnecessary calls to `to_owned`-like functions\n\nChecks for unnecessary calls to [`ToOwned::to_owned`](https://doc.rust-lang.org/std/borrow/trait.ToOwned.html#tymethod.to_owned)\nand other `to_owned`-like functions.\n\nThe unnecessary calls result in useless allocations."
    },
    {
      "id": "clippy::unnecessary_join",
      "name": "UNNECESSARY_JOIN",
      "snake_name": "unnecessary_join",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "using `.collect::<Vec<String>>().join(\\",
      "what_it_does": "Checks for usage of `.collect::<Vec<String>>().join(\"\")` on iterators.",
      "why_bad": "`.collect::<String>()` is more concise and might be more performant",
      "example": "```no_run\nlet vector = vec![\"hello\",  \"world\"];\nlet output = vector.iter().map(|item| item.to_uppercase()).collect::<Vec<String>>().join(\"\");\nprintln!(\"{}\", output);\n```\nThe correct use would be:\n```no_run\nlet vector = vec![\"hello\",  \"world\"];\nlet output = vector.iter().map(|item| item.to_uppercase()).collect::<String>();\nprintln!(\"{}\", output);\n```",
      "version": "1.61.0",
      "source_file": "mod.rs",
      "embedding_text": "using `.collect::<Vec<String>>().join(\\\n\nChecks for usage of `.collect::<Vec<String>>().join(\"\")` on iterators.\n\n`.collect::<String>()` is more concise and might be more performant"
    },
    {
      "id": "clippy::needless_option_as_deref",
      "name": "NEEDLESS_OPTION_AS_DEREF",
      "snake_name": "needless_option_as_deref",
      "category": "complexity",
      "weight": 1.0,
      "brief": "no-op use of `deref` or `deref_mut` method to `Option`.",
      "what_it_does": "Checks for no-op uses of `Option::{as_deref, as_deref_mut}`,\nfor example, `Option<&T>::as_deref()` returns the same type.",
      "why_bad": "Redundant code and improving readability.",
      "example": "```no_run\nlet a = Some(&1);\nlet b = a.as_deref(); // goes from Option<&i32> to Option<&i32>\n```\n\nUse instead:\n```no_run\nlet a = Some(&1);\nlet b = a;\n```",
      "version": "1.57.0",
      "source_file": "mod.rs",
      "embedding_text": "no-op use of `deref` or `deref_mut` method to `Option`.\n\nChecks for no-op uses of `Option::{as_deref, as_deref_mut}`,\nfor example, `Option<&T>::as_deref()` returns the same type.\n\nRedundant code and improving readability."
    },
    {
      "id": "clippy::is_digit_ascii_radix",
      "name": "IS_DIGIT_ASCII_RADIX",
      "snake_name": "is_digit_ascii_radix",
      "category": "style",
      "weight": 0.95,
      "brief": "use of `char::is_digit(..)` with literal radix of 10 or 16",
      "what_it_does": "Finds usages of [`char::is_digit`](https://doc.rust-lang.org/stable/std/primitive.char.html#method.is_digit) that\ncan be replaced with [`is_ascii_digit`](https://doc.rust-lang.org/stable/std/primitive.char.html#method.is_ascii_digit) or\n[`is_ascii_hexdigit`](https://doc.rust-lang.org/stable/std/primitive.char.html#method.is_ascii_hexdigit).",
      "why_bad": "`is_digit(..)` is slower and requires specifying the radix.",
      "example": "```no_run\nlet c: char = '6';\nc.is_digit(10);\nc.is_digit(16);\n```\nUse instead:\n```no_run\nlet c: char = '6';\nc.is_ascii_digit();\nc.is_ascii_hexdigit();\n```",
      "version": "1.62.0",
      "source_file": "mod.rs",
      "embedding_text": "use of `char::is_digit(..)` with literal radix of 10 or 16\n\nFinds usages of [`char::is_digit`](https://doc.rust-lang.org/stable/std/primitive.char.html#method.is_digit) that\ncan be replaced with [`is_ascii_digit`](https://doc.rust-lang.org/stable/std/primitive.char.html#method.is_ascii_digit) or\n[`is_ascii_hexdigit`](https://doc.rust-lang.org/stable/std/primitive.char.html#method.is_ascii_hexdigit).\n\n`is_digit(..)` is slower and requires specifying the radix."
    },
    {
      "id": "clippy::needless_option_take",
      "name": "NEEDLESS_OPTION_TAKE",
      "snake_name": "needless_option_take",
      "category": "complexity",
      "weight": 1.0,
      "brief": "using `.as_ref().take()` on a temporary value",
      "what_it_does": "Checks for calling `take` function after `as_ref`.",
      "why_bad": "Redundant code. `take` writes `None` to its argument.\nIn this case the modification is useless as it's a temporary that cannot be read from afterwards.",
      "example": "```no_run\nlet x = Some(3);\nx.as_ref().take();\n```\nUse instead:\n```no_run\nlet x = Some(3);\nx.as_ref();\n```",
      "version": "1.62.0",
      "source_file": "mod.rs",
      "embedding_text": "using `.as_ref().take()` on a temporary value\n\nChecks for calling `take` function after `as_ref`.\n\nRedundant code. `take` writes `None` to its argument.\nIn this case the modification is useless as it's a temporary that cannot be read from afterwards."
    },
    {
      "id": "clippy::no_effect_replace",
      "name": "NO_EFFECT_REPLACE",
      "snake_name": "no_effect_replace",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "replace with no effect",
      "what_it_does": "Checks for `replace` statements which have no effect.",
      "why_bad": "It's either a mistake or confusing.",
      "example": "```no_run\n\"1234\".replace(\"12\", \"12\");\n\"1234\".replacen(\"12\", \"12\", 1);\n```",
      "version": "1.63.0",
      "source_file": "mod.rs",
      "embedding_text": "replace with no effect\n\nChecks for `replace` statements which have no effect.\n\nIt's either a mistake or confusing."
    },
    {
      "id": "clippy::obfuscated_if_else",
      "name": "OBFUSCATED_IF_ELSE",
      "snake_name": "obfuscated_if_else",
      "category": "style",
      "weight": 0.95,
      "brief": "use of `.then_some(..).unwrap_or(..)` can be written \\\n    more clearly with `if .. else ..`",
      "what_it_does": "Checks for unnecessary method chains that can be simplified into `if .. else ..`.",
      "why_bad": "This can be written more clearly with `if .. else ..`",
      "example": "```no_run\nlet x = true;\nx.then_some(\"a\").unwrap_or(\"b\");\n```\nUse instead:\n```no_run\nlet x = true;\nif x { \"a\" } else { \"b\" };\n```",
      "version": "1.64.0",
      "source_file": "mod.rs",
      "embedding_text": "use of `.then_some(..).unwrap_or(..)` can be written \\\n    more clearly with `if .. else ..`\n\nChecks for unnecessary method chains that can be simplified into `if .. else ..`.\n\nThis can be written more clearly with `if .. else ..`"
    },
    {
      "id": "clippy::iter_on_single_items",
      "name": "ITER_ON_SINGLE_ITEMS",
      "snake_name": "iter_on_single_items",
      "category": "nursery",
      "weight": 0.9,
      "brief": "Iterator for array of length 1",
      "what_it_does": "Checks for calls to `iter`, `iter_mut` or `into_iter` on collections containing a single item",
      "why_bad": "It is simpler to use the once function from the standard library:",
      "example": "```no_run\nlet a = [123].iter();\nlet b = Some(123).into_iter();\n```\nUse instead:\n```no_run\nuse std::iter;\nlet a = iter::once(&123);\nlet b = iter::once(123);\n```",
      "version": "1.65.0",
      "source_file": "mod.rs",
      "embedding_text": "Iterator for array of length 1\n\nChecks for calls to `iter`, `iter_mut` or `into_iter` on collections containing a single item\n\nIt is simpler to use the once function from the standard library:"
    },
    {
      "id": "clippy::iter_on_empty_collections",
      "name": "ITER_ON_EMPTY_COLLECTIONS",
      "snake_name": "iter_on_empty_collections",
      "category": "nursery",
      "weight": 0.9,
      "brief": "Iterator for empty array",
      "what_it_does": "Checks for calls to `iter`, `iter_mut` or `into_iter` on empty collections",
      "why_bad": "It is simpler to use the empty function from the standard library:",
      "example": "```no_run\nuse std::{slice, option};\nlet a: slice::Iter<i32> = [].iter();\nlet f: option::IntoIter<i32> = None.into_iter();\n```\nUse instead:\n```no_run\nuse std::iter;\nlet a: iter::Empty<i32> = iter::empty();\nlet b: iter::Empty<i32> = iter::empty();\n```",
      "version": "1.65.0",
      "source_file": "mod.rs",
      "embedding_text": "Iterator for empty array\n\nChecks for calls to `iter`, `iter_mut` or `into_iter` on empty collections\n\nIt is simpler to use the empty function from the standard library:"
    },
    {
      "id": "clippy::naive_bytecount",
      "name": "NAIVE_BYTECOUNT",
      "snake_name": "naive_bytecount",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "use of naive `<slice>.filter(|&x| x == y).count()` to count byte values",
      "what_it_does": "Checks for naive byte counts",
      "why_bad": "The [`bytecount`](https://crates.io/crates/bytecount)\ncrate has methods to count your bytes faster, especially for large slices.",
      "example": "```no_run\n# let vec = vec![1_u8];\nlet count = vec.iter().filter(|x| **x == 0u8).count();\n```\n\nUse instead:\n```rust,ignore\n# let vec = vec![1_u8];\nlet count = bytecount::count(&vec, 0u8);\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "use of naive `<slice>.filter(|&x| x == y).count()` to count byte values\n\nChecks for naive byte counts\n\nThe [`bytecount`](https://crates.io/crates/bytecount)\ncrate has methods to count your bytes faster, especially for large slices."
    },
    {
      "id": "clippy::bytes_count_to_len",
      "name": "BYTES_COUNT_TO_LEN",
      "snake_name": "bytes_count_to_len",
      "category": "complexity",
      "weight": 1.0,
      "brief": "Using `bytes().count()` when `len()` performs the same functionality",
      "what_it_does": "It checks for `str::bytes().count()` and suggests replacing it with\n`str::len()`.",
      "why_bad": "`str::bytes().count()` is longer and may not be as performant as using\n`str::len()`.",
      "example": "```no_run\n\"hello\".bytes().count();\nString::from(\"hello\").bytes().count();\n```\nUse instead:\n```no_run\n\"hello\".len();\nString::from(\"hello\").len();\n```",
      "version": "1.62.0",
      "source_file": "mod.rs",
      "embedding_text": "Using `bytes().count()` when `len()` performs the same functionality\n\nIt checks for `str::bytes().count()` and suggests replacing it with\n`str::len()`.\n\n`str::bytes().count()` is longer and may not be as performant as using\n`str::len()`."
    },
    {
      "id": "clippy::case_sensitive_file_extension_comparisons",
      "name": "CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS",
      "snake_name": "case_sensitive_file_extension_comparisons",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "Checks for calls to ends_with with case-sensitive file extensions",
      "what_it_does": "Checks for calls to `ends_with` with possible file extensions\nand suggests to use a case-insensitive approach instead.",
      "why_bad": "`ends_with` is case-sensitive and may not detect files with a valid extension.",
      "example": "```no_run\nfn is_rust_file(filename: &str) -> bool {\nfilename.ends_with(\".rs\")\n}\n```\nUse instead:\n```no_run\nfn is_rust_file(filename: &str) -> bool {\nlet filename = std::path::Path::new(filename);\nfilename.extension()\n.map_or(false, |ext| ext.eq_ignore_ascii_case(\"rs\"))\n}\n```",
      "version": "1.51.0",
      "source_file": "mod.rs",
      "embedding_text": "Checks for calls to ends_with with case-sensitive file extensions\n\nChecks for calls to `ends_with` with possible file extensions\nand suggests to use a case-insensitive approach instead.\n\n`ends_with` is case-sensitive and may not detect files with a valid extension."
    },
    {
      "id": "clippy::get_first",
      "name": "GET_FIRST",
      "snake_name": "get_first",
      "category": "style",
      "weight": 0.95,
      "brief": "Using `x.get(0)` when `x.first()` or `x.front()` is simpler",
      "what_it_does": "Checks for usage of `x.get(0)` instead of\n`x.first()` or `x.front()`.",
      "why_bad": "Using `x.first()` for `Vec`s and slices or `x.front()`\nfor `VecDeque`s is easier to read and has the same result.",
      "example": "```no_run\nlet x = vec![2, 3, 5];\nlet first_element = x.get(0);\n```\n\nUse instead:\n```no_run\nlet x = vec![2, 3, 5];\nlet first_element = x.first();\n```",
      "version": "1.63.0",
      "source_file": "mod.rs",
      "embedding_text": "Using `x.get(0)` when `x.first()` or `x.front()` is simpler\n\nChecks for usage of `x.get(0)` instead of\n`x.first()` or `x.front()`.\n\nUsing `x.first()` for `Vec`s and slices or `x.front()`\nfor `VecDeque`s is easier to read and has the same result."
    },
    {
      "id": "clippy::manual_ok_or",
      "name": "MANUAL_OK_OR",
      "snake_name": "manual_ok_or",
      "category": "style",
      "weight": 0.95,
      "brief": "finds patterns that can be encoded more concisely with `Option::ok_or`",
      "what_it_does": "Finds patterns that reimplement `Option::ok_or`.",
      "why_bad": "Concise code helps focusing on behavior instead of boilerplate.",
      "example": "```no_run\nlet foo: Option<i32> = None;\nfoo.map_or(Err(\"error\"), |v| Ok(v));\n```\n\nUse instead:\n```no_run\nlet foo: Option<i32> = None;\nfoo.ok_or(\"error\");\n```",
      "version": "1.49.0",
      "source_file": "mod.rs",
      "embedding_text": "finds patterns that can be encoded more concisely with `Option::ok_or`\n\nFinds patterns that reimplement `Option::ok_or`.\n\nConcise code helps focusing on behavior instead of boilerplate."
    },
    {
      "id": "clippy::map_clone",
      "name": "MAP_CLONE",
      "snake_name": "map_clone",
      "category": "style",
      "weight": 0.95,
      "brief": "using `iterator.map(|x| x.clone())`, or dereferencing closures for `Copy` types",
      "what_it_does": "Checks for usage of `map(|x| x.clone())` or\ndereferencing closures for `Copy` types, on `Iterator` or `Option`,\nand suggests `cloned()` or `copied()` instead",
      "why_bad": "Readability, this can be written more concisely",
      "example": "```no_run\nlet x = vec![42, 43];\nlet y = x.iter();\nlet z = y.map(|i| *i);\n```\n\nThe correct use would be:\n\n```no_run\nlet x = vec![42, 43];\nlet y = x.iter();\nlet z = y.cloned();\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "using `iterator.map(|x| x.clone())`, or dereferencing closures for `Copy` types\n\nChecks for usage of `map(|x| x.clone())` or\ndereferencing closures for `Copy` types, on `Iterator` or `Option`,\nand suggests `cloned()` or `copied()` instead\n\nReadability, this can be written more concisely"
    },
    {
      "id": "clippy::map_err_ignore",
      "name": "MAP_ERR_IGNORE",
      "snake_name": "map_err_ignore",
      "category": "restriction",
      "weight": 1.0,
      "brief": "`map_err` should not ignore the original error",
      "what_it_does": "Checks for instances of `map_err(|_| Some::Enum)`",
      "why_bad": "This `map_err` throws away the original error rather than allowing the enum to\ncontain and report the cause of the error.",
      "example": "Before:\n```no_run\nuse std::fmt;\n\n#[derive(Debug)]\nenum Error {\nIndivisible,\nRemainder(u8),\n}\n\nimpl fmt::Display for Error {\nfn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\nmatch self {\nError::Indivisible => write!(f, \"could not divide input by three\"),\nError::Remainder(remainder) => write!(\nf,\n\"input is not divisible by three, remainder = {}\",\nremainder\n),\n}\n}\n}\n\nimpl std::error::Error for Error {}\n\nfn divisible_by_3(input: &str) -> Result<(), Error> {\ninput\n.parse::<i32>()\n.map_err(|_| Error::Indivisible)\n.map(|v| v % 3)\n.and_then(|remainder| {\nif remainder == 0 {\nOk(())\n} else {\nErr(Error::Remainder(remainder as u8))\n}\n})\n}\n```\n\nAfter:\n```rust\nuse std::{fmt, num::ParseIntError};\n\n#[derive(Debug)]\nenum Error {\nIndivisible(ParseIntError),\nRemainder(u8),\n}\n\nimpl fmt::Display for Error {\nfn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\nmatch self {\nError::Indivisible(_) => write!(f, \"could not divide input by three\"),\nError::Remainder(remainder) => write!(\nf,\n\"input is not divisible by three, remainder = {}\",\nremainder\n),\n}\n}\n}\n\nimpl std::error::Error for Error {\nfn source(&self) -> Option<&(dyn std::error::Error + 'static)> {\nmatch self {\nError::Indivisible(source) => Some(source),\n_ => None,\n}\n}\n}\n\nfn divisible_by_3(input: &str) -> Result<(), Error> {\ninput\n.parse::<i32>()\n.map_err(Error::Indivisible)\n.map(|v| v % 3)\n.and_then(|remainder| {\nif remainder == 0 {\nOk(())\n} else {\nErr(Error::Remainder(remainder as u8))\n}\n})\n}\n```",
      "version": "1.48.0",
      "source_file": "mod.rs",
      "embedding_text": "`map_err` should not ignore the original error\n\nChecks for instances of `map_err(|_| Some::Enum)`\n\nThis `map_err` throws away the original error rather than allowing the enum to\ncontain and report the cause of the error."
    },
    {
      "id": "clippy::mut_mutex_lock",
      "name": "MUT_MUTEX_LOCK",
      "snake_name": "mut_mutex_lock",
      "category": "style",
      "weight": 0.95,
      "brief": "`&mut Mutex::lock` does unnecessary locking",
      "what_it_does": "Checks for `&mut Mutex::lock` calls",
      "why_bad": "`Mutex::lock` is less efficient than\ncalling `Mutex::get_mut`. In addition you also have a statically\nguarantee that the mutex isn't locked, instead of just a runtime\nguarantee.",
      "example": "```no_run\nuse std::sync::{Arc, Mutex};\n\nlet mut value_rc = Arc::new(Mutex::new(42_u8));\nlet value_mutex = Arc::get_mut(&mut value_rc).unwrap();\n\nlet mut value = value_mutex.lock().unwrap();\n*value += 1;\n```\nUse instead:\n```no_run\nuse std::sync::{Arc, Mutex};\n\nlet mut value_rc = Arc::new(Mutex::new(42_u8));\nlet value_mutex = Arc::get_mut(&mut value_rc).unwrap();\n\nlet value = value_mutex.get_mut().unwrap();\n*value += 1;\n```",
      "version": "1.49.0",
      "source_file": "mod.rs",
      "embedding_text": "`&mut Mutex::lock` does unnecessary locking\n\nChecks for `&mut Mutex::lock` calls\n\n`Mutex::lock` is less efficient than\ncalling `Mutex::get_mut`. In addition you also have a statically\nguarantee that the mutex isn't locked, instead of just a runtime\nguarantee."
    },
    {
      "id": "clippy::nonsensical_open_options",
      "name": "NONSENSICAL_OPEN_OPTIONS",
      "snake_name": "nonsensical_open_options",
      "category": "correctness",
      "weight": 1.2,
      "brief": "nonsensical combination of options for opening a file",
      "what_it_does": "Checks for duplicate open options as well as combinations\nthat make no sense.",
      "why_bad": "In the best case, the code will be harder to read than\nnecessary. I don't know the worst case.",
      "example": "```no_run\nuse std::fs::OpenOptions;\n\nOpenOptions::new().read(true).truncate(true);\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "nonsensical combination of options for opening a file\n\nChecks for duplicate open options as well as combinations\nthat make no sense.\n\nIn the best case, the code will be harder to read than\nnecessary. I don't know the worst case."
    },
    {
      "id": "clippy::suspicious_open_options",
      "name": "SUSPICIOUS_OPEN_OPTIONS",
      "snake_name": "suspicious_open_options",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "suspicious combination of options for opening a file",
      "what_it_does": "Checks for the suspicious use of `OpenOptions::create()`\nwithout an explicit `OpenOptions::truncate()`.",
      "why_bad": "`create()` alone will either create a new file or open an\nexisting file. If the file already exists, it will be\noverwritten when written to, but the file will not be\ntruncated by default.\nIf less data is written to the file\nthan it already contains, the remainder of the file will\nremain unchanged, and the end of the file will contain old\ndata.\nIn most cases, one should either use `create_new` to ensure\nthe file is created from scratch, or ensure `truncate` is\ncalled so that the truncation behaviour is explicit. `truncate(true)`\nwill ensure the file is entirely overwritten with new data, whereas\n`truncate(false)` will explicitly keep the default behavior.",
      "example": "```rust,no_run\nuse std::fs::OpenOptions;\n\nOpenOptions::new().create(true);\n```\nUse instead:\n```rust,no_run\nuse std::fs::OpenOptions;\n\nOpenOptions::new().create(true).truncate(true);\n```",
      "version": "1.77.0",
      "source_file": "mod.rs",
      "embedding_text": "suspicious combination of options for opening a file\n\nChecks for the suspicious use of `OpenOptions::create()`\nwithout an explicit `OpenOptions::truncate()`.\n\n`create()` alone will either create a new file or open an\nexisting file. If the file already exists, it will be\noverwritten when written to, but the file will not be\ntruncated by default.\nIf less data is written to the file\nthan it already contains, the remainder of the file will\nremain unchanged, and the end of the file will contain old\ndata.\nIn most cases, one should either use `create_new` to ensure\nthe file is created from scratch, or ensure `truncate` is\ncalled so that the truncation behaviour is explicit. `truncate(true)`\nwill ensure the file is entirely overwritten with new data, whereas\n`truncate(false)` will explicitly keep the default behavior."
    },
    {
      "id": "clippy::path_buf_push_overwrite",
      "name": "PATH_BUF_PUSH_OVERWRITE",
      "snake_name": "path_buf_push_overwrite",
      "category": "nursery",
      "weight": 0.9,
      "brief": "calling `push` with file system root on `PathBuf` can overwrite it",
      "what_it_does": "* Checks for [push](https://doc.rust-lang.org/std/path/struct.PathBuf.html#method.push)\ncalls on `PathBuf` that can cause overwrites.",
      "why_bad": "Calling `push` with a root path at the start can overwrite the\nprevious defined path.",
      "example": "```no_run\nuse std::path::PathBuf;\n\nlet mut x = PathBuf::from(\"/foo\");\nx.push(\"/bar\");\nassert_eq!(x, PathBuf::from(\"/bar\"));\n```\nCould be written:\n\n```no_run\nuse std::path::PathBuf;\n\nlet mut x = PathBuf::from(\"/foo\");\nx.push(\"bar\");\nassert_eq!(x, PathBuf::from(\"/foo/bar\"));\n```",
      "version": "1.36.0",
      "source_file": "mod.rs",
      "embedding_text": "calling `push` with file system root on `PathBuf` can overwrite it\n\n* Checks for [push](https://doc.rust-lang.org/std/path/struct.PathBuf.html#method.push)\ncalls on `PathBuf` that can cause overwrites.\n\nCalling `push` with a root path at the start can overwrite the\nprevious defined path."
    },
    {
      "id": "clippy::range_zip_with_len",
      "name": "RANGE_ZIP_WITH_LEN",
      "snake_name": "range_zip_with_len",
      "category": "complexity",
      "weight": 1.0,
      "brief": "zipping iterator with a range when `enumerate()` would do",
      "what_it_does": "Checks for zipping a collection with the range of\n`0.._.len()`.",
      "why_bad": "The code is better expressed with `.enumerate()`.",
      "example": "```no_run\n# let x = vec![1];\nlet _ = x.iter().zip(0..x.len());\n```\n\nUse instead:\n```no_run\n# let x = vec![1];\nlet _ = x.iter().enumerate();\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "zipping iterator with a range when `enumerate()` would do\n\nChecks for zipping a collection with the range of\n`0.._.len()`.\n\nThe code is better expressed with `.enumerate()`."
    },
    {
      "id": "clippy::repeat_once",
      "name": "REPEAT_ONCE",
      "snake_name": "repeat_once",
      "category": "complexity",
      "weight": 1.0,
      "brief": "using `.repeat(1)` instead of `String.clone()`, `str.to_string()` or `slice.to_vec()` ",
      "what_it_does": "Checks for usage of `.repeat(1)` and suggest the following method for each types.\n- `.to_string()` for `str`\n- `.clone()` for `String`\n- `.to_vec()` for `slice`\n\nThe lint will evaluate constant expressions and values as arguments of `.repeat(..)` and emit a message if\nthey are equivalent to `1`. (Related discussion in [rust-clippy#7306](https://github.com/rust-lang/rust-clippy/issues/7306))",
      "why_bad": "For example, `String.repeat(1)` is equivalent to `.clone()`. If cloning\nthe string is the intention behind this, `clone()` should be used.",
      "example": "```no_run\nfn main() {\nlet x = String::from(\"hello world\").repeat(1);\n}\n```\nUse instead:\n```no_run\nfn main() {\nlet x = String::from(\"hello world\").clone();\n}\n```",
      "version": "1.47.0",
      "source_file": "mod.rs",
      "embedding_text": "using `.repeat(1)` instead of `String.clone()`, `str.to_string()` or `slice.to_vec()` \n\nChecks for usage of `.repeat(1)` and suggest the following method for each types.\n- `.to_string()` for `str`\n- `.clone()` for `String`\n- `.to_vec()` for `slice`\n\nThe lint will evaluate constant expressions and values as arguments of `.repeat(..)` and emit a message if\nthey are equivalent to `1`. (Related discussion in [rust-clippy#7306](https://github.com/rust-lang/rust-clippy/issues/7306))\n\nFor example, `String.repeat(1)` is equivalent to `.clone()`. If cloning\nthe string is the intention behind this, `clone()` should be used."
    },
    {
      "id": "clippy::stable_sort_primitive",
      "name": "STABLE_SORT_PRIMITIVE",
      "snake_name": "stable_sort_primitive",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "use of sort() when sort_unstable() is equivalent",
      "what_it_does": "When sorting primitive values (integers, bools, chars, as well\nas arrays, slices, and tuples of such items), it is typically better to\nuse an unstable sort than a stable sort.",
      "why_bad": "Typically, using a stable sort consumes more memory and cpu cycles.\nBecause values which compare equal are identical, preserving their\nrelative order (the guarantee that a stable sort provides) means\nnothing, while the extra costs still apply.",
      "example": "```no_run\nlet mut vec = vec![2, 1, 3];\nvec.sort();\n```\nUse instead:\n```no_run\nlet mut vec = vec![2, 1, 3];\nvec.sort_unstable();\n```",
      "version": "1.47.0",
      "source_file": "mod.rs",
      "embedding_text": "use of sort() when sort_unstable() is equivalent\n\nWhen sorting primitive values (integers, bools, chars, as well\nas arrays, slices, and tuples of such items), it is typically better to\nuse an unstable sort than a stable sort.\n\nTypically, using a stable sort consumes more memory and cpu cycles.\nBecause values which compare equal are identical, preserving their\nrelative order (the guarantee that a stable sort provides) means\nnothing, while the extra costs still apply."
    },
    {
      "id": "clippy::type_id_on_box",
      "name": "TYPE_ID_ON_BOX",
      "snake_name": "type_id_on_box",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "calling `.type_id()` on a boxed trait object",
      "what_it_does": "Looks for calls to `.type_id()` on a `Box<dyn _>`.",
      "why_bad": "This almost certainly does not do what the user expects and can lead to subtle bugs.\nCalling `.type_id()` on a `Box<dyn Trait>` returns a fixed `TypeId` of the `Box` itself,\nrather than returning the `TypeId` of the underlying type behind the trait object.\n\nFor `Box<dyn Any>` specifically (and trait objects that have `Any` as its supertrait),\nthis lint will provide a suggestion, which is to dereference the receiver explicitly\nto go from `Box<dyn Any>` to `dyn Any`.\nThis makes sure that `.type_id()` resolves to a dynamic call on the trait object\nand not on the box.\n\nIf the fixed `TypeId` of the `Box` is the intended behavior, it's better to be explicit about it\nand write `TypeId::of::<Box<dyn Trait>>()`:\nthis makes it clear that a fixed `TypeId` is returned and not the `TypeId` of the implementor.",
      "example": "```rust,ignore\nuse std::any::{Any, TypeId};\n\nlet any_box: Box<dyn Any> = Box::new(42_i32);\nassert_eq!(any_box.type_id(), TypeId::of::<i32>()); // \u26a0\ufe0f this fails!\n```\nUse instead:\n```no_run\nuse std::any::{Any, TypeId};\n\nlet any_box: Box<dyn Any> = Box::new(42_i32);\nassert_eq!((*any_box).type_id(), TypeId::of::<i32>());\n//          ^ dereference first, to call `type_id` on `dyn Any`\n```",
      "version": "1.73.0",
      "source_file": "mod.rs",
      "embedding_text": "calling `.type_id()` on a boxed trait object\n\nLooks for calls to `.type_id()` on a `Box<dyn _>`.\n\nThis almost certainly does not do what the user expects and can lead to subtle bugs.\nCalling `.type_id()` on a `Box<dyn Trait>` returns a fixed `TypeId` of the `Box` itself,\nrather than returning the `TypeId` of the underlying type behind the trait object.\n\nFor `Box<dyn Any>` specifically (and trait objects that have `Any` as its supertrait),\nthis lint will provide a suggestion, which is to dereference the receiver explicitly\nto go from `Box<dyn Any>` to `dyn Any`.\nThis makes sure that `.type_id()` resolves to a dynamic call on the trait object\nand not on the box.\n\nIf the fixed `TypeId` of the `Box` is the intended behavior, it's better to be explicit about it\nand write `TypeId::of::<Box<dyn Trait>>()`:\nthis makes it clear that a fixed `TypeId` is returned and not the `TypeId` of the implementor."
    },
    {
      "id": "clippy::unit_hash",
      "name": "UNIT_HASH",
      "snake_name": "unit_hash",
      "category": "correctness",
      "weight": 1.2,
      "brief": "hashing a unit value, which does nothing",
      "what_it_does": "Detects `().hash(_)`.",
      "why_bad": "Hashing a unit value doesn't do anything as the implementation of `Hash` for `()` is a no-op.",
      "example": "```no_run\n# use std::hash::Hash;\n# use std::collections::hash_map::DefaultHasher;\n# enum Foo { Empty, WithValue(u8) }\n# use Foo::*;\n# let mut state = DefaultHasher::new();\n# let my_enum = Foo::Empty;\nmatch my_enum {\nEmpty => ().hash(&mut state),\nWithValue(x) => x.hash(&mut state),\n}\n```\nUse instead:\n```no_run\n# use std::hash::Hash;\n# use std::collections::hash_map::DefaultHasher;\n# enum Foo { Empty, WithValue(u8) }\n# use Foo::*;\n# let mut state = DefaultHasher::new();\n# let my_enum = Foo::Empty;\nmatch my_enum {\nEmpty => 0_u8.hash(&mut state),\nWithValue(x) => x.hash(&mut state),\n}\n```",
      "version": "1.58.0",
      "source_file": "mod.rs",
      "embedding_text": "hashing a unit value, which does nothing\n\nDetects `().hash(_)`.\n\nHashing a unit value doesn't do anything as the implementation of `Hash` for `()` is a no-op."
    },
    {
      "id": "clippy::unnecessary_sort_by",
      "name": "UNNECESSARY_SORT_BY",
      "snake_name": "unnecessary_sort_by",
      "category": "complexity",
      "weight": 1.0,
      "brief": "Use of `Vec::sort_by` when `Vec::sort_by_key` or `Vec::sort` would be clearer",
      "what_it_does": "Checks for usage of `Vec::sort_by` passing in a closure\nwhich compares the two arguments, either directly or indirectly.",
      "why_bad": "It is more clear to use `Vec::sort_by_key` (or `Vec::sort` if\npossible) than to use `Vec::sort_by` and a more complicated\nclosure.",
      "example": "```no_run\n# struct A;\n# impl A { fn foo(&self) {} }\n# let mut vec: Vec<A> = Vec::new();\nvec.sort_by(|a, b| a.foo().cmp(&b.foo()));\n```\nUse instead:\n```no_run\n# struct A;\n# impl A { fn foo(&self) {} }\n# let mut vec: Vec<A> = Vec::new();\nvec.sort_by_key(|a| a.foo());\n```",
      "version": "1.46.0",
      "source_file": "mod.rs",
      "embedding_text": "Use of `Vec::sort_by` when `Vec::sort_by_key` or `Vec::sort` would be clearer\n\nChecks for usage of `Vec::sort_by` passing in a closure\nwhich compares the two arguments, either directly or indirectly.\n\nIt is more clear to use `Vec::sort_by_key` (or `Vec::sort` if\npossible) than to use `Vec::sort_by` and a more complicated\nclosure."
    },
    {
      "id": "clippy::vec_resize_to_zero",
      "name": "VEC_RESIZE_TO_ZERO",
      "snake_name": "vec_resize_to_zero",
      "category": "correctness",
      "weight": 1.2,
      "brief": "emptying a vector with `resize(0, an_int)` instead of `clear()` is probably an argument inversion mistake",
      "what_it_does": "Finds occurrences of `Vec::resize(0, an_int)`",
      "why_bad": "This is probably an argument inversion mistake.",
      "example": "```no_run\nvec![1, 2, 3, 4, 5].resize(0, 5)\n```\n\nUse instead:\n```no_run\nvec![1, 2, 3, 4, 5].clear()\n```",
      "version": "1.46.0",
      "source_file": "mod.rs",
      "embedding_text": "emptying a vector with `resize(0, an_int)` instead of `clear()` is probably an argument inversion mistake\n\nFinds occurrences of `Vec::resize(0, an_int)`\n\nThis is probably an argument inversion mistake."
    },
    {
      "id": "clippy::verbose_file_reads",
      "name": "VERBOSE_FILE_READS",
      "snake_name": "verbose_file_reads",
      "category": "restriction",
      "weight": 1.0,
      "brief": "use of `File::read_to_end` or `File::read_to_string`",
      "what_it_does": "Checks for usage of File::read_to_end and File::read_to_string.",
      "why_bad": "`fs::{read, read_to_string}` provide the same functionality when `buf` is empty with fewer imports and no intermediate values.\nSee also: [fs::read docs](https://doc.rust-lang.org/std/fs/fn.read.html), [fs::read_to_string docs](https://doc.rust-lang.org/std/fs/fn.read_to_string.html)",
      "example": "```rust,no_run\n# use std::io::Read;\n# use std::fs::File;\nlet mut f = File::open(\"foo.txt\").unwrap();\nlet mut bytes = Vec::new();\nf.read_to_end(&mut bytes).unwrap();\n```\nCan be written more concisely as\n```rust,no_run\n# use std::fs;\nlet mut bytes = fs::read(\"foo.txt\").unwrap();\n```",
      "version": "1.44.0",
      "source_file": "mod.rs",
      "embedding_text": "use of `File::read_to_end` or `File::read_to_string`\n\nChecks for usage of File::read_to_end and File::read_to_string.\n\n`fs::{read, read_to_string}` provide the same functionality when `buf` is empty with fewer imports and no intermediate values.\nSee also: [fs::read docs](https://doc.rust-lang.org/std/fs/fn.read.html), [fs::read_to_string docs](https://doc.rust-lang.org/std/fs/fn.read_to_string.html)"
    },
    {
      "id": "clippy::iter_kv_map",
      "name": "ITER_KV_MAP",
      "snake_name": "iter_kv_map",
      "category": "complexity",
      "weight": 1.0,
      "brief": "iterating on map using `iter` when `keys` or `values` would do",
      "what_it_does": "Checks for iterating a map (`HashMap` or `BTreeMap`) and\nignoring either the keys or values.",
      "why_bad": "Readability. There are `keys` and `values` methods that\ncan be used to express that we only need the keys or the values.",
      "example": "```no_run\n# use std::collections::HashMap;\nlet map: HashMap<u32, u32> = HashMap::new();\nlet values = map.iter().map(|(_, value)| value).collect::<Vec<_>>();\n```\n\nUse instead:\n```no_run\n# use std::collections::HashMap;\nlet map: HashMap<u32, u32> = HashMap::new();\nlet values = map.values().collect::<Vec<_>>();\n```",
      "version": "1.66.0",
      "source_file": "mod.rs",
      "embedding_text": "iterating on map using `iter` when `keys` or `values` would do\n\nChecks for iterating a map (`HashMap` or `BTreeMap`) and\nignoring either the keys or values.\n\nReadability. There are `keys` and `values` methods that\ncan be used to express that we only need the keys or the values."
    },
    {
      "id": "clippy::seek_from_current",
      "name": "SEEK_FROM_CURRENT",
      "snake_name": "seek_from_current",
      "category": "complexity",
      "weight": 1.0,
      "brief": "use dedicated method for seek from current position",
      "what_it_does": "Checks if the `seek` method of the `Seek` trait is called with `SeekFrom::Current(0)`,\nand if it is, suggests using `stream_position` instead.",
      "why_bad": "Readability. Use dedicated method.",
      "example": "```rust,no_run\nuse std::fs::File;\nuse std::io::{self, Write, Seek, SeekFrom};\n\nfn main() -> io::Result<()> {\nlet mut f = File::create(\"foo.txt\")?;\nf.write_all(b\"Hello\")?;\neprintln!(\"Written {} bytes\", f.seek(SeekFrom::Current(0))?);\n\nOk(())\n}\n```\nUse instead:\n```rust,no_run\nuse std::fs::File;\nuse std::io::{self, Write, Seek, SeekFrom};\n\nfn main() -> io::Result<()> {\nlet mut f = File::create(\"foo.txt\")?;\nf.write_all(b\"Hello\")?;\neprintln!(\"Written {} bytes\", f.stream_position()?);\n\nOk(())\n}\n```",
      "version": "1.67.0",
      "source_file": "mod.rs",
      "embedding_text": "use dedicated method for seek from current position\n\nChecks if the `seek` method of the `Seek` trait is called with `SeekFrom::Current(0)`,\nand if it is, suggests using `stream_position` instead.\n\nReadability. Use dedicated method."
    },
    {
      "id": "clippy::seek_to_start_instead_of_rewind",
      "name": "SEEK_TO_START_INSTEAD_OF_REWIND",
      "snake_name": "seek_to_start_instead_of_rewind",
      "category": "complexity",
      "weight": 1.0,
      "brief": "jumping to the start of stream using `seek` method",
      "what_it_does": "Checks for jumps to the start of a stream that implements `Seek`\nand uses the `seek` method providing `Start` as parameter.",
      "why_bad": "Readability. There is a specific method that was implemented for\nthis exact scenario.",
      "example": "```no_run\n# use std::io;\nfn foo<T: io::Seek>(t: &mut T) {\nt.seek(io::SeekFrom::Start(0));\n}\n```\nUse instead:\n```no_run\n# use std::io;\nfn foo<T: io::Seek>(t: &mut T) {\nt.rewind();\n}\n```",
      "version": "1.67.0",
      "source_file": "mod.rs",
      "embedding_text": "jumping to the start of stream using `seek` method\n\nChecks for jumps to the start of a stream that implements `Seek`\nand uses the `seek` method providing `Start` as parameter.\n\nReadability. There is a specific method that was implemented for\nthis exact scenario."
    },
    {
      "id": "clippy::needless_collect",
      "name": "NEEDLESS_COLLECT",
      "snake_name": "needless_collect",
      "category": "nursery",
      "weight": 0.9,
      "brief": "collecting an iterator when collect is not needed",
      "what_it_does": "Checks for functions collecting an iterator when collect\nis not needed.",
      "why_bad": "`collect` causes the allocation of a new data structure,\nwhen this allocation may not be needed.",
      "example": "```no_run\n# let iterator = vec![1].into_iter();\nlet len = iterator.collect::<Vec<_>>().len();\n```\nUse instead:\n```no_run\n# let iterator = vec![1].into_iter();\nlet len = iterator.count();\n```",
      "version": "1.30.0",
      "source_file": "mod.rs",
      "embedding_text": "collecting an iterator when collect is not needed\n\nChecks for functions collecting an iterator when collect\nis not needed.\n\n`collect` causes the allocation of a new data structure,\nwhen this allocation may not be needed."
    },
    {
      "id": "clippy::suspicious_command_arg_space",
      "name": "SUSPICIOUS_COMMAND_ARG_SPACE",
      "snake_name": "suspicious_command_arg_space",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "single command line argument that looks like it should be multiple arguments",
      "what_it_does": "Checks for `Command::arg()` invocations that look like they\nshould be multiple arguments instead, such as `arg(\"-t ext2\")`.",
      "why_bad": "`Command::arg()` does not split arguments by space. An argument like `arg(\"-t ext2\")`\nwill be passed as a single argument to the command,\nwhich is likely not what was intended.",
      "example": "```no_run\nstd::process::Command::new(\"echo\").arg(\"-n hello\").spawn().unwrap();\n```\nUse instead:\n```no_run\nstd::process::Command::new(\"echo\").args([\"-n\", \"hello\"]).spawn().unwrap();\n```",
      "version": "1.69.0",
      "source_file": "mod.rs",
      "embedding_text": "single command line argument that looks like it should be multiple arguments\n\nChecks for `Command::arg()` invocations that look like they\nshould be multiple arguments instead, such as `arg(\"-t ext2\")`.\n\n`Command::arg()` does not split arguments by space. An argument like `arg(\"-t ext2\")`\nwill be passed as a single argument to the command,\nwhich is likely not what was intended."
    },
    {
      "id": "clippy::clear_with_drain",
      "name": "CLEAR_WITH_DRAIN",
      "snake_name": "clear_with_drain",
      "category": "nursery",
      "weight": 0.9,
      "brief": "calling `drain` in order to `clear` a container",
      "what_it_does": "Checks for usage of `.drain(..)` for the sole purpose of clearing a container.",
      "why_bad": "This creates an unnecessary iterator that is dropped immediately.\n\nCalling `.clear()` also makes the intent clearer.",
      "example": "```no_run\nlet mut v = vec![1, 2, 3];\nv.drain(..);\n```\nUse instead:\n```no_run\nlet mut v = vec![1, 2, 3];\nv.clear();\n```",
      "version": "1.70.0",
      "source_file": "mod.rs",
      "embedding_text": "calling `drain` in order to `clear` a container\n\nChecks for usage of `.drain(..)` for the sole purpose of clearing a container.\n\nThis creates an unnecessary iterator that is dropped immediately.\n\nCalling `.clear()` also makes the intent clearer."
    },
    {
      "id": "clippy::manual_next_back",
      "name": "MANUAL_NEXT_BACK",
      "snake_name": "manual_next_back",
      "category": "style",
      "weight": 0.95,
      "brief": "manual reverse iteration of `DoubleEndedIterator`",
      "what_it_does": "Checks for `.rev().next()` on a `DoubleEndedIterator`",
      "why_bad": "`.next_back()` is cleaner.",
      "example": "```no_run\n# let foo = [0; 10];\nfoo.iter().rev().next();\n```\nUse instead:\n```no_run\n# let foo = [0; 10];\nfoo.iter().next_back();\n```",
      "version": "1.71.0",
      "source_file": "mod.rs",
      "embedding_text": "manual reverse iteration of `DoubleEndedIterator`\n\nChecks for `.rev().next()` on a `DoubleEndedIterator`\n\n`.next_back()` is cleaner."
    },
    {
      "id": "clippy::drain_collect",
      "name": "DRAIN_COLLECT",
      "snake_name": "drain_collect",
      "category": "perf",
      "weight": 1.0,
      "brief": "calling `.drain(..).collect()` to move all elements into a new collection",
      "what_it_does": "Checks for calls to `.drain()` that clear the collection, immediately followed by a call to `.collect()`.\n\n> \"Collection\" in this context refers to any type with a `drain` method:\n> `Vec`, `VecDeque`, `BinaryHeap`, `HashSet`,`HashMap`, `String`",
      "why_bad": "Using `mem::take` is faster as it avoids the allocation.\nWhen using `mem::take`, the old collection is replaced with an empty one and ownership of\nthe old collection is returned.",
      "example": "```no_run\nfn remove_all(v: &mut Vec<i32>) -> Vec<i32> {\nv.drain(..).collect()\n}\n```\nUse instead:\n```no_run\nuse std::mem;\nfn remove_all(v: &mut Vec<i32>) -> Vec<i32> {\nmem::take(v)\n}\n```",
      "version": "1.72.0",
      "source_file": "mod.rs",
      "embedding_text": "calling `.drain(..).collect()` to move all elements into a new collection\n\nChecks for calls to `.drain()` that clear the collection, immediately followed by a call to `.collect()`.\n\n> \"Collection\" in this context refers to any type with a `drain` method:\n> `Vec`, `VecDeque`, `BinaryHeap`, `HashSet`,`HashMap`, `String`\n\nUsing `mem::take` is faster as it avoids the allocation.\nWhen using `mem::take`, the old collection is replaced with an empty one and ownership of\nthe old collection is returned."
    },
    {
      "id": "clippy::manual_try_fold",
      "name": "MANUAL_TRY_FOLD",
      "snake_name": "manual_try_fold",
      "category": "perf",
      "weight": 1.0,
      "brief": "checks for usage of `Iterator::fold` with a type that implements `Try`",
      "what_it_does": "Checks for usage of `Iterator::fold` with a type that implements `Try`.",
      "why_bad": "The code should use `try_fold` instead, which short-circuits on failure, thus opening the\ndoor for additional optimizations not possible with `fold` as rustc can guarantee the\nfunction is never called on `None`, `Err`, etc., alleviating otherwise necessary checks. It's\nalso slightly more idiomatic.",
      "example": "```no_run\nvec![1, 2, 3].iter().fold(Some(0i32), |sum, i| sum?.checked_add(*i));\n```\nUse instead:\n```no_run\nvec![1, 2, 3].iter().try_fold(0i32, |sum, i| sum.checked_add(*i));\n```",
      "version": "1.72.0",
      "source_file": "mod.rs",
      "embedding_text": "checks for usage of `Iterator::fold` with a type that implements `Try`\n\nChecks for usage of `Iterator::fold` with a type that implements `Try`.\n\nThe code should use `try_fold` instead, which short-circuits on failure, thus opening the\ndoor for additional optimizations not possible with `fold` as rustc can guarantee the\nfunction is never called on `None`, `Err`, etc., alleviating otherwise necessary checks. It's\nalso slightly more idiomatic."
    },
    {
      "id": "clippy::read_line_without_trim",
      "name": "READ_LINE_WITHOUT_TRIM",
      "snake_name": "read_line_without_trim",
      "category": "correctness",
      "weight": 1.2,
      "brief": "calling `Stdin::read_line`, then trying to parse it without first trimming",
      "what_it_does": "Looks for calls to [`Stdin::read_line`] to read a line from the standard input\ninto a string, then later attempting to use that string for an operation that will never\nwork for strings with a trailing newline character in it (e.g. parsing into a `i32`).",
      "why_bad": "The operation will always fail at runtime no matter what the user enters, thus\nmaking it a useless operation.",
      "example": "```rust,ignore\nlet mut input = String::new();\nstd::io::stdin().read_line(&mut input).expect(\"Failed to read a line\");\nlet num: i32 = input.parse().expect(\"Not a number!\");\nassert_eq!(num, 42); // we never even get here!\n```\nUse instead:\n```rust,ignore\nlet mut input = String::new();\nstd::io::stdin().read_line(&mut input).expect(\"Failed to read a line\");\nlet num: i32 = input.trim_end().parse().expect(\"Not a number!\");\n//                  ^^^^^^^^^^^ remove the trailing newline\nassert_eq!(num, 42);\n```",
      "version": "1.73.0",
      "source_file": "mod.rs",
      "embedding_text": "calling `Stdin::read_line`, then trying to parse it without first trimming\n\nLooks for calls to [`Stdin::read_line`] to read a line from the standard input\ninto a string, then later attempting to use that string for an operation that will never\nwork for strings with a trailing newline character in it (e.g. parsing into a `i32`).\n\nThe operation will always fail at runtime no matter what the user enters, thus\nmaking it a useless operation."
    },
    {
      "id": "clippy::string_lit_chars_any",
      "name": "STRING_LIT_CHARS_ANY",
      "snake_name": "string_lit_chars_any",
      "category": "restriction",
      "weight": 1.0,
      "brief": "checks for `<string_lit>.chars().any(|i| i == c)`",
      "what_it_does": "Checks for `<string_lit>.chars().any(|i| i == c)`.",
      "why_bad": "It's significantly slower than using a pattern instead, like\n`matches!(c, '\\\\' | '.' | '+')`.\n\nDespite this being faster, this is not `perf` as this is pretty common, and is a rather nice\nway to check if a `char` is any in a set. In any case, this `restriction` lint is available\nfor situations where that additional performance is absolutely necessary.",
      "example": "```no_run\n# let c = 'c';\n\"\\\\.+*?()|[]{}^$#&-~\".chars().any(|x| x == c);\n```\nUse instead:\n```no_run\n# let c = 'c';\nmatches!(c, '\\\\' | '.' | '+' | '*' | '(' | ')' | '|' | '[' | ']' | '{' | '}' | '^' | '$' | '#' | '&' | '-' | '~');\n```",
      "version": "1.73.0",
      "source_file": "mod.rs",
      "embedding_text": "checks for `<string_lit>.chars().any(|i| i == c)`\n\nChecks for `<string_lit>.chars().any(|i| i == c)`.\n\nIt's significantly slower than using a pattern instead, like\n`matches!(c, '\\\\' | '.' | '+')`.\n\nDespite this being faster, this is not `perf` as this is pretty common, and is a rather nice\nway to check if a `char` is any in a set. In any case, this `restriction` lint is available\nfor situations where that additional performance is absolutely necessary."
    },
    {
      "id": "clippy::format_collect",
      "name": "FORMAT_COLLECT",
      "snake_name": "format_collect",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "`format!`ing every element in a collection, then collecting the strings into a new `String`",
      "what_it_does": "Checks for usage of `.map(|_| format!(..)).collect::<String>()`.",
      "why_bad": "This allocates a new string for every element in the iterator.\nThis can be done more efficiently by creating the `String` once and appending to it in `Iterator::fold`,\nusing either the `write!` macro which supports exactly the same syntax as the `format!` macro,\nor concatenating with `+` in case the iterator yields `&str`/`String`.\n\nNote also that `write!`-ing into a `String` can never fail, despite the return type of `write!` being `std::fmt::Result`,\nso it can be safely ignored or unwrapped.",
      "example": "```no_run\nfn hex_encode(bytes: &[u8]) -> String {\nbytes.iter().map(|b| format!(\"{b:02X}\")).collect()\n}\n```\nUse instead:\n```no_run\nuse std::fmt::Write;\nfn hex_encode(bytes: &[u8]) -> String {\nbytes.iter().fold(String::new(), |mut output, b| {\nlet _ = write!(output, \"{b:02X}\");\noutput\n})\n}\n```",
      "version": "1.73.0",
      "source_file": "mod.rs",
      "embedding_text": "`format!`ing every element in a collection, then collecting the strings into a new `String`\n\nChecks for usage of `.map(|_| format!(..)).collect::<String>()`.\n\nThis allocates a new string for every element in the iterator.\nThis can be done more efficiently by creating the `String` once and appending to it in `Iterator::fold`,\nusing either the `write!` macro which supports exactly the same syntax as the `format!` macro,\nor concatenating with `+` in case the iterator yields `&str`/`String`.\n\nNote also that `write!`-ing into a `String` can never fail, despite the return type of `write!` being `std::fmt::Result`,\nso it can be safely ignored or unwrapped."
    },
    {
      "id": "clippy::iter_skip_zero",
      "name": "ITER_SKIP_ZERO",
      "snake_name": "iter_skip_zero",
      "category": "correctness",
      "weight": 1.2,
      "brief": "disallows `.skip(0)`",
      "what_it_does": "Checks for usage of `.skip(0)` on iterators.",
      "why_bad": "This was likely intended to be `.skip(1)` to skip the first element, as `.skip(0)` does\nnothing. If not, the call should be removed.",
      "example": "```no_run\nlet v = vec![1, 2, 3];\nlet x = v.iter().skip(0).collect::<Vec<_>>();\nlet y = v.iter().collect::<Vec<_>>();\nassert_eq!(x, y);\n```",
      "version": "1.73.0",
      "source_file": "mod.rs",
      "embedding_text": "disallows `.skip(0)`\n\nChecks for usage of `.skip(0)` on iterators.\n\nThis was likely intended to be `.skip(1)` to skip the first element, as `.skip(0)` does\nnothing. If not, the call should be removed."
    },
    {
      "id": "clippy::filter_map_bool_then",
      "name": "FILTER_MAP_BOOL_THEN",
      "snake_name": "filter_map_bool_then",
      "category": "style",
      "weight": 0.95,
      "brief": "checks for usage of `bool::then` in `Iterator::filter_map`",
      "what_it_does": "Checks for usage of `bool::then` in `Iterator::filter_map`.",
      "why_bad": "This can be written with `filter` then `map` instead, which would reduce nesting and\nseparates the filtering from the transformation phase. This comes with no cost to\nperformance and is just cleaner.",
      "example": "```no_run\n# fn really_expensive_fn(i: i32) -> i32 { i }\n# let v = vec![];\n_ = v.into_iter().filter_map(|i| (i % 2 == 0).then(|| really_expensive_fn(i)));\n```\nUse instead:\n```no_run\n# fn really_expensive_fn(i: i32) -> i32 { i }\n# let v = vec![];\n_ = v.into_iter().filter(|i| i % 2 == 0).map(|i| really_expensive_fn(i));\n```",
      "version": "1.73.0",
      "source_file": "mod.rs",
      "embedding_text": "checks for usage of `bool::then` in `Iterator::filter_map`\n\nChecks for usage of `bool::then` in `Iterator::filter_map`.\n\nThis can be written with `filter` then `map` instead, which would reduce nesting and\nseparates the filtering from the transformation phase. This comes with no cost to\nperformance and is just cleaner."
    },
    {
      "id": "clippy::readonly_write_lock",
      "name": "READONLY_WRITE_LOCK",
      "snake_name": "readonly_write_lock",
      "category": "perf",
      "weight": 1.0,
      "brief": "acquiring a write lock when a read lock would work",
      "what_it_does": "Looks for calls to `RwLock::write` where the lock is only used for reading.",
      "why_bad": "The write portion of `RwLock` is exclusive, meaning that no other thread\ncan access the lock while this writer is active.",
      "example": "```no_run\nuse std::sync::RwLock;\nfn assert_is_zero(lock: &RwLock<i32>) {\nlet num = lock.write().unwrap();\nassert_eq!(*num, 0);\n}\n```\n\nUse instead:\n```no_run\nuse std::sync::RwLock;\nfn assert_is_zero(lock: &RwLock<i32>) {\nlet num = lock.read().unwrap();\nassert_eq!(*num, 0);\n}\n```",
      "version": "1.73.0",
      "source_file": "mod.rs",
      "embedding_text": "acquiring a write lock when a read lock would work\n\nLooks for calls to `RwLock::write` where the lock is only used for reading.\n\nThe write portion of `RwLock` is exclusive, meaning that no other thread\ncan access the lock while this writer is active."
    },
    {
      "id": "clippy::iter_out_of_bounds",
      "name": "ITER_OUT_OF_BOUNDS",
      "snake_name": "iter_out_of_bounds",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "calls to `.take()` or `.skip()` that are out of bounds",
      "what_it_does": "Looks for iterator combinator calls such as `.take(x)` or `.skip(x)`\nwhere `x` is greater than the amount of items that an iterator will produce.",
      "why_bad": "Taking or skipping more items than there are in an iterator either creates an iterator\nwith all items from the original iterator or an iterator with no items at all.\nThis is most likely not what the user intended to do.",
      "example": "```no_run\nfor _ in [1, 2, 3].iter().take(4) {}\n```\nUse instead:\n```no_run\nfor _ in [1, 2, 3].iter() {}\n```",
      "version": "1.74.0",
      "source_file": "mod.rs",
      "embedding_text": "calls to `.take()` or `.skip()` that are out of bounds\n\nLooks for iterator combinator calls such as `.take(x)` or `.skip(x)`\nwhere `x` is greater than the amount of items that an iterator will produce.\n\nTaking or skipping more items than there are in an iterator either creates an iterator\nwith all items from the original iterator or an iterator with no items at all.\nThis is most likely not what the user intended to do."
    },
    {
      "id": "clippy::path_ends_with_ext",
      "name": "PATH_ENDS_WITH_EXT",
      "snake_name": "path_ends_with_ext",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "attempting to compare file extensions using `Path::ends_with`",
      "what_it_does": "Looks for calls to `Path::ends_with` calls where the argument looks like a file extension.\n\nBy default, Clippy has a short list of known filenames that start with a dot\nbut aren't necessarily file extensions (e.g. the `.git` folder), which are allowed by default.\nThe `allowed-dotfiles` configuration can be used to allow additional\nfile extensions that Clippy should not lint.",
      "why_bad": "This doesn't actually compare file extensions. Rather, `ends_with` compares the given argument\nto the last **component** of the path and checks if it matches exactly.",
      "example": "```no_run\n# use std::path::Path;\nfn is_markdown(path: &Path) -> bool {\npath.ends_with(\".md\")\n}\n```\nUse instead:\n```no_run\n# use std::path::Path;\nfn is_markdown(path: &Path) -> bool {\npath.extension().is_some_and(|ext| ext == \"md\")\n}\n```",
      "version": "1.74.0",
      "source_file": "mod.rs",
      "embedding_text": "attempting to compare file extensions using `Path::ends_with`\n\nLooks for calls to `Path::ends_with` calls where the argument looks like a file extension.\n\nBy default, Clippy has a short list of known filenames that start with a dot\nbut aren't necessarily file extensions (e.g. the `.git` folder), which are allowed by default.\nThe `allowed-dotfiles` configuration can be used to allow additional\nfile extensions that Clippy should not lint.\n\nThis doesn't actually compare file extensions. Rather, `ends_with` compares the given argument\nto the last **component** of the path and checks if it matches exactly."
    },
    {
      "id": "clippy::redundant_as_str",
      "name": "REDUNDANT_AS_STR",
      "snake_name": "redundant_as_str",
      "category": "complexity",
      "weight": 1.0,
      "brief": "`as_str` used to call a method on `str` that is also available on `String`",
      "what_it_does": "Checks for usage of `as_str()` on a `String` chained with a method available on the `String` itself.",
      "why_bad": "The `as_str()` conversion is pointless and can be removed for simplicity and cleanliness.",
      "example": "```no_run\nlet owned_string = \"This is a string\".to_owned();\nowned_string.as_str().as_bytes()\n# ;\n```\n\nUse instead:\n```no_run\nlet owned_string = \"This is a string\".to_owned();\nowned_string.as_bytes()\n# ;\n```",
      "version": "1.74.0",
      "source_file": "mod.rs",
      "embedding_text": "`as_str` used to call a method on `str` that is also available on `String`\n\nChecks for usage of `as_str()` on a `String` chained with a method available on the `String` itself.\n\nThe `as_str()` conversion is pointless and can be removed for simplicity and cleanliness."
    },
    {
      "id": "clippy::waker_clone_wake",
      "name": "WAKER_CLONE_WAKE",
      "snake_name": "waker_clone_wake",
      "category": "perf",
      "weight": 1.0,
      "brief": "cloning a `Waker` only to wake it",
      "what_it_does": "Checks for usage of `waker.clone().wake()`",
      "why_bad": "Cloning the waker is not necessary, `wake_by_ref()` enables the same operation\nwithout extra cloning/dropping.",
      "example": "```rust,ignore\nwaker.clone().wake();\n```\nShould be written\n```rust,ignore\nwaker.wake_by_ref();\n```",
      "version": "1.75.0",
      "source_file": "mod.rs",
      "embedding_text": "cloning a `Waker` only to wake it\n\nChecks for usage of `waker.clone().wake()`\n\nCloning the waker is not necessary, `wake_by_ref()` enables the same operation\nwithout extra cloning/dropping."
    },
    {
      "id": "clippy::unnecessary_fallible_conversions",
      "name": "UNNECESSARY_FALLIBLE_CONVERSIONS",
      "snake_name": "unnecessary_fallible_conversions",
      "category": "style",
      "weight": 0.95,
      "brief": "calling the `try_from` and `try_into` trait methods when `From`/`Into` is implemented",
      "what_it_does": "Checks for calls to `TryInto::try_into` and `TryFrom::try_from` when their infallible counterparts\ncould be used.",
      "why_bad": "In those cases, the `TryInto` and `TryFrom` trait implementation is a blanket impl that forwards\nto `Into` or `From`, which always succeeds.\nThe returned `Result<_, Infallible>` requires error handling to get the contained value\neven though the conversion can never fail.",
      "example": "```rust\nlet _: Result<i64, _> = 1i32.try_into();\nlet _: Result<i64, _> = <_>::try_from(1i32);\n```\nUse `from`/`into` instead:\n```rust\nlet _: i64 = 1i32.into();\nlet _: i64 = <_>::from(1i32);\n```",
      "version": "1.75.0",
      "source_file": "mod.rs",
      "embedding_text": "calling the `try_from` and `try_into` trait methods when `From`/`Into` is implemented\n\nChecks for calls to `TryInto::try_into` and `TryFrom::try_from` when their infallible counterparts\ncould be used.\n\nIn those cases, the `TryInto` and `TryFrom` trait implementation is a blanket impl that forwards\nto `Into` or `From`, which always succeeds.\nThe returned `Result<_, Infallible>` requires error handling to get the contained value\neven though the conversion can never fail."
    },
    {
      "id": "clippy::join_absolute_paths",
      "name": "JOIN_ABSOLUTE_PATHS",
      "snake_name": "join_absolute_paths",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "calls to `Path::join` which will overwrite the original path",
      "what_it_does": "Checks for calls to `Path::join` that start with a path separator (`\\\\` or `/`).",
      "why_bad": "If the argument to `Path::join` starts with a separator, it will overwrite\nthe original path. If this is intentional, prefer using `Path::new` instead.\n\nNote the behavior is platform dependent. A leading `\\\\` will be accepted\non unix systems as part of the file name\n\nSee [`Path::join`](https://doc.rust-lang.org/std/path/struct.Path.html#method.join)",
      "example": "```rust\n# use std::path::{Path, PathBuf};\nlet path = Path::new(\"/bin\");\nlet joined_path = path.join(\"/sh\");\nassert_eq!(joined_path, PathBuf::from(\"/sh\"));\n```\n\nUse instead;\n```rust\n# use std::path::{Path, PathBuf};\nlet path = Path::new(\"/bin\");\n\n// If this was unintentional, remove the leading separator\nlet joined_path = path.join(\"sh\");\nassert_eq!(joined_path, PathBuf::from(\"/bin/sh\"));\n\n// If this was intentional, create a new path instead\nlet new = Path::new(\"/sh\");\nassert_eq!(new, PathBuf::from(\"/sh\"));\n```",
      "version": "1.76.0",
      "source_file": "mod.rs",
      "embedding_text": "calls to `Path::join` which will overwrite the original path\n\nChecks for calls to `Path::join` that start with a path separator (`\\\\` or `/`).\n\nIf the argument to `Path::join` starts with a separator, it will overwrite\nthe original path. If this is intentional, prefer using `Path::new` instead.\n\nNote the behavior is platform dependent. A leading `\\\\` will be accepted\non unix systems as part of the file name\n\nSee [`Path::join`](https://doc.rust-lang.org/std/path/struct.Path.html#method.join)"
    },
    {
      "id": "clippy::result_filter_map",
      "name": "RESULT_FILTER_MAP",
      "snake_name": "result_filter_map",
      "category": "complexity",
      "weight": 1.0,
      "brief": "filtering `Result` for `Ok` then force-unwrapping, which can be one type-safe operation",
      "what_it_does": "Checks for iterators of `Result`s using `.filter(Result::is_ok).map(Result::unwrap)` that may\nbe replaced with a `.flatten()` call.",
      "why_bad": "`Result` implements `IntoIterator<Item = T>`. This means that `Result` can be flattened\nautomatically without suspicious-looking `unwrap` calls.",
      "example": "```no_run\nlet _ = std::iter::empty::<Result<i32, ()>>().filter(Result::is_ok).map(Result::unwrap);\n```\nUse instead:\n```no_run\nlet _ = std::iter::empty::<Result<i32, ()>>().flatten();\n```",
      "version": "1.77.0",
      "source_file": "mod.rs",
      "embedding_text": "filtering `Result` for `Ok` then force-unwrapping, which can be one type-safe operation\n\nChecks for iterators of `Result`s using `.filter(Result::is_ok).map(Result::unwrap)` that may\nbe replaced with a `.flatten()` call.\n\n`Result` implements `IntoIterator<Item = T>`. This means that `Result` can be flattened\nautomatically without suspicious-looking `unwrap` calls."
    },
    {
      "id": "clippy::iter_filter_is_some",
      "name": "ITER_FILTER_IS_SOME",
      "snake_name": "iter_filter_is_some",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "filtering an iterator over `Option`s for `Some` can be achieved with `flatten`",
      "what_it_does": "Checks for usage of `.filter(Option::is_some)` that may be replaced with a `.flatten()` call.\nThis lint will require additional changes to the follow-up calls as it affects the type.",
      "why_bad": "This pattern is often followed by manual unwrapping of the `Option`. The simplification\nresults in more readable and succinct code without the need for manual unwrapping.",
      "example": "```no_run\nvec![Some(1)].into_iter().filter(Option::is_some);\n\n```\nUse instead:\n```no_run\nvec![Some(1)].into_iter().flatten();\n```",
      "version": "1.77.0",
      "source_file": "mod.rs",
      "embedding_text": "filtering an iterator over `Option`s for `Some` can be achieved with `flatten`\n\nChecks for usage of `.filter(Option::is_some)` that may be replaced with a `.flatten()` call.\nThis lint will require additional changes to the follow-up calls as it affects the type.\n\nThis pattern is often followed by manual unwrapping of the `Option`. The simplification\nresults in more readable and succinct code without the need for manual unwrapping."
    },
    {
      "id": "clippy::iter_filter_is_ok",
      "name": "ITER_FILTER_IS_OK",
      "snake_name": "iter_filter_is_ok",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "filtering an iterator over `Result`s for `Ok` can be achieved with `flatten`",
      "what_it_does": "Checks for usage of `.filter(Result::is_ok)` that may be replaced with a `.flatten()` call.\nThis lint will require additional changes to the follow-up calls as it affects the type.",
      "why_bad": "This pattern is often followed by manual unwrapping of `Result`. The simplification\nresults in more readable and succinct code without the need for manual unwrapping.",
      "example": "```no_run\nvec![Ok::<i32, String>(1)].into_iter().filter(Result::is_ok);\n\n```\nUse instead:\n```no_run\nvec![Ok::<i32, String>(1)].into_iter().flatten();\n```",
      "version": "1.77.0",
      "source_file": "mod.rs",
      "embedding_text": "filtering an iterator over `Result`s for `Ok` can be achieved with `flatten`\n\nChecks for usage of `.filter(Result::is_ok)` that may be replaced with a `.flatten()` call.\nThis lint will require additional changes to the follow-up calls as it affects the type.\n\nThis pattern is often followed by manual unwrapping of `Result`. The simplification\nresults in more readable and succinct code without the need for manual unwrapping."
    },
    {
      "id": "clippy::manual_is_variant_and",
      "name": "MANUAL_IS_VARIANT_AND",
      "snake_name": "manual_is_variant_and",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "using `.map(f).unwrap_or_default()` or `.map(f) == Some/Ok(true)`, which are more succinctly expressed as `is_some_and(f)` or `is_ok_and(f)`",
      "what_it_does": "Checks for usage of `option.map(f).unwrap_or_default()` and `result.map(f).unwrap_or_default()` where f is a function or closure that returns the `bool` type.\nAlso checks for equality comparisons like `option.map(f) == Some(true)` and `result.map(f) == Ok(true)`.",
      "why_bad": "Readability. These can be written more concisely as `option.is_some_and(f)` and `result.is_ok_and(f)`.",
      "example": "```no_run\n# let option = Some(1);\n# let result: Result<usize, ()> = Ok(1);\noption.map(|a| a > 10).unwrap_or_default();\nresult.map(|a| a > 10).unwrap_or_default();\n\noption.map(|a| a > 10) == Some(true);\nresult.map(|a| a > 10) == Ok(true);\noption.map(|a| a > 10) != Some(true);\nresult.map(|a| a > 10) != Ok(true);\n```\nUse instead:\n```no_run\n# let option = Some(1);\n# let result: Result<usize, ()> = Ok(1);\noption.is_some_and(|a| a > 10);\nresult.is_ok_and(|a| a > 10);\n\noption.is_some_and(|a| a > 10);\nresult.is_ok_and(|a| a > 10);\noption.is_none_or(|a| a > 10);\n!result.is_ok_and(|a| a > 10);\n```",
      "version": "1.77.0",
      "source_file": "mod.rs",
      "embedding_text": "using `.map(f).unwrap_or_default()` or `.map(f) == Some/Ok(true)`, which are more succinctly expressed as `is_some_and(f)` or `is_ok_and(f)`\n\nChecks for usage of `option.map(f).unwrap_or_default()` and `result.map(f).unwrap_or_default()` where f is a function or closure that returns the `bool` type.\nAlso checks for equality comparisons like `option.map(f) == Some(true)` and `result.map(f) == Ok(true)`.\n\nReadability. These can be written more concisely as `option.is_some_and(f)` and `result.is_ok_and(f)`."
    },
    {
      "id": "clippy::str_split_at_newline",
      "name": "STR_SPLIT_AT_NEWLINE",
      "snake_name": "str_split_at_newline",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "splitting a trimmed string at hard-coded newlines",
      "what_it_does": "Checks for usages of `str.trim().split(\"\\n\")` and `str.trim().split(\"\\r\\n\")`.",
      "why_bad": "Hard-coding the line endings makes the code less compatible. `str.lines` should be used instead.",
      "example": "```no_run\n\"some\\ntext\\nwith\\nnewlines\\n\".trim().split('\\n');\n```\nUse instead:\n```no_run\n\"some\\ntext\\nwith\\nnewlines\\n\".lines();\n```",
      "version": "1.77.0",
      "source_file": "mod.rs",
      "embedding_text": "splitting a trimmed string at hard-coded newlines\n\nChecks for usages of `str.trim().split(\"\\n\")` and `str.trim().split(\"\\r\\n\")`.\n\nHard-coding the line endings makes the code less compatible. `str.lines` should be used instead."
    },
    {
      "id": "clippy::option_as_ref_cloned",
      "name": "OPTION_AS_REF_CLONED",
      "snake_name": "option_as_ref_cloned",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "cloning an `Option` via `as_ref().cloned()`",
      "what_it_does": "Checks for usage of `.as_ref().cloned()` and `.as_mut().cloned()` on `Option`s",
      "why_bad": "This can be written more concisely by cloning the `Option` directly.",
      "example": "```no_run\nfn foo(bar: &Option<Vec<u8>>) -> Option<Vec<u8>> {\nbar.as_ref().cloned()\n}\n```\nUse instead:\n```no_run\nfn foo(bar: &Option<Vec<u8>>) -> Option<Vec<u8>> {\nbar.clone()\n}\n```",
      "version": "1.77.0",
      "source_file": "mod.rs",
      "embedding_text": "cloning an `Option` via `as_ref().cloned()`\n\nChecks for usage of `.as_ref().cloned()` and `.as_mut().cloned()` on `Option`s\n\nThis can be written more concisely by cloning the `Option` directly."
    },
    {
      "id": "clippy::unnecessary_min_or_max",
      "name": "UNNECESSARY_MIN_OR_MAX",
      "snake_name": "unnecessary_min_or_max",
      "category": "complexity",
      "weight": 1.0,
      "brief": "using 'min()/max()' when there is no need for it",
      "what_it_does": "Checks for unnecessary calls to `min()` or `max()` in the following cases\n- Either both side is constant\n- One side is clearly larger than the other, like i32::MIN and an i32 variable",
      "why_bad": "In the aforementioned cases it is not necessary to call `min()` or `max()`\nto compare values, it may even cause confusion.",
      "example": "```no_run\nlet _ = 0.min(7_u32);\n```\nUse instead:\n```no_run\nlet _ = 0;\n```",
      "version": "1.81.0",
      "source_file": "mod.rs",
      "embedding_text": "using 'min()/max()' when there is no need for it\n\nChecks for unnecessary calls to `min()` or `max()` in the following cases\n- Either both side is constant\n- One side is clearly larger than the other, like i32::MIN and an i32 variable\n\nIn the aforementioned cases it is not necessary to call `min()` or `max()`\nto compare values, it may even cause confusion."
    },
    {
      "id": "clippy::unnecessary_result_map_or_else",
      "name": "UNNECESSARY_RESULT_MAP_OR_ELSE",
      "snake_name": "unnecessary_result_map_or_else",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "making no use of the \\",
      "what_it_does": "Checks for usage of `.map_or_else()` \"map closure\" for `Result` type.",
      "why_bad": "This can be written more concisely by using `unwrap_or_else()`.",
      "example": "```no_run\n# fn handle_error(_: ()) -> u32 { 0 }\nlet x: Result<u32, ()> = Ok(0);\nlet y = x.map_or_else(|err| handle_error(err), |n| n);\n```\nUse instead:\n```no_run\n# fn handle_error(_: ()) -> u32 { 0 }\nlet x: Result<u32, ()> = Ok(0);\nlet y = x.unwrap_or_else(|err| handle_error(err));\n```",
      "version": "1.78.0",
      "source_file": "mod.rs",
      "embedding_text": "making no use of the \\\n\nChecks for usage of `.map_or_else()` \"map closure\" for `Result` type.\n\nThis can be written more concisely by using `unwrap_or_else()`."
    },
    {
      "id": "clippy::unnecessary_get_then_check",
      "name": "UNNECESSARY_GET_THEN_CHECK",
      "snake_name": "unnecessary_get_then_check",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "calling `.get().is_some()` or `.get().is_none()` instead of `.contains()` or `.contains_key()`",
      "what_it_does": "Checks the usage of `.get().is_some()` or `.get().is_none()` on std map types.",
      "why_bad": "It can be done in one call with `.contains()`/`.contains_key()`.",
      "example": "```no_run\n# use std::collections::HashSet;\nlet s: HashSet<String> = HashSet::new();\nif s.get(\"a\").is_some() {\n// code\n}\n```\nUse instead:\n```no_run\n# use std::collections::HashSet;\nlet s: HashSet<String> = HashSet::new();\nif s.contains(\"a\") {\n// code\n}\n```",
      "version": "1.78.0",
      "source_file": "mod.rs",
      "embedding_text": "calling `.get().is_some()` or `.get().is_none()` instead of `.contains()` or `.contains_key()`\n\nChecks the usage of `.get().is_some()` or `.get().is_none()` on std map types.\n\nIt can be done in one call with `.contains()`/`.contains_key()`."
    },
    {
      "id": "clippy::const_is_empty",
      "name": "CONST_IS_EMPTY",
      "snake_name": "const_is_empty",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "is_empty() called on strings known at compile time",
      "what_it_does": "It identifies calls to `.is_empty()` on constant values.",
      "why_bad": "String literals and constant values are known at compile time. Checking if they\nare empty will always return the same value. This might not be the intention of\nthe expression.",
      "example": "```no_run\nlet value = \"\";\nif value.is_empty() {\nprintln!(\"the string is empty\");\n}\n```\nUse instead:\n```no_run\nprintln!(\"the string is empty\");\n```",
      "version": "1.79.0",
      "source_file": "mod.rs",
      "embedding_text": "is_empty() called on strings known at compile time\n\nIt identifies calls to `.is_empty()` on constant values.\n\nString literals and constant values are known at compile time. Checking if they\nare empty will always return the same value. This might not be the intention of\nthe expression."
    },
    {
      "id": "clippy::unnecessary_map_or",
      "name": "UNNECESSARY_MAP_OR",
      "snake_name": "unnecessary_map_or",
      "category": "style",
      "weight": 0.95,
      "brief": "reduce unnecessary calls to `.map_or(bool, \u2026)`",
      "what_it_does": "Converts some constructs mapping an Enum value for equality comparison.",
      "why_bad": "Calls such as `opt.map_or(false, |val| val == 5)` are needlessly long and cumbersome,\nand can be reduced to, for example, `opt == Some(5)` assuming `opt` implements `PartialEq`.\nAlso, calls such as `opt.map_or(true, |val| val == 5)` can be reduced to\n`opt.is_none_or(|val| val == 5)`.\nThis lint offers readability and conciseness improvements.",
      "example": "```no_run\npub fn a(x: Option<i32>) -> (bool, bool) {\n(\nx.map_or(false, |n| n == 5),\nx.map_or(true, |n| n > 5),\n)\n}\n```\nUse instead:\n```no_run\npub fn a(x: Option<i32>) -> (bool, bool) {\n(\nx == Some(5),\nx.is_none_or(|n| n > 5),\n)\n}\n```",
      "version": "1.84.0",
      "source_file": "mod.rs",
      "embedding_text": "reduce unnecessary calls to `.map_or(bool, \u2026)`\n\nConverts some constructs mapping an Enum value for equality comparison.\n\nCalls such as `opt.map_or(false, |val| val == 5)` are needlessly long and cumbersome,\nand can be reduced to, for example, `opt == Some(5)` assuming `opt` implements `PartialEq`.\nAlso, calls such as `opt.map_or(true, |val| val == 5)` can be reduced to\n`opt.is_none_or(|val| val == 5)`.\nThis lint offers readability and conciseness improvements."
    },
    {
      "id": "clippy::needless_character_iteration",
      "name": "NEEDLESS_CHARACTER_ITERATION",
      "snake_name": "needless_character_iteration",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "is_ascii() called on a char iterator",
      "what_it_does": "Checks if an iterator is used to check if a string is ascii.",
      "why_bad": "The `str` type already implements the `is_ascii` method.",
      "example": "```no_run\n\"foo\".chars().all(|c| c.is_ascii());\n```\nUse instead:\n```no_run\n\"foo\".is_ascii();\n```",
      "version": "1.81.0",
      "source_file": "mod.rs",
      "embedding_text": "is_ascii() called on a char iterator\n\nChecks if an iterator is used to check if a string is ascii.\n\nThe `str` type already implements the `is_ascii` method."
    },
    {
      "id": "clippy::manual_inspect",
      "name": "MANUAL_INSPECT",
      "snake_name": "manual_inspect",
      "category": "complexity",
      "weight": 1.0,
      "brief": "use of `map` returning the original item",
      "what_it_does": "Checks for uses of `map` which return the original item.",
      "why_bad": "`inspect` is both clearer in intent and shorter.",
      "example": "```no_run\nlet x = Some(0).map(|x| { println!(\"{x}\"); x });\n```\nUse instead:\n```no_run\nlet x = Some(0).inspect(|x| println!(\"{x}\"));\n```",
      "version": "1.81.0",
      "source_file": "mod.rs",
      "embedding_text": "use of `map` returning the original item\n\nChecks for uses of `map` which return the original item.\n\n`inspect` is both clearer in intent and shorter."
    },
    {
      "id": "clippy::unnecessary_first_then_check",
      "name": "UNNECESSARY_FIRST_THEN_CHECK",
      "snake_name": "unnecessary_first_then_check",
      "category": "complexity",
      "weight": 1.0,
      "brief": "calling `.first().is_some()` or `.first().is_none()` instead of `.is_empty()`",
      "what_it_does": "Checks the usage of `.first().is_some()` or `.first().is_none()` to check if a slice is\nempty.",
      "why_bad": "Using `.is_empty()` is shorter and better communicates the intention.",
      "example": "```no_run\nlet v = vec![1, 2, 3];\nif v.first().is_none() {\n// The vector is empty...\n}\n```\nUse instead:\n```no_run\nlet v = vec![1, 2, 3];\nif v.is_empty() {\n// The vector is empty...\n}\n```",
      "version": "1.83.0",
      "source_file": "mod.rs",
      "embedding_text": "calling `.first().is_some()` or `.first().is_none()` instead of `.is_empty()`\n\nChecks the usage of `.first().is_some()` or `.first().is_none()` to check if a slice is\nempty.\n\nUsing `.is_empty()` is shorter and better communicates the intention."
    },
    {
      "id": "clippy::needless_as_bytes",
      "name": "NEEDLESS_AS_BYTES",
      "snake_name": "needless_as_bytes",
      "category": "complexity",
      "weight": 1.0,
      "brief": "detect useless calls to `as_bytes()`",
      "what_it_does": "It detects useless calls to `str::as_bytes()` before calling `len()` or `is_empty()`.",
      "why_bad": "The `len()` and `is_empty()` methods are also directly available on strings, and they\nreturn identical results. In particular, `len()` on a string returns the number of\nbytes.",
      "example": "```\nlet len = \"some string\".as_bytes().len();\nlet b = \"some string\".as_bytes().is_empty();\n```\nUse instead:\n```\nlet len = \"some string\".len();\nlet b = \"some string\".is_empty();\n```",
      "version": "1.84.0",
      "source_file": "mod.rs",
      "embedding_text": "detect useless calls to `as_bytes()`\n\nIt detects useless calls to `str::as_bytes()` before calling `len()` or `is_empty()`.\n\nThe `len()` and `is_empty()` methods are also directly available on strings, and they\nreturn identical results. In particular, `len()` on a string returns the number of\nbytes."
    },
    {
      "id": "clippy::map_all_any_identity",
      "name": "MAP_ALL_ANY_IDENTITY",
      "snake_name": "map_all_any_identity",
      "category": "complexity",
      "weight": 1.0,
      "brief": "combine `.map(_)` followed by `.all(identity)`/`.any(identity)` into a single call",
      "what_it_does": "Checks for usage of `.map(\u2026)`, followed by `.all(identity)` or `.any(identity)`.",
      "why_bad": "The `.all(\u2026)` or `.any(\u2026)` methods can be called directly in place of `.map(\u2026)`.",
      "example": "```\n# let mut v = [\"\"];\nlet e1 = v.iter().map(|s| s.is_empty()).all(|a| a);\nlet e2 = v.iter().map(|s| s.is_empty()).any(std::convert::identity);\n```\nUse instead:\n```\n# let mut v = [\"\"];\nlet e1 = v.iter().all(|s| s.is_empty());\nlet e2 = v.iter().any(|s| s.is_empty());\n```",
      "version": "1.84.0",
      "source_file": "mod.rs",
      "embedding_text": "combine `.map(_)` followed by `.all(identity)`/`.any(identity)` into a single call\n\nChecks for usage of `.map(\u2026)`, followed by `.all(identity)` or `.any(identity)`.\n\nThe `.all(\u2026)` or `.any(\u2026)` methods can be called directly in place of `.map(\u2026)`."
    },
    {
      "id": "clippy::map_with_unused_argument_over_ranges",
      "name": "MAP_WITH_UNUSED_ARGUMENT_OVER_RANGES",
      "snake_name": "map_with_unused_argument_over_ranges",
      "category": "restriction",
      "weight": 1.0,
      "brief": "map of a trivial closure (not dependent on parameter) over a range",
      "what_it_does": "Checks for `Iterator::map` over ranges without using the parameter which\ncould be more clearly expressed using `std::iter::repeat(...).take(...)`\nor `std::iter::repeat_n`.",
      "why_bad": "It expresses the intent more clearly to `take` the correct number of times\nfrom a generating function than to apply a closure to each number in a\nrange only to discard them.",
      "example": "```no_run\nlet random_numbers : Vec<_> = (0..10).map(|_| { 3 + 1 }).collect();\n```\nUse instead:\n```no_run\nlet f : Vec<_> = std::iter::repeat( 3 + 1 ).take(10).collect();\n```",
      "version": "1.84.0",
      "source_file": "mod.rs",
      "embedding_text": "map of a trivial closure (not dependent on parameter) over a range\n\nChecks for `Iterator::map` over ranges without using the parameter which\ncould be more clearly expressed using `std::iter::repeat(...).take(...)`\nor `std::iter::repeat_n`.\n\nIt expresses the intent more clearly to `take` the correct number of times\nfrom a generating function than to apply a closure to each number in a\nrange only to discard them."
    },
    {
      "id": "clippy::double_ended_iterator_last",
      "name": "DOUBLE_ENDED_ITERATOR_LAST",
      "snake_name": "double_ended_iterator_last",
      "category": "perf",
      "weight": 1.0,
      "brief": "using `Iterator::last` on a `DoubleEndedIterator`",
      "what_it_does": "Checks for `Iterator::last` being called on a  `DoubleEndedIterator`, which can be replaced\nwith `DoubleEndedIterator::next_back`.",
      "why_bad": "`Iterator::last` is implemented by consuming the iterator, which is unnecessary if\nthe iterator is a `DoubleEndedIterator`. Since Rust traits do not allow specialization,\n`Iterator::last` cannot be optimized for `DoubleEndedIterator`.",
      "example": "```no_run\nlet last_arg = \"echo hello world\".split(' ').last();\n```\nUse instead:\n```no_run\nlet last_arg = \"echo hello world\".split(' ').next_back();\n```",
      "version": "1.86.0",
      "source_file": "mod.rs",
      "embedding_text": "using `Iterator::last` on a `DoubleEndedIterator`\n\nChecks for `Iterator::last` being called on a  `DoubleEndedIterator`, which can be replaced\nwith `DoubleEndedIterator::next_back`.\n\n`Iterator::last` is implemented by consuming the iterator, which is unnecessary if\nthe iterator is a `DoubleEndedIterator`. Since Rust traits do not allow specialization,\n`Iterator::last` cannot be optimized for `DoubleEndedIterator`."
    },
    {
      "id": "clippy::useless_nonzero_new_unchecked",
      "name": "USELESS_NONZERO_NEW_UNCHECKED",
      "snake_name": "useless_nonzero_new_unchecked",
      "category": "complexity",
      "weight": 1.0,
      "brief": "using `NonZero::new_unchecked()` in a `const` context",
      "what_it_does": "Checks for `NonZero*::new_unchecked()` being used in a `const` context.",
      "why_bad": "Using `NonZero*::new_unchecked()` is an `unsafe` function and requires an `unsafe` context. When used in a\ncontext evaluated at compilation time, `NonZero*::new().unwrap()` will provide the same result with identical\nruntime performances while not requiring `unsafe`.",
      "example": "```no_run\nuse std::num::NonZeroUsize;\nconst PLAYERS: NonZeroUsize = unsafe { NonZeroUsize::new_unchecked(3) };\n```\nUse instead:\n```no_run\nuse std::num::NonZeroUsize;\nconst PLAYERS: NonZeroUsize = NonZeroUsize::new(3).unwrap();\n```",
      "version": "1.86.0",
      "source_file": "mod.rs",
      "embedding_text": "using `NonZero::new_unchecked()` in a `const` context\n\nChecks for `NonZero*::new_unchecked()` being used in a `const` context.\n\nUsing `NonZero*::new_unchecked()` is an `unsafe` function and requires an `unsafe` context. When used in a\ncontext evaluated at compilation time, `NonZero*::new().unwrap()` will provide the same result with identical\nruntime performances while not requiring `unsafe`."
    },
    {
      "id": "clippy::manual_repeat_n",
      "name": "MANUAL_REPEAT_N",
      "snake_name": "manual_repeat_n",
      "category": "style",
      "weight": 0.95,
      "brief": "detect `repeat().take()` that can be replaced with `repeat_n()`",
      "what_it_does": "Checks for `repeat().take()` that can be replaced with `repeat_n()`.",
      "why_bad": "Using `repeat_n()` is more concise and clearer. Also, `repeat_n()` is sometimes faster than `repeat().take()` when the type of the element is non-trivial to clone because the original value can be reused for the last `.next()` call rather than always cloning.",
      "example": "```no_run\nlet _ = std::iter::repeat(10).take(3);\n```\nUse instead:\n```no_run\nlet _ = std::iter::repeat_n(10, 3);\n```",
      "version": "1.86.0",
      "source_file": "mod.rs",
      "embedding_text": "detect `repeat().take()` that can be replaced with `repeat_n()`\n\nChecks for `repeat().take()` that can be replaced with `repeat_n()`.\n\nUsing `repeat_n()` is more concise and clearer. Also, `repeat_n()` is sometimes faster than `repeat().take()` when the type of the element is non-trivial to clone because the original value can be reused for the last `.next()` call rather than always cloning."
    },
    {
      "id": "clippy::sliced_string_as_bytes",
      "name": "SLICED_STRING_AS_BYTES",
      "snake_name": "sliced_string_as_bytes",
      "category": "perf",
      "weight": 1.0,
      "brief": "slicing a string and immediately calling as_bytes is less efficient and can lead to panics",
      "what_it_does": "Checks for string slices immediately followed by `as_bytes`.",
      "why_bad": "It involves doing an unnecessary UTF-8 alignment check which is less efficient, and can cause a panic.",
      "example": "```rust\nlet s = \"Lorem ipsum\";\ns[1..5].as_bytes();\n```\nUse instead:\n```rust\nlet s = \"Lorem ipsum\";\n&s.as_bytes()[1..5];\n```",
      "version": "1.86.0",
      "source_file": "mod.rs",
      "embedding_text": "slicing a string and immediately calling as_bytes is less efficient and can lead to panics\n\nChecks for string slices immediately followed by `as_bytes`.\n\nIt involves doing an unnecessary UTF-8 alignment check which is less efficient, and can cause a panic."
    },
    {
      "id": "clippy::return_and_then",
      "name": "RETURN_AND_THEN",
      "snake_name": "return_and_then",
      "category": "restriction",
      "weight": 1.0,
      "brief": "using `Option::and_then` or `Result::and_then` to chain a computation that returns an `Option` or a `Result`",
      "what_it_does": "Detect functions that end with `Option::and_then` or `Result::and_then`, and suggest using\nthe `?` operator instead.",
      "why_bad": "The `and_then` method is used to chain a computation that returns an `Option` or a `Result`.\nThis can be replaced with the `?` operator, which is more concise and idiomatic.",
      "example": "```no_run\nfn test(opt: Option<i32>) -> Option<i32> {\nopt.and_then(|n| {\nif n > 1 {\nSome(n + 1)\n} else {\nNone\n}\n})\n}\n```\nUse instead:\n```no_run\nfn test(opt: Option<i32>) -> Option<i32> {\nlet n = opt?;\nif n > 1 {\nSome(n + 1)\n} else {\nNone\n}\n}\n```",
      "version": "1.86.0",
      "source_file": "mod.rs",
      "embedding_text": "using `Option::and_then` or `Result::and_then` to chain a computation that returns an `Option` or a `Result`\n\nDetect functions that end with `Option::and_then` or `Result::and_then`, and suggest using\nthe `?` operator instead.\n\nThe `and_then` method is used to chain a computation that returns an `Option` or a `Result`.\nThis can be replaced with the `?` operator, which is more concise and idiomatic."
    },
    {
      "id": "clippy::unbuffered_bytes",
      "name": "UNBUFFERED_BYTES",
      "snake_name": "unbuffered_bytes",
      "category": "perf",
      "weight": 1.0,
      "brief": "calling .bytes() is very inefficient when data is not in memory",
      "what_it_does": "Checks for calls to `Read::bytes` on types which don't implement `BufRead`.",
      "why_bad": "The default implementation calls `read` for each byte, which can be very inefficient for data that's not in memory, such as `File`.",
      "example": "```no_run\nuse std::io::Read;\nuse std::fs::File;\nlet file = File::open(\"./bytes.txt\").unwrap();\nfile.bytes();\n```\nUse instead:\n```no_run\nuse std::io::{BufReader, Read};\nuse std::fs::File;\nlet file = BufReader::new(File::open(\"./bytes.txt\").unwrap());\nfile.bytes();\n```",
      "version": "1.87.0",
      "source_file": "mod.rs",
      "embedding_text": "calling .bytes() is very inefficient when data is not in memory\n\nChecks for calls to `Read::bytes` on types which don't implement `BufRead`.\n\nThe default implementation calls `read` for each byte, which can be very inefficient for data that's not in memory, such as `File`."
    },
    {
      "id": "clippy::manual_contains",
      "name": "MANUAL_CONTAINS",
      "snake_name": "manual_contains",
      "category": "perf",
      "weight": 1.0,
      "brief": "unnecessary `iter().any()` on slices that can be replaced with `contains()`",
      "what_it_does": "Checks for usage of `iter().any()` on slices when it can be replaced with `contains()` and suggests doing so.",
      "why_bad": "`contains()` is more concise and idiomatic, while also being faster in some cases.",
      "example": "```no_run\nfn foo(values: &[u8]) -> bool {\nvalues.iter().any(|&v| v == 10)\n}\n```\nUse instead:\n```no_run\nfn foo(values: &[u8]) -> bool {\nvalues.contains(&10)\n}\n```",
      "version": "1.87.0",
      "source_file": "mod.rs",
      "embedding_text": "unnecessary `iter().any()` on slices that can be replaced with `contains()`\n\nChecks for usage of `iter().any()` on slices when it can be replaced with `contains()` and suggests doing so.\n\n`contains()` is more concise and idiomatic, while also being faster in some cases."
    },
    {
      "id": "clippy::io_other_error",
      "name": "IO_OTHER_ERROR",
      "snake_name": "io_other_error",
      "category": "style",
      "weight": 0.95,
      "brief": "calling `std::io::Error::new(std::io::ErrorKind::Other, _)`",
      "what_it_does": "",
      "why_bad": "Since Rust 1.74, there's the `io::Error::other(_)` shortcut.",
      "example": "```no_run\nuse std::io;\nlet _ = io::Error::new(io::ErrorKind::Other, \"bad\".to_string());\n```\nUse instead:\n```no_run\nlet _ = std::io::Error::other(\"bad\".to_string());\n```",
      "version": "1.87.0",
      "source_file": "mod.rs",
      "embedding_text": "calling `std::io::Error::new(std::io::ErrorKind::Other, _)`\n\n\n\nSince Rust 1.74, there's the `io::Error::other(_)` shortcut."
    },
    {
      "id": "clippy::swap_with_temporary",
      "name": "SWAP_WITH_TEMPORARY",
      "snake_name": "swap_with_temporary",
      "category": "complexity",
      "weight": 1.0,
      "brief": "detect swap with a temporary value",
      "what_it_does": "Checks for usage of `std::mem::swap` with temporary values.",
      "why_bad": "Storing a new value in place of a temporary value which will\nbe dropped right after the `swap` is an inefficient way of performing\nan assignment. The same result can be achieved by using a regular\nassignment.",
      "example": "```no_run\nfn replace_string(s: &mut String) {\nstd::mem::swap(s, &mut String::from(\"replaced\"));\n}\n```\nUse instead:\n```no_run\nfn replace_string(s: &mut String) {\n*s = String::from(\"replaced\");\n}\n```\n\nAlso, swapping two temporary values has no effect, as they will\nboth be dropped right after swapping them. This is likely an indication\nof a bug. For example, the following code swaps the references to\nthe last element of the vectors, instead of swapping the elements\nthemselves:\n\n```no_run\nfn bug(v1: &mut [i32], v2: &mut [i32]) {\n// Incorrect: swapping temporary references (`&mut &mut` passed to swap)\nstd::mem::swap(&mut v1.last_mut().unwrap(), &mut v2.last_mut().unwrap());\n}\n```\nUse instead:\n```no_run\nfn correct(v1: &mut [i32], v2: &mut [i32]) {\nstd::mem::swap(v1.last_mut().unwrap(), v2.last_mut().unwrap());\n}\n```",
      "version": "1.88.0",
      "source_file": "mod.rs",
      "embedding_text": "detect swap with a temporary value\n\nChecks for usage of `std::mem::swap` with temporary values.\n\nStoring a new value in place of a temporary value which will\nbe dropped right after the `swap` is an inefficient way of performing\nan assignment. The same result can be achieved by using a regular\nassignment."
    },
    {
      "id": "clippy::ip_constant",
      "name": "IP_CONSTANT",
      "snake_name": "ip_constant",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "hardcoded localhost IP address",
      "what_it_does": "Checks for IP addresses that could be replaced with predefined constants such as\n`Ipv4Addr::new(127, 0, 0, 1)` instead of using the appropriate constants.",
      "why_bad": "Using specific IP addresses like `127.0.0.1` or `::1` is less clear and less maintainable than using the\npredefined constants `Ipv4Addr::LOCALHOST` or `Ipv6Addr::LOCALHOST`. These constants improve code\nreadability, make the intent explicit, and are less error-prone.",
      "example": "```no_run\nuse std::net::{Ipv4Addr, Ipv6Addr};\n\n// IPv4 loopback\nlet addr_v4 = Ipv4Addr::new(127, 0, 0, 1);\n\n// IPv6 loopback\nlet addr_v6 = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1);\n```\nUse instead:\n```no_run\nuse std::net::{Ipv4Addr, Ipv6Addr};\n\n// IPv4 loopback\nlet addr_v4 = Ipv4Addr::LOCALHOST;\n\n// IPv6 loopback\nlet addr_v6 = Ipv6Addr::LOCALHOST;\n```",
      "version": "1.89.0",
      "source_file": "mod.rs",
      "embedding_text": "hardcoded localhost IP address\n\nChecks for IP addresses that could be replaced with predefined constants such as\n`Ipv4Addr::new(127, 0, 0, 1)` instead of using the appropriate constants.\n\nUsing specific IP addresses like `127.0.0.1` or `::1` is less clear and less maintainable than using the\npredefined constants `Ipv4Addr::LOCALHOST` or `Ipv6Addr::LOCALHOST`. These constants improve code\nreadability, make the intent explicit, and are less error-prone."
    },
    {
      "id": "clippy::redundant_iter_cloned",
      "name": "REDUNDANT_ITER_CLONED",
      "snake_name": "redundant_iter_cloned",
      "category": "perf",
      "weight": 1.0,
      "brief": "detects redundant calls to `Iterator::cloned`",
      "what_it_does": "Checks for calls to `Iterator::cloned` where the original value could be used\ninstead.",
      "why_bad": "It is not always possible for the compiler to eliminate useless allocations and\ndeallocations generated by redundant `clone()`s.",
      "example": "```no_run\nlet x = vec![String::new()];\nlet _ = x.iter().cloned().map(|x| x.len());\n```\nUse instead:\n```no_run\nlet x = vec![String::new()];\nlet _ = x.iter().map(|x| x.len());\n```",
      "version": "1.92.0",
      "source_file": "mod.rs",
      "embedding_text": "detects redundant calls to `Iterator::cloned`\n\nChecks for calls to `Iterator::cloned` where the original value could be used\ninstead.\n\nIt is not always possible for the compiler to eliminate useless allocations and\ndeallocations generated by redundant `clone()`s."
    },
    {
      "id": "clippy::unnecessary_option_map_or_else",
      "name": "UNNECESSARY_OPTION_MAP_OR_ELSE",
      "snake_name": "unnecessary_option_map_or_else",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "making no use of the \\",
      "what_it_does": "",
      "why_bad": "This can be written more concisely by using `unwrap_or_else()`.",
      "example": "```no_run\nlet k = 10;\nlet x: Option<u32> = Some(4);\nlet y = x.map_or_else(|| 2 * k, |n| n);\n```\nUse instead:\n```no_run\nlet k = 10;\nlet x: Option<u32> = Some(4);\nlet y = x.unwrap_or_else(|| 2 * k);\n```",
      "version": "1.92.0",
      "source_file": "mod.rs",
      "embedding_text": "making no use of the \\\n\n\n\nThis can be written more concisely by using `unwrap_or_else()`."
    },
    {
      "id": "clippy::lines_filter_map_ok",
      "name": "LINES_FILTER_MAP_OK",
      "snake_name": "lines_filter_map_ok",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "filtering `std::io::Lines` with `filter_map()`, `flat_map()`, or `flatten()` might cause an infinite loop",
      "what_it_does": "Checks for usage of `lines.filter_map(Result::ok)` or `lines.flat_map(Result::ok)`\nwhen `lines` has type `std::io::Lines`.",
      "why_bad": "`Lines` instances might produce a never-ending stream of `Err`, in which case\n`filter_map(Result::ok)` will enter an infinite loop while waiting for an\n`Ok` variant. Calling `next()` once is sufficient to enter the infinite loop,\neven in the absence of explicit loops in the user code.\n\nThis situation can arise when working with user-provided paths. On some platforms,\n`std::fs::File::open(path)` might return `Ok(fs)` even when `path` is a directory,\nbut any later attempt to read from `fs` will return an error.",
      "example": "```no_run\n# use std::{fs::File, io::{self, BufRead, BufReader}};\n# let _ = || -> io::Result<()> {\nlet mut lines = BufReader::new(File::open(\"some-path\")?).lines().filter_map(Result::ok);\n// If \"some-path\" points to a directory, the next statement never terminates:\nlet first_line: Option<String> = lines.next();\n# Ok(()) };\n```\nUse instead:\n```no_run\n# use std::{fs::File, io::{self, BufRead, BufReader}};\n# let _ = || -> io::Result<()> {\nlet mut lines = BufReader::new(File::open(\"some-path\")?).lines().map_while(Result::ok);\nlet first_line: Option<String> = lines.next();\n# Ok(()) };\n```",
      "version": "1.70.0",
      "source_file": "mod.rs",
      "embedding_text": "filtering `std::io::Lines` with `filter_map()`, `flat_map()`, or `flatten()` might cause an infinite loop\n\nChecks for usage of `lines.filter_map(Result::ok)` or `lines.flat_map(Result::ok)`\nwhen `lines` has type `std::io::Lines`.\n\n`Lines` instances might produce a never-ending stream of `Err`, in which case\n`filter_map(Result::ok)` will enter an infinite loop while waiting for an\n`Ok` variant. Calling `next()` once is sufficient to enter the infinite loop,\neven in the absence of explicit loops in the user code.\n\nThis situation can arise when working with user-provided paths. On some platforms,\n`std::fs::File::open(path)` might return `Ok(fs)` even when `path` is a directory,\nbut any later attempt to read from `fs` will return an error."
    },
    {
      "id": "clippy::min_ident_chars",
      "name": "MIN_IDENT_CHARS",
      "snake_name": "min_ident_chars",
      "category": "restriction",
      "weight": 1.0,
      "brief": "disallows idents that are too short",
      "what_it_does": "Checks for identifiers which consist of a single character (or fewer than the configured threshold).\n\nNote: This lint can be very noisy when enabled; it may be desirable to only enable it\ntemporarily.",
      "why_bad": "To improve readability by requiring that every variable has a name more specific than a single letter can be.",
      "example": "```rust,ignore\nfor m in movies {\nlet title = m.t;\n}\n```\nUse instead:\n```rust,ignore\nfor movie in movies {\nlet title = movie.title;\n}\n```",
      "version": "1.72.0",
      "source_file": "min_ident_chars.rs",
      "embedding_text": "disallows idents that are too short\n\nChecks for identifiers which consist of a single character (or fewer than the configured threshold).\n\nNote: This lint can be very noisy when enabled; it may be desirable to only enable it\ntemporarily.\n\nTo improve readability by requiring that every variable has a name more specific than a single letter can be."
    },
    {
      "id": "clippy::min_max",
      "name": "MIN_MAX",
      "snake_name": "min_max",
      "category": "correctness",
      "weight": 1.2,
      "brief": "`min(_, max(_, _))` (or vice versa) with bounds clamping the result to a constant",
      "what_it_does": "Checks for expressions where `std::cmp::min` and `max` are\nused to clamp values, but switched so that the result is constant.",
      "why_bad": "This is in all probability not the intended outcome. At\nthe least it hurts readability of the code.",
      "example": "```rust,ignore\nmin(0, max(100, x))\n\n// or\n\nx.max(100).min(0)\n```\nIt will always be equal to `0`. Probably the author meant to clamp the value\nbetween 0 and 100, but has erroneously swapped `min` and `max`.",
      "version": "pre 1.29.0",
      "source_file": "minmax.rs",
      "embedding_text": "`min(_, max(_, _))` (or vice versa) with bounds clamping the result to a constant\n\nChecks for expressions where `std::cmp::min` and `max` are\nused to clamp values, but switched so that the result is constant.\n\nThis is in all probability not the intended outcome. At\nthe least it hurts readability of the code."
    },
    {
      "id": "clippy::used_underscore_binding",
      "name": "USED_UNDERSCORE_BINDING",
      "snake_name": "used_underscore_binding",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "using a binding which is prefixed with an underscore",
      "what_it_does": "Checks for the use of bindings with a single leading\nunderscore.",
      "why_bad": "A single leading underscore is usually used to indicate\nthat a binding will not be used. Using such a binding breaks this\nexpectation.",
      "example": "```no_run\nlet _x = 0;\nlet y = _x + 1; // Here we are using `_x`, even though it has a leading\n// underscore. We should rename `_x` to `x`\n```",
      "version": "pre 1.29.0",
      "source_file": "misc.rs",
      "embedding_text": "using a binding which is prefixed with an underscore\n\nChecks for the use of bindings with a single leading\nunderscore.\n\nA single leading underscore is usually used to indicate\nthat a binding will not be used. Using such a binding breaks this\nexpectation."
    },
    {
      "id": "clippy::used_underscore_items",
      "name": "USED_UNDERSCORE_ITEMS",
      "snake_name": "used_underscore_items",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "using a item which is prefixed with an underscore",
      "what_it_does": "Checks for the use of item with a single leading\nunderscore.",
      "why_bad": "A single leading underscore is usually used to indicate\nthat a item will not be used. Using such a item breaks this\nexpectation.",
      "example": "```no_run\nfn _foo() {}\n\nstruct _FooStruct {}\n\nfn main() {\n_foo();\nlet _ = _FooStruct{};\n}\n```\n\nUse instead:\n```no_run\nfn foo() {}\n\nstruct FooStruct {}\n\nfn main() {\nfoo();\nlet _ = FooStruct{};\n}\n```",
      "version": "1.83.0",
      "source_file": "misc.rs",
      "embedding_text": "using a item which is prefixed with an underscore\n\nChecks for the use of item with a single leading\nunderscore.\n\nA single leading underscore is usually used to indicate\nthat a item will not be used. Using such a item breaks this\nexpectation."
    },
    {
      "id": "clippy::short_circuit_statement",
      "name": "SHORT_CIRCUIT_STATEMENT",
      "snake_name": "short_circuit_statement",
      "category": "complexity",
      "weight": 1.0,
      "brief": "using a short circuit boolean condition as a statement",
      "what_it_does": "Checks for the use of short circuit boolean conditions as\na\nstatement.",
      "why_bad": "Using a short circuit boolean condition as a statement\nmay hide the fact that the second part is executed or not depending on the\noutcome of the first part.",
      "example": "```rust,ignore\nf() && g(); // We should write `if f() { g(); }`.\n```",
      "version": "pre 1.29.0",
      "source_file": "misc.rs",
      "embedding_text": "using a short circuit boolean condition as a statement\n\nChecks for the use of short circuit boolean conditions as\na\nstatement.\n\nUsing a short circuit boolean condition as a statement\nmay hide the fact that the second part is executed or not depending on the\noutcome of the first part."
    },
    {
      "id": "clippy::unneeded_field_pattern",
      "name": "UNNEEDED_FIELD_PATTERN",
      "snake_name": "unneeded_field_pattern",
      "category": "restriction",
      "weight": 1.0,
      "brief": "struct fields bound to a wildcard instead of using `..`",
      "what_it_does": "Checks for structure field patterns bound to wildcards.",
      "why_bad": "Using `..` instead is shorter and leaves the focus on\nthe fields that are actually bound.",
      "example": "```no_run\n# struct Foo {\n#     a: i32,\n#     b: i32,\n#     c: i32,\n# }\nlet f = Foo { a: 0, b: 0, c: 0 };\n\nmatch f {\nFoo { a: _, b: 0, .. } => {},\nFoo { a: _, b: _, c: _ } => {},\n}\n```\n\nUse instead:\n```no_run\n# struct Foo {\n#     a: i32,\n#     b: i32,\n#     c: i32,\n# }\nlet f = Foo { a: 0, b: 0, c: 0 };\n\nmatch f {\nFoo { b: 0, .. } => {},\nFoo { .. } => {},\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "struct fields bound to a wildcard instead of using `..`\n\nChecks for structure field patterns bound to wildcards.\n\nUsing `..` instead is shorter and leaves the focus on\nthe fields that are actually bound."
    },
    {
      "id": "clippy::mixed_case_hex_literals",
      "name": "MIXED_CASE_HEX_LITERALS",
      "snake_name": "mixed_case_hex_literals",
      "category": "style",
      "weight": 0.95,
      "brief": "hex literals whose letter digits are not consistently upper- or lowercased",
      "what_it_does": "Warns on hexadecimal literals with mixed-case letter\ndigits.",
      "why_bad": "It looks confusing.",
      "example": "```no_run\n# let _ =\n0x1a9BAcD\n# ;\n```\n\nUse instead:\n```no_run\n# let _ =\n0x1A9BACD\n# ;\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "hex literals whose letter digits are not consistently upper- or lowercased\n\nWarns on hexadecimal literals with mixed-case letter\ndigits.\n\nIt looks confusing."
    },
    {
      "id": "clippy::unseparated_literal_suffix",
      "name": "UNSEPARATED_LITERAL_SUFFIX",
      "snake_name": "unseparated_literal_suffix",
      "category": "restriction",
      "weight": 1.0,
      "brief": "literals whose suffix is not separated by an underscore",
      "what_it_does": "Warns if literal suffixes are not separated by an\nunderscore.\nTo enforce unseparated literal suffix style,\nsee the `separated_literal_suffix` lint.",
      "why_bad": "Suffix style should be consistent.",
      "example": "```no_run\n# let _ =\n123832i32\n# ;\n```\n\nUse instead:\n```no_run\n# let _ =\n123832_i32\n# ;\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "literals whose suffix is not separated by an underscore\n\nWarns if literal suffixes are not separated by an\nunderscore.\nTo enforce unseparated literal suffix style,\nsee the `separated_literal_suffix` lint.\n\nSuffix style should be consistent."
    },
    {
      "id": "clippy::separated_literal_suffix",
      "name": "SEPARATED_LITERAL_SUFFIX",
      "snake_name": "separated_literal_suffix",
      "category": "restriction",
      "weight": 1.0,
      "brief": "literals whose suffix is separated by an underscore",
      "what_it_does": "Warns if literal suffixes are separated by an underscore.\nTo enforce separated literal suffix style,\nsee the `unseparated_literal_suffix` lint.",
      "why_bad": "Suffix style should be consistent.",
      "example": "```no_run\n# let _ =\n123832_i32\n# ;\n```\n\nUse instead:\n```no_run\n# let _ =\n123832i32\n# ;\n```",
      "version": "1.58.0",
      "source_file": "mod.rs",
      "embedding_text": "literals whose suffix is separated by an underscore\n\nWarns if literal suffixes are separated by an underscore.\nTo enforce separated literal suffix style,\nsee the `unseparated_literal_suffix` lint.\n\nSuffix style should be consistent."
    },
    {
      "id": "clippy::zero_prefixed_literal",
      "name": "ZERO_PREFIXED_LITERAL",
      "snake_name": "zero_prefixed_literal",
      "category": "complexity",
      "weight": 1.0,
      "brief": "integer literals starting with `0`",
      "what_it_does": "Warns if an integral constant literal starts with `0`.",
      "why_bad": "In some languages (including the infamous C language\nand most of its\nfamily), this marks an octal constant. In Rust however, this is a decimal\nconstant. This could\nbe confusing for both the writer and a reader of the constant.",
      "example": "In Rust:\n```no_run\nfn main() {\nlet a = 0123;\nprintln!(\"{}\", a);\n}\n```\n\nprints `123`, while in C:\n\n```c\n#include <stdio.h>\n\nint main() {\nint a = 0123;\nprintf(\"%d\\n\", a);\n}\n```\n\nprints `83` (as `83 == 0o123` while `123 == 0o173`).",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "integer literals starting with `0`\n\nWarns if an integral constant literal starts with `0`.\n\nIn some languages (including the infamous C language\nand most of its\nfamily), this marks an octal constant. In Rust however, this is a decimal\nconstant. This could\nbe confusing for both the writer and a reader of the constant."
    },
    {
      "id": "clippy::builtin_type_shadow",
      "name": "BUILTIN_TYPE_SHADOW",
      "snake_name": "builtin_type_shadow",
      "category": "style",
      "weight": 0.95,
      "brief": "shadowing a builtin type",
      "what_it_does": "Warns if a generic shadows a built-in type.",
      "why_bad": "This gives surprising type errors.",
      "example": "```ignore\nimpl<u32> Foo<u32> {\nfn impl_func(&self) -> u32 {\n42\n}\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "shadowing a builtin type\n\nWarns if a generic shadows a built-in type.\n\nThis gives surprising type errors."
    },
    {
      "id": "clippy::redundant_pattern",
      "name": "REDUNDANT_PATTERN",
      "snake_name": "redundant_pattern",
      "category": "style",
      "weight": 0.95,
      "brief": "using `name @ _` in a pattern",
      "what_it_does": "Checks for patterns in the form `name @ _`.",
      "why_bad": "It's almost always more readable to just use direct\nbindings.",
      "example": "```no_run\n# let v = Some(\"abc\");\nmatch v {\nSome(x) => (),\ny @ _ => (),\n}\n```\n\nUse instead:\n```no_run\n# let v = Some(\"abc\");\nmatch v {\nSome(x) => (),\ny => (),\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "using `name @ _` in a pattern\n\nChecks for patterns in the form `name @ _`.\n\nIt's almost always more readable to just use direct\nbindings."
    },
    {
      "id": "clippy::unneeded_wildcard_pattern",
      "name": "UNNEEDED_WILDCARD_PATTERN",
      "snake_name": "unneeded_wildcard_pattern",
      "category": "complexity",
      "weight": 1.0,
      "brief": "tuple patterns with a wildcard pattern (`_`) is next to a rest pattern (`..`)",
      "what_it_does": "Checks for tuple patterns with a wildcard\npattern (`_`) is next to a rest pattern (`..`).\n\n_NOTE_: While `_, ..` means there is at least one element left, `..`\nmeans there are 0 or more elements left. This can make a difference\nwhen refactoring, but shouldn't result in errors in the refactored code,\nsince the wildcard pattern isn't used anyway.",
      "why_bad": "The wildcard pattern is unneeded as the rest pattern\ncan match that element as well.",
      "example": "```no_run\n# struct TupleStruct(u32, u32, u32);\n# let t = TupleStruct(1, 2, 3);\nmatch t {\nTupleStruct(0, .., _) => (),\n_ => (),\n}\n```\n\nUse instead:\n```no_run\n# struct TupleStruct(u32, u32, u32);\n# let t = TupleStruct(1, 2, 3);\nmatch t {\nTupleStruct(0, ..) => (),\n_ => (),\n}\n```",
      "version": "1.40.0",
      "source_file": "mod.rs",
      "embedding_text": "tuple patterns with a wildcard pattern (`_`) is next to a rest pattern (`..`)\n\nChecks for tuple patterns with a wildcard\npattern (`_`) is next to a rest pattern (`..`).\n\n_NOTE_: While `_, ..` means there is at least one element left, `..`\nmeans there are 0 or more elements left. This can make a difference\nwhen refactoring, but shouldn't result in errors in the refactored code,\nsince the wildcard pattern isn't used anyway.\n\nThe wildcard pattern is unneeded as the rest pattern\ncan match that element as well."
    },
    {
      "id": "clippy::redundant_at_rest_pattern",
      "name": "REDUNDANT_AT_REST_PATTERN",
      "snake_name": "redundant_at_rest_pattern",
      "category": "complexity",
      "weight": 1.0,
      "brief": "checks for `[all @ ..]` where `all` would suffice",
      "what_it_does": "Checks for `[all @ ..]` patterns.",
      "why_bad": "In all cases, `all` works fine and can often make code simpler, as you possibly won't need\nto convert from say a `Vec` to a slice by dereferencing.",
      "example": "```rust,ignore\nif let [all @ ..] = &*v {\n// NOTE: Type is a slice here\nprintln!(\"all elements: {all:#?}\");\n}\n```\nUse instead:\n```rust,ignore\nif let all = v {\n// NOTE: Type is a `Vec` here\nprintln!(\"all elements: {all:#?}\");\n}\n// or\nprintln!(\"all elements: {v:#?}\");\n```",
      "version": "1.72.0",
      "source_file": "mod.rs",
      "embedding_text": "checks for `[all @ ..]` where `all` would suffice\n\nChecks for `[all @ ..]` patterns.\n\nIn all cases, `all` works fine and can often make code simpler, as you possibly won't need\nto convert from say a `Vec` to a slice by dereferencing."
    },
    {
      "id": "clippy::mismatching_type_param_order",
      "name": "MISMATCHING_TYPE_PARAM_ORDER",
      "snake_name": "mismatching_type_param_order",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "type parameter positioned inconsistently between type def and impl block",
      "what_it_does": "Checks for type parameters which are positioned inconsistently between\na type definition and impl block. Specifically, a parameter in an impl\nblock which has the same name as a parameter in the type def, but is in\na different place.",
      "why_bad": "Type parameters are determined by their position rather than name.\nNaming type parameters inconsistently may cause you to refer to the\nwrong type parameter.",
      "example": "```no_run\nstruct Foo<A, B> {\nx: A,\ny: B,\n}\n// inside the impl, B refers to Foo::A\nimpl<B, A> Foo<B, A> {}\n```\nUse instead:\n```no_run\nstruct Foo<A, B> {\nx: A,\ny: B,\n}\nimpl<A, B> Foo<A, B> {}\n```",
      "version": "1.63.0",
      "source_file": "mismatching_type_param_order.rs",
      "embedding_text": "type parameter positioned inconsistently between type def and impl block\n\nChecks for type parameters which are positioned inconsistently between\na type definition and impl block. Specifically, a parameter in an impl\nblock which has the same name as a parameter in the type def, but is in\na different place.\n\nType parameters are determined by their position rather than name.\nNaming type parameters inconsistently may cause you to refer to the\nwrong type parameter."
    },
    {
      "id": "clippy::missing_assert_message",
      "name": "MISSING_ASSERT_MESSAGE",
      "snake_name": "missing_assert_message",
      "category": "restriction",
      "weight": 1.0,
      "brief": "checks assertions without a custom panic message",
      "what_it_does": "Checks assertions without a custom panic message.",
      "why_bad": "Without a good custom message, it'd be hard to understand what went wrong when the assertion fails.\nA good custom message should be more about why the failure of the assertion is problematic\nand not what is failed because the assertion already conveys that.\n\nAlthough the same reasoning applies to testing functions, this lint ignores them as they would be too noisy.\nAlso, in most cases understanding the test failure would be easier\ncompared to understanding a complex invariant distributed around the codebase.",
      "example": "```no_run\n# struct Service { ready: bool }\nfn call(service: Service) {\nassert!(service.ready);\n}\n```\nUse instead:\n```no_run\n# struct Service { ready: bool }\nfn call(service: Service) {\nassert!(service.ready, \"`service.poll_ready()` must be called first to ensure that service is ready to receive requests\");\n}\n```",
      "version": "1.70.0",
      "source_file": "missing_assert_message.rs",
      "embedding_text": "checks assertions without a custom panic message\n\nChecks assertions without a custom panic message.\n\nWithout a good custom message, it'd be hard to understand what went wrong when the assertion fails.\nA good custom message should be more about why the failure of the assertion is problematic\nand not what is failed because the assertion already conveys that.\n\nAlthough the same reasoning applies to testing functions, this lint ignores them as they would be too noisy.\nAlso, in most cases understanding the test failure would be easier\ncompared to understanding a complex invariant distributed around the codebase."
    },
    {
      "id": "clippy::missing_asserts_for_indexing",
      "name": "MISSING_ASSERTS_FOR_INDEXING",
      "snake_name": "missing_asserts_for_indexing",
      "category": "restriction",
      "weight": 1.0,
      "brief": "indexing into a slice multiple times without an `assert`",
      "what_it_does": "Checks for repeated slice indexing without asserting beforehand that the length\nis greater than the largest index used to index into the slice.",
      "why_bad": "In the general case where the compiler does not have a lot of information\nabout the length of a slice, indexing it repeatedly will generate a bounds check\nfor every single index.\n\nAsserting that the length of the slice is at least as large as the largest value\nto index beforehand gives the compiler enough information to elide the bounds checks,\neffectively reducing the number of bounds checks from however many times\nthe slice was indexed to just one (the assert).",
      "example": "```no_run\nfn sum(v: &[u8]) -> u8 {\n// 4 bounds checks\nv[0] + v[1] + v[2] + v[3]\n}\n```\nUse instead:\n```no_run\nfn sum(v: &[u8]) -> u8 {\nassert!(v.len() > 3);\n// no bounds checks\nv[0] + v[1] + v[2] + v[3]\n}\n```",
      "version": "1.74.0",
      "source_file": "missing_asserts_for_indexing.rs",
      "embedding_text": "indexing into a slice multiple times without an `assert`\n\nChecks for repeated slice indexing without asserting beforehand that the length\nis greater than the largest index used to index into the slice.\n\nIn the general case where the compiler does not have a lot of information\nabout the length of a slice, indexing it repeatedly will generate a bounds check\nfor every single index.\n\nAsserting that the length of the slice is at least as large as the largest value\nto index beforehand gives the compiler enough information to elide the bounds checks,\neffectively reducing the number of bounds checks from however many times\nthe slice was indexed to just one (the assert)."
    },
    {
      "id": "clippy::missing_const_for_fn",
      "name": "MISSING_CONST_FOR_FN",
      "snake_name": "missing_const_for_fn",
      "category": "nursery",
      "weight": 0.9,
      "brief": "Lint functions definitions that could be made `const fn`",
      "what_it_does": "Suggests the use of `const` in functions and methods where possible.",
      "why_bad": "Not having the function const prevents callers of the function from being const as well.",
      "example": "```no_run\n# struct Foo {\n#     random_number: usize,\n# }\n# impl Foo {\nfn new() -> Self {\nSelf { random_number: 42 }\n}\n# }\n```\n\nCould be a const fn:\n\n```no_run\n# struct Foo {\n#     random_number: usize,\n# }\n# impl Foo {\nconst fn new() -> Self {\nSelf { random_number: 42 }\n}\n# }\n```",
      "version": "1.34.0",
      "source_file": "missing_const_for_fn.rs",
      "embedding_text": "Lint functions definitions that could be made `const fn`\n\nSuggests the use of `const` in functions and methods where possible.\n\nNot having the function const prevents callers of the function from being const as well."
    },
    {
      "id": "clippy::missing_const_for_thread_local",
      "name": "MISSING_CONST_FOR_THREAD_LOCAL",
      "snake_name": "missing_const_for_thread_local",
      "category": "perf",
      "weight": 1.0,
      "brief": "suggest using `const` in `thread_local!` macro",
      "what_it_does": "Suggests to use `const` in `thread_local!` macro if possible.",
      "why_bad": "The `thread_local!` macro wraps static declarations and makes them thread-local.\nIt supports using a `const` keyword that may be used for declarations that can\nbe evaluated as a constant expression. This can enable a more efficient thread\nlocal implementation that can avoid lazy initialization. For types that do not\nneed to be dropped, this can enable an even more efficient implementation that\ndoes not need to track any additional state.\n\nhttps://doc.rust-lang.org/std/macro.thread_local.html",
      "example": "```no_run\nthread_local! {\nstatic BUF: String = String::new();\n}\n```\nUse instead:\n```no_run\nthread_local! {\nstatic BUF: String = const { String::new() };\n}\n```",
      "version": "1.77.0",
      "source_file": "missing_const_for_thread_local.rs",
      "embedding_text": "suggest using `const` in `thread_local!` macro\n\nSuggests to use `const` in `thread_local!` macro if possible.\n\nThe `thread_local!` macro wraps static declarations and makes them thread-local.\nIt supports using a `const` keyword that may be used for declarations that can\nbe evaluated as a constant expression. This can enable a more efficient thread\nlocal implementation that can avoid lazy initialization. For types that do not\nneed to be dropped, this can enable an even more efficient implementation that\ndoes not need to track any additional state.\n\nhttps://doc.rust-lang.org/std/macro.thread_local.html"
    },
    {
      "id": "clippy::missing_docs_in_private_items",
      "name": "MISSING_DOCS_IN_PRIVATE_ITEMS",
      "snake_name": "missing_docs_in_private_items",
      "category": "restriction",
      "weight": 1.0,
      "brief": "detects missing documentation for private members",
      "what_it_does": "Warns if there is missing documentation for any private documentable item.",
      "why_bad": "Doc is good. *rustc* has a `MISSING_DOCS`\nallowed-by-default lint for\npublic members, but has no way to enforce documentation of private items.\nThis lint fixes that.",
      "example": "",
      "version": "pre 1.29.0",
      "source_file": "missing_doc.rs",
      "embedding_text": "detects missing documentation for private members\n\nWarns if there is missing documentation for any private documentable item.\n\nDoc is good. *rustc* has a `MISSING_DOCS`\nallowed-by-default lint for\npublic members, but has no way to enforce documentation of private items.\nThis lint fixes that."
    },
    {
      "id": "clippy::missing_enforced_import_renames",
      "name": "MISSING_ENFORCED_IMPORT_RENAMES",
      "snake_name": "missing_enforced_import_renames",
      "category": "style",
      "weight": 0.95,
      "brief": "enforce import renames",
      "what_it_does": "Checks for imports that do not rename the item as specified\nin the `enforced-import-renames` config option.\n\nNote: Even though this lint is warn-by-default, it will only trigger if\nimport renames are defined in the `clippy.toml` file.",
      "why_bad": "Consistency is important; if a project has defined import renames, then they should be\nfollowed. More practically, some item names are too vague outside of their defining scope,\nin which case this can enforce a more meaningful naming.",
      "example": "An example clippy.toml configuration:\n```toml\n# clippy.toml\nenforced-import-renames = [\n{ path = \"serde_json::Value\", rename = \"JsonValue\" },\n]\n```\n\n```rust,ignore\nuse serde_json::Value;\n```\nUse instead:\n```rust,ignore\nuse serde_json::Value as JsonValue;\n```",
      "version": "1.55.0",
      "source_file": "missing_enforced_import_rename.rs",
      "embedding_text": "enforce import renames\n\nChecks for imports that do not rename the item as specified\nin the `enforced-import-renames` config option.\n\nNote: Even though this lint is warn-by-default, it will only trigger if\nimport renames are defined in the `clippy.toml` file.\n\nConsistency is important; if a project has defined import renames, then they should be\nfollowed. More practically, some item names are too vague outside of their defining scope,\nin which case this can enforce a more meaningful naming."
    },
    {
      "id": "clippy::missing_fields_in_debug",
      "name": "MISSING_FIELDS_IN_DEBUG",
      "snake_name": "missing_fields_in_debug",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "missing fields in manual `Debug` implementation",
      "what_it_does": "Checks for manual [`core::fmt::Debug`](https://doc.rust-lang.org/core/fmt/trait.Debug.html) implementations that do not use all fields.",
      "why_bad": "A common mistake is to forget to update manual `Debug` implementations when adding a new field\nto a struct or a new variant to an enum.\n\nAt the same time, it also acts as a style lint to suggest using [`core::fmt::DebugStruct::finish_non_exhaustive`](https://doc.rust-lang.org/core/fmt/struct.DebugStruct.html#method.finish_non_exhaustive)\nfor the times when the user intentionally wants to leave out certain fields (e.g. to hide implementation details).",
      "example": "```no_run\nuse std::fmt;\nstruct Foo {\ndata: String,\n// implementation detail\nhidden_data: i32\n}\nimpl fmt::Debug for Foo {\nfn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\nformatter\n.debug_struct(\"Foo\")\n.field(\"data\", &self.data)\n.finish()\n}\n}\n```\nUse instead:\n```no_run\nuse std::fmt;\nstruct Foo {\ndata: String,\n// implementation detail\nhidden_data: i32\n}\nimpl fmt::Debug for Foo {\nfn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\nformatter\n.debug_struct(\"Foo\")\n.field(\"data\", &self.data)\n.finish_non_exhaustive()\n}\n}\n```",
      "version": "1.70.0",
      "source_file": "missing_fields_in_debug.rs",
      "embedding_text": "missing fields in manual `Debug` implementation\n\nChecks for manual [`core::fmt::Debug`](https://doc.rust-lang.org/core/fmt/trait.Debug.html) implementations that do not use all fields.\n\nA common mistake is to forget to update manual `Debug` implementations when adding a new field\nto a struct or a new variant to an enum.\n\nAt the same time, it also acts as a style lint to suggest using [`core::fmt::DebugStruct::finish_non_exhaustive`](https://doc.rust-lang.org/core/fmt/struct.DebugStruct.html#method.finish_non_exhaustive)\nfor the times when the user intentionally wants to leave out certain fields (e.g. to hide implementation details)."
    },
    {
      "id": "clippy::missing_inline_in_public_items",
      "name": "MISSING_INLINE_IN_PUBLIC_ITEMS",
      "snake_name": "missing_inline_in_public_items",
      "category": "restriction",
      "weight": 1.0,
      "brief": "detects missing `#[inline]` attribute for public callables (functions, trait methods, methods...)",
      "what_it_does": "It lints if an exported function, method, trait method with default impl,\nor trait method impl is not `#[inline]`.",
      "why_bad": "When a function is not marked `#[inline]`, it is not\n[a \u201csmall\u201d candidate for automatic inlining][small], and LTO is not in use, then it is not\npossible for the function to be inlined into the code of any crate other than the one in\nwhich it is defined.  Depending on the role of the function and the relationship of the crates,\nthis could significantly reduce performance.\n\nCertain types of crates might intend for most of the methods in their public API to be able\nto be inlined across crates even when LTO is disabled.\nThis lint allows those crates to require all exported methods to be `#[inline]` by default, and\nthen opt out for specific methods where this might not make sense.",
      "example": "```no_run\npub fn foo() {} // missing #[inline]\nfn ok() {} // ok\n#[inline] pub fn bar() {} // ok\n#[inline(always)] pub fn baz() {} // ok\n\npub trait Bar {\nfn bar(); // ok\nfn def_bar() {} // missing #[inline]\n}\n\nstruct Baz;\nimpl Baz {\nfn private() {} // ok\n}\n\nimpl Bar for Baz {\nfn bar() {} // ok - Baz is not exported\n}\n\npub struct PubBaz;\nimpl PubBaz {\nfn private() {} // ok\npub fn not_private() {} // missing #[inline]\n}\n\nimpl Bar for PubBaz {\nfn bar() {} // missing #[inline]\nfn def_bar() {} // missing #[inline]\n}\n```\n\n[small]: https://github.com/rust-lang/rust/pull/116505",
      "version": "pre 1.29.0",
      "source_file": "missing_inline.rs",
      "embedding_text": "detects missing `#[inline]` attribute for public callables (functions, trait methods, methods...)\n\nIt lints if an exported function, method, trait method with default impl,\nor trait method impl is not `#[inline]`.\n\nWhen a function is not marked `#[inline]`, it is not\n[a \u201csmall\u201d candidate for automatic inlining][small], and LTO is not in use, then it is not\npossible for the function to be inlined into the code of any crate other than the one in\nwhich it is defined.  Depending on the role of the function and the relationship of the crates,\nthis could significantly reduce performance.\n\nCertain types of crates might intend for most of the methods in their public API to be able\nto be inlined across crates even when LTO is disabled.\nThis lint allows those crates to require all exported methods to be `#[inline]` by default, and\nthen opt out for specific methods where this might not make sense."
    },
    {
      "id": "clippy::missing_trait_methods",
      "name": "MISSING_TRAIT_METHODS",
      "snake_name": "missing_trait_methods",
      "category": "restriction",
      "weight": 1.0,
      "brief": "trait implementation uses default provided method",
      "what_it_does": "Checks if a provided method is used implicitly by a trait\nimplementation.",
      "why_bad": "To ensure that a certain implementation implements every method; for example,\na wrapper type where every method should delegate to the corresponding method of\nthe inner type's implementation.\n\nThis lint should typically be enabled on a specific trait `impl` item\nrather than globally.",
      "example": "```no_run\ntrait Trait {\nfn required();\n\nfn provided() {}\n}\n\n# struct Type;\n#[warn(clippy::missing_trait_methods)]\nimpl Trait for Type {\nfn required() { /* ... */ }\n}\n```\nUse instead:\n```no_run\ntrait Trait {\nfn required();\n\nfn provided() {}\n}\n\n# struct Type;\n#[warn(clippy::missing_trait_methods)]\nimpl Trait for Type {\nfn required() { /* ... */ }\n\nfn provided() { /* ... */ }\n}\n```",
      "version": "1.66.0",
      "source_file": "missing_trait_methods.rs",
      "embedding_text": "trait implementation uses default provided method\n\nChecks if a provided method is used implicitly by a trait\nimplementation.\n\nTo ensure that a certain implementation implements every method; for example,\na wrapper type where every method should delegate to the corresponding method of\nthe inner type's implementation.\n\nThis lint should typically be enabled on a specific trait `impl` item\nrather than globally."
    },
    {
      "id": "clippy::mixed_read_write_in_expression",
      "name": "MIXED_READ_WRITE_IN_EXPRESSION",
      "snake_name": "mixed_read_write_in_expression",
      "category": "restriction",
      "weight": 1.0,
      "brief": "whether a variable read occurs before a write depends on sub-expression evaluation order",
      "what_it_does": "Checks for a read and a write to the same variable where\nwhether the read occurs before or after the write depends on the evaluation\norder of sub-expressions.",
      "why_bad": "While [the evaluation order of sub-expressions] is fully specified in Rust,\nit still may be confusing to read an expression where the evaluation order\naffects its behavior.",
      "example": "```no_run\nlet mut x = 0;\n\nlet a = {\nx = 1;\n1\n} + x;\n// Unclear whether a is 1 or 2.\n```\n\nUse instead:\n```no_run\n# let mut x = 0;\nlet tmp = {\nx = 1;\n1\n};\nlet a = tmp + x;\n```\n\n[order]: (https://doc.rust-lang.org/reference/expressions.html?highlight=subexpression#evaluation-order-of-operands)",
      "version": "pre 1.29.0",
      "source_file": "mixed_read_write_in_expression.rs",
      "embedding_text": "whether a variable read occurs before a write depends on sub-expression evaluation order\n\nChecks for a read and a write to the same variable where\nwhether the read occurs before or after the write depends on the evaluation\norder of sub-expressions.\n\nWhile [the evaluation order of sub-expressions] is fully specified in Rust,\nit still may be confusing to read an expression where the evaluation order\naffects its behavior."
    },
    {
      "id": "clippy::diverging_sub_expression",
      "name": "DIVERGING_SUB_EXPRESSION",
      "snake_name": "diverging_sub_expression",
      "category": "complexity",
      "weight": 1.0,
      "brief": "whether an expression contains a diverging sub expression",
      "what_it_does": "Checks for diverging calls that are not match arms or\nstatements.",
      "why_bad": "It is often confusing to read. In addition, the\nsub-expression evaluation order for Rust is not well documented.",
      "example": "```rust,no_run\n# fn b() -> bool { true }\n# fn c() -> bool { true }\nlet a = b() || panic!() || c();\n// `c()` is dead, `panic!()` is only called if `b()` returns `false`\nlet x = (a, b, c, panic!());\n// can simply be replaced by `panic!()`\n```",
      "version": "pre 1.29.0",
      "source_file": "mixed_read_write_in_expression.rs",
      "embedding_text": "whether an expression contains a diverging sub expression\n\nChecks for diverging calls that are not match arms or\nstatements.\n\nIt is often confusing to read. In addition, the\nsub-expression evaluation order for Rust is not well documented."
    },
    {
      "id": "clippy::mod_module_files",
      "name": "MOD_MODULE_FILES",
      "snake_name": "mod_module_files",
      "category": "restriction",
      "weight": 1.0,
      "brief": "checks that module layout is consistent",
      "what_it_does": "Checks that module layout uses only self named module files; bans `mod.rs` files.",
      "why_bad": "Having multiple module layout styles in a project can be confusing.",
      "example": "```text\nsrc/\nstuff/\nstuff_files.rs\nmod.rs\nlib.rs\n```\nUse instead:\n```text\nsrc/\nstuff/\nstuff_files.rs\nstuff.rs\nlib.rs\n```",
      "version": "1.57.0",
      "source_file": "module_style.rs",
      "embedding_text": "checks that module layout is consistent\n\nChecks that module layout uses only self named module files; bans `mod.rs` files.\n\nHaving multiple module layout styles in a project can be confusing."
    },
    {
      "id": "clippy::self_named_module_files",
      "name": "SELF_NAMED_MODULE_FILES",
      "snake_name": "self_named_module_files",
      "category": "restriction",
      "weight": 1.0,
      "brief": "checks that module layout is consistent",
      "what_it_does": "Checks that module layout uses only `mod.rs` files.",
      "why_bad": "Having multiple module layout styles in a project can be confusing.",
      "example": "```text\nsrc/\nstuff/\nstuff_files.rs\nstuff.rs\nlib.rs\n```\nUse instead:\n```text\nsrc/\nstuff/\nstuff_files.rs\nmod.rs\nlib.rs\n```",
      "version": "1.57.0",
      "source_file": "module_style.rs",
      "embedding_text": "checks that module layout is consistent\n\nChecks that module layout uses only `mod.rs` files.\n\nHaving multiple module layout styles in a project can be confusing."
    },
    {
      "id": "clippy::multi_assignments",
      "name": "MULTI_ASSIGNMENTS",
      "snake_name": "multi_assignments",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "instead of using `a = b = c;` use `a = c; b = c;`",
      "what_it_does": "Checks for nested assignments.",
      "why_bad": "While this is in most cases already a type mismatch,\nthe result of an assignment being `()` can throw off people coming from languages like python or C,\nwhere such assignments return a copy of the assigned value.",
      "example": "```no_run\n# let (a, b);\na = b = 42;\n```\nUse instead:\n```no_run\n# let (a, b);\nb = 42;\na = b;\n```",
      "version": "1.65.0",
      "source_file": "multi_assignments.rs",
      "embedding_text": "instead of using `a = b = c;` use `a = c; b = c;`\n\nChecks for nested assignments.\n\nWhile this is in most cases already a type mismatch,\nthe result of an assignment being `()` can throw off people coming from languages like python or C,\nwhere such assignments return a copy of the assigned value."
    },
    {
      "id": "clippy::multiple_bound_locations",
      "name": "MULTIPLE_BOUND_LOCATIONS",
      "snake_name": "multiple_bound_locations",
      "category": "style",
      "weight": 0.95,
      "brief": "defining generic bounds in multiple locations",
      "what_it_does": "Check if a generic is defined both in the bound predicate and in the `where` clause.",
      "why_bad": "It can be confusing for developers when seeing bounds for a generic in multiple places.",
      "example": "```no_run\nfn ty<F: std::fmt::Debug>(a: F)\nwhere\nF: Sized,\n{}\n```\nUse instead:\n```no_run\nfn ty<F>(a: F)\nwhere\nF: Sized + std::fmt::Debug,\n{}\n```",
      "version": "1.78.0",
      "source_file": "multiple_bound_locations.rs",
      "embedding_text": "defining generic bounds in multiple locations\n\nCheck if a generic is defined both in the bound predicate and in the `where` clause.\n\nIt can be confusing for developers when seeing bounds for a generic in multiple places."
    },
    {
      "id": "clippy::multiple_unsafe_ops_per_block",
      "name": "MULTIPLE_UNSAFE_OPS_PER_BLOCK",
      "snake_name": "multiple_unsafe_ops_per_block",
      "category": "restriction",
      "weight": 1.0,
      "brief": "more than one unsafe operation per `unsafe` block",
      "what_it_does": "Checks for `unsafe` blocks that contain more than one unsafe operation.",
      "why_bad": "Combined with `undocumented_unsafe_blocks`,\nthis lint ensures that each unsafe operation must be independently justified.\nCombined with `unused_unsafe`, this lint also ensures\nelimination of unnecessary unsafe blocks through refactoring.",
      "example": "```no_run\n/// Reads a `char` from the given pointer.\n///\n/// # Safety\n///\n/// `ptr` must point to four consecutive, initialized bytes which\n/// form a valid `char` when interpreted in the native byte order.\nfn read_char(ptr: *const u8) -> char {\n// SAFETY: The caller has guaranteed that the value pointed\n// to by `bytes` is a valid `char`.\nunsafe { char::from_u32_unchecked(*ptr.cast::<u32>()) }\n}\n```\nUse instead:\n```no_run\n/// Reads a `char` from the given pointer.\n///\n/// # Safety\n///\n/// - `ptr` must be 4-byte aligned, point to four consecutive\n///   initialized bytes, and be valid for reads of 4 bytes.\n/// - The bytes pointed to by `ptr` must represent a valid\n///   `char` when interpreted in the native byte order.\nfn read_char(ptr: *const u8) -> char {\n// SAFETY: `ptr` is 4-byte aligned, points to four consecutive\n// initialized bytes, and is valid for reads of 4 bytes.\nlet int_value = unsafe { *ptr.cast::<u32>() };\n\n// SAFETY: The caller has guaranteed that the four bytes\n// pointed to by `bytes` represent a valid `char`.\nunsafe { char::from_u32_unchecked(int_value) }\n}\n```",
      "version": "1.69.0",
      "source_file": "multiple_unsafe_ops_per_block.rs",
      "embedding_text": "more than one unsafe operation per `unsafe` block\n\nChecks for `unsafe` blocks that contain more than one unsafe operation.\n\nCombined with `undocumented_unsafe_blocks`,\nthis lint ensures that each unsafe operation must be independently justified.\nCombined with `unused_unsafe`, this lint also ensures\nelimination of unnecessary unsafe blocks through refactoring."
    },
    {
      "id": "clippy::mutable_key_type",
      "name": "MUTABLE_KEY_TYPE",
      "snake_name": "mutable_key_type",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "Check for mutable `Map`/`Set` key type",
      "what_it_does": "Checks for sets/maps with mutable key types.",
      "why_bad": "All of `HashMap`, `HashSet`, `BTreeMap` and\n`BtreeSet` rely on either the hash or the order of keys be unchanging,\nso having types with interior mutability is a bad idea.",
      "example": "```no_run\nuse std::cmp::{PartialEq, Eq};\nuse std::collections::HashSet;\nuse std::hash::{Hash, Hasher};\nuse std::sync::atomic::AtomicUsize;\n\nstruct Bad(AtomicUsize);\nimpl PartialEq for Bad {\nfn eq(&self, rhs: &Self) -> bool {\n..\n# ; true\n}\n}\n\nimpl Eq for Bad {}\n\nimpl Hash for Bad {\nfn hash<H: Hasher>(&self, h: &mut H) {\n..\n# ;\n}\n}\n\nfn main() {\nlet _: HashSet<Bad> = HashSet::new();\n}\n```",
      "version": "1.42.0",
      "source_file": "mut_key.rs",
      "embedding_text": "Check for mutable `Map`/`Set` key type\n\nChecks for sets/maps with mutable key types.\n\nAll of `HashMap`, `HashSet`, `BTreeMap` and\n`BtreeSet` rely on either the hash or the order of keys be unchanging,\nso having types with interior mutability is a bad idea."
    },
    {
      "id": "clippy::mut_mut",
      "name": "MUT_MUT",
      "snake_name": "mut_mut",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "usage of double mut-refs, e.g., `&mut &mut ...`",
      "what_it_does": "Checks for instances of `mut mut` references.",
      "why_bad": "This is usually just a typo or a misunderstanding of how references work.",
      "example": "```no_run\nlet x = &mut &mut 1;\n\nlet mut x = &mut 1;\nlet y = &mut x;\n\nfn foo(x: &mut &mut u32) {}\n```\nUse instead\n```no_run\nlet x = &mut 1;\n\nlet mut x = &mut 1;\nlet y = &mut *x; // reborrow\n\nfn foo(x: &mut u32) {}\n```",
      "version": "pre 1.29.0",
      "source_file": "mut_mut.rs",
      "embedding_text": "usage of double mut-refs, e.g., `&mut &mut ...`\n\nChecks for instances of `mut mut` references.\n\nThis is usually just a typo or a misunderstanding of how references work."
    },
    {
      "id": "clippy::debug_assert_with_mut_call",
      "name": "DEBUG_ASSERT_WITH_MUT_CALL",
      "snake_name": "debug_assert_with_mut_call",
      "category": "nursery",
      "weight": 0.9,
      "brief": "mutable arguments in `debug_assert{,_ne,_eq}!`",
      "what_it_does": "Checks for function/method calls with a mutable\nparameter in `debug_assert!`, `debug_assert_eq!` and `debug_assert_ne!` macros.",
      "why_bad": "In release builds `debug_assert!` macros are optimized out by the\ncompiler.\nTherefore mutating something in a `debug_assert!` macro results in different behavior\nbetween a release and debug build.",
      "example": "```rust,ignore\ndebug_assert_eq!(vec![3].pop(), Some(3));\n\n// or\n\n# let mut x = 5;\n# fn takes_a_mut_parameter(_: &mut u32) -> bool { unimplemented!() }\ndebug_assert!(takes_a_mut_parameter(&mut x));\n```",
      "version": "1.40.0",
      "source_file": "mutable_debug_assertion.rs",
      "embedding_text": "mutable arguments in `debug_assert{,_ne,_eq}!`\n\nChecks for function/method calls with a mutable\nparameter in `debug_assert!`, `debug_assert_eq!` and `debug_assert_ne!` macros.\n\nIn release builds `debug_assert!` macros are optimized out by the\ncompiler.\nTherefore mutating something in a `debug_assert!` macro results in different behavior\nbetween a release and debug build."
    },
    {
      "id": "clippy::mutex_atomic",
      "name": "MUTEX_ATOMIC",
      "snake_name": "mutex_atomic",
      "category": "restriction",
      "weight": 1.0,
      "brief": "using a mutex where an atomic value could be used instead.",
      "what_it_does": "Checks for usage of `Mutex<X>` where an atomic will do.",
      "why_bad": "Using a mutex just to make access to a plain bool or\nreference sequential is shooting flies with cannons.\n`std::sync::atomic::AtomicBool` and `std::sync::atomic::AtomicPtr` are leaner and\nfaster.\n\nOn the other hand, `Mutex`es are, in general, easier to\nverify correctness. An atomic does not behave the same as\nan equivalent mutex. See [this issue](https://github.com/rust-lang/rust-clippy/issues/4295)'s\ncommentary for more details.",
      "example": "```no_run\n# let y = true;\n# use std::sync::Mutex;\nlet x = Mutex::new(&y);\n```\n\nUse instead:\n```no_run\n# let y = true;\n# use std::sync::atomic::AtomicBool;\nlet x = AtomicBool::new(y);\n```",
      "version": "pre 1.29.0",
      "source_file": "mutex_atomic.rs",
      "embedding_text": "using a mutex where an atomic value could be used instead.\n\nChecks for usage of `Mutex<X>` where an atomic will do.\n\nUsing a mutex just to make access to a plain bool or\nreference sequential is shooting flies with cannons.\n`std::sync::atomic::AtomicBool` and `std::sync::atomic::AtomicPtr` are leaner and\nfaster.\n\nOn the other hand, `Mutex`es are, in general, easier to\nverify correctness. An atomic does not behave the same as\nan equivalent mutex. See [this issue](https://github.com/rust-lang/rust-clippy/issues/4295)'s\ncommentary for more details."
    },
    {
      "id": "clippy::mutex_integer",
      "name": "MUTEX_INTEGER",
      "snake_name": "mutex_integer",
      "category": "restriction",
      "weight": 1.0,
      "brief": "using a mutex for an integer type",
      "what_it_does": "Checks for usage of `Mutex<X>` where `X` is an integral\ntype.",
      "why_bad": "Using a mutex just to make access to a plain integer\nsequential is\nshooting flies with cannons. `std::sync::atomic::AtomicUsize` is leaner and faster.\n\nOn the other hand, `Mutex`es are, in general, easier to\nverify correctness. An atomic does not behave the same as\nan equivalent mutex. See [this issue](https://github.com/rust-lang/rust-clippy/issues/4295)'s\ncommentary for more details.",
      "example": "```no_run\n# use std::sync::Mutex;\nlet x = Mutex::new(0usize);\n```\n\nUse instead:\n```no_run\n# use std::sync::atomic::AtomicUsize;\nlet x = AtomicUsize::new(0usize);\n```",
      "version": "pre 1.29.0",
      "source_file": "mutex_atomic.rs",
      "embedding_text": "using a mutex for an integer type\n\nChecks for usage of `Mutex<X>` where `X` is an integral\ntype.\n\nUsing a mutex just to make access to a plain integer\nsequential is\nshooting flies with cannons. `std::sync::atomic::AtomicUsize` is leaner and faster.\n\nOn the other hand, `Mutex`es are, in general, easier to\nverify correctness. An atomic does not behave the same as\nan equivalent mutex. See [this issue](https://github.com/rust-lang/rust-clippy/issues/4295)'s\ncommentary for more details."
    },
    {
      "id": "clippy::needless_arbitrary_self_type",
      "name": "NEEDLESS_ARBITRARY_SELF_TYPE",
      "snake_name": "needless_arbitrary_self_type",
      "category": "complexity",
      "weight": 1.0,
      "brief": "type of `self` parameter is already by default `Self`",
      "what_it_does": "The lint checks for `self` in fn parameters that\nspecify the `Self`-type explicitly",
      "why_bad": "Increases the amount and decreases the readability of code",
      "example": "```no_run\nenum ValType {\nI32,\nI64,\nF32,\nF64,\n}\n\nimpl ValType {\npub fn bytes(self: Self) -> usize {\nmatch self {\nSelf::I32 | Self::F32 => 4,\nSelf::I64 | Self::F64 => 8,\n}\n}\n}\n```\n\nCould be rewritten as\n\n```no_run\nenum ValType {\nI32,\nI64,\nF32,\nF64,\n}\n\nimpl ValType {\npub fn bytes(self) -> usize {\nmatch self {\nSelf::I32 | Self::F32 => 4,\nSelf::I64 | Self::F64 => 8,\n}\n}\n}\n```",
      "version": "1.47.0",
      "source_file": "needless_arbitrary_self_type.rs",
      "embedding_text": "type of `self` parameter is already by default `Self`\n\nThe lint checks for `self` in fn parameters that\nspecify the `Self`-type explicitly\n\nIncreases the amount and decreases the readability of code"
    },
    {
      "id": "clippy::needless_bool",
      "name": "NEEDLESS_BOOL",
      "snake_name": "needless_bool",
      "category": "complexity",
      "weight": 1.0,
      "brief": "if-statements with plain booleans in the then- and else-clause, e.g., `if p { true } else { false }`",
      "what_it_does": "Checks for expressions of the form `if c { true } else {\nfalse }` (or vice versa) and suggests using the condition directly.",
      "why_bad": "Redundant code.",
      "example": "```no_run\n# let x = true;\nif x {\nfalse\n} else {\ntrue\n}\n# ;\n```\n\nUse instead:\n```no_run\n# let x = true;\n!x\n# ;\n```",
      "version": "pre 1.29.0",
      "source_file": "needless_bool.rs",
      "embedding_text": "if-statements with plain booleans in the then- and else-clause, e.g., `if p { true } else { false }`\n\nChecks for expressions of the form `if c { true } else {\nfalse }` (or vice versa) and suggests using the condition directly.\n\nRedundant code."
    },
    {
      "id": "clippy::needless_bool_assign",
      "name": "NEEDLESS_BOOL_ASSIGN",
      "snake_name": "needless_bool_assign",
      "category": "complexity",
      "weight": 1.0,
      "brief": "setting the same boolean variable in both branches of an if-statement",
      "what_it_does": "Checks for expressions of the form `if c { x = true } else { x = false }`\n(or vice versa) and suggest assigning the variable directly from the\ncondition.",
      "why_bad": "Redundant code.",
      "example": "```rust,ignore\n# fn must_keep(x: i32, y: i32) -> bool { x == y }\n# let x = 32; let y = 10;\n# let mut skip: bool;\nif must_keep(x, y) {\nskip = false;\n} else {\nskip = true;\n}\n```\nUse instead:\n```rust,ignore\n# fn must_keep(x: i32, y: i32) -> bool { x == y }\n# let x = 32; let y = 10;\n# let mut skip: bool;\nskip = !must_keep(x, y);\n```",
      "version": "1.71.0",
      "source_file": "needless_bool.rs",
      "embedding_text": "setting the same boolean variable in both branches of an if-statement\n\nChecks for expressions of the form `if c { x = true } else { x = false }`\n(or vice versa) and suggest assigning the variable directly from the\ncondition.\n\nRedundant code."
    },
    {
      "id": "clippy::needless_borrowed_reference",
      "name": "NEEDLESS_BORROWED_REFERENCE",
      "snake_name": "needless_borrowed_reference",
      "category": "complexity",
      "weight": 1.0,
      "brief": "destructuring a reference and borrowing the inner value",
      "what_it_does": "Checks for bindings that needlessly destructure a reference and borrow the inner\nvalue with `&ref`.",
      "why_bad": "This pattern has no effect in almost all cases.",
      "example": "```no_run\nlet mut v = Vec::<String>::new();\nv.iter_mut().filter(|&ref a| a.is_empty());\n\nif let &[ref first, ref second] = v.as_slice() {}\n```\n\nUse instead:\n```no_run\nlet mut v = Vec::<String>::new();\nv.iter_mut().filter(|a| a.is_empty());\n\nif let [first, second] = v.as_slice() {}\n```",
      "version": "pre 1.29.0",
      "source_file": "needless_borrowed_ref.rs",
      "embedding_text": "destructuring a reference and borrowing the inner value\n\nChecks for bindings that needlessly destructure a reference and borrow the inner\nvalue with `&ref`.\n\nThis pattern has no effect in almost all cases."
    },
    {
      "id": "clippy::needless_borrows_for_generic_args",
      "name": "NEEDLESS_BORROWS_FOR_GENERIC_ARGS",
      "snake_name": "needless_borrows_for_generic_args",
      "category": "style",
      "weight": 0.95,
      "brief": "taking a reference that is going to be automatically dereferenced",
      "what_it_does": "Checks for borrow operations (`&`) that are used as a generic argument to a\nfunction when the borrowed value could be used.",
      "why_bad": "Suggests that the receiver of the expression borrows\nthe expression.",
      "example": "```no_run\nfn f(_: impl AsRef<str>) {}\n\nlet x = \"foo\";\nf(&x);\n```\n\nUse instead:\n```no_run\nfn f(_: impl AsRef<str>) {}\n\nlet x = \"foo\";\nf(x);\n```",
      "version": "1.74.0",
      "source_file": "needless_borrows_for_generic_args.rs",
      "embedding_text": "taking a reference that is going to be automatically dereferenced\n\nChecks for borrow operations (`&`) that are used as a generic argument to a\nfunction when the borrowed value could be used.\n\nSuggests that the receiver of the expression borrows\nthe expression."
    },
    {
      "id": "clippy::needless_continue",
      "name": "NEEDLESS_CONTINUE",
      "snake_name": "needless_continue",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "`continue` statements that can be replaced by a rearrangement of code",
      "what_it_does": "The lint checks for `if`-statements appearing in loops\nthat contain a `continue` statement in either their main blocks or their\n`else`-blocks, when omitting the `else`-block possibly with some\nrearrangement of code can make the code easier to understand.\nThe lint also checks if the last statement in the loop is a `continue`",
      "why_bad": "Having explicit `else` blocks for `if` statements\ncontaining `continue` in their THEN branch adds unnecessary branching and\nnesting to the code. Having an else block containing just `continue` can\nalso be better written by grouping the statements following the whole `if`\nstatement within the THEN block and omitting the else block completely.",
      "example": "```no_run\n# fn condition() -> bool { false }\n# fn update_condition() {}\n# let x = false;\nwhile condition() {\nupdate_condition();\nif x {\n// ...\n} else {\ncontinue;\n}\nprintln!(\"Hello, world\");\n}\n```\n\nCould be rewritten as\n\n```no_run\n# fn condition() -> bool { false }\n# fn update_condition() {}\n# let x = false;\nwhile condition() {\nupdate_condition();\nif x {\n// ...\nprintln!(\"Hello, world\");\n}\n}\n```\n\nAs another example, the following code\n\n```no_run\n# fn waiting() -> bool { false }\nloop {\nif waiting() {\ncontinue;\n} else {\n// Do something useful\n}\n# break;\n}\n```\nCould be rewritten as\n\n```no_run\n# fn waiting() -> bool { false }\nloop {\nif waiting() {\ncontinue;\n}\n// Do something useful\n# break;\n}\n```\n\n```rust\n# use std::io::ErrorKind;\n\nfn foo() -> ErrorKind { ErrorKind::NotFound }\nfor _ in 0..10 {\nmatch foo() {\nErrorKind::NotFound => {\neprintln!(\"not found\");\ncontinue\n}\nErrorKind::TimedOut => {\neprintln!(\"timeout\");\ncontinue\n}\n_ => {\neprintln!(\"other error\");\ncontinue\n}\n}\n}\n```\nCould be rewritten as\n\n\n```rust\n# use std::io::ErrorKind;\n\nfn foo() -> ErrorKind { ErrorKind::NotFound }\nfor _ in 0..10 {\nmatch foo() {\nErrorKind::NotFound => {\neprintln!(\"not found\");\n}\nErrorKind::TimedOut => {\neprintln!(\"timeout\");\n}\n_ => {\neprintln!(\"other error\");\n}\n}\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "needless_continue.rs",
      "embedding_text": "`continue` statements that can be replaced by a rearrangement of code\n\nThe lint checks for `if`-statements appearing in loops\nthat contain a `continue` statement in either their main blocks or their\n`else`-blocks, when omitting the `else`-block possibly with some\nrearrangement of code can make the code easier to understand.\nThe lint also checks if the last statement in the loop is a `continue`\n\nHaving explicit `else` blocks for `if` statements\ncontaining `continue` in their THEN branch adds unnecessary branching and\nnesting to the code. Having an else block containing just `continue` can\nalso be better written by grouping the statements following the whole `if`\nstatement within the THEN block and omitting the else block completely."
    },
    {
      "id": "clippy::needless_else",
      "name": "NEEDLESS_ELSE",
      "snake_name": "needless_else",
      "category": "style",
      "weight": 0.95,
      "brief": "empty else branch",
      "what_it_does": "Checks for empty `else` branches.",
      "why_bad": "An empty else branch does nothing and can be removed.",
      "example": "```no_run\n# fn check() -> bool { true }\nif check() {\nprintln!(\"Check successful!\");\n} else {\n}\n```\nUse instead:\n```no_run\n# fn check() -> bool { true }\nif check() {\nprintln!(\"Check successful!\");\n}\n```",
      "version": "1.72.0",
      "source_file": "needless_else.rs",
      "embedding_text": "empty else branch\n\nChecks for empty `else` branches.\n\nAn empty else branch does nothing and can be removed."
    },
    {
      "id": "clippy::needless_for_each",
      "name": "NEEDLESS_FOR_EACH",
      "snake_name": "needless_for_each",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "using `for_each` where a `for` loop would be simpler",
      "what_it_does": "Checks for usage of `for_each` that would be more simply written as a\n`for` loop.",
      "why_bad": "`for_each` may be used after applying iterator transformers like\n`filter` for better readability and performance. It may also be used to fit a simple\noperation on one line.\nBut when none of these apply, a simple `for` loop is more idiomatic.",
      "example": "```no_run\nlet v = vec![0, 1, 2];\nv.iter().for_each(|elem| {\nprintln!(\"{elem}\");\n})\n```\nUse instead:\n```no_run\nlet v = vec![0, 1, 2];\nfor elem in &v {\nprintln!(\"{elem}\");\n}\n```",
      "version": "1.53.0",
      "source_file": "needless_for_each.rs",
      "embedding_text": "using `for_each` where a `for` loop would be simpler\n\nChecks for usage of `for_each` that would be more simply written as a\n`for` loop.\n\n`for_each` may be used after applying iterator transformers like\n`filter` for better readability and performance. It may also be used to fit a simple\noperation on one line.\nBut when none of these apply, a simple `for` loop is more idiomatic."
    },
    {
      "id": "clippy::needless_ifs",
      "name": "NEEDLESS_IFS",
      "snake_name": "needless_ifs",
      "category": "complexity",
      "weight": 1.0,
      "brief": "checks for empty if branches",
      "what_it_does": "Checks for empty `if` branches with no else branch.",
      "why_bad": "It can be entirely omitted, and often the condition too.",
      "example": "```rust,ignore\nif really_expensive_condition(&i) {}\nif really_expensive_condition_with_side_effects(&mut i) {}\n```\nUse instead:\n```rust,ignore\n// <omitted>\nreally_expensive_condition_with_side_effects(&mut i);\n```",
      "version": "1.72.0",
      "source_file": "needless_ifs.rs",
      "embedding_text": "checks for empty if branches\n\nChecks for empty `if` branches with no else branch.\n\nIt can be entirely omitted, and often the condition too."
    },
    {
      "id": "clippy::needless_late_init",
      "name": "NEEDLESS_LATE_INIT",
      "snake_name": "needless_late_init",
      "category": "style",
      "weight": 0.95,
      "brief": "late initializations that can be replaced by a `let` statement with an initializer",
      "what_it_does": "Checks for late initializations that can be replaced by a `let` statement\nwith an initializer.",
      "why_bad": "Assigning in the `let` statement is less repetitive.",
      "example": "```no_run\nlet a;\na = 1;\n\nlet b;\nmatch 3 {\n0 => b = \"zero\",\n1 => b = \"one\",\n_ => b = \"many\",\n}\n\nlet c;\nif true {\nc = 1;\n} else {\nc = -1;\n}\n```\nUse instead:\n```no_run\nlet a = 1;\n\nlet b = match 3 {\n0 => \"zero\",\n1 => \"one\",\n_ => \"many\",\n};\n\nlet c = if true {\n1\n} else {\n-1\n};\n```",
      "version": "1.59.0",
      "source_file": "needless_late_init.rs",
      "embedding_text": "late initializations that can be replaced by a `let` statement with an initializer\n\nChecks for late initializations that can be replaced by a `let` statement\nwith an initializer.\n\nAssigning in the `let` statement is less repetitive."
    },
    {
      "id": "clippy::needless_maybe_sized",
      "name": "NEEDLESS_MAYBE_SIZED",
      "snake_name": "needless_maybe_sized",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "a `?Sized` bound that is unusable due to a `Sized` requirement",
      "what_it_does": "Lints `?Sized` bounds applied to type parameters that cannot be unsized",
      "why_bad": "The `?Sized` bound is misleading because it cannot be satisfied by an\nunsized type",
      "example": "```rust\n// `T` cannot be unsized because `Clone` requires it to be `Sized`\nfn f<T: Clone + ?Sized>(t: &T) {}\n```\nUse instead:\n```rust\nfn f<T: Clone>(t: &T) {}\n\n// or choose alternative bounds for `T` so that it can be unsized\n```",
      "version": "1.81.0",
      "source_file": "needless_maybe_sized.rs",
      "embedding_text": "a `?Sized` bound that is unusable due to a `Sized` requirement\n\nLints `?Sized` bounds applied to type parameters that cannot be unsized\n\nThe `?Sized` bound is misleading because it cannot be satisfied by an\nunsized type"
    },
    {
      "id": "clippy::needless_parens_on_range_literals",
      "name": "NEEDLESS_PARENS_ON_RANGE_LITERALS",
      "snake_name": "needless_parens_on_range_literals",
      "category": "style",
      "weight": 0.95,
      "brief": "needless parenthesis on range literals can be removed",
      "what_it_does": "The lint checks for parenthesis on literals in range statements that are\nsuperfluous.",
      "why_bad": "Having superfluous parenthesis makes the code less readable\noverhead when reading.",
      "example": "```no_run\nfor i in (0)..10 {\nprintln!(\"{i}\");\n}\n```\n\nUse instead:\n\n```no_run\nfor i in 0..10 {\nprintln!(\"{i}\");\n}\n```",
      "version": "1.63.0",
      "source_file": "needless_parens_on_range_literals.rs",
      "embedding_text": "needless parenthesis on range literals can be removed\n\nThe lint checks for parenthesis on literals in range statements that are\nsuperfluous.\n\nHaving superfluous parenthesis makes the code less readable\noverhead when reading."
    },
    {
      "id": "clippy::needless_pass_by_ref_mut",
      "name": "NEEDLESS_PASS_BY_REF_MUT",
      "snake_name": "needless_pass_by_ref_mut",
      "category": "nursery",
      "weight": 0.9,
      "brief": "using a `&mut` argument when it's not mutated",
      "what_it_does": "Check if a `&mut` function argument is actually used mutably.\n\nBe careful if the function is publicly reexported as it would break compatibility with\nusers of this function, when the users pass this function as an argument.",
      "why_bad": "Less `mut` means less fights with the borrow checker. It can also lead to more\nopportunities for parallelization.",
      "example": "```no_run\nfn foo(y: &mut i32) -> i32 {\n12 + *y\n}\n```\nUse instead:\n```no_run\nfn foo(y: &i32) -> i32 {\n12 + *y\n}\n```",
      "version": "1.73.0",
      "source_file": "needless_pass_by_ref_mut.rs",
      "embedding_text": "using a `&mut` argument when it's not mutated\n\nCheck if a `&mut` function argument is actually used mutably.\n\nBe careful if the function is publicly reexported as it would break compatibility with\nusers of this function, when the users pass this function as an argument.\n\nLess `mut` means less fights with the borrow checker. It can also lead to more\nopportunities for parallelization."
    },
    {
      "id": "clippy::needless_pass_by_value",
      "name": "NEEDLESS_PASS_BY_VALUE",
      "snake_name": "needless_pass_by_value",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "functions taking arguments by value, but not consuming them in its body",
      "what_it_does": "Checks for functions taking arguments by value, but not\nconsuming them in its\nbody.",
      "why_bad": "Taking arguments by reference is more flexible and can\nsometimes avoid\nunnecessary allocations.",
      "example": "```no_run\nfn foo(v: Vec<i32>) {\nassert_eq!(v.len(), 42);\n}\n```\nshould be\n```no_run\nfn foo(v: &[i32]) {\nassert_eq!(v.len(), 42);\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "needless_pass_by_value.rs",
      "embedding_text": "functions taking arguments by value, but not consuming them in its body\n\nChecks for functions taking arguments by value, but not\nconsuming them in its\nbody.\n\nTaking arguments by reference is more flexible and can\nsometimes avoid\nunnecessary allocations."
    },
    {
      "id": "clippy::needless_question_mark",
      "name": "NEEDLESS_QUESTION_MARK",
      "snake_name": "needless_question_mark",
      "category": "complexity",
      "weight": 1.0,
      "brief": "using `Ok(x?)` or `Some(x?)` where `x` would be equivalent",
      "what_it_does": "Suggests replacing `Ok(x?)` or `Some(x?)` with `x` in return positions where the `?` operator\nis not needed to convert the type of `x`.",
      "why_bad": "There's no reason to use `?` to short-circuit when execution of the body will end there anyway.",
      "example": "```no_run\n# use std::num::ParseIntError;\nfn f(s: &str) -> Option<usize> {\nSome(s.find('x')?)\n}\n\nfn g(s: &str) -> Result<usize, ParseIntError> {\nOk(s.parse()?)\n}\n```\nUse instead:\n```no_run\n# use std::num::ParseIntError;\nfn f(s: &str) -> Option<usize> {\ns.find('x')\n}\n\nfn g(s: &str) -> Result<usize, ParseIntError> {\ns.parse()\n}\n```",
      "version": "1.51.0",
      "source_file": "needless_question_mark.rs",
      "embedding_text": "using `Ok(x?)` or `Some(x?)` where `x` would be equivalent\n\nSuggests replacing `Ok(x?)` or `Some(x?)` with `x` in return positions where the `?` operator\nis not needed to convert the type of `x`.\n\nThere's no reason to use `?` to short-circuit when execution of the body will end there anyway."
    },
    {
      "id": "clippy::needless_update",
      "name": "NEEDLESS_UPDATE",
      "snake_name": "needless_update",
      "category": "complexity",
      "weight": 1.0,
      "brief": "using `Foo { ..base }` when there are no missing fields",
      "what_it_does": "Checks for needlessly including a base struct on update\nwhen all fields are changed anyway.\n\nThis lint is not applied to structs marked with\n[non_exhaustive](https://doc.rust-lang.org/reference/attributes/type_system.html).",
      "why_bad": "This will cost resources (because the base has to be\nsomewhere), and make the code less readable.",
      "example": "```no_run\n# struct Point {\n#     x: i32,\n#     y: i32,\n#     z: i32,\n# }\n# let zero_point = Point { x: 0, y: 0, z: 0 };\nPoint {\nx: 1,\ny: 1,\nz: 1,\n..zero_point\n};\n```\n\nUse instead:\n```rust,ignore\n// Missing field `z`\nPoint {\nx: 1,\ny: 1,\n..zero_point\n};\n```",
      "version": "pre 1.29.0",
      "source_file": "needless_update.rs",
      "embedding_text": "using `Foo { ..base }` when there are no missing fields\n\nChecks for needlessly including a base struct on update\nwhen all fields are changed anyway.\n\nThis lint is not applied to structs marked with\n[non_exhaustive](https://doc.rust-lang.org/reference/attributes/type_system.html).\n\nThis will cost resources (because the base has to be\nsomewhere), and make the code less readable."
    },
    {
      "id": "clippy::neg_cmp_op_on_partial_ord",
      "name": "NEG_CMP_OP_ON_PARTIAL_ORD",
      "snake_name": "neg_cmp_op_on_partial_ord",
      "category": "complexity",
      "weight": 1.0,
      "brief": "The use of negated comparison operators on partially ordered types may produce confusing code.",
      "what_it_does": "Checks for the usage of negated comparison operators on types which only implement\n`PartialOrd` (e.g., `f64`).",
      "why_bad": "These operators make it easy to forget that the underlying types actually allow not only three\npotential Orderings (Less, Equal, Greater) but also a fourth one (Uncomparable). This is\nespecially easy to miss if the operator based comparison result is negated.",
      "example": "```no_run\nlet a = 1.0;\nlet b = f64::NAN;\n\nlet not_less_or_equal = !(a <= b);\n```\n\nUse instead:\n```no_run\nuse std::cmp::Ordering;\n# let a = 1.0;\n# let b = f64::NAN;\n\nlet _not_less_or_equal = match a.partial_cmp(&b) {\nNone | Some(Ordering::Greater) => true,\n_ => false,\n};\n```",
      "version": "pre 1.29.0",
      "source_file": "neg_cmp_op_on_partial_ord.rs",
      "embedding_text": "The use of negated comparison operators on partially ordered types may produce confusing code.\n\nChecks for the usage of negated comparison operators on types which only implement\n`PartialOrd` (e.g., `f64`).\n\nThese operators make it easy to forget that the underlying types actually allow not only three\npotential Orderings (Less, Equal, Greater) but also a fourth one (Uncomparable). This is\nespecially easy to miss if the operator based comparison result is negated."
    },
    {
      "id": "clippy::neg_multiply",
      "name": "NEG_MULTIPLY",
      "snake_name": "neg_multiply",
      "category": "style",
      "weight": 0.95,
      "brief": "multiplying integers by `-1`",
      "what_it_does": "Checks for multiplication by -1 as a form of negation.",
      "why_bad": "It's more readable to just negate.",
      "example": "```rust,ignore\nlet a = x * -1;\n```\n\nUse instead:\n```rust,ignore\nlet a = -x;\n```",
      "version": "pre 1.29.0",
      "source_file": "neg_multiply.rs",
      "embedding_text": "multiplying integers by `-1`\n\nChecks for multiplication by -1 as a form of negation.\n\nIt's more readable to just negate."
    },
    {
      "id": "clippy::new_without_default",
      "name": "NEW_WITHOUT_DEFAULT",
      "snake_name": "new_without_default",
      "category": "style",
      "weight": 0.95,
      "brief": "`pub fn new() -> Self` method without `Default` implementation",
      "what_it_does": "Checks for public types with a `pub fn new() -> Self` method and no\nimplementation of\n[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html).",
      "why_bad": "The user might expect to be able to use\n[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) as the\ntype can be constructed without arguments.",
      "example": "```ignore\npub struct Foo(Bar);\n\nimpl Foo {\npub fn new() -> Self {\nFoo(Bar::new())\n}\n}\n```\n\nTo fix the lint, add a `Default` implementation that delegates to `new`:\n\n```ignore\npub struct Foo(Bar);\n\nimpl Default for Foo {\nfn default() -> Self {\nFoo::new()\n}\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "new_without_default.rs",
      "embedding_text": "`pub fn new() -> Self` method without `Default` implementation\n\nChecks for public types with a `pub fn new() -> Self` method and no\nimplementation of\n[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html).\n\nThe user might expect to be able to use\n[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) as the\ntype can be constructed without arguments."
    },
    {
      "id": "clippy::no_effect",
      "name": "NO_EFFECT",
      "snake_name": "no_effect",
      "category": "complexity",
      "weight": 1.0,
      "brief": "statements with no effect",
      "what_it_does": "Checks for statements which have no effect.",
      "why_bad": "Unlike dead code, these statements are actually\nexecuted. However, as they have no effect, all they do is make the code less\nreadable.",
      "example": "```no_run\n0;\n```",
      "version": "pre 1.29.0",
      "source_file": "no_effect.rs",
      "embedding_text": "statements with no effect\n\nChecks for statements which have no effect.\n\nUnlike dead code, these statements are actually\nexecuted. However, as they have no effect, all they do is make the code less\nreadable."
    },
    {
      "id": "clippy::no_effect_underscore_binding",
      "name": "NO_EFFECT_UNDERSCORE_BINDING",
      "snake_name": "no_effect_underscore_binding",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "binding to `_` prefixed variable with no side-effect",
      "what_it_does": "Checks for binding to underscore prefixed variable without side-effects.",
      "why_bad": "Unlike dead code, these bindings are actually\nexecuted. However, as they have no effect and shouldn't be used further on, all they\ndo is make the code less readable.",
      "example": "```rust,ignore\nlet _i_serve_no_purpose = 1;\n```",
      "version": "1.58.0",
      "source_file": "no_effect.rs",
      "embedding_text": "binding to `_` prefixed variable with no side-effect\n\nChecks for binding to underscore prefixed variable without side-effects.\n\nUnlike dead code, these bindings are actually\nexecuted. However, as they have no effect and shouldn't be used further on, all they\ndo is make the code less readable."
    },
    {
      "id": "clippy::unnecessary_operation",
      "name": "UNNECESSARY_OPERATION",
      "snake_name": "unnecessary_operation",
      "category": "complexity",
      "weight": 1.0,
      "brief": "outer expressions with no effect",
      "what_it_does": "Checks for expression statements that can be reduced to a\nsub-expression.",
      "why_bad": "Expressions by themselves often have no side-effects.\nHaving such expressions reduces readability.",
      "example": "```rust,ignore\ncompute_array()[0];\n```",
      "version": "pre 1.29.0",
      "source_file": "no_effect.rs",
      "embedding_text": "outer expressions with no effect\n\nChecks for expression statements that can be reduced to a\nsub-expression.\n\nExpressions by themselves often have no side-effects.\nHaving such expressions reduces readability."
    },
    {
      "id": "clippy::no_mangle_with_rust_abi",
      "name": "NO_MANGLE_WITH_RUST_ABI",
      "snake_name": "no_mangle_with_rust_abi",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "convert Rust ABI functions to C ABI",
      "what_it_does": "Checks for Rust ABI functions with the `#[no_mangle]` attribute.",
      "why_bad": "The Rust ABI is not stable, but in many simple cases matches\nenough with the C ABI that it is possible to forget to add\n`extern \"C\"` to a function called from C. Changes to the\nRust ABI can break this at any point.",
      "example": "```rust,ignore\n#[no_mangle]\nfn example(arg_one: u32, arg_two: usize) {}\n```\n\nUse instead:\n```rust,ignore\n#[no_mangle]\nextern \"C\" fn example(arg_one: u32, arg_two: usize) {}\n```",
      "version": "1.69.0",
      "source_file": "no_mangle_with_rust_abi.rs",
      "embedding_text": "convert Rust ABI functions to C ABI\n\nChecks for Rust ABI functions with the `#[no_mangle]` attribute.\n\nThe Rust ABI is not stable, but in many simple cases matches\nenough with the C ABI that it is possible to forget to add\n`extern \"C\"` to a function called from C. Changes to the\nRust ABI can break this at any point."
    },
    {
      "id": "clippy::non_canonical_clone_impl",
      "name": "NON_CANONICAL_CLONE_IMPL",
      "snake_name": "non_canonical_clone_impl",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "non-canonical implementation of `Clone` on a `Copy` type",
      "what_it_does": "Checks for non-canonical implementations of `Clone` when `Copy` is already implemented.",
      "why_bad": "If both `Clone` and `Copy` are implemented, they must agree. This can done by dereferencing\n`self` in `Clone`'s implementation, which will avoid any possibility of the implementations\nbecoming out of sync.",
      "example": "```rust,ignore\n#[derive(Eq, PartialEq)]\nstruct A(u32);\n\nimpl Clone for A {\nfn clone(&self) -> Self {\nSelf(self.0)\n}\n}\n\nimpl Copy for A {}\n```\nUse instead:\n```rust,ignore\n#[derive(Eq, PartialEq)]\nstruct A(u32);\n\nimpl Clone for A {\nfn clone(&self) -> Self {\n*self\n}\n}\n\nimpl Copy for A {}\n```",
      "version": "1.72.0",
      "source_file": "non_canonical_impls.rs",
      "embedding_text": "non-canonical implementation of `Clone` on a `Copy` type\n\nChecks for non-canonical implementations of `Clone` when `Copy` is already implemented.\n\nIf both `Clone` and `Copy` are implemented, they must agree. This can done by dereferencing\n`self` in `Clone`'s implementation, which will avoid any possibility of the implementations\nbecoming out of sync."
    },
    {
      "id": "clippy::non_canonical_partial_ord_impl",
      "name": "NON_CANONICAL_PARTIAL_ORD_IMPL",
      "snake_name": "non_canonical_partial_ord_impl",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "non-canonical implementation of `PartialOrd` on an `Ord` type",
      "what_it_does": "Checks for non-canonical implementations of `PartialOrd` when `Ord` is already implemented.",
      "why_bad": "If both `PartialOrd` and `Ord` are implemented, they must agree. This is commonly done by\nwrapping the result of `cmp` in `Some` for `partial_cmp`. Not doing this may silently\nintroduce an error upon refactoring.",
      "example": "```no_run\n# use std::cmp::Ordering;\n#[derive(Eq, PartialEq)]\nstruct A(u32);\n\nimpl Ord for A {\nfn cmp(&self, other: &Self) -> Ordering {\n// ...\n#       todo!();\n}\n}\n\nimpl PartialOrd for A {\nfn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n// ...\n#       todo!();\n}\n}\n```\nUse instead:\n```no_run\n# use std::cmp::Ordering;\n#[derive(Eq, PartialEq)]\nstruct A(u32);\n\nimpl Ord for A {\nfn cmp(&self, other: &Self) -> Ordering {\n// ...\n#       todo!();\n}\n}\n\nimpl PartialOrd for A {\nfn partial_cmp(&self, other: &Self) -> Option<Ordering> {\nSome(self.cmp(other))   // or self.cmp(other).into()\n}\n}\n```",
      "version": "1.73.0",
      "source_file": "non_canonical_impls.rs",
      "embedding_text": "non-canonical implementation of `PartialOrd` on an `Ord` type\n\nChecks for non-canonical implementations of `PartialOrd` when `Ord` is already implemented.\n\nIf both `PartialOrd` and `Ord` are implemented, they must agree. This is commonly done by\nwrapping the result of `cmp` in `Some` for `partial_cmp`. Not doing this may silently\nintroduce an error upon refactoring."
    },
    {
      "id": "clippy::declare_interior_mutable_const",
      "name": "DECLARE_INTERIOR_MUTABLE_CONST",
      "snake_name": "declare_interior_mutable_const",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "declaring `const` with interior mutability",
      "what_it_does": "Checks for the declaration of named constant which contain interior mutability.",
      "why_bad": "Named constants are copied at every use site which means any change to their value\nwill be lost after the newly created value is dropped. e.g.\n\n```rust\nuse core::sync::atomic::{AtomicUsize, Ordering};\nconst ATOMIC: AtomicUsize = AtomicUsize::new(0);\nfn add_one() -> usize {\n// This will always return `0` since `ATOMIC` is copied before it's used.\nATOMIC.fetch_add(1, Ordering::AcqRel)\n}\n```\n\nIf shared modification of the value is desired, a `static` item is needed instead.\nIf that is not desired, a `const fn` constructor should be used to make it obvious\nat the use site that a new value is created.",
      "example": "```no_run\nuse std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n\nconst CONST_ATOM: AtomicUsize = AtomicUsize::new(12);\nCONST_ATOM.store(6, SeqCst); // the content of the atomic is unchanged\nassert_eq!(CONST_ATOM.load(SeqCst), 12); // because the CONST_ATOM in these lines are distinct\n```\n\nUse instead:\n```no_run\n# use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\nstatic STATIC_ATOM: AtomicUsize = AtomicUsize::new(15);\nSTATIC_ATOM.store(9, SeqCst);\nassert_eq!(STATIC_ATOM.load(SeqCst), 9); // use a `static` item to refer to the same instance\n```",
      "version": "pre 1.29.0",
      "source_file": "non_copy_const.rs",
      "embedding_text": "declaring `const` with interior mutability\n\nChecks for the declaration of named constant which contain interior mutability.\n\nNamed constants are copied at every use site which means any change to their value\nwill be lost after the newly created value is dropped. e.g.\n\n```rust\nuse core::sync::atomic::{AtomicUsize, Ordering};\nconst ATOMIC: AtomicUsize = AtomicUsize::new(0);\nfn add_one() -> usize {\n// This will always return `0` since `ATOMIC` is copied before it's used.\nATOMIC.fetch_add(1, Ordering::AcqRel)\n}\n```\n\nIf shared modification of the value is desired, a `static` item is needed instead.\nIf that is not desired, a `const fn` constructor should be used to make it obvious\nat the use site that a new value is created."
    },
    {
      "id": "clippy::borrow_interior_mutable_const",
      "name": "BORROW_INTERIOR_MUTABLE_CONST",
      "snake_name": "borrow_interior_mutable_const",
      "category": "style",
      "weight": 0.95,
      "brief": "referencing `const` with interior mutability",
      "what_it_does": "Checks for a borrow of a named constant with interior mutability.",
      "why_bad": "Named constants are copied at every use site which means any change to their value\nwill be lost after the newly created value is dropped. e.g.\n\n```rust\nuse core::sync::atomic::{AtomicUsize, Ordering};\nconst ATOMIC: AtomicUsize = AtomicUsize::new(0);\nfn add_one() -> usize {\n// This will always return `0` since `ATOMIC` is copied before it's borrowed\n// for use by `fetch_add`.\nATOMIC.fetch_add(1, Ordering::AcqRel)\n}\n```",
      "example": "```no_run\nuse std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\nconst CONST_ATOM: AtomicUsize = AtomicUsize::new(12);\n\nCONST_ATOM.store(6, SeqCst); // the content of the atomic is unchanged\nassert_eq!(CONST_ATOM.load(SeqCst), 12); // because the CONST_ATOM in these lines are distinct\n```\n\nUse instead:\n```no_run\nuse std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\nconst CONST_ATOM: AtomicUsize = AtomicUsize::new(12);\n\nstatic STATIC_ATOM: AtomicUsize = CONST_ATOM;\nSTATIC_ATOM.store(9, SeqCst);\nassert_eq!(STATIC_ATOM.load(SeqCst), 9); // use a `static` item to refer to the same instance\n```",
      "version": "pre 1.29.0",
      "source_file": "non_copy_const.rs",
      "embedding_text": "referencing `const` with interior mutability\n\nChecks for a borrow of a named constant with interior mutability.\n\nNamed constants are copied at every use site which means any change to their value\nwill be lost after the newly created value is dropped. e.g.\n\n```rust\nuse core::sync::atomic::{AtomicUsize, Ordering};\nconst ATOMIC: AtomicUsize = AtomicUsize::new(0);\nfn add_one() -> usize {\n// This will always return `0` since `ATOMIC` is copied before it's borrowed\n// for use by `fetch_add`.\nATOMIC.fetch_add(1, Ordering::AcqRel)\n}\n```"
    },
    {
      "id": "clippy::similar_names",
      "name": "SIMILAR_NAMES",
      "snake_name": "similar_names",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "similarly named items and bindings",
      "what_it_does": "Checks for names that are very similar and thus confusing.\n\nNote: this lint looks for similar names throughout each\nscope. To allow it, you need to allow it on the scope\nlevel, not on the name that is reported.",
      "why_bad": "It's hard to distinguish between names that differ only\nby a single character.",
      "example": "```ignore\nlet checked_exp = something;\nlet checked_expr = something_else;\n```",
      "version": "pre 1.29.0",
      "source_file": "non_expressive_names.rs",
      "embedding_text": "similarly named items and bindings\n\nChecks for names that are very similar and thus confusing.\n\nNote: this lint looks for similar names throughout each\nscope. To allow it, you need to allow it on the scope\nlevel, not on the name that is reported.\n\nIt's hard to distinguish between names that differ only\nby a single character."
    },
    {
      "id": "clippy::many_single_char_names",
      "name": "MANY_SINGLE_CHAR_NAMES",
      "snake_name": "many_single_char_names",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "too many single character bindings",
      "what_it_does": "Checks for too many variables whose name consists of a\nsingle character.",
      "why_bad": "It's hard to memorize what a variable means without a\ndescriptive name.",
      "example": "```ignore\nlet (a, b, c, d, e, f, g) = (...);\n```",
      "version": "pre 1.29.0",
      "source_file": "non_expressive_names.rs",
      "embedding_text": "too many single character bindings\n\nChecks for too many variables whose name consists of a\nsingle character.\n\nIt's hard to memorize what a variable means without a\ndescriptive name."
    },
    {
      "id": "clippy::just_underscores_and_digits",
      "name": "JUST_UNDERSCORES_AND_DIGITS",
      "snake_name": "just_underscores_and_digits",
      "category": "style",
      "weight": 0.95,
      "brief": "unclear name",
      "what_it_does": "Checks if you have variables whose name consists of just\nunderscores and digits.",
      "why_bad": "It's hard to memorize what a variable means without a\ndescriptive name.",
      "example": "```no_run\nlet _1 = 1;\nlet ___1 = 1;\nlet __1___2 = 11;\n```",
      "version": "pre 1.29.0",
      "source_file": "non_expressive_names.rs",
      "embedding_text": "unclear name\n\nChecks if you have variables whose name consists of just\nunderscores and digits.\n\nIt's hard to memorize what a variable means without a\ndescriptive name."
    },
    {
      "id": "clippy::non_octal_unix_permissions",
      "name": "NON_OCTAL_UNIX_PERMISSIONS",
      "snake_name": "non_octal_unix_permissions",
      "category": "correctness",
      "weight": 1.2,
      "brief": "use of non-octal value to set unix file permissions, which will be translated into octal",
      "what_it_does": "Checks for non-octal values used to set Unix file permissions.",
      "why_bad": "They will be converted into octal, creating potentially\nunintended file permissions.",
      "example": "```rust,ignore\nuse std::fs::OpenOptions;\nuse std::os::unix::fs::OpenOptionsExt;\n\nlet mut options = OpenOptions::new();\noptions.mode(644);\n```\nUse instead:\n```rust,ignore\nuse std::fs::OpenOptions;\nuse std::os::unix::fs::OpenOptionsExt;\n\nlet mut options = OpenOptions::new();\noptions.mode(0o644);\n```",
      "version": "1.53.0",
      "source_file": "non_octal_unix_permissions.rs",
      "embedding_text": "use of non-octal value to set unix file permissions, which will be translated into octal\n\nChecks for non-octal values used to set Unix file permissions.\n\nThey will be converted into octal, creating potentially\nunintended file permissions."
    },
    {
      "id": "clippy::non_send_fields_in_send_ty",
      "name": "NON_SEND_FIELDS_IN_SEND_TY",
      "snake_name": "non_send_fields_in_send_ty",
      "category": "nursery",
      "weight": 0.9,
      "brief": "there is a field that is not safe to be sent to another thread in a `Send` struct",
      "what_it_does": "This lint warns about a `Send` implementation for a type that\ncontains fields that are not safe to be sent across threads.\nIt tries to detect fields that can cause a soundness issue\nwhen sent to another thread (e.g., `Rc`) while allowing `!Send` fields\nthat are expected to exist in a `Send` type, such as raw pointers.",
      "why_bad": "Sending the struct to another thread effectively sends all of its fields,\nand the fields that do not implement `Send` can lead to soundness bugs\nsuch as data races when accessed in a thread\nthat is different from the thread that created it.\n\nSee:\n* [*The Rustonomicon* about *Send and Sync*](https://doc.rust-lang.org/nomicon/send-and-sync.html)\n* [The documentation of `Send`](https://doc.rust-lang.org/std/marker/trait.Send.html)",
      "example": "```rust,ignore\nstruct ExampleStruct<T> {\nrc_is_not_send: Rc<String>,\nunbounded_generic_field: T,\n}\n\n// This impl is unsound because it allows sending `!Send` types through `ExampleStruct`\nunsafe impl<T> Send for ExampleStruct<T> {}\n```\nUse thread-safe types like [`std::sync::Arc`](https://doc.rust-lang.org/std/sync/struct.Arc.html)\nor specify correct bounds on generic type parameters (`T: Send`).",
      "version": "1.57.0",
      "source_file": "non_send_fields_in_send_ty.rs",
      "embedding_text": "there is a field that is not safe to be sent to another thread in a `Send` struct\n\nThis lint warns about a `Send` implementation for a type that\ncontains fields that are not safe to be sent across threads.\nIt tries to detect fields that can cause a soundness issue\nwhen sent to another thread (e.g., `Rc`) while allowing `!Send` fields\nthat are expected to exist in a `Send` type, such as raw pointers.\n\nSending the struct to another thread effectively sends all of its fields,\nand the fields that do not implement `Send` can lead to soundness bugs\nsuch as data races when accessed in a thread\nthat is different from the thread that created it.\n\nSee:\n* [*The Rustonomicon* about *Send and Sync*](https://doc.rust-lang.org/nomicon/send-and-sync.html)\n* [The documentation of `Send`](https://doc.rust-lang.org/std/marker/trait.Send.html)"
    },
    {
      "id": "clippy::non_std_lazy_statics",
      "name": "NON_STD_LAZY_STATICS",
      "snake_name": "non_std_lazy_statics",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "lazy static that could be replaced by `std::sync::LazyLock`",
      "what_it_does": "Lints when `once_cell::sync::Lazy` or `lazy_static!` are used to define a static variable,\nand suggests replacing such cases with `std::sync::LazyLock` instead.\n\nNote: This lint will not trigger in crate with `no_std` context, or with MSRV < 1.80.0. It\nalso will not trigger on `once_cell::sync::Lazy` usage in crates which use other types\nfrom `once_cell`, such as `once_cell::race::OnceBox`.",
      "why_bad": "- Reduces the need for an extra dependency\n- Enforce convention of using standard library types when possible",
      "example": "```ignore\nlazy_static! {\nstatic ref FOO: String = \"foo\".to_uppercase();\n}\nstatic BAR: once_cell::sync::Lazy<String> = once_cell::sync::Lazy::new(|| \"BAR\".to_lowercase());\n```\nUse instead:\n```ignore\nstatic FOO: std::sync::LazyLock<String> = std::sync::LazyLock::new(|| \"FOO\".to_lowercase());\nstatic BAR: std::sync::LazyLock<String> = std::sync::LazyLock::new(|| \"BAR\".to_lowercase());\n```",
      "version": "1.86.0",
      "source_file": "non_std_lazy_statics.rs",
      "embedding_text": "lazy static that could be replaced by `std::sync::LazyLock`\n\nLints when `once_cell::sync::Lazy` or `lazy_static!` are used to define a static variable,\nand suggests replacing such cases with `std::sync::LazyLock` instead.\n\nNote: This lint will not trigger in crate with `no_std` context, or with MSRV < 1.80.0. It\nalso will not trigger on `once_cell::sync::Lazy` usage in crates which use other types\nfrom `once_cell`, such as `once_cell::race::OnceBox`.\n\n- Reduces the need for an extra dependency\n- Enforce convention of using standard library types when possible"
    },
    {
      "id": "clippy::non_zero_suggestions",
      "name": "NON_ZERO_SUGGESTIONS",
      "snake_name": "non_zero_suggestions",
      "category": "restriction",
      "weight": 1.0,
      "brief": "suggests using `NonZero#` from `u#` or `i#` for more efficient and type-safe conversions",
      "what_it_does": "Checks for conversions from `NonZero` types to regular integer types,\nand suggests using `NonZero` types for the target as well.",
      "why_bad": "Converting from `NonZero` types to regular integer types and then back to `NonZero`\ntypes is less efficient and loses the type-safety guarantees provided by `NonZero` types.\nUsing `NonZero` types consistently can lead to more optimized code and prevent\ncertain classes of errors related to zero values.",
      "example": "```no_run\nuse std::num::{NonZeroU32, NonZeroU64};\n\nfn example(x: u64, y: NonZeroU32) {\n// Bad: Converting NonZeroU32 to u64 unnecessarily\nlet r1 = x / u64::from(y.get());\nlet r2 = x % u64::from(y.get());\n}\n```\nUse instead:\n```no_run\nuse std::num::{NonZeroU32, NonZeroU64};\n\nfn example(x: u64, y: NonZeroU32) {\n// Good: Preserving the NonZero property\nlet r1 = x / NonZeroU64::from(y);\nlet r2 = x % NonZeroU64::from(y);\n}\n```",
      "version": "1.83.0",
      "source_file": "non_zero_suggestions.rs",
      "embedding_text": "suggests using `NonZero#` from `u#` or `i#` for more efficient and type-safe conversions\n\nChecks for conversions from `NonZero` types to regular integer types,\nand suggests using `NonZero` types for the target as well.\n\nConverting from `NonZero` types to regular integer types and then back to `NonZero`\ntypes is less efficient and loses the type-safety guarantees provided by `NonZero` types.\nUsing `NonZero` types consistently can lead to more optimized code and prevent\ncertain classes of errors related to zero values."
    },
    {
      "id": "clippy::nonstandard_macro_braces",
      "name": "NONSTANDARD_MACRO_BRACES",
      "snake_name": "nonstandard_macro_braces",
      "category": "nursery",
      "weight": 0.9,
      "brief": "check consistent use of braces in macro",
      "what_it_does": "Checks that common macros are used with consistent bracing.",
      "why_bad": "Having non-conventional braces on well-stablished macros can be confusing\nwhen debugging, and they bring incosistencies with the rest of the ecosystem.",
      "example": "```no_run\nvec!{1, 2, 3};\n```\nUse instead:\n```no_run\nvec![1, 2, 3];\n```",
      "version": "1.55.0",
      "source_file": "nonstandard_macro_braces.rs",
      "embedding_text": "check consistent use of braces in macro\n\nChecks that common macros are used with consistent bracing.\n\nHaving non-conventional braces on well-stablished macros can be confusing\nwhen debugging, and they bring incosistencies with the rest of the ecosystem."
    },
    {
      "id": "clippy::octal_escapes",
      "name": "OCTAL_ESCAPES",
      "snake_name": "octal_escapes",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "string escape sequences looking like octal characters",
      "what_it_does": "Checks for `\\0` escapes in string and byte literals that look like octal\ncharacter escapes in C.",
      "why_bad": "C and other languages support octal character escapes in strings, where\na backslash is followed by up to three octal digits. For example, `\\033`\nstands for the ASCII character 27 (ESC). Rust does not support this\nnotation, but has the escape code `\\0` which stands for a null\nbyte/character, and any following digits do not form part of the escape\nsequence. Therefore, `\\033` is not a compiler error but the result may\nbe surprising.",
      "example": "```no_run\nlet one = \"\\033[1m Bold? \\033[0m\";  // \\033 intended as escape\nlet two = \"\\033\\0\";                 // \\033 intended as null-3-3\n```\n\nUse instead:\n```no_run\nlet one = \"\\x1b[1mWill this be bold?\\x1b[0m\";\nlet two = \"\\x0033\\x00\";\n```",
      "version": "1.59.0",
      "source_file": "octal_escapes.rs",
      "embedding_text": "string escape sequences looking like octal characters\n\nChecks for `\\0` escapes in string and byte literals that look like octal\ncharacter escapes in C.\n\nC and other languages support octal character escapes in strings, where\na backslash is followed by up to three octal digits. For example, `\\033`\nstands for the ASCII character 27 (ESC). Rust does not support this\nnotation, but has the escape code `\\0` which stands for a null\nbyte/character, and any following digits do not form part of the escape\nsequence. Therefore, `\\033` is not a compiler error but the result may\nbe surprising."
    },
    {
      "id": "clippy::only_used_in_recursion",
      "name": "ONLY_USED_IN_RECURSION",
      "snake_name": "only_used_in_recursion",
      "category": "complexity",
      "weight": 1.0,
      "brief": "arguments that is only used in recursion can be removed",
      "what_it_does": "Checks for arguments that are only used in recursion with no side-effects.",
      "why_bad": "It could contain a useless calculation and can make function simpler.\n\nThe arguments can be involved in calculations and assignments but as long as\nthe calculations have no side-effects (function calls or mutating dereference)\nand the assigned variables are also only in recursion, it is useless.",
      "example": "```no_run\nfn f(a: usize, b: usize) -> usize {\nif a == 0 {\n1\n} else {\nf(a - 1, b + 1)\n}\n}\n# fn main() {\n#     print!(\"{}\", f(1, 1));\n# }\n```\nUse instead:\n```no_run\nfn f(a: usize) -> usize {\nif a == 0 {\n1\n} else {\nf(a - 1)\n}\n}\n# fn main() {\n#     print!(\"{}\", f(1));\n# }\n```",
      "version": "1.61.0",
      "source_file": "only_used_in_recursion.rs",
      "embedding_text": "arguments that is only used in recursion can be removed\n\nChecks for arguments that are only used in recursion with no side-effects.\n\nIt could contain a useless calculation and can make function simpler.\n\nThe arguments can be involved in calculations and assignments but as long as\nthe calculations have no side-effects (function calls or mutating dereference)\nand the assigned variables are also only in recursion, it is useless."
    },
    {
      "id": "clippy::self_only_used_in_recursion",
      "name": "SELF_ONLY_USED_IN_RECURSION",
      "snake_name": "self_only_used_in_recursion",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "self receiver only used to recursively call method can be removed",
      "what_it_does": "Checks for `self` receiver that is only used in recursion with no side-effects.",
      "why_bad": "It may be possible to remove the `self` argument, allowing the function to be\nused without an object of type `Self`.",
      "example": "```no_run\nstruct Foo;\nimpl Foo {\nfn f(&self, n: u32) -> u32 {\nif n == 0 {\n1\n} else {\nn * self.f(n - 1)\n}\n}\n}\n# fn main() {\n#     print!(\"{}\", Foo.f(10));\n# }\n```\nUse instead:\n```no_run\nstruct Foo;\nimpl Foo {\nfn f(n: u32) -> u32 {\nif n == 0 {\n1\n} else {\nn * Self::f(n - 1)\n}\n}\n}\n# fn main() {\n#     print!(\"{}\", Foo::f(10));\n# }\n```",
      "version": "1.92.0",
      "source_file": "only_used_in_recursion.rs",
      "embedding_text": "self receiver only used to recursively call method can be removed\n\nChecks for `self` receiver that is only used in recursion with no side-effects.\n\nIt may be possible to remove the `self` argument, allowing the function to be\nused without an object of type `Self`."
    },
    {
      "id": "clippy::absurd_extreme_comparisons",
      "name": "ABSURD_EXTREME_COMPARISONS",
      "snake_name": "absurd_extreme_comparisons",
      "category": "correctness",
      "weight": 1.2,
      "brief": "a comparison with a maximum or minimum value that is always true or false",
      "what_it_does": "Checks for comparisons where one side of the relation is\neither the minimum or maximum value for its type and warns if it involves a\ncase that is always true or always false. Only integer and boolean types are\nchecked.",
      "why_bad": "An expression like `min <= x` may misleadingly imply\nthat it is possible for `x` to be less than the minimum. Expressions like\n`max < x` are probably mistakes.",
      "example": "```no_run\nlet vec: Vec<isize> = Vec::new();\nif vec.len() <= 0 {}\nif 100 > i32::MAX {}\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "a comparison with a maximum or minimum value that is always true or false\n\nChecks for comparisons where one side of the relation is\neither the minimum or maximum value for its type and warns if it involves a\ncase that is always true or always false. Only integer and boolean types are\nchecked.\n\nAn expression like `min <= x` may misleadingly imply\nthat it is possible for `x` to be less than the minimum. Expressions like\n`max < x` are probably mistakes."
    },
    {
      "id": "clippy::arithmetic_side_effects",
      "name": "ARITHMETIC_SIDE_EFFECTS",
      "snake_name": "arithmetic_side_effects",
      "category": "restriction",
      "weight": 1.0,
      "brief": "any arithmetic expression that can cause side effects like overflows or panics",
      "what_it_does": "Checks any kind of arithmetic operation of any type.\n\nOperators like `+`, `-`, `*` or `<<` are usually capable of overflowing according to the [Rust\nReference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#overflow),\nor can panic (`/`, `%`).\n\nKnown safe built-in types like `Wrapping` or `Saturating`, floats, operations in constant\nenvironments, allowed types and non-constant operations that won't overflow are ignored.",
      "why_bad": "For integers, overflow will trigger a panic in debug builds or wrap the result in\nrelease mode; division by zero will cause a panic in either mode. As a result, it is\ndesirable to explicitly call checked, wrapping or saturating arithmetic methods.",
      "example": "```no_run\n// `n` can be any number, including `i32::MAX`.\nfn foo(n: i32) -> i32 {\nn + 1\n}\n```\n\nThird-party types can also overflow or present unwanted side-effects.",
      "version": "1.64.0",
      "source_file": "mod.rs",
      "embedding_text": "any arithmetic expression that can cause side effects like overflows or panics\n\nChecks any kind of arithmetic operation of any type.\n\nOperators like `+`, `-`, `*` or `<<` are usually capable of overflowing according to the [Rust\nReference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#overflow),\nor can panic (`/`, `%`).\n\nKnown safe built-in types like `Wrapping` or `Saturating`, floats, operations in constant\nenvironments, allowed types and non-constant operations that won't overflow are ignored.\n\nFor integers, overflow will trigger a panic in debug builds or wrap the result in\nrelease mode; division by zero will cause a panic in either mode. As a result, it is\ndesirable to explicitly call checked, wrapping or saturating arithmetic methods."
    },
    {
      "id": "clippy::float_arithmetic",
      "name": "FLOAT_ARITHMETIC",
      "snake_name": "float_arithmetic",
      "category": "restriction",
      "weight": 1.0,
      "brief": "any floating-point arithmetic statement",
      "what_it_does": "Checks for float arithmetic.",
      "why_bad": "For some embedded systems or kernel development, it\ncan be useful to rule out floating-point numbers.",
      "example": "```no_run\n# let a = 0.0;\na + 1.0;\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "any floating-point arithmetic statement\n\nChecks for float arithmetic.\n\nFor some embedded systems or kernel development, it\ncan be useful to rule out floating-point numbers."
    },
    {
      "id": "clippy::assign_op_pattern",
      "name": "ASSIGN_OP_PATTERN",
      "snake_name": "assign_op_pattern",
      "category": "style",
      "weight": 0.95,
      "brief": "assigning the result of an operation on a variable to that same variable",
      "what_it_does": "Checks for `a = a op b` or `a = b commutative_op a`\npatterns.",
      "why_bad": "These can be written as the shorter `a op= b`.",
      "example": "```no_run\nlet mut a = 5;\nlet b = 0;\n// ...\n\na = a + b;\n```\n\nUse instead:\n```no_run\nlet mut a = 5;\nlet b = 0;\n// ...\n\na += b;\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "assigning the result of an operation on a variable to that same variable\n\nChecks for `a = a op b` or `a = b commutative_op a`\npatterns.\n\nThese can be written as the shorter `a op= b`."
    },
    {
      "id": "clippy::misrefactored_assign_op",
      "name": "MISREFACTORED_ASSIGN_OP",
      "snake_name": "misrefactored_assign_op",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "having a variable on both sides of an assign op",
      "what_it_does": "Checks for `a op= a op b` or `a op= b op a` patterns.",
      "why_bad": "Most likely these are bugs where one meant to write `a\nop= b`.",
      "example": "```no_run\nlet mut a = 5;\nlet b = 2;\n// ...\na += a + b;\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "having a variable on both sides of an assign op\n\nChecks for `a op= a op b` or `a op= b op a` patterns.\n\nMost likely these are bugs where one meant to write `a\nop= b`."
    },
    {
      "id": "clippy::bad_bit_mask",
      "name": "BAD_BIT_MASK",
      "snake_name": "bad_bit_mask",
      "category": "correctness",
      "weight": 1.2,
      "brief": "expressions of the form `_ & mask == select` that will only ever return `true` or `false`",
      "what_it_does": "Checks for incompatible bit masks in comparisons.\n\nThe formula for detecting if an expression of the type `_ <bit_op> m\n<cmp_op> c` (where `<bit_op>` is one of {`&`, `|`} and `<cmp_op>` is one of\n{`!=`, `>=`, `>`, `!=`, `>=`, `>`}) can be determined from the following\ntable:\n\n|Comparison  |Bit Op|Example      |is always|Formula               |\n|------------|------|-------------|---------|----------------------|\n|`==` or `!=`| `&`  |`x & 2 == 3` |`false`  |`c & m != c`          |\n|`<`  or `>=`| `&`  |`x & 2 < 3`  |`true`   |`m < c`               |\n|`>`  or `<=`| `&`  |`x & 1 > 1`  |`false`  |`m <= c`              |\n|`==` or `!=`| `\\|` |`x \\| 1 == 0`|`false`  |`c \\| m != c`         |\n|`<`  or `>=`| `\\|` |`x \\| 1 < 1` |`false`  |`m >= c`              |\n|`<=` or `>` | `\\|` |`x \\| 1 > 0` |`true`   |`m > c`               |",
      "why_bad": "If the bits that the comparison cares about are always\nset to zero or one by the bit mask, the comparison is constant `true` or\n`false` (depending on mask, compared value, and operators).\n\nSo the code is actively misleading, and the only reason someone would write\nthis intentionally is to win an underhanded Rust contest or create a\ntest-case for this lint.",
      "example": "```no_run\n# let x = 1;\nif (x & 1 == 2) { }\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "expressions of the form `_ & mask == select` that will only ever return `true` or `false`\n\nChecks for incompatible bit masks in comparisons.\n\nThe formula for detecting if an expression of the type `_ <bit_op> m\n<cmp_op> c` (where `<bit_op>` is one of {`&`, `|`} and `<cmp_op>` is one of\n{`!=`, `>=`, `>`, `!=`, `>=`, `>`}) can be determined from the following\ntable:\n\n|Comparison  |Bit Op|Example      |is always|Formula               |\n|------------|------|-------------|---------|----------------------|\n|`==` or `!=`| `&`  |`x & 2 == 3` |`false`  |`c & m != c`          |\n|`<`  or `>=`| `&`  |`x & 2 < 3`  |`true`   |`m < c`               |\n|`>`  or `<=`| `&`  |`x & 1 > 1`  |`false`  |`m <= c`              |\n|`==` or `!=`| `\\|` |`x \\| 1 == 0`|`false`  |`c \\| m != c`         |\n|`<`  or `>=`| `\\|` |`x \\| 1 < 1` |`false`  |`m >= c`              |\n|`<=` or `>` | `\\|` |`x \\| 1 > 0` |`true`   |`m > c`               |\n\nIf the bits that the comparison cares about are always\nset to zero or one by the bit mask, the comparison is constant `true` or\n`false` (depending on mask, compared value, and operators).\n\nSo the code is actively misleading, and the only reason someone would write\nthis intentionally is to win an underhanded Rust contest or create a\ntest-case for this lint."
    },
    {
      "id": "clippy::ineffective_bit_mask",
      "name": "INEFFECTIVE_BIT_MASK",
      "snake_name": "ineffective_bit_mask",
      "category": "correctness",
      "weight": 1.2,
      "brief": "expressions where a bit mask will be rendered useless by a comparison, e.g., `(x | 1) > 2`",
      "what_it_does": "Checks for bit masks in comparisons which can be removed\nwithout changing the outcome. The basic structure can be seen in the\nfollowing table:\n\n|Comparison| Bit Op   |Example     |equals |\n|----------|----------|------------|-------|\n|`>` / `<=`|`\\|` / `^`|`x \\| 2 > 3`|`x > 3`|\n|`<` / `>=`|`\\|` / `^`|`x ^ 1 < 4` |`x < 4`|",
      "why_bad": "Not equally evil as [`bad_bit_mask`](#bad_bit_mask),\nbut still a bit misleading, because the bit mask is ineffective.",
      "example": "```no_run\n# let x = 1;\nif (x | 1 > 3) {  }\n```\n\nUse instead:\n\n```no_run\n# let x = 1;\nif (x >= 2) {  }\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "expressions where a bit mask will be rendered useless by a comparison, e.g., `(x | 1) > 2`\n\nChecks for bit masks in comparisons which can be removed\nwithout changing the outcome. The basic structure can be seen in the\nfollowing table:\n\n|Comparison| Bit Op   |Example     |equals |\n|----------|----------|------------|-------|\n|`>` / `<=`|`\\|` / `^`|`x \\| 2 > 3`|`x > 3`|\n|`<` / `>=`|`\\|` / `^`|`x ^ 1 < 4` |`x < 4`|\n\nNot equally evil as [`bad_bit_mask`](#bad_bit_mask),\nbut still a bit misleading, because the bit mask is ineffective."
    },
    {
      "id": "clippy::verbose_bit_mask",
      "name": "VERBOSE_BIT_MASK",
      "snake_name": "verbose_bit_mask",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "expressions where a bit mask is less readable than the corresponding method call",
      "what_it_does": "Checks for bit masks that can be replaced by a call\nto `trailing_zeros`",
      "why_bad": "`x.trailing_zeros() >= 4` is much clearer than `x & 15\n== 0`",
      "example": "```no_run\n# let x = 1;\nif x & 0b1111 == 0 { }\n```\n\nUse instead:\n\n```no_run\n# let x: i32 = 1;\nif x.trailing_zeros() >= 4 { }\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "expressions where a bit mask is less readable than the corresponding method call\n\nChecks for bit masks that can be replaced by a call\nto `trailing_zeros`\n\n`x.trailing_zeros() >= 4` is much clearer than `x & 15\n== 0`"
    },
    {
      "id": "clippy::double_comparisons",
      "name": "DOUBLE_COMPARISONS",
      "snake_name": "double_comparisons",
      "category": "complexity",
      "weight": 1.0,
      "brief": "unnecessary double comparisons that can be simplified",
      "what_it_does": "Checks for double comparisons that could be simplified to a single expression.",
      "why_bad": "Readability.",
      "example": "```no_run\n# let x = 1;\n# let y = 2;\nif x == y || x < y {}\n```\n\nUse instead:\n\n```no_run\n# let x = 1;\n# let y = 2;\nif x <= y {}\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "unnecessary double comparisons that can be simplified\n\nChecks for double comparisons that could be simplified to a single expression.\n\nReadability."
    },
    {
      "id": "clippy::impossible_comparisons",
      "name": "IMPOSSIBLE_COMPARISONS",
      "snake_name": "impossible_comparisons",
      "category": "correctness",
      "weight": 1.2,
      "brief": "double comparisons that will never evaluate to `true`",
      "what_it_does": "Checks for double comparisons that can never succeed",
      "why_bad": "The whole expression can be replaced by `false`,\nwhich is probably not the programmer's intention",
      "example": "```no_run\n# let status_code = 200;\nif status_code <= 400 && status_code > 500 {}\n```",
      "version": "1.73.0",
      "source_file": "mod.rs",
      "embedding_text": "double comparisons that will never evaluate to `true`\n\nChecks for double comparisons that can never succeed\n\nThe whole expression can be replaced by `false`,\nwhich is probably not the programmer's intention"
    },
    {
      "id": "clippy::redundant_comparisons",
      "name": "REDUNDANT_COMPARISONS",
      "snake_name": "redundant_comparisons",
      "category": "correctness",
      "weight": 1.2,
      "brief": "double comparisons where one of them can be removed",
      "what_it_does": "Checks for ineffective double comparisons against constants.",
      "why_bad": "Only one of the comparisons has any effect on the result, the programmer\nprobably intended to flip one of the comparison operators, or compare a\ndifferent value entirely.",
      "example": "```no_run\n# let status_code = 200;\nif status_code <= 400 && status_code < 500 {}\n```",
      "version": "1.73.0",
      "source_file": "mod.rs",
      "embedding_text": "double comparisons where one of them can be removed\n\nChecks for ineffective double comparisons against constants.\n\nOnly one of the comparisons has any effect on the result, the programmer\nprobably intended to flip one of the comparison operators, or compare a\ndifferent value entirely."
    },
    {
      "id": "clippy::duration_subsec",
      "name": "DURATION_SUBSEC",
      "snake_name": "duration_subsec",
      "category": "complexity",
      "weight": 1.0,
      "brief": "checks for calculation of subsecond microseconds or milliseconds",
      "what_it_does": "Checks for calculation of subsecond microseconds or milliseconds\nfrom other `Duration` methods.",
      "why_bad": "It's more concise to call `Duration::subsec_micros()` or\n`Duration::subsec_millis()` than to calculate them.",
      "example": "```no_run\n# use std::time::Duration;\n# let duration = Duration::new(5, 0);\nlet micros = duration.subsec_nanos() / 1_000;\nlet millis = duration.subsec_nanos() / 1_000_000;\n```\n\nUse instead:\n```no_run\n# use std::time::Duration;\n# let duration = Duration::new(5, 0);\nlet micros = duration.subsec_micros();\nlet millis = duration.subsec_millis();\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "checks for calculation of subsecond microseconds or milliseconds\n\nChecks for calculation of subsecond microseconds or milliseconds\nfrom other `Duration` methods.\n\nIt's more concise to call `Duration::subsec_micros()` or\n`Duration::subsec_millis()` than to calculate them."
    },
    {
      "id": "clippy::eq_op",
      "name": "EQ_OP",
      "snake_name": "eq_op",
      "category": "correctness",
      "weight": 1.2,
      "brief": "equal operands on both sides of a comparison or bitwise combination (e.g., `x == x`)",
      "what_it_does": "Checks for equal operands to comparison, logical and\nbitwise, difference and division binary operators (`==`, `>`, etc., `&&`,\n`||`, `&`, `|`, `^`, `-` and `/`).",
      "why_bad": "This is usually just a typo or a copy and paste error.",
      "example": "```no_run\n# let x = 1;\nif x + 1 == x + 1 {}\n\n// or\n\n# let a = 3;\n# let b = 4;\nassert_eq!(a, a);\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "equal operands on both sides of a comparison or bitwise combination (e.g., `x == x`)\n\nChecks for equal operands to comparison, logical and\nbitwise, difference and division binary operators (`==`, `>`, etc., `&&`,\n`||`, `&`, `|`, `^`, `-` and `/`).\n\nThis is usually just a typo or a copy and paste error."
    },
    {
      "id": "clippy::op_ref",
      "name": "OP_REF",
      "snake_name": "op_ref",
      "category": "style",
      "weight": 0.95,
      "brief": "taking a reference to satisfy the type constraints on `==`",
      "what_it_does": "Checks for arguments to `==` which have their address\ntaken to satisfy a bound\nand suggests to dereference the other argument instead",
      "why_bad": "It is more idiomatic to dereference the other argument.",
      "example": "```rust,ignore\n&x == y\n```\n\nUse instead:\n```rust,ignore\nx == *y\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "taking a reference to satisfy the type constraints on `==`\n\nChecks for arguments to `==` which have their address\ntaken to satisfy a bound\nand suggests to dereference the other argument instead\n\nIt is more idiomatic to dereference the other argument."
    },
    {
      "id": "clippy::erasing_op",
      "name": "ERASING_OP",
      "snake_name": "erasing_op",
      "category": "correctness",
      "weight": 1.2,
      "brief": "using erasing operations, e.g., `x * 0` or `y & 0`",
      "what_it_does": "Checks for erasing operations, e.g., `x * 0`.",
      "why_bad": "The whole expression can be replaced by zero.\nThis is most likely not the intended outcome and should probably be\ncorrected",
      "example": "```no_run\nlet x = 1;\n0 / x;\n0 * x;\nx & 0;\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "using erasing operations, e.g., `x * 0` or `y & 0`\n\nChecks for erasing operations, e.g., `x * 0`.\n\nThe whole expression can be replaced by zero.\nThis is most likely not the intended outcome and should probably be\ncorrected"
    },
    {
      "id": "clippy::float_equality_without_abs",
      "name": "FLOAT_EQUALITY_WITHOUT_ABS",
      "snake_name": "float_equality_without_abs",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "float equality check without `.abs()`",
      "what_it_does": "Checks for statements of the form `(a - b) < f32::EPSILON` or\n`(a - b) < f64::EPSILON`. Note the missing `.abs()`.",
      "why_bad": "The code without `.abs()` is more likely to have a bug.",
      "example": "```no_run\npub fn is_roughly_equal(a: f32, b: f32) -> bool {\n(a - b) < f32::EPSILON\n}\n```\nUse instead:\n```no_run\npub fn is_roughly_equal(a: f32, b: f32) -> bool {\n(a - b).abs() < f32::EPSILON\n}\n```",
      "version": "1.48.0",
      "source_file": "mod.rs",
      "embedding_text": "float equality check without `.abs()`\n\nChecks for statements of the form `(a - b) < f32::EPSILON` or\n`(a - b) < f64::EPSILON`. Note the missing `.abs()`.\n\nThe code without `.abs()` is more likely to have a bug."
    },
    {
      "id": "clippy::identity_op",
      "name": "IDENTITY_OP",
      "snake_name": "identity_op",
      "category": "complexity",
      "weight": 1.0,
      "brief": "using identity operations, e.g., `x + 0` or `y / 1`",
      "what_it_does": "Checks for identity operations, e.g., `x + 0`.",
      "why_bad": "This code can be removed without changing the\nmeaning. So it just obscures what's going on. Delete it mercilessly.",
      "example": "```no_run\n# let x = 1;\nx / 1 + 0 * 1 - 0 | 0;\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "using identity operations, e.g., `x + 0` or `y / 1`\n\nChecks for identity operations, e.g., `x + 0`.\n\nThis code can be removed without changing the\nmeaning. So it just obscures what's going on. Delete it mercilessly."
    },
    {
      "id": "clippy::integer_division",
      "name": "INTEGER_DIVISION",
      "snake_name": "integer_division",
      "category": "restriction",
      "weight": 1.0,
      "brief": "integer division may cause loss of precision",
      "what_it_does": "Checks for division of integers",
      "why_bad": "When outside of some very specific algorithms,\ninteger division is very often a mistake because it discards the\nremainder.",
      "example": "```no_run\nlet x = 3 / 2;\nprintln!(\"{}\", x);\n```\n\nUse instead:\n```no_run\nlet x = 3f32 / 2f32;\nprintln!(\"{}\", x);\n```",
      "version": "1.37.0",
      "source_file": "mod.rs",
      "embedding_text": "integer division may cause loss of precision\n\nChecks for division of integers\n\nWhen outside of some very specific algorithms,\ninteger division is very often a mistake because it discards the\nremainder."
    },
    {
      "id": "clippy::cmp_owned",
      "name": "CMP_OWNED",
      "snake_name": "cmp_owned",
      "category": "perf",
      "weight": 1.0,
      "brief": "creating owned instances for comparing with others, e.g., `x == \\",
      "what_it_does": "Checks for conversions to owned values just for the sake\nof a comparison.",
      "why_bad": "The comparison can operate on a reference, so creating\nan owned value effectively throws it away directly afterwards, which is\nneedlessly consuming code and heap space.",
      "example": "```no_run\n# let x = \"foo\";\n# let y = String::from(\"foo\");\nif x.to_owned() == y {}\n```\n\nUse instead:\n```no_run\n# let x = \"foo\";\n# let y = String::from(\"foo\");\nif x == y {}\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "creating owned instances for comparing with others, e.g., `x == \\\n\nChecks for conversions to owned values just for the sake\nof a comparison.\n\nThe comparison can operate on a reference, so creating\nan owned value effectively throws it away directly afterwards, which is\nneedlessly consuming code and heap space."
    },
    {
      "id": "clippy::float_cmp",
      "name": "FLOAT_CMP",
      "snake_name": "float_cmp",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "using `==` or `!=` on float values instead of comparing difference with an allowed error",
      "what_it_does": "Checks for (in-)equality comparisons on floating-point\nvalues (apart from zero), except in functions called `*eq*` (which probably\nimplement equality for a type involving floats).",
      "why_bad": "Floating point calculations are usually imprecise, so asking if two values are *exactly*\nequal is asking for trouble because arriving at the same logical result via different\nroutes (e.g. calculation versus constant) may yield different values.",
      "example": "```no_run\nlet a: f64 = 1000.1;\nlet b: f64 = 0.2;\nlet x = a + b;\nlet y = 1000.3; // Expected value.\n\n// Actual value: 1000.3000000000001\nprintln!(\"{x}\");\n\nlet are_equal = x == y;\nprintln!(\"{are_equal}\"); // false\n```\n\nThe correct way to compare floating point numbers is to define an allowed error margin. This\nmay be challenging if there is no \"natural\" error margin to permit. Broadly speaking, there\nare two cases:\n\n1. If your values are in a known range and you can define a threshold for \"close enough to\nbe equal\", it may be appropriate to define an absolute error margin. For example, if your\ndata is \"length of vehicle in centimeters\", you may consider 0.1 cm to be \"close enough\".\n1. If your code is more general and you do not know the range of values, you should use a\nrelative error margin, accepting e.g. 0.1% of error regardless of specific values.\n\nFor the scenario where you can define a meaningful absolute error margin, consider using:\n\n```no_run\nlet a: f64 = 1000.1;\nlet b: f64 = 0.2;\nlet x = a + b;\nlet y = 1000.3; // Expected value.\n\nconst ALLOWED_ERROR_VEHICLE_LENGTH_CM: f64 = 0.1;\nlet within_tolerance = (x - y).abs() < ALLOWED_ERROR_VEHICLE_LENGTH_CM;\nprintln!(\"{within_tolerance}\"); // true\n```\n\nNOTE: Do not use `f64::EPSILON` - while the error margin is often called \"epsilon\", this is\na different use of the term that is not suitable for floating point equality comparison.\nIndeed, for the example above using `f64::EPSILON` as the allowed error would return `false`.\n\nFor the scenario where no meaningful absolute error can be defined, refer to\n[the floating point guide](https://www.floating-point-gui.de/errors/comparison)\nfor a reference implementation of relative error based comparison of floating point values.\n`MIN_NORMAL` in the reference implementation is equivalent to `MIN_POSITIVE` in Rust.",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "using `==` or `!=` on float values instead of comparing difference with an allowed error\n\nChecks for (in-)equality comparisons on floating-point\nvalues (apart from zero), except in functions called `*eq*` (which probably\nimplement equality for a type involving floats).\n\nFloating point calculations are usually imprecise, so asking if two values are *exactly*\nequal is asking for trouble because arriving at the same logical result via different\nroutes (e.g. calculation versus constant) may yield different values."
    },
    {
      "id": "clippy::float_cmp_const",
      "name": "FLOAT_CMP_CONST",
      "snake_name": "float_cmp_const",
      "category": "restriction",
      "weight": 1.0,
      "brief": "using `==` or `!=` on float constants instead of comparing difference with an allowed error",
      "what_it_does": "Checks for (in-)equality comparisons on constant floating-point\nvalues (apart from zero), except in functions called `*eq*` (which probably\nimplement equality for a type involving floats).",
      "why_bad": "Floating point calculations are usually imprecise, so asking if two values are *exactly*\nequal is asking for trouble because arriving at the same logical result via different\nroutes (e.g. calculation versus constant) may yield different values.",
      "example": "```no_run\nlet a: f64 = 1000.1;\nlet b: f64 = 0.2;\nlet x = a + b;\nconst Y: f64 = 1000.3; // Expected value.\n\n// Actual value: 1000.3000000000001\nprintln!(\"{x}\");\n\nlet are_equal = x == Y;\nprintln!(\"{are_equal}\"); // false\n```\n\nThe correct way to compare floating point numbers is to define an allowed error margin. This\nmay be challenging if there is no \"natural\" error margin to permit. Broadly speaking, there\nare two cases:\n\n1. If your values are in a known range and you can define a threshold for \"close enough to\nbe equal\", it may be appropriate to define an absolute error margin. For example, if your\ndata is \"length of vehicle in centimeters\", you may consider 0.1 cm to be \"close enough\".\n1. If your code is more general and you do not know the range of values, you should use a\nrelative error margin, accepting e.g. 0.1% of error regardless of specific values.\n\nFor the scenario where you can define a meaningful absolute error margin, consider using:\n\n```no_run\nlet a: f64 = 1000.1;\nlet b: f64 = 0.2;\nlet x = a + b;\nconst Y: f64 = 1000.3; // Expected value.\n\nconst ALLOWED_ERROR_VEHICLE_LENGTH_CM: f64 = 0.1;\nlet within_tolerance = (x - Y).abs() < ALLOWED_ERROR_VEHICLE_LENGTH_CM;\nprintln!(\"{within_tolerance}\"); // true\n```\n\nNOTE: Do not use `f64::EPSILON` - while the error margin is often called \"epsilon\", this is\na different use of the term that is not suitable for floating point equality comparison.\nIndeed, for the example above using `f64::EPSILON` as the allowed error would return `false`.\n\nFor the scenario where no meaningful absolute error can be defined, refer to\n[the floating point guide](https://www.floating-point-gui.de/errors/comparison)\nfor a reference implementation of relative error based comparison of floating point values.\n`MIN_NORMAL` in the reference implementation is equivalent to `MIN_POSITIVE` in Rust.",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "using `==` or `!=` on float constants instead of comparing difference with an allowed error\n\nChecks for (in-)equality comparisons on constant floating-point\nvalues (apart from zero), except in functions called `*eq*` (which probably\nimplement equality for a type involving floats).\n\nFloating point calculations are usually imprecise, so asking if two values are *exactly*\nequal is asking for trouble because arriving at the same logical result via different\nroutes (e.g. calculation versus constant) may yield different values."
    },
    {
      "id": "clippy::modulo_one",
      "name": "MODULO_ONE",
      "snake_name": "modulo_one",
      "category": "correctness",
      "weight": 1.2,
      "brief": "taking an integer modulo +/-1, which can either panic/overflow or always returns 0",
      "what_it_does": "Checks for getting the remainder of integer division by one or minus\none.",
      "why_bad": "The result for a divisor of one can only ever be zero; for\nminus one it can cause panic/overflow (if the left operand is the minimal value of\nthe respective integer type) or results in zero. No one will write such code\ndeliberately, unless trying to win an Underhanded Rust Contest. Even for that\ncontest, it's probably a bad idea. Use something more underhanded.",
      "example": "```no_run\n# let x = 1;\nlet a = x % 1;\nlet a = x % -1;\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "taking an integer modulo +/-1, which can either panic/overflow or always returns 0\n\nChecks for getting the remainder of integer division by one or minus\none.\n\nThe result for a divisor of one can only ever be zero; for\nminus one it can cause panic/overflow (if the left operand is the minimal value of\nthe respective integer type) or results in zero. No one will write such code\ndeliberately, unless trying to win an Underhanded Rust Contest. Even for that\ncontest, it's probably a bad idea. Use something more underhanded."
    },
    {
      "id": "clippy::modulo_arithmetic",
      "name": "MODULO_ARITHMETIC",
      "snake_name": "modulo_arithmetic",
      "category": "restriction",
      "weight": 1.0,
      "brief": "any modulo arithmetic statement",
      "what_it_does": "Checks for modulo arithmetic.",
      "why_bad": "The results of modulo (`%`) operation might differ\ndepending on the language, when negative numbers are involved.\nIf you interop with different languages it might be beneficial\nto double check all places that use modulo arithmetic.\n\nFor example, in Rust `17 % -3 = 2`, but in Python `17 % -3 = -1`.",
      "example": "```no_run\nlet x = -17 % 3;\n```",
      "version": "1.42.0",
      "source_file": "mod.rs",
      "embedding_text": "any modulo arithmetic statement\n\nChecks for modulo arithmetic.\n\nThe results of modulo (`%`) operation might differ\ndepending on the language, when negative numbers are involved.\nIf you interop with different languages it might be beneficial\nto double check all places that use modulo arithmetic.\n\nFor example, in Rust `17 % -3 = 2`, but in Python `17 % -3 = -1`."
    },
    {
      "id": "clippy::needless_bitwise_bool",
      "name": "NEEDLESS_BITWISE_BOOL",
      "snake_name": "needless_bitwise_bool",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "Boolean expressions that use bitwise rather than lazy operators",
      "what_it_does": "Checks for usage of bitwise and/or operators between booleans, where performance may be improved by using\na lazy and.",
      "why_bad": "The bitwise operators do not support short-circuiting, so it may hinder code performance.\nAdditionally, boolean logic \"masked\" as bitwise logic is not caught by lints like `unnecessary_fold`",
      "example": "```no_run\nlet (x,y) = (true, false);\nif x & !y {} // where both x and y are booleans\n```\nUse instead:\n```no_run\nlet (x,y) = (true, false);\nif x && !y {}\n```",
      "version": "1.54.0",
      "source_file": "mod.rs",
      "embedding_text": "Boolean expressions that use bitwise rather than lazy operators\n\nChecks for usage of bitwise and/or operators between booleans, where performance may be improved by using\na lazy and.\n\nThe bitwise operators do not support short-circuiting, so it may hinder code performance.\nAdditionally, boolean logic \"masked\" as bitwise logic is not caught by lints like `unnecessary_fold`"
    },
    {
      "id": "clippy::self_assignment",
      "name": "SELF_ASSIGNMENT",
      "snake_name": "self_assignment",
      "category": "correctness",
      "weight": 1.2,
      "brief": "explicit self-assignment",
      "what_it_does": "Checks for explicit self-assignments.",
      "why_bad": "Self-assignments are redundant and unlikely to be\nintentional.",
      "example": "```no_run\nstruct Event {\nx: i32,\n}\n\nfn copy_position(a: &mut Event, b: &Event) {\na.x = a.x;\n}\n```\n\nShould be:\n```no_run\nstruct Event {\nx: i32,\n}\n\nfn copy_position(a: &mut Event, b: &Event) {\na.x = b.x;\n}\n```",
      "version": "1.48.0",
      "source_file": "mod.rs",
      "embedding_text": "explicit self-assignment\n\nChecks for explicit self-assignments.\n\nSelf-assignments are redundant and unlikely to be\nintentional."
    },
    {
      "id": "clippy::manual_midpoint",
      "name": "MANUAL_MIDPOINT",
      "snake_name": "manual_midpoint",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "manual implementation of `midpoint` which can overflow",
      "what_it_does": "Checks for manual implementation of `midpoint`.",
      "why_bad": "Using `(x + y) / 2` might cause an overflow on the intermediate\naddition result.",
      "example": "```no_run\n# let a: u32 = 0;\nlet c = (a + 10) / 2;\n```\nUse instead:\n```no_run\n# let a: u32 = 0;\nlet c = u32::midpoint(a, 10);\n```",
      "version": "1.87.0",
      "source_file": "mod.rs",
      "embedding_text": "manual implementation of `midpoint` which can overflow\n\nChecks for manual implementation of `midpoint`.\n\nUsing `(x + y) / 2` might cause an overflow on the intermediate\naddition result."
    },
    {
      "id": "clippy::manual_is_multiple_of",
      "name": "MANUAL_IS_MULTIPLE_OF",
      "snake_name": "manual_is_multiple_of",
      "category": "complexity",
      "weight": 1.0,
      "brief": "manual implementation of `.is_multiple_of()`",
      "what_it_does": "Checks for manual implementation of `.is_multiple_of()` on\nunsigned integer types.",
      "why_bad": "`a.is_multiple_of(b)` is a clearer way to check for divisibility\nof `a` by `b`. This expression can never panic.",
      "example": "```no_run\n# let (a, b) = (3u64, 4u64);\nif a % b == 0 {\nprintln!(\"{a} is divisible by {b}\");\n}\n```\nUse instead:\n```no_run\n# let (a, b) = (3u64, 4u64);\nif a.is_multiple_of(b) {\nprintln!(\"{a} is divisible by {b}\");\n}\n```",
      "version": "1.90.0",
      "source_file": "mod.rs",
      "embedding_text": "manual implementation of `.is_multiple_of()`\n\nChecks for manual implementation of `.is_multiple_of()` on\nunsigned integer types.\n\n`a.is_multiple_of(b)` is a clearer way to check for divisibility\nof `a` by `b`. This expression can never panic."
    },
    {
      "id": "clippy::manual_div_ceil",
      "name": "MANUAL_DIV_CEIL",
      "snake_name": "manual_div_ceil",
      "category": "complexity",
      "weight": 1.0,
      "brief": "manually reimplementing `div_ceil`",
      "what_it_does": "Checks for an expression like `(x + (y - 1)) / y` which is a common manual reimplementation\nof `x.div_ceil(y)`.",
      "why_bad": "It's simpler, clearer and more readable.",
      "example": "```no_run\nlet x: i32 = 7;\nlet y: i32 = 4;\nlet div = (x + (y - 1)) / y;\n```\nUse instead:\n```no_run\n#![feature(int_roundings)]\nlet x: i32 = 7;\nlet y: i32 = 4;\nlet div = x.div_ceil(y);\n```",
      "version": "1.83.0",
      "source_file": "mod.rs",
      "embedding_text": "manually reimplementing `div_ceil`\n\nChecks for an expression like `(x + (y - 1)) / y` which is a common manual reimplementation\nof `x.div_ceil(y)`.\n\nIt's simpler, clearer and more readable."
    },
    {
      "id": "clippy::invalid_upcast_comparisons",
      "name": "INVALID_UPCAST_COMPARISONS",
      "snake_name": "invalid_upcast_comparisons",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "a comparison involving an upcast which is always true or false",
      "what_it_does": "Checks for comparisons where the relation is always either\ntrue or false, but where one side has been upcast so that the comparison is\nnecessary. Only integer types are checked.",
      "why_bad": "An expression like `let x : u8 = ...; (x as u32) > 300`\nwill mistakenly imply that it is possible for `x` to be outside the range of\n`u8`.",
      "example": "```no_run\nlet x: u8 = 1;\n(x as u32) > 300;\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "a comparison involving an upcast which is always true or false\n\nChecks for comparisons where the relation is always either\ntrue or false, but where one side has been upcast so that the comparison is\nnecessary. Only integer types are checked.\n\nAn expression like `let x : u8 = ...; (x as u32) > 300`\nwill mistakenly imply that it is possible for `x` to be outside the range of\n`u8`."
    },
    {
      "id": "clippy::integer_division_remainder_used",
      "name": "INTEGER_DIVISION_REMAINDER_USED",
      "snake_name": "integer_division_remainder_used",
      "category": "restriction",
      "weight": 1.0,
      "brief": "use of disallowed default division and remainder operations",
      "what_it_does": "Checks for the usage of division (`/`) and remainder (`%`) operations\nwhen performed on any integer types using the default `Div` and `Rem` trait implementations.",
      "why_bad": "In cryptographic contexts, division can result in timing sidechannel vulnerabilities,\nand needs to be replaced with constant-time code instead (e.g. Barrett reduction).",
      "example": "```no_run\nlet my_div = 10 / 2;\n```\nUse instead:\n```no_run\nlet my_div = 10 >> 1;\n```",
      "version": "1.79.0",
      "source_file": "mod.rs",
      "embedding_text": "use of disallowed default division and remainder operations\n\nChecks for the usage of division (`/`) and remainder (`%`) operations\nwhen performed on any integer types using the default `Div` and `Rem` trait implementations.\n\nIn cryptographic contexts, division can result in timing sidechannel vulnerabilities,\nand needs to be replaced with constant-time code instead (e.g. Barrett reduction)."
    },
    {
      "id": "clippy::decimal_bitwise_operands",
      "name": "DECIMAL_BITWISE_OPERANDS",
      "snake_name": "decimal_bitwise_operands",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "use binary, hex, or octal literals for bitwise operations",
      "what_it_does": "Checks for decimal literals used as bit masks in bitwise operations.",
      "why_bad": "Using decimal literals for bit masks can make the code less readable and obscure the intended bit pattern.\nBinary, hexadecimal, or octal literals make the bit pattern more explicit and easier to understand at a glance.",
      "example": "```rust,no_run\nlet a = 14 & 6; // Bit pattern is not immediately clear\n```\nUse instead:\n```rust,no_run\nlet a = 0b1110 & 0b0110;\n```",
      "version": "1.93.0",
      "source_file": "mod.rs",
      "embedding_text": "use binary, hex, or octal literals for bitwise operations\n\nChecks for decimal literals used as bit masks in bitwise operations.\n\nUsing decimal literals for bit masks can make the code less readable and obscure the intended bit pattern.\nBinary, hexadecimal, or octal literals make the bit pattern more explicit and easier to understand at a glance."
    },
    {
      "id": "clippy::option_env_unwrap",
      "name": "OPTION_ENV_UNWRAP",
      "snake_name": "option_env_unwrap",
      "category": "correctness",
      "weight": 1.2,
      "brief": "using `option_env!(...).unwrap()` to get environment variable",
      "what_it_does": "Checks for usage of `option_env!(...).unwrap()` and\nsuggests usage of the `env!` macro.",
      "why_bad": "Unwrapping the result of `option_env!` will panic\nat run-time if the environment variable doesn't exist, whereas `env!`\ncatches it at compile-time.",
      "example": "```rust,no_run\nlet _ = option_env!(\"HOME\").unwrap();\n```\n\nIs better expressed as:\n\n```rust,no_run\nlet _ = env!(\"HOME\");\n```",
      "version": "1.43.0",
      "source_file": "option_env_unwrap.rs",
      "embedding_text": "using `option_env!(...).unwrap()` to get environment variable\n\nChecks for usage of `option_env!(...).unwrap()` and\nsuggests usage of the `env!` macro.\n\nUnwrapping the result of `option_env!` will panic\nat run-time if the environment variable doesn't exist, whereas `env!`\ncatches it at compile-time."
    },
    {
      "id": "clippy::option_if_let_else",
      "name": "OPTION_IF_LET_ELSE",
      "snake_name": "option_if_let_else",
      "category": "nursery",
      "weight": 0.9,
      "brief": "reimplementation of Option::map_or",
      "what_it_does": "Lints usage of `if let Some(v) = ... { y } else { x }` and\n`match .. { Some(v) => y, None/_ => x }` which are more\nidiomatically done with `Option::map_or` (if the else bit is a pure\nexpression) or `Option::map_or_else` (if the else bit is an impure\nexpression).",
      "why_bad": "Using the dedicated functions of the `Option` type is clearer and\nmore concise than an `if let` expression.",
      "example": "```no_run\n# let optional: Option<u32> = Some(0);\n# fn do_complicated_function() -> u32 { 5 };\nlet _ = if let Some(foo) = optional {\nfoo\n} else {\n5\n};\nlet _ = match optional {\nSome(val) => val + 1,\nNone => 5\n};\nlet _ = if let Some(foo) = optional {\nfoo\n} else {\nlet y = do_complicated_function();\ny*y\n};\n```\n\nshould be\n\n```no_run\n# let optional: Option<u32> = Some(0);\n# fn do_complicated_function() -> u32 { 5 };\nlet _ = optional.map_or(5, |foo| foo);\nlet _ = optional.map_or(5, |val| val + 1);\nlet _ = optional.map_or_else(||{\nlet y = do_complicated_function();\ny*y\n}, |foo| foo);\n```",
      "version": "1.47.0",
      "source_file": "option_if_let_else.rs",
      "embedding_text": "reimplementation of Option::map_or\n\nLints usage of `if let Some(v) = ... { y } else { x }` and\n`match .. { Some(v) => y, None/_ => x }` which are more\nidiomatically done with `Option::map_or` (if the else bit is a pure\nexpression) or `Option::map_or_else` (if the else bit is an impure\nexpression).\n\nUsing the dedicated functions of the `Option` type is clearer and\nmore concise than an `if let` expression."
    },
    {
      "id": "clippy::panic_in_result_fn",
      "name": "PANIC_IN_RESULT_FN",
      "snake_name": "panic_in_result_fn",
      "category": "restriction",
      "weight": 1.0,
      "brief": "functions of type `Result<..>` that contain `panic!()` or assertion",
      "what_it_does": "Checks for usage of `panic!` or assertions in a function whose return type is `Result`.",
      "why_bad": "For some codebases, it is desirable for functions of type result to return an error instead of crashing. Hence panicking macros should be avoided.",
      "example": "```no_run\nfn result_with_panic() -> Result<bool, String>\n{\npanic!(\"error\");\n}\n```\nUse instead:\n```no_run\nfn result_without_panic() -> Result<bool, String> {\nErr(String::from(\"error\"))\n}\n```",
      "version": "1.48.0",
      "source_file": "panic_in_result_fn.rs",
      "embedding_text": "functions of type `Result<..>` that contain `panic!()` or assertion\n\nChecks for usage of `panic!` or assertions in a function whose return type is `Result`.\n\nFor some codebases, it is desirable for functions of type result to return an error instead of crashing. Hence panicking macros should be avoided."
    },
    {
      "id": "clippy::panic",
      "name": "PANIC",
      "snake_name": "panic",
      "category": "restriction",
      "weight": 1.0,
      "brief": "usage of the `panic!` macro",
      "what_it_does": "Checks for usage of `panic!`.",
      "why_bad": "This macro, or panics in general, may be unwanted in production code.",
      "example": "```no_run\npanic!(\"even with a good reason\");\n```",
      "version": "1.40.0",
      "source_file": "panic_unimplemented.rs",
      "embedding_text": "usage of the `panic!` macro\n\nChecks for usage of `panic!`.\n\nThis macro, or panics in general, may be unwanted in production code."
    },
    {
      "id": "clippy::unimplemented",
      "name": "UNIMPLEMENTED",
      "snake_name": "unimplemented",
      "category": "restriction",
      "weight": 1.0,
      "brief": "`unimplemented!` should not be present in production code",
      "what_it_does": "Checks for usage of `unimplemented!`.",
      "why_bad": "This macro, or panics in general, may be unwanted in production code.",
      "example": "```no_run\nunimplemented!();\n```",
      "version": "pre 1.29.0",
      "source_file": "panic_unimplemented.rs",
      "embedding_text": "`unimplemented!` should not be present in production code\n\nChecks for usage of `unimplemented!`.\n\nThis macro, or panics in general, may be unwanted in production code."
    },
    {
      "id": "clippy::todo",
      "name": "TODO",
      "snake_name": "todo",
      "category": "restriction",
      "weight": 1.0,
      "brief": "`todo!` should not be present in production code",
      "what_it_does": "Checks for usage of `todo!`.",
      "why_bad": "The `todo!` macro indicates the presence of unfinished code,\nso it should not be present in production code.",
      "example": "```no_run\ntodo!();\n```\nFinish the implementation, or consider marking it as explicitly unimplemented.\n```no_run\nunimplemented!();\n```",
      "version": "1.40.0",
      "source_file": "panic_unimplemented.rs",
      "embedding_text": "`todo!` should not be present in production code\n\nChecks for usage of `todo!`.\n\nThe `todo!` macro indicates the presence of unfinished code,\nso it should not be present in production code."
    },
    {
      "id": "clippy::unreachable",
      "name": "UNREACHABLE",
      "snake_name": "unreachable",
      "category": "restriction",
      "weight": 1.0,
      "brief": "usage of the `unreachable!` macro",
      "what_it_does": "Checks for usage of `unreachable!`.",
      "why_bad": "This macro, or panics in general, may be unwanted in production code.",
      "example": "```no_run\nunreachable!();\n```",
      "version": "1.40.0",
      "source_file": "panic_unimplemented.rs",
      "embedding_text": "usage of the `unreachable!` macro\n\nChecks for usage of `unreachable!`.\n\nThis macro, or panics in general, may be unwanted in production code."
    },
    {
      "id": "clippy::panicking_overflow_checks",
      "name": "PANICKING_OVERFLOW_CHECKS",
      "snake_name": "panicking_overflow_checks",
      "category": "correctness",
      "weight": 1.2,
      "brief": "overflow checks which will panic in debug mode",
      "what_it_does": "Detects C-style underflow/overflow checks.",
      "why_bad": "These checks will, by default, panic in debug builds rather than check\nwhether the operation caused an overflow.",
      "example": "```no_run\n# let a = 1i32;\n# let b = 2i32;\nif a + b < a {\n// handle overflow\n}\n```\n\nUse instead:\n```no_run\n# let a = 1i32;\n# let b = 2i32;\nif a.checked_add(b).is_none() {\n// handle overflow\n}\n```\n\nOr:\n```no_run\n# let a = 1i32;\n# let b = 2i32;\nif a.overflowing_add(b).1 {\n// handle overflow\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "panicking_overflow_checks.rs",
      "embedding_text": "overflow checks which will panic in debug mode\n\nDetects C-style underflow/overflow checks.\n\nThese checks will, by default, panic in debug builds rather than check\nwhether the operation caused an overflow."
    },
    {
      "id": "clippy::partial_pub_fields",
      "name": "PARTIAL_PUB_FIELDS",
      "snake_name": "partial_pub_fields",
      "category": "restriction",
      "weight": 1.0,
      "brief": "partial fields of a struct are public",
      "what_it_does": "Checks whether some but not all fields of a `struct` are public.\n\nEither make all fields of a type public, or make none of them public",
      "why_bad": "Most types should either be:\n* Abstract data types: complex objects with opaque implementation which guard\ninterior invariants and expose intentionally limited API to the outside world.\n* Data:\u2009relatively simple objects which group a bunch of related attributes together,\nbut have no invariants.",
      "example": "```no_run\npub struct Color {\npub r: u8,\npub g: u8,\nb: u8,\n}\n```\nUse instead:\n```no_run\npub struct Color {\npub r: u8,\npub g: u8,\npub b: u8,\n}\n```",
      "version": "1.66.0",
      "source_file": "partial_pub_fields.rs",
      "embedding_text": "partial fields of a struct are public\n\nChecks whether some but not all fields of a `struct` are public.\n\nEither make all fields of a type public, or make none of them public\n\nMost types should either be:\n* Abstract data types: complex objects with opaque implementation which guard\ninterior invariants and expose intentionally limited API to the outside world.\n* Data:\u2009relatively simple objects which group a bunch of related attributes together,\nbut have no invariants."
    },
    {
      "id": "clippy::partialeq_ne_impl",
      "name": "PARTIALEQ_NE_IMPL",
      "snake_name": "partialeq_ne_impl",
      "category": "complexity",
      "weight": 1.0,
      "brief": "re-implementing `PartialEq::ne`",
      "what_it_does": "Checks for manual re-implementations of `PartialEq::ne`.",
      "why_bad": "`PartialEq::ne` is required to always return the\nnegated result of `PartialEq::eq`, which is exactly what the default\nimplementation does. Therefore, there should never be any need to\nre-implement it.",
      "example": "```no_run\nstruct Foo;\n\nimpl PartialEq for Foo {\nfn eq(&self, other: &Foo) -> bool { true }\nfn ne(&self, other: &Foo) -> bool { !(self == other) }\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "partialeq_ne_impl.rs",
      "embedding_text": "re-implementing `PartialEq::ne`\n\nChecks for manual re-implementations of `PartialEq::ne`.\n\n`PartialEq::ne` is required to always return the\nnegated result of `PartialEq::eq`, which is exactly what the default\nimplementation does. Therefore, there should never be any need to\nre-implement it."
    },
    {
      "id": "clippy::partialeq_to_none",
      "name": "PARTIALEQ_TO_NONE",
      "snake_name": "partialeq_to_none",
      "category": "style",
      "weight": 0.95,
      "brief": "Binary comparison to `Option<T>::None` relies on `T: PartialEq`, which is unneeded",
      "what_it_does": "Checks for binary comparisons to a literal `Option::None`.",
      "why_bad": "A programmer checking if some `foo` is `None` via a comparison `foo == None`\nis usually inspired from other programming languages (e.g. `foo is None`\nin Python).\nChecking if a value of type `Option<T>` is (not) equal to `None` in that\nway relies on `T: PartialEq` to do the comparison, which is unneeded.",
      "example": "```no_run\nfn foo(f: Option<u32>) -> &'static str {\nif f != None { \"yay\" } else { \"nay\" }\n}\n```\nUse instead:\n```no_run\nfn foo(f: Option<u32>) -> &'static str {\nif f.is_some() { \"yay\" } else { \"nay\" }\n}\n```",
      "version": "1.65.0",
      "source_file": "partialeq_to_none.rs",
      "embedding_text": "Binary comparison to `Option<T>::None` relies on `T: PartialEq`, which is unneeded\n\nChecks for binary comparisons to a literal `Option::None`.\n\nA programmer checking if some `foo` is `None` via a comparison `foo == None`\nis usually inspired from other programming languages (e.g. `foo is None`\nin Python).\nChecking if a value of type `Option<T>` is (not) equal to `None` in that\nway relies on `T: PartialEq` to do the comparison, which is unneeded."
    },
    {
      "id": "clippy::trivially_copy_pass_by_ref",
      "name": "TRIVIALLY_COPY_PASS_BY_REF",
      "snake_name": "trivially_copy_pass_by_ref",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "functions taking small copyable arguments by reference",
      "what_it_does": "Checks for functions taking arguments by reference, where\nthe argument type is `Copy` and small enough to be more efficient to always\npass by value.",
      "why_bad": "In many calling conventions instances of structs will\nbe passed through registers if they fit into two or less general purpose\nregisters.",
      "example": "```no_run\nfn foo(v: &u32) {}\n```\n\nUse instead:\n```no_run\nfn foo(v: u32) {}\n```",
      "version": "pre 1.29.0",
      "source_file": "pass_by_ref_or_value.rs",
      "embedding_text": "functions taking small copyable arguments by reference\n\nChecks for functions taking arguments by reference, where\nthe argument type is `Copy` and small enough to be more efficient to always\npass by value.\n\nIn many calling conventions instances of structs will\nbe passed through registers if they fit into two or less general purpose\nregisters."
    },
    {
      "id": "clippy::large_types_passed_by_value",
      "name": "LARGE_TYPES_PASSED_BY_VALUE",
      "snake_name": "large_types_passed_by_value",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "functions taking large arguments by value",
      "what_it_does": "Checks for functions taking arguments by value, where\nthe argument type is `Copy` and large enough to be worth considering\npassing by reference. Does not trigger if the function is being exported,\nbecause that might induce API breakage, if the parameter is declared as mutable,\nor if the argument is a `self`.",
      "why_bad": "Arguments passed by value might result in an unnecessary\nshallow copy, taking up more space in the stack and requiring a call to\n`memcpy`, which can be expensive.",
      "example": "```no_run\n#[derive(Clone, Copy)]\nstruct TooLarge([u8; 2048]);\n\nfn foo(v: TooLarge) {}\n```\n\nUse instead:\n```no_run\n# #[derive(Clone, Copy)]\n# struct TooLarge([u8; 2048]);\nfn foo(v: &TooLarge) {}\n```",
      "version": "1.49.0",
      "source_file": "pass_by_ref_or_value.rs",
      "embedding_text": "functions taking large arguments by value\n\nChecks for functions taking arguments by value, where\nthe argument type is `Copy` and large enough to be worth considering\npassing by reference. Does not trigger if the function is being exported,\nbecause that might induce API breakage, if the parameter is declared as mutable,\nor if the argument is a `self`.\n\nArguments passed by value might result in an unnecessary\nshallow copy, taking up more space in the stack and requiring a call to\n`memcpy`, which can be expensive."
    },
    {
      "id": "clippy::pathbuf_init_then_push",
      "name": "PATHBUF_INIT_THEN_PUSH",
      "snake_name": "pathbuf_init_then_push",
      "category": "restriction",
      "weight": 1.0,
      "brief": "`push` immediately after `PathBuf` creation",
      "what_it_does": "Checks for calls to `push` immediately after creating a new `PathBuf`.",
      "why_bad": "Multiple `.join()` calls are usually easier to read than multiple `.push`\ncalls across multiple statements. It might also be possible to use\n`PathBuf::from` instead.",
      "example": "```rust\n# use std::path::PathBuf;\nlet mut path_buf = PathBuf::new();\npath_buf.push(\"foo\");\n```\nUse instead:\n```rust\n# use std::path::PathBuf;\nlet path_buf = PathBuf::from(\"foo\");\n// or\nlet path_buf = PathBuf::new().join(\"foo\");\n```",
      "version": "1.82.0",
      "source_file": "pathbuf_init_then_push.rs",
      "embedding_text": "`push` immediately after `PathBuf` creation\n\nChecks for calls to `push` immediately after creating a new `PathBuf`.\n\nMultiple `.join()` calls are usually easier to read than multiple `.push`\ncalls across multiple statements. It might also be possible to use\n`PathBuf::from` instead."
    },
    {
      "id": "clippy::pattern_type_mismatch",
      "name": "PATTERN_TYPE_MISMATCH",
      "snake_name": "pattern_type_mismatch",
      "category": "restriction",
      "weight": 1.0,
      "brief": "type of pattern does not match the expression type",
      "what_it_does": "Checks for patterns that aren't exact representations of the types\nthey are applied to.\n\nTo satisfy this lint, you will have to adjust either the expression that is matched\nagainst or the pattern itself, as well as the bindings that are introduced by the\nadjusted patterns. For matching you will have to either dereference the expression\nwith the `*` operator, or amend the patterns to explicitly match against `&<pattern>`\nor `&mut <pattern>` depending on the reference mutability. For the bindings you need\nto use the inverse. You can leave them as plain bindings if you wish for the value\nto be copied, but you must use `ref mut <variable>` or `ref <variable>` to construct\na reference into the matched structure.\n\nIf you are looking for a way to learn about ownership semantics in more detail, it\nis recommended to look at IDE options available to you to highlight types, lifetimes\nand reference semantics in your code. The available tooling would expose these things\nin a general way even outside of the various pattern matching mechanics. Of course\nthis lint can still be used to highlight areas of interest and ensure a good understanding\nof ownership semantics.",
      "why_bad": "It increases ownership hints in the code, and will guard against some changes\nin ownership.",
      "example": "This example shows the basic adjustments necessary to satisfy the lint. Note how\nthe matched expression is explicitly dereferenced with `*` and the `inner` variable\nis bound to a shared borrow via `ref inner`.\n\n```rust,ignore\n// Bad\nlet value = &Some(Box::new(23));\nmatch value {\nSome(inner) => println!(\"{}\", inner),\nNone => println!(\"none\"),\n}\n\n// Good\nlet value = &Some(Box::new(23));\nmatch *value {\nSome(ref inner) => println!(\"{}\", inner),\nNone => println!(\"none\"),\n}\n```\n\nThe following example demonstrates one of the advantages of the more verbose style.\nNote how the second version uses `ref mut a` to explicitly declare `a` a shared mutable\nborrow, while `b` is simply taken by value. This ensures that the loop body cannot\naccidentally modify the wrong part of the structure.\n\n```rust,ignore\n// Bad\nlet mut values = vec![(2, 3), (3, 4)];\nfor (a, b) in &mut values {\n*a += *b;\n}\n\n// Good\nlet mut values = vec![(2, 3), (3, 4)];\nfor &mut (ref mut a, b) in &mut values {\n*a += b;\n}\n```",
      "version": "1.47.0",
      "source_file": "pattern_type_mismatch.rs",
      "embedding_text": "type of pattern does not match the expression type\n\nChecks for patterns that aren't exact representations of the types\nthey are applied to.\n\nTo satisfy this lint, you will have to adjust either the expression that is matched\nagainst or the pattern itself, as well as the bindings that are introduced by the\nadjusted patterns. For matching you will have to either dereference the expression\nwith the `*` operator, or amend the patterns to explicitly match against `&<pattern>`\nor `&mut <pattern>` depending on the reference mutability. For the bindings you need\nto use the inverse. You can leave them as plain bindings if you wish for the value\nto be copied, but you must use `ref mut <variable>` or `ref <variable>` to construct\na reference into the matched structure.\n\nIf you are looking for a way to learn about ownership semantics in more detail, it\nis recommended to look at IDE options available to you to highlight types, lifetimes\nand reference semantics in your code. The available tooling would expose these things\nin a general way even outside of the various pattern matching mechanics. Of course\nthis lint can still be used to highlight areas of interest and ensure a good understanding\nof ownership semantics.\n\nIt increases ownership hints in the code, and will guard against some changes\nin ownership."
    },
    {
      "id": "clippy::permissions_set_readonly_false",
      "name": "PERMISSIONS_SET_READONLY_FALSE",
      "snake_name": "permissions_set_readonly_false",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "Checks for calls to `std::fs::Permissions.set_readonly` with argument `false`",
      "what_it_does": "Checks for calls to `std::fs::Permissions.set_readonly` with argument `false`.",
      "why_bad": "On Unix platforms this results in the file being world writable,\nequivalent to `chmod a+w <file>`.",
      "example": "```no_run\nuse std::fs::File;\nlet f = File::create(\"foo.txt\").unwrap();\nlet metadata = f.metadata().unwrap();\nlet mut permissions = metadata.permissions();\npermissions.set_readonly(false);\n```",
      "version": "1.68.0",
      "source_file": "permissions_set_readonly_false.rs",
      "embedding_text": "Checks for calls to `std::fs::Permissions.set_readonly` with argument `false`\n\nChecks for calls to `std::fs::Permissions.set_readonly` with argument `false`.\n\nOn Unix platforms this results in the file being world writable,\nequivalent to `chmod a+w <file>`."
    },
    {
      "id": "clippy::pointers_in_nomem_asm_block",
      "name": "POINTERS_IN_NOMEM_ASM_BLOCK",
      "snake_name": "pointers_in_nomem_asm_block",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "pointers in nomem asm block",
      "what_it_does": "Checks if any pointer is being passed to an asm! block with `nomem` option.",
      "why_bad": "`nomem` forbids any reads or writes to memory and passing a pointer suggests\nthat either of those will happen.",
      "example": "```no_run\nfn f(p: *mut u32) {\nunsafe { core::arch::asm!(\"mov [{p}], 42\", p = in(reg) p, options(nomem, nostack)); }\n}\n```\nUse instead:\n```no_run\nfn f(p: *mut u32) {\nunsafe { core::arch::asm!(\"mov [{p}], 42\", p = in(reg) p, options(nostack)); }\n}\n```",
      "version": "1.81.0",
      "source_file": "pointers_in_nomem_asm_block.rs",
      "embedding_text": "pointers in nomem asm block\n\nChecks if any pointer is being passed to an asm! block with `nomem` option.\n\n`nomem` forbids any reads or writes to memory and passing a pointer suggests\nthat either of those will happen."
    },
    {
      "id": "clippy::precedence",
      "name": "PRECEDENCE",
      "snake_name": "precedence",
      "category": "complexity",
      "weight": 1.0,
      "brief": "operations where precedence may be unclear",
      "what_it_does": "Checks for operations where precedence may be unclear and suggests to add parentheses.\nIt catches a mixed usage of arithmetic and bit shifting/combining operators,\nas well as method calls applied to closures.",
      "why_bad": "Not everyone knows the precedence of those operators by\nheart, so expressions like these may trip others trying to reason about the\ncode.",
      "example": "`1 << 2 + 3` equals 32, while `(1 << 2) + 3` equals 7",
      "version": "pre 1.29.0",
      "source_file": "precedence.rs",
      "embedding_text": "operations where precedence may be unclear\n\nChecks for operations where precedence may be unclear and suggests to add parentheses.\nIt catches a mixed usage of arithmetic and bit shifting/combining operators,\nas well as method calls applied to closures.\n\nNot everyone knows the precedence of those operators by\nheart, so expressions like these may trip others trying to reason about the\ncode."
    },
    {
      "id": "clippy::precedence_bits",
      "name": "PRECEDENCE_BITS",
      "snake_name": "precedence_bits",
      "category": "restriction",
      "weight": 1.0,
      "brief": "operations mixing bit shifting with bit combining/masking",
      "what_it_does": "Checks for bit shifting operations combined with bit masking/combining operators\nand suggest using parentheses.",
      "why_bad": "Not everyone knows the precedence of those operators by\nheart, so expressions like these may trip others trying to reason about the\ncode.",
      "example": "`0x2345 & 0xF000 >> 12` equals 5, while `(0x2345 & 0xF000) >> 12` equals 2",
      "version": "1.86.0",
      "source_file": "precedence.rs",
      "embedding_text": "operations mixing bit shifting with bit combining/masking\n\nChecks for bit shifting operations combined with bit masking/combining operators\nand suggest using parentheses.\n\nNot everyone knows the precedence of those operators by\nheart, so expressions like these may trip others trying to reason about the\ncode."
    },
    {
      "id": "clippy::ptr_arg",
      "name": "PTR_ARG",
      "snake_name": "ptr_arg",
      "category": "style",
      "weight": 0.95,
      "brief": "fn arguments of the type `&Vec<...>` or `&String`, suggesting to use `&[...]` or `&str` instead, respectively",
      "what_it_does": "This lint checks for function arguments of type `&String`, `&Vec`,\n`&PathBuf`, and `Cow<_>`. It will also suggest you replace `.clone()` calls\nwith the appropriate `.to_owned()`/`to_string()` calls.",
      "why_bad": "Requiring the argument to be of the specific type\nmakes the function less useful for no benefit; slices in the form of `&[T]`\nor `&str` usually suffice and can be obtained from other types, too.",
      "example": "```ignore\nfn foo(&Vec<u32>) { .. }\n```\n\nUse instead:\n```ignore\nfn foo(&[u32]) { .. }\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "fn arguments of the type `&Vec<...>` or `&String`, suggesting to use `&[...]` or `&str` instead, respectively\n\nThis lint checks for function arguments of type `&String`, `&Vec`,\n`&PathBuf`, and `Cow<_>`. It will also suggest you replace `.clone()` calls\nwith the appropriate `.to_owned()`/`to_string()` calls.\n\nRequiring the argument to be of the specific type\nmakes the function less useful for no benefit; slices in the form of `&[T]`\nor `&str` usually suffice and can be obtained from other types, too."
    },
    {
      "id": "clippy::cmp_null",
      "name": "CMP_NULL",
      "snake_name": "cmp_null",
      "category": "style",
      "weight": 0.95,
      "brief": "comparing a pointer to a null pointer, suggesting to use `.is_null()` instead",
      "what_it_does": "This lint checks for equality comparisons with `ptr::null` or `ptr::null_mut`",
      "why_bad": "It's easier and more readable to use the inherent\n`.is_null()`\nmethod instead",
      "example": "```rust,ignore\nuse std::ptr;\n\nif x == ptr::null() {\n// ..\n}\n```\n\nUse instead:\n```rust,ignore\nif x.is_null() {\n// ..\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "comparing a pointer to a null pointer, suggesting to use `.is_null()` instead\n\nThis lint checks for equality comparisons with `ptr::null` or `ptr::null_mut`\n\nIt's easier and more readable to use the inherent\n`.is_null()`\nmethod instead"
    },
    {
      "id": "clippy::mut_from_ref",
      "name": "MUT_FROM_REF",
      "snake_name": "mut_from_ref",
      "category": "correctness",
      "weight": 1.2,
      "brief": "fns that create mutable refs from immutable ref args",
      "what_it_does": "This lint checks for functions that take immutable references and return\nmutable ones. This will not trigger if no unsafe code exists as there\nare multiple safe functions which will do this transformation\n\nTo be on the conservative side, if there's at least one mutable\nreference with the output lifetime, this lint will not trigger.",
      "why_bad": "Creating a mutable reference which can be repeatably derived from an\nimmutable reference is unsound as it allows creating multiple live\nmutable references to the same object.\n\nThis [error](https://github.com/rust-lang/rust/issues/39465) actually\nlead to an interim Rust release 1.15.1.",
      "example": "```ignore\nfn foo(&Foo) -> &mut Bar { .. }\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "fns that create mutable refs from immutable ref args\n\nThis lint checks for functions that take immutable references and return\nmutable ones. This will not trigger if no unsafe code exists as there\nare multiple safe functions which will do this transformation\n\nTo be on the conservative side, if there's at least one mutable\nreference with the output lifetime, this lint will not trigger.\n\nCreating a mutable reference which can be repeatably derived from an\nimmutable reference is unsound as it allows creating multiple live\nmutable references to the same object.\n\nThis [error](https://github.com/rust-lang/rust/issues/39465) actually\nlead to an interim Rust release 1.15.1."
    },
    {
      "id": "clippy::ptr_eq",
      "name": "PTR_EQ",
      "snake_name": "ptr_eq",
      "category": "style",
      "weight": 0.95,
      "brief": "use `std::ptr::eq` when comparing raw pointers",
      "what_it_does": "Use `std::ptr::eq` when applicable",
      "why_bad": "`ptr::eq` can be used to compare `&T` references\n(which coerce to `*const T` implicitly) by their address rather than\ncomparing the values they point to.",
      "example": "```no_run\nlet a = &[1, 2, 3];\nlet b = &[1, 2, 3];\n\nassert!(a as *const _ as usize == b as *const _ as usize);\n```\nUse instead:\n```no_run\nlet a = &[1, 2, 3];\nlet b = &[1, 2, 3];\n\nassert!(std::ptr::eq(a, b));\n```",
      "version": "1.49.0",
      "source_file": "mod.rs",
      "embedding_text": "use `std::ptr::eq` when comparing raw pointers\n\nUse `std::ptr::eq` when applicable\n\n`ptr::eq` can be used to compare `&T` references\n(which coerce to `*const T` implicitly) by their address rather than\ncomparing the values they point to."
    },
    {
      "id": "clippy::pub_underscore_fields",
      "name": "PUB_UNDERSCORE_FIELDS",
      "snake_name": "pub_underscore_fields",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "struct field prefixed with underscore and marked public",
      "what_it_does": "Checks whether any field of the struct is prefixed with an `_` (underscore) and also marked\n`pub` (public)",
      "why_bad": "Fields prefixed with an `_` are inferred as unused, which suggests it should not be marked\nas `pub`, because marking it as `pub` infers it will be used.",
      "example": "```rust\nstruct FileHandle {\npub _descriptor: usize,\n}\n```\nUse instead:\n```rust\nstruct FileHandle {\n_descriptor: usize,\n}\n```\n\nOR\n\n```rust\nstruct FileHandle {\npub descriptor: usize,\n}\n```",
      "version": "1.77.0",
      "source_file": "pub_underscore_fields.rs",
      "embedding_text": "struct field prefixed with underscore and marked public\n\nChecks whether any field of the struct is prefixed with an `_` (underscore) and also marked\n`pub` (public)\n\nFields prefixed with an `_` are inferred as unused, which suggests it should not be marked\nas `pub`, because marking it as `pub` infers it will be used."
    },
    {
      "id": "clippy::pub_use",
      "name": "PUB_USE",
      "snake_name": "pub_use",
      "category": "restriction",
      "weight": 1.0,
      "brief": "restricts the usage of `pub use`",
      "what_it_does": "Restricts the usage of `pub use ...`",
      "why_bad": "A project may wish to limit `pub use` instances to prevent\nunintentional exports, or to encourage placing exported items directly in public modules.",
      "example": "```no_run\npub mod outer {\nmod inner {\npub struct Test {}\n}\npub use inner::Test;\n}\n\nuse outer::Test;\n```\nUse instead:\n```no_run\npub mod outer {\npub struct Test {}\n}\n\nuse outer::Test;\n```",
      "version": "1.62.0",
      "source_file": "pub_use.rs",
      "embedding_text": "restricts the usage of `pub use`\n\nRestricts the usage of `pub use ...`\n\nA project may wish to limit `pub use` instances to prevent\nunintentional exports, or to encourage placing exported items directly in public modules."
    },
    {
      "id": "clippy::question_mark",
      "name": "QUESTION_MARK",
      "snake_name": "question_mark",
      "category": "style",
      "weight": 0.95,
      "brief": "checks for expressions that could be replaced by the `?` operator",
      "what_it_does": "Checks for expressions that could be replaced by the `?` operator.",
      "why_bad": "Using the `?` operator is shorter and more idiomatic.",
      "example": "```ignore\nif option.is_none() {\nreturn None;\n}\n```\n\nCould be written:\n\n```ignore\noption?;\n```",
      "version": "pre 1.29.0",
      "source_file": "question_mark.rs",
      "embedding_text": "checks for expressions that could be replaced by the `?` operator\n\nChecks for expressions that could be replaced by the `?` operator.\n\nUsing the `?` operator is shorter and more idiomatic."
    },
    {
      "id": "clippy::question_mark_used",
      "name": "QUESTION_MARK_USED",
      "snake_name": "question_mark_used",
      "category": "restriction",
      "weight": 1.0,
      "brief": "checks if the `?` operator is used",
      "what_it_does": "Checks for expressions that use the `?` operator and rejects them.",
      "why_bad": "Sometimes code wants to avoid the `?` operator because for instance a local\nblock requires a macro to re-throw errors to attach additional information to the\nerror.",
      "example": "```ignore\nlet result = expr?;\n```\n\nCould be written:\n\n```ignore\nutility_macro!(expr);\n```",
      "version": "1.69.0",
      "source_file": "question_mark_used.rs",
      "embedding_text": "checks if the `?` operator is used\n\nChecks for expressions that use the `?` operator and rejects them.\n\nSometimes code wants to avoid the `?` operator because for instance a local\nblock requires a macro to re-throw errors to attach additional information to the\nerror."
    },
    {
      "id": "clippy::range_plus_one",
      "name": "RANGE_PLUS_ONE",
      "snake_name": "range_plus_one",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "`x..(y+1)` reads better as `x..=y`",
      "what_it_does": "Checks for exclusive ranges where 1 is added to the\nupper bound, e.g., `x..(y+1)`.",
      "why_bad": "The code is more readable with an inclusive range\nlike `x..=y`.",
      "example": "```no_run\n# let x = 0;\n# let y = 1;\nfor i in x..(y+1) {\n// ..\n}\n```\n\nUse instead:\n```no_run\n# let x = 0;\n# let y = 1;\nfor i in x..=y {\n// ..\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "ranges.rs",
      "embedding_text": "`x..(y+1)` reads better as `x..=y`\n\nChecks for exclusive ranges where 1 is added to the\nupper bound, e.g., `x..(y+1)`.\n\nThe code is more readable with an inclusive range\nlike `x..=y`."
    },
    {
      "id": "clippy::range_minus_one",
      "name": "RANGE_MINUS_ONE",
      "snake_name": "range_minus_one",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "`x..=(y-1)` reads better as `x..y`",
      "what_it_does": "Checks for inclusive ranges where 1 is subtracted from\nthe upper bound, e.g., `x..=(y-1)`.",
      "why_bad": "The code is more readable with an exclusive range\nlike `x..y`.",
      "example": "```no_run\n# let x = 0;\n# let y = 1;\nfor i in x..=(y-1) {\n// ..\n}\n```\n\nUse instead:\n```no_run\n# let x = 0;\n# let y = 1;\nfor i in x..y {\n// ..\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "ranges.rs",
      "embedding_text": "`x..=(y-1)` reads better as `x..y`\n\nChecks for inclusive ranges where 1 is subtracted from\nthe upper bound, e.g., `x..=(y-1)`.\n\nThe code is more readable with an exclusive range\nlike `x..y`."
    },
    {
      "id": "clippy::reversed_empty_ranges",
      "name": "REVERSED_EMPTY_RANGES",
      "snake_name": "reversed_empty_ranges",
      "category": "correctness",
      "weight": 1.2,
      "brief": "reversing the limits of range expressions, resulting in empty ranges",
      "what_it_does": "Checks for range expressions `x..y` where both `x` and `y`\nare constant and `x` is greater to `y`. Also triggers if `x` is equal to `y` when they are conditions to a `for` loop.",
      "why_bad": "Empty ranges yield no values so iterating them is a no-op.\nMoreover, trying to use a reversed range to index a slice will panic at run-time.",
      "example": "```rust,no_run\nfn main() {\n(10..=0).for_each(|x| println!(\"{}\", x));\n\nlet arr = [1, 2, 3, 4, 5];\nlet sub = &arr[3..1];\n}\n```\nUse instead:\n```no_run\nfn main() {\n(0..=10).rev().for_each(|x| println!(\"{}\", x));\n\nlet arr = [1, 2, 3, 4, 5];\nlet sub = &arr[1..3];\n}\n```",
      "version": "1.45.0",
      "source_file": "ranges.rs",
      "embedding_text": "reversing the limits of range expressions, resulting in empty ranges\n\nChecks for range expressions `x..y` where both `x` and `y`\nare constant and `x` is greater to `y`. Also triggers if `x` is equal to `y` when they are conditions to a `for` loop.\n\nEmpty ranges yield no values so iterating them is a no-op.\nMoreover, trying to use a reversed range to index a slice will panic at run-time."
    },
    {
      "id": "clippy::manual_range_contains",
      "name": "MANUAL_RANGE_CONTAINS",
      "snake_name": "manual_range_contains",
      "category": "style",
      "weight": 0.95,
      "brief": "manually reimplementing {`Range`, `RangeInclusive`}`::contains`",
      "what_it_does": "Checks for expressions like `x >= 3 && x < 8` that could\nbe more readably expressed as `(3..8).contains(x)`.",
      "why_bad": "`contains` expresses the intent better and has less\nfailure modes (such as fencepost errors or using `||` instead of `&&`).",
      "example": "```no_run\n// given\nlet x = 6;\n\nassert!(x >= 3 && x < 8);\n```\nUse instead:\n```no_run\n# let x = 6;\nassert!((3..8).contains(&x));\n```",
      "version": "1.49.0",
      "source_file": "ranges.rs",
      "embedding_text": "manually reimplementing {`Range`, `RangeInclusive`}`::contains`\n\nChecks for expressions like `x >= 3 && x < 8` that could\nbe more readably expressed as `(3..8).contains(x)`.\n\n`contains` expresses the intent better and has less\nfailure modes (such as fencepost errors or using `||` instead of `&&`)."
    },
    {
      "id": "clippy::needless_raw_strings",
      "name": "NEEDLESS_RAW_STRINGS",
      "snake_name": "needless_raw_strings",
      "category": "restriction",
      "weight": 1.0,
      "brief": "suggests using a string literal when a raw string literal is unnecessary",
      "what_it_does": "Checks for raw string literals where a string literal can be used instead.",
      "why_bad": "For consistent style by using simpler string literals whenever possible.\n\nHowever, there are many cases where using a raw string literal is more\nidiomatic than a string literal, so it's opt-in.",
      "example": "```no_run\nlet r = r\"Hello, world!\";\n```\nUse instead:\n```no_run\nlet r = \"Hello, world!\";\n```",
      "version": "1.72.0",
      "source_file": "raw_strings.rs",
      "embedding_text": "suggests using a string literal when a raw string literal is unnecessary\n\nChecks for raw string literals where a string literal can be used instead.\n\nFor consistent style by using simpler string literals whenever possible.\n\nHowever, there are many cases where using a raw string literal is more\nidiomatic than a string literal, so it's opt-in."
    },
    {
      "id": "clippy::needless_raw_string_hashes",
      "name": "NEEDLESS_RAW_STRING_HASHES",
      "snake_name": "needless_raw_string_hashes",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "suggests reducing the number of hashes around a raw string literal",
      "what_it_does": "Checks for raw string literals with an unnecessary amount of hashes around them.",
      "why_bad": "It's just unnecessary, and makes it look like there's more escaping needed than is actually\nnecessary.",
      "example": "```no_run\nlet r = r",
      "version": "1.72.0",
      "source_file": "raw_strings.rs",
      "embedding_text": "suggests reducing the number of hashes around a raw string literal\n\nChecks for raw string literals with an unnecessary amount of hashes around them.\n\nIt's just unnecessary, and makes it look like there's more escaping needed than is actually\nnecessary."
    },
    {
      "id": "clippy::rc_clone_in_vec_init",
      "name": "RC_CLONE_IN_VEC_INIT",
      "snake_name": "rc_clone_in_vec_init",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "initializing reference-counted pointer in `vec![elem; len]`",
      "what_it_does": "Checks for reference-counted pointers (`Arc`, `Rc`, `rc::Weak`, and `sync::Weak`)\nin `vec![elem; len]`",
      "why_bad": "This will create `elem` once and clone it `len` times - doing so with `Arc`/`Rc`/`Weak`\nis a bit misleading, as it will create references to the same pointer, rather\nthan different instances.",
      "example": "```no_run\nlet v = vec![std::sync::Arc::new(\"some data\".to_string()); 100];\n// or\nlet v = vec![std::rc::Rc::new(\"some data\".to_string()); 100];\n```\nUse instead:\n```no_run\n// Initialize each value separately:\nlet mut data = Vec::with_capacity(100);\nfor _ in 0..100 {\ndata.push(std::rc::Rc::new(\"some data\".to_string()));\n}\n\n// Or if you want clones of the same reference,\n// Create the reference beforehand to clarify that\n// it should be cloned for each value\nlet data = std::rc::Rc::new(\"some data\".to_string());\nlet v = vec![data; 100];\n```",
      "version": "1.63.0",
      "source_file": "rc_clone_in_vec_init.rs",
      "embedding_text": "initializing reference-counted pointer in `vec![elem; len]`\n\nChecks for reference-counted pointers (`Arc`, `Rc`, `rc::Weak`, and `sync::Weak`)\nin `vec![elem; len]`\n\nThis will create `elem` once and clone it `len` times - doing so with `Arc`/`Rc`/`Weak`\nis a bit misleading, as it will create references to the same pointer, rather\nthan different instances."
    },
    {
      "id": "clippy::read_zero_byte_vec",
      "name": "READ_ZERO_BYTE_VEC",
      "snake_name": "read_zero_byte_vec",
      "category": "nursery",
      "weight": 0.9,
      "brief": "checks for reads into a zero-length `Vec`",
      "what_it_does": "This lint catches reads into a zero-length `Vec`.\nEspecially in the case of a call to `with_capacity`, this lint warns that read\ngets the number of bytes from the `Vec`'s length, not its capacity.",
      "why_bad": "Reading zero bytes is almost certainly not the intended behavior.",
      "example": "```no_run\nuse std::io;\nfn foo<F: io::Read>(mut f: F) {\nlet mut data = Vec::with_capacity(100);\nf.read(&mut data).unwrap();\n}\n```\nUse instead:\n```no_run\nuse std::io;\nfn foo<F: io::Read>(mut f: F) {\nlet mut data = Vec::with_capacity(100);\ndata.resize(100, 0);\nf.read(&mut data).unwrap();\n}\n```",
      "version": "1.63.0",
      "source_file": "read_zero_byte_vec.rs",
      "embedding_text": "checks for reads into a zero-length `Vec`\n\nThis lint catches reads into a zero-length `Vec`.\nEspecially in the case of a call to `with_capacity`, this lint warns that read\ngets the number of bytes from the `Vec`'s length, not its capacity.\n\nReading zero bytes is almost certainly not the intended behavior."
    },
    {
      "id": "clippy::redundant_async_block",
      "name": "REDUNDANT_ASYNC_BLOCK",
      "snake_name": "redundant_async_block",
      "category": "complexity",
      "weight": 1.0,
      "brief": "`async { future.await }` can be replaced by `future`",
      "what_it_does": "Checks for `async` block that only returns `await` on a future.",
      "why_bad": "It is simpler and more efficient to use the future directly.",
      "example": "```no_run\nlet f = async {\n1 + 2\n};\nlet fut = async {\nf.await\n};\n```\nUse instead:\n```no_run\nlet f = async {\n1 + 2\n};\nlet fut = f;\n```",
      "version": "1.70.0",
      "source_file": "redundant_async_block.rs",
      "embedding_text": "`async { future.await }` can be replaced by `future`\n\nChecks for `async` block that only returns `await` on a future.\n\nIt is simpler and more efficient to use the future directly."
    },
    {
      "id": "clippy::redundant_clone",
      "name": "REDUNDANT_CLONE",
      "snake_name": "redundant_clone",
      "category": "nursery",
      "weight": 0.9,
      "brief": "`clone()` of an owned value that is going to be dropped immediately",
      "what_it_does": "Checks for a redundant `clone()` (and its relatives) which clones an owned\nvalue that is going to be dropped without further use.",
      "why_bad": "It is not always possible for the compiler to eliminate useless\nallocations and deallocations generated by redundant `clone()`s.",
      "example": "```no_run\n# use std::path::Path;\n# #[derive(Clone)]\n# struct Foo;\n# impl Foo {\n#     fn new() -> Self { Foo {} }\n# }\n# fn call(x: Foo) {}\n{\nlet x = Foo::new();\ncall(x.clone());\ncall(x.clone()); // this can just pass `x`\n}\n\n[\"lorem\", \"ipsum\"].join(\" \").to_string();\n\nPath::new(\"/a/b\").join(\"c\").to_path_buf();\n```",
      "version": "1.32.0",
      "source_file": "redundant_clone.rs",
      "embedding_text": "`clone()` of an owned value that is going to be dropped immediately\n\nChecks for a redundant `clone()` (and its relatives) which clones an owned\nvalue that is going to be dropped without further use.\n\nIt is not always possible for the compiler to eliminate useless\nallocations and deallocations generated by redundant `clone()`s."
    },
    {
      "id": "clippy::redundant_closure_call",
      "name": "REDUNDANT_CLOSURE_CALL",
      "snake_name": "redundant_closure_call",
      "category": "complexity",
      "weight": 1.0,
      "brief": "throwaway closures called in the expression they are defined",
      "what_it_does": "Detects closures called in the same expression where they\nare defined.",
      "why_bad": "It is unnecessarily adding to the expression's\ncomplexity.",
      "example": "```no_run\nlet a = (|| 42)();\n```\n\nUse instead:\n```no_run\nlet a = 42;\n```",
      "version": "pre 1.29.0",
      "source_file": "redundant_closure_call.rs",
      "embedding_text": "throwaway closures called in the expression they are defined\n\nDetects closures called in the same expression where they\nare defined.\n\nIt is unnecessarily adding to the expression's\ncomplexity."
    },
    {
      "id": "clippy::redundant_else",
      "name": "REDUNDANT_ELSE",
      "snake_name": "redundant_else",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "`else` branch that can be removed without changing semantics",
      "what_it_does": "Checks for `else` blocks that can be removed without changing semantics.",
      "why_bad": "The `else` block adds unnecessary indentation and verbosity.",
      "example": "```no_run\nfn my_func(count: u32) {\nif count == 0 {\nprint!(\"Nothing to do\");\nreturn;\n} else {\nprint!(\"Moving on...\");\n}\n}\n```\nUse instead:\n```no_run\nfn my_func(count: u32) {\nif count == 0 {\nprint!(\"Nothing to do\");\nreturn;\n}\nprint!(\"Moving on...\");\n}\n```",
      "version": "1.50.0",
      "source_file": "redundant_else.rs",
      "embedding_text": "`else` branch that can be removed without changing semantics\n\nChecks for `else` blocks that can be removed without changing semantics.\n\nThe `else` block adds unnecessary indentation and verbosity."
    },
    {
      "id": "clippy::redundant_field_names",
      "name": "REDUNDANT_FIELD_NAMES",
      "snake_name": "redundant_field_names",
      "category": "style",
      "weight": 0.95,
      "brief": "checks for fields in struct literals where shorthands could be used",
      "what_it_does": "Checks for fields in struct literals where shorthands\ncould be used.",
      "why_bad": "If the field and variable names are the same,\nthe field name is redundant.",
      "example": "```no_run\nlet bar: u8 = 123;\n\nstruct Foo {\nbar: u8,\n}\n\nlet foo = Foo { bar: bar };\n```\nthe last line can be simplified to\n```ignore\nlet foo = Foo { bar };\n```",
      "version": "pre 1.29.0",
      "source_file": "redundant_field_names.rs",
      "embedding_text": "checks for fields in struct literals where shorthands could be used\n\nChecks for fields in struct literals where shorthands\ncould be used.\n\nIf the field and variable names are the same,\nthe field name is redundant."
    },
    {
      "id": "clippy::redundant_locals",
      "name": "REDUNDANT_LOCALS",
      "snake_name": "redundant_locals",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "redundant redefinition of a local binding",
      "what_it_does": "Checks for redundant redefinitions of local bindings.",
      "why_bad": "Redundant redefinitions of local bindings do not change behavior other than variable's lifetimes and are likely to be unintended.\n\nThese rebindings can be intentional to shorten the lifetimes of variables because they affect when the `Drop` implementation is called. Other than that, they do not affect your code's meaning but they _may_ affect `rustc`'s stack allocation.",
      "example": "```no_run\nlet a = 0;\nlet a = a;\n\nfn foo(b: i32) {\nlet b = b;\n}\n```\nUse instead:\n```no_run\nlet a = 0;\n// no redefinition with the same name\n\nfn foo(b: i32) {\n// no redefinition with the same name\n}\n```",
      "version": "1.73.0",
      "source_file": "redundant_locals.rs",
      "embedding_text": "redundant redefinition of a local binding\n\nChecks for redundant redefinitions of local bindings.\n\nRedundant redefinitions of local bindings do not change behavior other than variable's lifetimes and are likely to be unintended.\n\nThese rebindings can be intentional to shorten the lifetimes of variables because they affect when the `Drop` implementation is called. Other than that, they do not affect your code's meaning but they _may_ affect `rustc`'s stack allocation."
    },
    {
      "id": "clippy::redundant_pub_crate",
      "name": "REDUNDANT_PUB_CRATE",
      "snake_name": "redundant_pub_crate",
      "category": "nursery",
      "weight": 0.9,
      "brief": "Using `pub(crate)` visibility on items that are not crate visible due to the visibility of the module that contains them.",
      "what_it_does": "Checks for items declared `pub(crate)` that are not crate visible because they\nare inside a private module.",
      "why_bad": "Writing `pub(crate)` is misleading when it's redundant due to the parent\nmodule's visibility.",
      "example": "```no_run\nmod internal {\npub(crate) fn internal_fn() { }\n}\n```\nThis function is not visible outside the module and it can be declared with `pub` or\nprivate visibility\n```no_run\nmod internal {\npub fn internal_fn() { }\n}\n```",
      "version": "1.44.0",
      "source_file": "redundant_pub_crate.rs",
      "embedding_text": "Using `pub(crate)` visibility on items that are not crate visible due to the visibility of the module that contains them.\n\nChecks for items declared `pub(crate)` that are not crate visible because they\nare inside a private module.\n\nWriting `pub(crate)` is misleading when it's redundant due to the parent\nmodule's visibility."
    },
    {
      "id": "clippy::redundant_slicing",
      "name": "REDUNDANT_SLICING",
      "snake_name": "redundant_slicing",
      "category": "complexity",
      "weight": 1.0,
      "brief": "redundant slicing of the whole range of a type",
      "what_it_does": "Checks for redundant slicing expressions which use the full range, and\ndo not change the type.",
      "why_bad": "It unnecessarily adds complexity to the expression.",
      "example": "```ignore\nfn get_slice(x: &[u32]) -> &[u32] {\n&x[..]\n}\n```\nUse instead:\n```ignore\nfn get_slice(x: &[u32]) -> &[u32] {\nx\n}\n```",
      "version": "1.51.0",
      "source_file": "redundant_slicing.rs",
      "embedding_text": "redundant slicing of the whole range of a type\n\nChecks for redundant slicing expressions which use the full range, and\ndo not change the type.\n\nIt unnecessarily adds complexity to the expression."
    },
    {
      "id": "clippy::deref_by_slicing",
      "name": "DEREF_BY_SLICING",
      "snake_name": "deref_by_slicing",
      "category": "restriction",
      "weight": 1.0,
      "brief": "slicing instead of dereferencing",
      "what_it_does": "Checks for slicing expressions which are equivalent to dereferencing the\nvalue.",
      "why_bad": "Some people may prefer to dereference rather than slice.",
      "example": "```no_run\nlet vec = vec![1, 2, 3];\nlet slice = &vec[..];\n```\nUse instead:\n```no_run\nlet vec = vec![1, 2, 3];\nlet slice = &*vec;\n```",
      "version": "1.61.0",
      "source_file": "redundant_slicing.rs",
      "embedding_text": "slicing instead of dereferencing\n\nChecks for slicing expressions which are equivalent to dereferencing the\nvalue.\n\nSome people may prefer to dereference rather than slice."
    },
    {
      "id": "clippy::redundant_static_lifetimes",
      "name": "REDUNDANT_STATIC_LIFETIMES",
      "snake_name": "redundant_static_lifetimes",
      "category": "style",
      "weight": 0.95,
      "brief": "Using explicit `'static` lifetime for constants or statics when elision rules would allow omitting them.",
      "what_it_does": "Checks for constants and statics with an explicit `'static` lifetime.",
      "why_bad": "Adding `'static` to every reference can create very\ncomplicated types.",
      "example": "```ignore\nconst FOO: &'static [(&'static str, &'static str, fn(&Bar) -> bool)] =\n&[...]\nstatic FOO: &'static [(&'static str, &'static str, fn(&Bar) -> bool)] =\n&[...]\n```\nThis code can be rewritten as\n```ignore\nconst FOO: &[(&str, &str, fn(&Bar) -> bool)] = &[...]\nstatic FOO: &[(&str, &str, fn(&Bar) -> bool)] = &[...]\n```",
      "version": "1.37.0",
      "source_file": "redundant_static_lifetimes.rs",
      "embedding_text": "Using explicit `'static` lifetime for constants or statics when elision rules would allow omitting them.\n\nChecks for constants and statics with an explicit `'static` lifetime.\n\nAdding `'static` to every reference can create very\ncomplicated types."
    },
    {
      "id": "clippy::redundant_type_annotations",
      "name": "REDUNDANT_TYPE_ANNOTATIONS",
      "snake_name": "redundant_type_annotations",
      "category": "restriction",
      "weight": 1.0,
      "brief": "warns about needless / redundant type annotations.",
      "what_it_does": "Warns about needless / redundant type annotations.",
      "why_bad": "Code without type annotations is shorter and in most cases\nmore idiomatic and easier to modify.",
      "example": "```no_run\nlet foo: String = String::new();\n```\nUse instead:\n```no_run\nlet foo = String::new();\n```",
      "version": "1.72.0",
      "source_file": "redundant_type_annotations.rs",
      "embedding_text": "warns about needless / redundant type annotations.\n\nWarns about needless / redundant type annotations.\n\nCode without type annotations is shorter and in most cases\nmore idiomatic and easier to modify."
    },
    {
      "id": "clippy::ref_option_ref",
      "name": "REF_OPTION_REF",
      "snake_name": "ref_option_ref",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "use `Option<&T>` instead of `&Option<&T>`",
      "what_it_does": "Checks for usage of `&Option<&T>`.",
      "why_bad": "Since `&` is Copy, it's useless to have a\nreference on `Option<&T>`.",
      "example": "```rust,ignore\nlet x: &Option<&u32> = &Some(&0u32);\n```\nUse instead:\n```rust,ignore\nlet x: Option<&u32> = Some(&0u32);\n```",
      "version": "1.49.0",
      "source_file": "ref_option_ref.rs",
      "embedding_text": "use `Option<&T>` instead of `&Option<&T>`\n\nChecks for usage of `&Option<&T>`.\n\nSince `&` is Copy, it's useless to have a\nreference on `Option<&T>`."
    },
    {
      "id": "clippy::ref_patterns",
      "name": "REF_PATTERNS",
      "snake_name": "ref_patterns",
      "category": "restriction",
      "weight": 1.0,
      "brief": "use of a ref pattern, e.g. Some(ref value)",
      "what_it_does": "Checks for usages of the `ref` keyword.",
      "why_bad": "The `ref` keyword can be confusing for people unfamiliar with it, and often\nit is more concise to use `&` instead.",
      "example": "```no_run\nlet opt = Some(5);\nif let Some(ref foo) = opt {}\n```\nUse instead:\n```no_run\nlet opt = Some(5);\nif let Some(foo) = &opt {}\n```",
      "version": "1.71.0",
      "source_file": "ref_patterns.rs",
      "embedding_text": "use of a ref pattern, e.g. Some(ref value)\n\nChecks for usages of the `ref` keyword.\n\nThe `ref` keyword can be confusing for people unfamiliar with it, and often\nit is more concise to use `&` instead."
    },
    {
      "id": "clippy::deref_addrof",
      "name": "DEREF_ADDROF",
      "snake_name": "deref_addrof",
      "category": "complexity",
      "weight": 1.0,
      "brief": "use of `*&` or `*&mut` in an expression",
      "what_it_does": "Checks for usage of `*&` and `*&mut` in expressions.",
      "why_bad": "Immediately dereferencing a reference is no-op and\nmakes the code less clear.",
      "example": "```rust,ignore\nlet a = f(*&mut b);\nlet c = *&d;\n```\n\nUse instead:\n```rust,ignore\nlet a = f(b);\nlet c = d;\n```",
      "version": "pre 1.29.0",
      "source_file": "reference.rs",
      "embedding_text": "use of `*&` or `*&mut` in an expression\n\nChecks for usage of `*&` and `*&mut` in expressions.\n\nImmediately dereferencing a reference is no-op and\nmakes the code less clear."
    },
    {
      "id": "clippy::invalid_regex",
      "name": "INVALID_REGEX",
      "snake_name": "invalid_regex",
      "category": "correctness",
      "weight": 1.2,
      "brief": "invalid regular expressions",
      "what_it_does": "Checks [regex](https://crates.io/crates/regex) creation\n(with `Regex::new`, `RegexBuilder::new`, or `RegexSet::new`) for correct\nregex syntax.",
      "why_bad": "This will lead to a runtime panic.",
      "example": "```ignore\nRegex::new(\"(\")\n```\n\nUse instead:\n```ignore\nRegex::new(\"\\(\")\n```",
      "version": "pre 1.29.0",
      "source_file": "regex.rs",
      "embedding_text": "invalid regular expressions\n\nChecks [regex](https://crates.io/crates/regex) creation\n(with `Regex::new`, `RegexBuilder::new`, or `RegexSet::new`) for correct\nregex syntax.\n\nThis will lead to a runtime panic."
    },
    {
      "id": "clippy::trivial_regex",
      "name": "TRIVIAL_REGEX",
      "snake_name": "trivial_regex",
      "category": "nursery",
      "weight": 0.9,
      "brief": "trivial regular expressions",
      "what_it_does": "Checks for trivial [regex](https://crates.io/crates/regex)\ncreation (with `Regex::new`, `RegexBuilder::new`, or `RegexSet::new`).",
      "why_bad": "Matching the regex can likely be replaced by `==` or\n`str::starts_with`, `str::ends_with` or `std::contains` or other `str`\nmethods.",
      "example": "```ignore\nRegex::new(\"^foobar\")\n```\n\nUse instead:\n```ignore\nstr::starts_with(\"foobar\")\n```",
      "version": "pre 1.29.0",
      "source_file": "regex.rs",
      "embedding_text": "trivial regular expressions\n\nChecks for trivial [regex](https://crates.io/crates/regex)\ncreation (with `Regex::new`, `RegexBuilder::new`, or `RegexSet::new`).\n\nMatching the regex can likely be replaced by `==` or\n`str::starts_with`, `str::ends_with` or `std::contains` or other `str`\nmethods."
    },
    {
      "id": "clippy::regex_creation_in_loops",
      "name": "REGEX_CREATION_IN_LOOPS",
      "snake_name": "regex_creation_in_loops",
      "category": "perf",
      "weight": 1.0,
      "brief": "regular expression compilation performed in a loop",
      "what_it_does": "Checks for [regex](https://crates.io/crates/regex) compilation inside a loop with a literal.",
      "why_bad": "Compiling a regex is a much more expensive operation than using one, and a compiled regex can be used multiple times.\nThis is documented as an antipattern [on the regex documentation](https://docs.rs/regex/latest/regex/#avoid-re-compiling-regexes-especially-in-a-loop)",
      "example": "```rust,ignore\n# let haystacks = [\"\"];\n# const MY_REGEX: &str = \"a.b\";\nfor haystack in haystacks {\nlet regex = regex::Regex::new(MY_REGEX).unwrap();\nif regex.is_match(haystack) {\n// Perform operation\n}\n}\n```\ncan be replaced with\n```rust,ignore\n# let haystacks = [\"\"];\n# const MY_REGEX: &str = \"a.b\";\nlet regex = regex::Regex::new(MY_REGEX).unwrap();\nfor haystack in haystacks {\nif regex.is_match(haystack) {\n// Perform operation\n}\n}\n```",
      "version": "1.84.0",
      "source_file": "regex.rs",
      "embedding_text": "regular expression compilation performed in a loop\n\nChecks for [regex](https://crates.io/crates/regex) compilation inside a loop with a literal.\n\nCompiling a regex is a much more expensive operation than using one, and a compiled regex can be used multiple times.\nThis is documented as an antipattern [on the regex documentation](https://docs.rs/regex/latest/regex/#avoid-re-compiling-regexes-especially-in-a-loop)"
    },
    {
      "id": "clippy::repeat_vec_with_capacity",
      "name": "REPEAT_VEC_WITH_CAPACITY",
      "snake_name": "repeat_vec_with_capacity",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "repeating a `Vec::with_capacity` expression which does not retain capacity",
      "what_it_does": "Looks for patterns such as `vec![Vec::with_capacity(x); n]` or `iter::repeat(Vec::with_capacity(x))`.",
      "why_bad": "These constructs work by cloning the element, but cloning a `Vec<_>` does not\nrespect the old vector's capacity and effectively discards it.\n\nThis makes `iter::repeat(Vec::with_capacity(x))` especially suspicious because the user most certainly\nexpected that the yielded `Vec<_>` will have the requested capacity, otherwise one can simply write\n`iter::repeat(Vec::new())` instead and it will have the same effect.\n\nSimilarly for `vec![x; n]`, the element `x` is cloned to fill the vec.\nUnlike `iter::repeat` however, the vec repeat macro does not have to clone the value `n` times\nbut just `n - 1` times, because it can reuse the passed value for the last slot.\nThat means that the last `Vec<_>` gets the requested capacity but all other ones do not.",
      "example": "```rust\n# use std::iter;\n\nlet _: Vec<Vec<u8>> = vec![Vec::with_capacity(42); 123];\nlet _: Vec<Vec<u8>> = iter::repeat(Vec::with_capacity(42)).take(123).collect();\n```\nUse instead:\n```rust\n# use std::iter;\n\nlet _: Vec<Vec<u8>> = iter::repeat_with(|| Vec::with_capacity(42)).take(123).collect();\n//                                      ^^^ this closure executes 123 times\n//                                          and the vecs will have the expected capacity\n```",
      "version": "1.76.0",
      "source_file": "repeat_vec_with_capacity.rs",
      "embedding_text": "repeating a `Vec::with_capacity` expression which does not retain capacity\n\nLooks for patterns such as `vec![Vec::with_capacity(x); n]` or `iter::repeat(Vec::with_capacity(x))`.\n\nThese constructs work by cloning the element, but cloning a `Vec<_>` does not\nrespect the old vector's capacity and effectively discards it.\n\nThis makes `iter::repeat(Vec::with_capacity(x))` especially suspicious because the user most certainly\nexpected that the yielded `Vec<_>` will have the requested capacity, otherwise one can simply write\n`iter::repeat(Vec::new())` instead and it will have the same effect.\n\nSimilarly for `vec![x; n]`, the element `x` is cloned to fill the vec.\nUnlike `iter::repeat` however, the vec repeat macro does not have to clone the value `n` times\nbut just `n - 1` times, because it can reuse the passed value for the last slot.\nThat means that the last `Vec<_>` gets the requested capacity but all other ones do not."
    },
    {
      "id": "clippy::replace_box",
      "name": "REPLACE_BOX",
      "snake_name": "replace_box",
      "category": "perf",
      "weight": 1.0,
      "brief": "assigning a newly created box to `Box<T>` is inefficient",
      "what_it_does": "Detects assignments of `Default::default()` or `Box::new(value)`\nto a place of type `Box<T>`.",
      "why_bad": "This incurs an extra heap allocation compared to assigning the boxed\nstorage.",
      "example": "```no_run\nlet mut b = Box::new(1u32);\nb = Default::default();\n```\nUse instead:\n```no_run\nlet mut b = Box::new(1u32);\n*b = Default::default();\n```",
      "version": "1.92.0",
      "source_file": "replace_box.rs",
      "embedding_text": "assigning a newly created box to `Box<T>` is inefficient\n\nDetects assignments of `Default::default()` or `Box::new(value)`\nto a place of type `Box<T>`.\n\nThis incurs an extra heap allocation compared to assigning the boxed\nstorage."
    },
    {
      "id": "clippy::reserve_after_initialization",
      "name": "RESERVE_AFTER_INITIALIZATION",
      "snake_name": "reserve_after_initialization",
      "category": "complexity",
      "weight": 1.0,
      "brief": "`reserve` called immediately after `Vec` creation",
      "what_it_does": "Informs the user about a more concise way to create a vector with a known capacity.",
      "why_bad": "The `Vec::with_capacity` constructor is less complex.",
      "example": "```no_run\nlet mut v: Vec<usize> = vec![];\nv.reserve(10);\n```\nUse instead:\n```no_run\nlet mut v: Vec<usize> = Vec::with_capacity(10);\n```",
      "version": "1.74.0",
      "source_file": "reserve_after_initialization.rs",
      "embedding_text": "`reserve` called immediately after `Vec` creation\n\nInforms the user about a more concise way to create a vector with a known capacity.\n\nThe `Vec::with_capacity` constructor is less complex."
    },
    {
      "id": "clippy::return_self_not_must_use",
      "name": "RETURN_SELF_NOT_MUST_USE",
      "snake_name": "return_self_not_must_use",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "missing `#[must_use]` annotation on a method returning `Self`",
      "what_it_does": "This lint warns when a method returning `Self` doesn't have the `#[must_use]` attribute.",
      "why_bad": "Methods returning `Self` often create new values, having the `#[must_use]` attribute\nprevents users from \"forgetting\" to use the newly created value.\n\nThe `#[must_use]` attribute can be added to the type itself to ensure that instances\nare never forgotten. Functions returning a type marked with `#[must_use]` will not be\nlinted, as the usage is already enforced by the type attribute.",
      "example": "```no_run\npub struct Bar;\nimpl Bar {\n// Missing attribute\npub fn bar(&self) -> Self {\nSelf\n}\n}\n```\n\nUse instead:\n```no_run\n# {\n// It's better to have the `#[must_use]` attribute on the method like this:\npub struct Bar;\nimpl Bar {\n#[must_use]\npub fn bar(&self) -> Self {\nSelf\n}\n}\n# }\n\n# {\n// Or on the type definition like this:\n#[must_use]\npub struct Bar;\nimpl Bar {\npub fn bar(&self) -> Self {\nSelf\n}\n}\n# }\n```",
      "version": "1.59.0",
      "source_file": "return_self_not_must_use.rs",
      "embedding_text": "missing `#[must_use]` annotation on a method returning `Self`\n\nThis lint warns when a method returning `Self` doesn't have the `#[must_use]` attribute.\n\nMethods returning `Self` often create new values, having the `#[must_use]` attribute\nprevents users from \"forgetting\" to use the newly created value.\n\nThe `#[must_use]` attribute can be added to the type itself to ensure that instances\nare never forgotten. Functions returning a type marked with `#[must_use]` will not be\nlinted, as the usage is already enforced by the type attribute."
    },
    {
      "id": "clippy::let_and_return",
      "name": "LET_AND_RETURN",
      "snake_name": "let_and_return",
      "category": "style",
      "weight": 0.95,
      "brief": "creating a let-binding and then immediately returning it like `let x = expr; x` at the end of a block",
      "what_it_does": "Checks for `let`-bindings, which are subsequently\nreturned.",
      "why_bad": "It is just extraneous code. Remove it to make your code\nmore rusty.",
      "example": "```no_run\nfn foo() -> String {\nlet x = String::new();\nx\n}\n```\ninstead, use\n```no_run\nfn foo() -> String {\nString::new()\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "creating a let-binding and then immediately returning it like `let x = expr; x` at the end of a block\n\nChecks for `let`-bindings, which are subsequently\nreturned.\n\nIt is just extraneous code. Remove it to make your code\nmore rusty."
    },
    {
      "id": "clippy::needless_return_with_question_mark",
      "name": "NEEDLESS_RETURN_WITH_QUESTION_MARK",
      "snake_name": "needless_return_with_question_mark",
      "category": "style",
      "weight": 0.95,
      "brief": "using a return statement like `return Err(expr)?;` where removing it would suffice",
      "what_it_does": "Checks for return statements on `Err` paired with the `?` operator.",
      "why_bad": "The `return` is unnecessary.\n\nReturns may be used to add attributes to the return expression. Return\nstatements with attributes are therefore be accepted by this lint.",
      "example": "```rust,ignore\nfn foo(x: usize) -> Result<(), Box<dyn Error>> {\nif x == 0 {\nreturn Err(...)?;\n}\nOk(())\n}\n```\nsimplify to\n```rust,ignore\nfn foo(x: usize) -> Result<(), Box<dyn Error>> {\nif x == 0 {\nErr(...)?;\n}\nOk(())\n}\n```\nif paired with `try_err`, use instead:\n```rust,ignore\nfn foo(x: usize) -> Result<(), Box<dyn Error>> {\nif x == 0 {\nreturn Err(...);\n}\nOk(())\n}\n```",
      "version": "1.73.0",
      "source_file": "mod.rs",
      "embedding_text": "using a return statement like `return Err(expr)?;` where removing it would suffice\n\nChecks for return statements on `Err` paired with the `?` operator.\n\nThe `return` is unnecessary.\n\nReturns may be used to add attributes to the return expression. Return\nstatements with attributes are therefore be accepted by this lint."
    },
    {
      "id": "clippy::same_length_and_capacity",
      "name": "SAME_LENGTH_AND_CAPACITY",
      "snake_name": "same_length_and_capacity",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "`from_raw_parts` with same length and capacity",
      "what_it_does": "Checks for usages of `Vec::from_raw_parts` and `String::from_raw_parts`\nwhere the same expression is used for the length and the capacity.",
      "why_bad": "If the same expression is being passed for the length and\ncapacity, it is most likely a semantic error. In the case of a\nVec, for example, the only way to end up with one that has\nthe same length and capacity is by going through a boxed slice,\ne.g. `Box::from(some_vec)`, which shrinks the capacity to match\nthe length.",
      "example": "```no_run\n#![feature(vec_into_raw_parts)]\nlet mut original: Vec::<i32> = Vec::with_capacity(20);\noriginal.extend([1, 2, 3, 4, 5]);\n\nlet (ptr, mut len, cap) = original.into_raw_parts();\n\n// I will add three more integers:\nunsafe {\nlet ptr = ptr as *mut i32;\n\nfor i in 6..9 {\n*ptr.add(i - 1) = i as i32;\nlen += 1;\n}\n}\n\n// But I forgot the capacity was separate from the length:\nlet reconstructed = unsafe { Vec::from_raw_parts(ptr, len, len) };\n```\n\nUse instead:\n```no_run\n#![feature(vec_into_raw_parts)]\nlet mut original: Vec::<i32> = Vec::with_capacity(20);\noriginal.extend([1, 2, 3, 4, 5]);\n\nlet (ptr, mut len, cap) = original.into_raw_parts();\n\n// I will add three more integers:\nunsafe {\nlet ptr = ptr as *mut i32;\n\nfor i in 6..9 {\n*ptr.add(i - 1) = i as i32;\nlen += 1;\n}\n}\n\n// This time, leverage the previously saved capacity:\nlet reconstructed = unsafe { Vec::from_raw_parts(ptr, len, cap) };\n```",
      "version": "1.93.0",
      "source_file": "same_length_and_capacity.rs",
      "embedding_text": "`from_raw_parts` with same length and capacity\n\nChecks for usages of `Vec::from_raw_parts` and `String::from_raw_parts`\nwhere the same expression is used for the length and the capacity.\n\nIf the same expression is being passed for the length and\ncapacity, it is most likely a semantic error. In the case of a\nVec, for example, the only way to end up with one that has\nthe same length and capacity is by going through a boxed slice,\ne.g. `Box::from(some_vec)`, which shrinks the capacity to match\nthe length."
    },
    {
      "id": "clippy::same_name_method",
      "name": "SAME_NAME_METHOD",
      "snake_name": "same_name_method",
      "category": "restriction",
      "weight": 1.0,
      "brief": "two method with same name",
      "what_it_does": "It lints if a struct has two methods with the same name:\none from a trait, another not from a trait.",
      "why_bad": "Confusing.",
      "example": "```no_run\ntrait T {\nfn foo(&self) {}\n}\n\nstruct S;\n\nimpl T for S {\nfn foo(&self) {}\n}\n\nimpl S {\nfn foo(&self) {}\n}\n```",
      "version": "1.57.0",
      "source_file": "same_name_method.rs",
      "embedding_text": "two method with same name\n\nIt lints if a struct has two methods with the same name:\none from a trait, another not from a trait.\n\nConfusing."
    },
    {
      "id": "clippy::self_named_constructors",
      "name": "SELF_NAMED_CONSTRUCTORS",
      "snake_name": "self_named_constructors",
      "category": "style",
      "weight": 0.95,
      "brief": "method should not have the same name as the type it is implemented for",
      "what_it_does": "Warns when constructors have the same name as their types.",
      "why_bad": "Repeating the name of the type is redundant.",
      "example": "```rust,ignore\nstruct Foo {}\n\nimpl Foo {\npub fn foo() -> Foo {\nFoo {}\n}\n}\n```\nUse instead:\n```rust,ignore\nstruct Foo {}\n\nimpl Foo {\npub fn new() -> Foo {\nFoo {}\n}\n}\n```",
      "version": "1.55.0",
      "source_file": "self_named_constructors.rs",
      "embedding_text": "method should not have the same name as the type it is implemented for\n\nWarns when constructors have the same name as their types.\n\nRepeating the name of the type is redundant."
    },
    {
      "id": "clippy::semicolon_inside_block",
      "name": "SEMICOLON_INSIDE_BLOCK",
      "snake_name": "semicolon_inside_block",
      "category": "restriction",
      "weight": 1.0,
      "brief": "add a semicolon inside the block",
      "what_it_does": "Suggests moving the semicolon after a block to the inside of the block, after its last\nexpression.",
      "why_bad": "For consistency it's best to have the semicolon inside/outside the block. Either way is fine\nand this lint suggests inside the block.\nTake a look at `semicolon_outside_block` for the other alternative.",
      "example": "```no_run\n# fn f(_: u32) {}\n# let x = 0;\nunsafe { f(x) };\n```\nUse instead:\n```no_run\n# fn f(_: u32) {}\n# let x = 0;\nunsafe { f(x); }\n```",
      "version": "1.68.0",
      "source_file": "semicolon_block.rs",
      "embedding_text": "add a semicolon inside the block\n\nSuggests moving the semicolon after a block to the inside of the block, after its last\nexpression.\n\nFor consistency it's best to have the semicolon inside/outside the block. Either way is fine\nand this lint suggests inside the block.\nTake a look at `semicolon_outside_block` for the other alternative."
    },
    {
      "id": "clippy::semicolon_outside_block",
      "name": "SEMICOLON_OUTSIDE_BLOCK",
      "snake_name": "semicolon_outside_block",
      "category": "restriction",
      "weight": 1.0,
      "brief": "add a semicolon outside the block",
      "what_it_does": "Suggests moving the semicolon from a block's final expression outside of the block.",
      "why_bad": "For consistency it's best to have the semicolon inside/outside the block. Either way is fine\nand this lint suggests outside the block.\nTake a look at `semicolon_inside_block` for the other alternative.",
      "example": "```no_run\n# fn f(_: u32) {}\n# let x = 0;\nunsafe { f(x); }\n```\nUse instead:\n```no_run\n# fn f(_: u32) {}\n# let x = 0;\nunsafe { f(x) };\n```",
      "version": "1.68.0",
      "source_file": "semicolon_block.rs",
      "embedding_text": "add a semicolon outside the block\n\nSuggests moving the semicolon from a block's final expression outside of the block.\n\nFor consistency it's best to have the semicolon inside/outside the block. Either way is fine\nand this lint suggests outside the block.\nTake a look at `semicolon_inside_block` for the other alternative."
    },
    {
      "id": "clippy::semicolon_if_nothing_returned",
      "name": "SEMICOLON_IF_NOTHING_RETURNED",
      "snake_name": "semicolon_if_nothing_returned",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "add a semicolon if nothing is returned",
      "what_it_does": "Looks for blocks of expressions and fires if the last expression returns\n`()` but is not followed by a semicolon.",
      "why_bad": "The semicolon might be optional but when extending the block with new\ncode, it doesn't require a change in previous last line.",
      "example": "```no_run\nfn main() {\nprintln!(\"Hello world\")\n}\n```\nUse instead:\n```no_run\nfn main() {\nprintln!(\"Hello world\");\n}\n```",
      "version": "1.52.0",
      "source_file": "semicolon_if_nothing_returned.rs",
      "embedding_text": "add a semicolon if nothing is returned\n\nLooks for blocks of expressions and fires if the last expression returns\n`()` but is not followed by a semicolon.\n\nThe semicolon might be optional but when extending the block with new\ncode, it doesn't require a change in previous last line."
    },
    {
      "id": "clippy::serde_api_misuse",
      "name": "SERDE_API_MISUSE",
      "snake_name": "serde_api_misuse",
      "category": "correctness",
      "weight": 1.2,
      "brief": "various things that will negatively affect your serde experience",
      "what_it_does": "Checks for misuses of the serde API.",
      "why_bad": "Serde is very finicky about how its API should be\nused, but the type system can't be used to enforce it (yet?).",
      "example": "Implementing `Visitor::visit_string` but not\n`Visitor::visit_str`.",
      "version": "pre 1.29.0",
      "source_file": "serde_api.rs",
      "embedding_text": "various things that will negatively affect your serde experience\n\nChecks for misuses of the serde API.\n\nSerde is very finicky about how its API should be\nused, but the type system can't be used to enforce it (yet?)."
    },
    {
      "id": "clippy::set_contains_or_insert",
      "name": "SET_CONTAINS_OR_INSERT",
      "snake_name": "set_contains_or_insert",
      "category": "nursery",
      "weight": 0.9,
      "brief": "call to `<set>::contains` followed by `<set>::insert`",
      "what_it_does": "Checks for usage of `contains` to see if a value is not present\nin a set like `HashSet` or `BTreeSet`, followed by an `insert`.",
      "why_bad": "Using just `insert` and checking the returned `bool` is more efficient.",
      "example": "```rust\nuse std::collections::HashSet;\nlet mut set = HashSet::new();\nlet value = 5;\nif !set.contains(&value) {\nset.insert(value);\nprintln!(\"inserted {value:?}\");\n}\n```\nUse instead:\n```rust\nuse std::collections::HashSet;\nlet mut set = HashSet::new();\nlet value = 5;\nif set.insert(&value) {\nprintln!(\"inserted {value:?}\");\n}\n```",
      "version": "1.81.0",
      "source_file": "set_contains_or_insert.rs",
      "embedding_text": "call to `<set>::contains` followed by `<set>::insert`\n\nChecks for usage of `contains` to see if a value is not present\nin a set like `HashSet` or `BTreeSet`, followed by an `insert`.\n\nUsing just `insert` and checking the returned `bool` is more efficient."
    },
    {
      "id": "clippy::shadow_same",
      "name": "SHADOW_SAME",
      "snake_name": "shadow_same",
      "category": "restriction",
      "weight": 1.0,
      "brief": "rebinding a name to itself, e.g., `let mut x = &mut x`",
      "what_it_does": "Checks for bindings that shadow other bindings already in\nscope, while just changing reference level or mutability.",
      "why_bad": "To require that what are formally distinct variables be given distinct names.\n\nSee also `shadow_reuse` and `shadow_unrelated` for other restrictions on shadowing.",
      "example": "```no_run\n# let x = 1;\nlet x = &x;\n```\n\nUse instead:\n```no_run\n# let x = 1;\nlet y = &x; // use different variable name\n```",
      "version": "pre 1.29.0",
      "source_file": "shadow.rs",
      "embedding_text": "rebinding a name to itself, e.g., `let mut x = &mut x`\n\nChecks for bindings that shadow other bindings already in\nscope, while just changing reference level or mutability.\n\nTo require that what are formally distinct variables be given distinct names.\n\nSee also `shadow_reuse` and `shadow_unrelated` for other restrictions on shadowing."
    },
    {
      "id": "clippy::shadow_reuse",
      "name": "SHADOW_REUSE",
      "snake_name": "shadow_reuse",
      "category": "restriction",
      "weight": 1.0,
      "brief": "rebinding a name to an expression that reuses the original value, e.g., `let x = x + 1`",
      "what_it_does": "Checks for bindings that shadow other bindings already in\nscope, while reusing the original value.",
      "why_bad": "Some argue that name shadowing like this hurts readability,\nbecause a value may be bound to different things depending on position in\nthe code.\n\nSee also `shadow_same` and `shadow_unrelated` for other restrictions on shadowing.",
      "example": "```no_run\nlet x = 2;\nlet x = x + 1;\n```\nuse different variable name:\n```no_run\nlet x = 2;\nlet y = x + 1;\n```",
      "version": "pre 1.29.0",
      "source_file": "shadow.rs",
      "embedding_text": "rebinding a name to an expression that reuses the original value, e.g., `let x = x + 1`\n\nChecks for bindings that shadow other bindings already in\nscope, while reusing the original value.\n\nSome argue that name shadowing like this hurts readability,\nbecause a value may be bound to different things depending on position in\nthe code.\n\nSee also `shadow_same` and `shadow_unrelated` for other restrictions on shadowing."
    },
    {
      "id": "clippy::shadow_unrelated",
      "name": "SHADOW_UNRELATED",
      "snake_name": "shadow_unrelated",
      "category": "restriction",
      "weight": 1.0,
      "brief": "rebinding a name without even using the original value",
      "what_it_does": "Checks for bindings that shadow other bindings already in\nscope, either without an initialization or with one that does not even use\nthe original value.",
      "why_bad": "Shadowing a binding with a closely related one is part of idiomatic Rust,\nbut shadowing a binding by accident with an unrelated one may indicate a mistake.\n\nAdditionally, name shadowing in general can hurt readability, especially in\nlarge code bases, because it is easy to lose track of the active binding at\nany place in the code. If linting against all shadowing is desired, you may wish\nto use the `shadow_same` and `shadow_reuse` lints as well.",
      "example": "```no_run\n# let y = 1;\n# let z = 2;\nlet x = y;\nlet x = z; // shadows the earlier binding\n```\n\nUse instead:\n```no_run\n# let y = 1;\n# let z = 2;\nlet x = y;\nlet w = z; // use different variable name\n```",
      "version": "pre 1.29.0",
      "source_file": "shadow.rs",
      "embedding_text": "rebinding a name without even using the original value\n\nChecks for bindings that shadow other bindings already in\nscope, either without an initialization or with one that does not even use\nthe original value.\n\nShadowing a binding with a closely related one is part of idiomatic Rust,\nbut shadowing a binding by accident with an unrelated one may indicate a mistake.\n\nAdditionally, name shadowing in general can hurt readability, especially in\nlarge code bases, because it is easy to lose track of the active binding at\nany place in the code. If linting against all shadowing is desired, you may wish\nto use the `shadow_same` and `shadow_reuse` lints as well."
    },
    {
      "id": "clippy::significant_drop_tightening",
      "name": "SIGNIFICANT_DROP_TIGHTENING",
      "snake_name": "significant_drop_tightening",
      "category": "nursery",
      "weight": 0.9,
      "brief": "Searches for elements marked with `#[clippy::has_significant_drop]` that could be early dropped but are in fact dropped at the end of their scopes",
      "what_it_does": "Searches for elements marked with `#[clippy::has_significant_drop]` that could be early\ndropped but are in fact dropped at the end of their scopes. In other words, enforces the\n\"tightening\" of their possible lifetimes.",
      "why_bad": "Elements marked with `#[clippy::has_significant_drop]` are generally synchronizing\nprimitives that manage shared resources, as such, it is desired to release them as soon as\npossible to avoid unnecessary resource contention.",
      "example": "```rust,ignore\nfn main() {\nlet lock = some_sync_resource.lock();\nlet owned_rslt = lock.do_stuff_with_resource();\n// Only `owned_rslt` is needed but `lock` is still held.\ndo_heavy_computation_that_takes_time(owned_rslt);\n}\n```\n\nUse instead:\n\n```rust,ignore\nfn main() {\nlet owned_rslt = some_sync_resource.lock().do_stuff_with_resource();\ndo_heavy_computation_that_takes_time(owned_rslt);\n}\n```",
      "version": "1.69.0",
      "source_file": "significant_drop_tightening.rs",
      "embedding_text": "Searches for elements marked with `#[clippy::has_significant_drop]` that could be early dropped but are in fact dropped at the end of their scopes\n\nSearches for elements marked with `#[clippy::has_significant_drop]` that could be early\ndropped but are in fact dropped at the end of their scopes. In other words, enforces the\n\"tightening\" of their possible lifetimes.\n\nElements marked with `#[clippy::has_significant_drop]` are generally synchronizing\nprimitives that manage shared resources, as such, it is desired to release them as soon as\npossible to avoid unnecessary resource contention."
    },
    {
      "id": "clippy::single_call_fn",
      "name": "SINGLE_CALL_FN",
      "snake_name": "single_call_fn",
      "category": "restriction",
      "weight": 1.0,
      "brief": "checks for functions that are only used once",
      "what_it_does": "Checks for functions that are only used once. Does not lint tests.",
      "why_bad": "If a function is only used once (perhaps because it used to be used more widely),\nthen the code could be simplified by moving that function's code into its caller.\n\nHowever, there are reasons not to do this everywhere:\n\n* Splitting a large function into multiple parts often improves readability\nby giving names to its parts.\n* A function\u2019s signature might serve a necessary purpose, such as constraining\nthe type of a closure passed to it.\n* Generic functions might call non-generic functions to reduce duplication\nin the produced machine code.\n\nIf this lint is used, prepare to `#[allow]` it a lot.",
      "example": "```no_run\npub fn a<T>(t: &T)\nwhere\nT: AsRef<str>,\n{\na_inner(t.as_ref())\n}\n\nfn a_inner(t: &str) {\n/* snip */\n}\n\n```\nUse instead:\n```no_run\npub fn a<T>(t: &T)\nwhere\nT: AsRef<str>,\n{\nlet t = t.as_ref();\n/* snip */\n}\n\n```",
      "version": "1.72.0",
      "source_file": "single_call_fn.rs",
      "embedding_text": "checks for functions that are only used once\n\nChecks for functions that are only used once. Does not lint tests.\n\nIf a function is only used once (perhaps because it used to be used more widely),\nthen the code could be simplified by moving that function's code into its caller.\n\nHowever, there are reasons not to do this everywhere:\n\n* Splitting a large function into multiple parts often improves readability\nby giving names to its parts.\n* A function\u2019s signature might serve a necessary purpose, such as constraining\nthe type of a closure passed to it.\n* Generic functions might call non-generic functions to reduce duplication\nin the produced machine code.\n\nIf this lint is used, prepare to `#[allow]` it a lot."
    },
    {
      "id": "clippy::single_char_lifetime_names",
      "name": "SINGLE_CHAR_LIFETIME_NAMES",
      "snake_name": "single_char_lifetime_names",
      "category": "restriction",
      "weight": 1.0,
      "brief": "warns against single-character lifetime names",
      "what_it_does": "Checks for lifetimes with names which are one character\nlong.",
      "why_bad": "A single character is likely not enough to express the\npurpose of a lifetime. Using a longer name can make code\neasier to understand.",
      "example": "```no_run\nstruct DiagnosticCtx<'a> {\nsource: &'a str,\n}\n```\nUse instead:\n```no_run\nstruct DiagnosticCtx<'src> {\nsource: &'src str,\n}\n```",
      "version": "1.60.0",
      "source_file": "single_char_lifetime_names.rs",
      "embedding_text": "warns against single-character lifetime names\n\nChecks for lifetimes with names which are one character\nlong.\n\nA single character is likely not enough to express the\npurpose of a lifetime. Using a longer name can make code\neasier to understand."
    },
    {
      "id": "clippy::single_component_path_imports",
      "name": "SINGLE_COMPONENT_PATH_IMPORTS",
      "snake_name": "single_component_path_imports",
      "category": "style",
      "weight": 0.95,
      "brief": "imports with single component path are redundant",
      "what_it_does": "Checking for imports with single component use path.",
      "why_bad": "Import with single component use path such as `use cratename;`\nis not necessary, and thus should be removed.",
      "example": "```rust,ignore\nuse regex;\n\nfn main() {\nregex::Regex::new(r\"^\\d{4}-\\d{2}-\\d{2}$\").unwrap();\n}\n```\nBetter as\n```rust,ignore\nfn main() {\nregex::Regex::new(r\"^\\d{4}-\\d{2}-\\d{2}$\").unwrap();\n}\n```",
      "version": "1.43.0",
      "source_file": "single_component_path_imports.rs",
      "embedding_text": "imports with single component path are redundant\n\nChecking for imports with single component use path.\n\nImport with single component use path such as `use cratename;`\nis not necessary, and thus should be removed."
    },
    {
      "id": "clippy::single_option_map",
      "name": "SINGLE_OPTION_MAP",
      "snake_name": "single_option_map",
      "category": "nursery",
      "weight": 0.9,
      "brief": "Checks for functions with method calls to `.map(_)` on an arg of type `Option` as the outermost expression.",
      "what_it_does": "Checks for functions with method calls to `.map(_)` on an arg\nof type `Option` as the outermost expression.",
      "why_bad": "Taking and returning an `Option<T>` may require additional\n`Some(_)` and `unwrap` if all you have is a `T`.",
      "example": "```no_run\nfn double(param: Option<u32>) -> Option<u32> {\nparam.map(|x| x * 2)\n}\n```\nUse instead:\n```no_run\nfn double(param: u32) -> u32 {\nparam * 2\n}\n```",
      "version": "1.87.0",
      "source_file": "single_option_map.rs",
      "embedding_text": "Checks for functions with method calls to `.map(_)` on an arg of type `Option` as the outermost expression.\n\nChecks for functions with method calls to `.map(_)` on an arg\nof type `Option` as the outermost expression.\n\nTaking and returning an `Option<T>` may require additional\n`Some(_)` and `unwrap` if all you have is a `T`."
    },
    {
      "id": "clippy::single_range_in_vec_init",
      "name": "SINGLE_RANGE_IN_VEC_INIT",
      "snake_name": "single_range_in_vec_init",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "checks for initialization of `Vec` or arrays which consist of a single range",
      "what_it_does": "Checks for `Vec` or array initializations that contain only one range.",
      "why_bad": "This is almost always incorrect, as it will result in a `Vec` that has only one element.\nAlmost always, the programmer intended for it to include all elements in the range or for\nthe end of the range to be the length instead.",
      "example": "```no_run\nlet x = [0..200];\n```\nUse instead:\n```no_run\n// If it was intended to include every element in the range...\nlet x = (0..200).collect::<Vec<i32>>();\n// ...Or if 200 was meant to be the len\nlet x = [0; 200];\n```",
      "version": "1.72.0",
      "source_file": "single_range_in_vec_init.rs",
      "embedding_text": "checks for initialization of `Vec` or arrays which consist of a single range\n\nChecks for `Vec` or array initializations that contain only one range.\n\nThis is almost always incorrect, as it will result in a `Vec` that has only one element.\nAlmost always, the programmer intended for it to include all elements in the range or for\nthe end of the range to be the length instead."
    },
    {
      "id": "clippy::size_of_in_element_count",
      "name": "SIZE_OF_IN_ELEMENT_COUNT",
      "snake_name": "size_of_in_element_count",
      "category": "correctness",
      "weight": 1.2,
      "brief": "using `size_of::<T>` or `size_of_val::<T>` where a count of elements of `T` is expected",
      "what_it_does": "Detects expressions where\n`size_of::<T>` or `size_of_val::<T>` is used as a\ncount of elements of type `T`",
      "why_bad": "These functions expect a count\nof `T` and not a number of bytes",
      "example": "```rust,no_run\n# use std::ptr::copy_nonoverlapping;\nconst SIZE: usize = 128;\nlet x = [2u8; SIZE];\nlet mut y = [2u8; SIZE];\nunsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>() * SIZE) };\n```",
      "version": "1.50.0",
      "source_file": "size_of_in_element_count.rs",
      "embedding_text": "using `size_of::<T>` or `size_of_val::<T>` where a count of elements of `T` is expected\n\nDetects expressions where\n`size_of::<T>` or `size_of_val::<T>` is used as a\ncount of elements of type `T`\n\nThese functions expect a count\nof `T` and not a number of bytes"
    },
    {
      "id": "clippy::size_of_ref",
      "name": "SIZE_OF_REF",
      "snake_name": "size_of_ref",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "Argument to `size_of_val()` is a double-reference, which is almost certainly unintended",
      "what_it_does": "Checks for calls to `size_of_val()` where the argument is\na reference to a reference.",
      "why_bad": "Calling `size_of_val()` with a reference to a reference as the argument\nyields the size of the reference-type, not the size of the value behind\nthe reference.",
      "example": "```no_run\nstruct Foo {\nbuffer: [u8],\n}\n\nimpl Foo {\nfn size(&self) -> usize {\n// Note that `&self` as an argument is a `&&Foo`: Because `self`\n// is already a reference, `&self` is a double-reference.\n// The return value of `size_of_val()` therefore is the\n// size of the reference-type, not the size of `self`.\nsize_of_val(&self)\n}\n}\n```\nUse instead:\n```no_run\nstruct Foo {\nbuffer: [u8],\n}\n\nimpl Foo {\nfn size(&self) -> usize {\n// Correct\nsize_of_val(self)\n}\n}\n```",
      "version": "1.68.0",
      "source_file": "size_of_ref.rs",
      "embedding_text": "Argument to `size_of_val()` is a double-reference, which is almost certainly unintended\n\nChecks for calls to `size_of_val()` where the argument is\na reference to a reference.\n\nCalling `size_of_val()` with a reference to a reference as the argument\nyields the size of the reference-type, not the size of the value behind\nthe reference."
    },
    {
      "id": "clippy::slow_vector_initialization",
      "name": "SLOW_VECTOR_INITIALIZATION",
      "snake_name": "slow_vector_initialization",
      "category": "perf",
      "weight": 1.0,
      "brief": "slow vector initialization",
      "what_it_does": "Checks slow zero-filled vector initialization",
      "why_bad": "These structures are non-idiomatic and less efficient than simply using\n`vec![0; len]`.\n\nSpecifically, for `vec![0; len]`, the compiler can use a specialized type of allocation\nthat also zero-initializes the allocated memory in the same call\n(see: [alloc_zeroed](https://doc.rust-lang.org/stable/std/alloc/trait.GlobalAlloc.html#method.alloc_zeroed)).\n\nWriting `Vec::new()` followed by `vec.resize(len, 0)` is suboptimal because,\nwhile it does do the same number of allocations,\nit involves two operations for allocating and initializing.\nThe `resize` call first allocates memory (since `Vec::new()` did not), and only *then* zero-initializes it.",
      "example": "```no_run\n# use core::iter::repeat;\n# let len = 4;\nlet mut vec1 = Vec::new();\nvec1.resize(len, 0);\n\nlet mut vec2 = Vec::with_capacity(len);\nvec2.resize(len, 0);\n\nlet mut vec3 = Vec::with_capacity(len);\nvec3.extend(repeat(0).take(len));\n```\n\nUse instead:\n```no_run\n# let len = 4;\nlet mut vec1 = vec![0; len];\nlet mut vec2 = vec![0; len];\nlet mut vec3 = vec![0; len];\n```",
      "version": "1.32.0",
      "source_file": "slow_vector_initialization.rs",
      "embedding_text": "slow vector initialization\n\nChecks slow zero-filled vector initialization\n\nThese structures are non-idiomatic and less efficient than simply using\n`vec![0; len]`.\n\nSpecifically, for `vec![0; len]`, the compiler can use a specialized type of allocation\nthat also zero-initializes the allocated memory in the same call\n(see: [alloc_zeroed](https://doc.rust-lang.org/stable/std/alloc/trait.GlobalAlloc.html#method.alloc_zeroed)).\n\nWriting `Vec::new()` followed by `vec.resize(len, 0)` is suboptimal because,\nwhile it does do the same number of allocations,\nit involves two operations for allocating and initializing.\nThe `resize` call first allocates memory (since `Vec::new()` did not), and only *then* zero-initializes it."
    },
    {
      "id": "clippy::std_instead_of_core",
      "name": "STD_INSTEAD_OF_CORE",
      "snake_name": "std_instead_of_core",
      "category": "restriction",
      "weight": 1.0,
      "brief": "type is imported from std when available in core",
      "what_it_does": "Finds items imported through `std` when available through `core`.",
      "why_bad": "Crates which have `no_std` compatibility may wish to ensure types are imported from core to ensure\ndisabling `std` does not cause the crate to fail to compile. This lint is also useful for crates\nmigrating to become `no_std` compatible.",
      "example": "```no_run\nuse std::hash::Hasher;\n```\nUse instead:\n```no_run\nuse core::hash::Hasher;\n```",
      "version": "1.64.0",
      "source_file": "std_instead_of_core.rs",
      "embedding_text": "type is imported from std when available in core\n\nFinds items imported through `std` when available through `core`.\n\nCrates which have `no_std` compatibility may wish to ensure types are imported from core to ensure\ndisabling `std` does not cause the crate to fail to compile. This lint is also useful for crates\nmigrating to become `no_std` compatible."
    },
    {
      "id": "clippy::std_instead_of_alloc",
      "name": "STD_INSTEAD_OF_ALLOC",
      "snake_name": "std_instead_of_alloc",
      "category": "restriction",
      "weight": 1.0,
      "brief": "type is imported from std when available in alloc",
      "what_it_does": "Finds items imported through `std` when available through `alloc`.",
      "why_bad": "Crates which have `no_std` compatibility and require alloc may wish to ensure types are imported from\nalloc to ensure disabling `std` does not cause the crate to fail to compile. This lint is also useful\nfor crates migrating to become `no_std` compatible.",
      "example": "```no_run\nuse std::vec::Vec;\n```\nUse instead:\n```no_run\n# extern crate alloc;\nuse alloc::vec::Vec;\n```",
      "version": "1.64.0",
      "source_file": "std_instead_of_core.rs",
      "embedding_text": "type is imported from std when available in alloc\n\nFinds items imported through `std` when available through `alloc`.\n\nCrates which have `no_std` compatibility and require alloc may wish to ensure types are imported from\nalloc to ensure disabling `std` does not cause the crate to fail to compile. This lint is also useful\nfor crates migrating to become `no_std` compatible."
    },
    {
      "id": "clippy::alloc_instead_of_core",
      "name": "ALLOC_INSTEAD_OF_CORE",
      "snake_name": "alloc_instead_of_core",
      "category": "restriction",
      "weight": 1.0,
      "brief": "type is imported from alloc when available in core",
      "what_it_does": "Finds items imported through `alloc` when available through `core`.",
      "why_bad": "Crates which have `no_std` compatibility and may optionally require alloc may wish to ensure types are\nimported from core to ensure disabling `alloc` does not cause the crate to fail to compile. This lint\nis also useful for crates migrating to become `no_std` compatible.",
      "example": "```no_run\n# extern crate alloc;\nuse alloc::slice::from_ref;\n```\nUse instead:\n```no_run\nuse core::slice::from_ref;\n```",
      "version": "1.64.0",
      "source_file": "std_instead_of_core.rs",
      "embedding_text": "type is imported from alloc when available in core\n\nFinds items imported through `alloc` when available through `core`.\n\nCrates which have `no_std` compatibility and may optionally require alloc may wish to ensure types are\nimported from core to ensure disabling `alloc` does not cause the crate to fail to compile. This lint\nis also useful for crates migrating to become `no_std` compatible."
    },
    {
      "id": "clippy::manual_pattern_char_comparison",
      "name": "MANUAL_PATTERN_CHAR_COMPARISON",
      "snake_name": "manual_pattern_char_comparison",
      "category": "style",
      "weight": 0.95,
      "brief": "manual char comparison in string patterns",
      "what_it_does": "Checks for manual `char` comparison in string patterns",
      "why_bad": "This can be written more concisely using a `char` or an array of `char`.\nThis is more readable and more optimized when comparing to only one `char`.",
      "example": "```no_run\n\"Hello World!\".trim_end_matches(|c| c == '.' || c == ',' || c == '!' || c == '?');\n```\nUse instead:\n```no_run\n\"Hello World!\".trim_end_matches(['.', ',', '!', '?']);\n```",
      "version": "1.81.0",
      "source_file": "string_patterns.rs",
      "embedding_text": "manual char comparison in string patterns\n\nChecks for manual `char` comparison in string patterns\n\nThis can be written more concisely using a `char` or an array of `char`.\nThis is more readable and more optimized when comparing to only one `char`."
    },
    {
      "id": "clippy::single_char_pattern",
      "name": "SINGLE_CHAR_PATTERN",
      "snake_name": "single_char_pattern",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "using a single-character str where a char could be used, e.g., `_.split(\\",
      "what_it_does": "Checks for string methods that receive a single-character\n`str` as an argument, e.g., `_.split(\"x\")`.",
      "why_bad": "While this can make a perf difference on some systems,\nbenchmarks have proven inconclusive. But at least using a\nchar literal makes it clear that we are looking at a single\ncharacter.",
      "example": "```rust,ignore\n_.split(\"x\");\n```\n\nUse instead:\n```rust,ignore\n_.split('x');\n```",
      "version": "pre 1.29.0",
      "source_file": "string_patterns.rs",
      "embedding_text": "using a single-character str where a char could be used, e.g., `_.split(\\\n\nChecks for string methods that receive a single-character\n`str` as an argument, e.g., `_.split(\"x\")`.\n\nWhile this can make a perf difference on some systems,\nbenchmarks have proven inconclusive. But at least using a\nchar literal makes it clear that we are looking at a single\ncharacter."
    },
    {
      "id": "clippy::string_add_assign",
      "name": "STRING_ADD_ASSIGN",
      "snake_name": "string_add_assign",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "using `x = x + ..` where x is a `String` instead of `push_str()`",
      "what_it_does": "Checks for string appends of the form `x = x + y` (without\n`let`!).",
      "why_bad": "It's not really bad, but some people think that the\n`.push_str(_)` method is more readable.",
      "example": "```no_run\nlet mut x = \"Hello\".to_owned();\nx = x + \", World\";\n\n// More readable\nx += \", World\";\nx.push_str(\", World\");\n```",
      "version": "pre 1.29.0",
      "source_file": "strings.rs",
      "embedding_text": "using `x = x + ..` where x is a `String` instead of `push_str()`\n\nChecks for string appends of the form `x = x + y` (without\n`let`!).\n\nIt's not really bad, but some people think that the\n`.push_str(_)` method is more readable."
    },
    {
      "id": "clippy::string_add",
      "name": "STRING_ADD",
      "snake_name": "string_add",
      "category": "restriction",
      "weight": 1.0,
      "brief": "using `x + ..` where x is a `String` instead of `push_str()`",
      "what_it_does": "Checks for all instances of `x + _` where `x` is of type\n`String`, but only if [`string_add_assign`](#string_add_assign) does *not*\nmatch.",
      "why_bad": "This particular\n`Add` implementation is asymmetric (the other operand need not be `String`,\nbut `x` does), while addition as mathematically defined is symmetric, and\nthe `String::push_str(_)` function is a perfectly good replacement.\nTherefore, some dislike it and wish not to have it in their code.\n\nThat said, other people think that string addition, having a long tradition\nin other languages is actually fine, which is why we decided to make this\nparticular lint `allow` by default.",
      "example": "```no_run\nlet x = \"Hello\".to_owned();\nx + \", World\";\n```\n\nUse instead:\n```no_run\nlet mut x = \"Hello\".to_owned();\nx.push_str(\", World\");\n```",
      "version": "pre 1.29.0",
      "source_file": "strings.rs",
      "embedding_text": "using `x + ..` where x is a `String` instead of `push_str()`\n\nChecks for all instances of `x + _` where `x` is of type\n`String`, but only if [`string_add_assign`](#string_add_assign) does *not*\nmatch.\n\nThis particular\n`Add` implementation is asymmetric (the other operand need not be `String`,\nbut `x` does), while addition as mathematically defined is symmetric, and\nthe `String::push_str(_)` function is a perfectly good replacement.\nTherefore, some dislike it and wish not to have it in their code.\n\nThat said, other people think that string addition, having a long tradition\nin other languages is actually fine, which is why we decided to make this\nparticular lint `allow` by default."
    },
    {
      "id": "clippy::string_lit_as_bytes",
      "name": "STRING_LIT_AS_BYTES",
      "snake_name": "string_lit_as_bytes",
      "category": "nursery",
      "weight": 0.9,
      "brief": "calling `as_bytes` on a string literal instead of using a byte string literal",
      "what_it_does": "Checks for the `as_bytes` method called on string literals\nthat contain only ASCII characters.",
      "why_bad": "Byte string literals (e.g., `b\"foo\"`) can be used\ninstead. They are shorter but less discoverable than `as_bytes()`.",
      "example": "```no_run\nlet bstr = \"a byte string\".as_bytes();\n```\n\nUse instead:\n```no_run\nlet bstr = b\"a byte string\";\n```",
      "version": "pre 1.29.0",
      "source_file": "strings.rs",
      "embedding_text": "calling `as_bytes` on a string literal instead of using a byte string literal\n\nChecks for the `as_bytes` method called on string literals\nthat contain only ASCII characters.\n\nByte string literals (e.g., `b\"foo\"`) can be used\ninstead. They are shorter but less discoverable than `as_bytes()`."
    },
    {
      "id": "clippy::string_slice",
      "name": "STRING_SLICE",
      "snake_name": "string_slice",
      "category": "restriction",
      "weight": 1.0,
      "brief": "slicing a string",
      "what_it_does": "Checks for slice operations on strings",
      "why_bad": "UTF-8 characters span multiple bytes, and it is easy to inadvertently confuse character\ncounts and string indices. This may lead to panics, and should warrant some test cases\ncontaining wide UTF-8 characters. This lint is most useful in code that should avoid\npanics at all costs.",
      "example": "```rust,should_panic\n&\"\u00d6lkanne\"[1..];\n```",
      "version": "1.58.0",
      "source_file": "strings.rs",
      "embedding_text": "slicing a string\n\nChecks for slice operations on strings\n\nUTF-8 characters span multiple bytes, and it is easy to inadvertently confuse character\ncounts and string indices. This may lead to panics, and should warrant some test cases\ncontaining wide UTF-8 characters. This lint is most useful in code that should avoid\npanics at all costs."
    },
    {
      "id": "clippy::string_from_utf8_as_bytes",
      "name": "STRING_FROM_UTF8_AS_BYTES",
      "snake_name": "string_from_utf8_as_bytes",
      "category": "complexity",
      "weight": 1.0,
      "brief": "casting string slices to byte slices and back",
      "what_it_does": "Check if the string is transformed to byte array and casted back to string.",
      "why_bad": "It's unnecessary, the string can be used directly.",
      "example": "```no_run\nstd::str::from_utf8(&\"Hello World!\".as_bytes()[6..11]).unwrap();\n```\n\nUse instead:\n```no_run\n&\"Hello World!\"[6..11];\n```",
      "version": "1.50.0",
      "source_file": "strings.rs",
      "embedding_text": "casting string slices to byte slices and back\n\nCheck if the string is transformed to byte array and casted back to string.\n\nIt's unnecessary, the string can be used directly."
    },
    {
      "id": "clippy::str_to_string",
      "name": "STR_TO_STRING",
      "snake_name": "str_to_string",
      "category": "restriction",
      "weight": 1.0,
      "brief": "using `to_string()` on a `&str`, which should be `to_owned()`",
      "what_it_does": "This lint checks for `.to_string()` method calls on values of type `&str`.",
      "why_bad": "The `to_string` method is also used on other types to convert them to a string.\nWhen called on a `&str` it turns the `&str` into the owned variant `String`, which can be\nmore specifically expressed with `.to_owned()`.",
      "example": "```no_run\nlet _ = \"str\".to_string();\n```\nUse instead:\n```no_run\nlet _ = \"str\".to_owned();\n```",
      "version": "pre 1.29.0",
      "source_file": "strings.rs",
      "embedding_text": "using `to_string()` on a `&str`, which should be `to_owned()`\n\nThis lint checks for `.to_string()` method calls on values of type `&str`.\n\nThe `to_string` method is also used on other types to convert them to a string.\nWhen called on a `&str` it turns the `&str` into the owned variant `String`, which can be\nmore specifically expressed with `.to_owned()`."
    },
    {
      "id": "clippy::trim_split_whitespace",
      "name": "TRIM_SPLIT_WHITESPACE",
      "snake_name": "trim_split_whitespace",
      "category": "style",
      "weight": 0.95,
      "brief": "using `str::trim()` or alike before `str::split_whitespace`",
      "what_it_does": "Warns about calling `str::trim` (or variants) before `str::split_whitespace`.",
      "why_bad": "`split_whitespace` already ignores leading and trailing whitespace.",
      "example": "```no_run\n\" A B C \".trim().split_whitespace();\n```\nUse instead:\n```no_run\n\" A B C \".split_whitespace();\n```",
      "version": "1.62.0",
      "source_file": "strings.rs",
      "embedding_text": "using `str::trim()` or alike before `str::split_whitespace`\n\nWarns about calling `str::trim` (or variants) before `str::split_whitespace`.\n\n`split_whitespace` already ignores leading and trailing whitespace."
    },
    {
      "id": "clippy::strlen_on_c_strings",
      "name": "STRLEN_ON_C_STRINGS",
      "snake_name": "strlen_on_c_strings",
      "category": "complexity",
      "weight": 1.0,
      "brief": "using `libc::strlen` on a `CString` or `CStr` value, while `as_bytes().len()` or `to_bytes().len()` respectively can be used instead",
      "what_it_does": "Checks for usage of `libc::strlen` on a `CString` or `CStr` value,\nand suggest calling `as_bytes().len()` or `to_bytes().len()` respectively instead.",
      "why_bad": "libc::strlen is an unsafe function, which we don't need to call\nif all we want to know is the length of the c-string.",
      "example": "```rust, ignore\nuse std::ffi::CString;\nlet cstring = CString::new(\"foo\").expect(\"CString::new failed\");\nlet len = unsafe { libc::strlen(cstring.as_ptr()) };\n```\nUse instead:\n```rust, no_run\nuse std::ffi::CString;\nlet cstring = CString::new(\"foo\").expect(\"CString::new failed\");\nlet len = cstring.as_bytes().len();\n```",
      "version": "1.55.0",
      "source_file": "strlen_on_c_strings.rs",
      "embedding_text": "using `libc::strlen` on a `CString` or `CStr` value, while `as_bytes().len()` or `to_bytes().len()` respectively can be used instead\n\nChecks for usage of `libc::strlen` on a `CString` or `CStr` value,\nand suggest calling `as_bytes().len()` or `to_bytes().len()` respectively instead.\n\nlibc::strlen is an unsafe function, which we don't need to call\nif all we want to know is the length of the c-string."
    },
    {
      "id": "clippy::suspicious_operation_groupings",
      "name": "SUSPICIOUS_OPERATION_GROUPINGS",
      "snake_name": "suspicious_operation_groupings",
      "category": "nursery",
      "weight": 0.9,
      "brief": "groupings of binary operations that look suspiciously like typos",
      "what_it_does": "Checks for unlikely usages of binary operators that are almost\ncertainly typos and/or copy/paste errors, given the other usages\nof binary operators nearby.",
      "why_bad": "They are probably bugs and if they aren't then they look like bugs\nand you should add a comment explaining why you are doing such an\nodd set of operations.",
      "example": "```no_run\nstruct Vec3 {\nx: f64,\ny: f64,\nz: f64,\n}\n\nimpl Eq for Vec3 {}\n\nimpl PartialEq for Vec3 {\nfn eq(&self, other: &Self) -> bool {\n// This should trigger the lint because `self.x` is compared to `other.y`\nself.x == other.y && self.y == other.y && self.z == other.z\n}\n}\n```\nUse instead:\n```no_run\n# struct Vec3 {\n#     x: f64,\n#     y: f64,\n#     z: f64,\n# }\n// same as above except:\nimpl PartialEq for Vec3 {\nfn eq(&self, other: &Self) -> bool {\n// Note we now compare other.x to self.x\nself.x == other.x && self.y == other.y && self.z == other.z\n}\n}\n```",
      "version": "1.50.0",
      "source_file": "suspicious_operation_groupings.rs",
      "embedding_text": "groupings of binary operations that look suspiciously like typos\n\nChecks for unlikely usages of binary operators that are almost\ncertainly typos and/or copy/paste errors, given the other usages\nof binary operators nearby.\n\nThey are probably bugs and if they aren't then they look like bugs\nand you should add a comment explaining why you are doing such an\nodd set of operations."
    },
    {
      "id": "clippy::suspicious_arithmetic_impl",
      "name": "SUSPICIOUS_ARITHMETIC_IMPL",
      "snake_name": "suspicious_arithmetic_impl",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "suspicious use of operators in impl of arithmetic trait",
      "what_it_does": "Lints for suspicious operations in impls of arithmetic operators, e.g.\nsubtracting elements in an Add impl.",
      "why_bad": "This is probably a typo or copy-and-paste error and not intended.",
      "example": "```ignore\nimpl Add for Foo {\ntype Output = Foo;\n\nfn add(self, other: Foo) -> Foo {\nFoo(self.0 - other.0)\n}\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "suspicious_trait_impl.rs",
      "embedding_text": "suspicious use of operators in impl of arithmetic trait\n\nLints for suspicious operations in impls of arithmetic operators, e.g.\nsubtracting elements in an Add impl.\n\nThis is probably a typo or copy-and-paste error and not intended."
    },
    {
      "id": "clippy::suspicious_op_assign_impl",
      "name": "SUSPICIOUS_OP_ASSIGN_IMPL",
      "snake_name": "suspicious_op_assign_impl",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "suspicious use of operators in impl of OpAssign trait",
      "what_it_does": "Lints for suspicious operations in impls of OpAssign, e.g.\nsubtracting elements in an AddAssign impl.",
      "why_bad": "This is probably a typo or copy-and-paste error and not intended.",
      "example": "```ignore\nimpl AddAssign for Foo {\nfn add_assign(&mut self, other: Foo) {\n*self = *self - other;\n}\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "suspicious_trait_impl.rs",
      "embedding_text": "suspicious use of operators in impl of OpAssign trait\n\nLints for suspicious operations in impls of OpAssign, e.g.\nsubtracting elements in an AddAssign impl.\n\nThis is probably a typo or copy-and-paste error and not intended."
    },
    {
      "id": "clippy::suspicious_xor_used_as_pow",
      "name": "SUSPICIOUS_XOR_USED_AS_POW",
      "snake_name": "suspicious_xor_used_as_pow",
      "category": "restriction",
      "weight": 1.0,
      "brief": "XOR (`^`) operator possibly used as exponentiation operator",
      "what_it_does": "Warns for a Bitwise XOR (`^`) operator being probably confused as a powering. It will not trigger if any of the numbers are not in decimal.",
      "why_bad": "It's most probably a typo and may lead to unexpected behaviours.",
      "example": "```no_run\nlet x = 3_i32 ^ 4_i32;\n```\nUse instead:\n```no_run\nlet x = 3_i32.pow(4);\n```",
      "version": "1.67.0",
      "source_file": "suspicious_xor_used_as_pow.rs",
      "embedding_text": "XOR (`^`) operator possibly used as exponentiation operator\n\nWarns for a Bitwise XOR (`^`) operator being probably confused as a powering. It will not trigger if any of the numbers are not in decimal.\n\nIt's most probably a typo and may lead to unexpected behaviours."
    },
    {
      "id": "clippy::manual_swap",
      "name": "MANUAL_SWAP",
      "snake_name": "manual_swap",
      "category": "complexity",
      "weight": 1.0,
      "brief": "manual swap of two variables",
      "what_it_does": "Checks for manual swapping.\n\nNote that the lint will not be emitted in const blocks, as the suggestion would not be applicable.",
      "why_bad": "The `std::mem::swap` function exposes the intent better\nwithout deinitializing or copying either variable.",
      "example": "```no_run\nlet mut a = 42;\nlet mut b = 1337;\n\nlet t = b;\nb = a;\na = t;\n```\nUse std::mem::swap():\n```no_run\nlet mut a = 1;\nlet mut b = 2;\nstd::mem::swap(&mut a, &mut b);\n```",
      "version": "pre 1.29.0",
      "source_file": "swap.rs",
      "embedding_text": "manual swap of two variables\n\nChecks for manual swapping.\n\nNote that the lint will not be emitted in const blocks, as the suggestion would not be applicable.\n\nThe `std::mem::swap` function exposes the intent better\nwithout deinitializing or copying either variable."
    },
    {
      "id": "clippy::almost_swapped",
      "name": "ALMOST_SWAPPED",
      "snake_name": "almost_swapped",
      "category": "correctness",
      "weight": 1.2,
      "brief": "`foo = bar; bar = foo` sequence",
      "what_it_does": "Checks for `foo = bar; bar = foo` sequences.",
      "why_bad": "This looks like a failed attempt to swap.",
      "example": "```no_run\n# let mut a = 1;\n# let mut b = 2;\na = b;\nb = a;\n```\nIf swapping is intended, use `swap()` instead:\n```no_run\n# let mut a = 1;\n# let mut b = 2;\nstd::mem::swap(&mut a, &mut b);\n```",
      "version": "pre 1.29.0",
      "source_file": "swap.rs",
      "embedding_text": "`foo = bar; bar = foo` sequence\n\nChecks for `foo = bar; bar = foo` sequences.\n\nThis looks like a failed attempt to swap."
    },
    {
      "id": "clippy::swap_ptr_to_ref",
      "name": "SWAP_PTR_TO_REF",
      "snake_name": "swap_ptr_to_ref",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "call to `mem::swap` using pointer derived references",
      "what_it_does": "Checks for calls to `core::mem::swap` where either parameter is derived from a pointer",
      "why_bad": "When at least one parameter to `swap` is derived from a pointer it may overlap with the\nother. This would then lead to undefined behavior.",
      "example": "```no_run\nunsafe fn swap(x: &[*mut u32], y: &[*mut u32]) {\nfor (&x, &y) in x.iter().zip(y) {\ncore::mem::swap(&mut *x, &mut *y);\n}\n}\n```\nUse instead:\n```no_run\nunsafe fn swap(x: &[*mut u32], y: &[*mut u32]) {\nfor (&x, &y) in x.iter().zip(y) {\ncore::ptr::swap(x, y);\n}\n}\n```",
      "version": "1.63.0",
      "source_file": "swap_ptr_to_ref.rs",
      "embedding_text": "call to `mem::swap` using pointer derived references\n\nChecks for calls to `core::mem::swap` where either parameter is derived from a pointer\n\nWhen at least one parameter to `swap` is derived from a pointer it may overlap with the\nother. This would then lead to undefined behavior."
    },
    {
      "id": "clippy::tabs_in_doc_comments",
      "name": "TABS_IN_DOC_COMMENTS",
      "snake_name": "tabs_in_doc_comments",
      "category": "style",
      "weight": 0.95,
      "brief": "using tabs in doc comments is not recommended",
      "what_it_does": "Checks doc comments for usage of tab characters.",
      "why_bad": "The rust style-guide promotes spaces instead of tabs for indentation.\nTo keep a consistent view on the source, also doc comments should not have tabs.\nAlso, explaining ascii-diagrams containing tabs can get displayed incorrectly when the\ndisplay settings of the author and reader differ.",
      "example": "```no_run\n///\n/// Struct to hold two strings:\n/// \t- first\t\tone\n/// \t- second\tone\npub struct DoubleString {\n///\n/// \t- First String:\n/// \t\t- needs to be inside here\nfirst_string: String,\n///\n/// \t- Second String:\n/// \t\t- needs to be inside here\nsecond_string: String,\n}\n```\n\nWill be converted to:\n```no_run\n///\n/// Struct to hold two strings:\n///     - first        one\n///     - second    one\npub struct DoubleString {\n///\n///     - First String:\n///         - needs to be inside here\nfirst_string: String,\n///\n///     - Second String:\n///         - needs to be inside here\nsecond_string: String,\n}\n```",
      "version": "1.41.0",
      "source_file": "tabs_in_doc_comments.rs",
      "embedding_text": "using tabs in doc comments is not recommended\n\nChecks doc comments for usage of tab characters.\n\nThe rust style-guide promotes spaces instead of tabs for indentation.\nTo keep a consistent view on the source, also doc comments should not have tabs.\nAlso, explaining ascii-diagrams containing tabs can get displayed incorrectly when the\ndisplay settings of the author and reader differ."
    },
    {
      "id": "clippy::temporary_assignment",
      "name": "TEMPORARY_ASSIGNMENT",
      "snake_name": "temporary_assignment",
      "category": "complexity",
      "weight": 1.0,
      "brief": "assignments to temporaries",
      "what_it_does": "Checks for construction of a structure or tuple just to\nassign a value in it.",
      "why_bad": "Readability. If the structure is only created to be\nupdated, why not write the structure you want in the first place?",
      "example": "```no_run\n(0, 0).0 = 1\n```",
      "version": "pre 1.29.0",
      "source_file": "temporary_assignment.rs",
      "embedding_text": "assignments to temporaries\n\nChecks for construction of a structure or tuple just to\nassign a value in it.\n\nReadability. If the structure is only created to be\nupdated, why not write the structure you want in the first place?"
    },
    {
      "id": "clippy::manual_instant_elapsed",
      "name": "MANUAL_INSTANT_ELAPSED",
      "snake_name": "manual_instant_elapsed",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "subtraction between `Instant::now()` and previous `Instant`",
      "what_it_does": "Lints subtraction between `Instant::now()` and another `Instant`.",
      "why_bad": "It is easy to accidentally write `prev_instant - Instant::now()`, which will always be 0ns\nas `Instant` subtraction saturates.\n\n`prev_instant.elapsed()` also more clearly signals intention.",
      "example": "```no_run\nuse std::time::Instant;\nlet prev_instant = Instant::now();\nlet duration = Instant::now() - prev_instant;\n```\nUse instead:\n```no_run\nuse std::time::Instant;\nlet prev_instant = Instant::now();\nlet duration = prev_instant.elapsed();\n```",
      "version": "1.65.0",
      "source_file": "time_subtraction.rs",
      "embedding_text": "subtraction between `Instant::now()` and previous `Instant`\n\nLints subtraction between `Instant::now()` and another `Instant`.\n\nIt is easy to accidentally write `prev_instant - Instant::now()`, which will always be 0ns\nas `Instant` subtraction saturates.\n\n`prev_instant.elapsed()` also more clearly signals intention."
    },
    {
      "id": "clippy::unchecked_time_subtraction",
      "name": "UNCHECKED_TIME_SUBTRACTION",
      "snake_name": "unchecked_time_subtraction",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "finds unchecked subtraction involving 'Duration' or 'Instant'",
      "what_it_does": "Lints subtraction between an `Instant` and a `Duration`, or between two `Duration` values.",
      "why_bad": "Unchecked subtraction could cause underflow on certain platforms, leading to\nunintentional panics.",
      "example": "```no_run\n# use std::time::{Instant, Duration};\nlet time_passed = Instant::now() - Duration::from_secs(5);\nlet dur1 = Duration::from_secs(3);\nlet dur2 = Duration::from_secs(5);\nlet diff = dur1 - dur2;\n```\n\nUse instead:\n```no_run\n# use std::time::{Instant, Duration};\nlet time_passed = Instant::now().checked_sub(Duration::from_secs(5));\nlet dur1 = Duration::from_secs(3);\nlet dur2 = Duration::from_secs(5);\nlet diff = dur1.checked_sub(dur2);\n```",
      "version": "1.67.0",
      "source_file": "time_subtraction.rs",
      "embedding_text": "finds unchecked subtraction involving 'Duration' or 'Instant'\n\nLints subtraction between an `Instant` and a `Duration`, or between two `Duration` values.\n\nUnchecked subtraction could cause underflow on certain platforms, leading to\nunintentional panics."
    },
    {
      "id": "clippy::to_digit_is_some",
      "name": "TO_DIGIT_IS_SOME",
      "snake_name": "to_digit_is_some",
      "category": "style",
      "weight": 0.95,
      "brief": "`char.is_digit()` is clearer",
      "what_it_does": "Checks for `.to_digit(..).is_some()` on `char`s.",
      "why_bad": "This is a convoluted way of checking if a `char` is a digit. It's\nmore straight forward to use the dedicated `is_digit` method.",
      "example": "```no_run\n# let c = 'c';\n# let radix = 10;\nlet is_digit = c.to_digit(radix).is_some();\n```\ncan be written as:\n```no_run\n# let c = 'c';\n# let radix = 10;\nlet is_digit = c.is_digit(radix);\n```",
      "version": "1.41.0",
      "source_file": "to_digit_is_some.rs",
      "embedding_text": "`char.is_digit()` is clearer\n\nChecks for `.to_digit(..).is_some()` on `char`s.\n\nThis is a convoluted way of checking if a `char` is a digit. It's\nmore straight forward to use the dedicated `is_digit` method."
    },
    {
      "id": "clippy::to_string_trait_impl",
      "name": "TO_STRING_TRAIT_IMPL",
      "snake_name": "to_string_trait_impl",
      "category": "style",
      "weight": 0.95,
      "brief": "check for direct implementations of `ToString`",
      "what_it_does": "Checks for direct implementations of `ToString`.",
      "why_bad": "This trait is automatically implemented for any type which implements the `Display` trait.\nAs such, `ToString` shouldn\u2019t be implemented directly: `Display` should be implemented instead,\nand you get the `ToString` implementation for free.",
      "example": "```no_run\nstruct Point {\nx: usize,\ny: usize,\n}\n\nimpl ToString for Point {\nfn to_string(&self) -> String {\nformat!(\"({}, {})\", self.x, self.y)\n}\n}\n```\nUse instead:\n```no_run\nstruct Point {\nx: usize,\ny: usize,\n}\n\nimpl std::fmt::Display for Point {\nfn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\nwrite!(f, \"({}, {})\", self.x, self.y)\n}\n}\n```",
      "version": "1.78.0",
      "source_file": "to_string_trait_impl.rs",
      "embedding_text": "check for direct implementations of `ToString`\n\nChecks for direct implementations of `ToString`.\n\nThis trait is automatically implemented for any type which implements the `Display` trait.\nAs such, `ToString` shouldn\u2019t be implemented directly: `Display` should be implemented instead,\nand you get the `ToString` implementation for free."
    },
    {
      "id": "clippy::toplevel_ref_arg",
      "name": "TOPLEVEL_REF_ARG",
      "snake_name": "toplevel_ref_arg",
      "category": "style",
      "weight": 0.95,
      "brief": "an entire binding declared as `ref`, in a function argument or a `let` statement",
      "what_it_does": "Checks for function arguments and let bindings denoted as\n`ref`.",
      "why_bad": "The `ref` declaration makes the function take an owned\nvalue, but turns the argument into a reference (which means that the value\nis destroyed when exiting the function). This adds not much value: either\ntake a reference type, or take an owned value and create references in the\nbody.\n\nFor let bindings, `let x = &foo;` is preferred over `let ref x = foo`. The\ntype of `x` is more obvious with the former.",
      "example": "```no_run\nfn foo(ref _x: u8) {}\n```\n\nUse instead:\n```no_run\nfn foo(_x: &u8) {}\n```",
      "version": "pre 1.29.0",
      "source_file": "toplevel_ref_arg.rs",
      "embedding_text": "an entire binding declared as `ref`, in a function argument or a `let` statement\n\nChecks for function arguments and let bindings denoted as\n`ref`.\n\nThe `ref` declaration makes the function take an owned\nvalue, but turns the argument into a reference (which means that the value\nis destroyed when exiting the function). This adds not much value: either\ntake a reference type, or take an owned value and create references in the\nbody.\n\nFor let bindings, `let x = &foo;` is preferred over `let ref x = foo`. The\ntype of `x` is more obvious with the former."
    },
    {
      "id": "clippy::trailing_empty_array",
      "name": "TRAILING_EMPTY_ARRAY",
      "snake_name": "trailing_empty_array",
      "category": "nursery",
      "weight": 0.9,
      "brief": "struct with a trailing zero-sized array but without `#[repr(C)]` or another `repr` attribute",
      "what_it_does": "Displays a warning when a struct with a trailing zero-sized array is declared without a `repr` attribute.",
      "why_bad": "Zero-sized arrays aren't very useful in Rust itself, so such a struct is likely being created to pass to C code or in some other situation where control over memory layout matters (for example, in conjunction with manual allocation to make it easy to compute the offset of the array). Either way, `#[repr(C)]` (or another `repr` attribute) is needed.",
      "example": "```no_run\nstruct RarelyUseful {\nsome_field: u32,\nlast: [u32; 0],\n}\n```\n\nUse instead:\n```no_run\n#[repr(C)]\nstruct MoreOftenUseful {\nsome_field: usize,\nlast: [u32; 0],\n}\n```",
      "version": "1.58.0",
      "source_file": "trailing_empty_array.rs",
      "embedding_text": "struct with a trailing zero-sized array but without `#[repr(C)]` or another `repr` attribute\n\nDisplays a warning when a struct with a trailing zero-sized array is declared without a `repr` attribute.\n\nZero-sized arrays aren't very useful in Rust itself, so such a struct is likely being created to pass to C code or in some other situation where control over memory layout matters (for example, in conjunction with manual allocation to make it easy to compute the offset of the array). Either way, `#[repr(C)]` (or another `repr` attribute) is needed."
    },
    {
      "id": "clippy::type_repetition_in_bounds",
      "name": "TYPE_REPETITION_IN_BOUNDS",
      "snake_name": "type_repetition_in_bounds",
      "category": "nursery",
      "weight": 0.9,
      "brief": "types are repeated unnecessarily in trait bounds, use `+` instead of using `T: _, T: _`",
      "what_it_does": "This lint warns about unnecessary type repetitions in trait bounds",
      "why_bad": "Repeating the type for every bound makes the code\nless readable than combining the bounds",
      "example": "```no_run\npub fn foo<T>(t: T) where T: Copy, T: Clone {}\n```\n\nUse instead:\n```no_run\npub fn foo<T>(t: T) where T: Copy + Clone {}\n```",
      "version": "1.38.0",
      "source_file": "trait_bounds.rs",
      "embedding_text": "types are repeated unnecessarily in trait bounds, use `+` instead of using `T: _, T: _`\n\nThis lint warns about unnecessary type repetitions in trait bounds\n\nRepeating the type for every bound makes the code\nless readable than combining the bounds"
    },
    {
      "id": "clippy::trait_duplication_in_bounds",
      "name": "TRAIT_DUPLICATION_IN_BOUNDS",
      "snake_name": "trait_duplication_in_bounds",
      "category": "nursery",
      "weight": 0.9,
      "brief": "check if the same trait bounds are specified more than once during a generic declaration",
      "what_it_does": "Checks for cases where generics or trait objects are being used and multiple\nsyntax specifications for trait bounds are used simultaneously.",
      "why_bad": "Duplicate bounds makes the code\nless readable than specifying them only once.",
      "example": "```no_run\nfn func<T: Clone + Default>(arg: T) where T: Clone + Default {}\n```\n\nUse instead:\n```no_run\n# mod hidden {\nfn func<T: Clone + Default>(arg: T) {}\n# }\n\n// or\n\nfn func<T>(arg: T) where T: Clone + Default {}\n```\n\n```no_run\nfn foo<T: Default + Default>(bar: T) {}\n```\nUse instead:\n```no_run\nfn foo<T: Default>(bar: T) {}\n```\n\n```no_run\nfn foo<T>(bar: T) where T: Default + Default {}\n```\nUse instead:\n```no_run\nfn foo<T>(bar: T) where T: Default {}\n```",
      "version": "1.47.0",
      "source_file": "trait_bounds.rs",
      "embedding_text": "check if the same trait bounds are specified more than once during a generic declaration\n\nChecks for cases where generics or trait objects are being used and multiple\nsyntax specifications for trait bounds are used simultaneously.\n\nDuplicate bounds makes the code\nless readable than specifying them only once."
    },
    {
      "id": "clippy::wrong_transmute",
      "name": "WRONG_TRANSMUTE",
      "snake_name": "wrong_transmute",
      "category": "correctness",
      "weight": 1.2,
      "brief": "transmutes that are confusing at best, undefined behavior at worst and always useless",
      "what_it_does": "Checks for transmutes that can't ever be correct on any\narchitecture.",
      "why_bad": "It's basically guaranteed to be undefined behavior.",
      "example": "```ignore\nlet ptr: *const T = core::intrinsics::transmute('x')\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "transmutes that are confusing at best, undefined behavior at worst and always useless\n\nChecks for transmutes that can't ever be correct on any\narchitecture.\n\nIt's basically guaranteed to be undefined behavior."
    },
    {
      "id": "clippy::useless_transmute",
      "name": "USELESS_TRANSMUTE",
      "snake_name": "useless_transmute",
      "category": "complexity",
      "weight": 1.0,
      "brief": "transmutes that have the same to and from types or could be a cast/coercion",
      "what_it_does": "Checks for transmutes to the original type of the object\nand transmutes that could be a cast.",
      "why_bad": "Readability. The code tricks people into thinking that\nsomething complex is going on.",
      "example": "```rust,ignore\ncore::intrinsics::transmute(t); // where the result type is the same as `t`'s\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "transmutes that have the same to and from types or could be a cast/coercion\n\nChecks for transmutes to the original type of the object\nand transmutes that could be a cast.\n\nReadability. The code tricks people into thinking that\nsomething complex is going on."
    },
    {
      "id": "clippy::transmutes_expressible_as_ptr_casts",
      "name": "TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS",
      "snake_name": "transmutes_expressible_as_ptr_casts",
      "category": "complexity",
      "weight": 1.0,
      "brief": "transmutes that could be a pointer cast",
      "what_it_does": "Checks for transmutes that could be a pointer cast.",
      "why_bad": "Readability. The code tricks people into thinking that\nsomething complex is going on.",
      "example": "```no_run\n# let p: *const [i32] = &[];\nunsafe { std::mem::transmute::<*const [i32], *const [u16]>(p) };\n```\nUse instead:\n```no_run\n# let p: *const [i32] = &[];\np as *const [u16];\n```",
      "version": "1.47.0",
      "source_file": "mod.rs",
      "embedding_text": "transmutes that could be a pointer cast\n\nChecks for transmutes that could be a pointer cast.\n\nReadability. The code tricks people into thinking that\nsomething complex is going on."
    },
    {
      "id": "clippy::crosspointer_transmute",
      "name": "CROSSPOINTER_TRANSMUTE",
      "snake_name": "crosspointer_transmute",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "transmutes that have to or from types that are a pointer to the other",
      "what_it_does": "Checks for transmutes between a type `T` and `*T`.",
      "why_bad": "It's easy to mistakenly transmute between a type and a\npointer to that type.",
      "example": "```rust,ignore\ncore::intrinsics::transmute(t) // where the result type is the same as\n// `*t` or `&t`'s\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "transmutes that have to or from types that are a pointer to the other\n\nChecks for transmutes between a type `T` and `*T`.\n\nIt's easy to mistakenly transmute between a type and a\npointer to that type."
    },
    {
      "id": "clippy::transmute_ptr_to_ref",
      "name": "TRANSMUTE_PTR_TO_REF",
      "snake_name": "transmute_ptr_to_ref",
      "category": "complexity",
      "weight": 1.0,
      "brief": "transmutes from a pointer to a reference type",
      "what_it_does": "Checks for transmutes from a pointer to a reference.",
      "why_bad": "This can always be rewritten with `&` and `*`.",
      "example": "```rust,ignore\nunsafe {\nlet _: &T = std::mem::transmute(p); // where p: *const T\n}\n\n// can be written:\nlet _: &T = &*p;\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "transmutes from a pointer to a reference type\n\nChecks for transmutes from a pointer to a reference.\n\nThis can always be rewritten with `&` and `*`."
    },
    {
      "id": "clippy::transmute_bytes_to_str",
      "name": "TRANSMUTE_BYTES_TO_STR",
      "snake_name": "transmute_bytes_to_str",
      "category": "complexity",
      "weight": 1.0,
      "brief": "transmutes from a `&[u8]` to a `&str`",
      "what_it_does": "Checks for transmutes from a `&[u8]` to a `&str`.",
      "why_bad": "Not every byte slice is a valid UTF-8 string.",
      "example": "```no_run\nlet b: &[u8] = &[1_u8, 2_u8];\nunsafe {\nlet _: &str = std::mem::transmute(b); // where b: &[u8]\n}\n\n// should be:\nlet _ = std::str::from_utf8(b).unwrap();\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "transmutes from a `&[u8]` to a `&str`\n\nChecks for transmutes from a `&[u8]` to a `&str`.\n\nNot every byte slice is a valid UTF-8 string."
    },
    {
      "id": "clippy::transmute_int_to_bool",
      "name": "TRANSMUTE_INT_TO_BOOL",
      "snake_name": "transmute_int_to_bool",
      "category": "complexity",
      "weight": 1.0,
      "brief": "transmutes from an integer to a `bool`",
      "what_it_does": "Checks for transmutes from an integer to a `bool`.",
      "why_bad": "This might result in an invalid in-memory representation of a `bool`.",
      "example": "```no_run\nlet x = 1_u8;\nunsafe {\nlet _: bool = std::mem::transmute(x); // where x: u8\n}\n\n// should be:\nlet _: bool = x != 0;\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "transmutes from an integer to a `bool`\n\nChecks for transmutes from an integer to a `bool`.\n\nThis might result in an invalid in-memory representation of a `bool`."
    },
    {
      "id": "clippy::transmute_int_to_non_zero",
      "name": "TRANSMUTE_INT_TO_NON_ZERO",
      "snake_name": "transmute_int_to_non_zero",
      "category": "complexity",
      "weight": 1.0,
      "brief": "transmutes from an integer to a non-zero wrapper",
      "what_it_does": "Checks for transmutes from `T` to `NonZero<T>`, and suggests the `new_unchecked`\nmethod instead.",
      "why_bad": "Transmutes work on any types and thus might cause unsoundness when those types change\nelsewhere. `new_unchecked` only works for the appropriate types instead.",
      "example": "```no_run\n# use core::num::NonZero;\nlet _: NonZero<u32> = unsafe { std::mem::transmute(123) };\n```\nUse instead:\n```no_run\n# use core::num::NonZero;\nlet _: NonZero<u32> = unsafe { NonZero::new_unchecked(123) };\n```",
      "version": "1.69.0",
      "source_file": "mod.rs",
      "embedding_text": "transmutes from an integer to a non-zero wrapper\n\nChecks for transmutes from `T` to `NonZero<T>`, and suggests the `new_unchecked`\nmethod instead.\n\nTransmutes work on any types and thus might cause unsoundness when those types change\nelsewhere. `new_unchecked` only works for the appropriate types instead."
    },
    {
      "id": "clippy::transmute_ptr_to_ptr",
      "name": "TRANSMUTE_PTR_TO_PTR",
      "snake_name": "transmute_ptr_to_ptr",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "transmutes from a pointer to a pointer / a reference to a reference",
      "what_it_does": "Checks for transmutes from a pointer to a pointer, or\nfrom a reference to a reference.",
      "why_bad": "Transmutes are dangerous, and these can instead be\nwritten as casts.",
      "example": "```no_run\nlet ptr = &1u32 as *const u32;\nunsafe {\n// pointer-to-pointer transmute\nlet _: *const f32 = std::mem::transmute(ptr);\n// ref-ref transmute\nlet _: &f32 = std::mem::transmute(&1u32);\n}\n// These can be respectively written:\nlet _ = ptr as *const f32;\nlet _ = unsafe{ &*(&1u32 as *const u32 as *const f32) };\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "transmutes from a pointer to a pointer / a reference to a reference\n\nChecks for transmutes from a pointer to a pointer, or\nfrom a reference to a reference.\n\nTransmutes are dangerous, and these can instead be\nwritten as casts."
    },
    {
      "id": "clippy::unsound_collection_transmute",
      "name": "UNSOUND_COLLECTION_TRANSMUTE",
      "snake_name": "unsound_collection_transmute",
      "category": "correctness",
      "weight": 1.2,
      "brief": "transmute between collections of layout-incompatible types",
      "what_it_does": "Checks for transmutes between collections whose\ntypes have different ABI, size or alignment.",
      "why_bad": "This is undefined behavior.",
      "example": "```no_run\n// different size, therefore likely out-of-bounds memory access\n// You absolutely do not want this in your code!\nunsafe {\nstd::mem::transmute::<_, Vec<u32>>(vec![2_u16])\n};\n```\n\nYou must always iterate, map and collect the values:\n\n```no_run\nvec![2_u16].into_iter().map(u32::from).collect::<Vec<_>>();\n```",
      "version": "1.40.0",
      "source_file": "mod.rs",
      "embedding_text": "transmute between collections of layout-incompatible types\n\nChecks for transmutes between collections whose\ntypes have different ABI, size or alignment.\n\nThis is undefined behavior."
    },
    {
      "id": "clippy::transmute_undefined_repr",
      "name": "TRANSMUTE_UNDEFINED_REPR",
      "snake_name": "transmute_undefined_repr",
      "category": "nursery",
      "weight": 0.9,
      "brief": "transmute to or from a type with an undefined representation",
      "what_it_does": "Checks for transmutes between types which do not have a representation defined relative to\neach other.",
      "why_bad": "The results of such a transmute are not defined.",
      "example": "```no_run\nstruct Foo<T>(u32, T);\nlet _ = unsafe { core::mem::transmute::<Foo<u32>, Foo<i32>>(Foo(0u32, 0u32)) };\n```\nUse instead:\n```no_run\n#[repr(C)]\nstruct Foo<T>(u32, T);\nlet _ = unsafe { core::mem::transmute::<Foo<u32>, Foo<i32>>(Foo(0u32, 0u32)) };\n```",
      "version": "1.60.0",
      "source_file": "mod.rs",
      "embedding_text": "transmute to or from a type with an undefined representation\n\nChecks for transmutes between types which do not have a representation defined relative to\neach other.\n\nThe results of such a transmute are not defined."
    },
    {
      "id": "clippy::transmuting_null",
      "name": "TRANSMUTING_NULL",
      "snake_name": "transmuting_null",
      "category": "correctness",
      "weight": 1.2,
      "brief": "transmutes from a null pointer to a reference, which is undefined behavior",
      "what_it_does": "Checks for transmute calls which would receive a null pointer.",
      "why_bad": "Transmuting a null pointer is undefined behavior.",
      "example": "```no_run\nlet null_ref: &u64 = unsafe { std::mem::transmute(0 as *const u64) };\n```",
      "version": "1.35.0",
      "source_file": "mod.rs",
      "embedding_text": "transmutes from a null pointer to a reference, which is undefined behavior\n\nChecks for transmute calls which would receive a null pointer.\n\nTransmuting a null pointer is undefined behavior."
    },
    {
      "id": "clippy::transmute_null_to_fn",
      "name": "TRANSMUTE_NULL_TO_FN",
      "snake_name": "transmute_null_to_fn",
      "category": "correctness",
      "weight": 1.2,
      "brief": "transmute results in a null function pointer, which is undefined behavior",
      "what_it_does": "Checks for null function pointer creation through transmute.",
      "why_bad": "Creating a null function pointer is undefined behavior.\n\nMore info: https://doc.rust-lang.org/nomicon/ffi.html#the-nullable-pointer-optimization",
      "example": "```no_run\nlet null_fn: fn() = unsafe { std::mem::transmute( std::ptr::null::<()>() ) };\n```\nUse instead:\n```no_run\nlet null_fn: Option<fn()> = None;\n```",
      "version": "1.68.0",
      "source_file": "mod.rs",
      "embedding_text": "transmute results in a null function pointer, which is undefined behavior\n\nChecks for null function pointer creation through transmute.\n\nCreating a null function pointer is undefined behavior.\n\nMore info: https://doc.rust-lang.org/nomicon/ffi.html#the-nullable-pointer-optimization"
    },
    {
      "id": "clippy::eager_transmute",
      "name": "EAGER_TRANSMUTE",
      "snake_name": "eager_transmute",
      "category": "correctness",
      "weight": 1.2,
      "brief": "eager evaluation of `transmute`",
      "what_it_does": "Checks for integer validity checks, followed by a transmute that is (incorrectly) evaluated\neagerly (e.g. using `bool::then_some`).",
      "why_bad": "Eager evaluation means that the `transmute` call is executed regardless of whether the condition is true or false.\nThis can introduce unsoundness and other subtle bugs.",
      "example": "Consider the following function which is meant to convert an unsigned integer to its enum equivalent via transmute.\n\n```no_run\n#[repr(u8)]\nenum Opcode {\nAdd = 0,\nSub = 1,\nMul = 2,\nDiv = 3\n}\n\nfn int_to_opcode(op: u8) -> Option<Opcode> {\n(op < 4).then_some(unsafe { std::mem::transmute(op) })\n}\n```\nThis may appear fine at first given that it checks that the `u8` is within the validity range of the enum,\n*however* the transmute is evaluated eagerly, meaning that it executes even if `op >= 4`!\n\nThis makes the function unsound, because it is possible for the caller to cause undefined behavior\n(creating an enum with an invalid bitpattern) entirely in safe code only by passing an incorrect value,\nwhich is normally only a bug that is possible in unsafe code.\n\nOne possible way in which this can go wrong practically is that the compiler sees it as:\n```rust,ignore (illustrative)\nlet temp: Foo = unsafe { std::mem::transmute(op) };\n(0 < 4).then_some(temp)\n```\nand optimizes away the `(0 < 4)` check based on the assumption that since a `Foo` was created from `op` with the validity range `0..3`,\nit is **impossible** for this condition to be false.\n\nIn short, it is possible for this function to be optimized in a way that makes it [never return `None`](https://godbolt.org/z/ocrcenevq),\neven if passed the value `4`.\n\nThis can be avoided by instead using lazy evaluation. For the example above, this should be written:\n```rust,ignore (illustrative)\nfn int_to_opcode(op: u8) -> Option<Opcode> {\n(op < 4).then(|| unsafe { std::mem::transmute(op) })\n^^^^ ^^ `bool::then` only executes the closure if the condition is true!\n}\n```",
      "version": "1.77.0",
      "source_file": "mod.rs",
      "embedding_text": "eager evaluation of `transmute`\n\nChecks for integer validity checks, followed by a transmute that is (incorrectly) evaluated\neagerly (e.g. using `bool::then_some`).\n\nEager evaluation means that the `transmute` call is executed regardless of whether the condition is true or false.\nThis can introduce unsoundness and other subtle bugs."
    },
    {
      "id": "clippy::missing_transmute_annotations",
      "name": "MISSING_TRANSMUTE_ANNOTATIONS",
      "snake_name": "missing_transmute_annotations",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "warns if a transmute call doesn't have all generics specified",
      "what_it_does": "Checks if transmute calls have all generics specified.",
      "why_bad": "If not, one or more unexpected types could be used during `transmute()`, potentially leading\nto Undefined Behavior or other problems.\n\nThis is particularly dangerous in case a seemingly innocent/unrelated change causes type\ninference to result in a different type. For example, if `transmute()` is the tail\nexpression of an `if`-branch, and the `else`-branch type changes, the compiler may silently\ninfer a different type to be returned by `transmute()`. That is because the compiler is\nfree to change the inference of a type as long as that inference is technically correct,\nregardless of the programmer's unknown expectation.\n\nBoth type-parameters, the input- and the output-type, to any `transmute()` should\nbe given explicitly: Setting the input-type explicitly avoids confusion about what the\nargument's type actually is. Setting the output-type explicitly avoids type-inference\nto infer a technically correct yet unexpected type.",
      "example": "```\n# unsafe {\nlet mut x: i32 = 0;\n// Avoid \"naked\" calls to `transmute()`!\nx = std::mem::transmute([1u16, 2u16]);\n\n// `first_answers` is intended to transmute a slice of bool to a slice of u8.\n// But the programmer forgot to index the first element of the outer slice,\n// so we are actually transmuting from \"pointers to slices\" instead of\n// transmuting from \"a slice of bool\", causing a nonsensical result.\nlet the_answers: &[&[bool]] = &[&[true, false, true]];\nlet first_answers: &[u8] = std::mem::transmute(the_answers);\n# }\n```\nUse instead:\n```\n# unsafe {\nlet x = std::mem::transmute::<[u16; 2], i32>([1u16, 2u16]);\n\n// The explicit type parameters on `transmute()` makes the intention clear,\n// and cause a type-error if the actual types don't match our expectation.\nlet the_answers: &[&[bool]] = &[&[true, false, true]];\nlet first_answers: &[u8] = std::mem::transmute::<&[bool], &[u8]>(the_answers[0]);\n# }\n```",
      "version": "1.79.0",
      "source_file": "mod.rs",
      "embedding_text": "warns if a transmute call doesn't have all generics specified\n\nChecks if transmute calls have all generics specified.\n\nIf not, one or more unexpected types could be used during `transmute()`, potentially leading\nto Undefined Behavior or other problems.\n\nThis is particularly dangerous in case a seemingly innocent/unrelated change causes type\ninference to result in a different type. For example, if `transmute()` is the tail\nexpression of an `if`-branch, and the `else`-branch type changes, the compiler may silently\ninfer a different type to be returned by `transmute()`. That is because the compiler is\nfree to change the inference of a type as long as that inference is technically correct,\nregardless of the programmer's unknown expectation.\n\nBoth type-parameters, the input- and the output-type, to any `transmute()` should\nbe given explicitly: Setting the input-type explicitly avoids confusion about what the\nargument's type actually is. Setting the output-type explicitly avoids type-inference\nto infer a technically correct yet unexpected type."
    },
    {
      "id": "clippy::tuple_array_conversions",
      "name": "TUPLE_ARRAY_CONVERSIONS",
      "snake_name": "tuple_array_conversions",
      "category": "nursery",
      "weight": 0.9,
      "brief": "checks for tuple<=>array conversions that are not done with `.into()`",
      "what_it_does": "Checks for tuple<=>array conversions that are not done with `.into()`.",
      "why_bad": "It may be unnecessary complexity. `.into()` works for converting tuples<=> arrays of up to\n12 elements and conveys the intent more clearly, while also leaving less room for hard to\nspot bugs!",
      "example": "```rust,ignore\nlet t1 = &[(1, 2), (3, 4)];\nlet v1: Vec<[u32; 2]> = t1.iter().map(|&(a, b)| [a, b]).collect();\n```\nUse instead:\n```rust,ignore\nlet t1 = &[(1, 2), (3, 4)];\nlet v1: Vec<[u32; 2]> = t1.iter().map(|&t| t.into()).collect();\n```",
      "version": "1.72.0",
      "source_file": "tuple_array_conversions.rs",
      "embedding_text": "checks for tuple<=>array conversions that are not done with `.into()`\n\nChecks for tuple<=>array conversions that are not done with `.into()`.\n\nIt may be unnecessary complexity. `.into()` works for converting tuples<=> arrays of up to\n12 elements and conveys the intent more clearly, while also leaving less room for hard to\nspot bugs!"
    },
    {
      "id": "clippy::box_collection",
      "name": "BOX_COLLECTION",
      "snake_name": "box_collection",
      "category": "perf",
      "weight": 1.0,
      "brief": "usage of `Box<Vec<T>>`, vector elements are already on the heap",
      "what_it_does": "Checks for usage of `Box<T>` where T is a collection such as Vec anywhere in the code.\nCheck the [Box documentation](https://doc.rust-lang.org/std/boxed/index.html) for more information.",
      "why_bad": "Collections already keeps their contents in a separate area on\nthe heap. So if you `Box` them, you just add another level of indirection\nwithout any benefit whatsoever.",
      "example": "```rust,ignore\nstruct X {\nvalues: Box<Vec<Foo>>,\n}\n```\n\nBetter:\n\n```rust,ignore\nstruct X {\nvalues: Vec<Foo>,\n}\n```",
      "version": "1.57.0",
      "source_file": "mod.rs",
      "embedding_text": "usage of `Box<Vec<T>>`, vector elements are already on the heap\n\nChecks for usage of `Box<T>` where T is a collection such as Vec anywhere in the code.\nCheck the [Box documentation](https://doc.rust-lang.org/std/boxed/index.html) for more information.\n\nCollections already keeps their contents in a separate area on\nthe heap. So if you `Box` them, you just add another level of indirection\nwithout any benefit whatsoever."
    },
    {
      "id": "clippy::vec_box",
      "name": "VEC_BOX",
      "snake_name": "vec_box",
      "category": "complexity",
      "weight": 1.0,
      "brief": "usage of `Vec<Box<T>>` where T: Sized, vector elements are already on the heap",
      "what_it_does": "Checks for usage of `Vec<Box<T>>` where T: Sized anywhere in the code.\nCheck the [Box documentation](https://doc.rust-lang.org/std/boxed/index.html) for more information.",
      "why_bad": "`Vec` already keeps its contents in a separate area on\nthe heap. So if you `Box` its contents, you just add another level of indirection.",
      "example": "```no_run\nstruct X {\nvalues: Vec<Box<i32>>,\n}\n```\n\nBetter:\n\n```no_run\nstruct X {\nvalues: Vec<i32>,\n}\n```",
      "version": "1.33.0",
      "source_file": "mod.rs",
      "embedding_text": "usage of `Vec<Box<T>>` where T: Sized, vector elements are already on the heap\n\nChecks for usage of `Vec<Box<T>>` where T: Sized anywhere in the code.\nCheck the [Box documentation](https://doc.rust-lang.org/std/boxed/index.html) for more information.\n\n`Vec` already keeps its contents in a separate area on\nthe heap. So if you `Box` its contents, you just add another level of indirection."
    },
    {
      "id": "clippy::option_option",
      "name": "OPTION_OPTION",
      "snake_name": "option_option",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "usage of `Option<Option<T>>`",
      "what_it_does": "Checks for usage of `Option<Option<_>>` in function signatures and type\ndefinitions",
      "why_bad": "`Option<_>` represents an optional value. `Option<Option<_>>`\nrepresents an optional value which itself wraps an optional. This is logically the\nsame thing as an optional value but has an unneeded extra level of wrapping.\n\nIf you have a case where `Some(Some(_))`, `Some(None)` and `None` are distinct cases,\nconsider a custom `enum` instead, with clear names for each case.",
      "example": "```no_run\nfn get_data() -> Option<Option<u32>> {\nNone\n}\n```\n\nBetter:\n\n```no_run\npub enum Contents {\nData(Vec<u8>), // Was Some(Some(Vec<u8>))\nNotYetFetched, // Was Some(None)\nNone,          // Was None\n}\n\nfn get_data() -> Contents {\nContents::None\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "usage of `Option<Option<T>>`\n\nChecks for usage of `Option<Option<_>>` in function signatures and type\ndefinitions\n\n`Option<_>` represents an optional value. `Option<Option<_>>`\nrepresents an optional value which itself wraps an optional. This is logically the\nsame thing as an optional value but has an unneeded extra level of wrapping.\n\nIf you have a case where `Some(Some(_))`, `Some(None)` and `None` are distinct cases,\nconsider a custom `enum` instead, with clear names for each case."
    },
    {
      "id": "clippy::linkedlist",
      "name": "LINKEDLIST",
      "snake_name": "linkedlist",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "usage of LinkedList, usually a vector is faster, or a more specialized data structure like a `VecDeque`",
      "what_it_does": "Checks for usage of any `LinkedList`, suggesting to use a\n`Vec` or a `VecDeque` (formerly called `RingBuf`).",
      "why_bad": "Gankra says:\n\n> The TL;DR of `LinkedList` is that it's built on a massive amount of\npointers and indirection.\n> It wastes memory, it has terrible cache locality, and is all-around slow.\n`RingBuf`, while\n> \"only\" amortized for push/pop, should be faster in the general case for\nalmost every possible\n> workload, and isn't even amortized at all if you can predict the capacity\nyou need.\n>\n> `LinkedList`s are only really good if you're doing a lot of merging or\nsplitting of lists.\n> This is because they can just mangle some pointers instead of actually\ncopying the data. Even\n> if you're doing a lot of insertion in the middle of the list, `RingBuf`\ncan still be better\n> because of how expensive it is to seek to the middle of a `LinkedList`.",
      "example": "```no_run\n# use std::collections::LinkedList;\nlet x: LinkedList<usize> = LinkedList::new();\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "usage of LinkedList, usually a vector is faster, or a more specialized data structure like a `VecDeque`\n\nChecks for usage of any `LinkedList`, suggesting to use a\n`Vec` or a `VecDeque` (formerly called `RingBuf`).\n\nGankra says:\n\n> The TL;DR of `LinkedList` is that it's built on a massive amount of\npointers and indirection.\n> It wastes memory, it has terrible cache locality, and is all-around slow.\n`RingBuf`, while\n> \"only\" amortized for push/pop, should be faster in the general case for\nalmost every possible\n> workload, and isn't even amortized at all if you can predict the capacity\nyou need.\n>\n> `LinkedList`s are only really good if you're doing a lot of merging or\nsplitting of lists.\n> This is because they can just mangle some pointers instead of actually\ncopying the data. Even\n> if you're doing a lot of insertion in the middle of the list, `RingBuf`\ncan still be better\n> because of how expensive it is to seek to the middle of a `LinkedList`."
    },
    {
      "id": "clippy::borrowed_box",
      "name": "BORROWED_BOX",
      "snake_name": "borrowed_box",
      "category": "complexity",
      "weight": 1.0,
      "brief": "a borrow of a boxed type",
      "what_it_does": "Checks for usage of `&Box<T>` anywhere in the code.\nCheck the [Box documentation](https://doc.rust-lang.org/std/boxed/index.html) for more information.",
      "why_bad": "A `&Box<T>` parameter requires the function caller to box `T` first before passing it to a function.\nUsing `&T` defines a concrete type for the parameter and generalizes the function, this would also\nauto-deref to `&T` at the function call site if passed a `&Box<T>`.",
      "example": "```rust,ignore\nfn foo(bar: &Box<T>) { ... }\n```\n\nBetter:\n\n```rust,ignore\nfn foo(bar: &T) { ... }\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "a borrow of a boxed type\n\nChecks for usage of `&Box<T>` anywhere in the code.\nCheck the [Box documentation](https://doc.rust-lang.org/std/boxed/index.html) for more information.\n\nA `&Box<T>` parameter requires the function caller to box `T` first before passing it to a function.\nUsing `&T` defines a concrete type for the parameter and generalizes the function, this would also\nauto-deref to `&T` at the function call site if passed a `&Box<T>`."
    },
    {
      "id": "clippy::redundant_allocation",
      "name": "REDUNDANT_ALLOCATION",
      "snake_name": "redundant_allocation",
      "category": "perf",
      "weight": 1.0,
      "brief": "redundant allocation",
      "what_it_does": "Checks for usage of redundant allocations anywhere in the code.",
      "why_bad": "Expressions such as `Rc<&T>`, `Rc<Rc<T>>`, `Rc<Arc<T>>`, `Rc<Box<T>>`, `Arc<&T>`, `Arc<Rc<T>>`,\n`Arc<Arc<T>>`, `Arc<Box<T>>`, `Box<&T>`, `Box<Rc<T>>`, `Box<Arc<T>>`, `Box<Box<T>>`, add an unnecessary level of indirection.",
      "example": "```no_run\n# use std::rc::Rc;\nfn foo(bar: Rc<&usize>) {}\n```\n\nBetter:\n\n```no_run\nfn foo(bar: &usize) {}\n```",
      "version": "1.44.0",
      "source_file": "mod.rs",
      "embedding_text": "redundant allocation\n\nChecks for usage of redundant allocations anywhere in the code.\n\nExpressions such as `Rc<&T>`, `Rc<Rc<T>>`, `Rc<Arc<T>>`, `Rc<Box<T>>`, `Arc<&T>`, `Arc<Rc<T>>`,\n`Arc<Arc<T>>`, `Arc<Box<T>>`, `Box<&T>`, `Box<Rc<T>>`, `Box<Arc<T>>`, `Box<Box<T>>`, add an unnecessary level of indirection."
    },
    {
      "id": "clippy::rc_buffer",
      "name": "RC_BUFFER",
      "snake_name": "rc_buffer",
      "category": "restriction",
      "weight": 1.0,
      "brief": "shared ownership of a buffer type",
      "what_it_does": "Checks for `Rc<T>` and `Arc<T>` when `T` is a mutable buffer type such as `String` or `Vec`.",
      "why_bad": "Expressions such as `Rc<String>` usually have no advantage over `Rc<str>`, since\nit is larger and involves an extra level of indirection, and doesn't implement `Borrow<str>`.\n\nWhile mutating a buffer type would still be possible with `Rc::get_mut()`, it only\nworks if there are no additional references yet, which usually defeats the purpose of\nenclosing it in a shared ownership type. Instead, additionally wrapping the inner\ntype with an interior mutable container (such as `RefCell` or `Mutex`) would normally\nbe used.",
      "example": "```rust,ignore\n# use std::rc::Rc;\nfn foo(interned: Rc<String>) { ... }\n```\n\nBetter:\n\n```rust,ignore\nfn foo(interned: Rc<str>) { ... }\n```",
      "version": "1.48.0",
      "source_file": "mod.rs",
      "embedding_text": "shared ownership of a buffer type\n\nChecks for `Rc<T>` and `Arc<T>` when `T` is a mutable buffer type such as `String` or `Vec`.\n\nExpressions such as `Rc<String>` usually have no advantage over `Rc<str>`, since\nit is larger and involves an extra level of indirection, and doesn't implement `Borrow<str>`.\n\nWhile mutating a buffer type would still be possible with `Rc::get_mut()`, it only\nworks if there are no additional references yet, which usually defeats the purpose of\nenclosing it in a shared ownership type. Instead, additionally wrapping the inner\ntype with an interior mutable container (such as `RefCell` or `Mutex`) would normally\nbe used."
    },
    {
      "id": "clippy::type_complexity",
      "name": "TYPE_COMPLEXITY",
      "snake_name": "type_complexity",
      "category": "complexity",
      "weight": 1.0,
      "brief": "usage of very complex types that might be better factored into `type` definitions",
      "what_it_does": "Checks for types used in structs, parameters and `let`\ndeclarations above a certain complexity threshold.",
      "why_bad": "Too complex types make the code less readable. Consider\nusing a `type` definition to simplify them.",
      "example": "```no_run\n# use std::rc::Rc;\nstruct PointMatrixContainer {\nmatrix: Rc<Vec<Vec<Box<(u32, u32, u32, u32)>>>>,\n}\n\nfn main() {\nlet point_matrix: Vec<Vec<Box<(u32, u32, u32, u32)>>> = vec![\nvec![\nBox::new((1, 2, 3, 4)),\nBox::new((5, 6, 7, 8)),\n],\nvec![\nBox::new((9, 10, 11, 12)),\n],\n];\n\nlet shared_point_matrix: Rc<Vec<Vec<Box<(u32, u32, u32, u32)>>>> = Rc::new(point_matrix);\n\nlet container = PointMatrixContainer {\nmatrix: shared_point_matrix,\n};\n\n// ...\n}\n```\nUse instead:",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "usage of very complex types that might be better factored into `type` definitions\n\nChecks for types used in structs, parameters and `let`\ndeclarations above a certain complexity threshold.\n\nToo complex types make the code less readable. Consider\nusing a `type` definition to simplify them."
    },
    {
      "id": "clippy::rc_mutex",
      "name": "RC_MUTEX",
      "snake_name": "rc_mutex",
      "category": "restriction",
      "weight": 1.0,
      "brief": "usage of `Rc<Mutex<T>>`",
      "what_it_does": "Checks for `Rc<Mutex<T>>`.",
      "why_bad": "`Rc` is used in single thread and `Mutex` is used in multi thread.\nConsider using `Rc<RefCell<T>>` in single thread or `Arc<Mutex<T>>` in multi thread.",
      "example": "```rust,ignore\nuse std::rc::Rc;\nuse std::sync::Mutex;\nfn foo(interned: Rc<Mutex<i32>>) { ... }\n```\n\nBetter:\n\n```rust,ignore\nuse std::rc::Rc;\nuse std::cell::RefCell\nfn foo(interned: Rc<RefCell<i32>>) { ... }\n```",
      "version": "1.55.0",
      "source_file": "mod.rs",
      "embedding_text": "usage of `Rc<Mutex<T>>`\n\nChecks for `Rc<Mutex<T>>`.\n\n`Rc` is used in single thread and `Mutex` is used in multi thread.\nConsider using `Rc<RefCell<T>>` in single thread or `Arc<Mutex<T>>` in multi thread."
    },
    {
      "id": "clippy::owned_cow",
      "name": "OWNED_COW",
      "snake_name": "owned_cow",
      "category": "style",
      "weight": 0.95,
      "brief": "needlessly owned Cow type",
      "what_it_does": "Detects needlessly owned `Cow` types.",
      "why_bad": "The borrowed types are usually more flexible, in that e.g. a\n`Cow<'_, str>` can accept both `&str` and `String` while\n`Cow<'_, String>` can only accept `&String` and `String`. In\nparticular, `&str` is more general, because it allows for string\nliterals while `&String` can only be borrowed from a heap-owned\n`String`).",
      "example": "```no_run\nlet wrogn: std::borrow::Cow<'_, Vec<u8>>;\n```\nUse instead:\n```no_run\nlet right: std::borrow::Cow<'_, [u8]>;\n```",
      "version": "1.87.0",
      "source_file": "mod.rs",
      "embedding_text": "needlessly owned Cow type\n\nDetects needlessly owned `Cow` types.\n\nThe borrowed types are usually more flexible, in that e.g. a\n`Cow<'_, str>` can accept both `&str` and `String` while\n`Cow<'_, String>` can only accept `&String` and `String`. In\nparticular, `&str` is more general, because it allows for string\nliterals while `&String` can only be borrowed from a heap-owned\n`String`)."
    },
    {
      "id": "clippy::unconditional_recursion",
      "name": "UNCONDITIONAL_RECURSION",
      "snake_name": "unconditional_recursion",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "detect unconditional recursion in some traits implementation",
      "what_it_does": "Checks that there isn't an infinite recursion in trait\nimplementations.",
      "why_bad": "Infinite recursion in trait implementation will either cause crashes\nor result in an infinite loop, and it is hard to detect.",
      "example": "```no_run\nenum Foo {\nA,\nB,\n}\n\nimpl PartialEq for Foo {\nfn eq(&self, other: &Self) -> bool {\nself == other // bad!\n}\n}\n```\n\nUse instead:\n\n```no_run\n#[derive(PartialEq)]\nenum Foo {\nA,\nB,\n}\n```\n\nAs an alternative, rewrite the logic without recursion:\n\n```no_run\nenum Foo {\nA,\nB,\n}\n\nimpl PartialEq for Foo {\nfn eq(&self, other: &Self) -> bool {\nmatches!((self, other), (Foo::A, Foo::A) | (Foo::B, Foo::B))\n}\n}\n```",
      "version": "1.77.0",
      "source_file": "unconditional_recursion.rs",
      "embedding_text": "detect unconditional recursion in some traits implementation\n\nChecks that there isn't an infinite recursion in trait\nimplementations.\n\nInfinite recursion in trait implementation will either cause crashes\nor result in an infinite loop, and it is hard to detect."
    },
    {
      "id": "clippy::undocumented_unsafe_blocks",
      "name": "UNDOCUMENTED_UNSAFE_BLOCKS",
      "snake_name": "undocumented_unsafe_blocks",
      "category": "restriction",
      "weight": 1.0,
      "brief": "creating an unsafe block without explaining why it is safe",
      "what_it_does": "Checks for `unsafe` blocks and impls without a `// SAFETY: ` comment\nexplaining why the unsafe operations performed inside\nthe block are safe.\n\nNote the comment must appear on the line(s) preceding the unsafe block\nwith nothing appearing in between. The following is ok:\n```ignore\nfoo(\n// SAFETY:\n// This is a valid safety comment\nunsafe { *x }\n)\n```\nBut neither of these are:\n```ignore\n// SAFETY:\n// This is not a valid safety comment\nfoo(\n/* SAFETY: Neither is this */ unsafe { *x },\n);\n```",
      "why_bad": "Undocumented unsafe blocks and impls can make it difficult to read and maintain code.\nWriting out the safety justification may help in discovering unsoundness or bugs.",
      "example": "```no_run\nuse std::ptr::NonNull;\nlet a = &mut 42;\n\nlet ptr = unsafe { NonNull::new_unchecked(a) };\n```\nUse instead:\n```no_run\nuse std::ptr::NonNull;\nlet a = &mut 42;\n\n// SAFETY: references are guaranteed to be non-null.\nlet ptr = unsafe { NonNull::new_unchecked(a) };\n```",
      "version": "1.58.0",
      "source_file": "undocumented_unsafe_blocks.rs",
      "embedding_text": "creating an unsafe block without explaining why it is safe\n\nChecks for `unsafe` blocks and impls without a `// SAFETY: ` comment\nexplaining why the unsafe operations performed inside\nthe block are safe.\n\nNote the comment must appear on the line(s) preceding the unsafe block\nwith nothing appearing in between. The following is ok:\n```ignore\nfoo(\n// SAFETY:\n// This is a valid safety comment\nunsafe { *x }\n)\n```\nBut neither of these are:\n```ignore\n// SAFETY:\n// This is not a valid safety comment\nfoo(\n/* SAFETY: Neither is this */ unsafe { *x },\n);\n```\n\nUndocumented unsafe blocks and impls can make it difficult to read and maintain code.\nWriting out the safety justification may help in discovering unsoundness or bugs."
    },
    {
      "id": "clippy::unnecessary_safety_comment",
      "name": "UNNECESSARY_SAFETY_COMMENT",
      "snake_name": "unnecessary_safety_comment",
      "category": "restriction",
      "weight": 1.0,
      "brief": "annotating safe code with a safety comment",
      "what_it_does": "Checks for `// SAFETY: ` comments on safe code.",
      "why_bad": "Safe code has no safety requirements, so there is no need to\ndescribe safety invariants.",
      "example": "```no_run\nuse std::ptr::NonNull;\nlet a = &mut 42;\n\n// SAFETY: references are guaranteed to be non-null.\nlet ptr = NonNull::new(a).unwrap();\n```\nUse instead:\n```no_run\nuse std::ptr::NonNull;\nlet a = &mut 42;\n\nlet ptr = NonNull::new(a).unwrap();\n```",
      "version": "1.67.0",
      "source_file": "undocumented_unsafe_blocks.rs",
      "embedding_text": "annotating safe code with a safety comment\n\nChecks for `// SAFETY: ` comments on safe code.\n\nSafe code has no safety requirements, so there is no need to\ndescribe safety invariants."
    },
    {
      "id": "clippy::invisible_characters",
      "name": "INVISIBLE_CHARACTERS",
      "snake_name": "invisible_characters",
      "category": "correctness",
      "weight": 1.2,
      "brief": "using an invisible character in a string literal, which is confusing",
      "what_it_does": "Checks for invisible Unicode characters in the code.",
      "why_bad": "Having an invisible character in the code makes for all\nsorts of April fools, but otherwise is very much frowned upon.",
      "example": "You don't see it, but there may be a zero-width space or soft hyphen\nsome\u00adwhere in this text.",
      "version": "1.49.0",
      "source_file": "unicode.rs",
      "embedding_text": "using an invisible character in a string literal, which is confusing\n\nChecks for invisible Unicode characters in the code.\n\nHaving an invisible character in the code makes for all\nsorts of April fools, but otherwise is very much frowned upon."
    },
    {
      "id": "clippy::non_ascii_literal",
      "name": "NON_ASCII_LITERAL",
      "snake_name": "non_ascii_literal",
      "category": "restriction",
      "weight": 1.0,
      "brief": "using any literal non-ASCII chars in a string literal instead of using the `\\\\u` escape",
      "what_it_does": "Checks for non-ASCII characters in string and char literals.",
      "why_bad": "Yeah, we know, the 90's called and wanted their charset\nback. Even so, there still are editors and other programs out there that\ndon't work well with Unicode. So if the code is meant to be used\ninternationally, on multiple operating systems, or has other portability\nrequirements, activating this lint could be useful.",
      "example": "```no_run\nlet x = String::from(\"\u20ac\");\n```\n\nUse instead:\n```no_run\nlet x = String::from(\"\\u{20ac}\");\n```",
      "version": "pre 1.29.0",
      "source_file": "unicode.rs",
      "embedding_text": "using any literal non-ASCII chars in a string literal instead of using the `\\\\u` escape\n\nChecks for non-ASCII characters in string and char literals.\n\nYeah, we know, the 90's called and wanted their charset\nback. Even so, there still are editors and other programs out there that\ndon't work well with Unicode. So if the code is meant to be used\ninternationally, on multiple operating systems, or has other portability\nrequirements, activating this lint could be useful."
    },
    {
      "id": "clippy::unicode_not_nfc",
      "name": "UNICODE_NOT_NFC",
      "snake_name": "unicode_not_nfc",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "using a Unicode literal not in NFC normal form (see [Unicode tr15](http://www.unicode.org/reports/tr15/) for further information)",
      "what_it_does": "Checks for string literals that contain Unicode in a form\nthat is not equal to its\n[NFC-recomposition](http://www.unicode.org/reports/tr15/#Norm_Forms).",
      "why_bad": "If such a string is compared to another, the results\nmay be surprising.",
      "example": "You may not see it, but \"a\u0300\"\" and \"\u00e0\"\" aren't the same string. The\nformer when escaped is actually `\"a\\u{300}\"` while the latter is `\"\\u{e0}\"`.",
      "version": "pre 1.29.0",
      "source_file": "unicode.rs",
      "embedding_text": "using a Unicode literal not in NFC normal form (see [Unicode tr15](http://www.unicode.org/reports/tr15/) for further information)\n\nChecks for string literals that contain Unicode in a form\nthat is not equal to its\n[NFC-recomposition](http://www.unicode.org/reports/tr15/#Norm_Forms).\n\nIf such a string is compared to another, the results\nmay be surprising."
    },
    {
      "id": "clippy::uninhabited_references",
      "name": "UNINHABITED_REFERENCES",
      "snake_name": "uninhabited_references",
      "category": "nursery",
      "weight": 0.9,
      "brief": "reference to uninhabited type",
      "what_it_does": "It detects references to uninhabited types, such as `!` and\nwarns when those are either dereferenced or returned from a function.",
      "why_bad": "Dereferencing a reference to an uninhabited type would create\nan instance of such a type, which cannot exist. This constitutes\nundefined behaviour. Such a reference could have been created\nby `unsafe` code.",
      "example": "The following function can return a reference to an uninhabited type\n(`Infallible`) because it uses `unsafe` code to create it. However,\nthe user of such a function could dereference the return value and\ntrigger an undefined behavior from safe code.\n\n```no_run\nfn create_ref() -> &'static std::convert::Infallible {\nunsafe { std::mem::transmute(&()) }\n}\n```",
      "version": "1.76.0",
      "source_file": "uninhabited_references.rs",
      "embedding_text": "reference to uninhabited type\n\nIt detects references to uninhabited types, such as `!` and\nwarns when those are either dereferenced or returned from a function.\n\nDereferencing a reference to an uninhabited type would create\nan instance of such a type, which cannot exist. This constitutes\nundefined behaviour. Such a reference could have been created\nby `unsafe` code."
    },
    {
      "id": "clippy::uninit_vec",
      "name": "UNINIT_VEC",
      "snake_name": "uninit_vec",
      "category": "correctness",
      "weight": 1.2,
      "brief": "Vec with uninitialized data",
      "what_it_does": "Checks for `set_len()` call that creates `Vec` with uninitialized elements.\nThis is commonly caused by calling `set_len()` right after allocating or\nreserving a buffer with `new()`, `default()`, `with_capacity()`, or `reserve()`.",
      "why_bad": "It creates a `Vec` with uninitialized data, which leads to\nundefined behavior with most safe operations. Notably, uninitialized\n`Vec<u8>` must not be used with generic `Read`.\n\nMoreover, calling `set_len()` on a `Vec` created with `new()` or `default()`\ncreates out-of-bound values that lead to heap memory corruption when used.",
      "example": "```rust,ignore\nlet mut vec: Vec<u8> = Vec::with_capacity(1000);\nunsafe { vec.set_len(1000); }\nreader.read(&mut vec); // undefined behavior!\n```",
      "version": "1.58.0",
      "source_file": "uninit_vec.rs",
      "embedding_text": "Vec with uninitialized data\n\nChecks for `set_len()` call that creates `Vec` with uninitialized elements.\nThis is commonly caused by calling `set_len()` right after allocating or\nreserving a buffer with `new()`, `default()`, `with_capacity()`, or `reserve()`.\n\nIt creates a `Vec` with uninitialized data, which leads to\nundefined behavior with most safe operations. Notably, uninitialized\n`Vec<u8>` must not be used with generic `Read`.\n\nMoreover, calling `set_len()` on a `Vec` created with `new()` or `default()`\ncreates out-of-bound values that lead to heap memory corruption when used."
    },
    {
      "id": "clippy::unit_return_expecting_ord",
      "name": "UNIT_RETURN_EXPECTING_ORD",
      "snake_name": "unit_return_expecting_ord",
      "category": "correctness",
      "weight": 1.2,
      "brief": "fn arguments of type Fn(...) -> Ord returning the unit type ().",
      "what_it_does": "Checks for functions that expect closures of type\nFn(...) -> Ord where the implemented closure returns the unit type.\nThe lint also suggests to remove the semi-colon at the end of the statement if present.",
      "why_bad": "Likely, returning the unit type is unintentional, and\ncould simply be caused by an extra semi-colon. Since () implements Ord\nit doesn't cause a compilation error.\nThis is the same reasoning behind the unit_cmp lint.",
      "example": "```no_run\nlet mut twins = vec![(1, 1), (2, 2)];\ntwins.sort_by_key(|x| { x.1; });\n```",
      "version": "1.47.0",
      "source_file": "unit_return_expecting_ord.rs",
      "embedding_text": "fn arguments of type Fn(...) -> Ord returning the unit type ().\n\nChecks for functions that expect closures of type\nFn(...) -> Ord where the implemented closure returns the unit type.\nThe lint also suggests to remove the semi-colon at the end of the statement if present.\n\nLikely, returning the unit type is unintentional, and\ncould simply be caused by an extra semi-colon. Since () implements Ord\nit doesn't cause a compilation error.\nThis is the same reasoning behind the unit_cmp lint."
    },
    {
      "id": "clippy::let_unit_value",
      "name": "LET_UNIT_VALUE",
      "snake_name": "let_unit_value",
      "category": "style",
      "weight": 0.95,
      "brief": "creating a `let` binding to a value of unit type, which usually can't be used afterwards",
      "what_it_does": "Checks for binding a unit value.",
      "why_bad": "A unit value cannot usefully be used anywhere. So\nbinding one is kind of pointless.",
      "example": "```no_run\nlet x = {\n1;\n};\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "creating a `let` binding to a value of unit type, which usually can't be used afterwards\n\nChecks for binding a unit value.\n\nA unit value cannot usefully be used anywhere. So\nbinding one is kind of pointless."
    },
    {
      "id": "clippy::unit_cmp",
      "name": "UNIT_CMP",
      "snake_name": "unit_cmp",
      "category": "correctness",
      "weight": 1.2,
      "brief": "comparing unit values",
      "what_it_does": "Checks for comparisons to unit. This includes all binary\ncomparisons (like `==` and `<`) and asserts.",
      "why_bad": "Unit is always equal to itself, and thus is just a\nclumsily written constant. Mostly this happens when someone accidentally\nadds semicolons at the end of the operands.",
      "example": "```no_run\n# fn foo() {};\n# fn bar() {};\n# fn baz() {};\nif {\nfoo();\n} == {\nbar();\n} {\nbaz();\n}\n```\nis equal to\n```no_run\n# fn foo() {};\n# fn bar() {};\n# fn baz() {};\n{\nfoo();\nbar();\nbaz();\n}\n```\n\nFor asserts:\n```no_run\n# fn foo() {};\n# fn bar() {};\nassert_eq!({ foo(); }, { bar(); });\n```\nwill always succeed",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "comparing unit values\n\nChecks for comparisons to unit. This includes all binary\ncomparisons (like `==` and `<`) and asserts.\n\nUnit is always equal to itself, and thus is just a\nclumsily written constant. Mostly this happens when someone accidentally\nadds semicolons at the end of the operands."
    },
    {
      "id": "clippy::unit_arg",
      "name": "UNIT_ARG",
      "snake_name": "unit_arg",
      "category": "complexity",
      "weight": 1.0,
      "brief": "passing unit to a function",
      "what_it_does": "Checks for passing a unit value as an argument to a function without using a\nunit literal (`()`).",
      "why_bad": "This is likely the result of an accidental semicolon.",
      "example": "```rust,ignore\nfoo({\nlet a = bar();\nbaz(a);\n})\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "passing unit to a function\n\nChecks for passing a unit value as an argument to a function without using a\nunit literal (`()`).\n\nThis is likely the result of an accidental semicolon."
    },
    {
      "id": "clippy::unnecessary_box_returns",
      "name": "UNNECESSARY_BOX_RETURNS",
      "snake_name": "unnecessary_box_returns",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "Needlessly returning a Box",
      "what_it_does": "Checks for a return type containing a `Box<T>` where `T` implements `Sized`\n\nThe lint ignores `Box<T>` where `T` is larger than `unnecessary_box_size`,\nas returning a large `T` directly may be detrimental to performance.",
      "why_bad": "It's better to just return `T` in these cases. The caller may not need\nthe value to be boxed, and it's expensive to free the memory once the\n`Box<T>` been dropped.",
      "example": "```no_run\nfn foo() -> Box<String> {\nBox::new(String::from(\"Hello, world!\"))\n}\n```\nUse instead:\n```no_run\nfn foo() -> String {\nString::from(\"Hello, world!\")\n}\n```",
      "version": "1.70.0",
      "source_file": "unnecessary_box_returns.rs",
      "embedding_text": "Needlessly returning a Box\n\nChecks for a return type containing a `Box<T>` where `T` implements `Sized`\n\nThe lint ignores `Box<T>` where `T` is larger than `unnecessary_box_size`,\nas returning a large `T` directly may be detrimental to performance.\n\nIt's better to just return `T` in these cases. The caller may not need\nthe value to be boxed, and it's expensive to free the memory once the\n`Box<T>` been dropped."
    },
    {
      "id": "clippy::unnecessary_literal_bound",
      "name": "UNNECESSARY_LITERAL_BOUND",
      "snake_name": "unnecessary_literal_bound",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "detects &str that could be &'static str in function return types",
      "what_it_does": "Detects functions that are written to return `&str` that could return `&'static str` but instead return a `&'a str`.",
      "why_bad": "This leaves the caller unable to use the `&str` as `&'static str`, causing unnecessary allocations or confusion.\nThis is also most likely what you meant to write.",
      "example": "```no_run\n# struct MyType;\nimpl MyType {\nfn returns_literal(&self) -> &str {\n\"Literal\"\n}\n}\n```\nUse instead:\n```no_run\n# struct MyType;\nimpl MyType {\nfn returns_literal(&self) -> &'static str {\n\"Literal\"\n}\n}\n```\nOr, in case you may return a non-literal `str` in future:\n```no_run\n# struct MyType;\nimpl MyType {\nfn returns_literal<'a>(&'a self) -> &'a str {\n\"Literal\"\n}\n}\n```",
      "version": "1.84.0",
      "source_file": "unnecessary_literal_bound.rs",
      "embedding_text": "detects &str that could be &'static str in function return types\n\nDetects functions that are written to return `&str` that could return `&'static str` but instead return a `&'a str`.\n\nThis leaves the caller unable to use the `&str` as `&'static str`, causing unnecessary allocations or confusion.\nThis is also most likely what you meant to write."
    },
    {
      "id": "clippy::unnecessary_map_on_constructor",
      "name": "UNNECESSARY_MAP_ON_CONSTRUCTOR",
      "snake_name": "unnecessary_map_on_constructor",
      "category": "complexity",
      "weight": 1.0,
      "brief": "using `map`/`map_err` on `Option` or `Result` constructors",
      "what_it_does": "Suggests removing the use of a `map()` (or `map_err()`) method when an `Option` or `Result`\nis being constructed.",
      "why_bad": "It introduces unnecessary complexity. Instead, the function can be called before\nconstructing the `Option` or `Result` from its return value.",
      "example": "```no_run\nSome(4).map(i32::swap_bytes)\n# ;\n```\nUse instead:\n```no_run\nSome(i32::swap_bytes(4))\n# ;\n```",
      "version": "1.74.0",
      "source_file": "unnecessary_map_on_constructor.rs",
      "embedding_text": "using `map`/`map_err` on `Option` or `Result` constructors\n\nSuggests removing the use of a `map()` (or `map_err()`) method when an `Option` or `Result`\nis being constructed.\n\nIt introduces unnecessary complexity. Instead, the function can be called before\nconstructing the `Option` or `Result` from its return value."
    },
    {
      "id": "clippy::unnecessary_mut_passed",
      "name": "UNNECESSARY_MUT_PASSED",
      "snake_name": "unnecessary_mut_passed",
      "category": "style",
      "weight": 0.95,
      "brief": "an argument passed as a mutable reference although the callee only demands an immutable reference",
      "what_it_does": "Detects passing a mutable reference to a function that only\nrequires an immutable reference.",
      "why_bad": "The mutable reference rules out all other references to\nthe value. Also the code misleads about the intent of the call site.",
      "example": "```no_run\n# let mut vec = Vec::new();\n# let mut value = 5;\nvec.push(&mut value);\n```\n\nUse instead:\n```no_run\n# let mut vec = Vec::new();\n# let value = 5;\nvec.push(&value);\n```",
      "version": "pre 1.29.0",
      "source_file": "unnecessary_mut_passed.rs",
      "embedding_text": "an argument passed as a mutable reference although the callee only demands an immutable reference\n\nDetects passing a mutable reference to a function that only\nrequires an immutable reference.\n\nThe mutable reference rules out all other references to\nthe value. Also the code misleads about the intent of the call site."
    },
    {
      "id": "clippy::unnecessary_owned_empty_strings",
      "name": "UNNECESSARY_OWNED_EMPTY_STRINGS",
      "snake_name": "unnecessary_owned_empty_strings",
      "category": "style",
      "weight": 0.95,
      "brief": "detects cases of references to owned empty strings being passed as an argument to a function expecting `&str`",
      "what_it_does": "Detects cases of owned empty strings being passed as an argument to a function expecting `&str`",
      "why_bad": "This results in longer and less readable code",
      "example": "```no_run\nvec![\"1\", \"2\", \"3\"].join(&String::new());\n```\nUse instead:\n```no_run\nvec![\"1\", \"2\", \"3\"].join(\"\");\n```",
      "version": "1.62.0",
      "source_file": "unnecessary_owned_empty_strings.rs",
      "embedding_text": "detects cases of references to owned empty strings being passed as an argument to a function expecting `&str`\n\nDetects cases of owned empty strings being passed as an argument to a function expecting `&str`\n\nThis results in longer and less readable code"
    },
    {
      "id": "clippy::unnecessary_self_imports",
      "name": "UNNECESSARY_SELF_IMPORTS",
      "snake_name": "unnecessary_self_imports",
      "category": "restriction",
      "weight": 1.0,
      "brief": "imports ending in `::{self}`, which can be omitted",
      "what_it_does": "Checks for imports ending in `::{self}`.",
      "why_bad": "In most cases, this can be written much more cleanly by omitting `::{self}`.",
      "example": "```no_run\nuse std::io::{self};\n```\nUse instead:\n```no_run\nuse std::io;\n```",
      "version": "1.53.0",
      "source_file": "unnecessary_self_imports.rs",
      "embedding_text": "imports ending in `::{self}`, which can be omitted\n\nChecks for imports ending in `::{self}`.\n\nIn most cases, this can be written much more cleanly by omitting `::{self}`."
    },
    {
      "id": "clippy::unnecessary_semicolon",
      "name": "UNNECESSARY_SEMICOLON",
      "snake_name": "unnecessary_semicolon",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "unnecessary semicolon after expression returning `()`",
      "what_it_does": "Checks for the presence of a semicolon at the end of\na `match` or `if` statement evaluating to `()`.",
      "why_bad": "The semicolon is not needed, and may be removed to\navoid confusion and visual clutter.",
      "example": "```no_run\n# let a: u32 = 42;\nif a > 10 {\nprintln!(\"a is greater than 10\");\n};\n```\nUse instead:\n```no_run\n# let a: u32 = 42;\nif a > 10 {\nprintln!(\"a is greater than 10\");\n}\n```",
      "version": "1.86.0",
      "source_file": "unnecessary_semicolon.rs",
      "embedding_text": "unnecessary semicolon after expression returning `()`\n\nChecks for the presence of a semicolon at the end of\na `match` or `if` statement evaluating to `()`.\n\nThe semicolon is not needed, and may be removed to\navoid confusion and visual clutter."
    },
    {
      "id": "clippy::unnecessary_struct_initialization",
      "name": "UNNECESSARY_STRUCT_INITIALIZATION",
      "snake_name": "unnecessary_struct_initialization",
      "category": "nursery",
      "weight": 0.9,
      "brief": "struct built from a base that can be written mode concisely",
      "what_it_does": "Checks for initialization of an identical `struct` from another instance\nof the type, either by copying a base without setting any field or by\nmoving all fields individually.",
      "why_bad": "Readability suffers from unnecessary struct building.",
      "example": "```no_run\nstruct S { s: String }\n\nlet a = S { s: String::from(\"Hello, world!\") };\nlet b = S { ..a };\n```\nUse instead:\n```no_run\nstruct S { s: String }\n\nlet a = S { s: String::from(\"Hello, world!\") };\nlet b = a;\n```\n\nThe struct literal ``S { ..a }`` in the assignment to ``b`` could be replaced\nwith just ``a``.",
      "version": "1.70.0",
      "source_file": "unnecessary_struct_initialization.rs",
      "embedding_text": "struct built from a base that can be written mode concisely\n\nChecks for initialization of an identical `struct` from another instance\nof the type, either by copying a base without setting any field or by\nmoving all fields individually.\n\nReadability suffers from unnecessary struct building."
    },
    {
      "id": "clippy::unnecessary_wraps",
      "name": "UNNECESSARY_WRAPS",
      "snake_name": "unnecessary_wraps",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "functions that only return `Ok` or `Some`",
      "what_it_does": "Checks for private functions that only return `Ok` or `Some`.",
      "why_bad": "It is not meaningful to wrap values when no `None` or `Err` is returned.",
      "example": "```no_run\nfn get_cool_number(a: bool, b: bool) -> Option<i32> {\nif a && b {\nreturn Some(50);\n}\nif a {\nSome(0)\n} else {\nSome(10)\n}\n}\n```\nUse instead:\n```no_run\nfn get_cool_number(a: bool, b: bool) -> i32 {\nif a && b {\nreturn 50;\n}\nif a {\n0\n} else {\n10\n}\n}\n```",
      "version": "1.50.0",
      "source_file": "unnecessary_wraps.rs",
      "embedding_text": "functions that only return `Ok` or `Some`\n\nChecks for private functions that only return `Ok` or `Some`.\n\nIt is not meaningful to wrap values when no `None` or `Err` is returned."
    },
    {
      "id": "clippy::unneeded_struct_pattern",
      "name": "UNNEEDED_STRUCT_PATTERN",
      "snake_name": "unneeded_struct_pattern",
      "category": "style",
      "weight": 0.95,
      "brief": "using struct pattern to match against unit variant",
      "what_it_does": "Checks for struct patterns that match against unit variant.",
      "why_bad": "Struct pattern `{ }` or `{ .. }` is not needed for unit variant.",
      "example": "```no_run\nmatch Some(42) {\nSome(v) => v,\nNone { .. } => 0,\n};\n// Or\nmatch Some(42) {\nSome(v) => v,\nNone { } => 0,\n};\n```\nUse instead:\n```no_run\nmatch Some(42) {\nSome(v) => v,\nNone => 0,\n};\n```",
      "version": "1.86.0",
      "source_file": "unneeded_struct_pattern.rs",
      "embedding_text": "using struct pattern to match against unit variant\n\nChecks for struct patterns that match against unit variant.\n\nStruct pattern `{ }` or `{ .. }` is not needed for unit variant."
    },
    {
      "id": "clippy::unnested_or_patterns",
      "name": "UNNESTED_OR_PATTERNS",
      "snake_name": "unnested_or_patterns",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "unnested or-patterns, e.g., `Foo(Bar) | Foo(Baz) instead of `Foo(Bar | Baz)`",
      "what_it_does": "Checks for unnested or-patterns, e.g., `Some(0) | Some(2)` and\nsuggests replacing the pattern with a nested one, `Some(0 | 2)`.\n\nAnother way to think of this is that it rewrites patterns in\n*disjunctive normal form (DNF)* into *conjunctive normal form (CNF)*.",
      "why_bad": "In the example above, `Some` is repeated, which unnecessarily complicates the pattern.",
      "example": "```no_run\nfn main() {\nif let Some(0) | Some(2) = Some(0) {}\n}\n```\nUse instead:\n```no_run\nfn main() {\nif let Some(0 | 2) = Some(0) {}\n}\n```",
      "version": "1.46.0",
      "source_file": "unnested_or_patterns.rs",
      "embedding_text": "unnested or-patterns, e.g., `Foo(Bar) | Foo(Baz) instead of `Foo(Bar | Baz)`\n\nChecks for unnested or-patterns, e.g., `Some(0) | Some(2)` and\nsuggests replacing the pattern with a nested one, `Some(0 | 2)`.\n\nAnother way to think of this is that it rewrites patterns in\n*disjunctive normal form (DNF)* into *conjunctive normal form (CNF)*.\n\nIn the example above, `Some` is repeated, which unnecessarily complicates the pattern."
    },
    {
      "id": "clippy::unsafe_removed_from_name",
      "name": "UNSAFE_REMOVED_FROM_NAME",
      "snake_name": "unsafe_removed_from_name",
      "category": "style",
      "weight": 0.95,
      "brief": "`unsafe` removed from API names on import",
      "what_it_does": "Checks for imports that remove \"unsafe\" from an item's\nname.",
      "why_bad": "Renaming makes it less clear which traits and\nstructures are unsafe.",
      "example": "```rust,ignore\nuse std::cell::{UnsafeCell as TotallySafeCell};\n\nextern crate crossbeam;\nuse crossbeam::{spawn_unsafe as spawn};\n```",
      "version": "pre 1.29.0",
      "source_file": "unsafe_removed_from_name.rs",
      "embedding_text": "`unsafe` removed from API names on import\n\nChecks for imports that remove \"unsafe\" from an item's\nname.\n\nRenaming makes it less clear which traits and\nstructures are unsafe."
    },
    {
      "id": "clippy::unused_async",
      "name": "UNUSED_ASYNC",
      "snake_name": "unused_async",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "finds async functions with no await statements",
      "what_it_does": "Checks for functions that are declared `async` but have no `.await`s inside of them.",
      "why_bad": "Async functions with no async code create overhead, both mentally and computationally.\nCallers of async methods either need to be calling from an async function themselves or run it on an executor, both of which\ncauses runtime overhead and hassle for the caller.",
      "example": "```no_run\nasync fn get_random_number() -> i64 {\n4 // Chosen by fair dice roll. Guaranteed to be random.\n}\nlet number_future = get_random_number();\n```\n\nUse instead:\n```no_run\nfn get_random_number_improved() -> i64 {\n4 // Chosen by fair dice roll. Guaranteed to be random.\n}\nlet number_future = async { get_random_number_improved() };\n```",
      "version": "1.54.0",
      "source_file": "unused_async.rs",
      "embedding_text": "finds async functions with no await statements\n\nChecks for functions that are declared `async` but have no `.await`s inside of them.\n\nAsync functions with no async code create overhead, both mentally and computationally.\nCallers of async methods either need to be calling from an async function themselves or run it on an executor, both of which\ncauses runtime overhead and hassle for the caller."
    },
    {
      "id": "clippy::unused_io_amount",
      "name": "UNUSED_IO_AMOUNT",
      "snake_name": "unused_io_amount",
      "category": "correctness",
      "weight": 1.2,
      "brief": "unused written/read amount",
      "what_it_does": "Checks for unused written/read amount.",
      "why_bad": "`io::Write::write(_vectored)` and\n`io::Read::read(_vectored)` are not guaranteed to\nprocess the entire buffer. They return how many bytes were processed, which\nmight be smaller\nthan a given buffer's length. If you don't need to deal with\npartial-write/read, use\n`write_all`/`read_exact` instead.\n\nWhen working with asynchronous code (either with the `futures`\ncrate or with `tokio`), a similar issue exists for\n`AsyncWriteExt::write()` and `AsyncReadExt::read()` : these\nfunctions are also not guaranteed to process the entire\nbuffer.  Your code should either handle partial-writes/reads, or\ncall the `write_all`/`read_exact` methods on those traits instead.",
      "example": "```rust,ignore\nuse std::io;\nfn foo<W: io::Write>(w: &mut W) -> io::Result<()> {\nw.write(b\"foo\")?;\nOk(())\n}\n```\nUse instead:\n```rust,ignore\nuse std::io;\nfn foo<W: io::Write>(w: &mut W) -> io::Result<()> {\nw.write_all(b\"foo\")?;\nOk(())\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "unused_io_amount.rs",
      "embedding_text": "unused written/read amount\n\nChecks for unused written/read amount.\n\n`io::Write::write(_vectored)` and\n`io::Read::read(_vectored)` are not guaranteed to\nprocess the entire buffer. They return how many bytes were processed, which\nmight be smaller\nthan a given buffer's length. If you don't need to deal with\npartial-write/read, use\n`write_all`/`read_exact` instead.\n\nWhen working with asynchronous code (either with the `futures`\ncrate or with `tokio`), a similar issue exists for\n`AsyncWriteExt::write()` and `AsyncReadExt::read()` : these\nfunctions are also not guaranteed to process the entire\nbuffer.  Your code should either handle partial-writes/reads, or\ncall the `write_all`/`read_exact` methods on those traits instead."
    },
    {
      "id": "clippy::unused_peekable",
      "name": "UNUSED_PEEKABLE",
      "snake_name": "unused_peekable",
      "category": "nursery",
      "weight": 0.9,
      "brief": "creating a peekable iterator without using any of its methods",
      "what_it_does": "Checks for the creation of a `peekable` iterator that is never `.peek()`ed",
      "why_bad": "Creating a peekable iterator without using any of its methods is likely a mistake,\nor just a leftover after a refactor.",
      "example": "```no_run\nlet collection = vec![1, 2, 3];\nlet iter = collection.iter().peekable();\n\nfor item in iter {\n// ...\n}\n```\n\nUse instead:\n```no_run\nlet collection = vec![1, 2, 3];\nlet iter = collection.iter();\n\nfor item in iter {\n// ...\n}\n```",
      "version": "1.65.0",
      "source_file": "unused_peekable.rs",
      "embedding_text": "creating a peekable iterator without using any of its methods\n\nChecks for the creation of a `peekable` iterator that is never `.peek()`ed\n\nCreating a peekable iterator without using any of its methods is likely a mistake,\nor just a leftover after a refactor."
    },
    {
      "id": "clippy::unused_result_ok",
      "name": "UNUSED_RESULT_OK",
      "snake_name": "unused_result_ok",
      "category": "restriction",
      "weight": 1.0,
      "brief": "Use of `.ok()` to silence `Result`'s `#[must_use]` is misleading. Use `let _ =` instead.",
      "what_it_does": "Checks for calls to `Result::ok()` without using the returned `Option`.",
      "why_bad": "Using `Result::ok()` may look like the result is checked like `unwrap` or `expect` would do\nbut it only silences the warning caused by `#[must_use]` on the `Result`.",
      "example": "```no_run\n# fn some_function() -> Result<(), ()> { Ok(()) }\nsome_function().ok();\n```\nUse instead:\n```no_run\n# fn some_function() -> Result<(), ()> { Ok(()) }\nlet _ = some_function();\n```",
      "version": "1.82.0",
      "source_file": "unused_result_ok.rs",
      "embedding_text": "Use of `.ok()` to silence `Result`'s `#[must_use]` is misleading. Use `let _ =` instead.\n\nChecks for calls to `Result::ok()` without using the returned `Option`.\n\nUsing `Result::ok()` may look like the result is checked like `unwrap` or `expect` would do\nbut it only silences the warning caused by `#[must_use]` on the `Result`."
    },
    {
      "id": "clippy::unused_rounding",
      "name": "UNUSED_ROUNDING",
      "snake_name": "unused_rounding",
      "category": "nursery",
      "weight": 0.9,
      "brief": "Uselessly rounding a whole number floating-point literal",
      "what_it_does": "Detects cases where a whole-number literal float is being rounded, using\nthe `floor`, `ceil`, or `round` methods.",
      "why_bad": "This is unnecessary and confusing to the reader. Doing this is probably a mistake.",
      "example": "```no_run\nlet x = 1f32.ceil();\n```\nUse instead:\n```no_run\nlet x = 1f32;\n```",
      "version": "1.63.0",
      "source_file": "unused_rounding.rs",
      "embedding_text": "Uselessly rounding a whole number floating-point literal\n\nDetects cases where a whole-number literal float is being rounded, using\nthe `floor`, `ceil`, or `round` methods.\n\nThis is unnecessary and confusing to the reader. Doing this is probably a mistake."
    },
    {
      "id": "clippy::unused_self",
      "name": "UNUSED_SELF",
      "snake_name": "unused_self",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "methods that contain a `self` argument but don't use it",
      "what_it_does": "Checks methods that contain a `self` argument but don't use it",
      "why_bad": "It may be clearer to define the method as an associated function instead\nof an instance method if it doesn't require `self`.",
      "example": "```rust,ignore\nstruct A;\nimpl A {\nfn method(&self) {}\n}\n```\n\nCould be written:\n\n```rust,ignore\nstruct A;\nimpl A {\nfn method() {}\n}\n```",
      "version": "1.40.0",
      "source_file": "unused_self.rs",
      "embedding_text": "methods that contain a `self` argument but don't use it\n\nChecks methods that contain a `self` argument but don't use it\n\nIt may be clearer to define the method as an associated function instead\nof an instance method if it doesn't require `self`."
    },
    {
      "id": "clippy::unused_trait_names",
      "name": "UNUSED_TRAIT_NAMES",
      "snake_name": "unused_trait_names",
      "category": "restriction",
      "weight": 1.0,
      "brief": "use items that import a trait but only use it anonymously",
      "what_it_does": "Checks for `use Trait` where the Trait is only used for its methods and not referenced by a path directly.",
      "why_bad": "Traits imported that aren't used directly can be imported anonymously with `use Trait as _`.\nIt is more explicit, avoids polluting the current scope with unused names and can be useful to show which imports are required for traits.",
      "example": "```no_run\nuse std::fmt::Write;\n\nfn main() {\nlet mut s = String::new();\nlet _ = write!(s, \"hello, world!\");\nprintln!(\"{s}\");\n}\n```\nUse instead:\n```no_run\nuse std::fmt::Write as _;\n\nfn main() {\nlet mut s = String::new();\nlet _ = write!(s, \"hello, world!\");\nprintln!(\"{s}\");\n}\n```",
      "version": "1.83.0",
      "source_file": "unused_trait_names.rs",
      "embedding_text": "use items that import a trait but only use it anonymously\n\nChecks for `use Trait` where the Trait is only used for its methods and not referenced by a path directly.\n\nTraits imported that aren't used directly can be imported anonymously with `use Trait as _`.\nIt is more explicit, avoids polluting the current scope with unused names and can be useful to show which imports are required for traits."
    },
    {
      "id": "clippy::unused_unit",
      "name": "UNUSED_UNIT",
      "snake_name": "unused_unit",
      "category": "style",
      "weight": 0.95,
      "brief": "needless unit expression",
      "what_it_does": "Checks for unit (`()`) expressions that can be removed.",
      "why_bad": "Such expressions add no value, but can make the code\nless readable. Depending on formatting they can make a `break` or `return`\nstatement look like a function call.",
      "example": "```no_run\nfn return_unit() -> () {\n()\n}\n```\nis equivalent to\n```no_run\nfn return_unit() {}\n```",
      "version": "1.31.0",
      "source_file": "unused_unit.rs",
      "embedding_text": "needless unit expression\n\nChecks for unit (`()`) expressions that can be removed.\n\nSuch expressions add no value, but can make the code\nless readable. Depending on formatting they can make a `break` or `return`\nstatement look like a function call."
    },
    {
      "id": "clippy::unnecessary_unwrap",
      "name": "UNNECESSARY_UNWRAP",
      "snake_name": "unnecessary_unwrap",
      "category": "complexity",
      "weight": 1.0,
      "brief": "checks for calls of `unwrap[_err]()` that cannot fail",
      "what_it_does": "Checks for calls of `unwrap[_err]()` that cannot fail.",
      "why_bad": "Using `if let` or `match` is more idiomatic.",
      "example": "```no_run\n# let option = Some(0);\n# fn do_something_with(_x: usize) {}\nif option.is_some() {\ndo_something_with(option.unwrap())\n}\n```\n\nCould be written:\n\n```no_run\n# let option = Some(0);\n# fn do_something_with(_x: usize) {}\nif let Some(value) = option {\ndo_something_with(value)\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "unwrap.rs",
      "embedding_text": "checks for calls of `unwrap[_err]()` that cannot fail\n\nChecks for calls of `unwrap[_err]()` that cannot fail.\n\nUsing `if let` or `match` is more idiomatic."
    },
    {
      "id": "clippy::panicking_unwrap",
      "name": "PANICKING_UNWRAP",
      "snake_name": "panicking_unwrap",
      "category": "correctness",
      "weight": 1.2,
      "brief": "checks for calls of `unwrap[_err]()` that will always fail",
      "what_it_does": "Checks for calls of `unwrap[_err]()` that will always fail.",
      "why_bad": "If panicking is desired, an explicit `panic!()` should be used.",
      "example": "```no_run\n# let option = Some(0);\n# fn do_something_with(_x: usize) {}\nif option.is_none() {\ndo_something_with(option.unwrap())\n}\n```\n\nThis code will always panic. The if condition should probably be inverted.",
      "version": "pre 1.29.0",
      "source_file": "unwrap.rs",
      "embedding_text": "checks for calls of `unwrap[_err]()` that will always fail\n\nChecks for calls of `unwrap[_err]()` that will always fail.\n\nIf panicking is desired, an explicit `panic!()` should be used."
    },
    {
      "id": "clippy::unwrap_in_result",
      "name": "UNWRAP_IN_RESULT",
      "snake_name": "unwrap_in_result",
      "category": "restriction",
      "weight": 1.0,
      "brief": "functions of type `Result<..>` or `Option`<...> that contain `expect()` or `unwrap()`",
      "what_it_does": "Checks for functions of type `Result` that contain `expect()` or `unwrap()`",
      "why_bad": "These functions promote recoverable errors to non-recoverable errors,\nwhich may be undesirable in code bases which wish to avoid panics,\nor be a bug in the specific function.",
      "example": "Before:\n```no_run\nfn divisible_by_3(i_str: String) -> Result<(), String> {\nlet i = i_str\n.parse::<i32>()\n.expect(\"cannot divide the input by three\");\n\nif i % 3 != 0 {\nErr(\"Number is not divisible by 3\")?\n}\n\nOk(())\n}\n```\n\nAfter:\n```no_run\nfn divisible_by_3(i_str: String) -> Result<(), String> {\nlet i = i_str\n.parse::<i32>()\n.map_err(|e| format!(\"cannot divide the input by three: {}\", e))?;\n\nif i % 3 != 0 {\nErr(\"Number is not divisible by 3\")?\n}\n\nOk(())\n}\n```",
      "version": "1.48.0",
      "source_file": "unwrap_in_result.rs",
      "embedding_text": "functions of type `Result<..>` or `Option`<...> that contain `expect()` or `unwrap()`\n\nChecks for functions of type `Result` that contain `expect()` or `unwrap()`\n\nThese functions promote recoverable errors to non-recoverable errors,\nwhich may be undesirable in code bases which wish to avoid panics,\nor be a bug in the specific function."
    },
    {
      "id": "clippy::upper_case_acronyms",
      "name": "UPPER_CASE_ACRONYMS",
      "snake_name": "upper_case_acronyms",
      "category": "style",
      "weight": 0.95,
      "brief": "capitalized acronyms are against the naming convention",
      "what_it_does": "Checks for fully capitalized names and optionally names containing a capitalized acronym.",
      "why_bad": "In CamelCase, acronyms count as one word.\nSee [naming conventions](https://rust-lang.github.io/api-guidelines/naming.html#casing-conforms-to-rfc-430-c-case)\nfor more.\n\nBy default, the lint only triggers on fully-capitalized names.\nYou can use the `upper-case-acronyms-aggressive: true` config option to enable linting\non all camel case names",
      "example": "```no_run\nstruct HTTPResponse;\n```\nUse instead:\n```no_run\nstruct HttpResponse;\n```",
      "version": "1.51.0",
      "source_file": "upper_case_acronyms.rs",
      "embedding_text": "capitalized acronyms are against the naming convention\n\nChecks for fully capitalized names and optionally names containing a capitalized acronym.\n\nIn CamelCase, acronyms count as one word.\nSee [naming conventions](https://rust-lang.github.io/api-guidelines/naming.html#casing-conforms-to-rfc-430-c-case)\nfor more.\n\nBy default, the lint only triggers on fully-capitalized names.\nYou can use the `upper-case-acronyms-aggressive: true` config option to enable linting\non all camel case names"
    },
    {
      "id": "clippy::use_self",
      "name": "USE_SELF",
      "snake_name": "use_self",
      "category": "nursery",
      "weight": 0.9,
      "brief": "unnecessary structure name repetition whereas `Self` is applicable",
      "what_it_does": "Checks for unnecessary repetition of structure name when a\nreplacement with `Self` is applicable.",
      "why_bad": "Unnecessary repetition. Mixed use of `Self` and struct\nname\nfeels inconsistent.",
      "example": "```no_run\nstruct Foo;\nimpl Foo {\nfn new() -> Foo {\nFoo {}\n}\n}\n```\ncould be\n```no_run\nstruct Foo;\nimpl Foo {\nfn new() -> Self {\nSelf {}\n}\n}\n```",
      "version": "pre 1.29.0",
      "source_file": "use_self.rs",
      "embedding_text": "unnecessary structure name repetition whereas `Self` is applicable\n\nChecks for unnecessary repetition of structure name when a\nreplacement with `Self` is applicable.\n\nUnnecessary repetition. Mixed use of `Self` and struct\nname\nfeels inconsistent."
    },
    {
      "id": "clippy::useless_concat",
      "name": "USELESS_CONCAT",
      "snake_name": "useless_concat",
      "category": "complexity",
      "weight": 1.0,
      "brief": "checks that the `concat` macro has at least two arguments",
      "what_it_does": "Checks that the `concat!` macro has at least two arguments.",
      "why_bad": "If there are less than 2 arguments, then calling the macro is doing nothing.",
      "example": "```no_run\nlet x = concat!(\"a\");\n```\nUse instead:\n```no_run\nlet x = \"a\";\n```",
      "version": "1.89.0",
      "source_file": "useless_concat.rs",
      "embedding_text": "checks that the `concat` macro has at least two arguments\n\nChecks that the `concat!` macro has at least two arguments.\n\nIf there are less than 2 arguments, then calling the macro is doing nothing."
    },
    {
      "id": "clippy::useless_conversion",
      "name": "USELESS_CONVERSION",
      "snake_name": "useless_conversion",
      "category": "complexity",
      "weight": 1.0,
      "brief": "calls to `Into`, `TryInto`, `From`, `TryFrom`, or `IntoIter` which perform useless conversions to the same type",
      "what_it_does": "Checks for `Into`, `TryInto`, `From`, `TryFrom`, or `IntoIter` calls\nwhich uselessly convert to the same type.",
      "why_bad": "Redundant code.",
      "example": "```no_run\n// format!() returns a `String`\nlet s: String = format!(\"hello\").into();\n```\n\nUse instead:\n```no_run\nlet s: String = format!(\"hello\");\n```",
      "version": "1.45.0",
      "source_file": "useless_conversion.rs",
      "embedding_text": "calls to `Into`, `TryInto`, `From`, `TryFrom`, or `IntoIter` which perform useless conversions to the same type\n\nChecks for `Into`, `TryInto`, `From`, `TryFrom`, or `IntoIter` calls\nwhich uselessly convert to the same type.\n\nRedundant code."
    },
    {
      "id": "clippy::useless_vec",
      "name": "USELESS_VEC",
      "snake_name": "useless_vec",
      "category": "perf",
      "weight": 1.0,
      "brief": "useless `vec!`",
      "what_it_does": "Checks for usage of `vec![..]` when using `[..]` would\nbe possible.",
      "why_bad": "This is less efficient.",
      "example": "```no_run\nfn foo(_x: &[u8]) {}\n\nfoo(&vec![1, 2]);\n```\n\nUse instead:\n```no_run\n# fn foo(_x: &[u8]) {}\nfoo(&[1, 2]);\n```",
      "version": "pre 1.29.0",
      "source_file": "useless_vec.rs",
      "embedding_text": "useless `vec!`\n\nChecks for usage of `vec![..]` when using `[..]` would\nbe possible.\n\nThis is less efficient."
    },
    {
      "id": "clippy::vec_init_then_push",
      "name": "VEC_INIT_THEN_PUSH",
      "snake_name": "vec_init_then_push",
      "category": "perf",
      "weight": 1.0,
      "brief": "`push` immediately after `Vec` creation",
      "what_it_does": "Checks for calls to `push` immediately after creating a new `Vec`.\n\nIf the `Vec` is created using `with_capacity` this will only lint if the capacity is a\nconstant and the number of pushes is greater than or equal to the initial capacity.\n\nIf the `Vec` is extended after the initial sequence of pushes and it was default initialized\nthen this will only lint after there were at least four pushes. This number may change in\nthe future.",
      "why_bad": "The `vec![]` macro is both more performant and easier to read than\nmultiple `push` calls.",
      "example": "```no_run\nlet mut v = Vec::new();\nv.push(0);\nv.push(1);\nv.push(2);\n```\nUse instead:\n```no_run\nlet v = vec![0, 1, 2];\n```",
      "version": "1.51.0",
      "source_file": "vec_init_then_push.rs",
      "embedding_text": "`push` immediately after `Vec` creation\n\nChecks for calls to `push` immediately after creating a new `Vec`.\n\nIf the `Vec` is created using `with_capacity` this will only lint if the capacity is a\nconstant and the number of pushes is greater than or equal to the initial capacity.\n\nIf the `Vec` is extended after the initial sequence of pushes and it was default initialized\nthen this will only lint after there were at least four pushes. This number may change in\nthe future.\n\nThe `vec![]` macro is both more performant and easier to read than\nmultiple `push` calls."
    },
    {
      "id": "clippy::needless_pub_self",
      "name": "NEEDLESS_PUB_SELF",
      "snake_name": "needless_pub_self",
      "category": "style",
      "weight": 0.95,
      "brief": "checks for usage of `pub(self)` and `pub(in self)`.",
      "what_it_does": "Checks for usage of `pub(self)` and `pub(in self)`.",
      "why_bad": "It's unnecessary, omitting the `pub` entirely will give the same results.",
      "example": "```rust,ignore\npub(self) type OptBox<T> = Option<Box<T>>;\n```\nUse instead:\n```rust,ignore\ntype OptBox<T> = Option<Box<T>>;\n```",
      "version": "1.72.0",
      "source_file": "visibility.rs",
      "embedding_text": "checks for usage of `pub(self)` and `pub(in self)`.\n\nChecks for usage of `pub(self)` and `pub(in self)`.\n\nIt's unnecessary, omitting the `pub` entirely will give the same results."
    },
    {
      "id": "clippy::pub_with_shorthand",
      "name": "PUB_WITH_SHORTHAND",
      "snake_name": "pub_with_shorthand",
      "category": "restriction",
      "weight": 1.0,
      "brief": "disallows usage of `pub(<loc>)`, without `in`",
      "what_it_does": "Checks for usage of `pub(<loc>)` with `in`.",
      "why_bad": "Consistency. Use it or don't, just be consistent about it.\n\nAlso see the `pub_without_shorthand` lint for an alternative.",
      "example": "```rust,ignore\npub(super) type OptBox<T> = Option<Box<T>>;\n```\nUse instead:\n```rust,ignore\npub(in super) type OptBox<T> = Option<Box<T>>;\n```",
      "version": "1.72.0",
      "source_file": "visibility.rs",
      "embedding_text": "disallows usage of `pub(<loc>)`, without `in`\n\nChecks for usage of `pub(<loc>)` with `in`.\n\nConsistency. Use it or don't, just be consistent about it.\n\nAlso see the `pub_without_shorthand` lint for an alternative."
    },
    {
      "id": "clippy::pub_without_shorthand",
      "name": "PUB_WITHOUT_SHORTHAND",
      "snake_name": "pub_without_shorthand",
      "category": "restriction",
      "weight": 1.0,
      "brief": "disallows usage of `pub(in <loc>)` with `in`",
      "what_it_does": "Checks for usage of `pub(<loc>)` without `in`.\n\nNote: As you cannot write a module's path in `pub(<loc>)`, this will only trigger on\n`pub(super)` and the like.",
      "why_bad": "Consistency. Use it or don't, just be consistent about it.\n\nAlso see the `pub_with_shorthand` lint for an alternative.",
      "example": "```rust,ignore\npub(in super) type OptBox<T> = Option<Box<T>>;\n```\nUse instead:\n```rust,ignore\npub(super) type OptBox<T> = Option<Box<T>>;\n```",
      "version": "1.72.0",
      "source_file": "visibility.rs",
      "embedding_text": "disallows usage of `pub(in <loc>)` with `in`\n\nChecks for usage of `pub(<loc>)` without `in`.\n\nNote: As you cannot write a module's path in `pub(<loc>)`, this will only trigger on\n`pub(super)` and the like.\n\nConsistency. Use it or don't, just be consistent about it.\n\nAlso see the `pub_with_shorthand` lint for an alternative."
    },
    {
      "id": "clippy::volatile_composites",
      "name": "VOLATILE_COMPOSITES",
      "snake_name": "volatile_composites",
      "category": "nursery",
      "weight": 0.9,
      "brief": "warn about volatile read/write applied to composite types",
      "what_it_does": "This lint warns when volatile load/store operations\n(`write_volatile`/`read_volatile`) are applied to composite types.",
      "why_bad": "Volatile operations are typically used with memory mapped IO devices,\nwhere the precise number and ordering of load and store instructions is\nimportant because they can have side effects. This is well defined for\nprimitive types like `u32`, but less well defined for structures and\nother composite types. In practice it's implementation defined, and the\nbehavior can be rustc-version dependent.\n\nAs a result, code should only apply `write_volatile`/`read_volatile` to\nprimitive types to be fully well-defined.",
      "example": "```no_run\nstruct MyDevice {\naddr: usize,\ncount: usize\n}\n\nfn start_device(device: *mut MyDevice, addr: usize, count: usize) {\nunsafe {\ndevice.write_volatile(MyDevice { addr, count });\n}\n}\n```\nInstead, operate on each primtive field individually:\n```no_run\nstruct MyDevice {\naddr: usize,\ncount: usize\n}\n\nfn start_device(device: *mut MyDevice, addr: usize, count: usize) {\nunsafe {\n(&raw mut (*device).addr).write_volatile(addr);\n(&raw mut (*device).count).write_volatile(count);\n}\n}\n```",
      "version": "1.92.0",
      "source_file": "volatile_composites.rs",
      "embedding_text": "warn about volatile read/write applied to composite types\n\nThis lint warns when volatile load/store operations\n(`write_volatile`/`read_volatile`) are applied to composite types.\n\nVolatile operations are typically used with memory mapped IO devices,\nwhere the precise number and ordering of load and store instructions is\nimportant because they can have side effects. This is well defined for\nprimitive types like `u32`, but less well defined for structures and\nother composite types. In practice it's implementation defined, and the\nbehavior can be rustc-version dependent.\n\nAs a result, code should only apply `write_volatile`/`read_volatile` to\nprimitive types to be fully well-defined."
    },
    {
      "id": "clippy::enum_glob_use",
      "name": "ENUM_GLOB_USE",
      "snake_name": "enum_glob_use",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "use items that import all variants of an enum",
      "what_it_does": "Checks for `use Enum::*`.",
      "why_bad": "It is usually better style to use the prefixed name of\nan enumeration variant, rather than importing variants.",
      "example": "```no_run\nuse std::cmp::Ordering::*;\n\n# fn foo(_: std::cmp::Ordering) {}\nfoo(Less);\n```\n\nUse instead:\n```no_run\nuse std::cmp::Ordering;\n\n# fn foo(_: Ordering) {}\nfoo(Ordering::Less)\n```",
      "version": "pre 1.29.0",
      "source_file": "wildcard_imports.rs",
      "embedding_text": "use items that import all variants of an enum\n\nChecks for `use Enum::*`.\n\nIt is usually better style to use the prefixed name of\nan enumeration variant, rather than importing variants."
    },
    {
      "id": "clippy::wildcard_imports",
      "name": "WILDCARD_IMPORTS",
      "snake_name": "wildcard_imports",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "lint `use _::*` statements",
      "what_it_does": "Checks for wildcard imports `use _::*`.",
      "why_bad": "wildcard imports can pollute the namespace. This is especially bad if\nyou try to import something through a wildcard, that already has been imported by name from\na different source:\n\n```rust,ignore\nuse crate1::foo; // Imports a function named foo\nuse crate2::*; // Has a function named foo\n\nfoo(); // Calls crate1::foo\n```\n\nThis can lead to confusing error messages at best and to unexpected behavior at worst.",
      "example": "```rust,ignore\nuse crate1::*;\n\nfoo();\n```\n\nUse instead:\n```rust,ignore\nuse crate1::foo;\n\nfoo();\n```",
      "version": "1.43.0",
      "source_file": "wildcard_imports.rs",
      "embedding_text": "lint `use _::*` statements\n\nChecks for wildcard imports `use _::*`.\n\nwildcard imports can pollute the namespace. This is especially bad if\nyou try to import something through a wildcard, that already has been imported by name from\na different source:\n\n```rust,ignore\nuse crate1::foo; // Imports a function named foo\nuse crate2::*; // Has a function named foo\n\nfoo(); // Calls crate1::foo\n```\n\nThis can lead to confusing error messages at best and to unexpected behavior at worst."
    },
    {
      "id": "clippy::println_empty_string",
      "name": "PRINTLN_EMPTY_STRING",
      "snake_name": "println_empty_string",
      "category": "style",
      "weight": 0.95,
      "brief": "using `println!(\\",
      "what_it_does": "This lint warns when you use `println!(\"\")` to\nprint a newline.",
      "why_bad": "You should use `println!()`, which is simpler.",
      "example": "```no_run\nprintln!(\"\");\n```\n\nUse instead:\n```no_run\nprintln!();\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "using `println!(\\\n\nThis lint warns when you use `println!(\"\")` to\nprint a newline.\n\nYou should use `println!()`, which is simpler."
    },
    {
      "id": "clippy::print_with_newline",
      "name": "PRINT_WITH_NEWLINE",
      "snake_name": "print_with_newline",
      "category": "style",
      "weight": 0.95,
      "brief": "using `print!()` with a format string that ends in a single newline",
      "what_it_does": "This lint warns when you use `print!()` with a format\nstring that ends in a newline.",
      "why_bad": "You should use `println!()` instead, which appends the\nnewline.",
      "example": "```no_run\n# let name = \"World\";\nprint!(\"Hello {}!\\n\", name);\n```\nuse println!() instead\n```no_run\n# let name = \"World\";\nprintln!(\"Hello {}!\", name);\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "using `print!()` with a format string that ends in a single newline\n\nThis lint warns when you use `print!()` with a format\nstring that ends in a newline.\n\nYou should use `println!()` instead, which appends the\nnewline."
    },
    {
      "id": "clippy::print_stdout",
      "name": "PRINT_STDOUT",
      "snake_name": "print_stdout",
      "category": "restriction",
      "weight": 1.0,
      "brief": "printing on stdout",
      "what_it_does": "Checks for printing on *stdout*. The purpose of this lint\nis to catch debugging remnants.",
      "why_bad": "People often print on *stdout* while debugging an\napplication and might forget to remove those prints afterward.",
      "example": "```no_run\nprintln!(\"Hello world!\");\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "printing on stdout\n\nChecks for printing on *stdout*. The purpose of this lint\nis to catch debugging remnants.\n\nPeople often print on *stdout* while debugging an\napplication and might forget to remove those prints afterward."
    },
    {
      "id": "clippy::print_stderr",
      "name": "PRINT_STDERR",
      "snake_name": "print_stderr",
      "category": "restriction",
      "weight": 1.0,
      "brief": "printing on stderr",
      "what_it_does": "Checks for printing on *stderr*. The purpose of this lint\nis to catch debugging remnants.",
      "why_bad": "People often print on *stderr* while debugging an\napplication and might forget to remove those prints afterward.",
      "example": "```no_run\neprintln!(\"Hello world!\");\n```",
      "version": "1.50.0",
      "source_file": "mod.rs",
      "embedding_text": "printing on stderr\n\nChecks for printing on *stderr*. The purpose of this lint\nis to catch debugging remnants.\n\nPeople often print on *stderr* while debugging an\napplication and might forget to remove those prints afterward."
    },
    {
      "id": "clippy::use_debug",
      "name": "USE_DEBUG",
      "snake_name": "use_debug",
      "category": "restriction",
      "weight": 1.0,
      "brief": "use of `Debug`-based formatting",
      "what_it_does": "Checks for usage of `Debug` formatting. The purpose of this\nlint is to catch debugging remnants.",
      "why_bad": "The purpose of the `Debug` trait is to facilitate debugging Rust code,\nand [no guarantees are made about its output][stability].\nIt should not be used in user-facing output.",
      "example": "```no_run\n# let foo = \"bar\";\nprintln!(\"{:?}\", foo);\n```\n\n[stability]: https://doc.rust-lang.org/stable/std/fmt/trait.Debug.html#stability",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "use of `Debug`-based formatting\n\nChecks for usage of `Debug` formatting. The purpose of this\nlint is to catch debugging remnants.\n\nThe purpose of the `Debug` trait is to facilitate debugging Rust code,\nand [no guarantees are made about its output][stability].\nIt should not be used in user-facing output."
    },
    {
      "id": "clippy::print_literal",
      "name": "PRINT_LITERAL",
      "snake_name": "print_literal",
      "category": "style",
      "weight": 0.95,
      "brief": "printing a literal with a format string",
      "what_it_does": "This lint warns about the use of literals as `print!`/`println!` args.",
      "why_bad": "Using literals as `println!` args is inefficient\n(c.f., https://github.com/matthiaskrgr/rust-str-bench) and unnecessary\n(i.e., just put the literal in the format string)",
      "example": "```no_run\nprintln!(\"{}\", \"foo\");\n```\nuse the literal without formatting:\n```no_run\nprintln!(\"foo\");\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "printing a literal with a format string\n\nThis lint warns about the use of literals as `print!`/`println!` args.\n\nUsing literals as `println!` args is inefficient\n(c.f., https://github.com/matthiaskrgr/rust-str-bench) and unnecessary\n(i.e., just put the literal in the format string)"
    },
    {
      "id": "clippy::writeln_empty_string",
      "name": "WRITELN_EMPTY_STRING",
      "snake_name": "writeln_empty_string",
      "category": "style",
      "weight": 0.95,
      "brief": "using `writeln!(buf, \\",
      "what_it_does": "This lint warns when you use `writeln!(buf, \"\")` to\nprint a newline.",
      "why_bad": "You should use `writeln!(buf)`, which is simpler.",
      "example": "```no_run\n# use std::fmt::Write;\n# let mut buf = String::new();\nwriteln!(buf, \"\");\n```\n\nUse instead:\n```no_run\n# use std::fmt::Write;\n# let mut buf = String::new();\nwriteln!(buf);\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "using `writeln!(buf, \\\n\nThis lint warns when you use `writeln!(buf, \"\")` to\nprint a newline.\n\nYou should use `writeln!(buf)`, which is simpler."
    },
    {
      "id": "clippy::write_with_newline",
      "name": "WRITE_WITH_NEWLINE",
      "snake_name": "write_with_newline",
      "category": "style",
      "weight": 0.95,
      "brief": "using `write!()` with a format string that ends in a single newline",
      "what_it_does": "This lint warns when you use `write!()` with a format\nstring that\nends in a newline.",
      "why_bad": "You should use `writeln!()` instead, which appends the\nnewline.",
      "example": "```no_run\n# use std::fmt::Write;\n# let mut buf = String::new();\n# let name = \"World\";\nwrite!(buf, \"Hello {}!\\n\", name);\n```\n\nUse instead:\n```no_run\n# use std::fmt::Write;\n# let mut buf = String::new();\n# let name = \"World\";\nwriteln!(buf, \"Hello {}!\", name);\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "using `write!()` with a format string that ends in a single newline\n\nThis lint warns when you use `write!()` with a format\nstring that\nends in a newline.\n\nYou should use `writeln!()` instead, which appends the\nnewline."
    },
    {
      "id": "clippy::write_literal",
      "name": "WRITE_LITERAL",
      "snake_name": "write_literal",
      "category": "style",
      "weight": 0.95,
      "brief": "writing a literal with a format string",
      "what_it_does": "This lint warns about the use of literals as `write!`/`writeln!` args.",
      "why_bad": "Using literals as `writeln!` args is inefficient\n(c.f., https://github.com/matthiaskrgr/rust-str-bench) and unnecessary\n(i.e., just put the literal in the format string)",
      "example": "```no_run\n# use std::fmt::Write;\n# let mut buf = String::new();\nwriteln!(buf, \"{}\", \"foo\");\n```\n\nUse instead:\n```no_run\n# use std::fmt::Write;\n# let mut buf = String::new();\nwriteln!(buf, \"foo\");\n```",
      "version": "pre 1.29.0",
      "source_file": "mod.rs",
      "embedding_text": "writing a literal with a format string\n\nThis lint warns about the use of literals as `write!`/`writeln!` args.\n\nUsing literals as `writeln!` args is inefficient\n(c.f., https://github.com/matthiaskrgr/rust-str-bench) and unnecessary\n(i.e., just put the literal in the format string)"
    },
    {
      "id": "clippy::zero_divided_by_zero",
      "name": "ZERO_DIVIDED_BY_ZERO",
      "snake_name": "zero_divided_by_zero",
      "category": "complexity",
      "weight": 1.0,
      "brief": "usage of `0.0 / 0.0` to obtain NaN instead of `f32::NAN` or `f64::NAN`",
      "what_it_does": "Checks for `0.0 / 0.0`.",
      "why_bad": "It's less readable than `f32::NAN` or `f64::NAN`.",
      "example": "```no_run\nlet nan = 0.0f32 / 0.0;\n```\n\nUse instead:\n```no_run\nlet nan = f32::NAN;\n```",
      "version": "pre 1.29.0",
      "source_file": "zero_div_zero.rs",
      "embedding_text": "usage of `0.0 / 0.0` to obtain NaN instead of `f32::NAN` or `f64::NAN`\n\nChecks for `0.0 / 0.0`.\n\nIt's less readable than `f32::NAN` or `f64::NAN`."
    },
    {
      "id": "clippy::zero_repeat_side_effects",
      "name": "ZERO_REPEAT_SIDE_EFFECTS",
      "snake_name": "zero_repeat_side_effects",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "usage of zero-sized initializations of arrays or vecs causing side effects",
      "what_it_does": "Checks for array or vec initializations which contain an expression with side effects,\nbut which have a repeat count of zero.",
      "why_bad": "Such an initialization, despite having a repeat length of 0, will still call the inner function.\nThis may not be obvious and as such there may be unintended side effects in code.",
      "example": "```no_run\nfn side_effect() -> i32 {\nprintln!(\"side effect\");\n10\n}\nlet a = [side_effect(); 0];\n```\nUse instead:\n```no_run\nfn side_effect() -> i32 {\nprintln!(\"side effect\");\n10\n}\nside_effect();\nlet a: [i32; 0] = [];\n```",
      "version": "1.79.0",
      "source_file": "zero_repeat_side_effects.rs",
      "embedding_text": "usage of zero-sized initializations of arrays or vecs causing side effects\n\nChecks for array or vec initializations which contain an expression with side effects,\nbut which have a repeat count of zero.\n\nSuch an initialization, despite having a repeat length of 0, will still call the inner function.\nThis may not be obvious and as such there may be unintended side effects in code."
    },
    {
      "id": "clippy::zero_sized_map_values",
      "name": "ZERO_SIZED_MAP_VALUES",
      "snake_name": "zero_sized_map_values",
      "category": "pedantic",
      "weight": 1.0,
      "brief": "usage of map with zero-sized value type",
      "what_it_does": "Checks for maps with zero-sized value types anywhere in the code.",
      "why_bad": "Since there is only a single value for a zero-sized type, a map\ncontaining zero sized values is effectively a set. Using a set in that case improves\nreadability and communicates intent more clearly.",
      "example": "```no_run\n# use std::collections::HashMap;\nfn unique_words(text: &str) -> HashMap<&str, ()> {\ntodo!();\n}\n```\nUse instead:\n```no_run\n# use std::collections::HashSet;\nfn unique_words(text: &str) -> HashSet<&str> {\ntodo!();\n}\n```",
      "version": "1.50.0",
      "source_file": "zero_sized_map_values.rs",
      "embedding_text": "usage of map with zero-sized value type\n\nChecks for maps with zero-sized value types anywhere in the code.\n\nSince there is only a single value for a zero-sized type, a map\ncontaining zero sized values is effectively a set. Using a set in that case improves\nreadability and communicates intent more clearly."
    },
    {
      "id": "clippy::zombie_processes",
      "name": "ZOMBIE_PROCESSES",
      "snake_name": "zombie_processes",
      "category": "suspicious",
      "weight": 1.15,
      "brief": "not waiting on a spawned child process",
      "what_it_does": "Looks for code that spawns a process but never calls `wait()` on the child.",
      "why_bad": "As explained in the [standard library documentation](https://doc.rust-lang.org/stable/std/process/struct.Child.html#warning),\ncalling `wait()` is necessary on Unix platforms to properly release all OS resources associated with the process.\nNot doing so will effectively leak process IDs and/or other limited global resources,\nwhich can eventually lead to resource exhaustion, so it's recommended to call `wait()` in long-running applications.\nSuch processes are called \"zombie processes\".\n\nTo reduce the rate of false positives, if the spawned process is assigned to a binding, the lint actually works the other way around; it\nconservatively checks that all uses of a variable definitely don't call `wait()` and only then emits a warning.\nFor that reason, a seemingly unrelated use can get called out as calling `wait()` in help messages.",
      "example": "```rust\nuse std::process::Command;\n\nlet _child = Command::new(\"ls\").spawn().expect(\"failed to execute child\");\n```\nUse instead:\n```rust\nuse std::process::Command;\n\nlet mut child = Command::new(\"ls\").spawn().expect(\"failed to execute child\");\nchild.wait().expect(\"failed to wait on child\");\n```",
      "version": "1.83.0",
      "source_file": "zombie_processes.rs",
      "embedding_text": "not waiting on a spawned child process\n\nLooks for code that spawns a process but never calls `wait()` on the child.\n\nAs explained in the [standard library documentation](https://doc.rust-lang.org/stable/std/process/struct.Child.html#warning),\ncalling `wait()` is necessary on Unix platforms to properly release all OS resources associated with the process.\nNot doing so will effectively leak process IDs and/or other limited global resources,\nwhich can eventually lead to resource exhaustion, so it's recommended to call `wait()` in long-running applications.\nSuch processes are called \"zombie processes\".\n\nTo reduce the rate of false positives, if the spawned process is assigned to a binding, the lint actually works the other way around; it\nconservatively checks that all uses of a variable definitely don't call `wait()` and only then emits a warning.\nFor that reason, a seemingly unrelated use can get called out as calling `wait()` in help messages."
    }
  ]
}
