{
  "source": "FLS RST files",
  "extraction_date": "2025-12-31",
  "statistics": {
    "total_sections": 339,
    "total_paragraph_ids": 3857,
    "files_processed": 23
  },
  "sections": [
    {
      "fls_id": "fls_l21tjqjkkaa0",
      "title": "Associated Items",
      "level": 1,
      "file": "associated-items",
      "content": "Associated Items\n\n AssociatedItemWithVisibility ::=\n VisibilityModifier? (\n ConstantDeclaration\n | FunctionDeclaration\n | TypeAliasDeclaration\n )\n\nAn associated item is an item that appears within an\nimplementation or a trait.\n\nAn associated constant is a constant that appears as an\nassociated item.\n\nAn associated function is a function that appears as an\nassociated item.\n\nAn associated type is a type alias that appears as an\nassociated item.\n\nAn associated type shall not be used in the path expression of a\nstruct expression.\n\nAn associated type with a :s:`TypeBoundList` shall appear only as an\nassociated trait type.\n\nA generic associated type is an associated type with\n[generic parameter]s.\n\nA lifetime parameter of a generic associated type requires a\nbound of the form T: 'lifetime, where T is a type parameter\nor Self and 'lifetime is the lifetime parameter, when\n\n* The generic associated type is used in an associated function of\n the same trait, and\n\n* The corresponding lifetime argument in the use is not the 'static\n lifetime and has either an explicit bound or an implied bound\n that constrains the type parameter, and\n\n* The intersection of all such uses is not empty.\n\nAn associated implementation constant is an associated constant that\nappears within an implementation.\n\nAn associated implementation constant shall have a constant\ninitializer.\n\nAn associated implementation function is an associated function that\nappears within an implementation.\n\nAn associated implementation function shall have a function body.\n\nAn associated implementation type is an associated type that appears\nwithin an implementation.\n\nAn associated implementation type shall have an initialization type.\n\nAn associated trait item is an associated item that appears\nwithin a trait.\n\nAn associated trait implementation item is an associated item that\nappears within a trait implementation.\n\nAn associated trait constant is an associated constant that appears\nwithin a trait.\n\nAn associated trait function is an associated function that appears\nwithin a trait.\n\nAn associated trait function shall not be subject to keyword const.\n\nEvery occurrence of an impl trait type in the return type of an\nassociated trait function is equivalent to referring to a new\nanonymous associated trait type of the implemented trait.\n\nAn associated trait type is an associated type that appears within\na trait.\n\nAn associated trait type shall not have an initialization type.\n\nAn associated trait type has an implicit core::marker::Sized\nbound.\n\nAn associated trait type of the form\n\nis equivalent to a where clause of the following form:\n\nAn associated trait implementation function is an associated function\nthat appears within a trait implementation.\n\nEvery occurrence of an impl trait type in the return type of an\nassociated trait implementation function is equivalent to referring to the\ncorresponding associated trait type of the corresponding associated\ntrait function.\n\nA method is an associated function with a self parameter.\n\nThe type of a self parameter shall be one of the following:\n\n* A type specification resolving to the implementing type of the\n related implementation, or\n\n* &T where T is one of the [type]s listed in this enumeration,\n or\n\n* &mut T where T is one of the [type]s listed in this\n enumeration, or\n\n* core::pin::Pin<T> <core::pin::Pin> where T is one of the [type]s listed in this\n enumeration.\n\nThe visibility modifier of an associated trait item or associated\ntrait implementation item is rejected, but may still be consumed by\n[macro]s.\n\nGeneric associated type with lifetime bound.",
      "paragraph_ids": [
        "fls_ckzd25qd213t",
        "fls_5y6ae0xqux57",
        "fls_lj7492aq7fzo",
        "fls_8cz4rdrklaj4",
        "fls_w8nu8suy7t5",
        "fls_wasocqdnuzd1",
        "fls_PeD0DzjK57be",
        "fls_3foYUch29ZtF",
        "fls_SnQc0zZS57Cz",
        "fls_6Z05BK2JSzpP",
        "fls_AtItgS1UvwiX",
        "fls_l3iwn56n1uz8",
        "fls_4ftfefcotb4g",
        "fls_qb5qpfe0uwk",
        "fls_1zlkeb6fz10j",
        "fls_tw8u0cc5867l",
        "fls_bx7931x4155h",
        "fls_bnTcCbDvdp94",
        "fls_N3cdn4lCZ2Bf",
        "fls_x564isbhobym",
        "fls_b6nns7oqvdpm",
        "fls_2TRwCz38kuRz",
        "fls_WnsVATJvUdza",
        "fls_yyhebj4qyk34",
        "fls_kl9p3ycl5mzf",
        "fls_a5prbmuruma4",
        "fls_vp2ov6ykueue",
        "fls_5uf74nvdm64o",
        "fls_amWtS80fPtza",
        "fls_Cu8FWrisrqz1",
        "fls_oy92gzxgc273",
        "fls_WXnCWfJGoQx3",
        "fls_OaszUw4IFobz",
        "fls_Wd2FZRomB5yn",
        "fls_lcEyToYIlcmf",
        "fls_IKSPR7ZQMErU",
        "fls_oHxzyaiT7Qm6",
        "fls_znfADVeOvXHD"
      ],
      "position": 125,
      "parent_fls_id": null,
      "sibling_fls_ids": [
        "fls_gvwd0kf72jt",
        "fls_3v733mnewssy",
        "fls_gdeyap4or1db",
        "fls_dzq9cdz4ibsz",
        "fls_ckvjj4tt1hh2",
        "fls_osd6c4utyjb3",
        "fls_qcb1n9c0e5hz",
        "fls_48qldfwwh493",
        "fls_y2k5paj8m8ug",
        "fls_fk2m2irwpeof",
        "fls_z1il3w9nulzy",
        "fls_wb86edg02t6a",
        "fls_411up5z0b6n6",
        "fls_83182bfa9uqb",
        "fls_ronnwodjjjsh",
        "fls_xgqh0ju6bmbn",
        "fls_hdwwrsyunir",
        "fls_wdicg3sqa98e",
        "fls_vgb6ev541b2r",
        "fls_EBwqH60SUHiN",
        "fls_jep7p27kaqlp",
        "fls_94a8v54bufn8"
      ]
    },
    {
      "fls_id": "fls_gvwd0kf72jt",
      "title": "Attributes",
      "level": 1,
      "file": "attributes",
      "content": "Attributes\n\n InnerAttribute ::=\n $$#![$$ AttributeContent $$]$$\n\n OuterAttributeOrDoc ::=\n OuterAttribute\n | OuterBuiltinAttribute\n | OuterBlockDoc\n | OuterLineDoc\n\n OuterAttribute ::=\n $$#[$$ AttributeContent $$]$$\n\n AttributeContent ::=\n SimplePath AttributeInput?\n\n AttributeInput ::=\n $$($$ TokenTree* $$)$$\n | $$=$$ Expression\n\n AttributeContentList ::=\n AttributeContent ($$,$$ AttributeContent)* $$,$$?\n\nAn attribute is a general, free-form metadatum that is interpreted based on\nits name, convention, language, and tool.\n\nAn inner attribute is an attribute that applies to an enclosing\nitem.\n\nAn outer attribute is an attribute that applies to a subsequent\nitem.\n\nAn attribute content is a construct that provides the content of\nan attribute.",
      "paragraph_ids": [
        "fls_rnzxj1t0hehl",
        "fls_yd0ehw5csaur",
        "fls_8o6vmzbw1b1j",
        "fls_9TMRVlQwAdTB"
      ],
      "position": 125,
      "parent_fls_id": null,
      "sibling_fls_ids": [
        "fls_l21tjqjkkaa0",
        "fls_3v733mnewssy",
        "fls_gdeyap4or1db",
        "fls_dzq9cdz4ibsz",
        "fls_ckvjj4tt1hh2",
        "fls_osd6c4utyjb3",
        "fls_qcb1n9c0e5hz",
        "fls_48qldfwwh493",
        "fls_y2k5paj8m8ug",
        "fls_fk2m2irwpeof",
        "fls_z1il3w9nulzy",
        "fls_wb86edg02t6a",
        "fls_411up5z0b6n6",
        "fls_83182bfa9uqb",
        "fls_ronnwodjjjsh",
        "fls_xgqh0ju6bmbn",
        "fls_hdwwrsyunir",
        "fls_wdicg3sqa98e",
        "fls_vgb6ev541b2r",
        "fls_EBwqH60SUHiN",
        "fls_jep7p27kaqlp",
        "fls_94a8v54bufn8"
      ]
    },
    {
      "fls_id": "fls_i52cujixq9qs",
      "title": "Attribute Properties",
      "level": 2,
      "file": "attributes",
      "content": "Attribute Properties\n\nAn active attribute is an attribute that is removed from the item\nit decorates.\n\nAn inert attribute is an attribute that remains with the item\nit decorates.\n\nThe following [attribute]s are [active attribute]s:\n\n* [Attribute macro]s.\n\n* Attribute cfg.\n\n* Attribute cfg_attr.\n\nAttribute test is an inert attribute when compiling for testing\npurposes, otherwise it is an active attribute.\n\nAll remaining [attribute]s are [inert attribute]s.",
      "paragraph_ids": [
        "fls_p4potvq7x532",
        "fls_xk7lb2g02sy7",
        "fls_q8wl7pidx2za",
        "fls_jottio69o9e7",
        "fls_gzyx9lfi5pvd",
        "fls_elsfqsiqor1y",
        "fls_4xu1rwecd9au",
        "fls_n3737i320qum"
      ],
      "position": 1473,
      "parent_fls_id": "fls_gvwd0kf72jt",
      "sibling_fls_ids": [
        "fls_ahmnqhm8anlb"
      ]
    },
    {
      "fls_id": "fls_ahmnqhm8anlb",
      "title": "Built-in Attributes",
      "level": 2,
      "file": "attributes",
      "content": "Built-in Attributes\n\n OuterBuiltinAttribute ::=\n $$#[$$ BuiltinAttributeContent $$]$$\n\n BuiltinAttributeContent ::=\n AutomaticallyDerivedContent\n | CfgAttrContent\n | CfgContent\n | CollapseDebuginfoContent\n | ColdContent\n | CrateNameContent\n | CrateTypeContent\n | DeriveContent\n | DocContent\n | ExportNameContent\n | GlobalAllocatorContent\n | InlineContent\n | IgnoreContent\n | LinkContent\n | LinkNameContent\n | LinkSectionContent\n | LinkOrdinalContent\n | MacroExportContent\n | MacroUseContent\n | NakedContent\n | NoBuiltinsContent\n | NoImplicitPreludeContent\n | NoLinkContent\n | NoMainContent\n | NoMangleContent\n | NonExhaustiveContent\n | NoStdContent\n | PanicHandlerContent\n | PathContent\n | ProcMacroAttributeContent\n | ProcMacroContent\n | ProcMacroDeriveContent\n | RecursionLimitContent\n | ReprContent\n | ShouldPanicContent\n | TargetFeatureContent\n | TestContent\n | TrackCallerContent\n | TypeLengthLimitContent\n | UnsafeContent\n | UsedContent\n | WindowsSubsystemContent\n\nA built-in attribute is a language-defined attribute.\n\nThe following [built-in attribute]s are [code generation attribute]s:\n\n* Attribute cold.\n\n* Attribute inline.\n\n* Attribute no_builtins.\n\n* Attribute target_feature.\n\n* Attribute track_caller.\n\n* Attribute naked.\n\nThe following [built-in attribute]s are\n[conditional compilation attribute]s:\n\n* Attribute cfg.\n\n* Attribute cfg_attr.\n\nThe following [built-in attribute]s are [derivation attribute]s:\n\n* Attribute automatically_derived.\n\n* Attribute derive.\n\nThe following [built-in attribute]s are [diagnostics attribute]s:\n\n* Attribute allow.\n\n* Attribute deny.\n\n* Attribute deprecated.\n\n* Attribute forbid.\n\n* Attribute must_use.\n\n* Attribute warn.\n\n* Attribute expect.\n\n* Attribute unsafe.\n\nThe following [built-in attribute]s are [documentation attribute]s:\n\n* Attribute doc.\n\nThe following [built-in attribute]s are\n[foreign function interface attribute]s:\n\n* Attribute crate_name.\n\n* Attribute crate_type.\n\n* Attribute export_name.\n\n* Attribute link.\n\n* Attribute link_name.\n\n* Attribute link_section.\n\n* Attribute no_link.\n\n* Attribute no_main.\n\n* Attribute no_mangle.\n\n* Attribute repr.\n\n* Attribute used.\n\nThe following [built-in attribute]s are [limits attribute]s:\n\n* Attribute recursion_limit.\n\n* Attribute type_length_limit.\n\nThe following [built-in attribute]s are [macro attribute]s:\n\n* Attribute macro_export.\n\n* Attribute macro_use.\n\n* Attribute proc_macro.\n\n* Attribute proc_macro_attribute.\n\n* Attribute proc_macro_derive.\n\nThe following [built-in attribute]s are [modules attribute]s:\n\n* Attribute path.\n\nThe following [built-in attribute]s are [prelude attribute]s:\n\n* Attribute no_implicit_prelude.\n\n* Attribute no_std.\n\nThe following [built-in attribute]s are [runtime attribute]s:\n\n* Attribute global_allocator.\n\n* Attribute panic_handler.\n\n* Attribute windows_subsystem.\n\nThe following [built-in attribute]s are [testing attribute]s:\n\n* Attribute ignore.\n\n* Attribute should_panic.\n\n* Attribute test.\n\nThe following [built-in attribute]s are [type attribute]s:\n\n* Attribute non_exhaustive.",
      "paragraph_ids": [
        "fls_92tqo8uas8kd",
        "fls_bxucstrfcco8",
        "fls_wle815gb9ai2",
        "fls_tvn08dtuilue",
        "fls_q4c023zdsfgn",
        "fls_xtu3p0kzwn7b",
        "fls_gxxbf6eag3et",
        "fls_eOJS3mxa9xgu",
        "fls_87o6n9et9jio",
        "fls_ui0i3rpt5v5u",
        "fls_6utorag4adlv",
        "fls_d8spdkjzp496",
        "fls_vidbcv25dyud",
        "fls_d0298bmlyuu4",
        "fls_dtb3t5ht5ngf",
        "fls_c5n4gzgs79vv",
        "fls_xheohvupr8kb",
        "fls_s5z2q5pl14p4",
        "fls_5ko0q9jnxv5a",
        "fls_rgjf5ibhurda",
        "fls_29y8icoou1gx",
        "fls_NrTL2FruARAv",
        "fls_4d2ArC50kNWL",
        "fls_3fxhz0olhbcy",
        "fls_oexj0952o05u",
        "fls_q579e97n1m8j",
        "fls_sn43rofpq6ld",
        "fls_56d70gkmin4p",
        "fls_mgb1xipm0qwo",
        "fls_rmhlssasdtkj",
        "fls_josaywt6g3rq",
        "fls_qk4vkn42c2jh",
        "fls_f21azsygoovw",
        "fls_4d31lwzblg91",
        "fls_muucfla1s8yn",
        "fls_wbdtpntjr95w",
        "fls_lglwcbsvi9yj",
        "fls_1gyg8hfb13n7",
        "fls_6005g57evfbp",
        "fls_3y4o8kq58dt8",
        "fls_vsix3pqf519x",
        "fls_c8uqw8p0qrh5",
        "fls_b3jobjxmqppy",
        "fls_xyhoxm30i7wn",
        "fls_nowfw1ffhupd",
        "fls_5i27houut1mu",
        "fls_1v9p4vr1nszn",
        "fls_jvkgtnulrqgh",
        "fls_k9p2xrs3dotn",
        "fls_73n30xdcx8e",
        "fls_e7zusnfka5dt",
        "fls_85ul6x76ew9",
        "fls_xkhm1sht2ju5",
        "fls_w9za4moh6gb3",
        "fls_3vubhygy9jje",
        "fls_mhaplbf40j02",
        "fls_23huzf3c4arx",
        "fls_i63y9xnnwq2z",
        "fls_yic8ksed28no",
        "fls_p1ugiol1e5v5",
        "fls_7xh2iphiteam"
      ],
      "position": 2291,
      "parent_fls_id": "fls_gvwd0kf72jt",
      "sibling_fls_ids": [
        "fls_i52cujixq9qs"
      ]
    },
    {
      "fls_id": "fls_h4k49eadninz",
      "title": "Code Generation Attributes",
      "level": 3,
      "file": "attributes",
      "content": "Code Generation Attributes",
      "paragraph_ids": [],
      "position": 7800,
      "parent_fls_id": "fls_ahmnqhm8anlb",
      "sibling_fls_ids": [
        "fls_cdx9zb1yxcc8",
        "fls_wednba84zi3y",
        "fls_t2590yyvclgb",
        "fls_8wcliky2svcs",
        "fls_pgp7ezcc9lh8",
        "fls_cjq792yj6vft",
        "fls_2084b06dr0wz",
        "fls_7bb5ua4g06k8",
        "fls_go457hpaf7ov",
        "fls_nbbvukrdngev",
        "fls_riyi0gy48fxw",
        "fls_r3zwgf9sg1xp"
      ]
    },
    {
      "fls_id": "fls_kpwbpp5hc00s",
      "title": "Attribute ``cold``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute cold\n\nAttribute cold shall apply to [function]s.\n\nAttribute :dc:`cold` indicates that its related function is unlikely\nto be called.",
      "paragraph_ids": [
        "fls_x860jl4103p",
        "fls_8zdexi5lgm2f"
      ],
      "position": 7878,
      "parent_fls_id": "fls_h4k49eadninz",
      "sibling_fls_ids": [
        "fls_ypio6boj3pwf",
        "fls_zakwockktml8",
        "fls_spdmit5fy7el",
        "fls_6qj249hphj1s",
        "fls_Sd6rUmpEb355"
      ]
    },
    {
      "fls_id": "fls_ypio6boj3pwf",
      "title": "Attribute ``inline``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute inline\n\n InlineHint ::=\n $$($$ ($$always$$ | $$never$$) $$)$$\n\nAttribute inline shall apply to [closure expression]s and\n[function]s.\n\nAttribute :dc:`inline` marks its related function as inlined.\nThe process of replacing a call expression to an inlined function\nwith the function body is referred to as inlining.\n\nAttribute inline without an :s:`InlineHint` suggests to a tool that\ninlining should be performed.\n\nAttribute inline with :s:`InlineHint` always suggests to a tool\nthat inlining should always be performed.\n\nAttribute inline with :s:`InlineHint` never suggests to a tool\nthat inlining should never be performed.\n\nA tool is not obliged to perform inlining.",
      "paragraph_ids": [
        "fls_jwyhky49ssup",
        "fls_s7bf7tf9206d",
        "fls_930o6urn669w",
        "fls_z7ufiqqujgdh",
        "fls_f0n4g5uky9tp",
        "fls_r3p4din7rjz8"
      ],
      "position": 8326,
      "parent_fls_id": "fls_h4k49eadninz",
      "sibling_fls_ids": [
        "fls_kpwbpp5hc00s",
        "fls_zakwockktml8",
        "fls_spdmit5fy7el",
        "fls_6qj249hphj1s",
        "fls_Sd6rUmpEb355"
      ]
    },
    {
      "fls_id": "fls_zakwockktml8",
      "title": "Attribute ``no_builtins``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute no_builtins\n\nAttribute no_builtins shall apply to the crate root module.\n\nAttribute :dc:`no_builtins` prevents the tool from replacing certain code\npatterns with calls to intrinsic functions.",
      "paragraph_ids": [
        "fls_x36c6j1ivbvp",
        "fls_k2k10qtn6f0g"
      ],
      "position": 9643,
      "parent_fls_id": "fls_h4k49eadninz",
      "sibling_fls_ids": [
        "fls_kpwbpp5hc00s",
        "fls_ypio6boj3pwf",
        "fls_spdmit5fy7el",
        "fls_6qj249hphj1s",
        "fls_Sd6rUmpEb355"
      ]
    },
    {
      "fls_id": "fls_spdmit5fy7el",
      "title": "Attribute ``target_feature``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute target_feature\n\n FeatureList ::=\n Feature ($$,$$ Feature)*\n\n Feature ::=\n $$adx$$\n | $$aes$$\n | $$avx$$\n | $$avx2$$\n | $$avx512bf16$$\n | $$avx512bitalg$$\n | $$avx512bw$$\n | $$avx512cd$$\n | $$avx512dq$$\n | $$avx512f$$\n | $$avx512fp16$$\n | $$avx512ifma$$\n | $$avx512vbmi$$\n | $$avx512vbmi2$$\n | $$avx512vl$$\n | $$avx512vnni$$\n | $$avx512vp2intersect$$\n | $$avx512vpopcntdq$$\n | $$avxifma$$\n | $$avxneconvert$$\n | $$avxvnni$$\n | $$avxvnniint16$$\n | $$avxvnniint8$$\n | $$bmi1$$\n | $$bmi2$$\n | $$fma$$\n | $$fxsr$$\n | $$gfni$$\n | $$kl$$\n | $$lzcnt$$\n | $$pclmulqdq$$\n | $$popcnt$$\n | $$rdrand$$\n | $$rdseed$$\n | $$sha$$\n | $$sha512$$\n | $$sm3$$\n | $$sm4$$\n | $$sse$$\n | $$sse2$$\n | $$sse3$$\n | $$sse4.1$$\n | $$sse4.2$$\n | $$sse4a$$\n | $$ssse3$$\n | $$tbm$$\n | $$vaes$$\n | $$vpclmulqdq$$\n | $$widekl$$\n | $$xsave$$\n | $$xsavec$$\n | $$xsaveopt$$\n | $$xsaves$$\n\nSafe [function]s that are annotated with [target_feature]s\ncan only be called without an unsafe block by a caller that is within a function\nthat enables all the [target_feature]s that the callee enables.\n\nAttribute :dc:`target_feature` enables target architecture features for its\nrelated function.\n\nThe target architecture features are as follows:\n\nIt is undefined behavior to execute a program compiled with target architecture\nfeatures that are not supported.",
      "paragraph_ids": [
        "fls_3qj3jvmtxvx6",
        "fls_agpkz1v3c281",
        "fls_91b7nd6qslsb",
        "fls_yz4itbk700ot",
        "fls_pdyotoq8uqi2",
        "fls_vdbjoy6gbk7l",
        "fls_k3szii6nviza",
        "fls_xsdkkfgv0pz6",
        "fls_8HPcvIaahaB9",
        "fls_lxcfj6XCKyMh",
        "fls_fh7i1Pcmqjdm",
        "fls_M9ne2sqhRB5L",
        "fls_xWcGvl83bVWC",
        "fls_5CVTkOoLHAvW",
        "fls_hThb8qn820wJ",
        "fls_1T0VYMtG3loD",
        "fls_AlBD9ckWKecQ",
        "fls_72cwAExPDMQ8",
        "fls_pSSIwmUAnUly",
        "fls_YOW8lcBQ5lNI",
        "fls_8PrvVL6dkr31",
        "fls_hKvaSExdlKgd",
        "fls_r5KEicrmEGJt",
        "fls_Qnx9nNiJeIAX",
        "fls_ZrcPWy4pxlTX",
        "fls_YW7otDxAliSj",
        "fls_G4aOoX8a7i7r",
        "fls_eglaup5zyfsk",
        "fls_tkayqh7li81o",
        "fls_vv8o31s0zmli",
        "fls_g0762ekvl2ah",
        "fls_HGKiXfM5fGVo",
        "fls_gtoLNHFmmBzd",
        "fls_406ltkru11tk",
        "fls_4mhyvwj8pbpk",
        "fls_ijsmqk7pgyiz",
        "fls_a1jggfetycxh",
        "fls_rmbadmoeaoxu",
        "fls_f9ydn049isbv",
        "fls_UPhNSZS89sYr",
        "fls_HoNwaLtDzwZi",
        "fls_VqjfIihpRe9m",
        "fls_7c31e21g6bdj",
        "fls_6d5a375j2775",
        "fls_xthidh2nyrno",
        "fls_w02pk6kf9w9e",
        "fls_lzl1gpco3osx",
        "fls_pGHKFrgGlFtg",
        "fls_9x2on8w44k4f",
        "fls_K6TM6oTLL1BA",
        "fls_gRf8F9PIGySt",
        "fls_NNj4H6A9VTR8",
        "fls_qZO82VdU5Iz9",
        "fls_rilqwazchfpp",
        "fls_f0of1395z9pn",
        "fls_v9gf6selc17l",
        "fls_jyb5s2r8w1po",
        "fls_xx51fjkbgg5g"
      ],
      "position": 10134,
      "parent_fls_id": "fls_h4k49eadninz",
      "sibling_fls_ids": [
        "fls_kpwbpp5hc00s",
        "fls_ypio6boj3pwf",
        "fls_zakwockktml8",
        "fls_6qj249hphj1s",
        "fls_Sd6rUmpEb355"
      ]
    },
    {
      "fls_id": "fls_6qj249hphj1s",
      "title": "Attribute ``track_caller``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute track_caller\n\nAttribute track_caller shall apply to non-[main function]s with\nABI \"Rust\".\n\nAttribute :dc:`track_caller` allows the function body of its\nrelated function to obtain a core::panic::Location which indicates\nthe topmost untracked caller that ultimately led to the invocation of the\nfunction.\n\nA tool is not required to implement this indication in an effective manner.\n\nWhen applied to an associated trait function, attribute\ntrack_caller applies to all [associated function]s of the\nimplemented trait. If the associated trait function has a default\nimplementation, then the attribute applies to all overriding\n[function]s.\n\nIt is undefined behavior when attribute track_caller applies to an\nexternal function but does not apply to all linked [implementation]s.\n\nIt is undefined behavior when attribute track_caller is applied to\nan exported function but the external function it links to is missing\nthe attribute.",
      "paragraph_ids": [
        "fls_h8yepgchjxv9",
        "fls_w1pxtzp7acty",
        "fls_zch43jpetmdu",
        "fls_y1e258p4rby5",
        "fls_vkz8t751gfhk",
        "fls_ddg0u5lej74x"
      ],
      "position": 18095,
      "parent_fls_id": "fls_h4k49eadninz",
      "sibling_fls_ids": [
        "fls_kpwbpp5hc00s",
        "fls_ypio6boj3pwf",
        "fls_zakwockktml8",
        "fls_spdmit5fy7el",
        "fls_Sd6rUmpEb355"
      ]
    },
    {
      "fls_id": "fls_Sd6rUmpEb355",
      "title": "Attribute ``naked``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute naked\n\nAttribute naked shall apply to [function]s.\n\nAttribute :dc:`naked` ensures that a function prologue and epilogue are not generated.\n\nAttribute naked function body must consist of exactly one\nmacro core::arch::naked_asm call.\n\nAttribute naked cannot be used together with [testing function]s.\n\nAttribute naked cannot be used together with attribute inline.\n\nAttribute naked cannot be used together with attribute track_caller.\n\nIt is a safety invariant for the function body to respect the ABI of the function.\n\nIt is a safety invariant for the function body to diverge <diverging expression>.",
      "paragraph_ids": [
        "fls_8eg0iN2diBZt",
        "fls_WnqgR5OyecIs",
        "fls_NCHa4Dc1M6oM",
        "fls_H7ccwNk2HGAi",
        "fls_ocOk47SGiRVb",
        "fls_VUL2qySBvRqy",
        "fls_0tYMAQY1V55p",
        "fls_wGbJrz4OpKKb"
      ],
      "position": 19596,
      "parent_fls_id": "fls_h4k49eadninz",
      "sibling_fls_ids": [
        "fls_kpwbpp5hc00s",
        "fls_ypio6boj3pwf",
        "fls_zakwockktml8",
        "fls_spdmit5fy7el",
        "fls_6qj249hphj1s"
      ]
    },
    {
      "fls_id": "fls_cdx9zb1yxcc8",
      "title": "Conditional Compilation Attributes",
      "level": 3,
      "file": "attributes",
      "content": "Conditional Compilation Attributes",
      "paragraph_ids": [],
      "position": 20706,
      "parent_fls_id": "fls_ahmnqhm8anlb",
      "sibling_fls_ids": [
        "fls_h4k49eadninz",
        "fls_wednba84zi3y",
        "fls_t2590yyvclgb",
        "fls_8wcliky2svcs",
        "fls_pgp7ezcc9lh8",
        "fls_cjq792yj6vft",
        "fls_2084b06dr0wz",
        "fls_7bb5ua4g06k8",
        "fls_go457hpaf7ov",
        "fls_nbbvukrdngev",
        "fls_riyi0gy48fxw",
        "fls_r3zwgf9sg1xp"
      ]
    },
    {
      "fls_id": "fls_fymvsy6ig99a",
      "title": "Attribute ``cfg``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute cfg\n\n ConfigurationPredicate ::=\n ConfigurationOption\n | ConfigurationPredicateAll\n | ConfigurationPredicateAny\n | ConfigurationPredicateNot\n | $$true$$\n | $$false$$\n\n ConfigurationOption ::=\n ConfigurationOptionName ConfigurationOptionValue?\n\n ConfigurationOptionName ::=\n Identifier\n\n ConfigurationOptionValue ::=\n $$=$$ StringLiteral\n\n ConfigurationPredicateAll ::=\n $$all$$ $$($$ ConfigurationPredicateList? $$)$$\n\n ConfigurationPredicateAny ::=\n $$any$$ $$($$ ConfigurationPredicateList? $$)$$\n\n ConfigurationPredicateNot ::=\n $$not$$ $$($$ ConfigurationPredicate $$)$$\n\n ConfigurationPredicateList ::=\n ConfigurationPredicate ($$,$$ ConfigurationPredicate)* $$,$$?\n\nAttribute :dc:`cfg` enables conditional compilation.\n\nA configuration predicate is a construct that evaluates statically\nto either true or false, and controls conditional compilation.\n\nAn all configuration predicate is a configuration predicate that\nmodels existential quantifier ALL.\n\nAn all configuration predicate evaluates statically to true when either\nall nested configuration predicates evaluate to true, or there are no nested\nconfiguration predicates.\n\nAn any configuration predicate is a configuration predicate that\nmodels existential quantifier ANY.\n\nAn any configuration predicate evaluates statically to true when any\nnested configuration predicate evaluates to true.\n\nA not configuration predicate is a configuration predicate that\nnegates the Boolean value of its nested configuration predicate.\n\nA not configuration predicate evaluates statically to true when its\nnested configuration predicate evaluates to false.\n\nConfiguration predicate :dc:`true` always evaluates statically to true.\n\nConfiguration predicate :dc:`false` always evaluates statically to false.\n\nThe evaluation of a configuration option is tool-defined.",
      "paragraph_ids": [
        "fls_xrjp7xw9jutz",
        "fls_l96kyix5xsof",
        "fls_y1MUhnKCxK6T",
        "fls_tncxxsyutppf",
        "fls_Rp73YEE3aFdI",
        "fls_m0zxktz168e0",
        "fls_XsxeOd32JI8x",
        "fls_tvsadfy9uibu",
        "fls_JWx8vQwl19Fu",
        "fls_SziFAQsio0ab",
        "fls_jbl9xyynjo0g"
      ],
      "position": 20800,
      "parent_fls_id": "fls_cdx9zb1yxcc8",
      "sibling_fls_ids": [
        "fls_dd9xh3wdjudo"
      ]
    },
    {
      "fls_id": "fls_dd9xh3wdjudo",
      "title": "Attribute ``cfg_attr``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute cfg_attr\n\nAttribute :dc:`cfg_attr` enables conditional compilation.\n\nAn attribute cfg_attr where the related\nconfiguration predicate evaluates to true is replaced with a new\nattribute for each :s:`AttributeContent` enumerated in the\n[attribute]'s :s:`AttributeContentList`.",
      "paragraph_ids": [
        "fls_r66jhict6rlq",
        "fls_rzw12sagm585"
      ],
      "position": 23389,
      "parent_fls_id": "fls_cdx9zb1yxcc8",
      "sibling_fls_ids": [
        "fls_fymvsy6ig99a"
      ]
    },
    {
      "fls_id": "fls_wednba84zi3y",
      "title": "Derivation Attributes",
      "level": 3,
      "file": "attributes",
      "content": "Derivation Attributes",
      "paragraph_ids": [],
      "position": 24074,
      "parent_fls_id": "fls_ahmnqhm8anlb",
      "sibling_fls_ids": [
        "fls_h4k49eadninz",
        "fls_cdx9zb1yxcc8",
        "fls_t2590yyvclgb",
        "fls_8wcliky2svcs",
        "fls_pgp7ezcc9lh8",
        "fls_cjq792yj6vft",
        "fls_2084b06dr0wz",
        "fls_7bb5ua4g06k8",
        "fls_go457hpaf7ov",
        "fls_nbbvukrdngev",
        "fls_riyi0gy48fxw",
        "fls_r3zwgf9sg1xp"
      ]
    },
    {
      "fls_id": "fls_bqw87nz4qbrb",
      "title": "Attribute ``automatically_derived``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute automatically_derived\n\nAttribute :dc:`automatically_derived` is automatically added to\n[implementation]s that are created by attribute derive for\n[built-in trait]s.",
      "paragraph_ids": [
        "fls_5u1e0lkt0ab1"
      ],
      "position": 24142,
      "parent_fls_id": "fls_wednba84zi3y",
      "sibling_fls_ids": [
        "fls_r6gj1p4gajnq"
      ]
    },
    {
      "fls_id": "fls_r6gj1p4gajnq",
      "title": "Attribute ``derive``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute derive\n\nAttribute derive shall apply to [abstract data type]s.\n\nAttribute :dc:`derive` lists [derive macro]s for automatic\nimplementation by a tool.\n\nAttribute derive causes trait core::cmp::PartialEq to be\nautomatically implemented for struct S<T> as follows:",
      "paragraph_ids": [
        "fls_4btm6zwf445a",
        "fls_pjmbmj2b35y8",
        "fls_xtty2ino4vwc"
      ],
      "position": 24559,
      "parent_fls_id": "fls_wednba84zi3y",
      "sibling_fls_ids": [
        "fls_bqw87nz4qbrb"
      ]
    },
    {
      "fls_id": "fls_t2590yyvclgb",
      "title": "Diagnostics Attributes",
      "level": 3,
      "file": "attributes",
      "content": "Diagnostics Attributes\n\nDiagnostic [attribute]s are related to linting, and are not defined in\nthis document.",
      "paragraph_ids": [
        "fls_ghumzt9ybtit"
      ],
      "position": 25496,
      "parent_fls_id": "fls_ahmnqhm8anlb",
      "sibling_fls_ids": [
        "fls_h4k49eadninz",
        "fls_cdx9zb1yxcc8",
        "fls_wednba84zi3y",
        "fls_8wcliky2svcs",
        "fls_pgp7ezcc9lh8",
        "fls_cjq792yj6vft",
        "fls_2084b06dr0wz",
        "fls_7bb5ua4g06k8",
        "fls_go457hpaf7ov",
        "fls_nbbvukrdngev",
        "fls_riyi0gy48fxw",
        "fls_r3zwgf9sg1xp"
      ]
    },
    {
      "fls_id": "fls_8wcliky2svcs",
      "title": "Documentation Attributes",
      "level": 3,
      "file": "attributes",
      "content": "Documentation Attributes",
      "paragraph_ids": [],
      "position": 25709,
      "parent_fls_id": "fls_ahmnqhm8anlb",
      "sibling_fls_ids": [
        "fls_h4k49eadninz",
        "fls_cdx9zb1yxcc8",
        "fls_wednba84zi3y",
        "fls_t2590yyvclgb",
        "fls_pgp7ezcc9lh8",
        "fls_cjq792yj6vft",
        "fls_2084b06dr0wz",
        "fls_7bb5ua4g06k8",
        "fls_go457hpaf7ov",
        "fls_nbbvukrdngev",
        "fls_riyi0gy48fxw",
        "fls_r3zwgf9sg1xp"
      ]
    },
    {
      "fls_id": "fls_63v1fqedzwfd",
      "title": "Attribute ``doc``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute doc\n\n DocInput ::=\n $$=$$ MacroInvocation\n | $$=$$ StringLiteral\n | $$($$ TokenTree* $$)$$\n\nAttribute :dc:`doc` associates documentation with a construct.",
      "paragraph_ids": [
        "fls_1ee9qjcgbwme"
      ],
      "position": 25783,
      "parent_fls_id": "fls_8wcliky2svcs",
      "sibling_fls_ids": []
    },
    {
      "fls_id": "fls_pgp7ezcc9lh8",
      "title": "Foreign Function Interface Attributes",
      "level": 3,
      "file": "attributes",
      "content": "Foreign Function Interface Attributes",
      "paragraph_ids": [],
      "position": 26254,
      "parent_fls_id": "fls_ahmnqhm8anlb",
      "sibling_fls_ids": [
        "fls_h4k49eadninz",
        "fls_cdx9zb1yxcc8",
        "fls_wednba84zi3y",
        "fls_t2590yyvclgb",
        "fls_8wcliky2svcs",
        "fls_cjq792yj6vft",
        "fls_2084b06dr0wz",
        "fls_7bb5ua4g06k8",
        "fls_go457hpaf7ov",
        "fls_nbbvukrdngev",
        "fls_riyi0gy48fxw",
        "fls_r3zwgf9sg1xp"
      ]
    },
    {
      "fls_id": "fls_sun645voqex6",
      "title": "Attribute ``crate_name``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute crate_name\n\nAttribute crate_name shall apply to the crate root module.\n\nAttribute :dc:`crate_name` shall specify the name of the related\ncrate.",
      "paragraph_ids": [
        "fls_tsdk8jyajcg",
        "fls_6riphqysh0gd"
      ],
      "position": 26354,
      "parent_fls_id": "fls_pgp7ezcc9lh8",
      "sibling_fls_ids": [
        "fls_ujig607lmwbm",
        "fls_olzilmy8n0nl",
        "fls_o0f9ae22ug1x",
        "fls_p44fky7fifc",
        "fls_hffpo88r61rh",
        "fls_Obik2w9gvhLN",
        "fls_ch9nkxkloozv",
        "fls_fh27ljezn3qz",
        "fls_mvd7nz8k3wcy",
        "fls_aibb2quva4mn",
        "fls_19LnTi3WabFd",
        "fls_7skf24auayqy"
      ]
    },
    {
      "fls_id": "fls_ujig607lmwbm",
      "title": "Attribute ``crate_type``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute crate_type\n\n CrateType ::=\n $$bin$$\n | $$cdylib$$\n | $$dylib$$\n | $$lib$$\n | $$proc-macro$$\n | $$rlib$$\n | $$staticlib$$\n\nAttribute crate_type shall apply to the crate root module.\n\nAttribute :dc:`crate_type` shall specify the linkage type of the\ncrate it appears in.",
      "paragraph_ids": [
        "fls_2i2g55nqqpc1",
        "fls_1zziddjuzjeq"
      ],
      "position": 26836,
      "parent_fls_id": "fls_pgp7ezcc9lh8",
      "sibling_fls_ids": [
        "fls_sun645voqex6",
        "fls_olzilmy8n0nl",
        "fls_o0f9ae22ug1x",
        "fls_p44fky7fifc",
        "fls_hffpo88r61rh",
        "fls_Obik2w9gvhLN",
        "fls_ch9nkxkloozv",
        "fls_fh27ljezn3qz",
        "fls_mvd7nz8k3wcy",
        "fls_aibb2quva4mn",
        "fls_19LnTi3WabFd",
        "fls_7skf24auayqy"
      ]
    },
    {
      "fls_id": "fls_olzilmy8n0nl",
      "title": "Attribute ``export_name``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute export_name\n\nAttribute export_name shall apply to [function]s and\n[static]s.\n\nAttribute :dc:`export_name` shall specify the exported symbol of the\nrelated function or static.",
      "paragraph_ids": [
        "fls_r3fwpuuaoeie",
        "fls_spwr6gf7kpds"
      ],
      "position": 27485,
      "parent_fls_id": "fls_pgp7ezcc9lh8",
      "sibling_fls_ids": [
        "fls_sun645voqex6",
        "fls_ujig607lmwbm",
        "fls_o0f9ae22ug1x",
        "fls_p44fky7fifc",
        "fls_hffpo88r61rh",
        "fls_Obik2w9gvhLN",
        "fls_ch9nkxkloozv",
        "fls_fh27ljezn3qz",
        "fls_mvd7nz8k3wcy",
        "fls_aibb2quva4mn",
        "fls_19LnTi3WabFd",
        "fls_7skf24auayqy"
      ]
    },
    {
      "fls_id": "fls_o0f9ae22ug1x",
      "title": "Attribute ``link``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute link\n\n LinkOption ::=\n NativeLibraryName\n | NativeLibraryNameWithKind\n | WebAssemblyModuleName\n\n NativeLibraryName ::=\n $$name$$ $$=$$ StringLiteral\n\n NativeLibraryNameWithKind ::=\n NativeLibraryName $$,$$ NativeLibraryKind\n\n WebAssemblyModuleName ::=\n $$wasm_import_module$$ $$=$$ StringLiteral\n\n NativeLibraryKind ::=\n $$kind$$ $$=$$ $$\"$$ NativeLibraryKindType $$\"$$\n\n NativeLibraryKindType ::=\n $$dylib$$\n | $$raw-dylib$$\n | $$framework$$\n | $$static$$\n\nAttribute link shall apply to [external block]s.\n\nAttribute :dc:`link` shall specify the name of a native library that a tool\nshould link with.\n\nThe following native library kinds are available:\n\nWhen attribute link appears without a native library kind, its native\nlibrary kind defaults to dylib. Native library kind framework is only valid\non macOS targets.\n\nIf attribute link appears without a WebAssembly module name, then the\nWebAssembly module name defaults to env.\n\nWhen attribute link appears with raw-dylib as the native library\nkind, the supplied name must include the file extension.\n\nWhen attribute link appears with raw-dylib as the native library\nkind, the [external function]s and [external static]s of the related\nexternal block shall not be subject to attribute no_mangle.",
      "paragraph_ids": [
        "fls_yslpkdngo8hj",
        "fls_6rohnk4swj6c",
        "fls_o83pf3bcrzma",
        "fls_5541q1qoxdpf",
        "fls_wpqawdpevkj6",
        "fls_HPl6poXGiAqV",
        "fls_h9dfs6kzmobp",
        "fls_3a3r4jf7hzqr",
        "fls_1tdheukgm6ai",
        "fls_3i9ijypnh8nx",
        "fls_iDjcQczFQknm",
        "fls_rcERq1PfKPJI"
      ],
      "position": 28043,
      "parent_fls_id": "fls_pgp7ezcc9lh8",
      "sibling_fls_ids": [
        "fls_sun645voqex6",
        "fls_ujig607lmwbm",
        "fls_olzilmy8n0nl",
        "fls_p44fky7fifc",
        "fls_hffpo88r61rh",
        "fls_Obik2w9gvhLN",
        "fls_ch9nkxkloozv",
        "fls_fh27ljezn3qz",
        "fls_mvd7nz8k3wcy",
        "fls_aibb2quva4mn",
        "fls_19LnTi3WabFd",
        "fls_7skf24auayqy"
      ]
    },
    {
      "fls_id": "fls_p44fky7fifc",
      "title": "Attribute ``link_name``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute link_name\n\nAttribute link_name shall apply to [external function]s and\n[external static]s.\n\nAttribute :dc:`link_name` shall specify the linking symbol of the related\nexternal function or external static.\n\nAttribute link_name shall not be applied to [external function]s\nand [external static]s that are annotated with Attribute\nlink_ordinal.",
      "paragraph_ids": [
        "fls_g09jhukl0ez2",
        "fls_d00wni4edi8f",
        "fls_0Athv8KFA5FO"
      ],
      "position": 30286,
      "parent_fls_id": "fls_pgp7ezcc9lh8",
      "sibling_fls_ids": [
        "fls_sun645voqex6",
        "fls_ujig607lmwbm",
        "fls_olzilmy8n0nl",
        "fls_o0f9ae22ug1x",
        "fls_hffpo88r61rh",
        "fls_Obik2w9gvhLN",
        "fls_ch9nkxkloozv",
        "fls_fh27ljezn3qz",
        "fls_mvd7nz8k3wcy",
        "fls_aibb2quva4mn",
        "fls_19LnTi3WabFd",
        "fls_7skf24auayqy"
      ]
    },
    {
      "fls_id": "fls_hffpo88r61rh",
      "title": "Attribute ``link_section``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute link_section\n\nAttribute link_section shall apply to [function]s and\n[static]s.\n\nAttribute :dc:`link_section` specifies the object file section where the\nsymbol of the related function or static will be placed.",
      "paragraph_ids": [
        "fls_5loqzajiz34m",
        "fls_cyxk12wuicml"
      ],
      "position": 31078,
      "parent_fls_id": "fls_pgp7ezcc9lh8",
      "sibling_fls_ids": [
        "fls_sun645voqex6",
        "fls_ujig607lmwbm",
        "fls_olzilmy8n0nl",
        "fls_o0f9ae22ug1x",
        "fls_p44fky7fifc",
        "fls_Obik2w9gvhLN",
        "fls_ch9nkxkloozv",
        "fls_fh27ljezn3qz",
        "fls_mvd7nz8k3wcy",
        "fls_aibb2quva4mn",
        "fls_19LnTi3WabFd",
        "fls_7skf24auayqy"
      ]
    },
    {
      "fls_id": "fls_Obik2w9gvhLN",
      "title": "Attribute ``link_ordinal``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute link_ordinal\n\nAttribute link_ordinal shall apply to [external function]s and\n[external static]s.\n\nThe related extern block of the [external function] or\n[external static] shall be subject to attribute link with\nraw-dylib as the native library kind.\n\nAttribute :dc:`link_ordinal` shall specify the linking symbol of the\nrelated external function or external static by ordinal number.",
      "paragraph_ids": [
        "fls_fuv29BIqcawW",
        "fls_qh5sXG4znAXa",
        "fls_ASnJJiXWGlKI"
      ],
      "position": 31687,
      "parent_fls_id": "fls_pgp7ezcc9lh8",
      "sibling_fls_ids": [
        "fls_sun645voqex6",
        "fls_ujig607lmwbm",
        "fls_olzilmy8n0nl",
        "fls_o0f9ae22ug1x",
        "fls_p44fky7fifc",
        "fls_hffpo88r61rh",
        "fls_ch9nkxkloozv",
        "fls_fh27ljezn3qz",
        "fls_mvd7nz8k3wcy",
        "fls_aibb2quva4mn",
        "fls_19LnTi3WabFd",
        "fls_7skf24auayqy"
      ]
    },
    {
      "fls_id": "fls_ch9nkxkloozv",
      "title": "Attribute ``no_link``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute no_link\n\nAttribute no_link shall apply to [crate import]s.\n\nAttribute :dc:`no_link` indicates that the imported external crate\nwill not be linked into the resulting binary or library.",
      "paragraph_ids": [
        "fls_ayhn6g6sgt3h",
        "fls_76ox8n3eef5"
      ],
      "position": 32576,
      "parent_fls_id": "fls_pgp7ezcc9lh8",
      "sibling_fls_ids": [
        "fls_sun645voqex6",
        "fls_ujig607lmwbm",
        "fls_olzilmy8n0nl",
        "fls_o0f9ae22ug1x",
        "fls_p44fky7fifc",
        "fls_hffpo88r61rh",
        "fls_Obik2w9gvhLN",
        "fls_fh27ljezn3qz",
        "fls_mvd7nz8k3wcy",
        "fls_aibb2quva4mn",
        "fls_19LnTi3WabFd",
        "fls_7skf24auayqy"
      ]
    },
    {
      "fls_id": "fls_fh27ljezn3qz",
      "title": "Attribute ``no_main``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute no_main\n\nAttribute no_main shall apply to the crate root module.\n\nAttribute :dc:`no_main` indicates that the symbols of the\nprogram entry point will not be present in a binary.",
      "paragraph_ids": [
        "fls_84a9k0fzmnfk",
        "fls_6qig3s3qpj0i"
      ],
      "position": 33080,
      "parent_fls_id": "fls_pgp7ezcc9lh8",
      "sibling_fls_ids": [
        "fls_sun645voqex6",
        "fls_ujig607lmwbm",
        "fls_olzilmy8n0nl",
        "fls_o0f9ae22ug1x",
        "fls_p44fky7fifc",
        "fls_hffpo88r61rh",
        "fls_Obik2w9gvhLN",
        "fls_ch9nkxkloozv",
        "fls_mvd7nz8k3wcy",
        "fls_aibb2quva4mn",
        "fls_19LnTi3WabFd",
        "fls_7skf24auayqy"
      ]
    },
    {
      "fls_id": "fls_mvd7nz8k3wcy",
      "title": "Attribute ``no_mangle``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute no_mangle\n\nAttribute no_mangle has no effect on [construct]s other than\n[function]s and [static]s.\n\nAttribute :dc:`no_mangle` indicates that the name of the related\nfunction or static will be used as the symbol for that function\nor static.\n\nAttribute no_mangle causes the related function or static to\nbe publicly exported from the produced library or object file.\n\nAn exported function is a function subject to attribute\nno_mangle.\n\nAn exported static is a static subject to attribute\nno_mangle.",
      "paragraph_ids": [
        "fls_q5swm5meafmx",
        "fls_esaew4fqk8mm",
        "fls_lvnclpxbye9u",
        "fls_VKuSiswPMll7",
        "fls_I029Rvr5BX5P"
      ],
      "position": 33550,
      "parent_fls_id": "fls_pgp7ezcc9lh8",
      "sibling_fls_ids": [
        "fls_sun645voqex6",
        "fls_ujig607lmwbm",
        "fls_olzilmy8n0nl",
        "fls_o0f9ae22ug1x",
        "fls_p44fky7fifc",
        "fls_hffpo88r61rh",
        "fls_Obik2w9gvhLN",
        "fls_ch9nkxkloozv",
        "fls_fh27ljezn3qz",
        "fls_aibb2quva4mn",
        "fls_19LnTi3WabFd",
        "fls_7skf24auayqy"
      ]
    },
    {
      "fls_id": "fls_aibb2quva4mn",
      "title": "Attribute ``repr``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute repr\n\n RepresentationList ::=\n Representation ($$,$$ Representation)* $$,$$?\n\n Representation ::=\n RepresentationKind\n | Alignment\n\n RepresentationKind ::=\n PrimitiveRepresentation\n | $$C$$\n | $$Rust$$\n | $$transparent$$\n\n Alignment ::=\n AlignmentDecrease\n | AlignmentIncrease\n\n PrimitiveRepresentation ::=\n $$i8$$\n | $$i16$$\n | $$i32$$\n | $$i64$$\n | $$i128$$\n | $$isize$$\n | $$u8$$\n | $$u16$$\n | $$u32$$\n | $$u64$$\n | $$u128$$\n | $$usize$$\n\n AlignmentDecrease ::=\n $$packed$$\n\n AlignmentIncrease ::=\n $$align$$ $$($$ DecimalLiteral $$)$$\n\nAttribute repr shall apply to [abstract data type]s.\n\nAttribute :dc:`repr` shall indicate the type representation of the\nrelated type.",
      "paragraph_ids": [
        "fls_vetjq9sw84qc",
        "fls_is2esjz1sy36"
      ],
      "position": 34533,
      "parent_fls_id": "fls_pgp7ezcc9lh8",
      "sibling_fls_ids": [
        "fls_sun645voqex6",
        "fls_ujig607lmwbm",
        "fls_olzilmy8n0nl",
        "fls_o0f9ae22ug1x",
        "fls_p44fky7fifc",
        "fls_hffpo88r61rh",
        "fls_Obik2w9gvhLN",
        "fls_ch9nkxkloozv",
        "fls_fh27ljezn3qz",
        "fls_mvd7nz8k3wcy",
        "fls_19LnTi3WabFd",
        "fls_7skf24auayqy"
      ]
    },
    {
      "fls_id": "fls_19LnTi3WabFd",
      "title": "Attribute ``unsafe``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute unsafe\n\nAttribute :dc:`unsafe` is used to indicate that an attribute is unsafe <unsafe operation>.\n\nAttribute unsafe shall apply to what the contained attribute applies to.\n\nAttribute unsafe does not affect the behavior of the contained attribute.\n\nThe contained attribute shall be one of the following:\n\n* Attribute no_mangle\n\n* Attribute export_name\n\n* Attribute link_section\n\n* Attribute naked",
      "paragraph_ids": [
        "fls_z5DTDKM9mU3o",
        "fls_5pjo3nGOxbVw",
        "fls_gpxlWbQUNsj8",
        "fls_PhrfxSBvXTPV",
        "fls_pCSew95bKJJ5",
        "fls_NRLgmOXxuljQ",
        "fls_ykpxNByUDyHG",
        "fls_2oP2nbDPtUg7"
      ],
      "position": 35733,
      "parent_fls_id": "fls_pgp7ezcc9lh8",
      "sibling_fls_ids": [
        "fls_sun645voqex6",
        "fls_ujig607lmwbm",
        "fls_olzilmy8n0nl",
        "fls_o0f9ae22ug1x",
        "fls_p44fky7fifc",
        "fls_hffpo88r61rh",
        "fls_Obik2w9gvhLN",
        "fls_ch9nkxkloozv",
        "fls_fh27ljezn3qz",
        "fls_mvd7nz8k3wcy",
        "fls_aibb2quva4mn",
        "fls_7skf24auayqy"
      ]
    },
    {
      "fls_id": "fls_7skf24auayqy",
      "title": "Attribute ``used``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute used\n\nAttribute used shall apply to [static]s.\n\nAttribute :dc:`used` forces a tool to keep the related static in the\noutput object file even if the static is not used or referenced by other\n[item]s in the crate.",
      "paragraph_ids": [
        "fls_s4ii078wgpk",
        "fls_k293nzcffks4"
      ],
      "position": 36704,
      "parent_fls_id": "fls_pgp7ezcc9lh8",
      "sibling_fls_ids": [
        "fls_sun645voqex6",
        "fls_ujig607lmwbm",
        "fls_olzilmy8n0nl",
        "fls_o0f9ae22ug1x",
        "fls_p44fky7fifc",
        "fls_hffpo88r61rh",
        "fls_Obik2w9gvhLN",
        "fls_ch9nkxkloozv",
        "fls_fh27ljezn3qz",
        "fls_mvd7nz8k3wcy",
        "fls_aibb2quva4mn",
        "fls_19LnTi3WabFd"
      ]
    },
    {
      "fls_id": "fls_cjq792yj6vft",
      "title": "Limits Attributes",
      "level": 3,
      "file": "attributes",
      "content": "Limits Attributes",
      "paragraph_ids": [],
      "position": 37247,
      "parent_fls_id": "fls_ahmnqhm8anlb",
      "sibling_fls_ids": [
        "fls_h4k49eadninz",
        "fls_cdx9zb1yxcc8",
        "fls_wednba84zi3y",
        "fls_t2590yyvclgb",
        "fls_8wcliky2svcs",
        "fls_pgp7ezcc9lh8",
        "fls_2084b06dr0wz",
        "fls_7bb5ua4g06k8",
        "fls_go457hpaf7ov",
        "fls_nbbvukrdngev",
        "fls_riyi0gy48fxw",
        "fls_r3zwgf9sg1xp"
      ]
    },
    {
      "fls_id": "fls_u2hzlzpzh7yy",
      "title": "Attribute ``recursion_limit``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute recursion_limit\n\nAttribute recursion_limit shall apply to the crate root module.\n\nAttribute :dc:`recursion_limit` sets the maximum depth of\nmacro expansion and auto-dereferencing.",
      "paragraph_ids": [
        "fls_o55cxc67sya7",
        "fls_o9p8fa8zhe15"
      ],
      "position": 37307,
      "parent_fls_id": "fls_cjq792yj6vft",
      "sibling_fls_ids": [
        "fls_tdjjuwbr7mkg"
      ]
    },
    {
      "fls_id": "fls_tdjjuwbr7mkg",
      "title": "Attribute ``type_length_limit``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute type_length_limit\n\nAttribute type_length_limit shall apply to the\ncrate root module.\n\nAttribute :dc:`type_length_limit` sets the maximum number of\n[generic substitution]s for [type parameter]s when constructing a\nconcrete type.",
      "paragraph_ids": [
        "fls_dfnkzj8ob3uq",
        "fls_61vt1r8g51nh"
      ],
      "position": 37857,
      "parent_fls_id": "fls_cjq792yj6vft",
      "sibling_fls_ids": [
        "fls_u2hzlzpzh7yy"
      ]
    },
    {
      "fls_id": "fls_2084b06dr0wz",
      "title": "Macros Attributes",
      "level": 3,
      "file": "attributes",
      "content": "Macros Attributes",
      "paragraph_ids": [],
      "position": 38467,
      "parent_fls_id": "fls_ahmnqhm8anlb",
      "sibling_fls_ids": [
        "fls_h4k49eadninz",
        "fls_cdx9zb1yxcc8",
        "fls_wednba84zi3y",
        "fls_t2590yyvclgb",
        "fls_8wcliky2svcs",
        "fls_pgp7ezcc9lh8",
        "fls_cjq792yj6vft",
        "fls_7bb5ua4g06k8",
        "fls_go457hpaf7ov",
        "fls_nbbvukrdngev",
        "fls_riyi0gy48fxw",
        "fls_r3zwgf9sg1xp"
      ]
    },
    {
      "fls_id": "fls_qyudjGHZfyJH",
      "title": "Attribute ``collapse_debuginfo``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute collapse_debuginfo\n\n CollapseDebuginfoKind ::=\n $$no$$\n | $$external$$\n | $$yes$$\n\nAttribute collapse_debuginfo shall apply to [declarative macro]s.\n\nAttribute :dc:`collapse_debuginfo` changes the debug location information\nfor the expanded code of the declarative macro to its invocation site. This\nrepeats recursively to the top most expansion of a declarative macro that\nis not annotated with attribute collapse_debuginfo.",
      "paragraph_ids": [
        "fls_EzKHtWHmXMAZ",
        "fls_BCvJpfQMYEcD"
      ],
      "position": 38527,
      "parent_fls_id": "fls_2084b06dr0wz",
      "sibling_fls_ids": [
        "fls_e0a96eb6ux3y",
        "fls_qxjy0f758x5s",
        "fls_qkmkev85o5jf",
        "fls_ejhlylrcajo",
        "fls_q6qecp6e413"
      ]
    },
    {
      "fls_id": "fls_e0a96eb6ux3y",
      "title": "Attribute ``macro_export``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute macro_export\n\nAttribute macro_export shall apply to [declarative macro]s.\n\nAttribute :dc:`macro_export` changes the visibility of the related\ndeclarative macro to public visibility and introduces the name\nof the declarative macro into the item scope of the\ncrate root module.",
      "paragraph_ids": [
        "fls_3ma7zkk6john",
        "fls_h26iw5wh4lla"
      ],
      "position": 39402,
      "parent_fls_id": "fls_2084b06dr0wz",
      "sibling_fls_ids": [
        "fls_qyudjGHZfyJH",
        "fls_qxjy0f758x5s",
        "fls_qkmkev85o5jf",
        "fls_ejhlylrcajo",
        "fls_q6qecp6e413"
      ]
    },
    {
      "fls_id": "fls_qxjy0f758x5s",
      "title": "Attribute ``macro_use``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute macro_use\n\n ImportedMacroList ::=\n $$($$ IdentifierList $$)$$\n\nAttribute macro_use shall apply to [crate import]s and\n[module]s.\n\nAn :s:`ImportedMacroList` enumerates macros-to-import. A macro-to-import shall\nbe subject to attribute macro_export.\n\nWhen applied to a crate import, attribute :dc:`macro_use`\nimports from the related crate either:\n\n* The enumerated macros-to-import, or\n\n* If no macros-to-import have been specified, all [macro]s subject to\n attribute macro_export.\n\nWhen applied to a module, attribute macro_use extends the\ntextual macro scope of the related macro.",
      "paragraph_ids": [
        "fls_uua0nthq9id",
        "fls_oq4kyo5z5tj5",
        "fls_skexvtpbjknn",
        "fls_v03924dr0u0z",
        "fls_eha2hoey857x",
        "fls_p6jlgmn2sg7j"
      ],
      "position": 40062,
      "parent_fls_id": "fls_2084b06dr0wz",
      "sibling_fls_ids": [
        "fls_qyudjGHZfyJH",
        "fls_e0a96eb6ux3y",
        "fls_qkmkev85o5jf",
        "fls_ejhlylrcajo",
        "fls_q6qecp6e413"
      ]
    },
    {
      "fls_id": "fls_qkmkev85o5jf",
      "title": "Attribute ``proc_macro``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute proc_macro\n\nAttribute proc_macro shall apply to public [function]s in the\ncrate root module of a proc-macro crate.\n\nAttribute :dc:`proc_macro` turns the related function into a\nfunction-like macro.",
      "paragraph_ids": [
        "fls_u48dtmh97g",
        "fls_t4ez0zg1m569"
      ],
      "position": 41205,
      "parent_fls_id": "fls_2084b06dr0wz",
      "sibling_fls_ids": [
        "fls_qyudjGHZfyJH",
        "fls_e0a96eb6ux3y",
        "fls_qxjy0f758x5s",
        "fls_ejhlylrcajo",
        "fls_q6qecp6e413"
      ]
    },
    {
      "fls_id": "fls_ejhlylrcajo",
      "title": "Attribute ``proc_macro_attribute``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute proc_macro_attribute\n\nAttribute proc_macro_attribute shall apply to public [function]s\nin the crate root module of a proc-macro crate.\n\nAttribute :dc:`proc_macro_attribute` turns the related function into\nan attribute macro.",
      "paragraph_ids": [
        "fls_huznzmkuhdky",
        "fls_gc3ly8fsodf1"
      ],
      "position": 41853,
      "parent_fls_id": "fls_2084b06dr0wz",
      "sibling_fls_ids": [
        "fls_qyudjGHZfyJH",
        "fls_e0a96eb6ux3y",
        "fls_qxjy0f758x5s",
        "fls_qkmkev85o5jf",
        "fls_q6qecp6e413"
      ]
    },
    {
      "fls_id": "fls_q6qecp6e413",
      "title": "Attribute ``proc_macro_derive``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute proc_macro_derive\n\n DeriveName ::=\n Name\n\n HelperAttributeList ::=\n $$attributes$$ $$($$ IdentifierList $$)$$\n\nAttribute proc_macro_derive shall apply to public [function]s in\nthe crate root module of a proc-macro crate.\n\nAttribute :dc:`proc_macro_derive` turns the related function into a\nderive macro, where :s:`DeriveName` defines the name of the\nderive macro available to attribute derive.\n\nThe :s:`HelperAttributeList` declares the [derive helper attribute]s of\nthe derive macro.",
      "paragraph_ids": [
        "fls_l82yswg0k3px",
        "fls_ir9i4i2x5gyx",
        "fls_NydVxyb43TH6"
      ],
      "position": 42633,
      "parent_fls_id": "fls_2084b06dr0wz",
      "sibling_fls_ids": [
        "fls_qyudjGHZfyJH",
        "fls_e0a96eb6ux3y",
        "fls_qxjy0f758x5s",
        "fls_qkmkev85o5jf",
        "fls_ejhlylrcajo"
      ]
    },
    {
      "fls_id": "fls_7bb5ua4g06k8",
      "title": "Modules Attributes",
      "level": 3,
      "file": "attributes",
      "content": "Modules Attributes",
      "paragraph_ids": [],
      "position": 43815,
      "parent_fls_id": "fls_ahmnqhm8anlb",
      "sibling_fls_ids": [
        "fls_h4k49eadninz",
        "fls_cdx9zb1yxcc8",
        "fls_wednba84zi3y",
        "fls_t2590yyvclgb",
        "fls_8wcliky2svcs",
        "fls_pgp7ezcc9lh8",
        "fls_cjq792yj6vft",
        "fls_2084b06dr0wz",
        "fls_go457hpaf7ov",
        "fls_nbbvukrdngev",
        "fls_riyi0gy48fxw",
        "fls_r3zwgf9sg1xp"
      ]
    },
    {
      "fls_id": "fls_1zbaajz5prpn",
      "title": "Attribute ``path``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute path\n\nAttribute path shall apply to [module]s.\n\nAttribute :dc:`path` specifies the module path of the respective\nmodule as a string literal.\n\nA tool is free to define the format of a module path.",
      "paragraph_ids": [
        "fls_lht4pcezmbxw",
        "fls_qb6anohvc03k",
        "fls_18tcecx4p2wp"
      ],
      "position": 43877,
      "parent_fls_id": "fls_7bb5ua4g06k8",
      "sibling_fls_ids": []
    },
    {
      "fls_id": "fls_go457hpaf7ov",
      "title": "Prelude Attributes",
      "level": 3,
      "file": "attributes",
      "content": "Prelude Attributes",
      "paragraph_ids": [],
      "position": 44536,
      "parent_fls_id": "fls_ahmnqhm8anlb",
      "sibling_fls_ids": [
        "fls_h4k49eadninz",
        "fls_cdx9zb1yxcc8",
        "fls_wednba84zi3y",
        "fls_t2590yyvclgb",
        "fls_8wcliky2svcs",
        "fls_pgp7ezcc9lh8",
        "fls_cjq792yj6vft",
        "fls_2084b06dr0wz",
        "fls_7bb5ua4g06k8",
        "fls_nbbvukrdngev",
        "fls_riyi0gy48fxw",
        "fls_r3zwgf9sg1xp"
      ]
    },
    {
      "fls_id": "fls_iikmhqsp1r5a",
      "title": "Attribute ``no_implicit_prelude``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute no_implicit_prelude\n\nThe inner attribute version of attribute no_implicit_prelude\nshall apply to the crate root module or to [module]s.\n\nThe outer attribute version of attribute no_implicit_prelude\nshall apply to [module]s.\n\nAttribute :dc:`no_implicit_prelude` prevents the import of the\nexternal prelude, the standard library prelude, and the tool\nprelude.",
      "paragraph_ids": [
        "fls_tki5k5uo74gw",
        "fls_cmrqxc5oax4r",
        "fls_c7v2hbdb7g2d"
      ],
      "position": 44598,
      "parent_fls_id": "fls_go457hpaf7ov",
      "sibling_fls_ids": [
        "fls_9xnaxd7qbakp"
      ]
    },
    {
      "fls_id": "fls_9xnaxd7qbakp",
      "title": "Attribute ``no_std``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute no_std\n\nAttribute no_std shall apply to the crate root module.\n\nAttribute :dc:`no_std` has the following effects:\n\n* Prevents the import of the standard library prelude.\n\n* Imports the core prelude.\n\n* Imports all [declarative macro]s subject to attribute\n macro_export of the core crate into the macro_use prelude.",
      "paragraph_ids": [
        "fls_qnxihxsvkyf6",
        "fls_kxav9vw59ts4",
        "fls_ve1shwjq09pl",
        "fls_wgwsn7laoju7",
        "fls_lxkd6hdboav4"
      ],
      "position": 45375,
      "parent_fls_id": "fls_go457hpaf7ov",
      "sibling_fls_ids": [
        "fls_iikmhqsp1r5a"
      ]
    },
    {
      "fls_id": "fls_nbbvukrdngev",
      "title": "Runtime Attributes",
      "level": 3,
      "file": "attributes",
      "content": "Runtime Attributes",
      "paragraph_ids": [],
      "position": 46090,
      "parent_fls_id": "fls_ahmnqhm8anlb",
      "sibling_fls_ids": [
        "fls_h4k49eadninz",
        "fls_cdx9zb1yxcc8",
        "fls_wednba84zi3y",
        "fls_t2590yyvclgb",
        "fls_8wcliky2svcs",
        "fls_pgp7ezcc9lh8",
        "fls_cjq792yj6vft",
        "fls_2084b06dr0wz",
        "fls_7bb5ua4g06k8",
        "fls_go457hpaf7ov",
        "fls_riyi0gy48fxw",
        "fls_r3zwgf9sg1xp"
      ]
    },
    {
      "fls_id": "fls_fs0lcfllamj",
      "title": "Attribute ``global_allocator``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute global_allocator\n\nAttribute global_allocator shall apply to [static]s whose\n[type]s implement the core::alloc::GlobalAlloc trait.\n\nAttribute :dc:`global_allocator` sets the global allocator to the related\nstatic.",
      "paragraph_ids": [
        "fls_5b8aewlgeon8",
        "fls_homoidh8mu1r"
      ],
      "position": 46152,
      "parent_fls_id": "fls_nbbvukrdngev",
      "sibling_fls_ids": [
        "fls_ls5eryuoxlp9",
        "fls_1l4mnlfk5rr2"
      ]
    },
    {
      "fls_id": "fls_ls5eryuoxlp9",
      "title": "Attribute ``panic_handler``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute panic_handler\n\nAttribute panic_handler shall apply to [function]s with the\nfollowing restrictions:\n\n* It lacks [function qualifier]s,\n\n* Its ABI is Rust,\n\n* It lacks [generic parameter]s,\n\n* It has a single function parameter whose type is &\n core::panic::PanicInfo,\n\n* It has the never type as its return type,\n\n* It lacks a where clause,\n\n* It has a function body.\n\nAttribute :dc:`panic_handler` indicates that its related function\ndefines the behavior of [panic]s.\n\nA crate graph shall contain exactly one function subject to\nattribute panic_handler.",
      "paragraph_ids": [
        "fls_ryz8qy1wdnma",
        "fls_ncyod5gegMqL",
        "fls_jzIHzPkJqVm8",
        "fls_qXii07xWRUoT",
        "fls_ZEjvn4mmfSct",
        "fls_iWPw0QFE5TrP",
        "fls_WirXqd7UV4M0",
        "fls_5CGTQTuT0I5v",
        "fls_8gqun8lma9wz",
        "fls_ka66jcu8gir7"
      ],
      "position": 46745,
      "parent_fls_id": "fls_nbbvukrdngev",
      "sibling_fls_ids": [
        "fls_fs0lcfllamj",
        "fls_1l4mnlfk5rr2"
      ]
    },
    {
      "fls_id": "fls_1l4mnlfk5rr2",
      "title": "Attribute ``windows_subsystem``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute windows_subsystem\n\n SubsystemKind ::=\n $$console$$\n | $$windows$$\n\nAttribute windows_subsystem shall apply to the crate root module\nof a binary crate.\n\nAttribute :dc:`windows_subsystem` specifies the subsystem on Windows.\n\nIf attribute windows_subsystem is missing, the subsystem of the\nrelated binary crate defaults to console.",
      "paragraph_ids": [
        "fls_7mzjahvdzpy5",
        "fls_t3c0t3lcnebk",
        "fls_go7pfkgpjk2t"
      ],
      "position": 47946,
      "parent_fls_id": "fls_nbbvukrdngev",
      "sibling_fls_ids": [
        "fls_fs0lcfllamj",
        "fls_ls5eryuoxlp9"
      ]
    },
    {
      "fls_id": "fls_riyi0gy48fxw",
      "title": "Testing Attributes",
      "level": 3,
      "file": "attributes",
      "content": "Testing Attributes",
      "paragraph_ids": [],
      "position": 48706,
      "parent_fls_id": "fls_ahmnqhm8anlb",
      "sibling_fls_ids": [
        "fls_h4k49eadninz",
        "fls_cdx9zb1yxcc8",
        "fls_wednba84zi3y",
        "fls_t2590yyvclgb",
        "fls_8wcliky2svcs",
        "fls_pgp7ezcc9lh8",
        "fls_cjq792yj6vft",
        "fls_2084b06dr0wz",
        "fls_7bb5ua4g06k8",
        "fls_go457hpaf7ov",
        "fls_nbbvukrdngev",
        "fls_r3zwgf9sg1xp"
      ]
    },
    {
      "fls_id": "fls_x849a4u7h82j",
      "title": "Attribute ``ignore``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute ignore\n\n IgnoreReason ::=\n $$=$$ StringLiteral\n\nAttribute ignore shall apply to [testing function]s.\n\nAttribute :dc:`ignore` prevents the execution of its related\ntesting function.",
      "paragraph_ids": [
        "fls_qmdylxse9yhu",
        "fls_9m8e59fc1tyh"
      ],
      "position": 48768,
      "parent_fls_id": "fls_riyi0gy48fxw",
      "sibling_fls_ids": [
        "fls_aes2d94g12b9",
        "fls_dv2j1fvvnk1t"
      ]
    },
    {
      "fls_id": "fls_aes2d94g12b9",
      "title": "Attribute ``should_panic``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute should_panic\n\n ExpectedPanicMessage ::=\n $$($$ $$expected$$ $$=$$ StringLiteral $$)$$\n\nAttribute should_panic shall apply to [testing function]s.\n\nAttribute :dc:`should_panic` indicates that for the related\ntesting function to pass, it should panic.\n\nIf :s:`ExpectedPanicMessage` is specified, then the related\ntesting function passes only when the panic message contains the\n:s:`ExpectedPanicMessage`.",
      "paragraph_ids": [
        "fls_w7dq8gnzel36",
        "fls_bm5x846zfnb8",
        "fls_bcoq5aus8nkr"
      ],
      "position": 49328,
      "parent_fls_id": "fls_riyi0gy48fxw",
      "sibling_fls_ids": [
        "fls_x849a4u7h82j",
        "fls_dv2j1fvvnk1t"
      ]
    },
    {
      "fls_id": "fls_dv2j1fvvnk1t",
      "title": "Attribute ``test``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute test\n\nAttribute test shall apply to [function]s that:\n\n* Is not an async function, and\n\n* Is not an unsafe function, and\n\n* Lacks [generic parameter]s, and\n\n* Lacks [function parameter]s, and\n\nAttribute :dc:`test` indicates that the respective function is a\ntesting function.\n\nA testing function that returns the unit type passes when it\nterminates and does not panic.\n\nA testing function that returns core::result::Result<(), E> passes when\nit returns core::result::Result::Ok(()).\n\nA testing function that does not terminate shall pass and fail according to\nthe tool.",
      "paragraph_ids": [
        "fls_o2elhg5w1rj9",
        "fls_ert22u8rvkxt",
        "fls_c9ckjrq6emdj",
        "fls_4uykzqpq6svl",
        "fls_aqzd30s267pt",
        "fls_ze6cs75y9aft",
        "fls_pcs0prrh23y3",
        "fls_niky8lbkvej9",
        "fls_qfuntdm2g184"
      ],
      "position": 50273,
      "parent_fls_id": "fls_riyi0gy48fxw",
      "sibling_fls_ids": [
        "fls_x849a4u7h82j",
        "fls_aes2d94g12b9"
      ]
    },
    {
      "fls_id": "fls_r3zwgf9sg1xp",
      "title": "Type Attributes",
      "level": 3,
      "file": "attributes",
      "content": "Type Attributes",
      "paragraph_ids": [],
      "position": 51513,
      "parent_fls_id": "fls_ahmnqhm8anlb",
      "sibling_fls_ids": [
        "fls_h4k49eadninz",
        "fls_cdx9zb1yxcc8",
        "fls_wednba84zi3y",
        "fls_t2590yyvclgb",
        "fls_8wcliky2svcs",
        "fls_pgp7ezcc9lh8",
        "fls_cjq792yj6vft",
        "fls_2084b06dr0wz",
        "fls_7bb5ua4g06k8",
        "fls_go457hpaf7ov",
        "fls_nbbvukrdngev",
        "fls_riyi0gy48fxw"
      ]
    },
    {
      "fls_id": "fls_9tmvuqrmk3ug",
      "title": "Attribute ``non_exhaustive``",
      "level": 4,
      "file": "attributes",
      "content": "Attribute non_exhaustive\n\nAttribute non_exhaustive shall apply to [enum type]s,\n[enum variant]s, and [struct type]s.\n\nAttribute :dc:`non_exhaustive` indicates that the related\nabstract data type or enum variant may have more [field]s or\n[enum variant]s added in the future. A type subject to attribute\nnon_exhaustive is referred to as a non-exhaustive type.\n\nA non-exhaustive type shall not be constructed outside of its defining\ncrate.\n\nAn enum variant subject to attribute non_exhaustive is referred\nto as a non-exhaustive variant.\n\nA non-exhaustive variant shall not be constructed outside of its defining\ncrate.\n\nPattern matching a non-exhaustive variant shall require a\nstruct pattern with a rest pattern outside its defining crate.\n\nPattern matching a non-exhaustive variant does not contribute towards\nthe exhaustiveness of [match arm]s.",
      "paragraph_ids": [
        "fls_szvrd79cgzsg",
        "fls_1of56vl2ewq0",
        "fls_hkyzdmmdyoin",
        "fls_7b0fvwrmz0mh",
        "fls_oqfrg9tqgaj8",
        "fls_aql3c89840ix",
        "fls_cez7yxfc376c"
      ],
      "position": 51569,
      "parent_fls_id": "fls_r3zwgf9sg1xp",
      "sibling_fls_ids": []
    },
    {
      "fls_id": "fls_3v733mnewssy",
      "title": "Concurrency",
      "level": 1,
      "file": "concurrency",
      "content": "Concurrency\n\nThe Rust programming language provides features for concurrent programming\nwithout [data race]s, whose rules are presented in this chapter.\n\nA data race is a scenario where two or more threads access a shared memory\nlocation concurrently without any synchronization, where one of the accesses is\na modification.\n\nIt is undefined behavior if two or more threads engage in a data race.",
      "paragraph_ids": [
        "fls_opt7v0mopxc8",
        "fls_tx4b8r6i93n4",
        "fls_isypweqewe78"
      ],
      "position": 125,
      "parent_fls_id": null,
      "sibling_fls_ids": [
        "fls_l21tjqjkkaa0",
        "fls_gvwd0kf72jt",
        "fls_gdeyap4or1db",
        "fls_dzq9cdz4ibsz",
        "fls_ckvjj4tt1hh2",
        "fls_osd6c4utyjb3",
        "fls_qcb1n9c0e5hz",
        "fls_48qldfwwh493",
        "fls_y2k5paj8m8ug",
        "fls_fk2m2irwpeof",
        "fls_z1il3w9nulzy",
        "fls_wb86edg02t6a",
        "fls_411up5z0b6n6",
        "fls_83182bfa9uqb",
        "fls_ronnwodjjjsh",
        "fls_xgqh0ju6bmbn",
        "fls_hdwwrsyunir",
        "fls_wdicg3sqa98e",
        "fls_vgb6ev541b2r",
        "fls_EBwqH60SUHiN",
        "fls_jep7p27kaqlp",
        "fls_94a8v54bufn8"
      ]
    },
    {
      "fls_id": "fls_eiw4by8z75di",
      "title": "Send and Sync",
      "level": 2,
      "file": "concurrency",
      "content": "Send and Sync\n\nThe Rust programming language provides the core::marker::Send and\ncore::marker::Sync [trait]s for preventing data races at the\ntype level.\n\nA send type is a type that implements the core::marker::Send\ntrait.\n\nAn abstract data type automatically implements the\ncore::marker::Send trait if the [type]s of all its\n[field]s are [send type]s.\n\nA send type shall have [value]s that are safe to transfer across\nthread boundaries.\n\nA sync type is a type that implements the core::marker::Sync\ntrait.\n\nAn abstract data type automatically implements the\ncore::marker::Sync trait if the [type]s of all its\n[field]s are [sync type]s.\n\nA sync type shall have [value]s that are allowed to be shared across\nmultiple threads at any given time without incurring data races.",
      "paragraph_ids": [
        "fls_n5l17mlglq11",
        "fls_2jujsujpjp3w",
        "fls_cax6fe4em23k",
        "fls_4ypqdehn7b0v",
        "fls_dekskhk4g895",
        "fls_y0iqr5ibnbfe",
        "fls_zgemofbs5q2x"
      ],
      "position": 702,
      "parent_fls_id": "fls_3v733mnewssy",
      "sibling_fls_ids": [
        "fls_vyc9vcuamlph",
        "fls_mtuwzinpfvkl"
      ]
    },
    {
      "fls_id": "fls_vyc9vcuamlph",
      "title": "Atomics",
      "level": 2,
      "file": "concurrency",
      "content": "Atomics\n\nAn atomic type is a type defined in module\ncore::sync::atomic. [Atomic type]s provide primitive shared-memory\ncommunication between threads.\n\n[Atomic type]s are related to [type]s as follows:",
      "paragraph_ids": [
        "fls_3pjla9s93mhd",
        "fls_wn4ynaio8u47",
        "fls_q7mn6pdd8bix",
        "fls_jx0784jzxy00",
        "fls_vzuwnpx7mt08",
        "fls_cpcd0vexfbhj",
        "fls_jt7rfq9atbiv",
        "fls_2hqmfwswc6k",
        "fls_5ab2sw3gwmt3",
        "fls_w2mw833g28eb",
        "fls_mjq1l1y0vmz4",
        "fls_906978wtss6n",
        "fls_4urmnh4mfehl",
        "fls_2qkrcd5eovpe",
        "fls_cry1e78gp19q"
      ],
      "position": 1853,
      "parent_fls_id": "fls_3v733mnewssy",
      "sibling_fls_ids": [
        "fls_eiw4by8z75di",
        "fls_mtuwzinpfvkl"
      ]
    },
    {
      "fls_id": "fls_mtuwzinpfvkl",
      "title": "Asynchronous Computation",
      "level": 2,
      "file": "concurrency",
      "content": "Asynchronous Computation\n\nThe Rust programming language provides asynchronous computation through\nmodule core::task and the core::future::Future trait.\n\nA future represents a value of a type that implements the\ncore::future::Future trait which may not have finished computing\nyet.\n\nThe computed value of a future is obtained by using an\nawait expression or by invoking core::future::Future::poll.\n\ncore::future::Future::poll shall not be invoked on a future that has\nalready returned core::task::Poll::Ready.",
      "paragraph_ids": [
        "fls_g40xp4andj5g",
        "fls_fte085hi1yqj",
        "fls_7muubin2wn1v",
        "fls_ftzey2156ha"
      ],
      "position": 3371,
      "parent_fls_id": "fls_3v733mnewssy",
      "sibling_fls_ids": [
        "fls_eiw4by8z75di",
        "fls_vyc9vcuamlph"
      ]
    },
    {
      "fls_id": "fls_gdeyap4or1db",
      "title": "Entities and Resolution",
      "level": 1,
      "file": "entities-and-resolution",
      "content": "Entities and Resolution",
      "paragraph_ids": [],
      "position": 125,
      "parent_fls_id": null,
      "sibling_fls_ids": [
        "fls_l21tjqjkkaa0",
        "fls_gvwd0kf72jt",
        "fls_3v733mnewssy",
        "fls_dzq9cdz4ibsz",
        "fls_ckvjj4tt1hh2",
        "fls_osd6c4utyjb3",
        "fls_qcb1n9c0e5hz",
        "fls_48qldfwwh493",
        "fls_y2k5paj8m8ug",
        "fls_fk2m2irwpeof",
        "fls_z1il3w9nulzy",
        "fls_wb86edg02t6a",
        "fls_411up5z0b6n6",
        "fls_83182bfa9uqb",
        "fls_ronnwodjjjsh",
        "fls_xgqh0ju6bmbn",
        "fls_hdwwrsyunir",
        "fls_wdicg3sqa98e",
        "fls_vgb6ev541b2r",
        "fls_EBwqH60SUHiN",
        "fls_jep7p27kaqlp",
        "fls_94a8v54bufn8"
      ]
    },
    {
      "fls_id": "fls_151r19d7xbgz",
      "title": "Entities",
      "level": 2,
      "file": "entities-and-resolution",
      "content": "Entities\n\nAn entity is a construct that can be referred to within program text,\nusually via a field access expression or a path.\n\nA name is an identifier that refers to an entity.\n\nA declaration is a construct that introduces a name for an\nentity.\n\nAn explicitly declared entity is an entity that has a\ndeclaration. The following entities <entity> are\nexplicitly declared entities <explicitly declared entity>:\n\n* [Associated item]s,\n\n* [Binding]s,\n\n* [Constant]s,\n\n* [Declarative macro]s,\n\n* [Enum type]s,\n\n* [Enum variant]s,\n\n* [Field]s,\n\n* [Function]s,\n\n* [Generic parameter]s,\n\n* [Implementation]s,\n\n* [Label]s,\n\n* [Module]s,\n\n* [Static]s,\n\n* [Struct type]s,\n\n* [Trait]s,\n\n* [Type alias]es,\n\n* [Union type]s.\n\nAn implicitly declared entity is an entity that lacks an explicit\ndeclaration. The following entities <entity> are\nimplicitly declared entities <implicitly declared entity>:\n\n* [Built-in attribute]s.\n\n* Language prelude entities <entity>.",
      "paragraph_ids": [
        "fls_x7j6wcigqt7u",
        "fls_40d2g0hvq2il",
        "fls_lcca91wjwnpx",
        "fls_94l2d7ti0hjw",
        "fls_kvdqmo8gmdxi",
        "fls_b3cdg74utyvo",
        "fls_njcmeqxzvfsa",
        "fls_63ul8sgf6dgr",
        "fls_6hxf0rn9j1sr",
        "fls_2qitjk5ssaau",
        "fls_4li2c5qc31c7",
        "fls_nq8n7w2s3bja",
        "fls_jv7qi34flit0",
        "fls_rutlgmzh3tnz",
        "fls_1owx5ch7sidm",
        "fls_8ldy7lec9bcd",
        "fls_3mt2p4ssqt0a",
        "fls_qqwu3e98lktb",
        "fls_fup6984lxdfy",
        "fls_ji9iem1c7ekq",
        "fls_v7w8ptbyxv9w",
        "fls_ig1l38gpy5gy",
        "fls_ed0t6u7fo3fi",
        "fls_gjps01c8l6aa"
      ],
      "position": 197,
      "parent_fls_id": "fls_gdeyap4or1db",
      "sibling_fls_ids": [
        "fls_jdknpu3kf865",
        "fls_9i5msiuuyihf",
        "fls_izl8iuhoz9e0",
        "fls_dq403wq5yrs",
        "fls_ld0ize96cm6m",
        "fls_9gprp17h6t1q",
        "fls_ydmnb7qnmzzq",
        "fls_40xoego2thsp"
      ]
    },
    {
      "fls_id": "fls_jdknpu3kf865",
      "title": "Visibility",
      "level": 2,
      "file": "entities-and-resolution",
      "content": "Visibility\n\n CratePublicModifier ::=\n $$pub$$ $$($$ $$crate$$ $$)$$\n\n SelfPublicModifier ::=\n $$pub$$ $$($$ $$self$$ $$)$$\n\n SimplePathPublicModifier ::=\n $$pub$$ $$($$ $$in$$ SimplePath $$)$$\n\n SimplePublicModifier ::=\n $$pub$$\n\n SuperPublicModifier ::=\n $$pub$$ $$($$ $$super$$ $$)$$\n\nVisibility is a property of [field]s and [item]s that determines\nwhich [module]s can refer to the name of the field or item.\n\nPublic visibility is a kind of visibility that allows for a name\nto be referred to from arbitrary module M as long as the ancestor\n[module]s of the related entity can be referred to from M.\n\nPrivate visibility is a kind of visibility that allows a name\nto be referred to only by the current module of the entity, and its\ndescendant [module]s.\n\nA visibility modifier sets the visibility of a name.\n\nA crate public modifier is a visibility modifier that grants a\nname public visibility within the current crate only.\n\nA self public modifier is a visibility modifier that grants a\nname private visibility. A self public modifier is equivalent\nto a simple path public modifier where the simple path denotes\nkeyword self.\n\nA simple path public modifier is a visibility modifier that grants a\nname public visibility within the provided simple path only.\n\nThe simple path of a simple path public modifier shall start\nwith a path segment expressed by either keyword crate,\nkeyword self, or keyword super.\n\nThe simple path of a simple path public modifier shall resolve to\nan ancestor module of the current module or the current module\nitself.\n\nA simple public modifier is a visibility modifier that grants a\nname public visibility.\n\nA super public modifier is a visibility modifier that grants a\nname public visibility within the parent module only. A\nsuper public modifier is equivalent to a simple path public modifier\nwhere the simple path denotes keyword super.\n\nAn external item, a field, or an item that appears without a\nvisibility modifier has private visibility by default.\n\nAn associated item of a trait has the same visibility as the\ntrait.\n\nAn enum variant and its [field]s have the same visibility as the\ncontaining enum type.",
      "paragraph_ids": [
        "fls_7kpepal8ghuj",
        "fls_qo0itr5il1kk",
        "fls_knjruq5wppv",
        "fls_t7i4n19qdgn4",
        "fls_aa4f3rvir9lm",
        "fls_tnh7o3pb4e22",
        "fls_yymgpyi67dty",
        "fls_hc121mxknq03",
        "fls_icztzxjpm1du",
        "fls_np8aghofjqhm",
        "fls_quzvhzpr0124",
        "fls_utgjx6l5zwfl",
        "fls_jifg2st5bfd6",
        "fls_dm0xr424ine1"
      ],
      "position": 2070,
      "parent_fls_id": "fls_gdeyap4or1db",
      "sibling_fls_ids": [
        "fls_151r19d7xbgz",
        "fls_9i5msiuuyihf",
        "fls_izl8iuhoz9e0",
        "fls_dq403wq5yrs",
        "fls_ld0ize96cm6m",
        "fls_9gprp17h6t1q",
        "fls_ydmnb7qnmzzq",
        "fls_40xoego2thsp"
      ]
    },
    {
      "fls_id": "fls_9i5msiuuyihf",
      "title": "Paths",
      "level": 2,
      "file": "entities-and-resolution",
      "content": "Paths\n\n SimplePathSegment ::=\n Identifier\n | $$crate$$\n | $$$crate$$\n | $$self$$\n | $$super$$\n\n SimplePathList ::=\n SimplePath ($$,$$ SimplePath)* $$,$$?\n\n QualifiedType ::=\n $$<$$ TypeSpecification QualifyingTrait? $$>$$\n\n QualifyingTrait ::=\n $$as$$ TypePath\n\n UnqualifiedPathExpression ::=\n $$::$$? PathExpressionSegment ($$::$$ PathExpressionSegment)*\n\n PathExpressionSegment ::=\n PathSegment ($$::$$ GenericArgumentList)?\n\n PathSegment ::=\n SimplePathSegment\n | $$Self$$\n\n QualifiedPathExpression ::=\n QualifiedType ($$::$$ PathExpressionSegment)+\n\n TypePath ::=\n $$::$$? TypePathSegment ($$::$$ TypePathSegment)*\n\n TypePathSegment ::=\n PathSegment $$::$$? (GenericArgumentList | QualifiedFnTrait)?\n\n QualifiedFnTrait ::=\n $$($$ TypeSpecificationList? $$)$$ ReturnType?\n\n QualifiedTypePath ::=\n QualifiedType ($$::$$ TypePathSegment)+\n\nA path is a sequence of [path segment]s logically separated by\nnamespace qualifier :: that resolves to an entity.\n\nA path segment is an element of a path.\n\nA path is subject to path resolution.\n\nIf a path segment is expressed as either keyword crate,\nkeyword $crate, keyword self, or keyword Self, then\nthe path segment shall be the first path segment of a path.\n\nA path that starts with a path segment that is expressed as\nkeyword $crate shall appear only within a macro transcriber.\n\nIf a path segment is expressed as keyword super, then the\npath segment shall either be the first path segment of a path,\nor the previous path segment of the path shall also be expressed as\nkeyword super.\n\nA global path is a path that starts with namespace qualifier\n::.\n\nA simple path is a path whose [path segment]s consist of either\n[identifier]s or certain [keyword]s as defined in the syntax rules\nabove.\n\nA path prefix is a path with its last path segment and\nnamespace qualifier :: stripped.\n\nIf a simple path appears in a use import and starts with a\npath segment expressed as either keyword crate, keyword\n$crate, keyword self, or keyword super, then the\npath shall be the simple path prefix of a glob import or a\nnesting import, or the simple path of a simple import.\n\nIf a simple path appears in a use import and starts with a\npath segment expressed as keyword self, then the path shall\nbe part of the :s:`UseImportContent` of a nesting import as long as the\npath is a single segment path.\n\nA simple path is subject to simple path resolution.\n\nA single segment path is a path consisting of exactly one\npath segment.\n\nA multi segment path is a path consisting of more than one\npath segment.\n\nAn unqualified path expression is a path expression without a qualified type.\n\nA path expression is subject to path expression resolution.\n\nA type path is a path that acts as a type specification.\n\nA type path is subject to type path resolution.\n\nA qualifying trait is a trait that imposes a restriction on a\nqualified type.\n\nA qualifying trait shall resolve to a trait.\n\nA qualified type is a type that is restricted to a set of\n[implementation]s that exhibit implementation conformance to a\nqualifying trait.\n\nA qualified type shall resolve to a type.\n\nA qualified type shall implement its related qualifying trait.\n\nA qualified path expression is a path expression that resolves\nthrough a qualified type.\n\nA qualified type path is a type path that resolves through a\nqualified type.\n\nAn associated type projection is a qualified type path of the form\n<type as trait>::associated_type, where type is a type, trait\nis a qualifying trait, and associated type is an associated type.\n\nA qualified fn trait is a construct that refers to the\ncore::ops::Fn, core::ops::FnMut, or core::ops::FnOnce\ntrait.\n\nIf a path contains a path segment with a qualified fn trait,\nthen the path segment shall be the last path segment of the\npath.\n\nThe following is a simple path. See :p:`fls_jdknpu3kf865` for the\ndeclaration of crate_visible_function.\n\nThe following is an unqualified path expression with a generic argument.\n\nThe following is a type path with a generic argument.\n\nThe following is a qualified path expression. The call expression\ninvokes the associated function of S's trait implementation of\ntrait T.\n\nThe following is a qualified type path. It resolves to the associated\ntype of S's trait implementation of trait T.",
      "paragraph_ids": [
        "fls_klcltwcwrw6i",
        "fls_y1z7kougmahd",
        "fls_8q8nqfpSz7Ly",
        "fls_opn5n5t2mo3m",
        "fls_774uryecc2sx",
        "fls_7k88ypcgaoff",
        "fls_7kb6ltajgiou",
        "fls_n77icl6idazp",
        "fls_YnUsdSM4x9eq",
        "fls_iuzvtr3oax1o",
        "fls_cw006jhlboa",
        "fls_kv5bpq8rf1j9",
        "fls_chtj3hcfe3ap",
        "fls_wm61yeclairz",
        "fls_nRgjCLYZL3iX",
        "fls_tvvycup09b51",
        "fls_h2zikgmazoxx",
        "fls_nj7s6xmzx55f",
        "fls_e65q3iz50j6a",
        "fls_Ai1jN5a8h3Dz",
        "fls_ybv0tdu7dnj5",
        "fls_qkYF2J7GVah8",
        "fls_QjNQbQhUcRTT",
        "fls_7sm3206va03c",
        "fls_huynsyx13gsz",
        "fls_RZvIsApi4WQm",
        "fls_f1ciozzetj5a",
        "fls_cy7vza3flqi9",
        "fls_cul31g1kkz5c",
        "fls_no853u27p4f3",
        "fls_28c21rzc6rsp",
        "fls_4s2n95h4rd1q",
        "fls_ojdntg5i79pb"
      ],
      "position": 6069,
      "parent_fls_id": "fls_gdeyap4or1db",
      "sibling_fls_ids": [
        "fls_151r19d7xbgz",
        "fls_jdknpu3kf865",
        "fls_izl8iuhoz9e0",
        "fls_dq403wq5yrs",
        "fls_ld0ize96cm6m",
        "fls_9gprp17h6t1q",
        "fls_ydmnb7qnmzzq",
        "fls_40xoego2thsp"
      ]
    },
    {
      "fls_id": "fls_izl8iuhoz9e0",
      "title": "Scopes",
      "level": 2,
      "file": "entities-and-resolution",
      "content": "Scopes\n\nA scope is a region of program text where an entity can be referred\nto. An entity is in scope when it can be referred to.",
      "paragraph_ids": [
        "fls_5x5xykocwyiy"
      ],
      "position": 12577,
      "parent_fls_id": "fls_gdeyap4or1db",
      "sibling_fls_ids": [
        "fls_151r19d7xbgz",
        "fls_jdknpu3kf865",
        "fls_9i5msiuuyihf",
        "fls_dq403wq5yrs",
        "fls_ld0ize96cm6m",
        "fls_9gprp17h6t1q",
        "fls_ydmnb7qnmzzq",
        "fls_40xoego2thsp"
      ]
    },
    {
      "fls_id": "fls_6ozthochxz1i",
      "title": "Binding Scopes",
      "level": 3,
      "file": "entities-and-resolution",
      "content": "Binding Scopes\n\nA binding scope is a scope for [binding]s.\n\nThe binding of a closure parameter is in scope within the\nrelated closure body.\n\nThe binding of a function parameter is in scope within the\nrelated function body.\n\nThe binding of a for loop or a while let loop is in scope\nwithin the related loop body.\n\nThe binding of an if let expression is in scope within the\nrelated block expression.\n\nThe binding of a let statement is in scope after the related\nlet statement, until the end of the block expression where the\nrelated let statement appears.\n\nThe binding of a match arm is in scope within its related\n[expression]s and related match arm guard.\n\nA binding declared outside of a const block expression is not in\nscope within such a const block expression.",
      "paragraph_ids": [
        "fls_ncg9etb3x7k0",
        "fls_u52mx4xw8zod",
        "fls_t9mk8kasobea",
        "fls_h9cvs854ae34",
        "fls_vl1qk0odouyb",
        "fls_74nk389rk075",
        "fls_xbnki64un70v",
        "fls_eBacCVlDaKYK"
      ],
      "position": 12809,
      "parent_fls_id": "fls_izl8iuhoz9e0",
      "sibling_fls_ids": [
        "fls_ftphlagzd2te",
        "fls_m0z7omni9hp0",
        "fls_769b4p8v3cwu",
        "fls_kgbi26212eof",
        "fls_octf6sf7yso",
        "fls_lnpyb285qdiy"
      ]
    },
    {
      "fls_id": "fls_ftphlagzd2te",
      "title": "Generic Parameter Scope",
      "level": 3,
      "file": "entities-and-resolution",
      "content": "Generic Parameter Scope\n\nA generic parameter scope is a scope for [generic parameter]s.\n\nA generic parameter is in scope of a :s:`GenericParameterList`.\n\nA generic parameter of an enum type is in scope within the\nrelated [enum variant]s and where clause.\n\nA generic parameter of a function pointer type is in scope\nwithin the related type specification.\n\nA generic parameter of an implementation is in scope within the\nrelated implementation body and where clause.\n\nA generic parameter of a struct type is in scope within the\nrelated [field]s and where clause.\n\nA generic parameter of a trait is in scope within the related\ntrait body and where clause.\n\nA generic parameter of a trait bound is in scope within the\nrelated [generic parameter]s or the related type path.\n\nA generic parameter of a type alias is in scope within the\nrelated initialization type and where clause.\n\nA generic parameter of a type bound predicate is in scope within\nthe related :s:`TypeBoundList`.\n\nA generic parameter of a union type is in scope within the\nrelated [field]s and where clause.\n\nA generic parameter is not in scope within nested [item]s,\nexcept within [associated item]s.",
      "paragraph_ids": [
        "fls_amoh8r4gghyj",
        "fls_6o38qhbna46z",
        "fls_jqevvpndxzdz",
        "fls_t9ztg017itkp",
        "fls_pmo939jw9m1m",
        "fls_67dtv1z3arbl",
        "fls_y8j4isk9libl",
        "fls_ow5ih7q3xxfx",
        "fls_h9rpwxpz72v0",
        "fls_3qm3vh97bvpb",
        "fls_xuxbpv5b2ym9",
        "fls_95z5mytvfjia"
      ],
      "position": 14001,
      "parent_fls_id": "fls_izl8iuhoz9e0",
      "sibling_fls_ids": [
        "fls_6ozthochxz1i",
        "fls_m0z7omni9hp0",
        "fls_769b4p8v3cwu",
        "fls_kgbi26212eof",
        "fls_octf6sf7yso",
        "fls_lnpyb285qdiy"
      ]
    },
    {
      "fls_id": "fls_m0z7omni9hp0",
      "title": "Item Scope",
      "level": 3,
      "file": "entities-and-resolution",
      "content": "Item Scope\n\nAn item scope is a scope for [item]s.\n\nAn item declared within the block expression of an\nexpression-with-block is in scope within the related\nblock expression.\n\nAn item declared within a module is in scope within the\nrelated module. Such an item is not in scope within nested\n[module]s.",
      "paragraph_ids": [
        "fls_p5o243hhe1y3",
        "fls_huvo0mp2i6fb",
        "fls_x8r0oppuc1t6"
      ],
      "position": 15770,
      "parent_fls_id": "fls_izl8iuhoz9e0",
      "sibling_fls_ids": [
        "fls_6ozthochxz1i",
        "fls_ftphlagzd2te",
        "fls_769b4p8v3cwu",
        "fls_kgbi26212eof",
        "fls_octf6sf7yso",
        "fls_lnpyb285qdiy"
      ]
    },
    {
      "fls_id": "fls_769b4p8v3cwu",
      "title": "Label Scope",
      "level": 3,
      "file": "entities-and-resolution",
      "content": "Label Scope\n\nA label scope is a scope for [label]s.\n\nA label is in scope within the block expression of the related\nloop expression.\n\nA label is not in scope within nested [async block]s,\n[closure expression]s, [constant context]s, and [item]s.",
      "paragraph_ids": [
        "fls_96kczd4zhpco",
        "fls_8sevg1sa82h4",
        "fls_ep5smja1rxdv"
      ],
      "position": 16277,
      "parent_fls_id": "fls_izl8iuhoz9e0",
      "sibling_fls_ids": [
        "fls_6ozthochxz1i",
        "fls_ftphlagzd2te",
        "fls_m0z7omni9hp0",
        "fls_kgbi26212eof",
        "fls_octf6sf7yso",
        "fls_lnpyb285qdiy"
      ]
    },
    {
      "fls_id": "fls_kgbi26212eof",
      "title": "Self Scope",
      "level": 3,
      "file": "entities-and-resolution",
      "content": "Self Scope\n\nA Self scope is a scope for Self.\n\nSelf of an enum type is in scope within the related\n[enum variant]s, [generic parameter]s, and where clause.\n\nSelf of an implementation is in scope within the related\n[generic parameter]s, implementation body, and where clause.\n\nSelf of a struct type is in scope within the related\n[field]s, [generic parameter]s, and where clause.\n\nSelf of a trait is in scope within the related\n[generic parameter]s, trait body, and where clause.\n\nSelf of a union type is in scope within the related\n[field]s, [generic parameter]s, and where clause.\n\nSelf is not in scope within [attribute]s.",
      "paragraph_ids": [
        "fls_kgt81m4f72ne",
        "fls_kxdwq4b136tl",
        "fls_nf4g82gi12ij",
        "fls_dy4gyepebe7b",
        "fls_cha4ddwfqwvj",
        "fls_ql4i021ut2n8",
        "fls_mj9vlxnf44oi"
      ],
      "position": 16720,
      "parent_fls_id": "fls_izl8iuhoz9e0",
      "sibling_fls_ids": [
        "fls_6ozthochxz1i",
        "fls_ftphlagzd2te",
        "fls_m0z7omni9hp0",
        "fls_769b4p8v3cwu",
        "fls_octf6sf7yso",
        "fls_lnpyb285qdiy"
      ]
    },
    {
      "fls_id": "fls_octf6sf7yso",
      "title": "Textual Macro Scope",
      "level": 3,
      "file": "entities-and-resolution",
      "content": "Textual Macro Scope\n\nA textual macro scope is a scope for [declarative macro]s.\n\nA declarative macro is in scope after the related macro\ndeclaration, until the end of the block expression or the enclosing\nmodule where the macro declaration appears.\n\nIf the textual macro scope is introduced by a module and the\nmodule is subject to attribute macro_use, then the\ntextual macro scope extends until the end of the scope introduced by\nthe enclosing block expression or module.",
      "paragraph_ids": [
        "fls_xkh8cqubhxad",
        "fls_iec3otx863yp",
        "fls_cbfuh9y87y6i"
      ],
      "position": 17749,
      "parent_fls_id": "fls_izl8iuhoz9e0",
      "sibling_fls_ids": [
        "fls_6ozthochxz1i",
        "fls_ftphlagzd2te",
        "fls_m0z7omni9hp0",
        "fls_769b4p8v3cwu",
        "fls_kgbi26212eof",
        "fls_lnpyb285qdiy"
      ]
    },
    {
      "fls_id": "fls_lnpyb285qdiy",
      "title": "Scope Hierarchy",
      "level": 3,
      "file": "entities-and-resolution",
      "content": "Scope Hierarchy\n\nThe scope hierarchy reflects the nesting of [scope]s as introduced\nby [scoping construct]s. An inner scope introduced by a nested\nscoping construct is the child of an outer scope introduced by an\nenclosing scoping construct.\n\nA scoping construct is a construct that introduces [scope]s\ninto the scope hierarchy. The following [construct]s are\n[scoping construct]s:\n\n* [Block expression]s,\n\n* [Closure expression]s,\n\n* [Declarative macro]s,\n\n* Enum type [declaration]s,\n\n* Function [declaration]s,\n\n* Function pointer type specifications <type specification>,\n\n* [If let expression]s,\n\n* Implementation [declaration]s,\n\n* [Let statement]s,\n\n* [Loop expression]s,\n\n* [Match arm]s,\n\n* Module [declaration]s,\n\n* Struct type [declaration]s,\n\n* [Trait bound]s,\n\n* Trait [declaration]s,\n\n* Type alias [declaration]s,\n\n* [Type bound predicate]s,\n\n* Union type [declaration]s.\n\nA closure expression introduces a binding scope into the\nscope hierarchy.\n\nA declarative macro introduces a textual macro scope into the\nscope hierarchy.\n\nThe declaration of an enum type introduces a\ngeneric parameter scope and a Self scope into the\nscope hierarchy.\n\nThe declaration of a function introduces a binding scope and a\ngeneric parameter scope into the scope hierarchy.\n\nThe type specification of a function pointer type introduces a\ngeneric parameter scope into the scope hierarchy.\n\nAn if let expression introduces a binding scope into the\nscope hierarchy.\n\nThe declaration of an implementation introduces a\ngeneric parameter scope and a Self scope into the\nscope hierarchy.\n\nA let statement introduces a binding scope into the\nscope hierarchy.\n\nA for loop expression or a while let loop expression introduces a\nbinding scope and a label scope into the scope hierarchy.\n\nAn infinite loop expression or a while loop expression introduces a\nlabel scope into the scope hierarchy.\n\nA match arm introduces a binding scope into the\nscope hierarchy.\n\nThe declaration of a module introduces an item scope into the\nscope hierarchy.\n\nThe declaration of a struct type introduces a\ngeneric parameter scope and a Self scope into the\nscope hierarchy.\n\nThe declaration of a trait introduces a generic parameter scope\nand a Self scope into the scope hierarchy.\n\nA trait bound introduces a generic parameter scope into the\nscope hierarchy.\n\nThe declaration of a type alias introduces a\ngeneric parameter scope.\n\nA type bound predicate introduces a generic parameter scope into the\nscope hierarchy.\n\nThe declaration of a union type introduces a\ngeneric parameter scope and a Self scope into the\nscope hierarchy.",
      "paragraph_ids": [
        "fls_4o7vfo6v39l7",
        "fls_ns4eog3od4kw",
        "fls_kqmykyzdb1k6",
        "fls_g86d5v14sxxv",
        "fls_ldwencd8zp9a",
        "fls_jz7hgkvocc9r",
        "fls_p4g8sxba7at9",
        "fls_d1cp5pt5wn0z",
        "fls_ibmm8y748z4",
        "fls_39011vsy2vxx",
        "fls_m81hyd154yun",
        "fls_fvgzmsaox4z3",
        "fls_rj8uld11o1br",
        "fls_hyp4dnpqe620",
        "fls_zgied4qysk2a",
        "fls_cn6dzmrxdp1w",
        "fls_9n7m0tv7w2np",
        "fls_sj2ivbf2l2dp",
        "fls_cejfio3ddy0j",
        "fls_j3rot386teec",
        "fls_nuobrpnymym1",
        "fls_r0x9sw7dwnww",
        "fls_ve7svuy7xvh0",
        "fls_pvfqhtts3qsa",
        "fls_9k9hourczbv7",
        "fls_p6wiuhkeypzs",
        "fls_34usianesmf6",
        "fls_n1a41d8i0rot",
        "fls_amhi3d9dd3i3",
        "fls_nu8xj3vza55j",
        "fls_fiyj50u6cg2n",
        "fls_azjx3y5yezoi",
        "fls_puly43s4x360",
        "fls_pxtlu7ud6w2h",
        "fls_ddxxt11u0yal",
        "fls_qofr9vme46wp",
        "fls_gjvfty9m84a9",
        "fls_xr9wors6oa7w"
      ],
      "position": 18452,
      "parent_fls_id": "fls_izl8iuhoz9e0",
      "sibling_fls_ids": [
        "fls_6ozthochxz1i",
        "fls_ftphlagzd2te",
        "fls_m0z7omni9hp0",
        "fls_769b4p8v3cwu",
        "fls_kgbi26212eof",
        "fls_octf6sf7yso"
      ]
    },
    {
      "fls_id": "fls_dq403wq5yrs",
      "title": "Namespaces",
      "level": 2,
      "file": "entities-and-resolution",
      "content": "Namespaces\n\nA namespace is a logical grouping of [name]s such that the occurrence\nof a name in one namespace does not conflict with an occurrence of\nthe same name in another namespace.\n\n[Name]s are segregated into one of five [namespace]s based on the\nkind of entity the name refers to.\n\nA label namespace contains [label]s.\n\nA lifetime namespace contains the [name]s of\n[lifetime parameter]s.\n\nA macro namespace contains the [name]s of the following kinds of\nentities <entity>:\n\n* [Attribute macro]s,\n\n* [Built-in attribute]s,\n\n* [Declarative macro]s,\n\n* [Derive macro]s,\n\n* [Function-like macro]s.\n\nA type namespace contains the [name]s of the following kinds of\nentities <entity>:\n\n* [Associated type]s,\n\n* bool [type]s,\n\n* [Enum type]s,\n\n* [Enum variant]s,\n\n* [Module]s,\n\n* [Numeric type]s,\n\n* Self,\n\n* [Struct type]s,\n\n* [Textual type]s,\n\n* [Trait]s,\n\n* [Type alias]es,\n\n* [Type parameter]s,\n\n* [Union type]s.\n\nA value namespace contains the [name]s of the following kinds of\nentities <entity>:\n\n* [Associated constant]s,\n\n* [Associated function]s,\n\n* [Binding]s,\n\n* [Constant]s,\n\n* [Constant parameter]s,\n\n* Enum variant constructors,\n\n* [Function]s,\n\n* Self constructors,\n\n* [Static]s,\n\n* Struct constructors.\n\nThe [name]s of the following kinds of entities <entity> are not part\nof any namespace:\n\n* [Enum field]s,\n\n* [Struct field]s,\n\n* [Union field]s.",
      "paragraph_ids": [
        "fls_1d4jm61qnt4l",
        "fls_avsua7bho205",
        "fls_9e3xeza853wx",
        "fls_w625tk3ogdui",
        "fls_crwfafrmydr7",
        "fls_t8fcpm8ldv1y",
        "fls_7pkex797rkeu",
        "fls_v32f2evgqt5q",
        "fls_f6yrzwu6yi30",
        "fls_nk0swexy2ztm",
        "fls_ckptn88o6lla",
        "fls_3ma5v1fop98p",
        "fls_nj7sep7ht7lg",
        "fls_g8h6t5x6yprm",
        "fls_2l1o7vqfr4m7",
        "fls_6q8rjv1jmu84",
        "fls_lx2tx1jt8t3a",
        "fls_mo00df28t7c1",
        "fls_8o3izim4zf8t",
        "fls_fweohszgbuj4",
        "fls_ry02dzisxz3h",
        "fls_dcz1bxjjfsq",
        "fls_wt9kgsi6n6ep",
        "fls_w29t5njbe46s",
        "fls_u1533bngb0yv",
        "fls_e8v4g45v5ry2",
        "fls_pq8bzav84q3z",
        "fls_ttr6v8ca4av0",
        "fls_aivi97hhfxy2",
        "fls_pie4ltdtzkl3",
        "fls_qmf7lk6h96sv",
        "fls_ufp3btk8pet5",
        "fls_t3bnpkfazw4z",
        "fls_y0shlli54n5y",
        "fls_tghgxcju5u2t",
        "fls_yesesxynpq6s",
        "fls_40o8y6exr3df",
        "fls_y76o5ug7dtv",
        "fls_3np518s1su4w"
      ],
      "position": 22578,
      "parent_fls_id": "fls_gdeyap4or1db",
      "sibling_fls_ids": [
        "fls_151r19d7xbgz",
        "fls_jdknpu3kf865",
        "fls_9i5msiuuyihf",
        "fls_izl8iuhoz9e0",
        "fls_ld0ize96cm6m",
        "fls_9gprp17h6t1q",
        "fls_ydmnb7qnmzzq",
        "fls_40xoego2thsp"
      ]
    },
    {
      "fls_id": "fls_ld0ize96cm6m",
      "title": "Preludes",
      "level": 2,
      "file": "entities-and-resolution",
      "content": "Preludes\n\nA prelude is a collection of entities <entity> that are automatically\nbrought in scope of every module in a crate. Such\nentities <entity> are referred to as\nprelude entities <prelude entity>. The name of a prelude entity\nis referred to as a prelude name.\n\nThe core prelude is a prelude that brings in scope of every\nmodule all re-exported entities <entity> from the\ncore::prelude::rust_2021 module.\n\nAn external prelude is a prelude that brings in scope of the\ncrate root module the entities <entity> of the [crate]s imported\nusing external [crate import]s or supplied by a tool. If the external\ncrate import uses a renaming, then the identifier of the\nrenaming is instead added to the external prelude. The core\ncrate is always added to the external prelude unless the crate\nroot is subject to attribute no_core.\n\nThe language prelude is a prelude that brings in scope of every\nmodule the following entities <entity>:\n\n* Boolean type bool.\n\n* [Built-in attribute]s.\n\n* [Floating-point type]s f32 and f64.\n\n* [Integer type]s i8, i16, i32, i64, i128,\n isize, u8, u16, u32, u64, u128, and usize.\n\n* [Textual type]s char and str.\n\nThe macro_use prelude is a prelude that brings in scope of the\ncrate root module the entities <entity> of [macro]s from\nexternal [crate]s that were imported using an external crate import.",
      "paragraph_ids": [
        "fls_po4gw6t2ptwu",
        "fls_n4102qskkmz2",
        "fls_atvnwly4w8g2",
        "fls_pbc7ktlu0pl",
        "fls_frjv68kqqxfh",
        "fls_rf6a2ae3y7vu",
        "fls_sxnnkzmuvexa",
        "fls_qsyorqjkdh2t",
        "fls_aolj6abvp9sa",
        "fls_of4n3vv15l5z"
      ],
      "position": 25259,
      "parent_fls_id": "fls_gdeyap4or1db",
      "sibling_fls_ids": [
        "fls_151r19d7xbgz",
        "fls_jdknpu3kf865",
        "fls_9i5msiuuyihf",
        "fls_izl8iuhoz9e0",
        "fls_dq403wq5yrs",
        "fls_9gprp17h6t1q",
        "fls_ydmnb7qnmzzq",
        "fls_40xoego2thsp"
      ]
    },
    {
      "fls_id": "fls_9gprp17h6t1q",
      "title": "Use Imports",
      "level": 2,
      "file": "entities-and-resolution",
      "content": "Use Imports\n\n UseImportContent ::=\n GlobImport\n | NestingImport\n | SimpleImport\n\n GlobImport ::=\n SimplePathPrefix? $$*$$\n\n NestingImport ::=\n SimplePathPrefix? $${$$ UseImportContentList? $$}$$\n\n SimpleImport ::=\n SimplePath Renaming?\n\n SimplePathPrefix ::=\n SimplePath? $$::$$\n\n UseImportContentList ::=\n UseImportContent ($$,$$ UseImportContent)* $$,$$?\n\nA use import brings entities <entity> in scope within the\nblock expression of an expression-with-block or module where the\nuse import resides.\n\nA simple path prefix is the leading simple path of a glob import\nor a nesting import.\n\nAn import path prefix is the fully constructed path prefix of a\nuse import. An import path prefix for a given\nsimple import or glob import is constructed as follows:\n\n#. Start the import path prefix as follows:\n\n * If the use import is a simple import then start with the\n [path segment]s of the simple import's simple path\n path prefix.\n\n * If the use import is a glob import then start with the\n [path segment]s of the glob import's simple path prefix.\n\n * If the use import is a nesting import then start with the\n [path segment]s of the nesting import's simple path prefix.\n\n#. Then if the current use import is the child of a nesting import,\n prepend the nesting import's simple path prefix to the\n import path prefix. Repeat this step with the nesting import as\n the current use import.\n\nA simple import is a use import that brings all entities <entity>\nit refers to into scope, optionally with a different\nname than they are declared with by using a renaming.\n\nA glob import is a use import that brings all entities <entity>\nexported by the module or enum its import path prefix resolves to\ninto scope.\n\nAn import path prefix shall resolve to a module or enum.\n\nA glob import brings [name]s into scope as follows:\n\n* If the import path prefix resolves to a module, bring all\n [name]s in the module that are visible from the location of the\n glob import into scope.\n\n* If the import path prefix resolves to an enum, bring the\n [name]s of all of the enum's [enum variant]s into scope.\n\nA simple import path is the path constructed by appending the last\npath segment of a simple import's simple path to the\nimport path prefix.\n\nA simple import brings [name]s into scope as follows:\n\n* If the simple path is keyword self and:\n\n * The simple import is in a nesting import, then bring the\n entity in type namespace that the import path prefix resolves\n to into scope.\n\n * Otherwise bring the containing module into scope.\n\n* Otherwise bring all entities <entity> that the simple import path\n resolves to that are visible from the location of the\n simple import into scope.\n\nAn Entity imported by a simple import subject to a\nrenaming with identifier is brought into scope under the\nname declared by the renaming.\n\nA trait imported by a simple import subject to a\nrenaming with character underscore _ is added into scope without\na name.\n\nA nesting import is a use import that provides a common\nsimple path prefix for its nested [use import]s.\n\nA glob import outside of a nesting import without a simple path\nprefix is rejected, but may still be consumed by [macro]s.\n\nA simple import with a simple path with a single path segment of\nkeyword self shall be subject to the following:\n\n* It shall either appear in a nesting import with a non-empty\n import path prefix, or\n\n* It shall be subject to a renaming.\n\nIt is a static error if two [glob import]s import the same name in the\nsame namespace but refer to different entities <entity> if the\nname is used or shadowed <shadowing>.\n\nIf two [glob import]s import the same entity under the same name,\nthe visibility of the name is the most permissive one.\n\nThe following is a glob import. See :p:`fls_jdknpu3kf865`\nfor the declaration of modules and functions. The imported functions\nare create_visible_function, outer_module_visible_function,\nvisible_function.\n\nThe following is a renaming import. The imported function is\nvisible_function under the name f.\n\nThe following is a selective import. The imported functions are\ncrate_visible_function and visible_function.",
      "paragraph_ids": [
        "fls_lyw4t098sxrj",
        "fls_sxo1jb25pl8a",
        "fls_WAA4WmohGu6T",
        "fls_IPYvldMqduf4",
        "fls_MOXId37fcNPY",
        "fls_2UyFcB6Our1v",
        "fls_irdKqoYzBM0M",
        "fls_gAWsqibl4GLq",
        "fls_2bkcn83smy2y",
        "fls_v3a6y2ze44v2",
        "fls_JHU0ersYB6eL",
        "fls_jlNKxkuhsvX4",
        "fls_q0KFfNALMslq",
        "fls_Hy17LzOFGfOp",
        "fls_90hQvSh7Bfyg",
        "fls_wRmvtgQkFA6w",
        "fls_kz2Gij5wHXnl",
        "fls_yY58pFpkig9o",
        "fls_ar03D5rxjzy0",
        "fls_ce73bg0BqV1X",
        "fls_FILuR3pfwjw3",
        "fls_iQOgxNihUEr7",
        "fls_ldr7tsuqw34s",
        "fls_iNUBX5fJAI1N",
        "fls_RUiFQ17bmRLt",
        "fls_hv3xT2CjZuxc",
        "fls_Pxc0Ts8Y7pfW",
        "fls_wB3fVglLOqbZ",
        "fls_zmYSBW995kSN",
        "fls_5dlnffim6fso",
        "fls_9rhflreuubhq",
        "fls_s86dgrdpl1w4"
      ],
      "position": 27232,
      "parent_fls_id": "fls_gdeyap4or1db",
      "sibling_fls_ids": [
        "fls_151r19d7xbgz",
        "fls_jdknpu3kf865",
        "fls_9i5msiuuyihf",
        "fls_izl8iuhoz9e0",
        "fls_dq403wq5yrs",
        "fls_ld0ize96cm6m",
        "fls_ydmnb7qnmzzq",
        "fls_40xoego2thsp"
      ]
    },
    {
      "fls_id": "fls_ydmnb7qnmzzq",
      "title": "Shadowing",
      "level": 2,
      "file": "entities-and-resolution",
      "content": "Shadowing\n\nShadowing is a property of [name]s. A name is said to be\nshadowed when another name with the same characters is introduced\nin the same scope within the same namespace, effectively hiding it.\nA name cannot be referred to by any means once it is shadowed.\n\nNo name shall be shadowed except for\n\n* [Prelude name]s,\n\n* The [name]s of [macro]s within textual macro scope,\n\n* The [name]s of [variable]s.\n\nA prelude name shadows other [prelude name]s depending on which\n[prelude]s are included in a module. The order of shadowing is as\nfollows, where a later prelude name shadows earlier prelude name:\n\n#. Language prelude names <prelude name>.\n\n#. Standard library prelude names <prelude name>.\n\n#. macro_use prelude names <prelude name>.\n\n#. Tool prelude names <prelude name>.\n\n#. External prelude names <prelude name>.",
      "paragraph_ids": [
        "fls_ob0riinmitkl",
        "fls_fslg89a70e3n",
        "fls_hp3f4r3399kt",
        "fls_z8qjpskt13yq",
        "fls_i0gp1y38lr73",
        "fls_7pif12rt4s4s",
        "fls_are9qz67p7b6",
        "fls_4tis5syofyg0",
        "fls_u0tsnkhacr06",
        "fls_iaklf84guczc",
        "fls_a0zovslu2v4u"
      ],
      "position": 33354,
      "parent_fls_id": "fls_gdeyap4or1db",
      "sibling_fls_ids": [
        "fls_151r19d7xbgz",
        "fls_jdknpu3kf865",
        "fls_9i5msiuuyihf",
        "fls_izl8iuhoz9e0",
        "fls_dq403wq5yrs",
        "fls_ld0ize96cm6m",
        "fls_9gprp17h6t1q",
        "fls_40xoego2thsp"
      ]
    },
    {
      "fls_id": "fls_40xoego2thsp",
      "title": "Resolution",
      "level": 2,
      "file": "entities-and-resolution",
      "content": "Resolution\n\nResolution is the process of finding a unique interpretation for a\nfield access expression, a method call expression, a call\nexpression or a path.\n\nA construct that is being resolved is said to be under resolution.\n\nA dereference type is either a reference type or a type that\nimplements the core::ops::Deref trait.\n\nA dereference type chain is a sequence of [dereference type]s. A\ndereference type chain starts with an initial dereference type. From\nthen on, the dereference type chain continues as follows:\n\n* If the previous dereference type is a reference type, then the\n dereference type chain continues with the inner type of the\n previous dereference type.\n\n* Otherwise the dereference type chain continues with type\n core::ops::Deref::Target of the previous dereference type.",
      "paragraph_ids": [
        "fls_ho4kem1slcxg",
        "fls_7le2vcdbtxbq",
        "fls_x3alg07yd7hx",
        "fls_4hulwazdu20i",
        "fls_ptocwx5p25lj",
        "fls_ygam5nisv98c"
      ],
      "position": 34681,
      "parent_fls_id": "fls_gdeyap4or1db",
      "sibling_fls_ids": [
        "fls_151r19d7xbgz",
        "fls_jdknpu3kf865",
        "fls_9i5msiuuyihf",
        "fls_izl8iuhoz9e0",
        "fls_dq403wq5yrs",
        "fls_ld0ize96cm6m",
        "fls_9gprp17h6t1q",
        "fls_ydmnb7qnmzzq"
      ]
    },
    {
      "fls_id": "fls_xcwfotmq2e5d",
      "title": "Field Resolution",
      "level": 3,
      "file": "entities-and-resolution",
      "content": "Field Resolution\n\nField resolution is a form of resolution that applies to a\nfield access expression.\n\nA candidate container type is the type of the container operand\nof a field access expression under resolution.\n\nA candidate container type chain is a sequence of\n[candidate container type]s. The candidate container type chain\nstarts with the type of the container operand of the\nfield access expression under resolution. From then on, the\ncandidate container type chain is treated as a\ndereference type chain.\n\nA candidate field is a field of a candidate container type\nthat is visible from the location of the field access expression\nunder resolution.\n\nA candidate indexed field is a candidate field whose position in the\ntype of the container operand matches the index of an\nindexed field selector.\n\nA candidate named field is a candidate field whose name matches\nthe characters of a named field selector.\n\nField resolution of a field access expression with an\nindexed field selector proceeds as follows:\n\n#. For each candidate container type of the\n candidate container type chain\n\n #. Try to locate a candidate indexed field of the\n candidate container type.\n\n #. If such a candidate indexed field exists and is visible at the point\n of the field access expression, then the field access expression\n resolves to that candidate indexed field and field resolution\n stops.\n\nField resolution of a field access expression with a\nnamed field selector proceeds as follows:\n\n#. For each candidate container type of the\n candidate container type chain\n\n #. Try to locate a candidate named field of the\n candidate container type.\n\n #. If such a candidate named field exists and is visible at the point\n of the field access expression, then the field access expression\n resolves to that candidate named field and field resolution\n stops.\n\nA field access expression shall resolve to exactly one field.",
      "paragraph_ids": [
        "fls_1nxknwjdp0am",
        "fls_j1bip4w30q8",
        "fls_jrk3gzqvqr8e",
        "fls_asn20qx16sr6",
        "fls_jzoon4x89zp7",
        "fls_r80pixfoe5hk",
        "fls_40oa0j6aiop3",
        "fls_2bp1zs7qaz7o",
        "fls_s14fegwhwnc8",
        "fls_tfjm27ydiake",
        "fls_p6hgoqo0kcx",
        "fls_e7sj392ohvbd",
        "fls_z6qt9obbhhcg",
        "fls_ljnjxex3u5o",
        "fls_nm06mru40tyg"
      ],
      "position": 35819,
      "parent_fls_id": "fls_40xoego2thsp",
      "sibling_fls_ids": [
        "fls_wqazkzle0ix9",
        "fls_TelBKNKodx3d",
        "fls_i6qzga6dyaee"
      ]
    },
    {
      "fls_id": "fls_wqazkzle0ix9",
      "title": "Method Resolution",
      "level": 3,
      "file": "entities-and-resolution",
      "content": "Method Resolution\n\nMethod resolution is a kind of resolution that applies to a\nmethod call expression.\n\nA receiver type is the type of the receiver operand\nof a method call expression.\n\nA candidate receiver type is the type of the receiver operand\nof a method call expression under resolution.\n\nA candidate receiver type chain is a sequence of\n[candidate receiver type]s. The candidate receiver type chain starts\nwith the type of the receiver operand of the\nmethod call expression under resolution. From then on, the\ncandidate receiver type chain is treated as a dereference type chain.\n\nA candidate method is a method of a candidate receiver type that\nis visible from the location of the method call expression\nunder resolution.\n\nMethod resolution proceeds as follows:\n\n#. For each candidate receiver type of the\n candidate receiver type chain\n\n #. Perform method resolution receiver candidate lookup for the\n candidate receiver type.\n\n #. If the last candidate receiver type is an array type, then\n perform method resolution receiver candidate lookup for a\n slice type where the slice type has the same element type\n as the array type.\n\nMethod resolution receiver candidate lookup for a receiver type\nproceeds as follows:\n\n#. Perform method resolution implementation candidate lookup for the\n receiver type.\n\n#. Perform method resolution implementation candidate lookup for the\n immutable borrow of the receiver type.\n\n#. Perform method resolution implementation candidate lookup for the\n mutable borrow of the receiver type.\n\nMethod resolution implementation candidate lookup for a\nreceiver type proceeds as follows:\n\n#. Perform method resolution inherent implementation candidate lookup for\n the receiver type.\n\n#. Perform method resolution trait implementation candidate lookup for the\n receiver type.\n\nMethod resolution inherent implementation candidate lookup for a\nreceiver type proceeds as follows:\n\n#. Construct the dereference type chain for the receiver type.\n\n#. For each dereference type in the dereference type chain\n\n #. For each inherent implementation in the set of\n [inherent implementation]s of the dereference type where the\n implementing type unifies <unify> with the\n dereference type\n\n #. Try to locate a candidate method in the inherent\n implementation, where the type of the self parameter\n unifies <unify> with the receiver type.\n\n #. If such a candidate method exists, then the\n method call expression resolves to that candidate method and\n method resolution stops.\n\nMethod resolution trait implementation candidate lookup for a\nreceiver type proceeds as follows:\n\n#. Construct the dereference type chain for the receiver type.\n\n#. For each dereference type in the dereference type chain\n\n #. For each trait implementation of the dereference type where the\n implemented trait is in scope\n\n #. Try to locate a candidate method in the\n trait implementation, where the type of the\n self parameter unifies <unify> with the receiver type.\n\n #. If such a candidate method exists, then the\n method call expression resolves to that candidate method and\n method resolution stops.\n\nA method call expression shall resolve to exactly one method.",
      "paragraph_ids": [
        "fls_e5a5z5yht26l",
        "fls_mbdS0xiNlj92",
        "fls_z80ylmlu1f3q",
        "fls_e1029pvq706h",
        "fls_w3ik83d43fr1",
        "fls_pybv4krsvktv",
        "fls_m2njj6no0p1i",
        "fls_16l2q1wpcnbp",
        "fls_fcnahkqxomuo",
        "fls_ii0fdpekn1qt",
        "fls_ohjmxhbw3nx3",
        "fls_lgpdicxxwq13",
        "fls_ugl3x4y3lli2",
        "fls_bb4cbmvui8fk",
        "fls_5wny1yxbyuz0",
        "fls_gsc8pt4tlsqv",
        "fls_tfglce1wuq5q",
        "fls_64bfcn9okeve",
        "fls_om90v9re8b2l",
        "fls_bsf4hy9x7c2e",
        "fls_cnn5hkf1z5q4",
        "fls_j9ho6xc2fj0w",
        "fls_1y94elgpg0uk",
        "fls_npsdxrtcslcf",
        "fls_yv5l823lwdsv",
        "fls_ckdoyvbaybe0",
        "fls_1azkiu20r0e4",
        "fls_ose5m4bhkg57",
        "fls_jw2yv23cduu4"
      ],
      "position": 38499,
      "parent_fls_id": "fls_40xoego2thsp",
      "sibling_fls_ids": [
        "fls_xcwfotmq2e5d",
        "fls_TelBKNKodx3d",
        "fls_i6qzga6dyaee"
      ]
    },
    {
      "fls_id": "fls_TelBKNKodx3d",
      "title": "Call Resolution",
      "level": 3,
      "file": "entities-and-resolution",
      "content": "Call Resolution\n\nCall resolution is a form of resolution that applies to a\ncall expression.\n\nA candidate callee type is the type of the call operand\nof a call expression under resolution.\n\nA candidate callee type chain is a sequence of [candidate callee type]s.\nThe candidate callee type chain starts with the type of the call\noperand of thecall expression under resolution. From then on, the\ncandidate callee type chain is treated as a dereference type chain.\n\nCall resolution of a call expression proceeds as follows:\n\n#. For each candidate callee type of the\n candidate callee type chain\n\n #. If the candidate callee type is a callee type, then the callee\n type of the call expression is that candidate callee type and\n call resolution stops.",
      "paragraph_ids": [
        "fls_ZjJ7y9r6QQMW",
        "fls_zBSloU2Gjv7x",
        "fls_XBakDylF7aOG",
        "fls_kzovwqIw7ghc",
        "fls_4iBdtE0Ji4Tf",
        "fls_TWR5GIUxPcaJ"
      ],
      "position": 43125,
      "parent_fls_id": "fls_40xoego2thsp",
      "sibling_fls_ids": [
        "fls_xcwfotmq2e5d",
        "fls_wqazkzle0ix9",
        "fls_i6qzga6dyaee"
      ]
    },
    {
      "fls_id": "fls_i6qzga6dyaee",
      "title": "Path Resolution",
      "level": 3,
      "file": "entities-and-resolution",
      "content": "Path Resolution\n\nPath resolution is a form of resolution that applies to a path.\n\nPath resolution resolves a path by resolving individual\n[path segment]s in sequence, starting from the leftmost path segment.\n\nA path segment shall resolve to exactly one entity.\n\nA candidate direct entity is an entity that is visible from the\nlocation of a path under resolution and is located by first examining\n[textual macro scope]s, followed by examining the scope hierarchy\nfrom the innermost scope enclosing the path to the outermost\nscope, followed by examining [prelude]s.\n\nA candidate external prelude entity is an entity that is visible\nfrom the location of a path under resolution and is located by\nexamining the external prelude.\n\nA candidate selected entity is an entity that is visible from\nthe location of a path under resolution and is located within a\nresolution context.\n\nA namespace context is a set of [namespace]s where the [name]s\nof candidate selected entities <candidate selected entity> reside.\n\nA resolution context is a set of entities <entity> that informs\npath resolution by restricting the number of\ncandidate selected entities <candidate selected entity>.\n\nThe resolution of the leftmost path segment of a path proceeds as\nfollows:\n\n* If the leftmost path segment is expressed as keyword crate,\n then what the leftmost path segment resolves to and its\n resolution context is the entity of the current crate.\n\n* If the leftmost path segment is expressed as keyword $crate,\n then what the leftmost path segment resolves to and its\n resolution context is the entity of the crate that declares\n the macro that is being expanded.\n\n* If the leftmost path segment is expressed as keyword self,\n then what the leftmost path segment resolves to and its\n resolution context is the entity of the current module.\n\n* If the leftmost path segment is expressed as keyword Self,\n then what the leftmost path segment resolves to and its\n resolution context is\n\n * The entity of the abstract data type, if the path appears\n within an abstract data type, or\n\n * The entity of the implementing type, if the path appears\n within an implementation, or\n\n * The entity of the trait, if the path appears within a\n trait.\n\n* If the leftmost path segment is expressed as keyword super,\n then what the leftmost path segment resolves to and its\n resolution context is the entity of the parent module of the\n current module.\n\n* If the leftmost path segment is an identifier, then\n\n * If the path is a global path, then try to find a\n candidate external prelude entity whose name matches the\n characters of the leftmost path segment. What the leftmost\n path segment resolves to and its resolution context is that\n candidate external prelude entity.\n\n * Otherwise try to find a candidate direct entity whose name\n matches the characters of the leftmost path segment and\n\n * If the candidate direct entity is a module, and the\n namespace context is the type namespace or the path has\n more than one [path segment]s, and the identifier is a name\n of a type of the language prelude, then resolution of the\n leftmost path segment and its resolution context is the\n type of the language prelude.\n\n * Otherwise the resolution of the leftmost path segment and its\n resolution context is that candidate direct entity.\n\n* If the leftmost path segment starts with a qualified type, then\n\n * The leftmost path segment resolves to the qualified type, and\n\n * If the qualified type is subject to a qualifying trait, then the\n resolution context of the leftmost path segment consists of the\n entities <entity> of all [implementation]s of the\n qualified type that implement the qualifying trait.\n\n * Otherwise the resolution context of the leftmost path segment\n consists of the entity of the qualified type, the\n entities <entity> of all its [inherent implementation]s, and the\n entities <entity> of all its [trait implementation]s of\n [trait]s that are in scope.\n\nThe resolution of the rightmost path segment is determined based on the\npath resolution kind, where the name of the\ncandidate selected entity is restricted by the namespace context.\n\nIt is a static error if the leftmost path segment is an identifier\nintroduced by the external prelude that is also shadowed <shadowing>.",
      "paragraph_ids": [
        "fls_8slvisr3jfja",
        "fls_nmev0tnzgw35",
        "fls_p23q1ob2qitz",
        "fls_e9rv8dfa0arl",
        "fls_yule33qm1ok",
        "fls_7xmhm2lf2h8f",
        "fls_ec4wo8odusqp",
        "fls_9tedg9lpewqa",
        "fls_mvymlhp7192e",
        "fls_cs485plo4z49",
        "fls_yrpem8vhxpr5",
        "fls_ri50nc2dg7c4",
        "fls_to52oma1bvx3",
        "fls_kpn2y7xb3s8q",
        "fls_z71op1vdnazq",
        "fls_2km29ekj9464",
        "fls_l2y464skbuta",
        "fls_n2x13sg5szbl",
        "fls_53kd7eb1qzuz",
        "fls_3spnlz9tqnhj",
        "fls_Mt6xKI08viYw",
        "fls_7hK059djudGN",
        "fls_lxa7uhmdoy9d",
        "fls_EcaZauRXEGcs",
        "fls_xujlscsir05f",
        "fls_wypnvfklnmc1",
        "fls_zi46lmwsn4rg",
        "fls_bATFGtxjKq0B"
      ],
      "position": 44237,
      "parent_fls_id": "fls_40xoego2thsp",
      "sibling_fls_ids": [
        "fls_xcwfotmq2e5d",
        "fls_wqazkzle0ix9",
        "fls_TelBKNKodx3d"
      ]
    },
    {
      "fls_id": "fls_bbso3c45kr9z",
      "title": "Simple Path Resolution",
      "level": 4,
      "file": "entities-and-resolution",
      "content": "Simple Path Resolution\n\nSimple path resolution is a kind of path resolution that applies to\na simple path.\n\nThe namespace context of simple path resolution is determined as\nfollows:\n\n* If the simple path is part of an attribute or a\n macro invocation, then the namespace context is the\n macro namespace.\n\n* If the simple path is part of a use import, then the\n namespace context consists of the macro namespace, the\n type namespace, and the value namespace.\n\n* If the simple path is part of a visibility modifier, then the\n namespace context consists of the type namespace.\n\nThe leftmost path segment of a simple path is resolved using general\npath resolution. The remaining [path segment]s are resolved in\nleft-to-right order, as follows:\n\n* If the current path segment is expressed as keyword super, then\n what the current path segment resolves to and its\n resolution context is the entity of the parent module of the\n previous [path segment]'s resolution context.\n\n* Otherwise try to find a candidate selected entity whose name\n matches the characters of the current path segment within the previous\n [path segment]'s resolution context, where if the current\n path segment is not the rightmost path segment, the\n resolution context is restricted to the entities <entity> of\n [module]s. What the current path segment resolves to and its\n resolution context is that candidate selected entity.",
      "paragraph_ids": [
        "fls_uml24jw5jo7a",
        "fls_59wd7loxst43",
        "fls_mk0ufkeggot6",
        "fls_ayv8okec9fwb",
        "fls_ppoc6wcplab6",
        "fls_dc0yv4306p82",
        "fls_jhivcca0xcqj",
        "fls_tfsgutcpube2"
      ],
      "position": 50095,
      "parent_fls_id": "fls_i6qzga6dyaee",
      "sibling_fls_ids": [
        "fls_o9u2h5m17kpz",
        "fls_1h0olpc7vbui"
      ]
    },
    {
      "fls_id": "fls_o9u2h5m17kpz",
      "title": "Path Expression Resolution",
      "level": 4,
      "file": "entities-and-resolution",
      "content": "Path Expression Resolution\n\nPath expression resolution is a form of path resolution that applies\nto a unqualified path expression.\n\nThe namespace context of path expression resolution is the\nvalue namespace.\n\nThe leftmost path segment of a unqualified path expression is resolved using\ngeneral path resolution. The remaining [path segment]s are resolved\nin left-to-right order, as follows:\n\n* If the current path segment is expressed as keyword super, then\n what the current path segment resolves to and its\n resolution context is the entity of the parent module of the\n previous [path segment]'s resolution context.\n\n* If the current path segment is the rightmost path segment, then\n\n * If the previous [path segment]'s resolution context is an\n enum type, then try to find a candidate selected entity whose\n name matches the characters of the current path segment, where\n the resolution context is restricted to the entities <entity> of\n the [enum variant]s of that enum type. What the current\n path segment resolves to and its resolution context is that\n candidate selected entity.\n\n * If the previous [path segment]'s resolution context is a\n module, then try to find a candidate selected entity whose\n name matches the characters of the current path segment within\n that module. What the current path segment resolves to and its\n resolution context is that candidate selected entity.\n\n * If the previous [path segment]'s resolution context is a\n trait or a type, then perform\n path expression resolution implementation candidate lookup for the\n current path segment and that trait or type.\n\n* Otherwise\n\n * If the previous [path segment]'s resolution context is a\n module, then try to find a candidate selected entity whose\n name matches the characters of the current path segment within\n that module, where the resolution context is restricted to the\n entities <entity> whose [name]s reside in the\n type namespace. What the current path segment resolves to and its\n resolution context is that candidate selected entity.\n\n * If the previous [path segment]'s resolution context is a\n trait, then try to find a candidate selected entity whose\n name matches the characters of the current path segment within\n that trait, where the resolution context is restricted to the\n entities <entity> of all [associated item]s of that trait.\n What the current path segment resolves to and its\n resolution context is that candidate selected entity.\n\n * If the previous [path segment]'s resolution context is a\n type, then try to find a candidate selected entity whose\n name matches the characters of the current path segment within\n that type, where the resolution context is restricted to the\n entities <entity> of all [associated item]s from its\n [inherent implementation]s, and the entities <entity> of all its\n [trait implementation]s of [trait]s that are in scope. What\n the current path segment resolves to and its resolution context\n is that candidate selected entity.\n\nPath expression resolution implementation candidate lookup for a\npath segment and a trait or type proceeds as follows:\n\n#. Perform\n path expression resolution inherent implementation candidate lookup for\n the path segment and the trait or type.\n\n#. Perform\n path expression resolution trait implementation candidate lookup for\n the path segment and the trait or type.\n\nPath expression resolution inherent implementation candidate lookup for a\npath segment and a trait or type proceeds as follows:\n\n#. For each inherent implementation in the set of\n [inherent implementation]s of the trait or type where the\n implementing type unifies <unify> with the trait or type\n\n #. Try to locate a visible constant or a visible function in the\n inherent implementation whose name matches the characters of\n the path segment.\n\n #. If such a constant or function exists, then the\n path segment resolves to that constant or function and\n path expression resolution stops.\n\nPath expression resolution trait implementation candidate lookup for a\npath segment and a trait or type proceeds as follows:\n\n#. For each trait implementation of the trait or type where the\n implemented trait is in scope\n\n #. Try to locate a visible constant or a visible function in the\n trait implementation whose name matches the characters of the\n path segment.\n\n #. If such a constant or function exists, then the\n path segment resolves to that constant or function and\n path expression resolution stops.",
      "paragraph_ids": [
        "fls_akjlqm3a2lb1",
        "fls_xyzdajtf4u2t",
        "fls_d45vu3iazi3",
        "fls_9pjhok9rctty",
        "fls_2wbpr9lvz5yq",
        "fls_u5nyv6ii1g2l",
        "fls_bscg48os5otx",
        "fls_qbmp0blpoxx9",
        "fls_ydni5laqv6gp",
        "fls_lsxbl6ep3150",
        "fls_x1n7w8w6lwm",
        "fls_v1h4frnbqruu",
        "fls_utfpnwlo0v99",
        "fls_1p8ocf1w5bp4",
        "fls_qb5yo7j5gnvf",
        "fls_o1g0forw6xw",
        "fls_bcqe13q696zg",
        "fls_3sceutaqpqha",
        "fls_6q9cwqlvxmd1",
        "fls_qeym3vbi36iv",
        "fls_8x0pqwpm80sj",
        "fls_pp09gmrnasjp",
        "fls_q0jt6n2j1hsx"
      ],
      "position": 52001,
      "parent_fls_id": "fls_i6qzga6dyaee",
      "sibling_fls_ids": [
        "fls_bbso3c45kr9z",
        "fls_1h0olpc7vbui"
      ]
    },
    {
      "fls_id": "fls_1h0olpc7vbui",
      "title": "Type Path Resolution",
      "level": 4,
      "file": "entities-and-resolution",
      "content": "Type Path Resolution\n\nType path resolution is a form of path resolution that applies to\na type path.\n\nThe namespace context of type path resolution is the\ntype namespace.\n\nThe leftmost path segment of a type path is resolved using general\npath resolution. The remaining [path segment]s are resolved in\nleft-to-right order, as follows:\n\n* If the current path segment is expressed as keyword super, then\n what the current path segment resolves to and its\n resolution context is the entity of the parent module of the\n previous [path segment]'s resolution context.\n\n* If the previous [path segment]'s resolution context is a\n module, then try to find a candidate selected entity whose\n name matches the characters of the current path segment within\n that module. What the current path segment resolves to and its\n resolution context is that candidate selected entity.\n\n* If the previous [path segment]'s resolution context is a\n trait, then try to find a candidate selected entity whose name\n matches the characters of the current path segment within that\n trait, where the resolution context is restricted to the\n entities <entity> of all [associated item]s of that trait.\n What the current path segment resolves to and its\n resolution context is that candidate selected entity.\n\n* If the previous [path segment]'s resolution context is a type,\n then try to find a candidate selected entity whose name matches\n the characters of the current path segment within that type,\n where the resolution context is restricted to the entities <entity>\n of all [associated item]s from its [inherent implementation]s, and\n the entities <entity> of all its [trait implementation]s of\n [trait]s that are in scope. What the current path segment\n resolves to and its resolution context is that\n candidate selected entity.\n\n* If the current path segment has a qualified fn trait, then the\n current path segment shall resolve to either the core::ops::Fn,\n core::ops::FnMut, or core::ops::FnOnce trait.",
      "paragraph_ids": [
        "fls_2zuncql8ir5k",
        "fls_bv5cj918dqqe",
        "fls_bsakzuteuh5s",
        "fls_j1ewjisx0mc2",
        "fls_o4snu1him277",
        "fls_goe8q52toik2",
        "fls_4rs35f6ydckj",
        "fls_jh4db1p7or0x"
      ],
      "position": 58044,
      "parent_fls_id": "fls_i6qzga6dyaee",
      "sibling_fls_ids": [
        "fls_bbso3c45kr9z",
        "fls_o9u2h5m17kpz"
      ]
    },
    {
      "fls_id": "fls_dzq9cdz4ibsz",
      "title": "Exceptions and Errors",
      "level": 1,
      "file": "exceptions-and-errors",
      "content": "Exceptions and Errors\n\nThe Rust programming language lacks exceptions and exception handlers. Instead,\nthe language uses the following tiered error handling scheme:\n\n* A possibly absent value is usually represented using enum\n core::option::Option.\n\n* The result of a possibly erroneous computation is usually represented using\n enum core::result::Result.\n\n* Erroneous behavior is signaled using macro core::panic.\n\nEnum core::option::Option indicates whether a value is\neither present using core::option::Option::Some or absent using\ncore::option::Option::None.\n\nEnum core::result::Result indicates whether a computation completed\nsuccessfully and produced a value using core::result::Result::Ok or\nthe computation failed with an error using core::result::Result::Err.",
      "paragraph_ids": [
        "fls_vsk4vhnuiyyz",
        "fls_ebangxc36t74",
        "fls_ckeitwiv326r",
        "fls_eg0orgibg98m",
        "fls_ko1x0gp9e7y3",
        "fls_gwu4cn4ziabe"
      ],
      "position": 125,
      "parent_fls_id": null,
      "sibling_fls_ids": [
        "fls_l21tjqjkkaa0",
        "fls_gvwd0kf72jt",
        "fls_3v733mnewssy",
        "fls_gdeyap4or1db",
        "fls_ckvjj4tt1hh2",
        "fls_osd6c4utyjb3",
        "fls_qcb1n9c0e5hz",
        "fls_48qldfwwh493",
        "fls_y2k5paj8m8ug",
        "fls_fk2m2irwpeof",
        "fls_z1il3w9nulzy",
        "fls_wb86edg02t6a",
        "fls_411up5z0b6n6",
        "fls_83182bfa9uqb",
        "fls_ronnwodjjjsh",
        "fls_xgqh0ju6bmbn",
        "fls_hdwwrsyunir",
        "fls_wdicg3sqa98e",
        "fls_vgb6ev541b2r",
        "fls_EBwqH60SUHiN",
        "fls_jep7p27kaqlp",
        "fls_94a8v54bufn8"
      ]
    },
    {
      "fls_id": "fls_k02nt1m5fq1z",
      "title": "Panic",
      "level": 2,
      "file": "exceptions-and-errors",
      "content": "Panic\n\nA panic is an abnormal program state caused by invoking macro\ncore::panic.\n\nInvoking macro core::panic has the following runtime effects:\n\n#. Control flow halts the execution of the current thread.\n\n#. Control flow of the current thread resumes execution by invoking the\n function subject to attribute panic_handler.",
      "paragraph_ids": [
        "fls_a554v4n0khye",
        "fls_i9njhpte5l0t",
        "fls_n6q7bksyn1m",
        "fls_xmtt04lw517w"
      ],
      "position": 1218,
      "parent_fls_id": "fls_dzq9cdz4ibsz",
      "sibling_fls_ids": [
        "fls_hi1iz0gbnksi"
      ]
    },
    {
      "fls_id": "fls_hi1iz0gbnksi",
      "title": "Abort",
      "level": 2,
      "file": "exceptions-and-errors",
      "content": "Abort\n\nAbort is the immediate termination of a program.\n\nAbort has the following runtime effects:\n\n#. Control flow halts the execution of all threads.\n\n#. The program terminates.",
      "paragraph_ids": [
        "fls_9a1izu3omkbn",
        "fls_iq6olct3rw4u",
        "fls_wd2q6ft9yzrg",
        "fls_7bnrbjb0pq5n"
      ],
      "position": 1862,
      "parent_fls_id": "fls_dzq9cdz4ibsz",
      "sibling_fls_ids": [
        "fls_k02nt1m5fq1z"
      ]
    },
    {
      "fls_id": "fls_ckvjj4tt1hh2",
      "title": "Expressions",
      "level": 1,
      "file": "expressions",
      "content": "Expressions\n\n ExpressionWithBlock ::=\n OuterAttributeOrDoc* (\n AsyncBlockExpression\n | BlockExpression\n | ConstBlockExpression\n | IfExpression\n | IfLetExpression\n | LoopExpression\n | MatchExpression\n | UnsafeBlockExpression\n | NamedBlockExpression\n )\n\n ExpressionWithoutBlock ::=\n OuterAttributeOrDoc* (\n ArrayExpression\n | AwaitExpression\n | BreakExpression\n | CallExpression\n | ClosureExpression\n | ContinueExpression\n | FieldAccessExpression\n | IndexExpression\n | LiteralExpression\n | MethodCallExpression\n | MacroInvocation\n | OperatorExpression\n | ParenthesizedExpression\n | PathExpression\n | RangeExpression\n | ReturnExpression\n | StructExpression\n | TupleExpression\n | UnderscoreExpression\n )\n\n ExpressionList ::=\n Expression ($$,$$ Expression)* $$,$$?\n\n Operand ::=\n Expression\n\n LeftOperand ::=\n Operand\n\n RightOperand ::=\n Operand\n\nA :ds:`SubjectExpression` is any expression in category :s:`Expression`, except\n:s:`StructExpression`.\n\nA :ds:`SubjectLetExpression` is any expression in category\n:s:`SubjectExpression`, except :s:`LazyBooleanExpression`.\n\nAn expression is a construct that produces a value, and may have\nside effects at run-time.\n\nAn expression-with-block is an expression whose structure involves a\nblock expression.\n\nAn expression-without-block is an expression whose structure does not\ninvolve a block expression.\n\nAn operand is an expression nested within an expression.\n\nA left operand is an operand that appears on the left-hand side of a\nbinary operator.\n\nA right operand is an operand that appears on the right-hand side of a\nbinary operator.\n\nA subject expression is an expression that controls [for loop]s,\n[if expression]s, and [match expression]s.\n\nA subject let expression is an expression that controls\n[if let expression]s and [while let loop]s.\n\nEvaluation is the process by which an expression achieves its runtime\neffects.",
      "paragraph_ids": [
        "fls_pwut2jbmk66k",
        "fls_361q9ljc6ybz",
        "fls_h5o6tgul4yor",
        "fls_xmklb3070sp",
        "fls_p15oeage4j0e",
        "fls_gwgttltgjma4",
        "fls_1r29rtnjlkql",
        "fls_qxdpyf4u3hbz",
        "fls_2j132xueobfv",
        "fls_a243nclqqjlu",
        "fls_1223lwh4nq49"
      ],
      "position": 125,
      "parent_fls_id": null,
      "sibling_fls_ids": [
        "fls_l21tjqjkkaa0",
        "fls_gvwd0kf72jt",
        "fls_3v733mnewssy",
        "fls_gdeyap4or1db",
        "fls_dzq9cdz4ibsz",
        "fls_osd6c4utyjb3",
        "fls_qcb1n9c0e5hz",
        "fls_48qldfwwh493",
        "fls_y2k5paj8m8ug",
        "fls_fk2m2irwpeof",
        "fls_z1il3w9nulzy",
        "fls_wb86edg02t6a",
        "fls_411up5z0b6n6",
        "fls_83182bfa9uqb",
        "fls_ronnwodjjjsh",
        "fls_xgqh0ju6bmbn",
        "fls_hdwwrsyunir",
        "fls_wdicg3sqa98e",
        "fls_vgb6ev541b2r",
        "fls_EBwqH60SUHiN",
        "fls_jep7p27kaqlp",
        "fls_94a8v54bufn8"
      ]
    },
    {
      "fls_id": "fls_isyftqu120l",
      "title": "Expression Classification",
      "level": 2,
      "file": "expressions",
      "content": "Expression Classification",
      "paragraph_ids": [],
      "position": 2881,
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_3ut3biyra4r9",
      "title": "Assignee Expressions",
      "level": 3,
      "file": "expressions",
      "content": "Assignee Expressions\n\nAn assignee expression is an expression that appears as the\nleft operand of an assignment expression. The following\n[expression]s are [assignee expression]s:\n\n* [Place expression]s,\n\n* [Underscore expression]s,\n\n* [Array expression]s of [assignee expression]s,\n\n* [Struct expression]s of [assignee expression]s.\n\n* [Tuple expression]s of [assignee expression]s,\n\n* [Tuple struct call expression]s of [assignee expression]s,\n\n[Parenthesized expression]s are allowed to appear anywhere in\n[assignee expression]s.",
      "paragraph_ids": [
        "fls_oqj7s9fi3j3j",
        "fls_skopz71arbwa",
        "fls_vxrg6preh46x",
        "fls_yso6dmog0an2",
        "fls_1tsdlpgkgb2u",
        "fls_hier3b8knpuq",
        "fls_horl3qcfdb0k",
        "fls_1smb3tj9pxsq"
      ],
      "position": 2956,
      "parent_fls_id": "fls_isyftqu120l",
      "sibling_fls_ids": [
        "fls_66m4rnbssgig",
        "fls_zJOAmSr3Dbqk",
        "fls_6ydylimiv553",
        "fls_e7zgqroy2qxn"
      ]
    },
    {
      "fls_id": "fls_66m4rnbssgig",
      "title": "Constant Expressions",
      "level": 3,
      "file": "expressions",
      "content": "Constant Expressions\n\nA constant expression is an expression that can be evaluated\nstatically. The following [construct]s are [constant expression]s as\nlong as their [operand]s are also [constant expression]s and do not\ninvolve [type]s that require destruction:\n\n* [Arithmetic expression]s of [scalar type]s,\n\n* [Array expression]s,\n\n* [Assignment expression]s,\n\n* [Bit expression]s of [scalar type]s,\n\n* [Block expression]s,\n\n* [Call expression]s where the callee is a constant function,\n\n* [Closure expression]s that do not capture <capturing>,\n\n* [Comparison expression]s of [scalar type]s,\n\n* [Compound assignment expression]s,\n\n* [Constant parameter]s,\n\n* [Dereference expression]s,\n\n* [Expression statement]s,\n\n* [Field access expression]s that do not invoke the core::ops::Deref\n trait,\n\n* [If expression]s,\n\n* [If let expression]s,\n\n* [Index expression]s,\n\n* [Infinite loop expression]s,\n\n* [Lazy boolean expression]s of [scalar type]s,\n\n* [Let statement]s,\n\n* [Literal expression]s,\n\n* [Match expression]s,\n\n* [Method call expression]s where the callee is a constant function or\n do not invoke the core::ops::Deref trait,\n\n* [Negation expression]s of [scalar type]s,\n\n* [Parenthesized expression]s,\n\n* [Path expression]s that resolve to [associated constant]s,\n [constant]s, [constant parameter]s, [function]s,\n [static]s, [tuple struct]s, and [unit struct]s,\n\n* [Range expression]s,\n\n* [Struct expression]s,\n\n* [Tuple expression]s,\n\n* [Type cast expression]s that are not [pointer-to-address cast]s,\n [function-pointer-to-address cast]s, and [unsized coercion]s that\n involve a trait object type,\n\n* [Unsafe block expression]s,\n\n* [While let loop expression]s,\n\n* [While loop expression]s.\n\n* All forms of [borrow]s except those of expressions that are subject to\n drop scope extension to the end of the program\n and which are either [mutable borrow]s\n or borrows of expressions that result in values with interior mutability.\n\nAn expression is not considered a constant expression when it\nexplicitly invokes an associated trait function or uses\n[arithmetic operator]s of non-builtin [type]s that invoke\ncore::ops [trait]s.\n\nIt is a static error if the size operand of an\narray repetition constructor or an array type depends on\n[generic parameter]s.\n\nA constant context is a construct that requires a\nconstant expression. The following [construct]s are\n[constant context]s:\n\n* The constant initializer of an associated constant or a\n constant,\n\n* The constant argument for a constant parameter,\n\n* The default value of a constant parameter,\n\n* The discriminant initializer of an enum variant,\n\n* The size operand of an array repetition constructor,\n\n* The size operand of an array type,\n\n* The static initializer of a static.\n\n* The block expression of a const block expression.\n\nAn invocation of the core::ptr::addr_of macro expands to a\nconstant expression allowed in any constant context and\nconstant function, subject to the same restrictions as a\nimmutable borrow expression.\n\nAn invocation of the core::panic macro expands to a\nconstant expression allowed in any constant context and\nconstant function, as long as the macro is either invoked without\narguments, or with a single string literal that does not\ncapture <capturing> formatting arguments.\n\nA constant expression is evaluated statically whenever its value is\nneeded.\n\nThe evaluation of a constant expression that results in\narithmetic overflow [panic]s.\n\nIt is a static error if a constant expression either [panic]s or\ncontrol reaches the invocation of macro core::panic.\n\nIt is a static error if the evaluation of a constant expression results in\na value that is unaligned.\n\nThe invocation of a constant function follows the dynamic semantics of a\nnon-[constant function] invocation.",
      "paragraph_ids": [
        "fls_1ji7368ieg0b",
        "fls_y6ore0iwx7e0",
        "fls_xguga84v3j8u",
        "fls_idxf02p7jogu",
        "fls_6z45ss502alt",
        "fls_wqs0792nud4e",
        "fls_490a1b74fut6",
        "fls_8nyu6phm1nji",
        "fls_8wux08bmpse",
        "fls_v1bnk7neb82a",
        "fls_6fq6bvxxvhsr",
        "fls_to4e7imq2c0w",
        "fls_krtbrpwf3mh0",
        "fls_3etom5uu8y4u",
        "fls_qls0wj8bmupz",
        "fls_b5fraqx07wuo",
        "fls_rpapnm3afan8",
        "fls_fc62yaqyjpl2",
        "fls_kwg8a351vc7",
        "fls_7mjv1xd45qr4",
        "fls_g7hoyfqy9mu1",
        "fls_br4g7qwfczig",
        "fls_w4lpq9bs8tsc",
        "fls_y1ezabo61nyk",
        "fls_6tb74n6lu0wf",
        "fls_axwrv7b3zt55",
        "fls_3bucpdj828bq",
        "fls_fobs8ebt7dhc",
        "fls_dyo3o1h3keqr",
        "fls_e0a1e8ddph7",
        "fls_zcuzhw7qkzkr",
        "fls_pbpzkfo1fgtz",
        "fls_qvofy4wkql0s",
        "fls_zyuxqty09SDO",
        "fls_3i7efddbsmn0",
        "fls_fmqar6o1bwqk",
        "fls_kjhma680hz3g",
        "fls_ljc6jq5ksbcs",
        "fls_3of516eo0kkx",
        "fls_yiks5bvojncc",
        "fls_66m2hwkju0vv",
        "fls_fsn32kmwg65u",
        "fls_j6kffhbxdm7o",
        "fls_ib8p7dfwddx2",
        "fls_ucFupTeCyylb",
        "fls_od0h3v40kjp6",
        "fls_6sc556tz4oxd",
        "fls_b1vfpvsdv38",
        "fls_b46nyamfqxdu",
        "fls_ms9vey2wymqp",
        "fls_XopG4yS9Q4q1",
        "fls_tg0kya5125jt"
      ],
      "position": 3848,
      "parent_fls_id": "fls_isyftqu120l",
      "sibling_fls_ids": [
        "fls_3ut3biyra4r9",
        "fls_zJOAmSr3Dbqk",
        "fls_6ydylimiv553",
        "fls_e7zgqroy2qxn"
      ]
    },
    {
      "fls_id": "fls_zJOAmSr3Dbqk",
      "title": "Diverging Expressions",
      "level": 3,
      "file": "expressions",
      "content": "Diverging Expressions\n\nA diverging expression is an expression whose evaluation causes\nprogram flow to diverge from the normal evaluation order.\n\n[Diverging expression]s are:\n\n* [Break expression]s,\n\n* [Return expression]s,\n\n* [Loop expression]s that are not the target of any\n [break expression]s,\n\n* [Call expression]s and [method call expression]s if the return\n type of the call operand is the never type,\n\n* Invocations of the core::panic macro,\n\n* Any expression whose evaluation requires the evaluation of a\n diverging subexpression on all reachable control flow paths.",
      "paragraph_ids": [
        "fls_oth9vFtcb9l4",
        "fls_cmBVodJMjZi7",
        "fls_xsOgdiIzysP1",
        "fls_xqxdHziqgWf5",
        "fls_fU91m6DCB0ip",
        "fls_4wDpAHhnWZAB",
        "fls_7HA5UThwjbQj",
        "fls_pdDr8Lk1GQ0T"
      ],
      "position": 9651,
      "parent_fls_id": "fls_isyftqu120l",
      "sibling_fls_ids": [
        "fls_3ut3biyra4r9",
        "fls_66m4rnbssgig",
        "fls_6ydylimiv553",
        "fls_e7zgqroy2qxn"
      ]
    },
    {
      "fls_id": "fls_6ydylimiv553",
      "title": "Place Expressions",
      "level": 3,
      "file": "expressions",
      "content": "Place Expressions\n\nA place expression is an expression that represents a memory\nlocation. The following [expression]s are [place expression]s:\n\n* [Dereference expression]s,\n\n* [Field access expression]s,\n\n* [Index expression]s,\n\n* [Parenthesized expression]s where the operand is a\n place expression,\n\n* [Path expression]s that resolve to a static or a variable.\n\n* A temporary.\n\nA mutable place expression is a place expression whose memory\nlocation can be modified. The following [place expression]s are\n[mutable place expression]s:\n\n* A dereference expression whose operand's type implements the\n core::ops::DerefMut trait,\n\n* A dereference expression whose operand's type is a\n mutable raw pointer type,\n\n* A dereference expression whose operand's type is a\n mutable reference type,\n\n* A field access expression where the container operand is a\n mutable place expression,\n\n* An index expression whose type implements the\n core::ops::IndexMut trait,\n\n* [Parenthesized expression]s where the operand is a\n mutable place expression,\n\n* A path expression that resolves to a mutable static,\n\n* A path expression that resolves to a mutable variable that is not\n currently borrowed,\n\n* A temporary.\n\nAn immutable place expression is a place expression whose memory\nlocation cannot be modified. All [place expression]s that are not\n[mutable place expression]s are [immutable place expression]s.\n\nA place expression context is a construct that may evaluate its\noperand as a memory location.\n\nThe following [construct]s are [place expression context]s:\n\n* The assignee operand of an assignment expression or a\n compound assignment expression,\n\n* The operand of a borrow expression,\n\n* The operand of a raw borrow expression,\n\n* The operand of a dereference expression,\n\n* The container operand of a field access expression,\n\n* The initialization expression of a let statement,\n\n* The operand of an implicit borrow,\n\n* The indexed operand of an index expression,\n\n* The subject let expression of an if let expression or a\n while let loop expression,\n\n* The subject expression of a match expression,\n\n* The base initializer of a struct expression.\n\nA mutable place expression context is a place expression context that\nmay evaluate its operand as a mutable memory location. The following\n[construct]s are [mutable place expression context]s:\n\n* The indexed operand of an index expression if evaluated in a\n mutable place expression context,\n\n* The assignee operand of an assignment expression or a\n compound assignment expression,\n\n* The operand of a mutable borrow expression,\n\n* The operand of a dereference expression if evaluated in a\n mutable place expression context,\n\n* The container operand of field access expression if evaluated in a\n mutable place expression context,\n\n* The subject let expression of an if let expression or a\n while let loop expression,\n\n* The operand of a mutable implicit borrow,\n\n* The initialization expression of a let statement,\n\n* The subject expression of a match expression,\n\nA place expression that is evaluated in a value expression context\nor bound by value in a pattern denotes the value held in the\nmemory location of the place expression. Such an evaluation is subject to\n[passing convention]s.",
      "paragraph_ids": [
        "fls_qbrcg3cl9td",
        "fls_jpmhibm4omm7",
        "fls_none1dykbn8c",
        "fls_lj7x5dgbmg9i",
        "fls_anzidgx02lly",
        "fls_ya05djl1d154",
        "fls_gv4M0DE3OMwk",
        "fls_ku38h562vfyl",
        "fls_1tq2o2huda9l",
        "fls_6b4rwkrc1ap6",
        "fls_s4bhrpykzmm7",
        "fls_xm0gm2q27x2e",
        "fls_bt50fltfqcvn",
        "fls_Sgfxp186GMvz",
        "fls_ilaqmj3hc5uv",
        "fls_m0gbw9myylv2",
        "fls_dcm3yr3y9y0a",
        "fls_cPEMHZtPkctX",
        "fls_4vxi1ji93dxb",
        "fls_fzsrdrHnndRd",
        "fls_ZED5wJQVO6nf",
        "fls_Ufz9W5vyZkv3",
        "fls_K7SbApHPmwjM",
        "fls_KxWIzoh9WwK7",
        "fls_oV9Hd6OiFAZX",
        "fls_NnGiNsH6Zgmp",
        "fls_jLZlxIHr4w2v",
        "fls_giZ7w1G02JSg",
        "fls_5yXuTLQOQ3cc",
        "fls_nman7mJVSQlm",
        "fls_JBfZuFDQg3mU",
        "fls_wxGAOWEVT77u",
        "fls_qytgkbhqr5ln",
        "fls_5gy92rsi2mqm",
        "fls_u80htrnr2ebz",
        "fls_o0feajus3jtu",
        "fls_ffjx1d5dseo4",
        "fls_9r7dopqf1nzl",
        "fls_o76QXHyrrJPG",
        "fls_ka5b87tkf8t6",
        "fls_brwv1zwu37e8",
        "fls_4axr4V0icdBP"
      ],
      "position": 10603,
      "parent_fls_id": "fls_isyftqu120l",
      "sibling_fls_ids": [
        "fls_3ut3biyra4r9",
        "fls_66m4rnbssgig",
        "fls_zJOAmSr3Dbqk",
        "fls_e7zgqroy2qxn"
      ]
    },
    {
      "fls_id": "fls_e7zgqroy2qxn",
      "title": "Value Expressions",
      "level": 3,
      "file": "expressions",
      "content": "Value Expressions\n\nA value expression is an expression that represents a value.\nAll [expression]s that are not [place expression]s are\n[value expression]s.\n\nA value expression context is an expression context that is not a\nplace expression context.\n\nThe evaluation of a value expression in a place expression context\nshall evaluate the value expression as a temporary and then use the\ntemporary in the place expression context.",
      "paragraph_ids": [
        "fls_7q4hrt6yfr9b",
        "fls_pB6xlp4uAg37",
        "fls_8uhfwqurbyqf"
      ],
      "position": 15533,
      "parent_fls_id": "fls_isyftqu120l",
      "sibling_fls_ids": [
        "fls_3ut3biyra4r9",
        "fls_66m4rnbssgig",
        "fls_zJOAmSr3Dbqk",
        "fls_6ydylimiv553"
      ]
    },
    {
      "fls_id": "fls_h0dvogc64tfh",
      "title": "Literal Expressions",
      "level": 2,
      "file": "expressions",
      "content": "Literal Expressions\n\nA literal expression is an expression that denotes a literal.\n\nThe type of a literal expression is the type of the corresponding\nliteral.\n\nThe value of a literal expression is the value of the\ncorresponding literal.\n\nThe evaluation of a literal expression has no effect.",
      "paragraph_ids": [
        "fls_rbwwczom3agt",
        "fls_w30su9x4q13r",
        "fls_wdpbg5xzgmwu",
        "fls_g061yzws1m45"
      ],
      "position": 16170,
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_6l60b5hwnjbm",
      "title": "Path Expressions",
      "level": 2,
      "file": "expressions",
      "content": "Path Expressions\n\nA path expression is an expression that denotes a path.\n\nA path expression shall resolve to either a constant parameter, a\nconstant, a function, a static, a tuple enum variant, a\ntuple struct, a unit enum variant, a unit struct, or a\nvariable.\n\nA path expression that resolves to a mutable static shall require\nunsafe context.\n\nThe type of a path expression is the type of the entity that\nit resolved to.\n\nThe value of a path expression is the entity that it resolved to.",
      "paragraph_ids": [
        "fls_gvanx4874ycy",
        "fls_EOkrcIj9CuhV",
        "fls_gz67ju6l7uhn",
        "fls_cjywisyiyti6",
        "fls_5ifai8nkp5ek"
      ],
      "position": 16864,
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_hndm19t57wby",
      "title": "Block Expressions",
      "level": 2,
      "file": "expressions",
      "content": "Block Expressions\n\n StatementList ::=\n Statement* Expression?\n\nA block expression is an expression that sequences [expression]s\nand [statement]s.\n\nA tail expression is the last expression within a block\nexpression.\n\nWhen the remaining [lexical element]s of a :s:`StatementList` match either\nan :s:`Expression` or :s:`Statement` they are interpreted as an :s:`Expression`.\n\nThe type of a block expression is determined as follows:\n\n* If the block expression contains at least one break expression and\n has a tail expression, then the type is the unified type of\n the [break type]s of all [break expression]s and the type of the\n tail expression.\n\n* Otherwise, if the block expression contains at least one\n break expression, then the type is the unified type of the\n [break type]s of all [break expression]s.\n\n* Otherwise, if the block expression has a tail expression, then the\n type is the type of the tail expression.\n\n* Otherwise the type is the unit type.\n\nThe value of a block expression is determined as follows:\n\n* If the block expression contains at least one break expression and\n a break expression broke out the block expression, then the\n value is the break value of the break expression that\n broke out of the block expression.\n\n* Otherwise, if the block expression has a tail expression, then the\n value is the value of the tail expression.\n\n* Otherwise the value is the unit value.\n\nThe evaluation of a block expression proceeds as follows:\n\n#. Each statement is executed in declarative order.\n\n#. The tail expression is evaluated.",
      "paragraph_ids": [
        "fls_nf65p0l0v0gr",
        "fls_tn3hj7k2lliu",
        "fls_DfCne8YWevLE",
        "fls_u4gj2lnkq9ub",
        "fls_ltEygvWDtHXE",
        "fls_97v4fnekrRXI",
        "fls_ob76y2ymdd27",
        "fls_u0avbm147nyh",
        "fls_1hzup0sf8l7l",
        "fls_kKZPKvJ902cw",
        "fls_9nmssjseq3jt",
        "fls_a3ulnvyc1ut",
        "fls_elcl73psruxw",
        "fls_13b5n127rj92",
        "fls_nzdpw59plr2g"
      ],
      "position": 17866,
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_aadan19t5006",
      "title": "Async Blocks",
      "level": 3,
      "file": "expressions",
      "content": "Async Blocks\n\nAn async block expression is a block expression that is specified\nwith keyword async and encapsulates behavior which is executed in\nan asynchronous manner.\n\nAn async block expression denotes a new async control flow boundary.\n\nAn async block expression is subject to capturing.\n\nThe type of an async block expression is a unique anonymous type\nthat implement the core::future::Future trait.\n\nThe value of an async block expression is a value of the\nasync block expression's type.\n\nThe evaluation of an async block expression produces a value of\nthe type of the async block expression that captures <capturing>\nthe [capture target]s of the async block expression.",
      "paragraph_ids": [
        "fls_hhidi5ukxo",
        "fls_oisws5qykedi",
        "fls_tzclkasinpoq",
        "fls_ncd0wkgtldem",
        "fls_pvnofoomgwl5",
        "fls_9ghp5yet75y6"
      ],
      "position": 20380,
      "parent_fls_id": "fls_hndm19t57wby",
      "sibling_fls_ids": [
        "fls_G59PiNQkVUnQ",
        "fls_0ybsR1hEo7wV",
        "fls_8wnyln2nmg4y"
      ]
    },
    {
      "fls_id": "fls_G59PiNQkVUnQ",
      "title": "Const Blocks",
      "level": 3,
      "file": "expressions",
      "content": "Const Blocks\n\nA const block expression is a block expression that is specified\nwith keyword const and encapsulates behavior which is evaluated\nstatically.\n\nAn const block expression denotes a new control flow boundary.\n\nThe block expression of a const block expression shall be a\nconstant expression.\n\nThe type of a const block expression is the type of the\ncontaining block expression.\n\nThe value of a const block expression is the value of the\ncontained block expression.",
      "paragraph_ids": [
        "fls_0lcunL4bo8ka",
        "fls_veEGzEbpT4ny",
        "fls_PiUS1hF3dv9U",
        "fls_wuwb0SnpP6Zu",
        "fls_2i7TD7VoQk4B"
      ],
      "position": 21591,
      "parent_fls_id": "fls_hndm19t57wby",
      "sibling_fls_ids": [
        "fls_aadan19t5006",
        "fls_0ybsR1hEo7wV",
        "fls_8wnyln2nmg4y"
      ]
    },
    {
      "fls_id": "fls_0ybsR1hEo7wV",
      "title": "Named Blocks",
      "level": 3,
      "file": "expressions",
      "content": "Named Blocks\n\nA named block expression is a block expression with a label.\n\nThe type of the named block expression is the type of its\nblock expression.\n\nThe value of the named block expression is the value of its\nblock expression.",
      "paragraph_ids": [
        "fls_J8wJNfcSAYrS",
        "fls_B4NBv2jfZLuy",
        "fls_YxvAUUYAPkaq"
      ],
      "position": 22495,
      "parent_fls_id": "fls_hndm19t57wby",
      "sibling_fls_ids": [
        "fls_aadan19t5006",
        "fls_G59PiNQkVUnQ",
        "fls_8wnyln2nmg4y"
      ]
    },
    {
      "fls_id": "fls_8wnyln2nmg4y",
      "title": "Unsafe Blocks",
      "level": 3,
      "file": "expressions",
      "content": "Unsafe Blocks\n\nAn unsafe block expression is a block expression that is specified\nwith keyword unsafe.\n\nAn unsafe block expression allows unsafety.\n\nThe type of the unsafe block expression is the type of its\nblock expression.\n\nThe value of the unsafe block expression is the value of its\nblock expression.\n\nThe evaluation of an unsafe block expression evaluates its\nblock expression.",
      "paragraph_ids": [
        "fls_2az5huhcxzzy",
        "fls_5ucvvja4dzoc",
        "fls_j3mmg317q442",
        "fls_nygurv3x3wq6",
        "fls_pv5gcy3tbjwo"
      ],
      "position": 23101,
      "parent_fls_id": "fls_hndm19t57wby",
      "sibling_fls_ids": [
        "fls_aadan19t5006",
        "fls_G59PiNQkVUnQ",
        "fls_0ybsR1hEo7wV"
      ]
    },
    {
      "fls_id": "fls_izdv9i4spokw",
      "title": "Operator Expressions",
      "level": 2,
      "file": "expressions",
      "content": "Operator Expressions\n\nAn operator expression is an expression that involves an operator.\n\nAn operator expression that operates with [floating-point value]s run as a constant expression is allowed to yield different [value]s compared to when run as a non-constant expression.",
      "paragraph_ids": [
        "fls_ursc5ynymoy",
        "fls_lSxXWxJn0vMO"
      ],
      "position": 23964,
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_qztk0bkju9u",
      "title": "Borrow Expression",
      "level": 3,
      "file": "expressions",
      "content": "Borrow Expression\n\nA borrow expression is an expression that borrows the value of\nits operand and creates a reference to the memory location of its\noperand.\n\nAn immutable borrow expression is a borrow expression that lacks\nkeyword mut.\n\nA mutable borrow expression is a borrow expression that has\nkeyword mut.\n\nWhen the operand of a borrow expression is a place expression,\nthe borrow expression produces a reference to the memory location\nindicated by the operand. The memory location is placed in a borrowed\nstate, or simply borrowed.\n\nThe type of a borrow expression is determined as follows:\n\n* If the borrow expression denotes an immutable borrow expression, then the\n type is &T, where T is the type of the operand.\n\n* If the borrow expression denotes a mutable borrow expression, then the\n type is &mut T, where T is the type of the operand.\n\nThe value of a borrow expression is the address of its operand.\n\nIt is a static error if a borrow expression would create an unaligned\nreference to a field in an abstract data type subject to\nattribute repr.\n\nThe evaluation of a borrow expression evaluates its operand.\n\nMutable borrow.",
      "paragraph_ids": [
        "fls_nnqfkl228hjx",
        "fls_r7ix8webgqlm",
        "fls_50j167r4v61b",
        "fls_ya77l2zgtilp",
        "fls_chr03xll75d",
        "fls_5b2x5ri2w54r",
        "fls_agl09ia869rk",
        "fls_8cvmee9bzs40",
        "fls_LuaPBicDlDTT",
        "fls_2jd0mgw4zja4",
        "fls_350qejoq9i23"
      ],
      "position": 24819,
      "parent_fls_id": "fls_izdv9i4spokw",
      "sibling_fls_ids": [
        "fls_5cm4gkt55hjh",
        "fls_pocsh1neugpc",
        "fls_wrecura8u5ar",
        "fls_1k9mkv7rbezi",
        "fls_abp6tjbz8tpn",
        "fls_nsvzzbldhq53",
        "fls_lstusiu2c8lu",
        "fls_vXGuvRWOLbEE",
        "fls_1qhsun1vyarz",
        "fls_y4by2i8dl05o",
        "fls_290jmzfh7x4e"
      ]
    },
    {
      "fls_id": "fls_5cm4gkt55hjh",
      "title": "Dereference Expression",
      "level": 3,
      "file": "expressions",
      "content": "Dereference Expression\n\nA dereference expression is an expression that obtains the pointed-to\nmemory location of its operand.\n\nWhen the operand of a dereference expression is of a pointer\ntype, the dereference expression denotes the pointed-to memory location of\nthe operand, or the dereference of the operand.\n\nThe dereference is assignable when the dereference expression is a\nmutable place expression.\n\nDereferencing a raw pointer shall require unsafe context unless the dereference expression is the operand of a raw borrow expression.\n\nIf the context of a dereference expression is an\nimmutable place expression context, then the dereference expression\nis equivalent to expression *core::ops::Deref::deref(&operand).\n\nIf the context of a dereference expression is a\nmutable place expression context, then the dereference expression\nis equivalent to expression\n*core::ops::DerefMut::deref_mut(&mut operand).\n\nThe type of a dereference expression is determined as follows:\n\n* If the type of the operand is &mut T, &T, *mut T, or\n *const T, then the type is T.\n\n* Otherwise the type is associated type\n core::ops::Deref::Target.\n\nThe value of a dereference expression is determined as follows:\n\n* If the type of the operand is &mut T, &T, *mut T, or\n *const T, then the value is the pointed-to value.\n\n* Otherwise the value is the result of evaluating expression\n *core::ops::Deref::deref(&operand) or expression\n *core::ops::DerefMut::deref_mut(&mut operand) respectively.\n\nThe evaluation of a dereference expression evaluates its operand.\n\nIt is undefined behavior to dereference a raw pointer that is either\ndangling or unaligned.\n\nSee :p:`fls_350qejoq9i23` for the declaration of ref_answer.",
      "paragraph_ids": [
        "fls_f6wktzofzdn1",
        "fls_aeh5pzpcjveq",
        "fls_9cc0ml2sru6x",
        "fls_8i4jzksxlrw0",
        "fls_d68ddlse4zp",
        "fls_g73vguanbs1x",
        "fls_8ibfqxtnahzx",
        "fls_7e7tka4f2f1a",
        "fls_y9bc691kkh6v",
        "fls_gw49nukfveib",
        "fls_jjf3sz9ddfhy",
        "fls_fyend8kkpqq4",
        "fls_72bpdsxxbgeq",
        "fls_9wgldua1u8yt",
        "fls_9ifaterm8nop"
      ],
      "position": 26752,
      "parent_fls_id": "fls_izdv9i4spokw",
      "sibling_fls_ids": [
        "fls_qztk0bkju9u",
        "fls_pocsh1neugpc",
        "fls_wrecura8u5ar",
        "fls_1k9mkv7rbezi",
        "fls_abp6tjbz8tpn",
        "fls_nsvzzbldhq53",
        "fls_lstusiu2c8lu",
        "fls_vXGuvRWOLbEE",
        "fls_1qhsun1vyarz",
        "fls_y4by2i8dl05o",
        "fls_290jmzfh7x4e"
      ]
    },
    {
      "fls_id": "fls_pocsh1neugpc",
      "title": "Error Propagation Expression",
      "level": 3,
      "file": "expressions",
      "content": "Error Propagation Expression\n\nAn error propagation expression is an expression that either evaluates\nto a value of its operand or returns a value to the enclosing control\nflow boundary.\n\nAn error propagation expression shall appear within a control flow\nboundary.\n\nThe type of an error propagation expression is associated type\ncore::ops::Try::Output.\n\nThe value of an error propagation expression is determined as follows:\n\n* If the evaluation of the error propagation expression executed\n core::ops::Try::branch, then the value is the value of\n the core::ops::ControlFlow::Continue variant.\n\n* Otherwise control flow is returned to the end of the enclosing control\n flow boundary.\n\nThe evaluation of an error propagation expression of the form\n\nis equivalent to the evaluation the following expression:",
      "paragraph_ids": [
        "fls_8q59wbumrt5s",
        "fls_mq2h4seoxah",
        "fls_ab4vhq4nwn7f",
        "fls_z4zikxy2b1em",
        "fls_a09614kgsspt",
        "fls_8df018q7y6g",
        "fls_alk4qvfprnvy",
        "fls_1nnhjcgy8kdh"
      ],
      "position": 29407,
      "parent_fls_id": "fls_izdv9i4spokw",
      "sibling_fls_ids": [
        "fls_qztk0bkju9u",
        "fls_5cm4gkt55hjh",
        "fls_wrecura8u5ar",
        "fls_1k9mkv7rbezi",
        "fls_abp6tjbz8tpn",
        "fls_nsvzzbldhq53",
        "fls_lstusiu2c8lu",
        "fls_vXGuvRWOLbEE",
        "fls_1qhsun1vyarz",
        "fls_y4by2i8dl05o",
        "fls_290jmzfh7x4e"
      ]
    },
    {
      "fls_id": "fls_wrecura8u5ar",
      "title": "Negation Expression",
      "level": 3,
      "file": "expressions",
      "content": "Negation Expression\n\n NegationOperator ::=\n BitwiseNegationOperator\n | SignNegationOperator\n\n BitwiseNegationOperator ::=\n $$!$$\n\n SignNegationOperator ::=\n $$-$$\n\nA negation expression is an expression that negates its operand.\n\nThe type of the operand of a negation expression with a\n:s:`BitwiseNegationOperator` shall implement the core::ops::Not\ntrait.\n\nThe type of a negation expression with a :s:`BitwiseNegationOperator`\nis associated type core::ops::Not::Output.\n\nThe value of a negation expression with a :s:`BitwiseNegationOperator`\nis the result of core::ops::Not::not(operand).\n\nThe type of the operand of a negation expression with a\n:s:`SignNegationOperator` shall implement the core::ops::Neg trait.\n\nThe type of a negation expression with a :s:`SignNegationOperator`\nshall be associated type core::ops::Neg::Output.\n\nThe value of a negation expression with a :s:`SignNegationOperator` is\nthe result of core::ops::Neg::neg(operand).\n\nThe evaluation of a negation expression with a\n:s:`BitwiseNegationOperator` proceeds as follows:\n\n#. The operand is evaluated.\n\n#. If the type of the operand is an integer type, then the\n negation expression evaluates to the bitwise negation of the\n operand.\n\n#. If the type of the operand is bool, then the result is computed as\n follows, depending on the value of the operand:\n\n \n\n#. If the type of operand is neither an integer type nor\n bool, then core::ops::Not::not(operand) is invoked.\n\nThe evaluation of a negation expression with a\n:s:`SignNegationOperator` proceeds as follows:\n\n#. The operand is evaluated.\n\n#. If the type of the operand is an integer type, then the\n negation expression evaluates to the value of the operand,\n with its sign inverted. If the result of the negation expression does\n not fit within the range of the operand type, then\n arithmetic overflow occurs.\n\n#. If the type of the operand is a floating-point type, then the\n negation expression evaluates to the value of the operand,\n with its sign inverted. No arithmetic overflow is possible.\n\n#. If the type of the operand is neither an integer type nor a\n floating-point type, then core::ops::Neg::neg(operand) is invoked.\n\nSign negation.\n\nBitwise negation.\n\nLogical negation.",
      "paragraph_ids": [
        "fls_pfa81kv2mru8",
        "fls_plcut8vzdwox",
        "fls_ohu0kljfexd3",
        "fls_ghqvj8q71o97",
        "fls_3m4mgqnzqhri",
        "fls_u7gzm6n75rzm",
        "fls_9rmq7iaf092d",
        "fls_yzt6pcsvj3a",
        "fls_8tgxtprtifrr",
        "fls_rFFlt33a5RsZ",
        "fls_h7pIl1WZ8Y2t",
        "fls_yfK3pGHzUo3x",
        "fls_dcNtgLq2hRZb",
        "fls_sxLwuITs62sN",
        "fls_gn3dnuxm2h8m",
        "fls_tsou6yz4mfte",
        "fls_zdfgqky85r1f",
        "fls_CutpaCFCGHQs",
        "fls_B2eKGWaJhFKD",
        "fls_uldh10k77sng",
        "fls_uo6vv2yf8usx",
        "fls_hbrg0d98jak5",
        "fls_kqtr9c3jorvg"
      ],
      "position": 31218,
      "parent_fls_id": "fls_izdv9i4spokw",
      "sibling_fls_ids": [
        "fls_qztk0bkju9u",
        "fls_5cm4gkt55hjh",
        "fls_pocsh1neugpc",
        "fls_1k9mkv7rbezi",
        "fls_abp6tjbz8tpn",
        "fls_nsvzzbldhq53",
        "fls_lstusiu2c8lu",
        "fls_vXGuvRWOLbEE",
        "fls_1qhsun1vyarz",
        "fls_y4by2i8dl05o",
        "fls_290jmzfh7x4e"
      ]
    },
    {
      "fls_id": "fls_1k9mkv7rbezi",
      "title": "Arithmetic Expressions",
      "level": 3,
      "file": "expressions",
      "content": "Arithmetic Expressions\n\n AdditionExpression ::=\n LeftOperand $$+$$ RightOperand\n\n DivisionExpression ::=\n LeftOperand $$/$$ RightOperand\n\n MultiplicationExpression ::=\n LeftOperand $$*$$ RightOperand\n\n RemainderExpression ::=\n LeftOperand $$%$$ RightOperand\n\n SubtractionExpression ::=\n LeftOperand $$-$$ RightOperand\n\nAn arithmetic expression is an expression that computes a value\nfrom two [operand]s using arithmetic.\n\nAn addition expression is an arithmetic expression that uses addition.\n\nThe type of the left operand of an addition expression shall\nimplement the core::ops::Add trait with the type of the\nright operand as the trait implementation type parameter.\n\nThe type of an addition expression is associated type\ncore::ops::Add::Output.\n\nThe value of an addition expression is the result of\ncore::ops::Add::add(left_operand, right_operand).\n\nA division expression is an arithmetic expression that uses division.\n\nThe type of the left operand of a division expression shall\nimplement the core::ops::Div trait where the type of the\nright operand is the trait implementation type parameter.\n\nThe type of a division expression is associated type\ncore::ops::Div::Output.\n\nThe value of a division expression is the result of\ncore::ops::Div::div(left_operand, right_operand).\n\nA multiplication expression is an arithmetic expression that uses\nmultiplication.\n\nThe type of the left operand of a multiplication expression\nshall implement the core::ops::Mul trait where the type of the\nright operand is the trait implementation type parameter.\n\nThe type of a multiplication expression is associated type\ncore::ops::Mul::Output.\n\nThe value of a multiplication expression is the result of\ncore::ops::Mul::mul(left_operand, right_operand).\n\nA remainder expression is an arithmetic expression that uses remainder\ndivision.\n\nThe type of the left operand of a remainder expression shall\nimplement the core::ops::Rem trait where the type of the\nright operand is the trait implementation type parameter.\n\nThe type of a remainder expression is associated type\ncore::ops::Rem::Output.\n\nThe value of a remainder expression is the result of\ncore::ops::Rem::rem(left_operand, right_operand).\n\nA subtraction expression is an arithmetic expression that uses\nsubtraction.\n\nThe type of the left operand of a subtraction expression shall\nimplement the core::ops::Sub trait where the type of the\nright operand is the trait implementation type parameter.\n\nThe type of a subtraction expression is associated type\ncore::ops::Sub::Output.\n\nThe value of a subtraction expression is the result of\ncore::ops::Sub::sub(left_operand, right_operand).\n\nThe evaluation of an addition expression proceeds as follows:\n\n#. The left operand is evaluated.\n\n#. The right operand is evaluated.\n\n#. If the type of both [operand]s is the same integer type or\n floating-point type, then the addition expression evaluates to the\n sum of the [operand]s, following the rules of unsigned integer addition\n for [unsigned integer type]s, two's complement addition for\n [signed integer type]s, or floating-point addition for\n [floating-point type]s. If unsigned integer addition or two's\n complement addition is performed, then the operation may result in an\n arithmetic overflow.\n\n#. Otherwise, core::ops::Add::add(left_operand, right_operand) is invoked.\n\nThe evaluation of a division expression proceeds as follows:\n\n#. The left operand is evaluated.\n\n#. The right operand is evaluated.\n\n#. If the type of both [operand]s is the same integer type or\n floating-point type, then the division expression evaluates to the\n quotient of the [operand]s, following the rules of unsigned integer\n division for [unsigned integer type]s, two's complement division for\n [signed integer type]s, or floating-point division for\n [floating-point type]s.\n\n #. If unsigned integer division is performed and the right operand is\n 0, then the operation results in a panic.\n\n #. If two's complement division is performed and the right operand is 0\n or the result does not fit in the target type, then the operation results\n in a panic.\n\n#. Otherwise, core::ops::Div::div(left_operand, right_operand) is invoked.\n\nThe evaluation of a multiplication expression proceeds as follows:\n\n#. The left operand is evaluated.\n\n#. The right operand is evaluated.\n\n#. If the type of both [operand]s is the same integer type or\n floating-point type, then the multiplication expression evaluates\n to the product of the [operand]s, following the rules of unsigned\n integer multiplication for [unsigned integer type]s, two's complement\n multiplication for [signed integer type]s, or floating-point\n multiplication for [floating-point type]s. If unsigned integer\n multiplication or two's complement multiplication is performed, then the\n operation may result in an arithmetic overflow.\n\n#. Otherwise, core::ops::Mul::mul(left_operand, right_operand) is invoked.\n\nThe evaluation of a remainder expression proceeds as follows:\n\n#. The left operand is evaluated.\n\n#. The right operand is evaluated.\n\n#. If the type of both [operand]s is the same integer type or\n floating-point type, then the remainder expression evaluates to\n the remainder of the division of the left operand by the\n right operand, following the rules of unsigned integer division for\n [unsigned integer type]s, two's complement division for\n [signed integer type]s, or floating-point division for\n [floating-point type]s.\n\n #. If unsigned integer division is performed and the right operand is\n 0, then the operation results in a panic.\n\n #. If two's complement division is performed and the right operand is 0\n or the resulting remainder does not fit in the target type, then the\n operation results in a panic.\n\n#. Otherwise, core::ops::Rem::rem(left_operand, right_operand) is invoked.\n\nThe evaluation of a subtraction expression proceeds as follows:\n\n#. The left operand is evaluated.\n\n#. The right operand is evaluated.\n\n#. If the type of both [operand]s is the same integer type or\n floating-point type, then the subtraction expression evaluates to\n the difference of the [operand]s, following the rules of unsigned\n integer subtraction for [unsigned integer type]s, two's complement\n subtraction for [signed integer type]s, or floating-point subtraction\n for [floating-point type]s. If unsigned integer subtraction or two's\n complement subtraction is performed, then the operation may result in an\n arithmetic overflow.\n\n#. Otherwise, core::ops::Sub::sub(left_operand, right_operand) is invoked.",
      "paragraph_ids": [
        "fls_asibqpe3z95h",
        "fls_kr8Opj3c7uvb",
        "fls_8imzo7agyx0k",
        "fls_vk17mfv47wk9",
        "fls_ryzhdpxgm7ii",
        "fls_dstca76y08ge",
        "fls_f1puss9t4btz",
        "fls_5rdrkvspw57z",
        "fls_thyq4h55mx55",
        "fls_kf41bphvlse3",
        "fls_hrml95g2txcj",
        "fls_ittf4yggk7do",
        "fls_ylqm6wucq2sw",
        "fls_3de9ulyzuoa",
        "fls_8fbhreyynhid",
        "fls_u3jwnrqun5kl",
        "fls_2ude3wrxji2p",
        "fls_aalxhbvu8kdi",
        "fls_fjcv1nm8tlgf",
        "fls_9x2i1zlsm364",
        "fls_v8vekngd27sz",
        "fls_5nsa9zefz9cv",
        "fls_u3pstd6xe43y",
        "fls_jjmc1xgny77",
        "fls_NcLf4o1dpniS",
        "fls_cayhj5hcuhcg",
        "fls_43knkymqpj7t",
        "fls_62gpbubfj30w",
        "fls_bveocgaagk1n",
        "fls_zLroZh43MOtN",
        "fls_Q9dhNiICGIfr",
        "fls_albbLSTYtmyq",
        "fls_qd6ggdgq2hob",
        "fls_lr2a21v5en59",
        "fls_kpbxcdaflb06",
        "fls_b94ojbfukhvd",
        "fls_Et5gp1I7VqBX",
        "fls_blyr18iao20n",
        "fls_g28igfbnwfe0",
        "fls_thcumw8n8xbw",
        "fls_gld1u9fnsj6d",
        "fls_Kdr6fLrRj0Du",
        "fls_FxLnXeGT2n9u",
        "fls_kN0HnldvDXSg",
        "fls_k7lmxvpkxtub",
        "fls_bndpd66973ev",
        "fls_izmfimd4yg27",
        "fls_ad9tc6ki8vcq",
        "fls_Vy0DyZqfy7Iv",
        "fls_b9g0r9vc4rou"
      ],
      "position": 34811,
      "parent_fls_id": "fls_izdv9i4spokw",
      "sibling_fls_ids": [
        "fls_qztk0bkju9u",
        "fls_5cm4gkt55hjh",
        "fls_pocsh1neugpc",
        "fls_wrecura8u5ar",
        "fls_abp6tjbz8tpn",
        "fls_nsvzzbldhq53",
        "fls_lstusiu2c8lu",
        "fls_vXGuvRWOLbEE",
        "fls_1qhsun1vyarz",
        "fls_y4by2i8dl05o",
        "fls_290jmzfh7x4e"
      ]
    },
    {
      "fls_id": "fls_abp6tjbz8tpn",
      "title": "Bit Expressions",
      "level": 3,
      "file": "expressions",
      "content": "Bit Expressions\n\n BitAndExpression ::=\n LeftOperand $$&$$ RightOperand\n\n BitOrExpression ::=\n LeftOperand $$|$$ RightOperand\n\n BitXorExpression ::=\n LeftOperand $$^$$ RightOperand\n\n ShiftLeftExpression ::=\n LeftOperand $$<<$$ RightOperand\n\n ShiftRightExpression ::=\n LeftOperand $$>>$$ RightOperand\n\nA bit expression is an expression that computes a value from two\n[operand]s using bit arithmetic.\n\nA bit and expression is a bit expression that uses bit and arithmetic.\n\nThe type of the left operand of a bit and expression shall\nimplement the core::ops::BitAnd trait where the type of the\nright operand is the trait implementation type parameter.\n\nThe type of a bit and expression is associated type\ncore::ops::BitAnd::Output.\n\nThe value of a bit and expression is the result of\ncore::ops::BitAnd::bitand(left_operand, right_operand).\n\nA bit or expression is a bit expression that uses bit or arithmetic.\n\nThe type of the left operand of a bit or expression shall\nimplement the core::ops::BitOr trait where the type of the\nright operand is the trait implementation type parameter.\n\nThe type of a bit or expression is associated type\ncore::ops::BitOr::Output.\n\nThe value of a bit or expression is the result of\ncore::ops::BitOr::bitor(left_operand, right_operand).\n\nA bit xor expression is a bit expression that uses bit exclusive or\narithmetic.\n\nThe type of the left operand of a bit xor expression shall\nimplement the core::ops::BitXor trait where the type of the\nright operand is the trait implementation type parameter.\n\nThe type of a bit xor expression is associated type\ncore::ops::BitXor::Output.\n\nThe value of a bit xor expression is the result of\ncore::ops::BitXor::bitxor(left_operand, right_operand).\n\nA shift left expression is a bit expression that uses bit shift left\narithmetic.\n\nThe type of the left operand of a shift left expression shall\nimplement the core::ops::Shl trait where the type of the\nright operand is the trait implementation type parameter.\n\nThe type of a shift left expression is associated type\ncore::ops::Shl::Output.\n\nThe value of a shift left expression is the result of\ncore::ops::Shl::shl(left_operand, right_operand).\n\nA shift right expression is a bit expression that uses bit shift right\narithmetic.\n\nThe type of the left operand of a shift right expression shall\nimplement the core::ops::Shr trait where the type of the\nright operand is the trait implementation type parameter.\n\nThe type of a shift right expression is associated type\ncore::ops::Shr::Output.\n\nThe value of a shift right expression is the result of\ncore::ops::Shr::shr(left_operand, right_operand).\n\nThe evaluation of a bit and expression proceeds as follows:\n\n#. The left operand is evaluated.\n\n#. The right operand is evaluated.\n\n#. core::ops::BitAnd::bitand(left_operand, right_operand) is invoked.\n\nThe evaluation of a bit or expression proceeds as follows:\n\n#. The left operand is evaluated.\n\n#. The right operand is evaluated.\n\n#. core::ops::BitOr::bitor(left_operand, right_operand) is invoked.\n\nThe evaluation of a bit xor expression proceeds as follows:\n\n#. The left operand is evaluated.\n\n#. The right operand is evaluated.\n\n#. core::ops::BitXor::bitxor(left_operand, right_operand) is invoked.\n\nThe evaluation of a shift left expression proceeds as follows:\n\n#. The left operand is evaluated.\n\n#. The right operand is evaluated.\n\n#. If the types of both [operand]s are [integer type]s, then the\n shift left expression evaluates to the value of the left operand\n whose bits are shifted left by the number of positions the right operand\n evaluates to. Vacated bits are filled with zeros. lhs << rhs evaluates\n to :math:`\\mathrm{lhs} \\times 2 ^ \\mathrm{rhs}`, casted to the type of the left\n operand. If the value of the right operand is negative or greater\n than or equal to the width of the left operand, then the operation results in\n an arithmetic overflow.\n\n#. Otherwise, core::ops::Shl::shl(left_operand, right_operand) is invoked.\n\nThe evaluation of a shift right expression proceeds as follows:\n\n#. The left operand is evaluated.\n\n#. The right operand is evaluated.\n\n#. If the types of both [operand]s are [integer type]s, then the\n shift right expression evaluates to the value of the left operand\n whose bits are shifted right by the number of positions the right\n operand evaluates to. If the type of the left operand is any\n signed integer type and is negative, then vacated bits are filled\n with ones. Otherwise, vacated bits are filled with zeros. lhs >> rhs\n evaluates to :math:`\\mathrm{lhs} / 2^ \\mathrm{rhs}`, casted to the type of\n the left operand. If the value of the right operand is negative,\n greater than or equal to the width of the left operand, then the operation\n results in an arithmetic overflow.\n\n#. Otherwise, core::ops::Shr::shr(left_operand, right_operand) is invoked.",
      "paragraph_ids": [
        "fls_3zd59yuywz6l",
        "fls_f6mmva3lbj1i",
        "fls_cmowpfrcelke",
        "fls_kchprk9z6xun",
        "fls_dimu987fw4kg",
        "fls_3136k1y6x3cu",
        "fls_oo2ynd8e1ys6",
        "fls_s6hkt5fg598y",
        "fls_osfse0t6ua8a",
        "fls_j7ujcuthga1i",
        "fls_fnywefl9nty2",
        "fls_4f24nyx0ix0j",
        "fls_8tb22c6zbp3",
        "fls_caxn774ij8lk",
        "fls_1f4pc612f2a8",
        "fls_8trozue35xe4",
        "fls_kqntxbwnc58v",
        "fls_t709sl4co3al",
        "fls_onutb0b9p9zj",
        "fls_yq8rtwfp3nv0",
        "fls_fbazfgd5m1ot",
        "fls_f4o8xlu67okn",
        "fls_kp747xqekyrr",
        "fls_m0pdk78dah6n",
        "fls_m2hsk41hwm2j",
        "fls_p9rlmjhbnbao",
        "fls_vprp53kv64q6",
        "fls_d456ummq6vrk",
        "fls_n269ufyesndz",
        "fls_i9iqtobheivu",
        "fls_htw2tpujktwt",
        "fls_gf9tyu1idpjk",
        "fls_u5irwqswbsvu",
        "fls_2kkpr955i4lm",
        "fls_7p64lgnjxylz",
        "fls_ieh1itrkcnf6",
        "fls_f0p70y92k14f",
        "fls_8QGbl2SBU3R0",
        "fls_303r0u6ug215",
        "fls_4gxj18t6cnzq",
        "fls_gurl2ve58drz",
        "fls_r02OGonXp93A",
        "fls_xkyj83mcb9d5"
      ],
      "position": 43969,
      "parent_fls_id": "fls_izdv9i4spokw",
      "sibling_fls_ids": [
        "fls_qztk0bkju9u",
        "fls_5cm4gkt55hjh",
        "fls_pocsh1neugpc",
        "fls_wrecura8u5ar",
        "fls_1k9mkv7rbezi",
        "fls_nsvzzbldhq53",
        "fls_lstusiu2c8lu",
        "fls_vXGuvRWOLbEE",
        "fls_1qhsun1vyarz",
        "fls_y4by2i8dl05o",
        "fls_290jmzfh7x4e"
      ]
    },
    {
      "fls_id": "fls_nsvzzbldhq53",
      "title": "Comparison Expressions",
      "level": 3,
      "file": "expressions",
      "content": "Comparison Expressions\n\n EqualsExpression ::=\n LeftOperand $$==$$ RightOperand\n\n GreaterThanExpression ::=\n LeftOperand $$>$$ RightOperand\n\n GreaterThanOrEqualsExpression ::=\n LeftOperand $$>=$$ RightOperand\n\n LessThanExpression ::=\n LeftOperand $$<$$ RightOperand\n\n LessThanOrEqualsExpression ::=\n LeftOperand $$<=$$ RightOperand\n\n NotEqualsExpression ::=\n LeftOperand $$!=$$ RightOperand\n\nA comparison expression is an expression that compares the\n[value]s of two [operand]s.\n\nA comparison expression implicitly takes [shared borrow]s of its\n[operand]s.\n\nThe type of a comparison expression is type bool.\n\nAn equals expression is a comparison expression that tests equality.\n\nThe type of the left operand of an equals expression shall\nimplement the core::cmp::PartialEq trait where the type of the\nright operand is the trait implementation type parameter.\n\nThe value of an equals expression is the result of\ncore::cmp::PartialEq::eq(&left_operand, &right_operand).\n\nA greater-than expression is a comparison expression that tests for a\ngreater-than relationship.\n\nThe type of the left operand of a greater-than expression shall\nimplement the core::cmp::PartialOrd trait where the type of the\nright operand is the trait implementation type parameter.\n\nThe value of a greater-than expression is the result of\ncore::cmp::PartialOrd::gt(&left_operand, &right_operand).\n\nA greater-than-or-equals expression is a comparison expression that\ntests for a greater-than-or-equals relationship.\n\nThe type of the left operand of a\ngreater-than-or-equals expression shall implement the\ncore::cmp::PartialOrd trait where the type of the\nright operand is the trait implementation type parameter.\n\nThe value of a greater-than-or-equals expression is the result of\ncore::cmp::PartialOrd::ge(&left_operand, &right_operand).\n\nA less-than expression is a comparison expression that tests for a\nless-than relationship.\n\nThe type of the left operand of a less-than expression shall\nimplement the core::cmp::PartialOrd trait where the type of\nthe right operand is the trait implementation type parameter.\n\nThe value of a less-than expression is the result of\ncore::cmp::PartialOrd::lt(&left_operand, &right_operand).\n\nA less-than-or-equals expression is a comparison expression that tests\nfor a less-than-or-equals relationship.\n\nThe type of the left operand of a less-than-or-equals expression\nshall implement the core::cmp::PartialOrd trait where the type\nof the right operand is the trait implementation type parameter.\n\nThe value of a less-than-or-equals expression is the result of\ncore::cmp::PartialOrd::le(&left_operand, &right_operand).\n\nA not-equals expression is a comparison expression that tests for\ninequality.\n\nThe type of the left operand of a not-equals expression shall\nimplement the core::cmp::PartialEq trait where the type of the\nright operand is the trait implementation type parameter.\n\nThe value of a not-equals expression is the result of\ncore::cmp::PartialEq::ne(&left_operand, &right_operand).\n\nThe evaluation of an equals expression proceeds as follows:\n\n#. The left operand is evaluated.\n\n#. The right operand is evaluated.\n\n#. core::cmp::PartialEq::eq(&left_operand, &right_operand) is invoked.\n\nThe evaluation of a greater-than expression proceeds as follows:\n\n#. The left operand is evaluated.\n\n#. The right operand is evaluated.\n\n#. core::cmp::PartialOrd::gt(&left_operand, &right_operand) is invoked.\n\nThe evaluation of a greater-than-or-equals expression proceeds as\nfollows:\n\n#. The left operand is evaluated.\n\n#. The right operand is evaluated.\n\n#. core::cmp::PartialOrd::ge(&left_operand, &right_operand) is invoked.\n\nThe evaluation of a less-than expression proceeds as follows:\n\n#. The left operand is evaluated.\n\n#. The right operand is evaluated.\n\n#. core::cmp::PartialOrd::lt(&left_operand, &right_operand) is invoked.\n\nThe evaluation of a less-than-or-equals expression proceeds as\nfollows:\n\n#. The left operand is evaluated.\n\n#. The right operand is evaluated.\n\n#. core::cmp::PartialOrd::le(&left_operand, &right_operand) is invoked.\n\nThe evaluation of a not-equals expression proceeds as follows:\n\n#. The left operand is evaluated.\n\n#. The right operand is evaluated.\n\n#. core::cmp::PartialEq::ne(&left_operand, &right_operand) is invoked.",
      "paragraph_ids": [
        "fls_yzuceqx6nxwa",
        "fls_asfrqemqviad",
        "fls_9s4re3ujnfis",
        "fls_ruyho6cu7rxg",
        "fls_8echqk9po1cf",
        "fls_d62qfloqk2ub",
        "fls_wapl0ir7uvbp",
        "fls_x2s6ydvj5zyd",
        "fls_pso38dowbk91",
        "fls_7n5gol6a8lod",
        "fls_hholzcbp5u3n",
        "fls_wytygse41vzm",
        "fls_yd4qqi39w248",
        "fls_ynibdcke3etb",
        "fls_xmtxkit3qpw7",
        "fls_yxwe1o27u6ns",
        "fls_6dgfieyxdan0",
        "fls_7pfsqby2saag",
        "fls_w71j7i3n1kit",
        "fls_qzo1torhv5i3",
        "fls_kodwkh58hmdv",
        "fls_ydt9zvh0h5ex",
        "fls_4vbrc31r0o60",
        "fls_hyy974ksbbrq",
        "fls_htrjqxiv3avh",
        "fls_1udbc4aom6ok",
        "fls_96mt7gx5ogo0",
        "fls_or0i2cqxwl8o",
        "fls_udnhkbxpk83m",
        "fls_mab6yirx77zl",
        "fls_2ggb7a7nhrk9",
        "fls_ukm97arfzsk1",
        "fls_wrftg7onlkmm",
        "fls_irlqykpbtvd",
        "fls_udonl4c7f6pz",
        "fls_ebvyhqbb921g",
        "fls_rfomib80bnn2",
        "fls_6cb4wg59wmef",
        "fls_dkbjn7noq8n2",
        "fls_kezynx2xc1q7",
        "fls_8luq5sellcaq",
        "fls_c93pacid548a",
        "fls_gqy6uuowij9e",
        "fls_s6sq6p8th5nt",
        "fls_kdga59xx4nx3"
      ],
      "position": 51007,
      "parent_fls_id": "fls_izdv9i4spokw",
      "sibling_fls_ids": [
        "fls_qztk0bkju9u",
        "fls_5cm4gkt55hjh",
        "fls_pocsh1neugpc",
        "fls_wrecura8u5ar",
        "fls_1k9mkv7rbezi",
        "fls_abp6tjbz8tpn",
        "fls_lstusiu2c8lu",
        "fls_vXGuvRWOLbEE",
        "fls_1qhsun1vyarz",
        "fls_y4by2i8dl05o",
        "fls_290jmzfh7x4e"
      ]
    },
    {
      "fls_id": "fls_lstusiu2c8lu",
      "title": "Lazy Boolean Expressions",
      "level": 3,
      "file": "expressions",
      "content": "Lazy Boolean Expressions\n\n LazyAndExpression ::=\n LeftOperand $$&&$$ RightOperand\n\n LazyOrExpression ::=\n LeftOperand $$||$$ RightOperand\n\nA lazy boolean expression is an expression that performs short circuit\nBoolean arithmetic.\n\nA lazy and expression is a lazy boolean expression that uses short\ncircuit and arithmetic.\n\nA lazy or expression is a lazy boolean expression that uses short\ncircuit or arithmetic.\n\nThe [type]s of the [operand]s of a lazy boolean expression shall\nbe type bool.\n\nThe type of a lazy boolean expression is type bool.\n\nThe value of a lazy boolean expression is either true or\nfalse.\n\nThe evaluation of a lazy and expression proceeds as follows:\n\n#. The left operand is evaluated.\n\n#. If the left operand evaluated to true, then the right operand\n is evaluated and returned as the [lazy and expression]'s value.\n\n#. Otherwise the lazy and expression evaluates to false.\n\nThe evaluation of a lazy or expression proceeds as follows:\n\n#. The left operand is evaluated.\n\n#. If the left operand evaluated to false, then the right operand\n is evaluated and returned as the [lazy or expression]'s value.\n\n#. Otherwise the lazy or expression evaluates to true.",
      "paragraph_ids": [
        "fls_gpbvus89iy4c",
        "fls_40jya46h62yi",
        "fls_k8u77ow5bb6c",
        "fls_u0gwo0s2l0tn",
        "fls_zas0lizgq2hn",
        "fls_xdgvrd58nkoa",
        "fls_ufre0ko2cwh2",
        "fls_jugckad775kq",
        "fls_tmfmu3syxp2q",
        "fls_srfv1d4idxy9",
        "fls_tflikh8cmxvc",
        "fls_p0rafjsridre",
        "fls_yg1348rlziw3",
        "fls_yffozo2vq5xz"
      ],
      "position": 57492,
      "parent_fls_id": "fls_izdv9i4spokw",
      "sibling_fls_ids": [
        "fls_qztk0bkju9u",
        "fls_5cm4gkt55hjh",
        "fls_pocsh1neugpc",
        "fls_wrecura8u5ar",
        "fls_1k9mkv7rbezi",
        "fls_abp6tjbz8tpn",
        "fls_nsvzzbldhq53",
        "fls_vXGuvRWOLbEE",
        "fls_1qhsun1vyarz",
        "fls_y4by2i8dl05o",
        "fls_290jmzfh7x4e"
      ]
    },
    {
      "fls_id": "fls_vXGuvRWOLbEE",
      "title": "Raw Borrow Expression",
      "level": 3,
      "file": "expressions",
      "content": "Raw Borrow Expression\n\nA raw borrow expression is an expression that creates a raw pointer to the memory location of its operand without incurring a borrow.\n\nAn immutable raw borrow expression is a raw borrow expression that has keyword const.\n\nA mutable raw borrow expression is a raw borrow expression that has keyword mut.\n\nWhen the operand of a raw borrow expression is a place expression, the raw borrow expression produces a raw pointer to the memory location indicated by the operand.\n\nIt is a static error if the operand of a raw borrow expression is a temporary.\n\nThe type of a raw borrow expression is determined as follows:\n\n* If the raw borrow expression denotes an immutable raw borrow expression, then the type is *const T, where T is the type of the operand.\n\n* If the raw borrow expression denotes a mutable raw borrow expression, then the type is *mut T, where T is the type of the operand.\n\nThe value of a raw borrow expression is the address of its operand.\n\nThe evaluation of a raw borrow expression evaluates its operand.\n\nMutable raw borrow.",
      "paragraph_ids": [
        "fls_TS6DvMon5h27",
        "fls_UtjWrE2qeplQ",
        "fls_4e7EE4a8Yvmy",
        "fls_gOXUWePymgGV",
        "fls_YBC8GrIBzZbi",
        "fls_Twkre8IzUa8S",
        "fls_Ki4FOzJMqtvJ",
        "fls_DJxQDBsO9hc7",
        "fls_WlXB0AHifCdd",
        "fls_qQrV8QuGGcVO",
        "fls_dTABiwAPGhdZ"
      ],
      "position": 59522,
      "parent_fls_id": "fls_izdv9i4spokw",
      "sibling_fls_ids": [
        "fls_qztk0bkju9u",
        "fls_5cm4gkt55hjh",
        "fls_pocsh1neugpc",
        "fls_wrecura8u5ar",
        "fls_1k9mkv7rbezi",
        "fls_abp6tjbz8tpn",
        "fls_nsvzzbldhq53",
        "fls_lstusiu2c8lu",
        "fls_1qhsun1vyarz",
        "fls_y4by2i8dl05o",
        "fls_290jmzfh7x4e"
      ]
    },
    {
      "fls_id": "fls_1qhsun1vyarz",
      "title": "Type Cast Expressions",
      "level": 3,
      "file": "expressions",
      "content": "Type Cast Expressions\n\nA type cast expression is an expression that changes the type of\nan operand.\n\nCast or casting is the process of changing the type of an\nexpression.\n\nThe TypeSpecificationWithoutBounds describes the target type of the\ntype cast expression.\n\nA type cast expression with the following characteristics performs a\nspecialized cast:\n\n* An operand of a numeric type and a target numeric type perform\n a numeric cast.\n\n* An operand of an enum type and a target integer type\n perform enum cast. An enum cast converts the operand to its\n discriminant, followed by a numeric cast.\n\n* An operand of type bool or type char and a\n target integer type perform primitive-to-integer cast. A\n primitive-to-integer cast\n\n * Converts an operand of type bool with value false\n to zero.\n\n * Converts an operand of type bool with value true\n to one.\n\n * Convert an operand of type char to the value of the\n corresponding code point, followed by a numeric cast.\n\n* An operand of type u8 and a target type char performs\n u8-to-char cast. A u8-to-char cast converts an operand of\n type u8 to the value of the corresponding code point.\n\n* An operand of type *const T or *mut T and a\n target type *const V or *mut V where V implements the\n core::marker::Sized trait performs pointer-to-pointer cast.\n\n* An operand of type *const T or *mut T where T implements\n the core::marker::Sized trait and a target integer type\n perform pointer-to-address cast. A pointer-to-address cast produces\n an integer that represents the machine address of the referenced memory. If\n the integer type is smaller than the type of the operand, the\n address is truncated.\n\n* An operand of integer type and target type *const V or\n *mut V where V implements the core::marker::Sized trait\n perform address-to-pointer cast. An address-to-pointer cast\n produces a pointer that interprets the integer as a machine address.\n\n* An operand of type &mut [T; N] and a target type\n *const T perform array-to-pointer cast.\n\n* An operand of a function item type and a target type\n *const V or *mut V where V implements the\n core::marker::Sized trait perform function-item-to-pointer cast.\n\n* An operand of a function item type and a target integer type\n perform function-to-address cast.\n\n* An operand of a function pointer type and a target type\n *const V or *mut V where V implements the\n core::marker::Sized trait perform\n function-pointer-to-pointer cast.\n\n* An operand of a function pointer type and a target integer type\n perform function-pointer-to-address cast. A\n function-pointer-to-address cast produces an integer that represents the\n machine address of the referenced function. If the integer type is\n smaller than the size of the function pointer type, the address is\n truncated.\n\nA cast is legal when it either performs type coercion or is a\nspecialized cast.\n\nThe type of a type cast expression is the target type.\n\nThe value of a type cast expression is the value of the\noperand after the cast.\n\nThe evaluation of a type cast expression evaluates its operand.\n\nThe evaluation of a numeric cast proceeds as follows:\n\n* Casting an operand of an integer type to a target integer type\n of the same size has no effect.\n\n* Casting an operand of an integer type to a target integer type\n with smaller size truncates the value of the operand.\n\n* Casting an operand of an integer type to a target integer type\n with a larger size either\n\n * Zero-extends the operand if the [operand]'s type is\n unsigned, or\n\n * Sign-extends the operand if the [operand]'s type is signed.\n\n* Casting an operand of a floating-point type to a target\n integer type rounds the value of the operand towards zero. In\n addition, the type cast expression\n\n * Returns zero if the operand denotes f32::NaN or f64::NaN\n respectively.\n\n * Saturates the value of the operand to the maximum value\n of the target integer type if the [operand]'s value\n exceeds the maximum value of the target integer type or denotes\n f32::INFINITY or f64::INFINITY respectively.\n\n * Saturates the value of the operand to the minimum value\n of the target integer type if the [operand]'s value\n exceeds the minimum value of the target integer type or denotes\n f32::NEG_INFINITY or f64::NEG_INFINITY respectively.\n\n* Casting an operand of an integer type to a target\n floating-point type produces the closest possible floating-point\n value. In addition, the type cast expression\n\n * Rounds the value of the operand preferring the value with an\n even least significant digit if exactly halfway between two floating-point\n numbers.\n\n * Produces f32::INFINITY or f64::INFINITY of the same sign as\n the value of the operand when the value of the operand\n causes arithmetic overflow.\n\n* Casting an operand of type f32 to a target type f64\n is perfect and lossless.\n\n* Casting an operand of type f64 to target type f32\n produces the closest possible f32 value. In addition, the\n type cast expression\n\n * Prefers the nearest value with an even least significant digit if\n exactly halfway between two floating-point numbers.\n\n * Produces f32::INFINITY of the same sign as the value of the\n operand when the value of the operand causes\n arithmetic overflow.\n\nSee :p:`fls_2jd0mgw4zja4` for the declaration of answer.",
      "paragraph_ids": [
        "fls_ltioqbhl14g0",
        "fls_99kvyh4puy57",
        "fls_a6midh2m0w0b",
        "fls_otaxe9okhdr1",
        "fls_4s69s9pcvbn7",
        "fls_le6bchl25ewz",
        "fls_pcromhosmnf0",
        "fls_al9f1t7vlsxi",
        "fls_jea17f39fmsg",
        "fls_eb00s8fxlvjb",
        "fls_qk5trk8wkvxb",
        "fls_t16yzaxro5ew",
        "fls_i4zsbbmfa2fl",
        "fls_59mpteeczzo",
        "fls_8ccwlliqw9jx",
        "fls_i8txki3htx92",
        "fls_6hbkvbb1c8aj",
        "fls_133j6xw8k4qe",
        "fls_bhw2j9wjpf2x",
        "fls_3ww5gbk9w4ys",
        "fls_hhxawo12cndy",
        "fls_uuayaksl8059",
        "fls_syk2li8ft3rx",
        "fls_uqv32nthva6y",
        "fls_kc3gwj9x3jnr",
        "fls_76eq3bd6birr",
        "fls_ldiritt32h2w",
        "fls_h9sxg3pxn7i2",
        "fls_shy6e0e30bco",
        "fls_4xldaoj5ac6t",
        "fls_50714cvaqkfv",
        "fls_g3xbmp8zx1yh",
        "fls_hcc5odh52bk7",
        "fls_o2ep4b6t287z",
        "fls_vfofk2aagsj5",
        "fls_cx86k8yfjhht",
        "fls_gzmdwibl5s4w",
        "fls_mjqvjt7v8a25",
        "fls_4fd5vkh0jt4",
        "fls_2etd73f8jg2n",
        "fls_vdxkpvmpwl3s"
      ],
      "position": 61396,
      "parent_fls_id": "fls_izdv9i4spokw",
      "sibling_fls_ids": [
        "fls_qztk0bkju9u",
        "fls_5cm4gkt55hjh",
        "fls_pocsh1neugpc",
        "fls_wrecura8u5ar",
        "fls_1k9mkv7rbezi",
        "fls_abp6tjbz8tpn",
        "fls_nsvzzbldhq53",
        "fls_lstusiu2c8lu",
        "fls_vXGuvRWOLbEE",
        "fls_y4by2i8dl05o",
        "fls_290jmzfh7x4e"
      ]
    },
    {
      "fls_id": "fls_y4by2i8dl05o",
      "title": "Assignment Expressions",
      "level": 3,
      "file": "expressions",
      "content": "Assignment Expressions\n\n AssigneeOperand ::=\n Operand\n\n ValueOperand ::=\n Operand\n\nAn assignment expression is an expression that assigns the value\nof a value operand to an assignee operand.\n\nAn assignee operand is the target operand of an\nassignment expression.\n\nA value operand is an operand that supplies the value that is\nassigned to an assignee operand by an assignment expression.\n\nThe type of an assignment expression is the unit type.\n\nThe value of an assignment expression is the unit value.",
      "paragraph_ids": [
        "fls_nhgexeu2h6wi",
        "fls_bsjw6f4a3wol",
        "fls_uinh05sslxeo",
        "fls_qengy157fa4a",
        "fls_bwwtgqprbxrm"
      ],
      "position": 69184,
      "parent_fls_id": "fls_izdv9i4spokw",
      "sibling_fls_ids": [
        "fls_qztk0bkju9u",
        "fls_5cm4gkt55hjh",
        "fls_pocsh1neugpc",
        "fls_wrecura8u5ar",
        "fls_1k9mkv7rbezi",
        "fls_abp6tjbz8tpn",
        "fls_nsvzzbldhq53",
        "fls_lstusiu2c8lu",
        "fls_vXGuvRWOLbEE",
        "fls_1qhsun1vyarz",
        "fls_290jmzfh7x4e"
      ]
    },
    {
      "fls_id": "fls_nnqlae9zp80s",
      "title": "Basic Assignment",
      "level": 4,
      "file": "expressions",
      "content": "Basic Assignment\n\nA basic assignment is an assignment expression that is not a\ndestructuring assignment.\n\nThe evaluation of a basic assignment proceeds as follows:\n\n#. The value operand is evaluated.\n\n#. The assignee operand is evaluated.\n\n#. The value denoted by the assignee operand is dropped, unless\n the assignee operand denotes an uninitialized variable or an\n uninitialized field of a variable.\n\n#. The value of the value operand is passed <passing convention>\n into the place of the assignee operand.",
      "paragraph_ids": [
        "fls_uhcodvq75nlr",
        "fls_esn5ceoldta",
        "fls_t8eqzc64ivin",
        "fls_b0mqcn5fejhk",
        "fls_9i0ctuo099bp",
        "fls_hc01gtvlxba"
      ],
      "position": 70090,
      "parent_fls_id": "fls_y4by2i8dl05o",
      "sibling_fls_ids": [
        "fls_9beohh5475s2"
      ]
    },
    {
      "fls_id": "fls_9beohh5475s2",
      "title": "Destructuring Assignment",
      "level": 4,
      "file": "expressions",
      "content": "Destructuring Assignment\n\nA destructuring assignment is an assignment expression where\nthe assignee operand is either an array expression, a struct\nexpression, a tuple expression or a tuple struct call expression.\n\nThe assignee operand of a destructuring assignment is treated as an\nassignee pattern depending on its kind, as follows:\n\n* An array expression corresponds to a slice pattern with all the\n [subexpression]s lowered to their corresponding [pattern]s.\n\n* A full range expression corresponds to a rest pattern if inside an\n array expression, otherwise this is a static error.\n\n* A place expression corresponds to an identifier pattern with a\n unique identifier and without keyword ref, keyword mut, or\n a bound pattern.\n\n* A struct expression corresponds to a struct pattern with all the\n [subexpression]s lowered to their corresponding [pattern]s.\n\n* A tuple expression corresponds to a tuple pattern with all the\n [subexpression]s lowered to their corresponding [pattern]s.\n\n* A tuple struct call expression corresponds to a\n tuple struct pattern with all the [subexpression]s lowered to their\n corresponding [pattern]s.\n\n* An underscore expression corresponds to an underscore pattern.\n\nThe pattern that corresponds to a destructuring assignment shall be\nan irrefutable pattern.\n\nA destructuring assignment is equivalent to a block expression of the\nfollowing form:\n\n* The first statement is a let statement with its pattern\n equivalent to the lowered assignee pattern and its\n initialization expression equivalent to the value operand.\n\n* Then each bound identifier of the assignee pattern is an\n assignment expression used as a statement, as follows:\n\n* The bound identifier becomes the value operand of the new\n assignment expression, and\n\n* The corresponding expression from the assignee operand of the\n destructuring assignment becomes the assignee operand of the new\n assignment expression.\n\nThe evaluation of a destructuring assignment proceeds as follows:\n\n#. The value operand is evaluated.\n\n#. The assignee operand is evaluated by evaluating its [operand]s in\n a left-to-right order.\n\n#. Each value denoted by the assignee operand is dropped\n in left-to-right order, unless the assignee operand denotes an\n uninitialized variable or an uninitialized field of a variable.\n\n#. The value of the value operand is passed <passing convention>\n into the place of the assignee operand.",
      "paragraph_ids": [
        "fls_2eheo4yo2orm",
        "fls_z8c3b9s9de3x",
        "fls_vqb89rkkjw81",
        "fls_vqj7ljrrd7wi",
        "fls_du5eybf8mocy",
        "fls_hj6srmzbobid",
        "fls_uydzlfc4hjbx",
        "fls_fa14yfvxsbx3",
        "fls_q90ikfi7ewoi",
        "fls_4bb07tn28ivw",
        "fls_g80a92tr2ser",
        "fls_u0iqhbw37xvq",
        "fls_wsfhd3udt6fq",
        "fls_ll6h6qcaos65",
        "fls_ajbdn54qe6wc",
        "fls_l4u5hhw8tnvs",
        "fls_dd62w8c9n9sd",
        "fls_jqu2u6mdccgi",
        "fls_n7nuj1lvpspc",
        "fls_qb8u5skn8bc4"
      ],
      "position": 71006,
      "parent_fls_id": "fls_y4by2i8dl05o",
      "sibling_fls_ids": [
        "fls_nnqlae9zp80s"
      ]
    },
    {
      "fls_id": "fls_290jmzfh7x4e",
      "title": "Compound Assignment Expressions",
      "level": 3,
      "file": "expressions",
      "content": "Compound Assignment Expressions\n\n AdditionAssignmentExpression ::=\n AssignedOperand $$+=$$ ModifyingOperand\n\n BitAndAssignmentExpression ::=\n AssignedOperand $$&=$$ ModifyingOperand\n\n BitOrAssignmentExpression ::=\n AssignedOperand $$|=$$ ModifyingOperand\n\n BitXorAssignmentExpression ::=\n AssignedOperand $$^=$$ ModifyingOperand\n\n DivisionAssignmentExpression ::=\n AssignedOperand $$/=$$ ModifyingOperand\n\n MultiplicationAssignmentExpression ::=\n AssignedOperand $$*=$$ ModifyingOperand\n\n RemainderAssignmentExpression ::=\n AssignedOperand $$%=$$ ModifyingOperand\n\n ShiftLeftAssignmentExpression ::=\n AssignedOperand $$<<=$$ ModifyingOperand\n\n ShiftRightAssignmentExpression ::=\n AssignedOperand $$>>=$$ ModifyingOperand\n\n SubtractionAssignmentExpression ::=\n AssignedOperand $$-=$$ ModifyingOperand\n\n AssignedOperand ::=\n Operand\n\n ModifyingOperand ::=\n Operand\n\nA compound assignment expression is an expression that first computes\na value from two [operand]s and then assigns the value to an\nassigned operand.\n\nA bit and assignment expression is a compound assignment expression\nthat uses bit and arithmetic.\n\nA bit or assignment expression is a compound assignment expression\nthat uses bit or arithmetic.\n\nA bit xor assignment expression is a compound assignment expression\nthat uses bit exclusive or arithmetic.\n\nA division assignment expression is a compound assignment expression\nthat uses division.\n\nA multiplication assignment expression is a\ncompound assignment expression that uses multiplication.\n\nA remainder assignment expression is a compound assignment expression\nthat uses remainder division.\n\nA shift left assignment expression is a compound assignment expression\nthat uses bit shift left arithmetic.\n\nA shift right assignment expression is a\ncompound assignment expression that uses bit shift right arithmetic.\n\nA subtraction assignment expression is a\ncompound assignment expression that uses subtraction.\n\nAn assigned operand is the target operand of a\ncompound assignment expression.\n\nA modifying operand is an operand that supplies the value that\nis used in the calculation of a compound assignment expression.\n\nAn assigned operand shall denote a mutable assignee expression.\n\nThe type of a compound assignment is the unit type.\n\nThe value of a compound assignment is the unit value.\n\nThe type of the assigned operand of an addition assignment shall\nimplement the core::ops::AddAssign trait where the type of the right\noperand is the trait implementation type parameter.\n\nThe type of the assigned operand of a bit and assignment shall\nimplement the core::ops::BitAndAssign trait where the type of\nthe modifying operand is the trait implementation type parameter.\n\nThe type of the assigned operand of a bit or assignment shall\nimplement the core::ops::BitOrAssign trait where the type of\nthe modifying operand is the trait implementation type parameter.\n\nThe type of the assigned operand of a bit xor assignment shall\nimplement the core::ops::BitXorAssign trait where the type of\nthe modifying operand is the trait implementation type parameter.\n\nThe type of the assigned operand of a division assignment shall\nimplement the core::ops::DivAssign trait where the type of the\nmodifying operand is the trait implementation type parameter.\n\nThe type of the assigned operand of a multiplication assignment\nshall implement the core::ops::MulAssign trait where the type\nof the modifying operand is the trait implementation\ntype parameter.\n\nThe type of the assigned operand of a remainder assignment shall\nimplement the core::ops::RemAssign trait where the type of the\nmodifying operand is the trait implementation type parameter.\n\nThe type of the assigned operand of a shift left assignment shall\nimplement the core::ops::ShlAssign trait where the type of the\nmodifying operand is the trait implementation type parameter.\n\nThe type of the assigned operand of a shift right assignment\nshall implement the core::ops::ShrAssign trait where the type\nof the modifying operand is the trait implementation\ntype parameter.\n\nThe type of the assigned operand of a subtraction assignment\nshall implement the core::ops::SubAssign trait where the type\nof the modifying operand is the trait implementation\ntype parameter.\n\nThe evaluation of a compound assignment proceeds as follows:\n\n#. If the [type]s of both [operand]s are [integer type]s or [floating-point type]s, then\n\n #. The modifying operand is evaluated.\n\n #. The assigned operand is evaluated.\n\n #. The appropriate function is invoked as indicated below.\n\n#. Otherwise\n\n #. The assigned operand is evaluated.\n\n #. The modifying operand is evaluated.\n\n #. The appropriate function is invoked as indicated below.\n\nFor an addition assignment,\ncore::ops::AddAssign::add_assign(&mut assigned_operand, modifying_operand)\nis invoked.\n\nFor a bit and assignment,\ncore::ops::BitAndAssign::bitand_assign(&mut assigned_operand, modifying_operand)\nis invoked.\n\nFor a bit or assignment,\ncore::ops::BitOrAssign::bitor_assign(&mut assigned_operand, modifying_operand)\nis invoked.\n\nFor a bit xor assignment,\ncore::ops::BitXorAssign::bitxor_assign(&mut assigned_operand, modifying_operand)\nis invoked.\n\nFor a division assignment,\ncore::ops::DivAssign::div_assign(&mut assigned_operand, modifying_operand)\nis invoked.\n\nFor a multiplication assignment,\ncore::ops::MulAssign::mul_assign(&mut assigned_operand, modifying_operand)\nis invoked.\n\nFor a remainder assignment,\ncore::ops::RemAssign::rem_assign(&mut assigned_operand, modifying_operand)\nis invoked.\n\nFor a shift left assignment,\ncore::ops::ShlAssign::shl_assign(&mut assigned_operand, modifying_operand)\nis invoked.\n\nFor a shift right assignment,\ncore::ops::ShrAssign::shr_assign(&mut assigned_operand, modifying_operand)\nis invoked.\n\nFor a subtraction assignment,\ncore::ops::SubAssign::sub_assign(&mut assigned_operand, modifying_operand)\nis invoked.",
      "paragraph_ids": [
        "fls_3bu3g8o5nopc",
        "fls_w2hbhb989yr4",
        "fls_ak4g5112jkl",
        "fls_lkjwyy78m2vx",
        "fls_pkzj0uigfcgm",
        "fls_ndlv3k9uclz2",
        "fls_fbp5dojti27r",
        "fls_oy9ur11k78t",
        "fls_s7rey2bndfei",
        "fls_7l7v7vigw3fu",
        "fls_dvy201zd6oym",
        "fls_9v09ayi2azpe",
        "fls_row7saf53vwd",
        "fls_xmgcdw9yhb55",
        "fls_yeh6mvyvb4dp",
        "fls_657knnsobdyu",
        "fls_m942dwwmr2cl",
        "fls_np33oqrz33mp",
        "fls_atdpr8be2o2r",
        "fls_fbgwb3pdfgz",
        "fls_8tbxq95x06yt",
        "fls_9oy9zo3x3fy3",
        "fls_pdgj2xekdead",
        "fls_4uoi6k8r7mvc",
        "fls_fjaz4m90cagr",
        "fls_eesn9kuylim",
        "fls_4nnqz4etisgw",
        "fls_a2g4hs15jpiu",
        "fls_kuet16jp6ps9",
        "fls_hovju0sni9gr",
        "fls_ngimpabunzis",
        "fls_4sbpfi12frwe",
        "fls_n5ds6ydgckvo",
        "fls_xjdu0y1slsg9",
        "fls_ijfmnnrdlu8n",
        "fls_6x7j9x354pkb",
        "fls_h2cpbz2t74hy",
        "fls_whj50spxz3bh",
        "fls_d1cxq1zbt5fq",
        "fls_48i245an2449",
        "fls_69wr03rt0ali",
        "fls_9d970yfwmj2d",
        "fls_p9687v3xckps",
        "fls_8j408kckzzud"
      ],
      "position": 74484,
      "parent_fls_id": "fls_izdv9i4spokw",
      "sibling_fls_ids": [
        "fls_qztk0bkju9u",
        "fls_5cm4gkt55hjh",
        "fls_pocsh1neugpc",
        "fls_wrecura8u5ar",
        "fls_1k9mkv7rbezi",
        "fls_abp6tjbz8tpn",
        "fls_nsvzzbldhq53",
        "fls_lstusiu2c8lu",
        "fls_vXGuvRWOLbEE",
        "fls_1qhsun1vyarz",
        "fls_y4by2i8dl05o"
      ]
    },
    {
      "fls_id": "fls_tpwp86mronn2",
      "title": "Underscore Expressions",
      "level": 2,
      "file": "expressions",
      "content": "Underscore Expressions\n\nAn underscore expression is an expression that acts as a placeholder\nin a destructuring assignment.\n\nAn underscore expression shall appear in the assigned operand of a\ndestructuring assignment.",
      "paragraph_ids": [
        "fls_pydmv629vfuu",
        "fls_wms3dbwjwyu4"
      ],
      "position": 83050,
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_g0uyl7qw4c7w",
      "title": "Parenthesized Expressions",
      "level": 2,
      "file": "expressions",
      "content": "Parenthesized Expressions\n\nA parenthesized expression is an expression that groups other\n[expression]s.\n\nThe type of a parenthesized expression is the type of its\noperand.\n\nThe value of a parenthesized expression is the value of its\noperand.\n\nThe evaluation of a parenthesized expression evaluates its\noperand.",
      "paragraph_ids": [
        "fls_jhazc75w5vj",
        "fls_5d66h7naoup6",
        "fls_xp9whcj2obk8",
        "fls_2po52gv0m021"
      ],
      "position": 83607,
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_xinykul167l",
      "title": "Array Expressions",
      "level": 2,
      "file": "expressions",
      "content": "Array Expressions\n\n ArrayElementExpression ::=\n ArrayElementConstructor\n | ArrayRepetitionConstructor\n\n ArrayElementConstructor ::=\n ExpressionList\n\n ArrayRepetitionConstructor ::=\n RepeatOperand $$;$$ SizeOperand\n\n RepeatOperand ::=\n Operand\n\n SizeOperand ::=\n Operand\n\nAn array expression is an expression that constructs an array.\n\nAn array element constructor is an array expression that lists all\nelements of the array being constructed.\n\nAn array repetition constructor is an array expression that specifies\nhow many times an element is repeated in the array being constructed.\n\nA repeat operand is an operand that specifies the element being\nrepeated in an array repetition constructor.\n\nA size operand is an operand that specifies the size of an array\nor an array type.\n\nThe size operand shall be a constant expression.\n\nThe [type]s of the [operand]s of an array element constructor\nshall be unifiable.\n\nIf the size operand is greater than one, then the type of the\nrepeat operand shall implement the core::copy::Copy trait\nor the repeat operand shall be a path expression resolving to a\nconstant.\n\nThe type of the size operand shall be type usize.\n\nThe type of an array expression is [T; N], where T is the\nelement type and N is the size of the array. The size of an\narray is determined as follows:\n\n* If the array expression appears with an array element constructor,\n then the size is the number of [operand]s in the\n array element constructor.\n\n* Otherwise the size is the value of size operand.\n\nThe value of an array expression is the constructed array.\n\nThe evaluation of an array expression with an\narray element constructor evaluates its [operand]s in left-to-right\norder.\n\nThe evaluation of an array expression with an\narray repetition constructor proceeds as follows:\n\n#. If the value of the size operand is greater than zero, then the\n repeat operand is evaluated once and its value is\n passed <passing convention> by copy [size operand]'s\n value times.\n\n#. Otherwise the repeat operand is evaluated once.\n\nTwo dimensional array.\n\nAn array of nine 42s.",
      "paragraph_ids": [
        "fls_ya9res33oxt6",
        "fls_fwtd3b10veiw",
        "fls_81jf78m5uga4",
        "fls_3y69y9ga4at7",
        "fls_2l9objtb23zn",
        "fls_9gmnjvs83d8o",
        "fls_by21pey7k423",
        "fls_x2xu2pynxy1u",
        "fls_qplsh3pdqitq",
        "fls_wmsekin1gd2y",
        "fls_2gto5kp9bjw8",
        "fls_guop34ayjw2",
        "fls_aj6tbe54v5jl",
        "fls_t52in1kkyli3",
        "fls_1kj8nlc5eb8a",
        "fls_f3izbkm8607z",
        "fls_5cs68nm54l31",
        "fls_p7hcqryal5cm",
        "fls_izlpt6100gvk"
      ],
      "position": 84340,
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_sxcr4aa098i6",
      "title": "Indexing Expressions",
      "level": 2,
      "file": "expressions",
      "content": "Indexing Expressions\n\n IndexedOperand ::=\n Operand\n\n IndexingOperand ::=\n Operand\n\nAn indexable type is a type that implements the\ncore::ops::Index trait.\n\nAn index expression is an expression that indexes into a value\nof an indexable type.\n\nAn indexed operand is an operand which indicates the value\nbeing indexed into by an index expression.\n\nAn indexing operand is an operand which specifies the index of an\nindex expression.\n\nAn index expression is a constant expression if the\nindexing operand and indexed operand are [constant expression]s.\n\nThe type of the indexing operand is the generic parameter of the\ncore::ops::Index implementation of the type of the\nindexed operand.\n\nIf the indexed operand is evaluated in a value expression context,\nthen\n\n* The type of the indexed operand shall implement the\n core::ops::Index trait.\n\n* The type of the index expression is &T, where T is\n associated type core::ops::Index::Output.\n\nIf the indexed operand is mutable and the index expression is\nevaluated in a mutable place expression context, then\n\n* The type of the indexed operand shall implement the\n core::ops::IndexMut trait.\n\n* The type of the index expression is &mut T, where T is\n the element type of the indexed operand's type.\n\nThe value of an index expression is the indexed memory location.\n\nThe evaluation of an index expression proceeds as follows:\n\n#. The indexed operand is evaluated.\n\n#. The indexing operand is evaluated.\n\n#. If the index expression is evaluated in a mutable place\n expression context, then expression\n *core::ops::IndexMut::index_mut(&mut indexed_operand, indexing_operand)\n is evaluated.\n\n#. Otherwise expression *core::ops::Index::index(&indexed_operand,\n indexing_operand) is evaluated.\n\nEvaluates to 6.",
      "paragraph_ids": [
        "fls_X9kdEAPTqsAe",
        "fls_42ijvuqqqlvh",
        "fls_pc0c22asgzvw",
        "fls_ff3sgpldn52o",
        "fls_w96p9oyv5mqt",
        "fls_u9sl7h4i8hqu",
        "fls_98qeczwv7fmy",
        "fls_sb2b8gszzaxq",
        "fls_issaykiuha75",
        "fls_y3sduoma6q9v",
        "fls_ld7lbvqms5i6",
        "fls_nw705fpon79b",
        "fls_fouu0z3jwoad",
        "fls_6sgj0ltt21i",
        "fls_e5l4y3dy69xi",
        "fls_fza3omn8yw7s",
        "fls_ehamppbq4gmg",
        "fls_i68oxj659hc1",
        "fls_esvpmh6razg3"
      ],
      "position": 87616,
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_k64tfywtn0g8",
      "title": "Tuple Expressions",
      "level": 2,
      "file": "expressions",
      "content": "Tuple Expressions\n\n TupleInitializerList ::=\n ExpressionList\n\nA tuple expression is an expression that constructs a tuple.\n\nA tuple initializer is an operand that provides the value of a\ntuple field in a tuple expression.\n\nThe type of a tuple expression is (T1, T2, ..., TN), where T1\nis the type of the first tuple initializer, T2 is the type of\nthe second tuple initializer, and TN is the type of the N-th\ntuple initializer.\n\nThe value of a tuple expression is (V1, V2, ..., VN), where V1\nis the value of the first tuple initializer, V2 is the value\nof the second tuple initializer, and VN is the value of the\nN-th tuple initializer.\n\nThe evaluation of a tuple expression evaluates its\n[tuple initializer]s in left-to-right order.",
      "paragraph_ids": [
        "fls_87rp1hfwvjel",
        "fls_581y6jq1eyn8",
        "fls_ljz3sxmfzflm",
        "fls_k2aznqo9j49p",
        "fls_waf55yd3mpsq"
      ],
      "position": 90486,
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_8tsynkj2cufj",
      "title": "Struct Expressions",
      "level": 2,
      "file": "expressions",
      "content": "Struct Expressions\n\n Constructee ::=\n PathExpression\n\n StructExpressionContent ::=\n BaseInitializer\n | FieldInitializerList ($$,$$ BaseInitializer | $$,$$?)\n\n BaseInitializer ::=\n $$..$$ Operand\n\n FieldInitializerList ::=\n FieldInitializer ($$,$$ FieldInitializer)*\n\n FieldInitializer ::=\n IndexedInitializer\n | NamedInitializer\n | ShorthandInitializer\n\n IndexedInitializer ::=\n FieldIndex $$:$$ Expression\n\n NamedInitializer ::=\n Identifier $$:$$ Expression\n\n ShorthandInitializer ::=\n Identifier\n\nA struct expression is an expression that constructs an\nenum value, a struct value, or a union value.\n\nA constructee indicates the enum variant, struct, or union\nwhose value is being constructed by a struct expression.\n\nA base initializer is a construct that specifies an enum value, or\na struct value to be used as a base for\nconstruction in a struct expression.\n\nThe type of a base initializer is the type of its operand.\nThe type of a base initializer shall be the same as the type of\nthe constructee.\n\nAn indexed initializer is a construct that specifies the index and\ninitial value of a field in a struct expression.\n\nAn indexed initializer matches a field of the constructee\nwhen the field index of the indexed initializer resolves to a valid\nposition of a field in the constructee. Such an\nindexed initializer is a matched indexed initializer.\n\nThe type of the operand of an indexed initializer and the\ntype of the matched field shall be unifiable.\n\nThe value of an indexed initializer is the value of its\noperand.\n\nA named initializer is a construct that specifies the name and\ninitial value of a field in a struct expression.\n\nA named initializer matches a field of the constructee when\nits identifier and the name of the field are the same. Such a\nnamed initializer is a matched named initializer.\n\nThe type of a named initializer and the type of the matched\nfield shall be unifiable.\n\nThe value of a named initializer is the value of its\nexpression.\n\nA shorthand initializer is a construct that specifies the name\nof a field in a struct expression.\n\nA shorthand initializer is equivalent to a named initializer where\nboth the identifier and the expression of the named initializer\ndenote the identifier of the shorthand initializer.\n\nA shorthand initializer matches a field of the constructee\nwhen its identifier and the name of the field are the same. Such\na shorthand initializer is a matched shorthand initializer.\n\nThe type of a shorthand initializer and the type of the matched\nfield shall be unifiable.\n\nThe value of a shorthand initializer is the value its\nidentifier resolves to.\n\nThe type of a struct expression is the type of the\nconstructee.\n\nThe value of a struct expression is the enum value,\nstruct value, or union value in construction.\n\nIf the constructee is a record enum variant or a record struct,\nthen\n\n* For each field of the constructee, the struct expression shall\n either:\n\n * Contain at most one matched named initializer, or\n\n * Contain at most one matched shorthand initializer, or\n\n * Have exactly one base initializer.\n\n* A base initializer is allowed even if all [field]s of the\n constructee have been matched.\n\nIf the constructee is a tuple enum variant or a tuple struct,\nthen\n\n* For each field of the constructee, the struct expression shall\n either:\n\n * Contain at most one matched indexed initializer, or\n\n * Have exactly one base initializer.\n\n* A base initializer is allowed even if all [field]s of the\n constructee have been matched.\n\nIf the constructee is a union type, then\n\n* The struct expression shall not contain a base initializer.\n\n* For the single field of the constructee, the struct expression\n shall either:\n\n * Contain exactly one matched named initializer, or\n\n * Contain exactly one matched shorthand initializer.\n\nIf the constructee is a unit enum variant or a unit struct, then\nthe struct expression shall have at most one base initializer.\n\nIf a base initializer is supplied, then for each field that was not\nmatched in the struct expression the value of the corresponding\nfield of the base initializer is passed <passing convention> to\nthe field of the constructee.\n\nThe evaluation of a struct expression evaluates its [operand]s in\na left-to-right order.",
      "paragraph_ids": [
        "fls_ij8rebvupb85",
        "fls_4z91ymz3ciup",
        "fls_uib1ml41mfrn",
        "fls_gfu267bpl9ql",
        "fls_ph7fsphbpbv4",
        "fls_y3p6rtm7ek3l",
        "fls_dfajs3xaxbv",
        "fls_e5b9n910z1cp",
        "fls_lwyq3vyc91rn",
        "fls_qed1pps827dv",
        "fls_b60omrhc7t73",
        "fls_z3gj1v6g605r",
        "fls_57t368kema7h",
        "fls_sm2hx8sh4agb",
        "fls_yjx1t3x6qpfg",
        "fls_2dajkhq58cdp",
        "fls_9s4znhi0u3ys",
        "fls_i31rodt42m0z",
        "fls_sjwd8o5mknjo",
        "fls_ccqomsereni2",
        "fls_pivpdyr4seez",
        "fls_bbmm5vir9xos",
        "fls_9370n5xkkzce",
        "fls_rclgwzdhfjj",
        "fls_lmxz5768v5d8",
        "fls_939cugbxju5e",
        "fls_c34qwhaq2asm",
        "fls_j2kmp1fee0g4",
        "fls_90q7krxazc6u",
        "fls_qo05owpmtag0",
        "fls_ywh3nk6emwmw",
        "fls_5w9lj5dc84p",
        "fls_5zceer19mhdu",
        "fls_mq80i8fof7sx",
        "fls_raon1c1vrhx7",
        "fls_njder5r7y5fg",
        "fls_w7x9wy6t0qcp",
        "fls_vsxsbqps64o"
      ],
      "position": 91807,
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_mjVXiDQRIAzU",
      "title": "Invocation Expressions",
      "level": 2,
      "file": "expressions",
      "content": "Invocation Expressions",
      "paragraph_ids": [],
      "position": 98745,
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_xa4nbfas01cj",
      "title": "Call Expressions",
      "level": 3,
      "file": "expressions",
      "content": "Call Expressions\n\n CallOperand ::=\n Operand\n\n ArgumentOperandList ::=\n ExpressionList\n\nA call expression is an expression that invokes a function or\nconstructs a tuple enum variant value or a tuple struct value.\n\nAn argument operand is an operand which is used as an argument in a\ncall expression or a method call expression.\n\nA call operand is the function being invoked or the\ntuple enum variant value or the tuple struct value being constructed\nby a call expression.\n\nA tuple struct call expression is a call expression where the\ncall operand resolves to a tuple struct.\n\nA callee type is either a function item type, a\nfunction pointer type, a tuple enum variant, a\ntuple struct type, or a type that implements any of the\ncore::ops::Fn, core::ops::FnMut, or core::ops::FnOnce\n[trait]s.\n\nThe type of a call expression is the return type of the invoked\nfunction, the type of the tuple enum variant or the\ntuple struct being constructed, or associated type\ncore::ops::FnOnce::Output.\n\nA call expression whose callee type is either an\nexternal function item type, an unsafe function item type, or an\nunsafe function pointer type shall require unsafe context.\n\nThe value of a call expression is determined as follows:\n\n* If the callee type is a function item type or a\n function pointer type, then the value is the result of invoking the\n corresponding function with the [argument operand]s.\n\n* If the callee type is a tuple enum variant or a\n tuple struct type, then the value is the result of constructing\n the tuple enum variant or the tuple struct with the\n [argument operand]s.\n\n* If the callee type implements the core::ops::Fn trait, then\n the value is the result of invoking\n core::ops::Fn::call(adjusted_call_operand, argument_operand_tuple),\n where adjusted_call_operand is the adjusted call operand, and\n argument_operand_tuple is a tuple that wraps the\n [argument operand]s.\n\n* If the call operand implements the core::ops::FnMut trait,\n then the value is the result of invoking\n core::ops::FnMut::call_mut(adjusted_call_operand, argument_operand_tuple),\n where adjusted_call_operand is the adjusted call operand, and\n argument_operand_tuple is a tuple that wraps the\n [argument operand]s.\n\n* If the call operand implements the core::ops::FnOnce trait,\n then the value is the result of invoking\n core::ops::FnOnce::call_once(adjusted_call_operand, argument_operand_tuple),\n where adjusted_call_operand is the adjusted call operand, and\n argument_operand_tuple is a tuple that wraps the\n [argument operand]s.\n\nA call expression is subject to call resolution.\n\nThe evaluation of a call expression proceeds as follows:\n\n#. The call operand is evaluated.\n\n#. The [argument operand]s are evaluated in left-to-right order.\n\n#. If the adjusted call operand is a function item type or\n function pointer type, then corresponding function is invoked.\n\n#. If the type of the call operand implements the\n core::ops::Fn trait, then\n core::ops::Fn::call(adjusted_call_operand, argument_operand_tuple) is\n invoked.\n\n#. If the type of the call operand implements the\n core::ops::FnMut trait, then\n core::ops::FnMut::call_mut(adjusted_call_operand, argument_operand_tuple)\n is invoked.\n\n#. If the type of the call operand implements the\n core::ops::FnOnce trait, then\n core::ops::FnOnce::call_once(adjusted_call_operand, argument_operand_tuple)\n is invoked.\n\nIt is undefined behavior to call a function with an ABI other than the\nABI the function was defined with.",
      "paragraph_ids": [
        "fls_fvgfx17ossd9",
        "fls_jvz5z3eqxb39",
        "fls_7ql1c71eidg8",
        "fls_QpBu34U6hXn9",
        "fls_4t6imtiw6kzt",
        "fls_bu6i3mcvnbin",
        "fls_8ljrgdept7s8",
        "fls_7p6zrjbpj0kl",
        "fls_yrr1s0tucgvh",
        "fls_RZjFs9koNOk8",
        "fls_s3q3sej1hgho",
        "fls_cu2ubdm3tfwb",
        "fls_9bbewx1l7h5h",
        "fls_ZSkcro52q097",
        "fls_ggr5i91vur0r",
        "fls_hwalzgdidbfz",
        "fls_p52mfvpadu7w",
        "fls_1cyo5qhbl1j9",
        "fls_nb0eqky2akzt",
        "fls_9lt4wh9ql5ae",
        "fls_ixebnlcccmit",
        "fls_5yeq4oah58dl"
      ],
      "position": 98815,
      "parent_fls_id": "fls_mjVXiDQRIAzU",
      "sibling_fls_ids": [
        "fls_z7q8kbjwdc7g",
        "fls_8gPCPVc99pXJ"
      ]
    },
    {
      "fls_id": "fls_z7q8kbjwdc7g",
      "title": "Method Call Expressions",
      "level": 3,
      "file": "expressions",
      "content": "Method Call Expressions\n\n ReceiverOperand ::=\n Operand\n\n MethodOperand ::=\n PathExpressionSegment\n\nA method call expression is an expression that invokes a method\nof a variable.\n\nA receiver operand is an operand that denotes the value whose\nmethod is being invoked by a method call expression.\n\nA method operand is an operand that denotes the method being\ninvoked by a method call expression.\n\nThe type of a method call expression is the return type of the\ninvoked method.\n\nThe value of a method call expression is the value returned by\nthe invoked method.\n\nA method call expression is subject to method resolution.\n\nThe evaluation of a method call expression proceeds as follows:\n\n#. The receiver operand is evaluated.\n\n#. The [argument operand]s are evaluated in left-to-right order.\n\n#. The method is invoked.",
      "paragraph_ids": [
        "fls_b7i26954j1hc",
        "fls_jx3ryre0xs88",
        "fls_3AQUOBo7akXu",
        "fls_11glzggtbgb3",
        "fls_ljvj1f9fv085",
        "fls_y7bj7y6davlh",
        "fls_oxxk3snd7ya0",
        "fls_gmpq15g77o20",
        "fls_pu0n9hakkym2",
        "fls_cawdkgvvd1x6"
      ],
      "position": 103773,
      "parent_fls_id": "fls_mjVXiDQRIAzU",
      "sibling_fls_ids": [
        "fls_xa4nbfas01cj",
        "fls_8gPCPVc99pXJ"
      ]
    },
    {
      "fls_id": "fls_8gPCPVc99pXJ",
      "title": "Call Conformance",
      "level": 3,
      "file": "expressions",
      "content": "Call Conformance\n\nA method call expression is equivalent to a call expression where the\ncall operand is the resolved method and the adjusted\nreceiver operand is prepended to the [argument operand]s.\n\nAn argument operand matches a function parameter or field of the\ncallee type when its position and the position of the\nfunction parameter or field are the same. Such an\nargument operand is a matched argument operand.\n\nThe type of a matched argument operand and the type of the\ncorresponding function parameter or field shall be unifiable.\n\nThe number of [argument operand]s shall be equal to the number of\n[field]s or [function parameter]s of the callee type.",
      "paragraph_ids": [
        "fls_tsn6SUUG9LvW",
        "fls_c40C6rg6rGv6",
        "fls_Gr1ixJ9vFjUm",
        "fls_jTMQa6AJSMpE"
      ],
      "position": 105531,
      "parent_fls_id": "fls_mjVXiDQRIAzU",
      "sibling_fls_ids": [
        "fls_xa4nbfas01cj",
        "fls_z7q8kbjwdc7g"
      ]
    },
    {
      "fls_id": "fls_18k3uajrgq5f",
      "title": "Field Access Expressions",
      "level": 2,
      "file": "expressions",
      "content": "Field Access Expressions\n\n ContainerOperand ::=\n Operand\n\n FieldSelector ::=\n IndexedFieldSelector\n | NamedFieldSelector\n\n IndexedFieldSelector ::=\n DecimalLiteral\n\n NamedFieldSelector ::=\n Identifier\n\nA field access expression is an expression that accesses a field\nof a value.\n\nA container operand is an operand that indicates the value whose\nfield is selected in a field access expression.\n\nA field selector is a construct that selects the field to be\naccessed in a field access expression.\n\nA selected field is a field that is selected by a\nfield access expression.\n\nThe type of a field access expression is the type of the\nselected field.\n\nThe value of a field access expression is the value of the\nselected field.\n\nReading the selected field of a union shall require\nunsafe context.\n\nWriting to the selected field of a union where the type of the\nselected field implements the core::marker::Copy trait or the\ncore::mem::ManuallyDrop trait shall not require unsafe context.\n\nWriting to and then reading from the selected field of a union\nsubject to attribute repr is equivalent to invoking function\ncore::mem::transmute<write_type, read_type>(field_bits) where write_type\nis the type used at the time of writing the selected field,\nread_type is the type used at the time of reading the\nselected field, and field_bits is the bit representation of the\nselected field.\n\nA field access expression is subject to field resolution.\n\nIt is undefined behavior reading the selected field of a\nunion type when it contains data that is invalid for the selected\nfield's type.\n\nThe evaluation of a field access expression evaluates its\ncontainer operand.\n\nSee :p:`fls_vsxsbqps64o` for the declaration of alice.\n\nThe following indexed field access evaluates to 42.",
      "paragraph_ids": [
        "fls_hr8qvwlhd9ts",
        "fls_s2vpn4ihenpe",
        "fls_yeuayil6uxzx",
        "fls_qqrconpa92i3",
        "fls_fovs9il2h9xg",
        "fls_r1b4n12i93pg",
        "fls_kddnnz8uc15b",
        "fls_an3no949lvfw",
        "fls_t6xmsm2nk1bc",
        "fls_jjnyuU9KIaGy",
        "fls_Vani4665hiJY",
        "fls_6uzouesw2sod",
        "fls_x27yayh4z787",
        "fls_dimto84ifanr"
      ],
      "position": 106445,
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_tjyexqrx0fx5",
      "title": "Closure Expressions",
      "level": 2,
      "file": "expressions",
      "content": "Closure Expressions\n\n ClosureBody ::=\n Expression\n\n ClosureBodyWithReturnType ::=\n ReturnTypeWithoutBounds BlockExpression\n\n ReturnTypeWithoutBounds ::=\n $$->$$ TypeSpecificationWithoutBounds\n\n ClosureParameterList ::=\n ClosureParameter ($$,$$ ClosureParameter)* $$,$$?\n\n ClosureParameter ::=\n OuterAttributeOrDoc* PatternWithoutAlternation TypeAscription?\n\nA closure expression is an expression that defines a\nclosure type and constructs a value of that type.\n\nAn async closure expression is a closure expression subject to keyword async that defines an async closure type and constructs a value of that type.\n\nThe return type of a closure type is determined as follows:\n\n* If the closure expression specifies a :s:`ClosureBodyWithReturnType`, then the return type is the specified :s:`ReturnTypeWithoutBounds`.\n\n* Otherwise the return type is the type of the closure body.\n\nThe return type of an async closure type is an anonymous return type with a core::future::Future trait bound and a binding argument for the Output associated type alias with the actual return type of the corresponding closure type.\n\nA closure body is a construct that represents the executable portion\nof a closure expression.\n\nA closure body denotes a new control flow boundary.\n\nA closure body is subject to capturing.\n\nA closure parameter is a construct that yields a set of\n[binding]s that bind matched input [value]s to [name]s at the\nsite of a call expression or a method call expression.\n\nThe type of a closure parameter is determined as follows:\n\n* If the closure parameter lacks a :s:`TypeSpecification`, the type is inferred form the usage of the closure parameter.\n\n* Otherwise the type is the specified type.\n\nThe pattern of a closure parameter shall be an\nirrefutable pattern.\n\nThe expected type of the pattern of a closure parameter is the type of the closure parameter.\n\nThe [binding]s of all [pattern]s of all [closure parameter]s of a closure expression shall not shadow another.\n\nThe type of a closure expression is the unique anonymous\nclosure type defined by it.\n\nThe value of a closure expression is the value of the unique\nanonymous closure type instantiated with the selected\n[capture target]s.\n\nThe evaluation of a closure expression proceeds as follows:\n\n#. An anonymous value of an unique anonymous closure type is created.",
      "paragraph_ids": [
        "fls_2d141c9a0yui",
        "fls_My6pMgpeFCFg",
        "fls_UgJgur0z6d4a",
        "fls_af1WL2mBKMfW",
        "fls_wLVeE6cNG8oa",
        "fls_DSy7bPKGzyov",
        "fls_srbl7ptknjyk",
        "fls_oey0ivaiu1l",
        "fls_fg8lx0yyt6oq",
        "fls_c3rzwUxjmBMY",
        "fls_81KOEXwps2HS",
        "fls_XWJ9SFggdVeH",
        "fls_mPWkIxTJErqx",
        "fls_r6gWLoNR7JMR",
        "fls_zsaTK9snhXs0",
        "fls_qPeOL6ZhXsgH",
        "fls_yn30xuejcfxo",
        "fls_sje6cdvifgv5",
        "fls_f59fw17gsasn",
        "fls_7w15ccc1zzxl"
      ],
      "position": 109213,
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_rr908hgunja7",
      "title": "Loop Expressions",
      "level": 2,
      "file": "expressions",
      "content": "Loop Expressions\n\n Label ::=\n $$'$$ NonKeywordIdentifier $$:$$\n\n LoopContent ::=\n ForLoopExpression\n | InfiniteLoopExpression\n | WhileLetLoopExpression\n | WhileLoopExpression\n\n LoopBody ::=\n BlockExpression\n\nA loop expression is an expression that evaluates a block\nexpression continuously as long as some criterion holds true.\n\nA loop body is the block expression of a loop expression.\n\nThe type of the loop body shall be the unit type.\n\nAn anonymous loop expression is a loop expression without a\nlabel.\n\nA named loop expression is a loop expression with a label.\n\nA loop expression is terminated when its block expression is no\nlonger evaluated.",
      "paragraph_ids": [
        "fls_y1d8kd1bdlmx",
        "fls_BjZjuiFnPtFd",
        "fls_XEc0cIkpkyzJ",
        "fls_eg93m93gvwal",
        "fls_phpoq9ho8f1v",
        "fls_aw6qczl4zpko"
      ],
      "position": 112914,
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_onfyolkcbeh3",
      "title": "For Loops",
      "level": 3,
      "file": "expressions",
      "content": "For Loops\n\nA for loop expression is a loop expression that continues to evaluate\nits loop body as long as its subject expression yields a value.\n\nThe type of a subject expression shall implement the\ncore::iter::IntoIterator trait.\n\nThe expected type of the pattern is the associated type core::iter::IntoIterator::Item of the subject expression's core::iter::IntoIterator implementation.\n\nThe type of a for loop expression is the unit type.\n\nThe value of a for loop expression is the unit value.\n\nThe evaluation of a for loop expression of the form\n\nis equivalent to the evaluation of the following block expression:",
      "paragraph_ids": [
        "fls_1bh2alh37frz",
        "fls_fkgbin6ydkm4",
        "fls_fo6Aa6Td6rMA",
        "fls_bmTjhKdpfgCB",
        "fls_FkxLf91WKiIo",
        "fls_kuxo0on3vit6",
        "fls_2lrzrtjhsdes"
      ],
      "position": 114009,
      "parent_fls_id": "fls_rr908hgunja7",
      "sibling_fls_ids": [
        "fls_sf4qnd43z2wc",
        "fls_5jjm1kt43axd",
        "fls_m6kd5i9dy8dx",
        "fls_uusi0zej55is",
        "fls_jr4tpuyksr75",
        "fls_sjwrlwvpulp"
      ]
    },
    {
      "fls_id": "fls_sf4qnd43z2wc",
      "title": "Infinite Loops",
      "level": 3,
      "file": "expressions",
      "content": "Infinite Loops\n\nAn infinite loop expression is a loop expression that continues to\nevaluate its loop body indefinitely.\n\nThe type of an infinite loop expression is determined as follows:\n\n* If the infinite loop expression does not contain a break expression,\n then the type is the never type.\n\n* If the infinite loop expression contains at least one\n break expression, then the type is the unified type of the\n [break type]s of all [break expression]s.\n\nThe value of an infinite loop expression is determined as follows:\n\n* If the infinite loop expression does not contain a break expression,\n then the value is the unit value.\n\n* If the infinite loop expression contains at least one\n break expression, then the value is the break value of the\n break expression that broke out of the loop expression.\n\nThe evaluation of an infinite loop expression proceeds as follows:\n\n#. The block expression is evaluated.\n\n#. Control restarts the evaluation of the infinite loop expression.",
      "paragraph_ids": [
        "fls_p11qw6mtxlda",
        "fls_b314wjbv0zwe",
        "fls_rpedapxnv8w3",
        "fls_wf11yp1jwf53",
        "fls_q3qpcf2fz7h",
        "fls_2ulbzmuuny3g",
        "fls_99imks9hj3kp",
        "fls_w4tj5gofwih1",
        "fls_pg3r6nyl865",
        "fls_lp15ilkul2uv"
      ],
      "position": 115947,
      "parent_fls_id": "fls_rr908hgunja7",
      "sibling_fls_ids": [
        "fls_onfyolkcbeh3",
        "fls_5jjm1kt43axd",
        "fls_m6kd5i9dy8dx",
        "fls_uusi0zej55is",
        "fls_jr4tpuyksr75",
        "fls_sjwrlwvpulp"
      ]
    },
    {
      "fls_id": "fls_5jjm1kt43axd",
      "title": "While Loops",
      "level": 3,
      "file": "expressions",
      "content": "While Loops\n\n IterationExpression ::=\n SubjectExpression\n\nA while loop expression is a loop expression that continues to\nevaluate its loop body as long as its iteration expression holds\ntrue.\n\nAn iteration expression is an expression that provides the criterion\nof a while loop expression.\n\nThe type of an iteration expression shall be type bool.\n\nThe type of a while loop expression is the unit type.\n\nThe value of a while loop expression is the unit value.\n\nThe evaluation of a while loop expression proceeds as follows:\n\n#. The iteration expression is evaluated.\n\n#. If the iteration expression evaluated to true, then:\n\n #. The block expression is evaluated.\n\n #. Control restarts the evaluation of the while loop expression.",
      "paragraph_ids": [
        "fls_ajby242tnu7c",
        "fls_13hmhzqz82v6",
        "fls_d7ofrq3777kq",
        "fls_P8iyTN6KZCVA",
        "fls_s6hRa5spz64w",
        "fls_1i7hm645h7ox",
        "fls_5x0du3u1jwd3",
        "fls_23uluvhhoct6",
        "fls_k7g4cac93617",
        "fls_j08k3brdpgno"
      ],
      "position": 117612,
      "parent_fls_id": "fls_rr908hgunja7",
      "sibling_fls_ids": [
        "fls_onfyolkcbeh3",
        "fls_sf4qnd43z2wc",
        "fls_m6kd5i9dy8dx",
        "fls_uusi0zej55is",
        "fls_jr4tpuyksr75",
        "fls_sjwrlwvpulp"
      ]
    },
    {
      "fls_id": "fls_m6kd5i9dy8dx",
      "title": "While Let Loops",
      "level": 3,
      "file": "expressions",
      "content": "While Let Loops\n\nA while let loop expression is a loop expression that continues to\nevaluate its loop body as long as its subject let expression yields\na value that can be matched against its pattern.\n\nThe expected type of the pattern is the type of the subject let expression.\n\nThe type of a while let loop expression is the unit type.\n\nThe value of a while let loop expression is the unit value.\n\nThe evaluation of a while let loop expression of the form\n\nshall be equivalent to the evaluation the following infinite loop:",
      "paragraph_ids": [
        "fls_fmdlyp9r9zl7",
        "fls_bC60ZSC9yUOI",
        "fls_gTfSLePwHTES",
        "fls_pTq4LIGIoAtN",
        "fls_z2ht5iaat5ag",
        "fls_pacf1uavh1qt"
      ],
      "position": 119088,
      "parent_fls_id": "fls_rr908hgunja7",
      "sibling_fls_ids": [
        "fls_onfyolkcbeh3",
        "fls_sf4qnd43z2wc",
        "fls_5jjm1kt43axd",
        "fls_uusi0zej55is",
        "fls_jr4tpuyksr75",
        "fls_sjwrlwvpulp"
      ]
    },
    {
      "fls_id": "fls_uusi0zej55is",
      "title": "Loop Labels",
      "level": 3,
      "file": "expressions",
      "content": "Loop Labels\n\nA label indication is a construct that indicates a label.\n\nA label indication shall indicate a label of an enclosing\nnamed block expression or named loop expression that does not pass a\ncontrol flow boundary in order to reach the enclosing\nnamed block expression or named loop expression.",
      "paragraph_ids": [
        "fls_tx5u743391h7",
        "fls_7hc8yboeaho0"
      ],
      "position": 120554,
      "parent_fls_id": "fls_rr908hgunja7",
      "sibling_fls_ids": [
        "fls_onfyolkcbeh3",
        "fls_sf4qnd43z2wc",
        "fls_5jjm1kt43axd",
        "fls_m6kd5i9dy8dx",
        "fls_jr4tpuyksr75",
        "fls_sjwrlwvpulp"
      ]
    },
    {
      "fls_id": "fls_jr4tpuyksr75",
      "title": "Break Expressions",
      "level": 3,
      "file": "expressions",
      "content": "Break Expressions\n\nA break expression is an expression that terminates a\nloop expression or a named block expression.\n\nA break expression shall appear within a loop body or a\nnamed block expression.\n\nIf a break expression appears within a named block expression, then\nthe break expression shall have a label indication.\n\nThe label indication of a break expression shall resolve to the\nlabel of an enclosing named block expression or\nnamed loop expression.\n\nA break expression with a label indication is associated with the\nnamed block expression or named loop expression whose label is\nindicated by the label indication.\n\nA break expression without a label indication is associated with the\ninnermost enclosing loop expression.\n\nIf a break expression appears within a loop expression, then the\nbreak expression shall have an operand only when it is associated\nwith an infinite loop.\n\nThe type of a break expression is the never type.\n\nBreak type is the type of the operand of a break expression.\n\nThe break type is determined as follows:\n\n* If the break expression lacks an operand, then the break type\n is the unit type.\n\n* If the break expression has an operand, then the break type is\n the type of its operand.\n\nBreak value is the value of the operand of a\nbreak expression.\n\nThe break value is determined as follows:\n\n* If the break expression lacks an operand, then the break value\n is the unit value.\n\n* If the break expression has an operand, then the break value is\n the value of its operand.\n\nIf a break expression appears within a loop expression, then the\nevaluation of the break expression proceeds as follows:\n\n#. The operand is evaluated.\n\n#. All enclosing [loop expression]s upto and including the associated\n loop expression are terminated.\n\nIf a break expression appears within a named block expression, then\nthe evaluation of the break expression proceeds as follows:\n\n#. The operand is evaluated.\n\n#. All enclosing [named block expression]s upto and including the\n associated named block expression are terminated.\n\nThe following break expression terminates both the inner and the outer loop.",
      "paragraph_ids": [
        "fls_i5ko1t2wbgxe",
        "fls_jiykbp51909f",
        "fls_gnupTkuafKNi",
        "fls_7frvr2nm2mcj",
        "fls_54d5uydc87td",
        "fls_ghxns2nggffj",
        "fls_3hI7FU42sVyX",
        "fls_dnnq1zym8ii0",
        "fls_1wdybpfldj7q",
        "fls_8yore99adr22",
        "fls_60imbzwg3e2x",
        "fls_l0c05wa9q97w",
        "fls_bgd7d5q69q0g",
        "fls_yb8jv4mkmki0",
        "fls_d7l1y2qbe8br",
        "fls_56szfyilc06",
        "fls_jnpx8mx1oa7n",
        "fls_l2kp8mw6bjj0",
        "fls_2nmadhe3ismj",
        "fls_XpFLrL78QMe1",
        "fls_WFAW1PG1YXdM",
        "fls_AurifMM8RpDp",
        "fls_32fwis9pxh77"
      ],
      "position": 121107,
      "parent_fls_id": "fls_rr908hgunja7",
      "sibling_fls_ids": [
        "fls_onfyolkcbeh3",
        "fls_sf4qnd43z2wc",
        "fls_5jjm1kt43axd",
        "fls_m6kd5i9dy8dx",
        "fls_uusi0zej55is",
        "fls_sjwrlwvpulp"
      ]
    },
    {
      "fls_id": "fls_sjwrlwvpulp",
      "title": "Continue Expressions",
      "level": 3,
      "file": "expressions",
      "content": "Continue Expressions\n\nA continue expression shall appear within a loop expression.\n\nA continue expression without a label indication is associated with\nthe innermost enclosing loop expression.\n\nA continue expression with a label indication is associated with a\nnamed loop expression whose label is indicated by the\nlabel indication.\n\nThe type of a continue expression is the never type.\n\nThe evaluation of a continue expression proceeds as follows:\n\n#. If the continue expression appears with a label indication, then\n all enclosing [loop expression]s upto and including the associated\n loop expression are terminated.\n\n#. The evaluation of the associated loop expression is restarted.\n\nThe following continue expression terminates and restarts game_loop.",
      "paragraph_ids": [
        "fls_wzs6kz9ffqzt",
        "fls_r5ke7b9n7k3s",
        "fls_ckm6i9c3s6j8",
        "fls_d0bmw8xiw5nk",
        "fls_vmyuuptfnwek",
        "fls_gm74eo754rq9",
        "fls_gvuesa5ekeif",
        "fls_767gv7zhqamh"
      ],
      "position": 124480,
      "parent_fls_id": "fls_rr908hgunja7",
      "sibling_fls_ids": [
        "fls_onfyolkcbeh3",
        "fls_sf4qnd43z2wc",
        "fls_5jjm1kt43axd",
        "fls_m6kd5i9dy8dx",
        "fls_uusi0zej55is",
        "fls_jr4tpuyksr75"
      ]
    },
    {
      "fls_id": "fls_18swodqqzadj",
      "title": "Range Expressions",
      "level": 2,
      "file": "expressions",
      "content": "Range Expressions\n\n RangeFromExpression ::=\n RangeExpressionLowBound $$..$$\n\n RangeFromToExpression ::=\n RangeExpressionLowBound $$..$$ RangeExpressionHighBound\n\n RangeFullExpression ::=\n $$..$$\n\n RangeInclusiveExpression ::=\n RangeExpressionLowBound $$..=$$ RangeExpressionHighBound\n\n RangeToExpression ::=\n $$..$$ RangeExpressionHighBound\n\n RangeToInclusiveExpression ::=\n $$..=$$ RangeExpressionHighBound\n\n RangeExpressionLowBound ::=\n Operand\n\n RangeExpressionHighBound ::=\n Operand\n\nA range expression is an expression that constructs a range.\n\nA range expression low bound is an operand that specifies the start of\na range.\n\nA range expression high bound is an operand that specifies the end of\na range.\n\nIf a range expression has two [operand]s, then the [type]s of the\n[operand]s shall be unifiable.\n\nA range-from expression is a range expression that specifies an\nincluded range expression low bound.\n\nThe type of a range-from expression is core::ops::RangeFrom.\n\nThe value of a range-from expression is\ncore::ops::RangeFrom { start: range_expression_low_bound }.\n\nA range-from-to expression is a range expression that specifies an\nincluded range expression low bound and an excluded\nrange expression high bound.\n\nThe type of a range-from-to expression is core::ops::Range.\n\nThe value of a range-from-to expression is\ncore::ops::Range { start: range_expression_low_bound, end: range_expression_high_bound }.\n\nA range-full expression is a range expression that covers the whole\nrange of a type.\n\nThe type of a range-full expression is core::ops::RangeFull.\n\nThe value of a range-full expression is core::ops::RangeFull {}.\n\nA range-inclusive expression is a range expression that specifies an\nincluded range expression low bound and an included\nrange expression high bound.\n\nThe type of a range-inclusive expression is\ncore::ops::RangeInclusive.\n\nThe value of a range-inclusive expression is\ncore::ops::RangeInclusive::new(range_expression_low_bound, range_expression_high_bound).\n\nA range-to expression is a range expression that specifies an excluded\nrange expression high bound.\n\nThe type of a range-to expression is core::ops::RangeTo.\n\nThe value of a range-to expression is\ncore::ops::RangeTo { end: range_expression_high_bound }.\n\nA range-to-inclusive expression is a range expression that specifies\nan included range expression high bound.\n\nThe type of a range-to-inclusive expression is\ncore::ops::RangeToInclusive.\n\nThe value of a range-to-inclusive expression is\ncore::ops::RangeToInclusive { end: range_expression_high_bound }.\n\nThe evaluation of a range expression evaluates its [operand]s in\nleft-to-right order.",
      "paragraph_ids": [
        "fls_bi82rusji8g0",
        "fls_msyv4oyk5zp9",
        "fls_f648uuxxh4vk",
        "fls_9pl4629t54yq",
        "fls_xaumwogwbv3g",
        "fls_exa2ufugnpgc",
        "fls_jqy0p155btca",
        "fls_ppustuqdji7b",
        "fls_ke2fpgodq84u",
        "fls_zb6jk6qykun6",
        "fls_x67xo25n0qlz",
        "fls_m6n0gvg3ct1b",
        "fls_yvh5cdgzevni",
        "fls_lh9my7g8oflq",
        "fls_livflk52xaj9",
        "fls_vj213j9bj61y",
        "fls_5a1uivj19kob",
        "fls_k611yoc8hk0n",
        "fls_m0slikrulnvd",
        "fls_1gc436ee1nzm",
        "fls_8sfjw83irpre",
        "fls_5xw4opkbxhsc",
        "fls_ehseim1p479z"
      ],
      "position": 125883,
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_nlzksiu8y3z9",
      "title": "If and If Let Expressions",
      "level": 2,
      "file": "expressions",
      "content": "If and If Let Expressions",
      "paragraph_ids": [],
      "position": 129895,
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_mkut7gut49gi",
      "title": "If Expressions",
      "level": 3,
      "file": "expressions",
      "content": "If Expressions\n\n ElseExpression ::=\n $$else$$ (BlockExpression | IfExpression | IfLetExpression)\n\nAn if expression is an expression that evaluates either a\nblock expression or an else expression depending on the value of\nits subject expression.\n\nAn else expression is an expression that represents either a\nblock expression, an if expression, or an if let expression.\n\nThe type of the subject expression of an if expression shall be\ntype bool.\n\nThe type of an if expression is the type of its\nblock expression.\n\nThe value of an if expression is the value of its\nblock expression.\n\nThe type of an else expression is the type of its\nblock expression, if expression, or if let expression.\n\nThe value of an else expression is the value of its\nblock expression, if expression, or if let expression.\n\nThe type of an if expression and the type of an\nelse expression shall be unifiable.\n\nThe evaluation of an if expression proceeds as follows:\n\n#. The subject expression is evaluated.\n\n#. If the subject expression evaluated to true, then the\n block expression is evaluated.\n\n#. If the subject expression evaluated to false and the\n if expression has an else expression, then the else expression\n is evaluated.\n\nThe evaluation of an else expression evaluates its\nblock expression, if expression, or if let expression.",
      "paragraph_ids": [
        "fls_2i4fbxbbvpf1",
        "fls_5azwlk7hav1k",
        "fls_r7gzxo16esri",
        "fls_iv9t4nfs4f6w",
        "fls_i9sxf2q5jjqt",
        "fls_1e8qer6bh2f3",
        "fls_p5pjxk5xfcbx",
        "fls_mpq7gicosgkt",
        "fls_yhlyzef9h97q",
        "fls_w7lq4dkoyuf7",
        "fls_5udx9zyeg5ga",
        "fls_67l4j48n6p7o",
        "fls_e8gd5lzcaifw"
      ],
      "position": 129971,
      "parent_fls_id": "fls_nlzksiu8y3z9",
      "sibling_fls_ids": [
        "fls_p0t1ch115tra"
      ]
    },
    {
      "fls_id": "fls_p0t1ch115tra",
      "title": "If Let Expressions",
      "level": 3,
      "file": "expressions",
      "content": "If Let Expressions\n\nAn if let expression is an expression that evaluates either a\nblock expression or an else expression depending on whether its\npattern can be matched against its subject let expression.\n\nThe expected type of the pattern is the type of the subject let expression.\n\nThe type of an if let expression is the type of its\nblock expression.\n\nThe value of an if let expression is the value of its\nblock expression.\n\nThe type of an if let expression and the type of an\nelse expression shall be unifiable.\n\nThe evaluation of an if let expression of the form\n\nis equivalent to the evaluation of the following match expression:\n\nThe evaluation of an if let expression of the form\n\nis equivalent to the evaluation of the following match expression:",
      "paragraph_ids": [
        "fls_dsrjup2umr9",
        "fls_okVOYzTT6fBK",
        "fls_4vyrufo4qdeg",
        "fls_qfnwwvzxsl3",
        "fls_lEr4iqwdBcbA",
        "fls_ijo73wtz1sy",
        "fls_qeho5iqiy59",
        "fls_nhngr8y850dt",
        "fls_8fg2ufaxjkv5"
      ],
      "position": 132336,
      "parent_fls_id": "fls_nlzksiu8y3z9",
      "sibling_fls_ids": [
        "fls_mkut7gut49gi"
      ]
    },
    {
      "fls_id": "fls_e5td0fa92fay",
      "title": "Match Expressions",
      "level": 2,
      "file": "expressions",
      "content": "Match Expressions\n\n MatchArmList ::=\n IntermediateMatchArm* FinalMatchArm\n\n IntermediateMatchArm ::=\n MatchArmMatcher $$=>$$\n $$($$ ExpressionWithBlock $$,$$? | ExpressionWithoutBlock $$,$$ $$)$$\n\n FinalMatchArm ::=\n MatchArmMatcher $$=>$$ Operand $$,$$?\n\n MatchArmMatcher ::=\n OuterAttributeOrDoc* Pattern MatchArmGuard?\n\n MatchArmGuard ::=\n $$if$$ Operand\n\nA match expression is an expression that tries to match one of its\nmultiple [pattern]s against its subject expression and if it succeeds,\nevaluates an operand.\n\nA match arm is a construct that consists of a match arm matcher\nand a match arm body.\n\nAn intermediate match arm is any non-[final match arm] of a\nmatch expression.\n\nA final match arm is the last match arm of a match expression.\n\nA match arm matcher is a construct that consists of a pattern and\na match arm guard.\n\nThe expected type of the pattern of the match arm matcher is the type of the subject expression.\n\nA match arm body is the operand of a match arm.\n\nA match arm guard is a construct that provides additional filtering to\na match arm matcher.\n\n[Binding]s introduced in the pattern of a match arm matcher are\nimmutable in the match arm guard.\n\nThe type of the subject expression and the [type]s of all\n[pattern]s of all [match arm matcher]s shall be unifiable.\n\nThe type of the operand of a match arm guard shall be type\nbool.\n\nThe [type]s of all match arm bodies <match arm body> shall be\nunifiable.\n\nThe type of a match expression is the unified type of the\n[type]s of the [operand]s of all [match arm]s.\n\nA match arm is selected when its pattern matches the\nvalue of the subject expression and its match arm guard (if any) evaluates to\ntrue.\n\nMatch arm selection happens in declarative order.\n\nThe [pattern]s of all [match arm]s taken together shall exhaustively\nmatch the [subject expression]'s type.\n\nThe value of a match expression is the value of the operand\nof the selected match arm.\n\nThe evaluation of a match expression proceeds as follows:\n\n#. The subject expression is evaluated.\n\n#. Each match arm is evaluated in declarative order as follows:\n\n #. The match arm matcher of the match arm is evaluated.\n\n #. If the match arm matcher succeeds, then\n\n #. The operand of the match arm is evaluated.\n\n #. Control stops the evaluation of the match expression.\n\n #. Otherwise control proceeds with the evaluation of the next\n match arm.\n\nThe evaluation of a match arm matcher proceeds as follows:\n\n#. The pattern of the match arm matcher is evaluated.\n\n#. If the pattern succeeds, then\n\n #. If the match arm matcher has a match arm guard, then\n\n #. The match arm guard is evaluated.\n\n #. If the match arm guard evaluates to true, then the\n match arm matcher succeeds.\n\n #. Otherwise the match arm matcher fails.\n\n#. Otherwise the match arm matcher fails.\n\nThe evaluation of a match arm guard evaluates its operand. A\nmatch arm guard evaluates to true when its operand evaluates to\ntrue, otherwise it evaluates to false.",
      "paragraph_ids": [
        "fls_ei4pbeksd1v8",
        "fls_l45i24ikfavm",
        "fls_d9gerg12hm2d",
        "fls_oj8dg28xw5yp",
        "fls_lrdrtedyz28i",
        "fls_zJQ4LecT1HYd",
        "fls_8wjdichfxp0y",
        "fls_hs1rr54hu18w",
        "fls_RPMOAaZ6lflI",
        "fls_knv1affr2o8t",
        "fls_bzhz5wjd90ii",
        "fls_17ag0wzdbxv6",
        "fls_5w964phrru82",
        "fls_g6xyz0beps3o",
        "fls_8dba4o5qg8js",
        "fls_e02um1gb89d0",
        "fls_4sh2yrslszvb",
        "fls_g551l8r8yh6d",
        "fls_y44jzkbv74bv",
        "fls_jwxykea99psw",
        "fls_pgulnjeoxwtj",
        "fls_2dg7wl68z7ar",
        "fls_yv11febo0kyb",
        "fls_mvi9z1x836qu",
        "fls_81nnizrxgrsm",
        "fls_4dv7x9nh2h4e",
        "fls_k7kliy101m0f",
        "fls_k68zkb6jv0vz",
        "fls_gbb6wbmher5z",
        "fls_jl4av757yx8j",
        "fls_wkh5wztauwhu",
        "fls_f5f0x8jstp1g",
        "fls_yk8l9zjh7i0d",
        "fls_sbtx1l6n2tp2"
      ],
      "position": 134315,
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_8l74abhlxzdl",
      "title": "Return Expressions",
      "level": 2,
      "file": "expressions",
      "content": "Return Expressions\n\nA return expression is an expression that optionally yields a\nvalue and causes control flow to return to the end of the enclosing\ncontrol flow boundary.\n\nA return expression shall appear within a control flow boundary.\n\nThe type of a return expression is the never type.\n\nThe value returned by a return expression is determined as follows:\n\n* If the return expression has an operand, then the value is the\n value of the operand.\n\n* If the return expression does not have an operand, then the\n value is the unit value.\n\nThe evaluation of a return expression proceeds as follows:\n\n#. If the return expression has an operand, then\n\n #. The operand is evaluated.\n\n #. The value of the operand is passed <passing convention>\n by move into the designated output location of the enclosing\n control flow boundary.\n\n#. Control destroys the current activation frame.\n\n#. Control is transferred to the caller frame.",
      "paragraph_ids": [
        "fls_u7jk4j8gkho",
        "fls_5v3j5ghhw8j8",
        "fls_7Ck4LMQMeQCv",
        "fls_r610t5vsi7bx",
        "fls_njndlx2rps2k",
        "fls_tjksia7prao1",
        "fls_bqmwlona6l5w",
        "fls_d9avvfi548t7",
        "fls_o3fc1z2mn8zc",
        "fls_bbf54ukld7j9",
        "fls_99ea30a5mulj",
        "fls_ubwj8uj6sbgt"
      ],
      "position": 139323,
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_hyrbmfmf6r8g",
      "title": "Await Expressions",
      "level": 2,
      "file": "expressions",
      "content": "Await Expressions\n\n FutureOperand ::=\n Operand\n\nAn await expression is an expression that polls a future,\nsuspending the execution of the future until the future is ready.\n\nA future operand is an operand whose future is being awaited by\nan await expression.\n\nAn await expression shall appear within an\nasync control flow boundary. Only the innermost control flow boundary\nshall be considered.\n\nThe type of a future operand shall implement the\ncore::future::IntoFuture trait.\n\nThe type of an await expression is\n<_ as core::future::IntoFuture>::Output.\n\nThe value of an await expression is the value held by\ncore::task::Poll::Ready.\n\nThe evaluation of an await expression proceeds as follows:\n\n#. The future operand is evaluated to a temporary by invoking\n core::future::IntoFuture::into_future with the future operand.\n\n#. The temporary is pinned using core::pin::Pin::new_unchecked.\n\n#. The pinned temporary is polled using core::future::Future::poll,\n passing in the core::task::Context of the current task.\n\n#. If core::future::Future::poll returns\n core::task::Poll::Pending, then the current future yields.\n\n#. If core::future::Future::poll returns core::task::Poll::Ready,\n then\n\n #. The value held within is unwrapped.\n\n #. Control stops the evaluation of the await expression.",
      "paragraph_ids": [
        "fls_sjz5s71hwm7l",
        "fls_vhchgab59jvd",
        "fls_k9pncajmhgk1",
        "fls_9uw5pd7kbrx3",
        "fls_c6mxfzef2qop",
        "fls_l396mo6k9ox7",
        "fls_1ppywe40s62c",
        "fls_eymcs2rgv3qw",
        "fls_qshnnpirkasz",
        "fls_umevprl99y6c",
        "fls_k76d8ady623m",
        "fls_frwtufwe8dya",
        "fls_u72ylhlmqge3",
        "fls_tn3vwidct3ks"
      ],
      "position": 141075,
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_kw25194gpael",
      "title": "Expression Precedence",
      "level": 2,
      "file": "expressions",
      "content": "Expression Precedence\n\nCertain [expression]s are subject to precedence and\nassociativity.\n\nPrecedence is the order by which [expression]s are evaluated in the\npresence of other [expression]s.\n\nAssociativity is the order by which [operand]s are evaluated within a\nsingle expression.\n\nThe precedence and associativity of qualifying [expression]s are\nas follows:",
      "paragraph_ids": [
        "fls_cwt7afsbgs7w",
        "fls_ya23jjg5wjl",
        "fls_bezkcuwp5qol",
        "fls_48br7odx6nke",
        "fls_mk2yk99p6nvp",
        "fls_jtdnf0vmn6xt",
        "fls_qurz25skmryg",
        "fls_ywqn5nixelkz",
        "fls_k3ohh8k888c",
        "fls_41n6z85h1z47",
        "fls_f39rzauxrlcl",
        "fls_djphr5mk0t6f",
        "fls_sif2aqky96j6",
        "fls_d7x817v8xzea",
        "fls_1f5ibdkz3l51",
        "fls_t1zqnab8a752",
        "fls_f6in3h5cj8i6",
        "fls_hxa1avitfvrq",
        "fls_sy2xzzq06i0x",
        "fls_hish3qfmawd",
        "fls_ruy7e6yccsqk",
        "fls_9qcm0dx9rolw",
        "fls_1l3rgtm6o54s",
        "fls_hr4kokysrjop"
      ],
      "position": 143263,
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_jmjn8jkbzujm",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_jmjn8jkbzujm",
      "title": "Capturing",
      "level": 2,
      "file": "expressions",
      "content": "Capturing\n\nA capturing expression is either an async block expression or a\nclosure expression.\n\nA capture target is either a variable or a field of a\nvariable.\n\nThe capturing environment of a capturing expression consists of the\n[value]s of all captured [capture target]s.\n\nCapturing is the process of saving the [capture target]s of a\n[capturing expression]'s capturing environment.\n\nA capture target requires capturing when it is used by\nthe capturing expression and it is defined outside of the\ncapturing expression. Such a capture target is said to be\ncaptured.\n\nCapture mode is the mechanism by which a capture target is captured.\n\nA captured capture target with capture mode by value capture\npasses <passing convention> the value of the capture target into\nthe capturing environment.\n\nA captured capture target with capture mode\nby immutable reference capture binds an immutable reference to the\ncapture target and passes the immutable reference into the\ncapturing environment.\n\nA captured capture target with capture mode\nby mutable reference capture binds a mutable reference to the\ncapture target and passes the mutable reference into the\ncapturing environment.\n\nA captured capture target with capture mode\nby unique immutable reference capture binds a\nunique immutable reference to the capture target and passes the\nmutable reference into the capturing environment.\n\nThe capture mode is determined based on the use of the capture target\nwithin the capturing expression, as follows:\n\n#. If the capturing expression is subject to keyword move, then\n the capture mode is by value capture.\n\n#. Otherwise the capture mode is determined based on the following\n precedence:\n\n #. By immutable reference capture.\n\n #. By unique immutable reference capture mode, if the\n capture target is a mutable reference that is being modified.\n\n #. By mutable reference capture mode.\n\n #. By value capture.\n\nA tool selects the first capture mode that is compatible with the use of\nthe capture target.",
      "paragraph_ids": [
        "fls_iamnzlm430ef",
        "fls_eca6tl7j0afx",
        "fls_e70ywb8191h",
        "fls_1y2ttb466m9c",
        "fls_ip81lt2mm940",
        "fls_y9n1i4hbq8sf",
        "fls_O6WYL8AUyPje",
        "fls_aCxt2Ovmb5He",
        "fls_xTNFfkxHm5yy",
        "fls_8HLaLAIZgYfs",
        "fls_t695ps4lfh6z",
        "fls_6j8cr7d5zs1l",
        "fls_l8e98pyhm08g",
        "fls_33hfay24hx8u",
        "fls_wmxsd0i2yemf",
        "fls_lu779ufqhggl",
        "fls_uqy5w9uc8gla",
        "fls_wvob7114tfat"
      ],
      "position": 146407,
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_ZfIBiJMf8qE1"
      ]
    },
    {
      "fls_id": "fls_ZfIBiJMf8qE1",
      "title": "Arithmetic Overflow",
      "level": 2,
      "file": "expressions",
      "content": "Arithmetic Overflow\n\nAn arithmetic overflow occurs when an operator expression computes a\nvalue of a scalar type that lies outside of the range of valid\n[value]s for the scalar type or when one or more operand of an\noperator expression lies outside of the range of valid [value]s for\nthe operation.\n\nThere are two allowed behaviors for arithmetic overflow:\n\n#. Evaluation of the expression may result in a panic.\n\n#. The resulting value of the expression may be truncated, discarding\n the most significant bits that do not fit in the target type.",
      "paragraph_ids": [
        "fls_oFIRXBPXu6Zv",
        "fls_8fU3h8PLasqA",
        "fls_R48VKcEIbfXC",
        "fls_QMpI8K43K2yU"
      ],
      "position": 149288,
      "parent_fls_id": "fls_ckvjj4tt1hh2",
      "sibling_fls_ids": [
        "fls_isyftqu120l",
        "fls_h0dvogc64tfh",
        "fls_6l60b5hwnjbm",
        "fls_hndm19t57wby",
        "fls_izdv9i4spokw",
        "fls_tpwp86mronn2",
        "fls_g0uyl7qw4c7w",
        "fls_xinykul167l",
        "fls_sxcr4aa098i6",
        "fls_k64tfywtn0g8",
        "fls_8tsynkj2cufj",
        "fls_mjVXiDQRIAzU",
        "fls_18k3uajrgq5f",
        "fls_tjyexqrx0fx5",
        "fls_rr908hgunja7",
        "fls_18swodqqzadj",
        "fls_nlzksiu8y3z9",
        "fls_e5td0fa92fay",
        "fls_8l74abhlxzdl",
        "fls_hyrbmfmf6r8g",
        "fls_kw25194gpael",
        "fls_jmjn8jkbzujm"
      ]
    },
    {
      "fls_id": "fls_osd6c4utyjb3",
      "title": "FFI",
      "level": 1,
      "file": "ffi",
      "content": "FFI\n\nForeign Function Interface or FFI employs ABI,\n[attribute]s, [external block]s, [external function]s, linkage,\nand type layout to interface a Rust program with foreign code.\n\nThe following [attribute]s affect FFI:\n\n* Attribute export_name.\n\n* Attribute link.\n\n* Attribute link_section\n\n* Attribute no_mangle.\n\n* Attribute used.",
      "paragraph_ids": [
        "fls_djlglv2eaihl",
        "fls_k1hiwghzxtfa",
        "fls_3cgtdk4698hm",
        "fls_shzmgci4f7o5",
        "fls_m7x5odt4nb23",
        "fls_4akfvpq1yg4g",
        "fls_9d8v0xeyi0f"
      ],
      "position": 125,
      "parent_fls_id": null,
      "sibling_fls_ids": [
        "fls_l21tjqjkkaa0",
        "fls_gvwd0kf72jt",
        "fls_3v733mnewssy",
        "fls_gdeyap4or1db",
        "fls_dzq9cdz4ibsz",
        "fls_ckvjj4tt1hh2",
        "fls_qcb1n9c0e5hz",
        "fls_48qldfwwh493",
        "fls_y2k5paj8m8ug",
        "fls_fk2m2irwpeof",
        "fls_z1il3w9nulzy",
        "fls_wb86edg02t6a",
        "fls_411up5z0b6n6",
        "fls_83182bfa9uqb",
        "fls_ronnwodjjjsh",
        "fls_xgqh0ju6bmbn",
        "fls_hdwwrsyunir",
        "fls_wdicg3sqa98e",
        "fls_vgb6ev541b2r",
        "fls_EBwqH60SUHiN",
        "fls_jep7p27kaqlp",
        "fls_94a8v54bufn8"
      ]
    },
    {
      "fls_id": "fls_usgd0xlijoxv",
      "title": "ABI",
      "level": 2,
      "file": "ffi",
      "content": "ABI\n\n AbiKind ::=\n RawStringLiteral\n | StringLiteral\n\nApplication Binary Interface or ABI is a set of conventions that\ndictate how data and computation cross language boundaries.\n\nThe ABI kind indicates the ABI of a construct.\n\nThe following [ABI]s are supported:\n\n* extern \"C\" - The default ABI of C code, referred to as\n extern C ABI.\n\n* extern \"C-unwind\" - The same as extern \"C\" with the addition that\n unwinding across FFI is permitted.\n\n* extern \"Rust\" - The default ABI of a Rust program, referred to as\n Rust ABI.\n\n* extern \"system\" - The operating system-dependent ABI.\n\n* extern \"system-unwind\" - The same as extern \"system\" with the\n addition that unwinding across FFI is permitted.\n\nA function without an explicit ABI has implicit Rust ABI, unless\nit appears within an external block.\n\nA function with an ABI but without a specified ABI kind has\nimplicit extern C ABI.\n\nA tool is allowed to specify additional [ABI]s. These [ABI]s may\ninclude, but may not be limited to, the following:\n\n* extern \"aapcs\" - The soft-float ABI for 32-bit ARM targets.\n\n* extern \"aapcs-unwind\" - The same as extern \"aapcs\"\n with the addition that unwinding across FFI is permitted.\n\n* extern \"cdecl\" - The x86_32 ABI of C code.\n\n* extern \"cdecl-unwind\" - The same as extern \"cdecl\"\n with the addition that unwinding across FFI is permitted.\n\n* extern \"fastcall\" - The fastcall ABI that corresponds to MSVC's\n __fastcall and GCC and clang's __attribute__((fastcall)).\n\n* extern \"stdcall\" - The x86_32 ABI of the Win32 API.\n\n* extern \"sysv64\" - The x86_64 non-Windows ABI of C code.\n\n* extern \"sysv64-unwind\" - The same as extern \"sysv64\"\n with the addition that unwinding across FFI is permitted.\n\n* extern \"vectorcall\" - The vectorcall ABI that corresponds to\n MSVC's __vectorcall and clang's __attribute__((vectorcall)).\n\n* extern \"win64\" - The x86_64 Windows ABI of C code.\n\n* extern \"win64-unwind\" - The same as extern \"win64\"\n with the addition that unwinding across FFI is permitted.\n\n* extern \"efiapi\" - The ABI for `UEFI <https://uefi.org/specifications>`_.\n\nIt is undefined behavior when a foreign exception crosses a\nforeign function interface boundary with an ABI that does not end in\n-unwind.",
      "paragraph_ids": [
        "fls_xangrq3tfze0",
        "fls_2w0xi6rxw3uz",
        "fls_9zitf1fvvfk8",
        "fls_x7ct9k82fpgn",
        "fls_LfjvLXvI6TFL",
        "fls_a2d8ltpgtvn6",
        "fls_8m7pc3riokst",
        "fls_NQAzj5ai1La5",
        "fls_r2drzo3dixe4",
        "fls_z2kzyin8dyr7",
        "fls_j6pqchx27ast",
        "fls_dbbfqaqa80r8",
        "fls_UippZpUyYpHl",
        "fls_36qrs2fxxvi7",
        "fls_CIyK8BYzzo26",
        "fls_6rtj6rwqxojh",
        "fls_d3nmpc5mtg27",
        "fls_7t7yxh94wnbl",
        "fls_ccFdnlX5HIYk",
        "fls_sxj4vy39sj4g",
        "fls_tyjs1x4j8ovp",
        "fls_xrCRprWS13R1",
        "fls_JHlqXjn4Sf07",
        "fls_M4LqHf8hbPA8"
      ],
      "position": 784,
      "parent_fls_id": "fls_osd6c4utyjb3",
      "sibling_fls_ids": [
        "fls_tmoh3y9oyqsy",
        "fls_yztwtek0y34v",
        "fls_s4yt19sptl7d"
      ]
    },
    {
      "fls_id": "fls_tmoh3y9oyqsy",
      "title": "External Blocks",
      "level": 2,
      "file": "ffi",
      "content": "External Blocks\n\n ExternItem ::=\n OuterAttributeOrDoc* (ExternalItemWithVisibility | TerminatedMacroInvocation)\n\n ExternalItemWithVisibility ::=\n VisibilityModifier? (\n FunctionDeclaration\n | StaticDeclaration\n )\n\nAn external block is a construct that provides the declarations of\n[external function]s and [external static]s as unchecked imports.\n\nAn unsafe external block is an external block subject to keyword unsafe.\n\nThe ABI of an external block is determined as follows:\n\n* If the external block specifies an :s:`AbiKind`, then the ABI is the specified :s:`AbiKind`.\n\n* Otherwise the ABI is the extern C ABI.",
      "paragraph_ids": [
        "fls_4dje9t5y2dia",
        "fls_8ltVLtAfvy0m",
        "fls_Nz0l16hMxqTd",
        "fls_4XOoiFloXM7t",
        "fls_PBsepNHImJKH"
      ],
      "position": 4162,
      "parent_fls_id": "fls_osd6c4utyjb3",
      "sibling_fls_ids": [
        "fls_usgd0xlijoxv",
        "fls_yztwtek0y34v",
        "fls_s4yt19sptl7d"
      ]
    },
    {
      "fls_id": "fls_yztwtek0y34v",
      "title": "External Functions",
      "level": 2,
      "file": "ffi",
      "content": "External Functions\n\nAn external function is an unchecked import of a foreign function.\n\nAn external function shall be invoked from an unsafe context unless it is defined in an unsafe external block and subject to :s:`ItemSafety` with keyword safe.\n\nAn external function shall not specify a :s:`FunctionQualifierList`.\n\nAn external function inherits the ABI of its enclosing\nexternal block.\n\nAn external function shall not specify a :s:`GenericParameterList`\ncontaining [constant parameter]s or [type parameter]s.\n\nAn external function shall not specify a :s:`FunctionBody`.\n\nAn external function shall not specify [pattern]s other than\n[identifier pattern]s and [underscore pattern]s.\n\nOnly the last parameter :s:`FunctionParameter` of an external function may\nspecify a :s:`FunctionParameterVariadicPart`.",
      "paragraph_ids": [
        "fls_v24ino4hix3m",
        "fls_l88r9fj82650",
        "fls_qwchgvvnp0qe",
        "fls_w00qi1gx204e",
        "fls_m7tu4w4lk8v",
        "fls_rdu4723vp0oo",
        "fls_9div9yusw64h",
        "fls_juob30rst11r"
      ],
      "position": 5543,
      "parent_fls_id": "fls_osd6c4utyjb3",
      "sibling_fls_ids": [
        "fls_usgd0xlijoxv",
        "fls_tmoh3y9oyqsy",
        "fls_s4yt19sptl7d"
      ]
    },
    {
      "fls_id": "fls_s4yt19sptl7d",
      "title": "External Statics",
      "level": 2,
      "file": "ffi",
      "content": "External Statics\n\nAn external static is an import of a foreign variable.\n\nAn external static inherits the ABI of its enclosing\nexternal block.\n\nAn external static shall be referenced from an unsafe context unless it is defined in an unsafe external block and subject to :s:`ItemSafety` with keyword safe.\n\nAn external static shall not specify a static initializer.\n\nAn immutable external static shall be initialized before Rust code\nis executed.",
      "paragraph_ids": [
        "fls_8ddsytjr4il6",
        "fls_H0cg9XMaGz0y",
        "fls_fo9with6xumo",
        "fls_tr7purzcldn0",
        "fls_en2h09ehj0j3"
      ],
      "position": 6698,
      "parent_fls_id": "fls_osd6c4utyjb3",
      "sibling_fls_ids": [
        "fls_usgd0xlijoxv",
        "fls_tmoh3y9oyqsy",
        "fls_yztwtek0y34v"
      ]
    },
    {
      "fls_id": "fls_qcb1n9c0e5hz",
      "title": "Functions",
      "level": 1,
      "file": "functions",
      "content": "Functions\n\n FunctionQualifierList ::=\n $$const$$? $$async$$? ItemSafety? AbiSpecification?\n\n FunctionParameterList ::=\n (FunctionParameter ($$,$$ FunctionParameter)* $$,$$?)\n | (SelfParameter ($$,$$ FunctionParameter)* $$,$$?)\n\n FunctionParameter ::=\n OuterAttributeOrDoc* (FunctionParameterPattern | FunctionParameterVariadicPart | TypeSpecification)\n\n FunctionParameterPattern ::=\n PatternWithoutAlternation (TypeAscription | ($$:$$ FunctionParameterVariadicPart))\n\n FunctionParameterVariadicPart ::=\n $$...$$\n\n ReturnType ::=\n $$->$$ TypeSpecification\n\n FunctionBody ::=\n BlockExpression\n\n SelfParameter ::=\n OuterAttributeOrDoc* (ShorthandSelf | TypedSelf)\n\n ShorthandSelf ::=\n ($$&$$ LifetimeIndication?)? $$mut$$? $$self$$\n\n TypedSelf ::=\n $$mut$$? $$self$$ TypeAscription\n\nA function is a value of a function type that models a behavior.\n\nA function declares a unique function item type for itself.\n\nA function qualifier is a construct that determines the role of\na function.\n\nA function shall not be subject to both keyword async and\nkeyword const.\n\nA function parameter is a construct that yields a set of\n[binding]s that bind matched input [value]s to [name]s at the\nsite of a call expression or a method call expression.\n\nA self parameter is a function parameter expressed by keyword\nself.\n\nA function shall not specify a self parameter unless it is an\nassociated function.\n\nThe type of a function parameter is determined as follows:\n\n* If the function parameter is a self parameter without a :s:`TypeSpecification`:\n\n * And the self parameter has token & and keyword mut, then the type is &mut Self.\n\n * And the self parameter has token & and lacks keyword mut, then the type is &Self.\n\n * And the self parameter lacks token & and keyword mut, then the type is Self.\n\n* Otherwise the type is the specified type.\n\nThe pattern of a function parameter shall be an irrefutable\npattern.\n\nThe expected type of the pattern of a function parameter is the type of the function parameter.\n\nThe [binding]s of all [pattern]s of all [function parameter]s of a function shall not shadow another.\n\nA variadic function is an external function that specifies\n:s:`FunctionParameterVariadicPart` as the last function parameter.\n\nA variadic function shall specify one of the following [ABI]s:\n\n* extern \"C\"\n* extern \"C-unwind\"\n* extern \"aapcs\"\n* extern \"aapcs-unwind\"\n* extern \"cdecl\"\n* extern \"cdecl-unwind\"\n* extern \"efiapi\"\n* extern \"system\"\n* extern \"system-unwind\"\n* extern \"sysv64\"\n* extern \"sysv64-unwind\"\n* extern \"win64\"\n* extern \"win64-unwind\"\n\nA return type is the type of the result a function, closure type or function pointer type returns.\n\nThe return type of a function is determined as follows:\n\n* If the :s:`FunctionDeclaration` specifies a :s:`ReturnType`, then the return type is the specified :s:`ReturnType`.\n\n* Otherwise the return type is the unit type.\n\nA function body is the block expression of a function.\n\nA function shall have a function body unless it is an\nassociated trait function or an external function.\n\nA function body denotes a control flow boundary.\n\nA function body of an async function denotes an\nasync control flow boundary.\n\nA function signature is a unique identification of a function\nthat encompasses of its [function qualifier]s, name,\n[generic parameter]s, [function parameter]s, return type, and\nwhere clause.\n\nA constant function is a function subject to keyword const.\n\nThe function body of a constant function shall be a\nconstant expression.\n\nA constant function shall be callable from a constant context.\n\nAn async function is a function subject to keyword async. An\nasync function of the form\n\nis equivalent to function\n\nAn unsafe function is a function subject to an :s:`ItemSafety` with keyword unsafe.\n\nA function shall only be subject to an :s:`ItemSafety` with keyword safe if it is an external function in an unsafe external block.\n\nThe invocation of an unsafe function shall require unsafe context.",
      "paragraph_ids": [
        "fls_gn1ngtx2tp2s",
        "fls_bdx9gnnjxru3",
        "fls_87jnkimc15gi",
        "fls_nwywh1vjt6rr",
        "fls_uwuthzfgslif",
        "fls_ymeo93t4mz4",
        "fls_ijbt4tgnl95n",
        "fls_AAYJDCNMJgTq",
        "fls_PGtp39f6gJwU",
        "fls_yZ2yIXxmy2ri",
        "fls_35aSvBxBnIzm",
        "fls_Ogziu8S01qPQ",
        "fls_xCSsxYUZUFed",
        "fls_lxzinvqveuqh",
        "fls_kcAbTPZXQ5Y8",
        "fls_PGDKWK7nPvgw",
        "fls_o4uSLPo00KUg",
        "fls_icdzs1mjh0n4",
        "fls_OR85NVifPwjr",
        "fls_4s2IdfYDzPrX",
        "fls_ZJJppPfiJRou",
        "fls_jOyZh9ujWWHQ",
        "fls_Xdr0bFwxhWiB",
        "fls_DpTFEHZAABdD",
        "fls_b7FTlWfnX2OI",
        "fls_6urL6fZ5cpaA",
        "fls_TMOzb6cYIOlH",
        "fls_eHPWHrvs7ETl",
        "fls_mjCrvmikm58M",
        "fls_4EUb9zFatZ97",
        "fls_4B4B5FIqAes9",
        "fls_vljy4mm0zca2",
        "fls_EqJb3Jl3vK8K",
        "fls_C7dvzcXcpQCy",
        "fls_J8X8ahnJLrMo",
        "fls_927nfm5mkbsp",
        "fls_yfm0jh62oaxr",
        "fls_bHwy8FLzEUi3",
        "fls_5Q861wb08DU3",
        "fls_owdlsaaygtho",
        "fls_2049qu3ji5x7",
        "fls_7mlanuh5mvpn",
        "fls_otr3hgp8lj1q",
        "fls_m3jiunibqj81",
        "fls_7vogmqyd87ey",
        "fls_7ucwmzqtittv",
        "fls_nUADhgcfvvGC",
        "fls_5hn8fkf7rcvz"
      ],
      "position": 125,
      "parent_fls_id": null,
      "sibling_fls_ids": [
        "fls_l21tjqjkkaa0",
        "fls_gvwd0kf72jt",
        "fls_3v733mnewssy",
        "fls_gdeyap4or1db",
        "fls_dzq9cdz4ibsz",
        "fls_ckvjj4tt1hh2",
        "fls_osd6c4utyjb3",
        "fls_48qldfwwh493",
        "fls_y2k5paj8m8ug",
        "fls_fk2m2irwpeof",
        "fls_z1il3w9nulzy",
        "fls_wb86edg02t6a",
        "fls_411up5z0b6n6",
        "fls_83182bfa9uqb",
        "fls_ronnwodjjjsh",
        "fls_xgqh0ju6bmbn",
        "fls_hdwwrsyunir",
        "fls_wdicg3sqa98e",
        "fls_vgb6ev541b2r",
        "fls_EBwqH60SUHiN",
        "fls_jep7p27kaqlp",
        "fls_94a8v54bufn8"
      ]
    },
    {
      "fls_id": "fls_48qldfwwh493",
      "title": "General",
      "level": 1,
      "file": "general",
      "content": "General\n\nThis document is influenced by the `Ada Reference Manual\n<http://www.ada-auth.org/standards/2xrm/html/RM-TTL.html>`_\nAda 202x edition, as well as the `Rust Language Reference\n<https://doc.rust-lang.org/stable/reference/>`_, the `Rust\nGuidebook <https://doc.rust-lang.org/book/>`_, and the `Rustonomicon\n<https://doc.rust-lang.org/nomicon/>`_.\n\nParts of these documents have been copied, in whole or in part, in particular\nbut not limited to:\n\n* The outline and structure of the documents;\n\n* The title, outline, organization, and numbering of chapters;\n\n* The structure, formality, wording, and numbering of paragraphs;\n\n* The definitions and uses of terms;\n\n* The categories of syntactic and semantic rules.\n\nConsult :doc:`licenses` for the relevant copyright notices and licenses.",
      "paragraph_ids": [
        "fls_c4ry0kgmvk9z",
        "fls_gxqbj0qoiaio",
        "fls_u8k9zr8da30",
        "fls_8mt9iigoboba",
        "fls_suhf2g3fatfa",
        "fls_jjr5kbn0wuco",
        "fls_4dfcjyprkzbx",
        "fls_tq9jcv5ddvwn"
      ],
      "position": 207,
      "parent_fls_id": null,
      "sibling_fls_ids": [
        "fls_l21tjqjkkaa0",
        "fls_gvwd0kf72jt",
        "fls_3v733mnewssy",
        "fls_gdeyap4or1db",
        "fls_dzq9cdz4ibsz",
        "fls_ckvjj4tt1hh2",
        "fls_osd6c4utyjb3",
        "fls_qcb1n9c0e5hz",
        "fls_y2k5paj8m8ug",
        "fls_fk2m2irwpeof",
        "fls_z1il3w9nulzy",
        "fls_wb86edg02t6a",
        "fls_411up5z0b6n6",
        "fls_83182bfa9uqb",
        "fls_ronnwodjjjsh",
        "fls_xgqh0ju6bmbn",
        "fls_hdwwrsyunir",
        "fls_wdicg3sqa98e",
        "fls_vgb6ev541b2r",
        "fls_EBwqH60SUHiN",
        "fls_jep7p27kaqlp",
        "fls_94a8v54bufn8"
      ]
    },
    {
      "fls_id": "fls_fo1c7pg2mw1",
      "title": "Scope",
      "level": 2,
      "file": "general",
      "content": "Scope\n\nThis document specifies the form and meaning of programs written in the 2021 Edition of the\nRust programming language, as implemented by the Rust compiler (rustc),\nversion |spec_version|.\nIt documents the current understanding for the purposes of\ncompiler validation. As such, given any doubt, it prefers documenting behavior\nof rustc over claiming correctness as a specification.\n\nThis document is made available for contribution and review,\nand can be a place of shared understanding. It\nis not intended as a discussion ground for language evolution. It is also not\nintended as a document enabling conformance between compilers.",
      "paragraph_ids": [
        "fls_srdq4mota5pr",
        "fls_dv1qish8svc"
      ],
      "position": 1224,
      "parent_fls_id": "fls_48qldfwwh493",
      "sibling_fls_ids": [
        "fls_9cd746qe40ag",
        "fls_ijzgf4h0mp3c"
      ]
    },
    {
      "fls_id": "fls_10yukmkhl0ng",
      "title": "Extent",
      "level": 3,
      "file": "general",
      "content": "Extent\n\nThis document specifies:\n\n* The form of a program written in Rust;\n\n* The effect of translating and executing such a program;\n\n* The manner in which [crate]s and [module]s may be combined to form\n Rust programs;\n\n* The language-defined libraries that a conforming tool is required to supply;\n\n* The violations that a conforming tool is required to detect, and the effect of\n attempting to translate or execute a program containing such violations;\n\n* The violations that a conforming tool is not required to detect.\n\nThis document does not specify:\n\n* The means by which a Rust program is transformed into object code executable\n by a processor;\n\n* The means by which translation or execution of Rust programs is invoked and\n the executing units are controlled;\n\n* The size or speed of the object code, or the relative execution speed of\n different language constructs;\n\n* The form or contents of any listings produced by a tool; in particular, the\n form or contents of error or warning messages;\n\n* The effect of undefined behavior;\n\n* The size of a program or program unit that will exceed the capacity of a\n conforming tool.",
      "paragraph_ids": [
        "fls_x78yd1sszydv",
        "fls_9e032738udnb",
        "fls_jk7scu5xs17z",
        "fls_jiryupa5fxgf",
        "fls_sph1a3sapinh",
        "fls_7tm19jxtffc8",
        "fls_5pbrl8lhuth1",
        "fls_o8fc3e53vp7g",
        "fls_rw0y5t13y6gs",
        "fls_x7c3o621qj9z",
        "fls_5y2b6yjcl1vz",
        "fls_8dennhk2dha",
        "fls_j2gs3hrbxtyx",
        "fls_gy2c7vfwkd8j"
      ],
      "position": 1946,
      "parent_fls_id": "fls_fo1c7pg2mw1",
      "sibling_fls_ids": [
        "fls_xscgklvg1wd2",
        "fls_99b7xi1bkgih",
        "fls_79rl6ylmct07"
      ]
    },
    {
      "fls_id": "fls_xscgklvg1wd2",
      "title": "Structure",
      "level": 3,
      "file": "general",
      "content": "Structure\n\nThis document contains 22 chapters, 4 appendices, and an index.\n\nThe specification of the Rust language is separated into:\n\n* Chapters 1 through 22,\n\n* Appendices A through D\n\nThe specification is normative, except for the material in each of the items\nlisted below, which is informative:\n\n* Text under an \"Examples\" heading.\n\n* Each subchapter whose title starts with the word \"Example\" or \"Examples\".\n\nAll appendices are informative.\n\nEach chapter is divided into subchapters that have a common structure. Each\nchapter and subchapter is then organized to include the following segments as is\nrelevant to the topic:\n\nThe syntax representation of a construct.\n\nCompile-time rules and facts for each construct. A construct is legal\nif it obeys all of the Legality Rules.\n\nLegality Rules are verified after macro expansion takes place.\n\nRun-time effects of each construct.\n\nSituations that result in unbounded errors.\n\nAdditional requirements for conforming tools.\n\nExamples illustrating the possible forms of a construct. This material\nis informative.",
      "paragraph_ids": [
        "fls_6lrqailxjb02",
        "fls_tys7ciqnp8bn",
        "fls_3ubhkaheu8i1",
        "fls_xw3grr2g5zgi",
        "fls_6srbinvnyd54",
        "fls_ciixfg9jhv42",
        "fls_ej94lm2682kg",
        "fls_xgk91jrbpyoc",
        "fls_jc4upf6685bw",
        "fls_oxzjqxgejx9t",
        "fls_gmx688d6ek1o",
        "fls_5zdjikp1jhc",
        "fls_as5bhc5t285g",
        "fls_70qjvaqoz007",
        "fls_o4rdsbc7u98",
        "fls_w8j575w2hmc8"
      ],
      "position": 3475,
      "parent_fls_id": "fls_fo1c7pg2mw1",
      "sibling_fls_ids": [
        "fls_10yukmkhl0ng",
        "fls_99b7xi1bkgih",
        "fls_79rl6ylmct07"
      ]
    },
    {
      "fls_id": "fls_99b7xi1bkgih",
      "title": "Conformity",
      "level": 3,
      "file": "general",
      "content": "Conformity\n\nA conforming tool shall:\n\n* Correctly translate legal programs written in Rust,\n\n* Reject programs that exceed the tool's implementation capacity,\n\n* Reject programs that contain errors whose detection is required by this document,\n\nThe external effect of the execution of a Rust program is defined in terms of\nits interactions with its external environment. The following are defined as\nexternal interactions:\n\n* Any call to an external function,\n\n* Any interaction with an external static,\n\n* Any result returned from a program entry point,\n\n* Any result returned from an exported function to an external caller.\n\nA tool that conforms to this document shall produce for the execution of a given\nRust program a set of interactions with the external environment whose order and\ntiming are consistent with the definitions and requirements of this document for\nthe semantics of the given program.\n\nA tool that conforms to this document shall support each capability required by\nthe language as specified.\n\nA tool that conforms to this document may provide additional [attribute]s\nas long as their names are not the same as the names of [built-in\nattribute]s.",
      "paragraph_ids": [
        "fls_kdyqtnc6loam",
        "fls_dBKu9jgx3OyH",
        "fls_faRvWyJJpno8",
        "fls_GZmxrO61eiJ1",
        "fls_nnmx2qsu14ft",
        "fls_gu3331rmv2ho",
        "fls_AR8ZIYlDRSNs",
        "fls_xAYhvEh7WWel",
        "fls_QvFpU8v5p8Hb",
        "fls_pl0fyjcwslqm",
        "fls_lkdm0mdghppv",
        "fls_d07x1mbhgpsd"
      ],
      "position": 5149,
      "parent_fls_id": "fls_fo1c7pg2mw1",
      "sibling_fls_ids": [
        "fls_10yukmkhl0ng",
        "fls_xscgklvg1wd2",
        "fls_79rl6ylmct07"
      ]
    },
    {
      "fls_id": "fls_79rl6ylmct07",
      "title": "Method of Description and Syntax Notation",
      "level": 3,
      "file": "general",
      "content": "Method of Description and Syntax Notation\n\nThe form of a Rust program is described by means of a context-free syntax\ntogether with context-dependent requirements expressed by narrative rules.\n\nThe semantic meaning of a Rust program is described by means of narrative rules defining\nboth the effects of each construct and the composition rules for constructs.\n\nThe context-free syntax of Rust is described using a simple variant of the\nBackus-Naur form. In particular:\n\n* A monospaced font is used to denote Rust syntax.\n\n* Words in PascalCase font are used to denote a syntactic category, for example:\n\n* Words in **bold** font are used to indicate literal words and [keyword]s,\n for example:\n\n* Characters in **bold** font are used to indicate literal characters and\n literal punctuation, for example:\n\n* A character preceded by \\ (bold reverse solidus) is used to denote an\n escaped character, for example:\n\n* A prefix followed by ? (question mark) is used to denote an optional\n prefix, for example:\n\n* A prefix followed by * (asterisk) is used to denote zero or more\n repetitions of the prefix, for example:\n\n* A prefix followed by + (plus sign) is used to denote one or more\n repetitions of the prefix, for example:\n\n* A prefix followed by L-H is used to denote the number of repetitions of\n the prefix within the range from L to H, inclusive. For example:\n\n* [ ] (square brackets) indicate any character within, for example:\n\n* ~[ ] (square brackets preceded by tilde) indicate any character except the\n characters within, for example:\n\n* [ - ] indicates any character within the specified range, inclusive. For\n example:\n\n* A | (vertical line) separates alternative items, for example:\n\n* ( ) (parentheses) are used to group items, for example:",
      "paragraph_ids": [
        "fls_mc4a28do6kcp",
        "fls_ioyp4wux6skt",
        "fls_jsflt7691ye4",
        "fls_98fm7z04lq9",
        "fls_ceb5a8t6cakr",
        "fls_pts29mb5ld68",
        "fls_gqjo5oh7vn3b",
        "fls_1dz634xp8xp5",
        "fls_pp9vtjlyblrl",
        "fls_6e2vd9fvhsmk",
        "fls_4onq0kkrt6qv",
        "fls_qu4rsmnq659w",
        "fls_rllu7aksf17e",
        "fls_blvsfqeevosr",
        "fls_lwcjq3wzjyvb",
        "fls_v7wd5yk00im6",
        "fls_nf8alga8uz6c"
      ],
      "position": 6714,
      "parent_fls_id": "fls_fo1c7pg2mw1",
      "sibling_fls_ids": [
        "fls_10yukmkhl0ng",
        "fls_xscgklvg1wd2",
        "fls_99b7xi1bkgih"
      ]
    },
    {
      "fls_id": "fls_9cd746qe40ag",
      "title": "Versioning",
      "level": 2,
      "file": "general",
      "content": "Versioning\n\nFerrocene is a qualified compiler and this is the accompanying language\nspecification for the qualified version of the compiler. This document will\nbe updated with each qualification to accurately reflect the behavior of the\ncompiler qualified under that version of Ferrocene.",
      "paragraph_ids": [
        "fls_l80e3kdwnldc"
      ],
      "position": 9565,
      "parent_fls_id": "fls_48qldfwwh493",
      "sibling_fls_ids": [
        "fls_fo1c7pg2mw1",
        "fls_ijzgf4h0mp3c"
      ]
    },
    {
      "fls_id": "fls_ijzgf4h0mp3c",
      "title": "Definitions",
      "level": 2,
      "file": "general",
      "content": "Definitions\n\nTerms are defined throughout this document, indicated by *italic* type. Terms\nexplicitly defined in this document are not to be presumed to refer implicitly\nto similar terms defined elsewhere.\n\nMathematical terms not defined in this document are to be interpreted according\nto the CRC Concise Encyclopedia of Mathematics, Second Edition.\n\nOther terms not defined in this document are to be interpreted according to the\nWebster's Third New International Dictionary of the English Language.\n\nThe definitions of terms are available in :doc:`glossary`.\n\nA *rule* is a requirement imposed on the programmer, stated in normative\nlanguage such as \"shall\", \"shall not\", \"must\", \"must not\", except for text\nunder Implementation Requirements heading.\n\nA *fact* is a requirement imposed on a conforming tool, stated in informative\nlanguage such as \"is\", \"is not\", \"can\", \"cannot\".",
      "paragraph_ids": [
        "fls_sm2kexes5pr7",
        "fls_2o98zw29xc46",
        "fls_lon5qffd65fi",
        "fls_qeolgxvcy75",
        "fls_h2m244agxaxs",
        "fls_47svine904xk"
      ],
      "position": 9912,
      "parent_fls_id": "fls_48qldfwwh493",
      "sibling_fls_ids": [
        "fls_fo1c7pg2mw1",
        "fls_9cd746qe40ag"
      ]
    },
    {
      "fls_id": "fls_y2k5paj8m8ug",
      "title": "Generics",
      "level": 1,
      "file": "generics",
      "content": "Generics",
      "paragraph_ids": [],
      "position": 125,
      "parent_fls_id": null,
      "sibling_fls_ids": [
        "fls_l21tjqjkkaa0",
        "fls_gvwd0kf72jt",
        "fls_3v733mnewssy",
        "fls_gdeyap4or1db",
        "fls_dzq9cdz4ibsz",
        "fls_ckvjj4tt1hh2",
        "fls_osd6c4utyjb3",
        "fls_qcb1n9c0e5hz",
        "fls_48qldfwwh493",
        "fls_fk2m2irwpeof",
        "fls_z1il3w9nulzy",
        "fls_wb86edg02t6a",
        "fls_411up5z0b6n6",
        "fls_83182bfa9uqb",
        "fls_ronnwodjjjsh",
        "fls_xgqh0ju6bmbn",
        "fls_hdwwrsyunir",
        "fls_wdicg3sqa98e",
        "fls_vgb6ev541b2r",
        "fls_EBwqH60SUHiN",
        "fls_jep7p27kaqlp",
        "fls_94a8v54bufn8"
      ]
    },
    {
      "fls_id": "fls_vhpwge5123cm",
      "title": "Generic Parameters",
      "level": 2,
      "file": "generics",
      "content": "Generic Parameters\n\n GenericParameter ::=\n OuterAttributeOrDoc* (\n ConstantParameter\n | LifetimeParameter\n | TypeParameter\n )\n\n ConstantParameter ::=\n $$const$$ Name TypeAscription ($$=$$ ConstantParameterInitializer)?\n\n ConstantParameterInitializer ::=\n BlockExpression\n | Identifier\n | $$-$$? LiteralExpression\n\n LifetimeParameter ::=\n Lifetime ($$:$$ LifetimeIndicationList)?\n\n TypeParameter ::=\n Name ($$:$$ TypeBoundList?)? ($$=$$ TypeParameterInitializer)?\n\n TypeParameterInitializer ::=\n TypeSpecification\n\nA generic parameter is a placeholder for a constant, a lifetime,\nor a type, whose constant, lifetime, or type is supplied\nstatically by a generic argument.\n\nAll :s:`[LifetimeParameter]s` in a :s:`GenericParameterList` shall precede all\n:s:`[ConstantParameter]s` and :s:`[TypeParameter]s`.\n\nA generic enum is an enum with [generic parameter]s.\n\nA generic function is a function with [generic parameter]s.\n\nA generic implementation is an implementation with\n[generic parameter]s.\n\nA generic struct is a struct with [generic parameter]s.\n\nA generic trait is a trait with [generic parameter]s.\n\nA generic type alias is a type alias with [generic parameter]s.\n\nA generic union is a union with [generic parameter]s.\n\nA constant parameter is a generic parameter for a constant.\n\nA constant parameter initializer is a construct that provides the\ndefault value of its related constant parameter.\n\nA constant parameter initializer shall be a constant expression.\n\nIt is a static error to use a generic parameter in the\ndiscriminant initializer of an enum variant.\n\nA lifetime parameter is a generic parameter for a lifetime.\n\nA lifetime parameter shall not be used within a constant context,\nexcept for the 'static lifetime.\n\nA type parameter is a generic parameter for a type.\n\nA type parameter initializer is a construct that provides the\ndefault value of its related type parameter.\n\nThe type of the type parameter initializer of a type parameter\nshall satisfy the [trait bound]s of the type parameter.\n\nA generic enum shall use all of its [type parameter]s and\n[lifetime parameter]s at least once in at least one of its\n[enum variant]s.\n\nA generic struct shall use all of its [type parameter]s and\n[lifetime parameter]s at least once in at least one of its [field]s.\n\nA generic union shall use all of its [type parameter]s and\n[lifetime parameter]s at least once in at least one of its [field]s.\n\nA generic parameter is said to constrain an implementation if the\ngeneric parameter appears at least once in one of the following:\n\n* As a binding argument in the [trait bound]s of a type that\n contains another generic parameter that constrains the\n implementation, or\n\n* The implemented trait, or\n\n* The implementing type.\n\nIt is a static error if a constant parameter or a type parameter of\nan implementation does not constrain the implementation.\n\nIt is a static error if a lifetime parameter of an implementation\nis used in an associated type without constraining the\nimplementation.\n\nThe type of a constant parameter shall be a scalar type.\n\nA constant parameter shall be used in the following contexts:\n\n* As a constant argument in the signature and [field]s of an\n item.\n\n* In the constant initializer of an associated constant.\n\n* As a constant argument of an [associated type]'s\n :s:`InitializationType`.\n\n* As a constant argument of any type used within a function body.\n\n* As a value of any expression within a function body.\n\nAn inferred constant is a constant argument whose value is\ninferred from the surrounding context by using _ (underscore) in its place.\n\nAn inferred constant cannot be used in item signatures.\n\nAn inferred constant cannot be surrounded by {} (curly braces).\n\nAn inferred constant can be surrounded by an arbitrary number of ()\n(parentheses).\n\nA type parameter has an implicit core::marker::Sized bound,\nunless an opt-out trait bound for the core::marker::Sized trait\nis present.\n\nA type parameter of an abstract data type has implicit\n[lifetime bound]s depending on its usage in the [field]s of the\nabstract data type as follows:\n\n* If the type parameter is used in a reference type, then the\n type parameter has an implicit lifetime bound for the\n lifetime of the reference type,\n\n* If the type parameter is used as a generic argument of an\n abstract data type, the type parameter inherits all the\n [lifetime bound]s from the corresponding generic parameter of\n the generic argument.\n\nA type parameter of a function has implicit [lifetime bound]s\ndepending on its usages in the [function parameter]s and return type\nas follows:\n\n* If the type parameter is used in a reference type, then the\n type parameter has an implicit lifetime bound for the lifetime\n of the reference type,\n\n* If the type parameter is used as a generic argument of an\n abstract data type, the type parameter inherits all the\n [lifetime bound]s from the corresponding generic parameter of\n the generic argument.\n\nA generic parameter with a bound of the form\n\nis equivalent to the generic parameter without the bound and a\nwhere clause of the following form:",
      "paragraph_ids": [
        "fls_sye3d17l9bf5",
        "fls_dalqke3rznrb",
        "fls_pi6eukz7kc99",
        "fls_ixmgqupxvf73",
        "fls_z311nxou9yi3",
        "fls_wmcp0n36jlbr",
        "fls_h42kg56vsefx",
        "fls_372h3oevejih",
        "fls_u8mqct93yimd",
        "fls_vpcqgec83ybt",
        "fls_3SjMBlc0b7qo",
        "fls_p4yb8EAXlRU0",
        "fls_4a2qshaf5se7",
        "fls_s0nrjwqg2wox",
        "fls_2grtygcj8o3",
        "fls_95eooah0vcqx",
        "fls_ahCqtkh0m5sR",
        "fls_3qZRBp9j26w3",
        "fls_x4s7p2v981r6",
        "fls_jzfk9fspzqja",
        "fls_6j616ydf2mnh",
        "fls_hyi2jnp38v1n",
        "fls_sseo6u6pbcki",
        "fls_62b59qvom3nm",
        "fls_oq76uff9gp0k",
        "fls_ua3w16qo9o4",
        "fls_w9ol06mldwb",
        "fls_g2pfrqhmeys8",
        "fls_56jq9k9l31rt",
        "fls_sh669lnc5o1b",
        "fls_h6kx8dxh5u96",
        "fls_5r7ontjlmgwj",
        "fls_prbwj1pmng6k",
        "fls_byqjs5fvy2bj",
        "fls_reASCId0i117",
        "fls_Ft5rGeL7QwJM",
        "fls_7epZNsTYNmgE",
        "fls_TvuMMQnR0drL",
        "fls_hidfwkwr2r73",
        "fls_yaYedRNaxhTe",
        "fls_axMVssU7an8p",
        "fls_iAnCoxISuxxb",
        "fls_wUwJEGzjCUAT",
        "fls_BN5nUuvq9AwY",
        "fls_ouOm2TQKNsP3",
        "fls_m0bzw4jap6sg",
        "fls_vo7mgm34hwg2"
      ],
      "position": 167,
      "parent_fls_id": "fls_y2k5paj8m8ug",
      "sibling_fls_ids": [
        "fls_7nv8ualeaqe3",
        "fls_utuu8mdbuyxm",
        "fls_i7g2n7hfg3ch"
      ]
    },
    {
      "fls_id": "fls_7nv8ualeaqe3",
      "title": "Where Clauses",
      "level": 2,
      "file": "generics",
      "content": "Where Clauses\n\n WhereClausePredicateList ::=\n WhereClausePredicate ($$,$$ WhereClausePredicate)* $$,$$?\n\n WhereClausePredicate ::=\n LifetimeBoundPredicate\n | TypeBoundPredicate\n\n LifetimeBoundPredicate ::=\n LifetimeIndication $$:$$ LifetimeIndicationList?\n\n TypeBoundPredicate ::=\n ForGenericParameterList? TypeSpecification $$:$$ TypeBoundList?\n\nA where clause is a construct that specifies [bound]s on\n[lifetime parameter]s and [type]s that have\nto hold for the construct subject to the where clause to be valid.\n\nA where clause predicate is either a lifetime bound predicate or a\ntype bound predicate.\n\nA lifetime bound predicate is a construct that specifies\n[lifetime bound]s on a lifetime parameter.\n\nA type bound predicate is a construct that specifies\n[lifetime bound]s and [trait bound]s on a type.\n\nA construct is valid when all of its [where clause predicate]s hold\ntrue for the supplied [generic argument]s.\n\nA trivial predicate is a where clause predicate that does not use\nthe [generic parameter]s or [higher-ranked trait bound]s of the related\nconstruct.\n\nIt is a static error to create a trivial predicate that does not hold.",
      "paragraph_ids": [
        "fls_3nqb7p5ifvio",
        "fls_fhy4rsmmbvyy",
        "fls_V4PKFqtCsAv6",
        "fls_cslGPmVjujHD",
        "fls_ytk74dyxuy6d",
        "fls_1xgw1dq60quz",
        "fls_47s8i7pzb9gg"
      ],
      "position": 7734,
      "parent_fls_id": "fls_y2k5paj8m8ug",
      "sibling_fls_ids": [
        "fls_vhpwge5123cm",
        "fls_utuu8mdbuyxm",
        "fls_i7g2n7hfg3ch"
      ]
    },
    {
      "fls_id": "fls_utuu8mdbuyxm",
      "title": "Generic Arguments",
      "level": 2,
      "file": "generics",
      "content": "Generic Arguments\n\n GenericArgument ::=\n BindingArgument\n | BindingBoundArgument\n | ConstantArgument\n | LifetimeArgument\n | TypeArgument\n\n BindingArgument ::=\n Identifier $$=$$ TypeSpecification\n\n BindingBoundArgument ::=\n Identifier $$:$$ TypeBoundList\n\n ConstantArgument ::=\n BlockExpression\n | $$-$$? LiteralExpression\n | Identifier\n\n LifetimeArgument ::=\n LifetimeIndication\n\n TypeArgument ::=\n TypeSpecification\n\nA generic argument supplies a static input for an\nassociated trait type or a generic parameter.\n\nA :s:`BindingArgument` shall follow :s:`[ConstantArgument]s`,\n:s:`[LifetimeArgument]s`, and :s:`[TypeArgument]s` in a\n:s:`GenericArgumentList`.\n\nA :s:`LifetimeArgument` shall precede :s:`[BindingArgument]s`,\n:s:`[ConstantArgument]s`, and :s:`[TypeArgument]s` in a\n:s:`GenericArgumentList`.\n\nA binding argument is a generic argument that supplies the type\nof an associated trait type.\n\nA binding bound argument is a generic argument that further imposes\n[bound]s on an associated trait type.\n\nA binding bound argument shall only be used within the confines of a\ntype bound predicate's [bound]s, [impl trait type]'s\n[bound]s, associated type's [bound]s or trait's\n[supertrait]s.\n\nA constant argument is a generic argument that supplies the\nvalue of a constant parameter.\n\nA constant argument may only appear as a single segment\npath expression, optionally encapsulated in a block expression, within\nan array repetition constructor or a type.\n\nA lifetime argument is a generic argument that supplies the\nlifetime of a lifetime parameter.\n\nA type argument is a generic argument that supplies the type of\na type parameter.\n\n[Generic argument]s are subject to generic conformance.\n\nThe following is a generic function with a binding argument.\n\nThe following are generic arguments for func.",
      "paragraph_ids": [
        "fls_3x6qd8vt5uus",
        "fls_ky39fb2vcom6",
        "fls_9n1ejjili06h",
        "fls_9pda3ja0ihks",
        "fls_mcUMWsYcxzmZ",
        "fls_dxMfAI4EZVS5",
        "fls_i3z9ueoe99zd",
        "fls_al4dhmqodvwc",
        "fls_10k9gdxlpuls",
        "fls_d4vdvpihoeb1",
        "fls_ukarc98ceesz",
        "fls_l88o2snx9qbt",
        "fls_thpj9io9tyuy"
      ],
      "position": 9478,
      "parent_fls_id": "fls_y2k5paj8m8ug",
      "sibling_fls_ids": [
        "fls_vhpwge5123cm",
        "fls_7nv8ualeaqe3",
        "fls_i7g2n7hfg3ch"
      ]
    },
    {
      "fls_id": "fls_i7g2n7hfg3ch",
      "title": "Generic Conformance",
      "level": 2,
      "file": "generics",
      "content": "Generic Conformance\n\nGeneric conformance measures the compatibility between a set of\n[generic parameter]s and a set of [generic argument]s.\n\nA binding argument is conformant with an associated type when the\nsupplied type of the binding argument fulfills the required\n[trait bound]s of the associated type.\n\nA constant argument is conformant with a constant parameter when\nthe [type]s of the constant argument and the constant parameter\nare unifiable.\n\nA lifetime argument is conformant with a lifetime parameter when it\noutlives the lifetime specified by the lifetime parameter.\n\nA type argument is conformant with a type parameter when the\ntype of the type argument fulfills the required [trait bound]s\nof the type parameter.\n\n[Generic argument]s are conformant with [generic parameter]s when\n\n* The [generic argument]s consist only of conformant\n [binding argument]s, conformant [constant argument]s, conformant\n [lifetime argument]s, and conformant [type argument]s, and\n\n* Any remaining [generic parameter]s without corresponding conformant\n [generic argument]s are [constant parameter]s with\n [constant parameter initializer]s, [lifetime parameter]s with\n either inferred [lifetime argument]s or [elided lifetime]s,\n [type parameter]s with [type parameter initializer]s or inferred\n [type argument]s, and\n\n* All [lifetime argument]s come first, followed by\n [constant argument]s and [type argument]s in the order defined by\n the [generic parameter]s, followed by [binding argument]s, and\n\n* All [constant argument]s, [lifetime argument]s, and\n [type argument]s have a corresponding generic parameter.\n\n[Generic argument]s shall be conformant.\n\nThe value of a constant parameter is determined as follows:\n\n* If the constant parameter has a conformant constant argument, then\n the value is that of the constant argument.\n\n* Otherwise, if the constant parameter has a\n constant parameter initializer, then the value is that of the\n constant parameter initializer.\n\n* Otherwise this is a static error.",
      "paragraph_ids": [
        "fls_CBWyxBJeYeb2",
        "fls_ltch5eivxgaa",
        "fls_gb3mpt5rxjoa",
        "fls_kdeltu9dsd0d",
        "fls_ws1h57fk1mkh",
        "fls_w0ozotuwtr9",
        "fls_91bylteu35bi",
        "fls_j6xtrxc6aik",
        "fls_us7d30cbwgpz",
        "fls_dp3hpvf0fmr8",
        "fls_mg45zcguxxg5",
        "fls_mDgq5XjzKAl3",
        "fls_YufUgB25ovh3",
        "fls_OhVxhJ23x7W2",
        "fls_Kyar0jH9BqeW"
      ],
      "position": 12279,
      "parent_fls_id": "fls_y2k5paj8m8ug",
      "sibling_fls_ids": [
        "fls_vhpwge5123cm",
        "fls_7nv8ualeaqe3",
        "fls_utuu8mdbuyxm"
      ]
    },
    {
      "fls_id": "fls_fk2m2irwpeof",
      "title": "Implementations",
      "level": 1,
      "file": "implementations",
      "content": "Implementations\n\n InherentImplementation ::=\n $$impl$$ GenericParameterList? ImplementingType WhereClause? ImplementationBody\n\n TraitImplementation ::=\n $$unsafe$$? $$impl$$ GenericParameterList? $$!$$? ImplementedTrait $$for$$ ImplementingType WhereClause? ImplementationBody\n\n ImplementingType ::=\n TypeSpecification\n\n ImplementedTrait ::=\n TypePath\n\n ImplementationBody ::=\n $${$$\n InnerAttributeOrDoc*\n AssociatedItem*\n $$}$$\n\nAn implementation is an item that supplements an\nimplementing type by extending its functionality.\n\nAn implementing type is the type that the [associated item]s of\nan implementation are associated with.\n\nWithin an implementation, the type Self acts as a type alias\nfor the implementing type.\n\nAn implementation body is a construct that encapsulates the\n[associated item]s, [inner attribute]s, and\n[inner doc comment]s of an implementation.\n\nAn inherent implementation is an implementation that adds direct\nfunctionality.\n\n[Inherent implementation]s of the same implementing type shall be\ndefined within the same crate.\n\nA trait implementation is an implementation that adds functionality\nspecified by a trait.\n\nAn unsafe trait implementation is a trait implementation subject to\nkeyword unsafe.\n\nAn implemented trait is a trait whose functionality has been\nimplemented by an implementing type.\n\nThe type path of a trait implementation shall resolve to a trait.\n\nA trait implementation shall be an unsafe trait implementation if and\nonly if it implements an unsafe trait.\n\n[Trait implementation]s are subject to implementation coherence and\nimplementation conformance.\n\n[Inherent implementation]s of the same implementing type shall not\ndefine more than one associated item with the same name in the same\nnamespace.\n\nCircle is an implementing type.\n\nThe following is an inherent implementation:\n\nThe following is a trait implementation:",
      "paragraph_ids": [
        "fls_ivxpoxggy7s6",
        "fls_yopmjbnw8tbl",
        "fls_eIHc8Y9fBtr0",
        "fls_Mcpdzzcw43M7",
        "fls_v0n0bna40dqr",
        "fls_797etpdk5dyb",
        "fls_ry3an0mwb63g",
        "fls_8pwr7ibvhmhu",
        "fls_47x0ep8of8wr",
        "fls_agitlryvyc16",
        "fls_mx5xjcejwa6u",
        "fls_z78dg261oob6",
        "fls_89yNjGNB7KI3",
        "fls_yuyesijndu9n",
        "fls_o62i75sjzp9y",
        "fls_a2utf0tmuhy4"
      ],
      "position": 125,
      "parent_fls_id": null,
      "sibling_fls_ids": [
        "fls_l21tjqjkkaa0",
        "fls_gvwd0kf72jt",
        "fls_3v733mnewssy",
        "fls_gdeyap4or1db",
        "fls_dzq9cdz4ibsz",
        "fls_ckvjj4tt1hh2",
        "fls_osd6c4utyjb3",
        "fls_qcb1n9c0e5hz",
        "fls_48qldfwwh493",
        "fls_y2k5paj8m8ug",
        "fls_z1il3w9nulzy",
        "fls_wb86edg02t6a",
        "fls_411up5z0b6n6",
        "fls_83182bfa9uqb",
        "fls_ronnwodjjjsh",
        "fls_xgqh0ju6bmbn",
        "fls_hdwwrsyunir",
        "fls_wdicg3sqa98e",
        "fls_vgb6ev541b2r",
        "fls_EBwqH60SUHiN",
        "fls_jep7p27kaqlp",
        "fls_94a8v54bufn8"
      ]
    },
    {
      "fls_id": "fls_46ork6fz5o2e",
      "title": "Implementation Coherence",
      "level": 2,
      "file": "implementations",
      "content": "Implementation Coherence\n\nA trait implementation exhibits implementation coherence when it is\nvalid and does not overlap with another trait implementation.\n\nTwo [trait implementation]s of the same implemented trait overlap when\nthe intersection of the [implementing type]s is non-empty.\n\nGiven trait implementation\nimpl<P1, P2, .., PN> Trait<T1, T2, .., TN> for T0, the\ntrait implementation is considered valid when\n\n* Trait is fundamental or a local trait, or\n\n* All of\n\n * At least one of [type]s T0, T1, .., TN is :T:`fundamental` or a\n local type, and\n\n * No type parameter of P1, P2, .., PN that is not used in another\n type may appear in the non-[local type]s and\n non-[fundamental] [type]s of T0, T1, .., TN.\n\nA trait or type is fundamental when its\nimplementation coherence rules are relaxed and the trait or type\nis always treated as if it was a local trait or a local type.\n\nThe following [type]s are fundamental:\n\n* [reference type]s\n\n* core::pin::Pin\n\n..\n also `alloc::boxed::Box`\n\nThe following [trait]s are fundamental:\n\n* core::ops::Fn\n\n* core::ops::FnMut\n\n* core::ops::FnOnce\n\n* core::marker::Sized\n\nA trait implementation shall be coherent.",
      "paragraph_ids": [
        "fls_fv1l4yjuut7p",
        "fls_swdusjwzgksx",
        "fls_ir7hp941ky8t",
        "fls_3tbm20k2ixol",
        "fls_lscc9ileg3gm",
        "fls_9klwbsh3vlxu",
        "fls_9gmc1tcscq9v",
        "fls_UkQhjEWSJpDq",
        "fls_fSybUG40hA5r",
        "fls_z8APl0CEF7a0",
        "fls_RJJafhpVsi6M",
        "fls_dtUJxhNkl8Ty",
        "fls_zJKovQrXQWdU",
        "fls_V6R8yQtsqNyv",
        "fls_CpC6XQN1iWqU",
        "fls_dj7YGw4e4i4H",
        "fls_koy70k770ayu"
      ],
      "position": 3292,
      "parent_fls_id": "fls_fk2m2irwpeof",
      "sibling_fls_ids": [
        "fls_e1pgdlv81vul"
      ]
    },
    {
      "fls_id": "fls_e1pgdlv81vul",
      "title": "Implementation Conformance",
      "level": 2,
      "file": "implementations",
      "content": "Implementation Conformance\n\nA trait implementation exhibits implementation conformance when it\nsatisfies the constraints of its implemented trait.\n\nAn associated trait constant is conformant with an associated constant\nof an implemented trait when\n\n* The [name]s of both [associated constant]s are the same, and\n\n* The type of the associated constant in the implementation is a\n subtype of the type of the associated trait constant.\n\nAn associated trait function is conformant with an associated function\nof an implemented trait when\n\n* The function signature of the associated function of the\n implemented trait is a subtype of the function signature of\n the associated trait function, and\n\n* The [bound]s of the associated function of the\n implemented trait are more general that the [bound]s of the\n associated trait function.\n\nAn associated type of a trait implementation is conformant with an\nassociated type of an implemented trait when\n\n* The [name]s of both [type]s are the same, and\n\n* The type specification of the associated type of the\n implemented trait conforms to the [bound]s of the\n associated type of the trait implementation.\n\nA trait implementation is conformant with an implemented trait when:\n\n* The trait implementation has a conformant associated constant\n for each associated constant of the implemented trait, unless the\n associated constant of the implemented trait has a default value,\n and\n\n* The trait implementation has a conformant associated function\n for each associated function of the implemented trait, unless\n the associated function of the implemented trait has a default\n implementation in the implemented trait, and\n\n* The trait implementation has a conformant associated type for each\n associated type of the implemented trait.\n\nA trait implementation shall be conformant.",
      "paragraph_ids": [
        "fls_YyUSuAYG4lX6",
        "fls_v31idwjau90d",
        "fls_k3wfh5japmyw",
        "fls_11qrqfuc3rmh",
        "fls_qmhduwunxww0",
        "fls_2500ivh0cc3y",
        "fls_18gimgfy0kw9",
        "fls_fi4qmauirlsm",
        "fls_2s8lh3k4rw6u",
        "fls_bb874uu2alt3",
        "fls_so8em6rphkhv",
        "fls_ldu9bmb9cy10",
        "fls_5cr6un2gzdft",
        "fls_pshfe3ioh0mg",
        "fls_8yq1g7nzv9px"
      ],
      "position": 5164,
      "parent_fls_id": "fls_fk2m2irwpeof",
      "sibling_fls_ids": [
        "fls_46ork6fz5o2e"
      ]
    },
    {
      "fls_id": "fls_z1il3w9nulzy",
      "title": "Inline Assembly",
      "level": 1,
      "file": "inline-assembly",
      "content": "Inline Assembly\n\nInline assembly is hand-written assembly code that is integrated into a\nRust program.\n\nInline assembly is written as an assembly code block that is\nwrapped inside a macro invocation of\nmacro core::arch::asm,\nmacro core::arch::global_asm, or\nmacro core::arch::naked_asm.\n\nInline assembly is available on the following architectures:\n\n* AArch64\n\n* ARM\n\n* RISC-V\n\n* x86 and x86-64",
      "paragraph_ids": [
        "fls_leamdp1r3hez",
        "fls_3fg60jblx0xb",
        "fls_helnk2iz8qhp",
        "fls_vanmt2dv7hzd",
        "fls_g8fuy1qnebxe",
        "fls_2n9el98anp8c",
        "fls_pnoh31rvu9a6"
      ],
      "position": 125,
      "parent_fls_id": null,
      "sibling_fls_ids": [
        "fls_l21tjqjkkaa0",
        "fls_gvwd0kf72jt",
        "fls_3v733mnewssy",
        "fls_gdeyap4or1db",
        "fls_dzq9cdz4ibsz",
        "fls_ckvjj4tt1hh2",
        "fls_osd6c4utyjb3",
        "fls_qcb1n9c0e5hz",
        "fls_48qldfwwh493",
        "fls_y2k5paj8m8ug",
        "fls_fk2m2irwpeof",
        "fls_wb86edg02t6a",
        "fls_411up5z0b6n6",
        "fls_83182bfa9uqb",
        "fls_ronnwodjjjsh",
        "fls_xgqh0ju6bmbn",
        "fls_hdwwrsyunir",
        "fls_wdicg3sqa98e",
        "fls_vgb6ev541b2r",
        "fls_EBwqH60SUHiN",
        "fls_jep7p27kaqlp",
        "fls_94a8v54bufn8"
      ]
    },
    {
      "fls_id": "fls_j9l8wn6wgm06",
      "title": "Registers",
      "level": 2,
      "file": "inline-assembly",
      "content": "Registers\n\n ExplicitRegisterName ::=\n $$a$$[$$0$$-$$31$$]\n | $$ah$$ | $$al$$ | $$ax$$\n | $$b$$[$$0$$-$$31$$]\n | $$bh$$ | $$bl$$ | $$bp$$ | $$bpl$$ | $$bx$$\n | $$ch$$ | $$cl$$ | $$cx$$\n | $$d$$[$$0$$-$$31$$]\n | $$dh$$ | $$di$$ | $$dil$$ | $$dl$$ | $$dx$$\n | $$eax$$ | $$ebp$$ | $$ebx$$ | $$ecx$$ | $$edi$$ | $$edx$$ | $$eip$$ | $$esi$$\n | $$esp$$\n | $$f$$[$$0$$-$$31$$]\n | $$fa$$[$$0$$-$$7$$]\n | $$ffr$$ | $$fp$$\n | $$fs$$[$$0$$-$$11$$]\n | $$ft$$[$$0$$-$$11$$]\n | $$gp$$\n | $$h$$[$$0$$-$$31$$]\n | $$ip$$\n | $$k$$[$$0$$-$$7$$]\n | $$lr$$\n | $$m$$[$$0$$-$$7$$]\n | $$p$$[$$0$$-$$15$$]\n | $$pc$$\n | $$q$$[$$0$$-$$31$$]\n | $$r$$[$$0$$-$$15$$]\n | $$r$$[$$8$$-$$15$$]$$d$$\n | $$r$$[$$8$$-$$15$$]$$w$$\n | $$ra$$ | $$rax$$\n | $$rb$$[$$8$$-$$15$$]\n | $$rbp$$ | $$rbx$$ | $$rcx$$\n | $$rdi$$ | $$rdx$$ | $$rfp$$ | $$rip$$ | $$rsi$$ | $$rsp$$\n | $$s$$[$$0$$-$$31$$]\n | $$si$$ | $$sil$$ | $$sl$$ | $$sp$$ | $$spl$$\n | $$st($$[$$0$$-$$7$$]$$)$$\n | $$t$$[$$0$$-$$6$$]\n | $$tmm$$[$$0$$-$$7$$]\n | $$tp$$\n | $$v$$[$$0$$-$$31$$]\n | $$w$$[$$0$$-$$31$$]\n | $$wsp$$ | $$wzr$$\n | $$x$$[$$0$$-$$31$$]\n | $$xmm$$[$$0$$-$$31$$]\n | $$xzr$$\n | $$ymm$$[$$0$$-$$31$$]\n | $$zero$$\n | $$zmm$$[$$0$$-$$31$$]\n\nA register is a hardware component capable of holding data that can be\nread and written.\n\nAn input register is a register whose register name is used in\na register argument subject to direction modifier in, inout,\nor inlateout.\n\nAn output register is a register whose register name is\nused in a register argument subject to direction modifier out,\nlateout, inout, or inlateout.\n\nA register that is not specified as an output register shall have the\nsame value upon exit from an assembly code block as it did upon entry\ninto the assembly code block.\n\nA register name is either the explicit register name of a\nregister, or the register class name of the register class a\nregister belongs to.\n\nAn explicit register name is a target-specific string that identifies\na register.\n\nAn explicit register name may be aliased as follows:\n\nCertain [explicit register name]s are not supported on selected\narchitectures, as follows:\n\nIt is a static error to use an unsupported explicit register name.\n\nIt is undefined behavior if a register that is not specified as an\noutput register has a different value upon exit from an\nassembly code block from the value it had upon entry into the\nassembly code block.",
      "paragraph_ids": [
        "fls_w5a6rybvptn6",
        "fls_rr8rsy7oilf0",
        "fls_5ruu8n6r9mvp",
        "fls_HV3Y1A2xn0zr",
        "fls_vesfzh8h6qzu",
        "fls_ffwqxlh60i5w",
        "fls_3p8akc7gcsnx",
        "fls_7dlx7nt77xk",
        "fls_w4z7yh5qyyed",
        "fls_rzp8eg6z6x3q",
        "fls_e1w41918j49",
        "fls_q0s90h7xmnn4",
        "fls_3pt63w76isay",
        "fls_f3clxd3vidhh",
        "fls_vyeczg1cjxys",
        "fls_h5t153uhzoq3",
        "fls_jhph577nqds1",
        "fls_mobj1y67vxvb",
        "fls_9ke412je1hqn",
        "fls_hndlas58937e",
        "fls_5x0yvjil3z8p",
        "fls_gxvlvnqs436h",
        "fls_mra7zuu7uzmb",
        "fls_maa7w0jwvat2",
        "fls_az7kcaq70h4d",
        "fls_xudmsflrhvo3",
        "fls_px77cr1k8coy",
        "fls_y1m7tlqk2dv7",
        "fls_3dqq9319okv5",
        "fls_5l9qo5c0gek8",
        "fls_1m68zqsxjuyp",
        "fls_bck9slu4hsn1",
        "fls_3x72q39c8iwt",
        "fls_yfbrla8c801g",
        "fls_3nuf1gcldamv",
        "fls_nquf1uaoezx6",
        "fls_91oeyxc75vu5",
        "fls_r5btazdpwqtw",
        "fls_vpibsan8aful",
        "fls_lj6xcaaecokk",
        "fls_bb1qjfin4zjc",
        "fls_7qj6pxuq2x9e",
        "fls_2xkw4nqt1s5a",
        "fls_dpzi4ygox7jw",
        "fls_yr5ztipvgezk",
        "fls_n8ccafjut1yd",
        "fls_iv23mcgw6l3r",
        "fls_yr7bac5k3uk7",
        "fls_gvb2zcrseqci",
        "fls_z1b9nf49nbjh",
        "fls_etfkcesnrlwt",
        "fls_8sqzva4ibf0i",
        "fls_8bo9p6mybuzi",
        "fls_dk4z9dracvps",
        "fls_7c7lgvw8gbkb",
        "fls_sb0ffx31gul9",
        "fls_f9psgjl6ervm",
        "fls_3y3b7znxznzu",
        "fls_7y201ev5b0mq",
        "fls_r2aoetnwhjkf",
        "fls_54n4ie3frc39",
        "fls_iok8gc906tc8",
        "fls_2mgjkyngbmbr",
        "fls_6tlnpguf23y3",
        "fls_bz5xyv89i5m7",
        "fls_soitzjqze3rf",
        "fls_b2c02r5y6zm9",
        "fls_2ufm8y5ttcxf",
        "fls_ub321ic94bbl",
        "fls_gtwmwsmyrdxe",
        "fls_vy8alu9yuza9",
        "fls_zEtLZ5KjQcHS"
      ],
      "position": 846,
      "parent_fls_id": "fls_z1il3w9nulzy",
      "sibling_fls_ids": [
        "fls_pz2ioqchjtym",
        "fls_hejgghwzblf",
        "fls_e0896uk0mdyl",
        "fls_a3joqzqp1v9d",
        "fls_ylli0ortyegk",
        "fls_qezwyridmjob",
        "fls_MW7mtH5oOeQ1"
      ]
    },
    {
      "fls_id": "fls_pz2ioqchjtym",
      "title": "Register Classes",
      "level": 2,
      "file": "inline-assembly",
      "content": "Register Classes\n\nA register class represents a set of [register]s.\n\nA register class name is a target-specific string that identifies a\nregister class.\n\n[Register]s are organized into [register class]es as follows:\n\nIf a value has a smaller size than the register it is allocated in,\nthen\n\n* On RISC-V architectures, if the register belongs to register class\n freg, then f32 [value]s are NaN-boxed <NaN-boxing>. in a\n f64 value.\n\n* Otherwise, for an input register, the upper bits of the register\n have an undefined value.\n\n* Otherwise, for an output register, the upper bits are ignored.\n\nIf a register argument has direction modifier inout and an\ninput-output register expression, then the input register expression\nand the output register expression shall have the same type.",
      "paragraph_ids": [
        "fls_7gxb7ztpuofj",
        "fls_on0i2cpk254y",
        "fls_40ksem5g5xx9",
        "fls_fqvjk6caipq",
        "fls_u0ie66ep3glg",
        "fls_wcvcansd88je",
        "fls_sbllpky4d7ka",
        "fls_nmx5xs829ms",
        "fls_nars4y8tv2w6",
        "fls_b5juxguclqjs",
        "fls_vmigixoxm5uf",
        "fls_vdqtbc4t69v2",
        "fls_t2d77dazjyjo",
        "fls_jh02uk3ypett",
        "fls_rjk5laiyqagy",
        "fls_26bq6wbwznx",
        "fls_6d25i0lkzd7u",
        "fls_y52suhleyid2",
        "fls_7b7c8xtm8fr7",
        "fls_ue0se3dcop6w",
        "fls_2m49cyfqffvo",
        "fls_mj1t0f9lp6v8",
        "fls_tpkkubhjt7lk",
        "fls_ivq874v4lmga",
        "fls_2wdcrocczwyi",
        "fls_v04te7p28dth",
        "fls_uypct69j2h6a",
        "fls_gyet9huf6nr",
        "fls_5ekbq9hacho9",
        "fls_furnyxmwqn09",
        "fls_1c4ts991vkpq",
        "fls_iwnb72jb9iwj",
        "fls_mw3axoixjgnq",
        "fls_mnzt6bxhycv9",
        "fls_drg7v8hxb5ca",
        "fls_78gb8z1fyluc",
        "fls_7dii7lee457t",
        "fls_ujhjocg1361b"
      ],
      "position": 10008,
      "parent_fls_id": "fls_z1il3w9nulzy",
      "sibling_fls_ids": [
        "fls_j9l8wn6wgm06",
        "fls_hejgghwzblf",
        "fls_e0896uk0mdyl",
        "fls_a3joqzqp1v9d",
        "fls_ylli0ortyegk",
        "fls_qezwyridmjob",
        "fls_MW7mtH5oOeQ1"
      ]
    },
    {
      "fls_id": "fls_hejgghwzblf",
      "title": "Register Arguments",
      "level": 2,
      "file": "inline-assembly",
      "content": "Register Arguments\n\n DirectionModifier ::=\n $$in$$\n | $$inlateout$$\n | $$inout$$\n | $$lateout$$\n | $$out$$\n\n RegisterExpression ::=\n InputOutputRegisterExpression\n | SimpleRegisterExpression\n | ConstRegisterExpression\n | SymPathExpression\n\n InputOutputRegisterExpression ::=\n InputRegisterExpression $$=>$$ OutputRegisterExpression\n | InputRegisterExpression $$=>$$ UnderscoreExpression\n\n InputRegisterExpression ::=\n Expression\n\n OutputRegisterExpression ::=\n Expression\n\n SimpleRegisterExpression ::=\n Expression\n | UnderscoreExpression\n\n ConstRegisterExpression ::=\n $$const$$ Expression\n\n SymPathExpression ::=\n $$sym$$ PathExpression\n\nA register argument is a construct that configures the input\nand output of a register, and optionally binds the configuration to an\nidentifier.\n\nA register argument shall be used within an assembly instruction.\n\nA named register argument is a register argument whose configuration\nis bound to an identifier.\n\nA positional register argument is a register argument whose\nconfiguration is not bound to an identifier.\n\nA named register argument shall appear after a\npositional register argument.\n\nAn explicit register argument is a register argument that uses an\nexplicit register name.\n\nAn explicit register argument shall appear after a\nnamed register argument.\n\nA register class argument is a register argument that uses a\nregister class name.\n\nA register class argument causes an assembler to select a suitable\nregister from the related register class.\n\nA direction modifier is a construct that indicates whether a\nregister argument initializes a register, assigns the value of a\nregister to an expression, or both.\n\nAn input register expression is an expression that provides the\ninitial value of a register.\n\nAn output register expression is an expression that is assigned the\nvalue of a register.\n\nA const register expression is an expression that is evaluated at compile-time.\n\nAn input-output register expression is a construct that specifies\nboth an input register expression and an output register expression.\n\nA simple register expression is either an expression or an\nunderscore expression.\n\nA register expression is either an input-output register expression, a simple register expression or a const register expression.\n\nThe type of a const register expression shall be an integer type.\n\nA sym path expression is a way for the assembly code block to refer either to\na function name or a static name.\n\nThe type of an input register expression,\noutput register expression, or simple register expression shall\ndepend on the architecture and the target feature in effect, as follows:\n\nIf a register argument has direction modifier in and a\nsimple register expression, then\n\n* Upon entry of an assembly code block, the register contains the\n value of the simple register expression.\n\n* On exit from an assembly code block, the register shall contain\n the same value, unless the register is subject to\n direction modifier lateout.\n\nIf a register argument has direction modifier out and a\nsimple register expression, then\n\n* Upon entry of an assembly code block, the register contains an\n undefined value.\n\n* On exit from an assembly code block, the value of the register\n is assigned to the simple register expression. The\n simple register expression shall be a place expression.\n\n* If the simple register expression is an underscore expression, then\n the value of the register is discarded.\n\nIf a register argument has direction modifier lateout and a\nsimple register expression, then the register argument behaves as a\nregister argument with direction modifier out, except that the\nregister can be reused with direction modifier in.\n\nIf a register argument has direction modifier inout and a\nsimple register expression, then\n\n* Upon entry of an assembly code block, the register contains the\n value of the simple register expression.\n\n* On exit from an assembly code block, the value of the register\n is assigned to the place indicated by the simple register expression.\n The simple register expression shall be a mutable place expression.\n\nIf a register argument has direction modifier inout and an\ninput-output register expression, then\n\n* Upon entry of an assembly code block, the register contains the\n value of the input register expression.\n\n* On exit from an assembly code block, the value of the register\n is assigned to the place indicated by the output register expression.\n The output register expression shall be a place expression.\n\n* If the output register expression is an underscore expression, then\n the value of the register is discarded.\n\nIf a register argument has direction modifier inlateout and a\nsimple register expression, then the register argument behaves as a\nregister argument with direction modifier inout, except that the\nregister can be reused with direction modifier in.\n\nIf a register argument has direction modifier inlateout and an\ninput-output register expression, then the register argument behaves\nas a register argument with direction modifier inout, except that\nthe register can be reused with direction modifier in.\n\nIt is a static error to specify a register argument with\ndirection modifier and register expression other than the\ncombinations listed above.\n\nThe evaluation of a register argument proceeds as follows:\n\n* If a register argument has an input-output register expression,\n then\n\n #. The input register expression is evaluated.\n\n #. The output register expression is evaluated.\n\n* If a register argument has a simple register expression, then the\n simple register expression is evaluated.",
      "paragraph_ids": [
        "fls_455dmnp4cxqv",
        "fls_6bv3s8be5xif",
        "fls_uddjvkz4g899",
        "fls_sqs5to20p0te",
        "fls_dzlycyk24euk",
        "fls_ics6gdzww1p",
        "fls_mmc1w8jjr55r",
        "fls_9hhtcey2d4t6",
        "fls_8aynifgq02gt",
        "fls_5a3vfresnv5z",
        "fls_fta1gb5tzi3a",
        "fls_sopiivuae0x7",
        "fls_81Ju1TEqJ48K",
        "fls_kkrcyk96w8x1",
        "fls_aniw4ehsn2kb",
        "fls_j9XOoXDmN5Dq",
        "fls_jU8zg4k8dFsY",
        "fls_y2wCBvXDtQK2",
        "fls_66owmltvhnu4",
        "fls_72p8e4bo6pns",
        "fls_z0dbmmp5yblf",
        "fls_4jdnt8uap95i",
        "fls_wd2hzsbzdg2y",
        "fls_sqy00lg5j7c6",
        "fls_vxba1ttvz6hh",
        "fls_xkbnla2avrn0",
        "fls_w6jhcv616l9o",
        "fls_xweobiwapog1",
        "fls_4matyejw6cls",
        "fls_hklqabav1jju",
        "fls_nq22h8gragil",
        "fls_uxgcrs57bznk",
        "fls_ym05938ejwng",
        "fls_5l77g8h8et2o",
        "fls_xlcliuums5b0",
        "fls_5p4hyl7mxgai",
        "fls_ilepg263w5o7",
        "fls_tubmavru8wvn",
        "fls_b1xi3u9k4pdl",
        "fls_i9ds6724tv20",
        "fls_trldyekxxlzx",
        "fls_efmpbyi4qjmf",
        "fls_4x3w50w7qm8w",
        "fls_6cne58tlquze",
        "fls_5w718fne9jsh",
        "fls_tel7kogaqytg",
        "fls_aw61psz5drg8",
        "fls_sv2x3x81b32j",
        "fls_nebb0nhxf5ix",
        "fls_j0pxc8g8kcxm",
        "fls_wwh6xyclxwqj",
        "fls_qcb47z1ap9dz",
        "fls_h01au4vk8mjd",
        "fls_92ijsf4p6yn",
        "fls_xkui7j3gnfg0",
        "fls_eahyqniqs2pn",
        "fls_5g7p2zo07gfe",
        "fls_dobbatnjs0yt",
        "fls_ax8t4uta34ym",
        "fls_dvft4ha00wj3",
        "fls_2ekwpx2bwj1b",
        "fls_3s2n9dlrlhz9",
        "fls_nbkkz6krcngi",
        "fls_utrvenwrettz",
        "fls_n85sjh925x"
      ],
      "position": 14461,
      "parent_fls_id": "fls_z1il3w9nulzy",
      "sibling_fls_ids": [
        "fls_j9l8wn6wgm06",
        "fls_pz2ioqchjtym",
        "fls_e0896uk0mdyl",
        "fls_a3joqzqp1v9d",
        "fls_ylli0ortyegk",
        "fls_qezwyridmjob",
        "fls_MW7mtH5oOeQ1"
      ]
    },
    {
      "fls_id": "fls_e0896uk0mdyl",
      "title": "Assembly Instructions",
      "level": 2,
      "file": "inline-assembly",
      "content": "Assembly Instructions\n\n AssemblyInstruction ::=\n StringLiteral\n\nAn assembly instruction is a string literal that represents a\nlow-level assembly operation or an assembly directive.\n\nAn assembly instruction shall use the syntax of format strings as\ndefined in module std::fmt, and contain zero or more\n[register parameter]s.\n\nAn assembly code block is a sequence of [assembly instruction]s.\n\nWhen an assembly code block contains multiple [assembly instruction]s,\nthe [assembly instruction]s are treated as concatenated into a single\nstring literal, with character 0x0A (new line) between them.\n\nThe set of memory locations that an assembly code block is allowed to\nread and write are the same as those for an external function, excluding\nthe memory locations that are private to the assembly code block.\n\nA tool is not required to guarantee that an assembly code block appears\nexactly once in the final assembly output.\n\nA tool is not required to guarantee that two [assembly code block]s\nappear in the same declarative order in the final assembly output, or appear\ncontiguously in successive addresses.\n\nA register parameter is a substring delimited by characters 0x7B (left\ncurly bracket) and 0x7D (right curly bracket) that is substituted with a\nregister argument in an assembly instruction.\n\nOn x86 architectures, direction flag DF in register EFLAGS shall\nbe cleared on exit from an assembly code block.\n\nOn x86 architectures, it is undefined behavior if direction flag DF in\nregister EFLAGS remains set on exit from an assembly code block.",
      "paragraph_ids": [
        "fls_4jr7eg6e0g4w",
        "fls_ihjhpy4osl53",
        "fls_2d05gcixjrzt",
        "fls_z64f094aivp6",
        "fls_u8lifqig90gq",
        "fls_lfeun3er5sc9",
        "fls_mmdmymljq8a3",
        "fls_xugsn2ghh73c",
        "fls_opnxq5kyw9jo",
        "fls_wydu9yft7a3r"
      ],
      "position": 25070,
      "parent_fls_id": "fls_z1il3w9nulzy",
      "sibling_fls_ids": [
        "fls_j9l8wn6wgm06",
        "fls_pz2ioqchjtym",
        "fls_hejgghwzblf",
        "fls_a3joqzqp1v9d",
        "fls_ylli0ortyegk",
        "fls_qezwyridmjob",
        "fls_MW7mtH5oOeQ1"
      ]
    },
    {
      "fls_id": "fls_lv19xysy1f7e",
      "title": "Register Parameter Modifiers",
      "level": 3,
      "file": "inline-assembly",
      "content": "Register Parameter Modifiers\n\nA register parameter modifier is a substring that starts with character\n0x3A (colon), follows a register parameter, and changes the formatting of\nthe related register parameter.\n\nThe effects of a register parameter modifier depends on the architecture\nand register class, as follows:",
      "paragraph_ids": [
        "fls_2xilifichdqu",
        "fls_o3fx9397ib74",
        "fls_3atrad53m22a",
        "fls_5zaqgz9jc8gy",
        "fls_erjczjotwqc3",
        "fls_z8m45i9xqkct",
        "fls_adaavz3olha3",
        "fls_u5dzca5f2pfm",
        "fls_6542a2hi5yhc",
        "fls_94thqwabspw2",
        "fls_xhp8xu8xvvgd",
        "fls_g0p2ebuffnxb",
        "fls_d0e2weni8q87",
        "fls_bq3p4k42tzh8",
        "fls_l5mkfdot97fz",
        "fls_sarl1hoq0lco",
        "fls_f4q9a0jrs4ek",
        "fls_w0hn6vkpuvpc",
        "fls_a7bvkyh5otx5",
        "fls_klthi4cczkem",
        "fls_pizgnxvcnj46",
        "fls_pvzfiuxka6wg",
        "fls_pf8yj3m81wk4",
        "fls_2bf3ady2idq1",
        "fls_x1se4r75v58o",
        "fls_rgovn5r3caif",
        "fls_faxm8xkhruvz",
        "fls_x1kkkvugpkyd",
        "fls_uonqmj16oqxe",
        "fls_ydhwlp56vmrz",
        "fls_yolqzfqbfjoh",
        "fls_ojzzhoed6t9l",
        "fls_gw56ok8llid3",
        "fls_ry7qoosmjrev",
        "fls_i0ax45x2wskd",
        "fls_op4dx1rqwhsf"
      ],
      "position": 27281,
      "parent_fls_id": "fls_e0896uk0mdyl",
      "sibling_fls_ids": [
        "fls_6momhvgx4w21"
      ]
    },
    {
      "fls_id": "fls_6momhvgx4w21",
      "title": "Directive Support",
      "level": 3,
      "file": "inline-assembly",
      "content": "Directive Support\n\nAn assembly directive is a request to the assembler to perform a\nparticular action or change a setting.\n\nIf an assembly code block contains stateful [assembly directive]s\nthat modify how subsequent assembly code is processed, then the\nassembly code block shall undo the effects of the stateful\n[assembly directive]s before the assembly code block is completed.\n\nThe common [assembly directive]s are as follows:\n\n#. .2byte, .4byte, .8byte\n\n#. .align, .ascii, .asciz, .alt_entry\n\n#. .balign, .balignl, .balignw, .balign, .balignl,\n .balignw, .bss, .byte\n\n#. .comm\n\n#. .data, .def, .double\n\n#. .endef, .equ, .equiv, .eqv\n\n#. .fill, .float\n\n#. .globl, .global\n\n#. .inst\n\n#. .lcomm, .long\n\n#. .octa, .option\n\n#. .private_extern, .p2align, .pushsection, .popsection\n\n#. .quad\n\n#. .scl, .section, .set, .short, .size, .skip,\n .sleb128, .space, .string\n\n#. .text, .type\n\n#. .uleb128\n\n#. .word\n\nThe following [assembly directive]s are relevant on ELF targets that\nsupport DWARF unwind info.\n\n#. .cfi_adjust_cfa_offset\n\n#. .cfi_def_cfa, .cfi_def_cfa_offset, .cfi_def_cfa_register\n\n#. .cfi_endproc, .cfi_escape\n\n#. .cfi_lsda\n\n#. .cfi_offset\n\n#. .cfi_personality\n\n#. .cfi_register, .cfi_rel_offset, .cfi_remember_state,\n .cfi_restore, .cfi_restore_state, .cfi_return_column\n\n#. .cfi_same_value, .cfi_sections, .cfi_signal_frame,\n .cfi_startproc\n\n#. .cfi_undefined\n\n#. .cfi_window_save\n\nThe following [assembly directive]s are relevant on targets with\nstructured exception handling.\n\n#. .seh_endproc, .seh_endprologue\n\n#. .seh_proc, .seh_pushreg\n\n#. .seh_savereg, .seh_setframe, .seh_stackalloc\n\nThe following [assembly directive]s are relevant on ARM targets.\n\n#. .code\n\n#. .even\n\n#. .fnstart, .fnend\n\n#. .movsp\n\n#. .save\n\n#. .thumb, .thumb_func\n\nThe following [assembly directive]s are relevant on x86 targets.\n\n#. .code16, .code32, .code64\n\n#. .nops",
      "paragraph_ids": [
        "fls_4tfod2vgz2m6",
        "fls_3b0ab1nlo641",
        "fls_caqznttql5p8",
        "fls_bcheqswo7a1",
        "fls_qxcl999rdwam",
        "fls_2yi7kjnhkfme",
        "fls_q0jp60aj81nv",
        "fls_akny3esj88yy",
        "fls_9jajt7jn9cxk",
        "fls_i7dr87fyrei8",
        "fls_rjzgpxt8z8x",
        "fls_iqrjkvgae5k",
        "fls_tzb5diegx3d5",
        "fls_82nia9oagat",
        "fls_qg6wt4plwnw6",
        "fls_8ci8ukk25nz3",
        "fls_ysbaz052rjg4",
        "fls_lbazk0g9r350",
        "fls_2dui79hn30o7",
        "fls_qzwyjj6xxwc2",
        "fls_9flwdfh5crsk",
        "fls_u1c09ssrllil",
        "fls_tx58qbvh3jz3",
        "fls_anwe21ypcjws",
        "fls_43rchr5ffxsv",
        "fls_rscmbo3kbrsm",
        "fls_hnol9houwn1f",
        "fls_es1lo6siw702",
        "fls_xlk7kd26j2rm",
        "fls_x9kaplz9g1z9",
        "fls_928ermlgde11",
        "fls_49bkqmxwl0d2",
        "fls_xlvkpe975b58",
        "fls_k3sy1ph0kvy",
        "fls_ku6noqc0poxq",
        "fls_hny0patop479",
        "fls_jm61m237cww",
        "fls_wvje5eua16xm",
        "fls_frxn2f6v584d",
        "fls_x6azw3td92b3",
        "fls_twerrggztho5",
        "fls_s4cbxrc4ijyp",
        "fls_2hdsgqko25l5",
        "fls_5tzwwove8mgq",
        "fls_e6nvq9xygvh"
      ],
      "position": 31136,
      "parent_fls_id": "fls_e0896uk0mdyl",
      "sibling_fls_ids": [
        "fls_lv19xysy1f7e"
      ]
    },
    {
      "fls_id": "fls_a3joqzqp1v9d",
      "title": "ABI Clobbers",
      "level": 2,
      "file": "inline-assembly",
      "content": "ABI Clobbers\n\n AbiKindList ::=\n AbiKind ($$,$$ AbiKind)* $$,$$?\n\nAn ABI clobber is an argument to macro core::arch::asm which\nindicates that the [value]s of selected [register]s might be\noverwritten during the execution of an assembly code block.\n\nMultiple [ABI clobber]s may be specified for an assembly code block.\nClobber constraints are applied for all unique [register]s in the union of\nall specified [ABI]s.\n\nThe effects of an ABI clobber depend on the ABI in effect, as follows:\n\nOn x86 architectures, the x87 floating-point register stack shall remain\nunchanged unless all st(\\ [0-7]\\ ) [register]s have been\nclobbered.\n\nOn x86 architectures, if all x87 [register]s are clobbered, then the x87\nregister stack is presumed empty upon entry of an assembly code block.\nThe x87 register stack shall be empty on exit from an\nassembly code block.",
      "paragraph_ids": [
        "fls_xa11ggykg0sh",
        "fls_e43sj9inlsym",
        "fls_gq2khxl1hixg",
        "fls_o2qn842y0vvc",
        "fls_msysjt5m2941",
        "fls_vyhl5po6pl4x",
        "fls_d1be48ik4a8",
        "fls_49pus6qqmf72",
        "fls_tc727ietnawz",
        "fls_6jgsmfvww667",
        "fls_gvzoq5mqwjx",
        "fls_bnwzzpcmiero"
      ],
      "position": 34630,
      "parent_fls_id": "fls_z1il3w9nulzy",
      "sibling_fls_ids": [
        "fls_j9l8wn6wgm06",
        "fls_pz2ioqchjtym",
        "fls_hejgghwzblf",
        "fls_e0896uk0mdyl",
        "fls_ylli0ortyegk",
        "fls_qezwyridmjob",
        "fls_MW7mtH5oOeQ1"
      ]
    },
    {
      "fls_id": "fls_ylli0ortyegk",
      "title": "Assembly Options",
      "level": 2,
      "file": "inline-assembly",
      "content": "Assembly Options\n\n OptionList ::=\n Option ($$,$$ Option)* $$,$$?\n\n Option ::=\n $$att_syntax$$\n | $$nomem$$\n | $$noreturn$$\n | $$nostack$$\n | $$preserves_flags$$\n | $$pure$$\n | $$raw$$\n | $$readonly$$\n\nAn assembly option is used to specify a characteristic of or a restriction\non the related assembly code block.\n\nAssembly option :dc:`att_syntax` is applicable only to x86 architectures\nand causes the assembler to use the .att_syntax prefix mode which prefixes\n[register]s with %.\n\nAssembly option nomem indicates that the assembly code block does\nnot read or write memory.\n\nAssembly option noreturn indicates that the assembly code block\ndoes not return, preventing the dropping of [variable]s.\n\nAssembly option nostack indicates that the assembly code block\ndoes not push on the stack, or write to the stack red-zone (if supported).\n\nIf assembly option nostack is not in effect, then an\nassembly code block is allowed to use stack space below the stack pointer.\nUpon entry of an assembly code block, the stack pointer is suitably\naligned according to the target ABI for [call expression]s. The stack\npointer shall be restored to its original value on exit from the\nassembly code block.\n\nAssembly option preserves_flags indicates that the\nassembly code block does not modify the flags register.\n\nIf assembly option preserves_flags is in effect, then the [value]s\nof the following flags [register]s shall be restored on exit from an\nassembly code block:\n\nAssembly option pure indicates that the assembly code block has no\nside effects, and its outputs depend only on direct inputs.\n\nAssembly option :dc:`raw` causes [assembly instruction]s to be parsed\nraw, without any special handling of [register parameter]s.\n\nAssembly option readonly indicates that the assembly code block\ndoes not write memory.\n\n[Assembly option]s att_syntax and raw shall appear only in\n:s:`GlobalAsmArguments`.\n\n[Assembly option]s nomem and readonly shall not be used together.\n\nAssembly option noreturn shall not be specified on an\nassembly code block that has [output register]s.\n\nAssembly option pure shall appear with either assembly option\nnomem or assembly option readonly.\n\nAssembly option pure shall not be specified on an\nassembly code block that either lacks [output register]s or all\n[register expression]s of [output register]s are\n[underscore expression]s.\n\nIt is undefined behavior if an assembly code block subject to\nassembly option pure has side effects other than its direct outputs.\n\nIt is undefined behavior if control reaches the end of an\nassembly code block subject to assembly option noreturn.",
      "paragraph_ids": [
        "fls_i21l6t3vn95t",
        "fls_g09kmp2a04g9",
        "fls_quer8ltdwnf2",
        "fls_5wpgqpcm1v40",
        "fls_ejuap3kkvs57",
        "fls_1nopbk5bkeqm",
        "fls_e5b1mp3byll2",
        "fls_2gf4wemrzaae",
        "fls_5ebifab8dhy",
        "fls_ae2x4ho3i0zr",
        "fls_188ib65a1z36",
        "fls_ia3cg424d601",
        "fls_j09bo53i5n69",
        "fls_eka6chp3hapa",
        "fls_nszx1gllufi2",
        "fls_d169ppna563c",
        "fls_h8549stij7pj",
        "fls_2drikpht6md9",
        "fls_x66j1cn6zi6p",
        "fls_ikwbu1ho33is",
        "fls_nf0h9crdzhfg",
        "fls_wh0wasawjj5s",
        "fls_s0ivlbjefh1u"
      ],
      "position": 37339,
      "parent_fls_id": "fls_z1il3w9nulzy",
      "sibling_fls_ids": [
        "fls_j9l8wn6wgm06",
        "fls_pz2ioqchjtym",
        "fls_hejgghwzblf",
        "fls_e0896uk0mdyl",
        "fls_a3joqzqp1v9d",
        "fls_qezwyridmjob",
        "fls_MW7mtH5oOeQ1"
      ]
    },
    {
      "fls_id": "fls_qezwyridmjob",
      "title": "Macros: asm, global_asm, and naked_asm",
      "level": 2,
      "file": "inline-assembly",
      "content": "Macros: asm, global_asm, and naked_asm\n\n GlobalAsmArguments ::=\n $$($$ AssemblyCodeBlock ($$,$$ RegisterArgument)* ($$,$$ AssemblyOption)* $$,$$? $$)$$\n\n LabelBlock ::=\n $$block$$ $${$$ StatementList $$}$$\n\n[Assembly code block]s are embedded within Rust source code using\n[macro]s core::arch::asm,\ncore::arch::global_asm, and\ncore::arch::naked_asm.\n\nWhen invoking macro core::arch::asm, the :s:`DelimitedTokenTree` of\nthe related macro invocation shall follow the syntax of :s:`AsmArguments`.\n\nInvoking macro core::arch::asm causes the related\nassembly code block to be integrated into the generated assembly of the\nfunction where the macro invocation took place. A tool is free to\nencapsulate the assembly code block in a separate function and\ngenerate a call expression to it.\n\nWhen invoking macro core::arch::global_asm and\nmacro core::arch::naked_asm, the\n:s:`DelimitedTokenTree` of the related macro invocation shall follow the\nsyntax of :s:`GlobalAsmArguments`.\n\nInvoking macro core::arch::global_asm causes the related\nassembly code block to be emitted outside the function where the\nmacro invocation took place.\n\nThe only [register argument]s that can be used with [macro]s\ncore::arch::global_asm and core::arch::naked_asm are\nconst <const register expression> and sym <sym path expression>.\n\nThe only [assembly option]s that can be used with [macro]s\ncore::arch::global_asm and core::arch::naked_asm are att_syntax and raw.\n\nThe evaluation of a macro invocation to macro\ncore::arch::asm or macro core::arch::global_asm evaluates\n[register argument]s in declarative order.\n\nThe execution of an assembly code block produced by\ninline assembly proceeds as follows:\n\n#. All [input register]s are initialized to the [value]s provided by\n the respective [register argument]s, in an undefined order.\n\n#. The [assembly instruction]s of the assembly code block are executed\n in declarative order.\n\n#. The [value]s of all [output register]s are assigned to the\n [register expression]s provided by the respective\n [register argument]s, in an undefined order.",
      "paragraph_ids": [
        "fls_ecteot716j8j",
        "fls_1ikzov7cxic1",
        "fls_4lb6yh12w1cv",
        "fls_tgzga1lanfuo",
        "fls_nfkbvs86d6kz",
        "fls_PEoOGTBjuEQc",
        "fls_vcB5xwgD6Ign",
        "fls_98vyqh9bzigx",
        "fls_ppnj8bcncdp9",
        "fls_wmay1vd8u0da",
        "fls_e613hpr50t9",
        "fls_bic6iyd1nvfm"
      ],
      "position": 42217,
      "parent_fls_id": "fls_z1il3w9nulzy",
      "sibling_fls_ids": [
        "fls_j9l8wn6wgm06",
        "fls_pz2ioqchjtym",
        "fls_hejgghwzblf",
        "fls_e0896uk0mdyl",
        "fls_a3joqzqp1v9d",
        "fls_ylli0ortyegk",
        "fls_MW7mtH5oOeQ1"
      ]
    },
    {
      "fls_id": "fls_MW7mtH5oOeQ1",
      "title": "Label block",
      "level": 2,
      "file": "inline-assembly",
      "content": "Label block\n\nA label block is a block expression whose memory address is substituted into an assembly code block.\n\nThe type of the label block must be unit type or never type.\n\nA label block does not propagate its [unsafe context] to its contained [statement]s.",
      "paragraph_ids": [
        "fls_ZKMMqhBRe5lJ",
        "fls_vJT3iAG1ZLh3",
        "fls_ER0GVQE9N7oH"
      ],
      "position": 45760,
      "parent_fls_id": "fls_z1il3w9nulzy",
      "sibling_fls_ids": [
        "fls_j9l8wn6wgm06",
        "fls_pz2ioqchjtym",
        "fls_hejgghwzblf",
        "fls_e0896uk0mdyl",
        "fls_a3joqzqp1v9d",
        "fls_ylli0ortyegk",
        "fls_qezwyridmjob"
      ]
    },
    {
      "fls_id": "fls_wb86edg02t6a",
      "title": "Items",
      "level": 1,
      "file": "items",
      "content": "Items\n\n ItemWithVisibility ::=\n VisibilityModifier? (\n ConstantDeclaration\n | EnumDeclaration\n | ExternalBlock\n | ExternalCrateImport\n | FunctionDeclaration\n | Implementation\n | ModuleDeclaration\n | StaticDeclaration\n | StructDeclaration\n | TraitDeclaration\n | TypeAliasDeclaration\n | UnionDeclaration\n | UseImport\n )\n\n MacroItem ::=\n MacroRulesDeclaration\n | TerminatedMacroInvocation\n\n ItemSafety ::=\n $$unsafe$$\n | $$safe$$\n\nThe macro expansion of a terminated macro invocation is treated as\nzero or more [item]s if the terminated macro invocation appears as\nan item.\n\nElaboration is the process by which a declaration achieves its runtime\neffects.",
      "paragraph_ids": [
        "fls_s3b1cba9lfj5",
        "fls_hil5f7y4xdhe"
      ],
      "position": 125,
      "parent_fls_id": null,
      "sibling_fls_ids": [
        "fls_l21tjqjkkaa0",
        "fls_gvwd0kf72jt",
        "fls_3v733mnewssy",
        "fls_gdeyap4or1db",
        "fls_dzq9cdz4ibsz",
        "fls_ckvjj4tt1hh2",
        "fls_osd6c4utyjb3",
        "fls_qcb1n9c0e5hz",
        "fls_48qldfwwh493",
        "fls_y2k5paj8m8ug",
        "fls_fk2m2irwpeof",
        "fls_z1il3w9nulzy",
        "fls_411up5z0b6n6",
        "fls_83182bfa9uqb",
        "fls_ronnwodjjjsh",
        "fls_xgqh0ju6bmbn",
        "fls_hdwwrsyunir",
        "fls_wdicg3sqa98e",
        "fls_vgb6ev541b2r",
        "fls_EBwqH60SUHiN",
        "fls_jep7p27kaqlp",
        "fls_94a8v54bufn8"
      ]
    },
    {
      "fls_id": "fls_411up5z0b6n6",
      "title": "Lexical Elements",
      "level": 1,
      "file": "lexical-elements",
      "content": "Lexical Elements\n\nThe text of a Rust program consists of [module]s organized into [source\nfile]s. The text of a source file is a sequence of [lexical\nelement]s, each composed of characters, whose rules are presented in this\nchapter.",
      "paragraph_ids": [
        "fls_pqwpf87b84tr"
      ],
      "position": 125,
      "parent_fls_id": null,
      "sibling_fls_ids": [
        "fls_l21tjqjkkaa0",
        "fls_gvwd0kf72jt",
        "fls_3v733mnewssy",
        "fls_gdeyap4or1db",
        "fls_dzq9cdz4ibsz",
        "fls_ckvjj4tt1hh2",
        "fls_osd6c4utyjb3",
        "fls_qcb1n9c0e5hz",
        "fls_48qldfwwh493",
        "fls_y2k5paj8m8ug",
        "fls_fk2m2irwpeof",
        "fls_z1il3w9nulzy",
        "fls_wb86edg02t6a",
        "fls_83182bfa9uqb",
        "fls_ronnwodjjjsh",
        "fls_xgqh0ju6bmbn",
        "fls_hdwwrsyunir",
        "fls_wdicg3sqa98e",
        "fls_vgb6ev541b2r",
        "fls_EBwqH60SUHiN",
        "fls_jep7p27kaqlp",
        "fls_94a8v54bufn8"
      ]
    },
    {
      "fls_id": "fls_2i089jvv8j5g",
      "title": "Character Set",
      "level": 2,
      "file": "lexical-elements",
      "content": "Character Set\n\nThe program text of a Rust program is written using the Unicode character\nset.\n\nA character is defined by this document for each cell in the coding space\ndescribed by Unicode, regardless of whether or not Unicode allocates a\ncharacter to that cell.\n\nA whitespace character is one of the following characters:\n\n* 0x09 (horizontal tabulation)\n\n* 0x0A (new line)\n\n* 0x0B (vertical tabulation)\n\n* 0x0C (form feed)\n\n* 0x0D (carriage return)\n\n* 0x20 (space)\n\n* 0x85 (next line)\n\n* 0x200E (left-to-right mark)\n\n* 0x200F (right-to-left mark)\n\n* 0x2028 (line separator)\n\n* 0x2029 (paragraph separator)\n\nA whitespace string is a string that consists of one or more\n[whitespace character]s.\n\nAn :ds:`AsciiCharacter` is any Unicode character in the range 0x00 - 0x7F, both inclusive.\n\nThe coded representation of a character is tool-defined.",
      "paragraph_ids": [
        "fls_itcth8292ud6",
        "fls_vfx8byq5zo8t",
        "fls_pvslhm3chtlb",
        "fls_a5ec9cpn4sc8",
        "fls_dgyrj49y3c7c",
        "fls_5ocmngyur7by",
        "fls_1aj0rgi9kpib",
        "fls_bfzdxsbq2c2q",
        "fls_vw0kq2y1o63m",
        "fls_ao296bmamwzh",
        "fls_6kymhq7embdh",
        "fls_8mxmrxvhn3by",
        "fls_bc6D1ATvmJJr",
        "fls_zfs15iel08y0",
        "fls_7eifv4ksunu1",
        "fls_PIDKEm8GiLNL",
        "fls_2brw13n9ldgy"
      ],
      "position": 470,
      "parent_fls_id": "fls_411up5z0b6n6",
      "sibling_fls_ids": [
        "fls_fgnllgz5k3e6",
        "fls_21vnag69kbwe",
        "fls_nrkd5wpi64oo",
        "fls_q8l2jza7d9xa",
        "fls_lish33a1naw5"
      ]
    },
    {
      "fls_id": "fls_fgnllgz5k3e6",
      "title": "Lexical Elements, Separators, and Punctuation",
      "level": 2,
      "file": "lexical-elements",
      "content": "Lexical Elements, Separators, and Punctuation\n\n Punctuation ::=\n Delimiter\n | $$+$$\n | $$-$$\n | $$*$$\n | $$/$$\n | $$%$$\n | $$^$$\n | $$!$$\n | $$&$$\n | $$|$$\n | $$&&$$\n | $$||$$\n | $$<<$$\n | $$>>$$\n | $$+=$$\n | $$-=$$\n | $$*=$$\n | $$/=$$\n | $$%=$$\n | $$^=$$\n | $$&=$$\n | $$|=$$\n | $$<<=$$\n | $$>>=$$\n | $$=$$\n | $$==$$\n | $$!=$$\n | $$>$$\n | $$<$$\n | $$>=$$\n | $$<=$$\n | $$@$$\n | $$_$$\n | $$.$$\n | $$..$$\n | $$...$$\n | $$..=$$\n | $$,$$\n | $$;$$\n | $$:$$\n | $$::$$\n | $$->$$\n | $$=>$$\n | $$#$$\n | $$$$$\n | $$?$$\n\n Delimiter ::=\n $${$$\n | $$}$$\n | $$[$$\n | $$]$$\n | $$($$\n | $$)$$\n\nThe text of a source file is a sequence of separate [lexical\nelement]s. The meaning of a program depends only on the particular sequence of\n[lexical element]s, excluding non-[doc comment]s.\n\nA lexical element is the most basic syntactic element in program text.\n\nThe text of a source file is divided into [line]s.\n\nA line is a sequence of zero or more characters followed by an end of\nline.\n\nThe representation of an end of line is tool-defined.\n\nA separator is a character or a string that separates adjacent [lexical\nelement]s. A whitespace string is a separator.\n\nA simple punctuator is one of the following special characters:\n\nA compound punctuator is one of the following two or more adjacent special\ncharacters:\n\nThe following [compound punctuator]s are [flexible compound\npunctuator]s.\n\nA flexible compound punctuator may be treated as a single compound\npunctuator or two adjacent [simple punctuator]s.\n\nEach of the special characters listed for single character punctuator\nis a simple punctuator except if this character is used as a character\nof a compound punctuator, or a character of a character literal, a\ncomment, a numeric literal, or a string literal.\n\nThe following names are used when referring to [punctuator]s:",
      "paragraph_ids": [
        "fls_d4nvxsvxj537",
        "fls_a1zylpqha73x",
        "fls_jy6wifn5r2bu",
        "fls_efdfq9nhpmp5",
        "fls_go25sisi5fdp",
        "fls_a6t53o8h1vdk",
        "fls_8fv63w6f4udl",
        "fls_es0tz1q9cmoo",
        "fls_vm86olkeecer",
        "fls_5zxdgxy8tjrq",
        "fls_x89vkq9rwlyt",
        "fls_bo3xh8r60ji1",
        "fls_sslkjuxjnteu",
        "fls_9g1godm0jp0z",
        "fls_6oith9q0soot",
        "fls_1dledwdc8fa6",
        "fls_lunw7ucj5ius",
        "fls_a4oiuhz95uiv",
        "fls_137x9s6guj6h",
        "fls_y0wdb09cpp1w",
        "fls_48b7mepiuupz",
        "fls_g9h9bsvrsmk1",
        "fls_fxne2xd0zzzo",
        "fls_il7zv5x3aw0q",
        "fls_ovcs1qm86ss9",
        "fls_wmhlvjm0b0j9",
        "fls_gg42klb2gn9v",
        "fls_icahptg5enj4",
        "fls_baawlxoi7yd4",
        "fls_m7gt3wfbtm81",
        "fls_6ewl7gn3sjm2",
        "fls_nb8q6oq8txv3",
        "fls_4nnky9ansr9j",
        "fls_h1gvudehmnn9",
        "fls_6yj1c3lh691s",
        "fls_2d3oo9nou9vv",
        "fls_st2vhcy14ud9",
        "fls_9gdyw71dl25",
        "fls_sp8ufz28l9w3",
        "fls_7kdr8biodxvz",
        "fls_pf92l9bkte2u",
        "fls_ui40thspgyav",
        "fls_h33qzachmimc",
        "fls_13ud1clgdnyv",
        "fls_7fosi8l2ktz2",
        "fls_9qitp6r75ia6",
        "fls_g0umao9roi2l",
        "fls_lamrpdpko48",
        "fls_s4lte9onbmqb",
        "fls_ywc297y8s0dt",
        "fls_ijb0fws4gshu",
        "fls_c25ur4xwbpk0",
        "fls_9dd9479zzq30",
        "fls_kwsu9d3ppv3f",
        "fls_oh62j9unw4mg",
        "fls_g0tltt8qmbum",
        "fls_ounkw8b8tk4f",
        "fls_8ywv8gftsfr1",
        "fls_hsn6zc29ifyx",
        "fls_o3amqe3ca82d",
        "fls_lkevfpj7sqd3",
        "fls_ff05ge2189z",
        "fls_nplkudde6oxf",
        "fls_qwnrklmbz0b"
      ],
      "position": 1850,
      "parent_fls_id": "fls_411up5z0b6n6",
      "sibling_fls_ids": [
        "fls_2i089jvv8j5g",
        "fls_21vnag69kbwe",
        "fls_nrkd5wpi64oo",
        "fls_q8l2jza7d9xa",
        "fls_lish33a1naw5"
      ]
    },
    {
      "fls_id": "fls_21vnag69kbwe",
      "title": "Identifiers",
      "level": 2,
      "file": "lexical-elements",
      "content": "Identifiers\n\n IdentifierList ::=\n Identifier ($$,$$ Identifier)* $$,$$?\n\n NonKeywordIdentifier ::=\n PureIdentifier\n | WeakKeyword\n\n RawIdentifier ::=\n $$r#$$ (PureIdentifier | RawIdentifierKeyword)\n\n PureIdentifier ::=\n XID_Start XID_Continue*\n | $$_$$ XID_Continue+\n\n IdentifierOrUnderscore ::=\n Identifier\n | $$_$$\n\n Renaming ::=\n $$as$$ IdentifierOrUnderscore\n\nA :ds:`RawIdentifierKeyword` is any keyword in category :s:`Keyword`,\nexcept crate, self, Self, and super.\n\n:ds:`XID_Start` and :ds:`XID_Continue` are defined in Unicode Standard Annex\n#31.\n\nAn identifier is a lexical element that refers to a name.\n\nA pure identifier is an identifier that does not include [weak\nkeyword]s.\n\nA pure identifier shall follow the specification in Unicode Standard Annex\n#31 for Unicode version 16.0, with the following profile:\n\n* Start = XID_Start, plus character 0x5F (low line).\n\n* Continue = XID_Continue\n\n* Medial = empty\n\nCharacters 0x200C (zero width non-joiner) and 0x200D (zero width joiner) shall\nnot appear in a pure identifier.\n\nA pure identifier shall be restricted to characters in category\n:s:`AsciiCharacter` in the following contexts:\n\n* [Crate import]s,\n\n* [Name]s of external [crate]s represented in a simple path, when\n the simple path starts with namespace qualifier ::,\n\n* [Name]s of [outline module]s that lack attribute path,\n\n* [Name]s of [item]s that are subject to attribute\n no_mangle,\n\n* [Name]s of [item]s within [external block]s.\n\n[Identifier]s are normalized using Normalization Form C as defined in\nUnicode Standard Annex #15.\n\nTwo [identifier]s are considered the same if they consist of the same\nsequence of characters after performing normalization.\n\n[Declarative macro]s and [procedural macro]s shall receive normalized\n[identifier]s in their input.",
      "paragraph_ids": [
        "fls_ls7ymvgd5kfa",
        "fls_aqj9aguczgqs",
        "fls_xsdmun5uqy4c",
        "fls_ktnf6zkrdy45",
        "fls_jpecw46eh061",
        "fls_lwcflgezgs5z",
        "fls_uts0hywaw1rq",
        "fls_lju1avcn0pfd",
        "fls_cs6cbw625np1",
        "fls_irwcldiotei2",
        "fls_g72rxs2z5960",
        "fls_w473jevurlt1",
        "fls_mt1u4m3simhc",
        "fls_e2v58o233lvd",
        "fls_op0lp1i065di",
        "fls_vde7gev5rz4q",
        "fls_j9yh8j8jgdeu",
        "fls_jejt5z8m1yew"
      ],
      "position": 8492,
      "parent_fls_id": "fls_411up5z0b6n6",
      "sibling_fls_ids": [
        "fls_2i089jvv8j5g",
        "fls_fgnllgz5k3e6",
        "fls_nrkd5wpi64oo",
        "fls_q8l2jza7d9xa",
        "fls_lish33a1naw5"
      ]
    },
    {
      "fls_id": "fls_nrkd5wpi64oo",
      "title": "Literals",
      "level": 2,
      "file": "lexical-elements",
      "content": "Literals\n\nA literal is a fixed value in program text.",
      "paragraph_ids": [
        "fls_s76un78zyd0j"
      ],
      "position": 11224,
      "parent_fls_id": "fls_411up5z0b6n6",
      "sibling_fls_ids": [
        "fls_2i089jvv8j5g",
        "fls_fgnllgz5k3e6",
        "fls_21vnag69kbwe",
        "fls_q8l2jza7d9xa",
        "fls_lish33a1naw5"
      ]
    },
    {
      "fls_id": "fls_2ifjqwnw03ms",
      "title": "Byte Literals",
      "level": 3,
      "file": "lexical-elements",
      "content": "Byte Literals\n\n ByteContent ::=\n ByteCharacter\n | ByteEscape\n\n ByteEscape ::=\n $$\\0$$\n | $$\\\"$$\n | $$\\'$$\n | $$\\t$$\n | $$\\n$$\n | $$\\r$$\n | $$\\\\$$\n | $$\\x$$ OctalDigit HexadecimalDigit\n\nA :ds:`ByteCharacter` is any character in category :s:`AsciiCharacter`\nexcept characters 0x09 (horizontal tabulation), 0x0A (new line), 0x0D (carriage\nreturn), 0x27 (apostrophe), and 0x5C (reverse solidus).\n\nA byte literal is a literal that denotes a fixed byte value.\n\nThe type of a byte literal is u8.",
      "paragraph_ids": [
        "fls_3hpzf12h60u4",
        "fls_q0qwr83frszx",
        "fls_fggytrv5jvw0"
      ],
      "position": 11576,
      "parent_fls_id": "fls_nrkd5wpi64oo",
      "sibling_fls_ids": [
        "fls_fqaffyrjob7v",
        "fls_U1gHCy16emVe",
        "fls_hv9jtycp0o1y",
        "fls_ypa86oqxhn9u",
        "fls_jkab8eevzbte"
      ]
    },
    {
      "fls_id": "fls_fqaffyrjob7v",
      "title": "Byte String Literals",
      "level": 3,
      "file": "lexical-elements",
      "content": "Byte String Literals\n\nA byte string literal is a literal that consists of multiple\n:s:`[AsciiCharacter]s`.\n\nThe character sequence 0x0D 0x0A (carriage return, new line) is replaced by 0x0A\n(new line) inside of a byte string literal.",
      "paragraph_ids": [
        "fls_t63zfv5JdUhj",
        "fls_Xd6LnfzMb7t7"
      ],
      "position": 12436,
      "parent_fls_id": "fls_nrkd5wpi64oo",
      "sibling_fls_ids": [
        "fls_2ifjqwnw03ms",
        "fls_U1gHCy16emVe",
        "fls_hv9jtycp0o1y",
        "fls_ypa86oqxhn9u",
        "fls_jkab8eevzbte"
      ]
    },
    {
      "fls_id": "fls_msbaxfC09VkK",
      "title": "Simple Byte String Literals",
      "level": 4,
      "file": "lexical-elements",
      "content": "Simple Byte String Literals\n\n SimpleByteStringContent ::=\n ByteEscape\n | SimpleByteStringCharacter\n | StringContinuation\n\nA :ds:`SimpleByteStringCharacter` is any character in category :s:`AsciiCharacter`\nexcept characters 0x0D (carriage return), 0x22 (quotation mark), and 0x5C\n(reverse solidus).\n\nA simple byte string literal is a byte string literal that consists of multiple\n:s:`[AsciiCharacter]s`.\n\nThe type of a simple byte string literal of size N is &'static [u8;\nN].",
      "paragraph_ids": [
        "fls_3dcqhuosqb84",
        "fls_moe3zfx39ox2",
        "fls_vffxb6arj9jf"
      ],
      "position": 12921,
      "parent_fls_id": "fls_fqaffyrjob7v",
      "sibling_fls_ids": [
        "fls_jps9102q0qfi"
      ]
    },
    {
      "fls_id": "fls_jps9102q0qfi",
      "title": "Raw Byte String Literals",
      "level": 4,
      "file": "lexical-elements",
      "content": "Raw Byte String Literals\n\n RawByteStringContent ::=\n NestedRawByteStringContent\n | $$\"$$ AsciiCharacter* $$\"$$\n\n NestedRawByteStringContent ::=\n $$#$$ RawByteStringContent $$#$$\n\nA raw byte string literal is a simple byte string literal that does not\nrecognize [escaped character]s.\n\nThe type of a raw byte string literal of size N is &'static\n[u8; N].",
      "paragraph_ids": [
        "fls_yyw7nv651580",
        "fls_5ybq0euwya42"
      ],
      "position": 13784,
      "parent_fls_id": "fls_fqaffyrjob7v",
      "sibling_fls_ids": [
        "fls_msbaxfC09VkK"
      ]
    },
    {
      "fls_id": "fls_U1gHCy16emVe",
      "title": "C String Literals",
      "level": 3,
      "file": "lexical-elements",
      "content": "C String Literals\n\nA c string literal is a literal that consists of multiple characters\nwith an implicit 0x00 byte appended to it.\n\nThe character sequence 0x0D 0x0A (carriage return, new line) is replaced by 0x0A\n(new line) inside of a c string literal.",
      "paragraph_ids": [
        "fls_VKCW830CzhhN",
        "fls_XJprzaEn82Xs"
      ],
      "position": 14499,
      "parent_fls_id": "fls_nrkd5wpi64oo",
      "sibling_fls_ids": [
        "fls_2ifjqwnw03ms",
        "fls_fqaffyrjob7v",
        "fls_hv9jtycp0o1y",
        "fls_ypa86oqxhn9u",
        "fls_jkab8eevzbte"
      ]
    },
    {
      "fls_id": "fls_p090c5oTnElW",
      "title": "Simple C String Literals",
      "level": 4,
      "file": "lexical-elements",
      "content": "Simple C String Literals\n\n SimpleCStringContent ::=\n AsciiEscape\n | SimpleStringCharacter\n | StringContinuation\n | UnicodeEscape\n\nA simple c string literal is any Unicode character except characters\n0x0D (carriage return), 0x22 (quotation mark), 0x5C (reverse solidus) and 0x00\n(null byte).\n\nA simple c string literal is a c string literal where the characters are\nUnicode characters.\n\nThe type of a simple string literal is &'static\n[core::ffi::CStr].",
      "paragraph_ids": [
        "fls_fnwQHo7twAom",
        "fls_nPI7j0siGP8G",
        "fls_Ae7LM4Wg0NA7"
      ],
      "position": 14993,
      "parent_fls_id": "fls_U1gHCy16emVe",
      "sibling_fls_ids": [
        "fls_G4LdypF3rL6i"
      ]
    },
    {
      "fls_id": "fls_G4LdypF3rL6i",
      "title": "Raw C String Literals",
      "level": 4,
      "file": "lexical-elements",
      "content": "Raw C String Literals\n\n RawCStringContent ::=\n NestedRawCStringContent\n | $$\"$$ ~[$$\\r$$]* $$\"$$\n\n NestedRawCStringContent ::=\n $$#$$ RawCStringContent $$#$$\n\nA raw c string literal is a simple c string literal that does not\nrecognize [escaped character]s.\n\nThe type of a simple string literal is &'static\n[core::ffi::CStr].",
      "paragraph_ids": [
        "fls_gLrei65i8Uzq",
        "fls_9nJHsg9dCi66"
      ],
      "position": 15904,
      "parent_fls_id": "fls_U1gHCy16emVe",
      "sibling_fls_ids": [
        "fls_p090c5oTnElW"
      ]
    },
    {
      "fls_id": "fls_hv9jtycp0o1y",
      "title": "Numeric Literals",
      "level": 3,
      "file": "lexical-elements",
      "content": "Numeric Literals\n\nA numeric literal is a literal that denotes a number.",
      "paragraph_ids": [
        "fls_fqpqnku27v99"
      ],
      "position": 16581,
      "parent_fls_id": "fls_nrkd5wpi64oo",
      "sibling_fls_ids": [
        "fls_2ifjqwnw03ms",
        "fls_fqaffyrjob7v",
        "fls_U1gHCy16emVe",
        "fls_ypa86oqxhn9u",
        "fls_jkab8eevzbte"
      ]
    },
    {
      "fls_id": "fls_2ed4axpsy9u0",
      "title": "Integer Literals",
      "level": 4,
      "file": "lexical-elements",
      "content": "Integer Literals\n\n IntegerContent ::=\n BinaryLiteral\n | DecimalLiteral\n | HexadecimalLiteral\n | OctalLiteral\n\n BinaryLiteral ::=\n $$0b$$ BinaryDigitOrUnderscore* BinaryDigit BinaryDigitOrUnderscore*\n\n BinaryDigitOrUnderscore ::=\n BinaryDigit\n | $$_$$\n\n BinaryDigit ::=\n [$$0$$-$$1$$]\n\n DecimalLiteral ::=\n DecimalDigit DecimalDigitOrUnderscore*\n\n DecimalDigitOrUnderscore ::=\n DecimalDigit\n | $$_$$\n\n DecimalDigit ::=\n [$$0$$-$$9$$]\n\n HexadecimalLiteral ::=\n $$0x$$ HexadecimalDigitOrUnderscore* HexadecimalDigit HexadecimalDigitOrUnderscore*\n\n HexadecimalDigitOrUnderscore ::=\n HexadecimalDigit\n | $$_$$\n\n HexadecimalDigit ::=\n [$$0$$-$$9$$ $$a$$-$$f$$ $$A$$-$$F$$]\n\n OctalLiteral ::=\n $$0o$$ OctalDigitOrUnderscore* OctalDigit OctalDigitOrUnderscore*\n\n OctalDigitOrUnderscore ::=\n OctalDigit\n | $$_$$\n\n OctalDigit ::=\n [$$0$$-$$7$$]\n\n IntegerSuffix ::=\n SignedIntegerSuffix\n | UnsignedIntegerSuffix\n\n SignedIntegerSuffix ::=\n $$i8$$\n | $$i16$$\n | $$i32$$\n | $$i64$$\n | $$i128$$\n | $$isize$$\n\n UnsignedIntegerSuffix ::=\n $$u8$$\n | $$u16$$\n | $$u32$$\n | $$u64$$\n | $$u128$$\n | $$usize$$\n\nAn integer literal is a numeric literal that denotes a whole number.\n\nA binary literal is an integer literal in base 2.\n\nA decimal literal is an integer literal in base 10.\n\nA hexadecimal literal is an integer literal in base 16.\n\nAn octal literal is an integer literal in base 8.\n\nAn integer suffix is a component of an integer literal that specifies\nan explicit integer type.\n\nA suffixed integer is an integer literal with an integer suffix.\n\nAn unsuffixed integer is an integer literal without an integer\nsuffix.\n\nThe type of a suffixed integer is determined by its integer\nsuffix as follows:\n\n* Suffix i8 specifies type i8.\n\n* Suffix i16 specifies type i16.\n\n* Suffix i32 specifies type i32.\n\n* Suffix i64 specifies type i64.\n\n* Suffix i128 specifies type i128.\n\n* Suffix isize specifies type isize.\n\n* Suffix u8 specifies type u8.\n\n* Suffix u16 specifies type u16.\n\n* Suffix u32 specifies type u32.\n\n* Suffix u64 specifies type u64.\n\n* Suffix u128 specifies type u128.\n\n* Suffix usize specifies type usize.\n\nThe type of an unsuffixed integer is determined by type inference\nas follows:\n\n* If an integer type can be uniquely determined from the surrounding\n program context, then the unsuffixed integer has that type.\n\n* If the program context under-constrains the type, then the inferred\n type is i32.\n\n* If the program context over-constrains the type, then this is considered\n a static error.",
      "paragraph_ids": [
        "fls_vkk2krfn93ry",
        "fls_nxqncu5yq4eu",
        "fls_rn8xfd66yvst",
        "fls_2268lchxkzjp",
        "fls_4v7awnutbpoe",
        "fls_f1e29aj0sqvl",
        "fls_u83mffscqm6",
        "fls_g10nuv14q4jn",
        "fls_hpkkvuj1z1ez",
        "fls_7yq2fep848ky",
        "fls_bzm8lwq3qlat",
        "fls_l4cx36brc1r5",
        "fls_wthchinwx996",
        "fls_7uoaet2pm3am",
        "fls_p4rw583o2qbi",
        "fls_xrv4q56lmoo3",
        "fls_66e3q5um6cwc",
        "fls_5asyk66y7c9d",
        "fls_76fifqjka0lx",
        "fls_fsaimo419gf0",
        "fls_hvzacbu7yiwc",
        "fls_50qipwqi3arw",
        "fls_idzhusp2l908",
        "fls_qqrqyc6uhol",
        "fls_pexi5jazthq6"
      ],
      "position": 16853,
      "parent_fls_id": "fls_hv9jtycp0o1y",
      "sibling_fls_ids": [
        "fls_29tlg1vyqay2"
      ]
    },
    {
      "fls_id": "fls_29tlg1vyqay2",
      "title": "Float Literals",
      "level": 4,
      "file": "lexical-elements",
      "content": "Float Literals\n\n FloatExponent ::=\n ExponentLetter ExponentSign? ExponentMagnitude\n\n ExponentLetter ::=\n $$e$$\n | $$E$$\n\n ExponentSign ::=\n $$+$$\n | $$-$$\n\n ExponentMagnitude ::=\n DecimalDigitOrUnderscore* DecimalDigit DecimalDigitOrUnderscore*\n\n FloatSuffix ::=\n $$f32$$\n | $$f64$$\n\nA float literal is a numeric literal that denotes a fractional number.\n\nA float suffix is a component of a float literal that specifies an\nexplicit floating-point type.\n\nA suffixed float is a float literal with a float suffix.\n\nAn unsuffixed float is a float literal without a float suffix.\n\nThe type of a suffixed float is determined by the float suffix\nas follows:\n\n* Suffix f32 specifies type f32.\n\n* Suffix f64 specifies type f64.\n\nThe type of an unsuffixed float is determined by type inference\nas follows:\n\n* If a floating-point type can be uniquely determined from the surrounding\n program context, then the unsuffixed float has that type.\n\n* If the program context under-constrains the type, then the inferred\n type is f64.\n\n* If the program context over-constrains the type, then this is considered\n a static error.",
      "paragraph_ids": [
        "fls_rzi7oeqokd6e",
        "fls_2ru1zyrykd37",
        "fls_21mhnhplzam7",
        "fls_drqh80k0sfkb",
        "fls_cbs7j9pjpusw",
        "fls_b9w7teaw1f8f",
        "fls_eawxng4ndhv0",
        "fls_yuhza1muo7o",
        "fls_4sxt1ct7fyen",
        "fls_wa72rssp0jnt",
        "fls_x2cw7g8g56f8"
      ],
      "position": 20676,
      "parent_fls_id": "fls_hv9jtycp0o1y",
      "sibling_fls_ids": [
        "fls_2ed4axpsy9u0"
      ]
    },
    {
      "fls_id": "fls_ypa86oqxhn9u",
      "title": "Character Literals",
      "level": 3,
      "file": "lexical-elements",
      "content": "Character Literals\n\n CharacterContent ::=\n AsciiEscape\n | CharacterLiteralCharacter\n | UnicodeEscape\n\n AsciiEscape ::=\n $$\\0$$\n | $$\\\"$$\n | $$\\'$$\n | $$\\t$$\n | $$\\n$$\n | $$\\r$$\n | $$\\\\$$\n | $$\\x$$ OctalDigit HexadecimalDigit\n\nA :ds:`CharacterLiteralCharacter` is any Unicode character except\ncharacters 0x09 (horizontal tabulation), 0x0A (new line), 0x0D (carriage\nreturn), 0x27 (apostrophe), and 0x5c (reverse solidus).\n\nA :ds:`UnicodeEscape` starts with a \\u{ literal, followed by 1 to 6\ninstances of a :s:`HexadecimalDigit`, inclusive, followed by a } character.\nIt can represent any Unicode codepoint between U+00000 and U+10FFFF,\ninclusive, except Unicode surrogate codepoints, which exist between\nthe range of U+D800 and U+DFFF, inclusive.\n\nA character literal is a literal that denotes a fixed Unicode\ncharacter.\n\nThe type of a character literal is char.",
      "paragraph_ids": [
        "fls_j9q9ton57rvl",
        "fls_5v9gx22g5wPm",
        "fls_vag2oy4q7d4n",
        "fls_n8z6p6g564r2"
      ],
      "position": 22649,
      "parent_fls_id": "fls_nrkd5wpi64oo",
      "sibling_fls_ids": [
        "fls_2ifjqwnw03ms",
        "fls_fqaffyrjob7v",
        "fls_U1gHCy16emVe",
        "fls_hv9jtycp0o1y",
        "fls_jkab8eevzbte"
      ]
    },
    {
      "fls_id": "fls_boyhlu5srp6u",
      "title": "Simple String Literals",
      "level": 4,
      "file": "lexical-elements",
      "content": "String Literals\n\nA string literal is a literal that consists of multiple characters.\n\nThe character sequence 0x0D 0x0A (carriage return, new line) is replaced by 0x0A\n(new line) inside of a string literal.",
      "paragraph_ids": [
        "fls_7fuctvtvdi7x",
        "fls_NyiCpU2tzJlQ"
      ],
      "position": 23957,
      "parent_fls_id": "fls_ypa86oqxhn9u",
      "sibling_fls_ids": [
        "fls_hucd52suu6it",
        "fls_usr6iuwpwqqh"
      ]
    },
    {
      "fls_id": "fls_hucd52suu6it",
      "title": "Simple String Literals",
      "level": 4,
      "file": "lexical-elements",
      "content": "Simple String Literals\n\n SimpleStringContent ::=\n AsciiEscape\n | SimpleStringCharacter\n | StringContinuation\n | UnicodeEscape\n\nA :ds:`SimpleStringCharacter` is any Unicode character except characters\n0x0D (carriage return), 0x22 (quotation mark), and 0x5C (reverse solidus).\n\n:ds:`StringContinuation` is the character sequence 0x5C 0x0A (reverse solidus,\nnew line).\n\nA simple string literal is a string literal where the characters are\nUnicode characters.\n\nThe type of a simple string literal is &'static str.",
      "paragraph_ids": [
        "fls_1pdzwkt5txfj",
        "fls_wawtu6j3fiqn",
        "fls_ycy5ee6orjx",
        "fls_6nt5kls21xes"
      ],
      "position": 24398,
      "parent_fls_id": "fls_ypa86oqxhn9u",
      "sibling_fls_ids": [
        "fls_boyhlu5srp6u",
        "fls_usr6iuwpwqqh"
      ]
    },
    {
      "fls_id": "fls_usr6iuwpwqqh",
      "title": "Raw String Literals",
      "level": 4,
      "file": "lexical-elements",
      "content": "Raw String Literals\n\n RawStringContent ::=\n NestedRawStringContent\n | $$\"$$ ~[$$\\r$$]* $$\"$$\n\n NestedRawStringContent ::=\n $$#$$ RawStringContent $$#$$\n\nA raw string literal is a simple string literal that does not\nrecognize [escaped character]s.\n\nThe type of a raw string literal is &'static str.",
      "paragraph_ids": [
        "fls_36suwhbwmq1t",
        "fls_ms43w1towz40"
      ],
      "position": 25369,
      "parent_fls_id": "fls_ypa86oqxhn9u",
      "sibling_fls_ids": [
        "fls_boyhlu5srp6u",
        "fls_hucd52suu6it"
      ]
    },
    {
      "fls_id": "fls_jkab8eevzbte",
      "title": "Boolean Literals",
      "level": 3,
      "file": "lexical-elements",
      "content": "Boolean Literals\n\nA boolean literal is a literal that denotes the truth [value]s of\nlogic and Boolean algebra.\n\nThe type of a boolean literal is bool.",
      "paragraph_ids": [
        "fls_1lll64ftupjd",
        "fls_pgngble3ilyx"
      ],
      "position": 26008,
      "parent_fls_id": "fls_nrkd5wpi64oo",
      "sibling_fls_ids": [
        "fls_2ifjqwnw03ms",
        "fls_fqaffyrjob7v",
        "fls_U1gHCy16emVe",
        "fls_hv9jtycp0o1y",
        "fls_ypa86oqxhn9u"
      ]
    },
    {
      "fls_id": "fls_q8l2jza7d9xa",
      "title": "Comments",
      "level": 2,
      "file": "lexical-elements",
      "content": "Comments\n\n BlockCommentOrDoc ::=\n BlockComment\n | InnerBlockDoc\n | OuterBlockDoc\n\n LineCommentOrDoc ::=\n LineComment\n | InnerLineDoc\n | OuterLineDoc\n\n LineComment ::=\n $$//$$\n | $$//$$ (~[$$!$$ $$/$$] | $$//$$) ~[$$\\n$$]*\n\n BlockComment ::=\n $$/*$$ (~[$$!$$ $$*$$] | $$**$$ | BlockCommentOrDoc) (BlockCommentOrDoc | ~[$$*/$$])* $$*/$$\n | $$/**/$$\n | $$/***/$$\n\n InnerBlockDoc ::=\n $$/*!$$ (BlockCommentOrDoc | ~[$$*/$$ $$\\r$$])* $$*/$$\n\n InnerLineDoc ::=\n $$//!$$ ~[$$\\n$$ $$\\r$$]*\n\n OuterBlockDoc ::=\n $$/**$$ (~[$$*$$] | BlockCommentOrDoc) (BlockCommentOrDoc | ~[$$*/$$ $$\\r$$])* $$*/$$\n\n OuterLineDoc ::=\n $$///$$ (~[$$/$$] ~[$$\\n$$ $$\\r$$]*)?\n\nA comment is a lexical element that acts as an annotation or an\nexplanation in program text.\n\nA block comment is a comment that spans one or more [line]s.\n\nA line comment is a comment that spans exactly one line.\n\nAn inner block doc is a block comment that applies to an enclosing\nnon-[comment] construct.\n\nAn inner line doc is a line comment that applies to an enclosing\nnon-[comment] construct.\n\nAn inner doc comment is either an inner block doc or an\ninner line doc.\n\nAn outer block doc is a block comment that applies to a subsequent\nnon-[comment] construct.\n\nAn outer line doc is a line comment that applies to a subsequent\nnon-[comment] construct.\n\nAn outer doc comment is either an outer block doc or an\nouter line doc.\n\nA doc comment is a comment class that includes [inner block\ndoc]s, [inner line doc]s, [outer block doc]s, and [outer line\ndoc]s.\n\nCharacter 0x0D (carriage return) shall not appear in a comment.\n\n[Block comment]s, [inner block doc]s, and [outer block doc]s\nshall extend one or more [line]s.\n\n[Line comment]s, [inner line doc]s, and [outer line doc]s shall\nextend exactly one line.\n\n[Outer block doc]s and [outer line doc]s shall apply to a subsequent\nnon-[comment] construct.\n\n[Inner block doc]s and [inner line doc]s shall apply to an enclosing\nnon-[comment] construct.\n\n[Inner block doc]s and [inner line doc]s are equivalent to\nattribute doc of the form #![doc = content], where content\nis a string literal form of the comment without the leading //!,\n/*! amd trailing */ characters.\n\n[Outer block doc]s and [outer line doc]s are equivalent to\nattribute doc of the form #[doc = content], where content\nis a string literal form of the comment without the leading ///,\n/** and trailing */ characters.",
      "paragraph_ids": [
        "fls_8obn3dtzpe5f",
        "fls_qsbnl11be35s",
        "fls_nayisy85kyq2",
        "fls_k3hj30hjkdhw",
        "fls_tspijl68lduc",
        "fls_KZp0yiFLTqxb",
        "fls_63gzofa9ktic",
        "fls_scko7crha0um",
        "fls_RYVL9KgaxKvl",
        "fls_7n6d3jx61ose",
        "fls_6fxcs17n4kw",
        "fls_uze7l7cxonk1",
        "fls_gy23lwlqw2mc",
        "fls_w7d0skpov1is",
        "fls_32ncjvj2kn7z",
        "fls_ok0zvo9vcmzo",
        "fls_nWtKuPi8Fw6v"
      ],
      "position": 26446,
      "parent_fls_id": "fls_411up5z0b6n6",
      "sibling_fls_ids": [
        "fls_2i089jvv8j5g",
        "fls_fgnllgz5k3e6",
        "fls_21vnag69kbwe",
        "fls_nrkd5wpi64oo",
        "fls_lish33a1naw5"
      ]
    },
    {
      "fls_id": "fls_lish33a1naw5",
      "title": "Keywords",
      "level": 2,
      "file": "lexical-elements",
      "content": "Keywords\n\nA keyword is a word in program text that has special meaning.\n\n[Keyword]s are case sensitive.",
      "paragraph_ids": [
        "fls_dti0uu7rz81w",
        "fls_sxg1o4oxql51"
      ],
      "position": 30432,
      "parent_fls_id": "fls_411up5z0b6n6",
      "sibling_fls_ids": [
        "fls_2i089jvv8j5g",
        "fls_fgnllgz5k3e6",
        "fls_21vnag69kbwe",
        "fls_nrkd5wpi64oo",
        "fls_q8l2jza7d9xa"
      ]
    },
    {
      "fls_id": "fls_mec5cg5aptf8",
      "title": "Strict Keywords",
      "level": 3,
      "file": "lexical-elements",
      "content": "Strict Keywords\n\nA strict keyword is a keyword that always holds its special meaning.",
      "paragraph_ids": [
        "fls_bsh7qsyvox21"
      ],
      "position": 30765,
      "parent_fls_id": "fls_lish33a1naw5",
      "sibling_fls_ids": [
        "fls_cbsgp6k0qa82",
        "fls_9kjpxri0axvg"
      ]
    },
    {
      "fls_id": "fls_cbsgp6k0qa82",
      "title": "Reserved Keywords",
      "level": 3,
      "file": "lexical-elements",
      "content": "Reserved Keywords\n\nA reserved keyword is a keyword that is not yet in use.",
      "paragraph_ids": [
        "fls_w4b97ewwnql"
      ],
      "position": 31624,
      "parent_fls_id": "fls_lish33a1naw5",
      "sibling_fls_ids": [
        "fls_mec5cg5aptf8",
        "fls_9kjpxri0axvg"
      ]
    },
    {
      "fls_id": "fls_9kjpxri0axvg",
      "title": "Weak Keywords",
      "level": 3,
      "file": "lexical-elements",
      "content": "Weak Keywords\n\nA weak keyword is a keyword whose special meaning depends on the\ncontext.\n\nWord macro_rules acts as a keyword only when used in the context of a\n:s:`MacroRulesDefinition`.\n\nWord 'static acts as a keyword only when used in the context of a\n:s:`LifetimeIndication`.\n\nWord union acts as a keyword only when used in the context of a\n:s:`UnionDeclaration`.\n\nWord safe acts as a keyword only when used as a qualifier of :s:`FunctionDeclaration` or :s:`StaticDeclaration` in the context of a :s:`ExternalBlock`.",
      "paragraph_ids": [
        "fls_bv87t1gvj7bz",
        "fls_bl55g03jmayf",
        "fls_c354oryv513p",
        "fls_r9fhuiq1ys1p",
        "fls_g0JEluWqBpNc"
      ],
      "position": 32083,
      "parent_fls_id": "fls_lish33a1naw5",
      "sibling_fls_ids": [
        "fls_mec5cg5aptf8",
        "fls_cbsgp6k0qa82"
      ]
    },
    {
      "fls_id": "fls_83182bfa9uqb",
      "title": "Macros",
      "level": 1,
      "file": "macros",
      "content": "Macros\n\nA macro is a custom definition that extends Rust by defining callable\nsyntactic transformations. The effects of a macro are realized through\n[macro invocation]s or attribute use. [Macro]s come in two\ndistinct forms:\n\n* [Declarative macro]s define rules for recognizing syntactic patterns and\n generating direct syntax.\n\n* [Procedural macro]s define augmented [function]s that operate on and\n return a stream of [lexical element]s.\n\n[Token]s are a subset of [lexical element]s consumed by [macro]s.",
      "paragraph_ids": [
        "fls_j1jc83erljo0",
        "fls_23eapx3ckymf",
        "fls_a5uemz2hnbi8",
        "fls_rnty1c8l5495"
      ],
      "position": 125,
      "parent_fls_id": null,
      "sibling_fls_ids": [
        "fls_l21tjqjkkaa0",
        "fls_gvwd0kf72jt",
        "fls_3v733mnewssy",
        "fls_gdeyap4or1db",
        "fls_dzq9cdz4ibsz",
        "fls_ckvjj4tt1hh2",
        "fls_osd6c4utyjb3",
        "fls_qcb1n9c0e5hz",
        "fls_48qldfwwh493",
        "fls_y2k5paj8m8ug",
        "fls_fk2m2irwpeof",
        "fls_z1il3w9nulzy",
        "fls_wb86edg02t6a",
        "fls_411up5z0b6n6",
        "fls_ronnwodjjjsh",
        "fls_xgqh0ju6bmbn",
        "fls_hdwwrsyunir",
        "fls_wdicg3sqa98e",
        "fls_vgb6ev541b2r",
        "fls_EBwqH60SUHiN",
        "fls_jep7p27kaqlp",
        "fls_94a8v54bufn8"
      ]
    },
    {
      "fls_id": "fls_xa7lp0zg1ol2",
      "title": "Declarative Macros",
      "level": 2,
      "file": "macros",
      "content": "Declarative Macros\n\n MacroRulesDefinition ::=\n $$($$ MacroRuleList $$)$$ $$;$$\n | $$[$$ MacroRuleList $$]$$ $$;$$\n | $${$$ MacroRuleList $$}$$\n\n MacroRuleList ::=\n MacroRule ($$;$$ MacroRule)* $$;$$?\n\n MacroRule ::=\n MacroMatcher $$=>$$ MacroTranscriber\n\n MacroMatcher ::=\n $$($$ MacroMatch* $$)$$\n | $$[$$ MacroMatch* $$]$$\n | $${$$ MacroMatch* $$}$$\n\n MacroTranscriber ::=\n DelimitedTokenTree\n\n MacroMatch ::=\n MacroMatcher\n | MacroMatchToken\n | MacroMetavariableMatch\n | MacroRepetitionMatch\n\nA :ds:`MacroMatchToken` is any lexical element in category\n:s:`LexicalElement`, except punctuation $ and category :s:`Delimiter`.\n\nA declarative macro is a macro that associates a name with a set\nof syntactic transformation [macro rule]s.\n\nA macro rule is a construct that consists of a macro matcher and\na macro transcriber.\n\nA macro matcher is a construct that describes a syntactic pattern that\na macro must match.\n\nA macro match is the most basic form of a satisfied macro matcher.\n\nA macro transcriber is a construct that describes the replacement\nsyntax of a macro.\n\nA declarative macro is invoked using a macro invocation.",
      "paragraph_ids": [
        "fls_ikzjsq8heyk6",
        "fls_w44hav7mw3ao",
        "fls_dw1nq4r9ghhd",
        "fls_oq4xn8guos8f",
        "fls_cdaf8viwmdfe",
        "fls_ljavs0w61z3j",
        "fls_3jspk8obv7sd"
      ],
      "position": 848,
      "parent_fls_id": "fls_83182bfa9uqb",
      "sibling_fls_ids": [
        "fls_wn1i6hzg2ff7",
        "fls_vnvt40pa48n8",
        "fls_wjldgtio5o75",
        "fls_xlfo7di0gsqz"
      ]
    },
    {
      "fls_id": "fls_8nzypdu9j3ge",
      "title": "Metavariables",
      "level": 3,
      "file": "macros",
      "content": "Metavariables\n\n MacroMetavariable ::=\n Keyword\n | NonKeywordIdentifier\n\n MacroFragmentSpecifier ::=\n $$block$$\n | $$expr$$\n | $$expr_2021$$\n | $$ident$$\n | $$item$$\n | $$lifetime$$\n | $$literal$$\n | $$meta$$\n | $$pat$$\n | $$pat_param$$\n | $$path$$\n | $$stmt$$\n | $$tt$$\n | $$ty$$\n | $$vis$$\n\n MacroMetavariableIndication ::=\n $$$$$ MacroMetavariable\n\n[Declarative macro]s employ [metavariable]s to match a token of\na particular kind and bind its value to a name for use during\nmacro transcription.\n\nA metavariable is a macro match that describes a variable.\n\nA metavariable is visible in the macro transcriber of the\nmacro rule of the macro matcher it is declared in.\n\nA fragment specifier is a construct that indicates the type of\na metavariable.\n\nFragment specifier kinds impose the following\n[fragment specifier restriction]s on the [token]s that follow them:\n\n* expr and expr_2021 shall only be followed by =>, ,, or ;.\n\n* pat shall only be followed by =>, ,, =, |, if, or\n in.\n\n* path shall only be followed by =>, ,, =, |, ;, :,\n >, >>, [, {, as, where, or a metavariable with\n the block fragment specifier kind.\n\n* pat_param shall only be followed by =>, ,, =, |, if,\n or in.\n\n* stmt shall only be followed by =>, ,, or ;.\n\n* ty shall only be followed by =>, ,, =, |, ;, :,\n >, >>, [, {, as, where, or a metavariable with\n the block fragment specifier kind.\n\n* vis shall only be followed by ,, an identifier except for\n priv, any token that may begin a :s:`TypeSpecification`, or a\n metavariable with the ident, ty or block\n fragment specifier kind.\n\n* Any other kind may be followed by any token.\n\nA metavariable indication is a construct that indicates a\nmetavariable.",
      "paragraph_ids": [
        "fls_g93r3teei8wo",
        "fls_4zdait30exvn",
        "fls_2HguXbL7DjKH",
        "fls_8zypylq60zba",
        "fls_8o9mcV2KrKac",
        "fls_PxR9vNHsaFnI",
        "fls_ePyoTeJJ11N0",
        "fls_0j7VOV4ewfeY",
        "fls_80cOMpIMU2gx",
        "fls_DFMRwsWI8e5z",
        "fls_BoIGgrFdyhwH",
        "fls_NBbygZwUxjFp",
        "fls_lZ8F1zUJju33",
        "fls_ephlmLsGTMgw"
      ],
      "position": 2603,
      "parent_fls_id": "fls_xa7lp0zg1ol2",
      "sibling_fls_ids": [
        "fls_k01lsksqtq1r"
      ]
    },
    {
      "fls_id": "fls_k01lsksqtq1r",
      "title": "Repetition",
      "level": 3,
      "file": "macros",
      "content": "Repetition\n\n MacroRepetitionMatchContent ::=\n MacroMatch*\n\n MacroRepetitionTranscriber ::=\n $$$$$ $$($$ TokenTree* $$)$$ MacroRepetitionSeparator? MacroRepetitionOperator\n\n MacroRepetitionOperator ::=\n $$+$$\n | $$*$$\n | $$?$$\n\nA :ds:`MacroRepetitionSeparator` is any lexical element in category\n:s:`LexicalElement`, except punctuation +, *, ?, and category\n:s:`Delimiter`.\n\nA macro repetition in matching allows for a syntactic pattern to be matched\nzero or multiple times during macro matching.\n\nA macro repetition in transcription allows for a syntactic pattern to be\ntranscribed zero or multiple times during macro transcription.\n\nA macro repetition is either a macro repetition in matching or a\nmacro repetition in transcription.\n\nA repetition operator is a construct that indicates the number\nof times a macro repetition in matching or a\nmacro repetition in transcription can be repeated.\n\nThe effects of a repetition operator are as follows:\n\n* * - Zero or more repetitions.\n\n* + - One or more repetitions.\n\n* ? - Zero or one repetition.\n\nA macro repetition has the following additional restrictions:\n\n* If the macro repetition has a separator, the separator shall\n be allowed by the :s:`MacroRepetitionMatchContent`'s\n [fragment specifier restriction]s.\n\n* If the repetition operator is * or +, then the\n possible beginnings of the :s:`MacroRepetitionMatchContent` shall be allowed\n by its :s:`MacroRepetitionMatchContent`'s\n [fragment specifier restriction]s.\n\n* If the repetition operator is ? or *, then the succeeding\n :s:`MacroMatch` must be allowed by the preceding :s:`MacroMatch`'s\n [fragment specifier restriction]s.\n\n* The possible beginnings of the :s:`MacroRepetitionMatchContent` must be\n allowed by the preceding :s:`MacroMatch`'s\n [fragment specifier restriction]s.\n\n* The succeeding :s:`MacroMatch` must be allowed by the possible endings of the\n :s:`MacroRepetitionMatchContent`'s [fragment specifier restriction]s.",
      "paragraph_ids": [
        "fls_4ps4x4513xau",
        "fls_8byjmlgum2f3",
        "fls_ltdp3zs60dzr",
        "fls_V1WRuzZUWUGj",
        "fls_u86j0zm2jshf",
        "fls_h5f8x4jdnvbu",
        "fls_hf4gj5pfl437",
        "fls_tm0w0680wf4x",
        "fls_10lsg5212ffb",
        "fls_UnfvR9NB1Nze",
        "fls_Sm4qVsHKYLY2",
        "fls_Rdvs8Dz6OUU7",
        "fls_UIlj6Csow81w",
        "fls_yp2XxDv4DzEi",
        "fls_n5TkJKWiDhCD"
      ],
      "position": 5384,
      "parent_fls_id": "fls_xa7lp0zg1ol2",
      "sibling_fls_ids": [
        "fls_8nzypdu9j3ge"
      ]
    },
    {
      "fls_id": "fls_wn1i6hzg2ff7",
      "title": "Procedural Macros",
      "level": 2,
      "file": "macros",
      "content": "Procedural Macros\n\nA procedural macro is a macro that encapsulates syntactic\ntransformations in a function. [Procedural macro]s consume one or more\nstreams of [token]s and produce a stream of [token]s.\n\n[Procedural macro]s shall be defined in a crate subject to\nattribute crate_type where the type is proc-macro.\n\nA macro implementation function is the function that encapsulates the\nsyntactic transformations of a procedural macro.\n\nA macro implementation function enters the name of the\nprocedural macro into the macro namespace.",
      "paragraph_ids": [
        "fls_ejbddhggstd2",
        "fls_pcce9gmjpxba",
        "fls_vtzuplb1p3s",
        "fls_mewfehvgm16r"
      ],
      "position": 8298,
      "parent_fls_id": "fls_83182bfa9uqb",
      "sibling_fls_ids": [
        "fls_xa7lp0zg1ol2",
        "fls_vnvt40pa48n8",
        "fls_wjldgtio5o75",
        "fls_xlfo7di0gsqz"
      ]
    },
    {
      "fls_id": "fls_2d6bqnpy6tvs",
      "title": "Function-like Macros",
      "level": 3,
      "file": "macros",
      "content": "Function-like Macros\n\nA function-like macro is a procedural macro that consumes a stream of\n[token]s and produces a stream of [token]s.\n\nThe macro implementation function of a function-like macro shall be\nsubject to the following restrictions:\n\n* It shall be subject to attribute proc_macro,\n\n* It shall be subject to visibility modifier pub,\n\n* It shall lack [function qualifier]s,\n\n* It shall lack [generic parameter]s,\n\n* It shall have a single function parameter whose type specification\n indicates type proc_macro::TokenStream,\n\n* It shall have a return type whose type specification indicates\n type proc_macro::TokenStream.\n\nA function-like macro is invoked using a macro invocation.\n\nThe sole parameter of the macro implementation function captures the\ntoken stream produced from the :s:`DelimitedTokenTree` of the\nmacro invocation, excluding outer :s:`[Delimiter]s`.",
      "paragraph_ids": [
        "fls_utd3zqczix",
        "fls_ojr30lf6jfx0",
        "fls_ljkjmegynhiy",
        "fls_8a8qhzjw5hax",
        "fls_ofzql79i9if",
        "fls_j1wsyzip2qb3",
        "fls_etyo9bmzxby6",
        "fls_mkl9b38m0sf1",
        "fls_lfmb22bfnrye",
        "fls_fbgal48cgj44"
      ],
      "position": 9080,
      "parent_fls_id": "fls_wn1i6hzg2ff7",
      "sibling_fls_ids": [
        "fls_o8s3r7m90q59",
        "fls_4vjbkm4ceymk"
      ]
    },
    {
      "fls_id": "fls_o8s3r7m90q59",
      "title": "Derive Macros",
      "level": 3,
      "file": "macros",
      "content": "Derive Macros\n\nA derive macro is a procedural macro that consumes a stream of\n[token]s and produces a stream of [token]s. [Derive macro]s are\nused to construct new syntax for [abstract data type]s.\n\nThe macro implementation function of a derive macro shall be subject\nto the following restrictions:\n\n* It shall be subject to attribute proc_macro_derive,\n\n* It shall be subject to visibility modifier pub,\n\n* It shall lack [function qualifier]s,\n\n* It shall lack [generic parameter]s,\n\n* It shall have a single function parameter whose type specification\n indicates type proc_macro::TokenStream,\n\n* It shall have a return type whose type specification indicates\n type proc_macro::TokenStream.\n\nA derive macro is invoked using attribute derive.\n\nThe sole parameter of the macro implementation function captures\nthe token stream produced from the related :s:`EnumDeclaration`,\n:s:`StructDeclaration`, or :s:`UnionDeclaration`.\n\nA derive macro adds all its declared [derive helper attribute]s into\nthe derive helper attribute scope of the abstract data type the\nattribute is attached to.\n\nA derive helper attribute is an inert attribute that acts as a\nhint to attribute derive.",
      "paragraph_ids": [
        "fls_e5x92q2rq8a0",
        "fls_ldw75sy5uj7p",
        "fls_7gcnui9beky",
        "fls_ef30ropg7dhx",
        "fls_mo00vqm9xfqc",
        "fls_gr9wugeqyb3b",
        "fls_npnze2cg8ae",
        "fls_w2h4lk6bmht",
        "fls_x96a0xzcyrko",
        "fls_caa16usjxryg",
        "fls_H5ipqqlH3pJh",
        "fls_mobky5ck1mi"
      ],
      "position": 10592,
      "parent_fls_id": "fls_wn1i6hzg2ff7",
      "sibling_fls_ids": [
        "fls_2d6bqnpy6tvs",
        "fls_4vjbkm4ceymk"
      ]
    },
    {
      "fls_id": "fls_4vjbkm4ceymk",
      "title": "Attribute Macros",
      "level": 3,
      "file": "macros",
      "content": "Attribute Macros\n\nAn attribute macro is a procedural macro that consumes two streams\nof [token]s to produce a single stream of [token]s, and defines a\nnew outer attribute that can be attached to [item]s.\n[Attribute macro]s are used to replace [item]s with other\n[item]s.\n\nThe macro implementation function of an attribute macro shall be\nsubject to the following restrictions:\n\n* It shall be subject to attribute proc_macro_attribute,\n\n* It shall be subject to visibility modifier pub,\n\n* It shall lack [function qualifier]s,\n\n* It shall lack [generic parameter]s,\n\n* It shall have two [function parameter]s whose [type specification]s\n indicate type proc_macro::TokenStream,\n\n* It shall have a return type whose type specification indicates type\n proc_macro::TokenStream.\n\nAn attribute macro is invoked using an attribute of the form\n\n* #[SimplePath], or\n\n* #[SimplePath DelimitedTokenTree]\n\nThe first function parameter of the macro implementation function\ncaptures the token stream produced from the :s:`DelimitedTokenTree`\nof the invoking attribute, excluding outer :s:`[Delimiter]s`. If no\n:s:`DelimitedTokenTree` is provided, then the token stream is considered\nempty.\n\nThe second function parameter of the macro implementation function\ncaptures the token stream produced from the related item, including\nall [outer attribute]s that apply to that item.",
      "paragraph_ids": [
        "fls_l3epi1dqpi8o",
        "fls_3sublbi9bz7k",
        "fls_eb8jxl70wmeh",
        "fls_7ugtmobgb2t9",
        "fls_y700oif45wum",
        "fls_hhsf1a9p6o55",
        "fls_4g932k8ueyqp",
        "fls_f5qy1pnlbpng",
        "fls_rzn48xylk4yj",
        "fls_78400zh02sdq",
        "fls_eyesmvuwpjn1",
        "fls_fku5beu3mr4c",
        "fls_knjsslplv5ri"
      ],
      "position": 12514,
      "parent_fls_id": "fls_wn1i6hzg2ff7",
      "sibling_fls_ids": [
        "fls_2d6bqnpy6tvs",
        "fls_o8s3r7m90q59"
      ]
    },
    {
      "fls_id": "fls_vnvt40pa48n8",
      "title": "Macro Invocation",
      "level": 2,
      "file": "macros",
      "content": "Macro Invocation\n\n DelimitedTokenTree ::=\n $$($$ TokenTree* $$)$$\n | $$[$$ TokenTree* $$]$$\n | $${$$ TokenTree* $$}$$\n\n TokenTree ::=\n DelimitedTokenTree\n | NonDelimitedToken\n\n TerminatedMacroInvocation ::=\n SimplePath $$!$$ $$($$ TokenTree* $$)$$ $$;$$\n | SimplePath $$!$$ $$[$$ TokenTree* $$]$$ $$;$$\n | SimplePath $$!$$ $${$$ TokenTree* $$}$$\n\nA :ds:`NonDelimitedToken` is any lexical element in category\n:s:`LexicalElement`, except category :s:`Delimiter`.\n\nA macro invocation is a call of a declarative macro or\nfunction-like macro that is expanded statically and replaced with the\nresult of the macro.\n\nA terminated macro invocation is a macro invocation that may be used\nas a statement.\n\nSee :p:`fls_xa7lp0zg1ol2` for the declaration of answer_to_life.\n\nSee :p:`fls_8nzypdu9j3ge` for the declaration of square.\n\nSee :p:`fls_k01lsksqtq1r` for the declaration of generate_pairs.\n\nSee :p:`fls_2d6bqnpy6tvs` for the declaration of\nmake_answer_to_life.\n\nSee :p:`fls_o8s3r7m90q59` for the declaration of Answer.\n\nSee :p:`fls_4vjbkm4ceymk` for the declaration of\noutput_and_return_item.",
      "paragraph_ids": [
        "fls_wushtmw9qt3y",
        "fls_snpxxcqhtjfv",
        "fls_6v06zvi1ctub",
        "fls_338rmbazl67o",
        "fls_lrr7gg8tian",
        "fls_8qxwwf4trnl",
        "fls_8z1sgtvchhhw",
        "fls_d9w3dn2yn7mo",
        "fls_1tftbd91yfpd"
      ],
      "position": 14744,
      "parent_fls_id": "fls_83182bfa9uqb",
      "sibling_fls_ids": [
        "fls_xa7lp0zg1ol2",
        "fls_wn1i6hzg2ff7",
        "fls_wjldgtio5o75",
        "fls_xlfo7di0gsqz"
      ]
    },
    {
      "fls_id": "fls_wjldgtio5o75",
      "title": "Macro Expansion",
      "level": 2,
      "file": "macros",
      "content": "Macro Expansion\n\nMacro expansion is the process of statically executing a\nmacro invocation and replacing it with the produced output of the\nmacro invocation.\n\nMacro expansion of [declarative macro]s proceeds as follows:\n\n#. The :s:`TokenTree` of the macro invocation has all\n [outer block doc]s and [outer line doc]s contained within replaced\n by their equivalent attribute doc representation.\n\n#. The :s:`TokenTree` of the macro invocation is matched against the\n [macro rule]s of the resolved macro by considering individual\n [macro matcher]s. It is a static error if no macro matcher is\n satisfied.\n\n#. The macro transcriber of the satisfied macro rule produces its\n result, with all [metavariable indication]s resolved. It is a static\n error if the macro transcriber fails to produce its result.\n\n#. The macro invocation is replaced with the result of the\n macro transcriber. It is a static error if the result cannot be parsed\n according to the expected expansion syntax of the context where the\n macro invocation resides. The expected expansion syntax is as follows:\n\n #. If the macro invocation appears as part of an associated item,\n an item within an external block, or another\n macro invocation, the output is required to constitute zero or more\n [item]s.\n\n #. If the macro invocation appears as part of an\n expression-without-block, the output is required to constitute an\n expression.\n\n #. If the macro invocation appears as part of a\n pattern-without-range, the output is required to constitute a\n [pattern].\n\n #. If the macro invocation appears as part of a statement, the\n output is required to constitute zero or more [statement]s.\n\n #. If the macro invocation appears as part of a\n type specification without [bound]s, the output is required to\n constitute a type.\n\nMacro expansion of [function-like macro]s proceeds as follows:\n\n#. The :s:`TokenTree` of the macro invocation has all [outer block\n doc]s and [outer line doc]s contained within replaced by their\n equivalent attribute doc representation.\n\n#. The :s:`TokenTree` of the macro invocation is transformed into a\n corresponding proc_macro::TokenStream.\n\n#. The macro implementation function is called with the\n proc_macro::TokenStream as its sole argument. It is a static error\n if the macro implementation function call fails.\n\n#. The macro invocation is replaced with the returned\n proc_macro::TokenStream of the macro implementation function\n call. It is a static error if the result can not be parsed according\n to the expected expansion syntax of the context where the macro\n invocation resides. The expected expansion syntax is as follows:\n\n #. If the macro invocation appears as part of an associated item,\n an item within an external block, or another\n macro invocation, the output is required to constitute zero or more\n [item]s.\n\n #. If the macro invocation appears as part of an\n expression-without-block, the output is required to constitute an\n expression.\n\n #. If the macro invocation appears as part of a\n pattern-without-range, the output is required to constitute zero or\n more [pattern]s.\n\n #. If the macro invocation appears as part of a statement, the\n output is required to constitute zero or more [statement]s.\n\n #. If the macro invocation appears as part of a\n type specification without [bound]s, the output is required to\n constitute a type.\n\nMacro expansion of [derive macro]s proceeds as follows:\n\n#. The item subject to the derive macro has all\n [outer block doc]s and [outer line doc]s contained within replaced\n by their equivalent attribute doc representation.\n\n#. The item subject to the derive macro is transformed into a\n corresponding proc_macro::TokenStream without the\n invoking derive attribute as well as any preceding derive\n [attribute]s.\n\n#. The macro implementation function is called with the\n proc_macro::TokenStream as its sole argument. It is a static error\n if the macro implementation function call fails.\n\n#. The returned proc_macro::TokenStream of the\n macro implementation function call is appended to the enclosing\n block expression or module where the related :s:`EnumDeclaration`,\n :s:`StructDeclaration`, or :s:`UnionDeclaration` resides. It is a static\n error if the output proc_macro::TokenStream does not constitute zero\n or more [item]s.\n\nMacro expansion of [attribute macro]s proceeds as follows:\n\n#. The :s:`DelimitedTokenTree` of the invoking attribute macro is\n transformed into a corresponding proc_macro::TokenStream without\n the outer :s:`[Delimiter]s`. If no :s:`DelimitedTokenTree` is provided,\n and empty proc_macro::TokenStream is used. This\n proc_macro::TokenStream constitutes the first function parameter\n of the macro implementation function.\n\n#. The item subject to the attribute macro has all\n [outer block doc]s and [outer line doc]s contained within replaced\n by their equivalent attribute doc representation.\n\n#. The item subject to the attribute macro is transformed into a\n corresponding proc_macro::TokenStream without the invoking\n attribute. This proc_macro::TokenStream constitutes the second\n function parameter of the macro implementation function.\n\n#. The macro implementation function is called with the two\n [proc_macro::TokenStream]s as the two arguments. It is a static error\n if the macro implementation function call fails.\n\n#. The item subject to the attribute macro is replaced with the\n returned proc_macro::TokenStream of the\n macro implementation function call. It is a static error if the output\n proc_macro::TokenStream does not constitute zero or more [item]s.",
      "paragraph_ids": [
        "fls_xscdaxvs4wx4",
        "fls_nz5stwcc41gk",
        "fls_40xq8Ri1OMZZ",
        "fls_76prdp6k1fga",
        "fls_76u274l4kew8",
        "fls_lakpily1zwfl",
        "fls_y20pmwo3v3uu",
        "fls_nsh2vwx8oiw",
        "fls_tu6kmwm4v9nj",
        "fls_3zn4dz19nyvq",
        "fls_t89sw6az99z7",
        "fls_417hvhvj2554",
        "fls_nNrs4EC3ff5T",
        "fls_srtqkdceaz5t",
        "fls_mi92etjtpamu",
        "fls_n8beqlt54rhy",
        "fls_vd3dzvr6re19",
        "fls_l8j2jiuuao4f",
        "fls_xvemyqj5gc6g",
        "fls_stseor6tln22",
        "fls_u11o90szy68s",
        "fls_qi5kyvj1e8th",
        "fls_vqIZaEl4EKu5",
        "fls_grtiwf7q8jah",
        "fls_tbe2qq7whq10",
        "fls_my93neopj9x0",
        "fls_zat7kwi5vc5c",
        "fls_tjn92evtlflq",
        "fls_AJmPrhHfZo6J",
        "fls_mpgh22bi8caz",
        "fls_ul7nhfyvyzh",
        "fls_z6xfhf71w10a"
      ],
      "position": 16692,
      "parent_fls_id": "fls_83182bfa9uqb",
      "sibling_fls_ids": [
        "fls_xa7lp0zg1ol2",
        "fls_wn1i6hzg2ff7",
        "fls_vnvt40pa48n8",
        "fls_xlfo7di0gsqz"
      ]
    },
    {
      "fls_id": "fls_4apk1exafxii",
      "title": "Macro Matching",
      "level": 3,
      "file": "macros",
      "content": "Macro Matching\n\nMacro matching is the process of performing rule matching and\ntoken matching.",
      "paragraph_ids": [
        "fls_ZmQZ8HQWv77L"
      ],
      "position": 24037,
      "parent_fls_id": "fls_wjldgtio5o75",
      "sibling_fls_ids": [
        "fls_ym00b6ewf4n3"
      ]
    },
    {
      "fls_id": "fls_n3ktmjqf87qb",
      "title": "Rule Matching",
      "level": 4,
      "file": "macros",
      "content": "Rule Matching\n\nRule matching is the process of consuming a :s:`TokenTree` in an attempt\nto fully satisfy the macro matcher of a macro rule that belongs to a\nresolved declarative macro.\n\nRule matching proceeds as follows:\n\n#. The [macro matcher]s of all [macro rule]s that belong to a resolved\n macro are tried against the :s:`TokenTree` of the macro invocation,\n in declarative order. In the event of a static error, no further attempts at\n selecting a subsequent macro matcher are made.\n\n#. The macro match of a candidate macro matcher is tried against\n the :s:`TokenTree` of the macro invocation by matching individual\n [token]s, in left-to-right order. Matching does not employ lookahead.\n It is a static error if matching a candidate macro matcher is ambiguous.\n Matching does not employ backtracking. It is a static error if matching a\n candidate macro matcher fails while parsing into a metavariable and\n having consumed at least one token while parsing the metavariable.\n\n#. It is a static error if no macro matcher is selected.",
      "paragraph_ids": [
        "fls_77ucvwu6idms",
        "fls_6h1jqhxzku5v",
        "fls_r6i1ykrhb49j",
        "fls_3qzes4lr8yuv",
        "fls_r878ysvsy4jb"
      ],
      "position": 24236,
      "parent_fls_id": "fls_4apk1exafxii",
      "sibling_fls_ids": [
        "fls_qpx6lgapce57"
      ]
    },
    {
      "fls_id": "fls_qpx6lgapce57",
      "title": "Token Matching",
      "level": 4,
      "file": "macros",
      "content": "Token Matching\n\nToken matching is the process of consuming a :s:`TokenTree` in an attempt\nto fully satisfy a macro match of a selected macro matcher that\nbelongs to a resolved declarative macro.\n\nToken matching proceeds as follows:\n\nThe outer :s:`[Delimiter]s` of a macro matcher match any outer\n:s:`[Delimiter]s` in the macro invocation.\n\nA metavariable in a macro matcher is matched against a sequence of\n[token]s in the macro invocation based on its fragment specifier:\n\n* Fragment specifier **block** requires a block expression.\n\n* Fragment specifier **expr** and **expr_2021** requires an expression that is not an underscore expression or const block expression.\n\n* Fragment specifier **ident** requires a pure identifier.\n\n* Fragment specifier **item** requires an item.\n\n* Fragment specifier **lifetime** requires character sequence 0x27\n 0x5F (apostrophe, low line), or character 0x27 (apostrophe) followed by an\n identifier.\n\n* Fragment specifier **literal** requires optional character 0x2D\n (hyphen-minus), followed by a literal expression.\n\n* Fragment specifier **meta** requires an attribute content.\n\n* Fragment specifier **pat** requires a pattern.\n\n* Fragment specifier **pat_param** requires a\n pattern-without-alternation.\n\n* Fragment specifier **path** requires a type path.\n\n* Fragment specifier **stmt** requires a statement without trailing\n character 0x3B (semicolon), excluding [item]s that require character\n 0x3B (semicolon).\n\n* Fragment specifier **tt** requires a :s:`TokenTree`.\n\n* Fragment specifier **ty** requires a type specification.\n\n* Fragment specifier **vis** requires a possibly empty visibility modifier.\n\nOnce a metavariable is matched, the matching sequence of [token]s is\nbound to that metavariable.\n\nRepetition in a macro matcher is matched based on how many times the\npattern appears consecutively optionally separated by a separator in\nthe :s:`TokenTree` of the macro invocation, as follows:\n\n* If the repeated pattern includes a separator, then the\n separator must be able to follow the repeated pattern.\n\n* If the repeated pattern can appear multiple times, then the repeated\n pattern must be able to follow itself.\n\n* If the repeated pattern can appear zero times, then the preceding\n pattern must be able to follow the succeeding pattern.\n\n* The repeated pattern must be able to follow the preceding pattern.\n\n* The succeeding pattern must be able to follow the repeated pattern.\n\nA repetition index is a monotonically increasing number that is\ninitialized to zero, and incremented by one.\n\nOnce a metavariable is matched, the matching sequence of [token]s is\ntreated as follows:\n\n#. The matching sequence of [token]s is stored in an ordered collection at\n the current repetition index.\n\n#. The current repetition index is incremented by one.\n\nEach matched metavariable in a macro repetition in matching is bound\nseparately, where the matches are stored in an ordered collection.\n\nAny other token in a macro matcher is matched literally against the\n:s:`TokenTree` of the macro invocation.\n\nIt is a static error if the :s:`TokenTree` of the macro invocation contains\nleftover [token]s after macro matching.",
      "paragraph_ids": [
        "fls_k6a24sbon5v9",
        "fls_6uuxv91xgmfz",
        "fls_g1rml9tavh8v",
        "fls_h7x3tc208zpk",
        "fls_p9eqa17d3dx",
        "fls_k00bck2k8tde",
        "fls_pf0qrz5nadl2",
        "fls_9fioah171ojx",
        "fls_j2o0f52zyvyb",
        "fls_w5dzv3z4zd5a",
        "fls_wtol98rrqka5",
        "fls_iorqt9q4ie9j",
        "fls_2zjed913qpvi",
        "fls_3zdts0fsa36u",
        "fls_mb3yr1j7npv5",
        "fls_xbuixjt9pum6",
        "fls_6annifhk6cd8",
        "fls_2zu22efr6ncy",
        "fls_dqroklsaayzb",
        "fls_ghqjk6xj85ng",
        "fls_lzwl4en5wcw0",
        "fls_cz44evkjzv29",
        "fls_o2exsai4m0gy",
        "fls_1ch299zp8h7",
        "fls_55ptfjlvoo8o",
        "fls_finzfb5ljkf8",
        "fls_s1ccs6jocsgr",
        "fls_wpi2i6hoj3li",
        "fls_uuey421a8n96",
        "fls_b5u47tuu136r",
        "fls_rb1tu4e7dpma",
        "fls_c76sdvos5xeo"
      ],
      "position": 25580,
      "parent_fls_id": "fls_4apk1exafxii",
      "sibling_fls_ids": [
        "fls_n3ktmjqf87qb"
      ]
    },
    {
      "fls_id": "fls_ym00b6ewf4n3",
      "title": "Macro Transcription",
      "level": 3,
      "file": "macros",
      "content": "Macro Transcription\n\nMacro transcription is the process of producing the expansion of a\ndeclarative macro.\n\nMacro transcription proceeds as follows:\n\nEvery metavariable indication found in the :s:`DelimitedTokenTree` of the\nmacro transcriber that belongs to a matched macro rule is replaced by\nthe matched sequence of [token]s of the metavariable.\n\nUnresolved [metavariable indication]s are kept as [token]s in the\noutput verbatim.\n\nEvery macro repetition in transcription found in the\n:s:`DelimitedTokenTree` of the macro transcriber shall be transcribed by\nrepeatedly transcribing the [token]s inside of it.\n\nThe number of transcription repetitions for a\nmacro repetition in transcription shall depend on its\nrepetition operator, as follows:\n\n* A repetition operator denoted by + shall require one or more\n repetitions.\n\n* A repetition operator denoted by * shall require zero or more\n repetitions.\n\n* A repetition operator denoted by ? shall require zero or one\n repetition.\n\nA metavariable indication that is matched inside of a\nmacro repetition shall not be used outside of a\nmacro repetition in transcription.\n\nA metavariable indication shall be used in a\nmacro repetition in transcription of the same nesting depth as its\ncorresponding metavariable appears in the macro matcher.\n\nA metavariable indication within a macro repetition in transcription\nshall repeat the same number of times in its matching macro repetition if\nthe macro repetition occurs at the same nesting depth.\n\nMultiple transcribed [metavariable indication]s in the same macro\nrepetition in transcription shall repeat the same number of times.\n\nWhen transcribing a metavariable indication in a\nmacro repetition in transcription, the metavariable indication is\nreplaced with the matched sequence of [token]s of the corresponding\niteration of the repetition metavariable taken from the ordered collection.\n\nA metavariable indication in a macro repetition in transcription shall\nbe transcribed to the matched [token]s in order, as follows:\n\nyields 0;1;2;\n\nGiven a macro invocation with N metavariable arguments, a\nmacro of the form\n\nis equivalent to a macro of the form\n\nwhere the metavariable of the macro repetition in matching are\nrepeated N times, and the [metavariable indication]s of the\nmacro repetition in transcription are repeated N times. Invoking such\na macro relates the first metavariable argument of the\nmacro invocation with the first metavariable of the\nmacro repetition in matching, the second metavariable argument with\nthe second metavariable, and so on.",
      "paragraph_ids": [
        "fls_y21i8062mft0",
        "fls_n2dx4ug5nd5w",
        "fls_iw7322ycvhkc",
        "fls_jgitbqmyixem",
        "fls_ihcwl6taptas",
        "fls_g3dtpw4rtgdr",
        "fls_pvp6dxykuv66",
        "fls_bd673n5awwbz",
        "fls_zbtwrtcy7pzf",
        "fls_eacyb6jap9ru",
        "fls_y4podc7ee8lf",
        "fls_wbys0m4a1omg",
        "fls_g445ovedgo4q",
        "fls_ctzthi6keit2",
        "fls_9n46ugmcqmix",
        "fls_JinrPA0pMZCr",
        "fls_95rn4cvgznmd",
        "fls_yg4c9x7049y4",
        "fls_o9rwz9z0a2h4"
      ],
      "position": 29970,
      "parent_fls_id": "fls_wjldgtio5o75",
      "sibling_fls_ids": [
        "fls_4apk1exafxii"
      ]
    },
    {
      "fls_id": "fls_xlfo7di0gsqz",
      "title": "Hygiene",
      "level": 2,
      "file": "macros",
      "content": "Hygiene\n\nHygiene is a property of [macro]s and [identifier]s that appear\nwithin them, which aims to eliminate the syntactic interference between a\nmacro and its environment.\n\nHygiene is categorized as follows:\n\n* Definition site hygiene, which resolves to a :s:`MacroRulesDeclaration`\n site. [Identifier]s with definition site hygiene cannot reference\n the environment of the :s:`MacroRulesDeclaration`, cannot be referenced by the\n environment of a :s:`MacroInvocation`, and are considered hygienic.\n\n* Call site hygiene, which resolves to a :s:`MacroInvocation` site.\n [Identifier]s with call site hygiene can reference the environment\n of the :s:`MacroRulesDeclaration`, can reference the environment of the\n :s:`MacroInvocation`, and are considered unhygienic.\n\n* Mixed site hygiene, which resolves to a :s:`MacroRulesDeclaration`\n site for [label]s, [variable]s, and the $crate\n metavariable, and to the :s:`MacroInvocation` site otherwise, and is\n considered partially hygienic.\n\nEvery macro has associated hygiene that depends on its kind:\n\n* [Declarative macro]s have mixed site hygiene.\n\n* [Procedural macro]s have call site hygiene and\n mixed site hygiene depending on the implementation of the\n procedural macro.\n\nThe metavariable $crate in a declarative macro's expansion refers\nto the crate the declarative macro was declared in.",
      "paragraph_ids": [
        "fls_7ezc7ncs678f",
        "fls_3axjf28xb1nt",
        "fls_dz2mvodl818d",
        "fls_puqhytfzfsg6",
        "fls_uyvnq88y9gk3",
        "fls_yxqcr19dig18",
        "fls_kx25olky1jov",
        "fls_v46v0t2vh6x4",
        "fls_7eqqk2cj0clr"
      ],
      "position": 33869,
      "parent_fls_id": "fls_83182bfa9uqb",
      "sibling_fls_ids": [
        "fls_xa7lp0zg1ol2",
        "fls_wn1i6hzg2ff7",
        "fls_vnvt40pa48n8",
        "fls_wjldgtio5o75"
      ]
    },
    {
      "fls_id": "fls_ronnwodjjjsh",
      "title": "Ownership and Destruction",
      "level": 1,
      "file": "ownership-and-deconstruction",
      "content": "Ownership and Destruction",
      "paragraph_ids": [],
      "position": 125,
      "parent_fls_id": null,
      "sibling_fls_ids": [
        "fls_l21tjqjkkaa0",
        "fls_gvwd0kf72jt",
        "fls_3v733mnewssy",
        "fls_gdeyap4or1db",
        "fls_dzq9cdz4ibsz",
        "fls_ckvjj4tt1hh2",
        "fls_osd6c4utyjb3",
        "fls_qcb1n9c0e5hz",
        "fls_48qldfwwh493",
        "fls_y2k5paj8m8ug",
        "fls_fk2m2irwpeof",
        "fls_z1il3w9nulzy",
        "fls_wb86edg02t6a",
        "fls_411up5z0b6n6",
        "fls_83182bfa9uqb",
        "fls_xgqh0ju6bmbn",
        "fls_hdwwrsyunir",
        "fls_wdicg3sqa98e",
        "fls_vgb6ev541b2r",
        "fls_EBwqH60SUHiN",
        "fls_jep7p27kaqlp",
        "fls_94a8v54bufn8"
      ]
    },
    {
      "fls_id": "fls_svkx6szhr472",
      "title": "Ownership",
      "level": 2,
      "file": "ownership-and-deconstruction",
      "content": "Ownership\n\nOwnership is a property of [value]s that is central to the resource\nmanagement model of Rust.\n\nAn owner is a variable that holds a value.\n\nA value shall have only one owner.",
      "paragraph_ids": [
        "fls_wt81sbsecmu0",
        "fls_ckcnkbb6y3cq",
        "fls_ze0u9gfylmhn"
      ],
      "position": 201,
      "parent_fls_id": "fls_ronnwodjjjsh",
      "sibling_fls_ids": [
        "fls_3xvm61x0t251",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_77scxuomlbgs",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_afafmafz4hf2"
      ]
    },
    {
      "fls_id": "fls_3xvm61x0t251",
      "title": "Initialization",
      "level": 2,
      "file": "ownership-and-deconstruction",
      "content": "Initialization\n\nInitialization is the act of supplying an initial value to a\nvariable.\n\nWhen a variable holds a value, the variable is considered to be\ninitialized.\n\nWhen a variable lacks a value or its value has been\npassed <passing convention> by move, the variable is considered\nto be uninitialized.\n\nA variable shall be initialized before it is accessed.\n\nAll memory starts as uninitialized.\n\nVariable a is initialized.\n\nVariable b starts off as uninitialized, but is later initialized by virtue\nof the assignment statement.\n\nVariable c starts off initialized, but is later uninitialized by virtue of a\ntransfer by move.",
      "paragraph_ids": [
        "fls_drfzu02bo7oe",
        "fls_wnhci8phdu4m",
        "fls_ch2lvm50olqd",
        "fls_46910buiwvv9",
        "fls_caufcwkpz689",
        "fls_4lg92b9yima6",
        "fls_xn1au0blioa3",
        "fls_jmcjboopvytb"
      ],
      "position": 552,
      "parent_fls_id": "fls_ronnwodjjjsh",
      "sibling_fls_ids": [
        "fls_svkx6szhr472",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_77scxuomlbgs",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_afafmafz4hf2"
      ]
    },
    {
      "fls_id": "fls_v5x85lt5ulva",
      "title": "References",
      "level": 2,
      "file": "ownership-and-deconstruction",
      "content": "References\n\nA reference is a value of a reference type. A reference\ncan be obtained explicitly by using a borrow expression or implicitly in\ncertain scenarios.\n\nA referent is the value pointed-to by a reference.\n\nA reference shall point to an initialized referent.\n\nThe lifetime of a referent shall be at least as long as the\nlifetime of its reference.\n\nA reference is active from the point of obtaining its referent\nupto the last use of the reference, prior to another assignment to the\nreference or the end of the scope of the reference.\n\nA referent shall not be passed <passing convention> by move while\na reference to it is active.\n\nA referent shall not be modified while a reference to it is\nactive.\n\nAn immutable reference is a value of a shared reference type, and\nprevents the mutation of its referent.\n\nA mutable reference is a value of a mutable reference type, and\nallows the mutation of its referent.\n\nThe referent of an immutable reference shall be mutated only when the\ntype of the referent is subject to interior mutability.\n\nWhile a mutable reference is active, no other reference shall\nrefer to a value that [overlap]s with the referent of the\nmutable reference.\n\nIt is undefined behavior to access a value through aliasing\n[mutable reference]s from unsafe context.",
      "paragraph_ids": [
        "fls_7x9pi2o7pee7",
        "fls_tsqvr3fmcel",
        "fls_ev4a82fdhwr8",
        "fls_cckf6dtkgwb4",
        "fls_8kqb8754e6p4",
        "fls_v69rptdjao42",
        "fls_vg9h6tz6z37w",
        "fls_wcf5mxrzbujn",
        "fls_fckoj1jh5mrc",
        "fls_hqxsuyn285he",
        "fls_i1ny0k726a4a",
        "fls_eT1hnLOx6vxk"
      ],
      "position": 1801,
      "parent_fls_id": "fls_ronnwodjjjsh",
      "sibling_fls_ids": [
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_a14slch83hzn",
        "fls_77scxuomlbgs",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_afafmafz4hf2"
      ]
    },
    {
      "fls_id": "fls_a14slch83hzn",
      "title": "Borrowing",
      "level": 2,
      "file": "ownership-and-deconstruction",
      "content": "Borrowing\n\nBorrowing is the process of temporarily associating a reference with a\nvalue without transferring ownership permanently.\n\nA borrow is a reference produced by borrowing.\n\nAn implicit borrow is a borrow that is not present syntactically in\nprogram text. An implicit borrow occurs in the following contexts:\n\n* The call operand of a call expression,\n\n* The [operand]s of a comparison expression,\n\n* The assigned operand of a compound assignment expression,\n\n* The operand of a field access expression,\n\n* The operand of a dereference expression,\n\n* The indexed operand of an index expression,\n\n* The receiver operand of a method call expression.\n\n`\nAn implicit borrow may be an immutable borrow or a mutable borrow\nif required.\n\nAn immutable borrow is an immutable reference produced by\nborrowing.\n\nA mutable borrow is a mutable reference produced by borrowing.\n\nBorrowing a field of a union type borrows all remaining\n[field]s using the same lifetime.\n\nImmutably borrowing a value proceeds as follows:\n\n#. An immutable borrow of type &'a T is created, where\n lifetime 'a is replaced by a lifetime variable, and\n T is replaced by the borrowed type.\n\n#. Lifetime inference is performed.\n\n#. The immutable borrow is checked against other [borrow]s and\n by move passing within the enclosing item.\n\n#. An immutable reference to the borrowed value is produced.\n\n#. The immutable borrow is released immediately after the last usage of its\n related immutable reference.\n\nMutably borrowing a value proceeds as follows:\n\n#. A mutable borrow of type &'a mut T is created, where\n lifetime 'a is replaced by a lifetime variable, and\n T is replaced by the borrowed type.\n\n#. Lifetime inference is performed.\n\n#. The mutable borrow is checked against other [borrow]s and\n by move passing within the enclosing item.\n\n#. A mutable reference to the borrowed value is produced.\n\n#. The mutable borrow is released immediately after the last usage of its\n related mutable reference.",
      "paragraph_ids": [
        "fls_c02flohk54pc",
        "fls_j9kof0px3l7s",
        "fls_zepwytjwy049",
        "fls_nordokzfy36d",
        "fls_bjf3futso849",
        "fls_yfmy4v5zlgw9",
        "fls_jv18y618j2s3",
        "fls_g4i0jb27iryr",
        "fls_kky9ufexrvaw",
        "fls_o5oq4jfswr4q",
        "fls_MT69AGRXH9pS",
        "fls_hyl4bdjbuzbw",
        "fls_pu19i4sj6yg0",
        "fls_kxws4zmaahj6",
        "fls_kup2ou22nwyl",
        "fls_8q5ly4x104ai",
        "fls_yhchu2bpil4m",
        "fls_568o7nyihndd",
        "fls_Z2n7EJiLY5CT",
        "fls_ibi9mqGeHNLp",
        "fls_f9we73i8vwq3",
        "fls_w5bjgaov8w60",
        "fls_gbqizu6gu6kk",
        "fls_ovkkxeybumvt",
        "fls_7Kzu0qXiBUCb",
        "fls_VDHBP4oAoqT5"
      ],
      "position": 3851,
      "parent_fls_id": "fls_ronnwodjjjsh",
      "sibling_fls_ids": [
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_v5x85lt5ulva",
        "fls_77scxuomlbgs",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_afafmafz4hf2"
      ]
    },
    {
      "fls_id": "fls_77scxuomlbgs",
      "title": "Passing Conventions",
      "level": 2,
      "file": "ownership-and-deconstruction",
      "content": "Passing Conventions\n\nA passing convention is the mechanism that defines how a value is\ntransferred between [place]s.\n\nA copy type is a type that implements the core::marker::Copy\ntrait.\n\nA value of a copy type is passed <passing convention>\nby copy. Passing by copy does not change the owner of the\nvalue.\n\nA move type is a type that implements the core::marker::Sized\ntrait and is not a copy type.\n\nA value of a move type is passed <passing convention>\nby move. Passing by move changes the owner of the value.\n\nA value of a place expression shall be\npassed <passing convention> by move only when it denotes:\n\n* A field of a place expression that can be\n passed <passing convention> by move and whose type does not\n implement the core::ops::Drop trait, or\n\n* A temporary, or\n\n* A variable which is not currently borrowed.\n\nA value of a value expression is always\npassed <passing convention> by move.\n\nA value not subject to by copy or by move passing convention\nshall not be passed <passing convention> between [place]s.\n\nPassing a value by copy from a source owner to a target\nowner proceeds as follows:\n\n#. The value of the source owner is copied.\n\n#. The copy is assigned to the target owner.\n\nPassing a value by move from a source owner to a target\nowner proceeds as follows:\n\n#. The value is unassigned from the source owner.\n\n#. The value is assigned to the target owner.\n\nType i32 is a copy type. By the end of the second let statement, x is\nthe owner of the original 42 and y is the owner of a cloned 42.\n\nType core::sync::atomic::AtomicI32 is a move type. By the end of the\nsecond let statement, x is uninitialized and y is the sole owner of the\natomic 42.",
      "paragraph_ids": [
        "fls_fvwx2ufeyzcs",
        "fls_h2pgsij1rbms",
        "fls_yx2knbby70fy",
        "fls_6ul3f6v0foma",
        "fls_3ztdz02efeoc",
        "fls_konzgoybhfqm",
        "fls_4bnbv7mqod57",
        "fls_3xk3p1unbjy5",
        "fls_vk1xhvdaakh0",
        "fls_vveEJn7lngT8",
        "fls_gq35gqagw35",
        "fls_cfqzpmnfeh8h",
        "fls_go9gdlk5d3km",
        "fls_459xx6febmf0",
        "fls_3xyq50abdiv6",
        "fls_7kcx3u8gvl1d",
        "fls_i4hrifsb9msr",
        "fls_7tadh1zel0fc",
        "fls_ywt328hcieka"
      ],
      "position": 7014,
      "parent_fls_id": "fls_ronnwodjjjsh",
      "sibling_fls_ids": [
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_afafmafz4hf2"
      ]
    },
    {
      "fls_id": "fls_4jiw35pan7vn",
      "title": "Destruction",
      "level": 2,
      "file": "ownership-and-deconstruction",
      "content": "Destruction\n\nDestruction is the process of recovering resources associated with a\nvalue as it goes out of scope.",
      "paragraph_ids": [
        "fls_e7ucq87s806d"
      ],
      "position": 9824,
      "parent_fls_id": "fls_ronnwodjjjsh",
      "sibling_fls_ids": [
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_77scxuomlbgs",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj",
        "fls_afafmafz4hf2"
      ]
    },
    {
      "fls_id": "fls_u2mzjgiwbkz0",
      "title": "Destructors",
      "level": 2,
      "file": "ownership-and-deconstruction",
      "content": "Destructors\n\nA drop type is a type that implements the core::ops::Drop\ntrait or contains a field that has a drop type.\n\nA destructor is a function that is invoked immediately before the\ndestruction of a value of a drop type.\n\nDropping a value is the act of invoking the destructor of the\nrelated type. Such an object is said to be dropped.\n\nAn uninitialized variable is not dropped.\n\nDropping an initialized variable proceeds as follows:\n\n#. If the drop type implements the core::ops::Drop trait, then\n core::ops::Drop::drop of the drop type is invoked.\n\n#. If the drop type is an array type, then its elements are\n dropped from the first element to the last element.\n\n#. Otherwise, if the drop type is a closure type, then all\n [capture target]s whose capture mode is by move are\n dropped in unspecified order.\n\n#. Otherwise, if the drop type is an enum type, then the [field]s\n of the active enum variant are dropped in declaration order.\n\n#. Otherwise, if the drop type is a slice type, then its elements are\n dropped from the first element to the last element.\n\n#. Otherwise, if the drop type is a struct type, then its\n [field]s are dropped in declaration order.\n\n#. Otherwise, if the drop type is a trait object type, then the\n destructor of the underlying type is invoked.\n\n#. Otherwise, if the drop type is a tuple type, then its [field]s\n are dropped in declaration order.\n\n#. Otherwise, dropping has no effect.\n\nWhen object array is dropped, its destructor drops the first element, then\nthe second element.\n\nObject uninitialized is not dropped.",
      "paragraph_ids": [
        "fls_9m0gszdle0qb",
        "fls_4nkzidytpi6",
        "fls_wzuwapjqtyyy",
        "fls_gfvm70iqu1l4",
        "fls_l2xkdjeydqtx",
        "fls_bync24y6gp93",
        "fls_jzancf72i95f",
        "fls_gjn2jnsal9gs",
        "fls_ol2w2292frfi",
        "fls_6ii5o68vuymj",
        "fls_sup43es8ps8r",
        "fls_y9q0eqr865b3",
        "fls_kdqng6eovxns",
        "fls_ag249y74jg6c",
        "fls_tw36n3g32a0y",
        "fls_fmn33zhorkf"
      ],
      "position": 10034,
      "parent_fls_id": "fls_ronnwodjjjsh",
      "sibling_fls_ids": [
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_77scxuomlbgs",
        "fls_4jiw35pan7vn",
        "fls_rm4ncoopcdvj",
        "fls_afafmafz4hf2"
      ]
    },
    {
      "fls_id": "fls_rm4ncoopcdvj",
      "title": "Drop Scopes",
      "level": 2,
      "file": "ownership-and-deconstruction",
      "content": "Drop Scopes\n\nA drop scope is a region of program text that governs the dropping of\n[value]s. When control flow leaves a drop scope, all [value]s\nassociated with that drop scope are dropped based on a\ndrop order.\n\nA drop construct is a construct that employs a drop scope. The\nfollowing [construct]s are [drop construct]s:\n\n* [Expression]s,\n\n* [Function]s,\n\n* A match arm of a match expression,\n\n* [Statement]s.\n\n[Drop scope]s are nested within one another as follows:\n\n* The drop scope of a function is the outermost drop scope.\n\n* The parent drop scope of a function body is the drop scope of\n its related function.\n\n* The parent drop scope of an operand in an expression statement\n is the drop scope of the expression statement.\n\n* The parent drop scope of the expression of a let statement is\n the drop scope of the let statement.\n\n* The parent drop scope of a statement is the drop scope of the\n block expression that contains the statement.\n\n* The parent drop scope of the operand of a match arm guard is\n the drop scope of the match arm that contains the\n match arm guard.\n\n* The parent drop scope of the operand of a match arm is the\n drop scope of the match arm that contains the operand.\n\n* The parent drop scope of a match arm is the drop scope of the\n related match expression.\n\n* The parent drop scope of all other [drop scope]s is the\n drop scope of the immediately enclosing expression.\n\nA binding declared in a for loop expression is associated with\nthe drop scope of the block expression of the\nfor loop expression.\n\nA binding declared in an if let expression is associated with the\ndrop scope of the block expression of the if let expression.\n\nA binding declared in a let statement is associated with the\ndrop scope of the block expression that contains the\nlet statement.\n\nA binding declared in a match expression is associated with the\ndrop scope of the match arm of the match expression.\n\nA binding declared in a while let loop expression is associated with\nthe drop scope of the block expression of the\nwhile let loop expression.\n\nA value or binding of a function parameter is associated with the\ndrop scope of the function of the function parameter.\n\nA temporary that is not subject to constant promotion is associated\nwith the innermost drop scope that contains the expression which\nproduced the temporary, taking into account drop scope extension. The\npossible [drop scope]s are as follows:\n\n* The drop scope of a function body.\n\n* The drop scope of a statement.\n\n* The drop scope of a block expression of an if expression, an\n infinite loop expression, or a while loop expression.\n\n* The drop scope of an else expression.\n\n* The drop scope of the subject expression of an if expression.\n\n* The drop scope of the iteration expression of a\n while loop expression.\n\n* The drop scope of the operand of a match arm.\n\n* The drop scope of the operand of a match arm guard.\n\n* The drop scope of the right operand of a\n lazy boolean expression.",
      "paragraph_ids": [
        "fls_7uav7vkcv4pz",
        "fls_txvxrn6wbyql",
        "fls_n6y6brm6pghr",
        "fls_gdh6wwvi7ci6",
        "fls_owqk2fcpvc4s",
        "fls_ckh8wkq0y5ja",
        "fls_2zwwnzepgmje",
        "fls_vlbx5ukw5c8l",
        "fls_d5yg6w8gv6aq",
        "fls_qidma4fpkhb0",
        "fls_1o9ye6cwoyiq",
        "fls_16htxf824xbk",
        "fls_lbsfhg42yiqy",
        "fls_5m3u3k6f00bd",
        "fls_m86ljncnmo7j",
        "fls_bewcu5xceu8i",
        "fls_iHHhlxCiqNWZ",
        "fls_swXXkbZGLPKa",
        "fls_vrqgac634wpr",
        "fls_fnvr5w2wzxns",
        "fls_1vZFa5mDEbXW",
        "fls_3jtU8grRaMM9",
        "fls_8r39duatupxw",
        "fls_2peq1tihglnr",
        "fls_il09n7sq0a3k",
        "fls_s1wbqld139gz",
        "fls_asvuef2pc3m0",
        "fls_560437qmeqtr",
        "fls_8cunkfc6x24q",
        "fls_n108lvc4otoc",
        "fls_ptk6yibqyfzi",
        "fls_dltmd8e8c5ia"
      ],
      "position": 12797,
      "parent_fls_id": "fls_ronnwodjjjsh",
      "sibling_fls_ids": [
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_77scxuomlbgs",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_afafmafz4hf2"
      ]
    },
    {
      "fls_id": "fls_5eima0pd31c0",
      "title": "Drop Scope Extension",
      "level": 3,
      "file": "ownership-and-deconstruction",
      "content": "Drop Scope Extension\n\nDrop scope extension is the process of extending a drop scope\nassociated with a temporary to prevent the premature dropping of the\ntemporary.\n\nAn extending pattern is either\n\n* A reference identifier pattern, or\n\n* A slice pattern, a struct pattern, tuple pattern or a\n tuple struct pattern that contains at least one subpattern that is\n an extending pattern.\n\nIf the pattern-without-alternation of a let statement is an\nextending pattern, then the drop scope of the expression of\nthe let statement is extended to the drop scope of the\nblock expression that contains the let statement.\n\nAn extending expression is an expression with an\nextended drop scope <drop scope extension>.\n\nAn extending expression is any of the following:\n\n* The expression of a let statement.\n\n* The operand of an extending expression that is an\n array expression, a borrow expression, a struct expression, a\n tuple expression, or a type cast expression.\n\n* The block expression and else expression of an if expression\n that is an extending expression.\n\n* The expression of an else expression that is an extending\n expression.\n\n* The expression of a match arm of a match expression that is an\n extending expression.\n\n* The tail expression of a block expression that is an\n extending expression.\n\n* The [argument operand]s of a tuple struct call expression\n that is an extending expression.\n\nThe drop scope of the operand of a borrow expression that is an\nextending expression is extended to the drop scope of the\nblock expression that contains the let statement.\n\nThe drop scope of the operand of a borrow expression, a\ndereference expression, or a field access expression that has an\nextended drop scope is extended to the drop scope of the\nexpression.\n\nThe drop scope of the indexed operand of an index expression that\nhas an extended drop scope is extended to the drop scope of the\nexpression.\n\nSee :p:`fls_u2mzjgiwbkz0` for the declaration of PrintOnDrop.\n\nThe drop scope of the temporary created for expression AtomicI32::new(42) is\nextended to the drop scope of the block expression.",
      "paragraph_ids": [
        "fls_kflqez2mtbit",
        "fls_xjw82bujm148",
        "fls_965wt48ooqyw",
        "fls_r8nt0zp8dnyp",
        "fls_3ycn4u1fe9h",
        "fls_YeeZWqTdMivX",
        "fls_wyzau8hhq74d",
        "fls_ju7cpftd8r2g",
        "fls_gjd1ow3l7swe",
        "fls_Rj9zhVutfQod",
        "fls_oodpp3LpXC13",
        "fls_xGThCPoTUSAi",
        "fls_iqw0d1l1lj3i",
        "fls_eeaJtK4w5gVK",
        "fls_aq01wjpkxhq9",
        "fls_VDPi1dJzJMUb",
        "fls_elGH7HSawMRb",
        "fls_29y59x8bmw75",
        "fls_subo2w7ln43q"
      ],
      "position": 17239,
      "parent_fls_id": "fls_rm4ncoopcdvj",
      "sibling_fls_ids": []
    },
    {
      "fls_id": "fls_afafmafz4hf2",
      "title": "Drop Order",
      "level": 2,
      "file": "ownership-and-deconstruction",
      "content": "Drop Order\n\nDrop order is the order by which [value]s are dropped when a\ndrop scope is left.\n\nWhen a drop scope is left, all [value]s associated with that\ndrop scope are dropped as follows:\n\n* [Binding]s are dropped in reverse declaration order.\n\n* Temporaries <temporary> are dropped in reverse creation order.\n\nWhen a drop scope of a function is left, then each\nfunction parameter is dropped from right to left as follows:\n\n#. All [binding]s introduced by the pattern of the\n function parameter are dropped in reverse declaration order,\n\n#. The value of the function parameter is dropped.\n\nWhen multiple [drop scope]s are left at once, the [value]s are\ndropped from the innermost drop scope to the outermost\ndrop scope.\n\nSee :p:`fls_u2mzjgiwbkz0` for the declaration of PrintOnDrop.\n\nThe drop order of the following variables is b, c, a. Dropping\nproceeds as follows:\n\n#. The scope of the block expression is left first because it is an inner scope.\n\n#. b is dropped.\n\n#. The outer scope is left.\n\n#. c is dropped because dropping occurs in reverse declarative order.\n\n#. a is dropped.",
      "paragraph_ids": [
        "fls_n6o1xzjiz8cv",
        "fls_jwofws3022ar",
        "fls_g07zq3n55094",
        "fls_a5tmilqxdb6f",
        "fls_zQGkVGWIzMQ7",
        "fls_K8whhUwAUVqR",
        "fls_NpCrm4t03oQg",
        "fls_3i348l3pbtrx",
        "fls_oe8l81y0wnao",
        "fls_4sgca9wcl8h0",
        "fls_a2m4ibzhgupa",
        "fls_go3bvd23vzi9",
        "fls_7rwo0he8x143",
        "fls_43yqlxjr3a10",
        "fls_a7lsq2kkzkk4"
      ],
      "position": 20400,
      "parent_fls_id": "fls_ronnwodjjjsh",
      "sibling_fls_ids": [
        "fls_svkx6szhr472",
        "fls_3xvm61x0t251",
        "fls_v5x85lt5ulva",
        "fls_a14slch83hzn",
        "fls_77scxuomlbgs",
        "fls_4jiw35pan7vn",
        "fls_u2mzjgiwbkz0",
        "fls_rm4ncoopcdvj"
      ]
    },
    {
      "fls_id": "fls_xgqh0ju6bmbn",
      "title": "Patterns",
      "level": 1,
      "file": "patterns",
      "content": "Patterns\n\n PatternList ::=\n Pattern ($$,$$ Pattern)* $$,$$?\n\n PatternWithoutAlternation ::=\n PatternWithoutRange\n | RangePattern\n\n PatternWithoutRange ::=\n IdentifierPattern\n | LiteralPattern\n | MacroInvocation\n | ParenthesizedPattern\n | PathPattern\n | ReferencePattern\n | RestPattern\n | SlicePattern\n | StructPattern\n | TuplePattern\n | UnderscorePattern\n\nA pattern is a construct that matches a value which satisfies all\nthe criteria of the pattern.\n\nA pattern-without-alternation is a pattern that cannot be alternated.\n\nA pattern-without-range is a pattern-without-alternation that\nexcludes [range pattern]s.\n\nA subpattern is a pattern nested within another pattern.\n\nA pattern has a type, with the exception of the rest pattern if\nit is not the inner pattern of a slice pattern or the pattern of\na possibly nested identifier pattern of a slice pattern\\ .\n\nThe expected type of a pattern is the type the pattern is being matched against.\n\nIt is a static error when [lexical element]s match multiple alternations\nof a pattern-without-range, except for when the pattern is &mut\n:s:`Identifier`. Such a pattern is interpreted as a reference pattern\nwith keyword mut containing an identifier pattern.\n\nAny two [pattern-without-alternation]s that are or-ed using character 0x7C\n(vertical line) are subject to the following restrictions:\n\n* The [type]s of the two [pattern-without-alternation]s shall be\n unifiable.\n\n* The [binding]s of the two [pattern-without-alternation]s shall\n be the same, shall have [unifiable type]s, and shall have the same\n [binding mode]s.",
      "paragraph_ids": [
        "fls_imegtsi224ts",
        "fls_mp6i4blzexnu",
        "fls_JJ1fJa1SsaWh",
        "fls_6xx34zr069bj",
        "fls_8xzjb0yzftkd",
        "fls_cma5t8waon0x",
        "fls_TUanRT7WU14E",
        "fls_8luyomzppck",
        "fls_rpvdfmy3n05a",
        "fls_kv533rntni1x"
      ],
      "position": 125,
      "parent_fls_id": null,
      "sibling_fls_ids": [
        "fls_l21tjqjkkaa0",
        "fls_gvwd0kf72jt",
        "fls_3v733mnewssy",
        "fls_gdeyap4or1db",
        "fls_dzq9cdz4ibsz",
        "fls_ckvjj4tt1hh2",
        "fls_osd6c4utyjb3",
        "fls_qcb1n9c0e5hz",
        "fls_48qldfwwh493",
        "fls_y2k5paj8m8ug",
        "fls_fk2m2irwpeof",
        "fls_z1il3w9nulzy",
        "fls_wb86edg02t6a",
        "fls_411up5z0b6n6",
        "fls_83182bfa9uqb",
        "fls_ronnwodjjjsh",
        "fls_hdwwrsyunir",
        "fls_wdicg3sqa98e",
        "fls_vgb6ev541b2r",
        "fls_EBwqH60SUHiN",
        "fls_jep7p27kaqlp",
        "fls_94a8v54bufn8"
      ]
    },
    {
      "fls_id": "fls_uh76pw6ykd57",
      "title": "Refutability",
      "level": 2,
      "file": "patterns",
      "content": "Refutability\n\nRefutability is a property of [pattern]s that expresses the ability to\nmatch all possible values of a type.\n\nAn irrefutable pattern is a pattern that always matches any value of its type.\n\nA refutable pattern is a pattern that has a possibility of not\nmatching a value of its type\n\nA pattern that is not an irrefutable pattern is a\nrefutable pattern.\n\nAn irrefutable constant is a constant of a type that has at most\none value.\n\nA refutable constant is a constant of a refutable type.\n\nx is an irrefutable pattern because it matches all possible values of type i32.\n\ncore::option::Option::Some(y) is a refutable pattern because it does not match value when\nvalue denotes core::option::Option::None.",
      "paragraph_ids": [
        "fls_9ntc4qmjmo90",
        "fls_9fjspnefoyvz",
        "fls_uq7ftuuq1sig",
        "fls_mnbyt7jfYAZ9",
        "fls_l76ycteulo8e",
        "fls_lh0d85tl4qvy",
        "fls_sgu9bnp7xajv",
        "fls_cl1g4fxfa020"
      ],
      "position": 2381,
      "parent_fls_id": "fls_xgqh0ju6bmbn",
      "sibling_fls_ids": [
        "fls_7dbd5t2750ce",
        "fls_qssijtofa9i8",
        "fls_jm6l7b90h6wa"
      ]
    },
    {
      "fls_id": "fls_7bxv8lybxm18",
      "title": "Identifier Patterns",
      "level": 3,
      "file": "patterns",
      "content": "Identifier Patterns\n\n BoundPattern ::=\n $$@$$ Pattern\n\nAn identifier pattern is a pattern that binds the value it\nmatches to a binding.\n\nA bound pattern is a pattern that imposes a constraint on a related\nidentifier pattern.\n\nAn identifier pattern yields a binding. An identifier pattern\nwith keyword mut yields a mutable binding.\n\nAn identifier pattern with keyword ref is a\nreference identifier pattern.\n\nThe identifier pattern enters its binding into binding scope in\nthe value namespace if it does not resolve to a constant, a\nunit struct constant or a unit enum variant.\n\nIt is a static error if the identifier pattern consists of anything other\nthan a binding when the binding resolves to a constant, a\nunit struct constant, or a unit enum variant.\n\nIt is a static error if the binding of an identifier pattern resolves\nto a tuple struct or a tuple enum variant.\n\nAn identifier pattern is an irrefutable pattern when:\n\n* It has a bound pattern and the bound pattern is an\n irrefutable pattern, or\n\n* It does not have a bound pattern and its binding resolves to an\n irrefutable constant.\n\n* It does not have a bound pattern and its binding does not resolve to\n a constant, a unit struct constant, or a unit enum variant.\n\nIf the identifier pattern does not have a bound pattern, then the\ntype of its binding is determined as follows:\n\n* If the identifier pattern has only keyword ref, then the\n type is & inferred_type, where inferred_type is the type\n determined by type inference.\n\n* If the identifier pattern has [keyword]s ref mut, then the\n type is &mut inferred_type, where inferred_type is the type\n determined by type inference.\n\n* Otherwise the type is inferred_type, where inferred_type is the\n type determined by type inference.\n\nIf the identifier pattern has a bound pattern, then the type of\nits binding is determined as follows:\n\n* If the identifier pattern has only keyword ref, then the\n type is & bound_pattern_type, where bound_pattern_type is the\n type of the bound pattern.\n\n* If the identifier pattern has [keyword]s ref mut, then the\n type is &mut bound_pattern_type, where bound_pattern_type is the\n type of the bound pattern.\n\n* Otherwise the type is inferred_type, where inferred_type is the\n type determined by type inference.\n\nAn identifier pattern in the context of a let expression.\n\nAn identifier pattern with a bound pattern in the context of a match expression.",
      "paragraph_ids": [
        "fls_uljdw9rf7ies",
        "fls_vy9uw586wy0d",
        "fls_hqwt3fvr063y",
        "fls_joIQdDn44oIT",
        "fls_24c95c56tugl",
        "fls_twcavjk7iquy",
        "fls_k1yBTstX7jEE",
        "fls_hw26hy33guk5",
        "fls_svfxwz4yy5i",
        "fls_x6f6q22b5jpc",
        "fls_r2mb8v2lh3x0",
        "fls_7oioaitb075g",
        "fls_40qin0ss5sqd",
        "fls_pivz0v7ey6sw",
        "fls_2ahkrddxwj1n",
        "fls_eucnafj3uedy",
        "fls_f8zo4scodhcr",
        "fls_d3fs2h7oqjl0",
        "fls_exo8asevh5x1",
        "fls_sfyfdxhvhk44",
        "fls_as0pqqmo1des"
      ],
      "position": 3618,
      "parent_fls_id": "fls_uh76pw6ykd57",
      "sibling_fls_ids": [
        "fls_2krxnq8q9ef1",
        "fls_1xit18et4ohh",
        "fls_uloyjbaso8pz",
        "fls_6tl1fx99yn6c",
        "fls_d2sc9hl3v0mk",
        "fls_7wpgnp4kjq82",
        "fls_qte70mgzpras"
      ]
    },
    {
      "fls_id": "fls_2krxnq8q9ef1",
      "title": "Literal Patterns",
      "level": 3,
      "file": "patterns",
      "content": "Literal Patterns\n\nA literal pattern is a pattern that matches a literal.\n\nA numeric literal pattern is a pattern that matches a numeric\nliteral.\n\nA numeric literal pattern's numeric literal value shall not be a IEEE\nfloating-point NaN.\n\nThe type of a literal pattern is the type of the specified\nliteral.\n\nTwo literal patterns in the context of a match expression.\nSee :p:`fls_sfyfdxhvhk44` for the declaration of x.",
      "paragraph_ids": [
        "fls_pah15qa54irs",
        "fls_COQKJC0dvtNO",
        "fls_JP8YSbxSN0Ym",
        "fls_co60bzvwashg",
        "fls_fqclaznjgtb1"
      ],
      "position": 7334,
      "parent_fls_id": "fls_uh76pw6ykd57",
      "sibling_fls_ids": [
        "fls_7bxv8lybxm18",
        "fls_1xit18et4ohh",
        "fls_uloyjbaso8pz",
        "fls_6tl1fx99yn6c",
        "fls_d2sc9hl3v0mk",
        "fls_7wpgnp4kjq82",
        "fls_qte70mgzpras"
      ]
    },
    {
      "fls_id": "fls_1xit18et4ohh",
      "title": "Parenthesized Patterns",
      "level": 3,
      "file": "patterns",
      "content": "Parenthesized Patterns\n\nA parenthesized pattern is a pattern that controls the precedence of\nits [subpattern]s.\n\nA parenthesized pattern is an irrefutable pattern when its nested\npattern is an irrefutable pattern.\n\nThe type of a parenthesized pattern is the type of its nested\npattern.\n\nSee :p:`fls_sfyfdxhvhk44` for the declaration of x.\n\nA parenthesized pattern inside a reference pattern in the context of a match\nexpression.",
      "paragraph_ids": [
        "fls_kvqzmt7my5dh",
        "fls_mrjhpiq5refe",
        "fls_pe5kh8y8u664",
        "fls_2xq8852gihn9",
        "fls_2dmeukyjqz9y"
      ],
      "position": 8371,
      "parent_fls_id": "fls_uh76pw6ykd57",
      "sibling_fls_ids": [
        "fls_7bxv8lybxm18",
        "fls_2krxnq8q9ef1",
        "fls_uloyjbaso8pz",
        "fls_6tl1fx99yn6c",
        "fls_d2sc9hl3v0mk",
        "fls_7wpgnp4kjq82",
        "fls_qte70mgzpras"
      ]
    },
    {
      "fls_id": "fls_uloyjbaso8pz",
      "title": "Path Patterns",
      "level": 3,
      "file": "patterns",
      "content": "Path Patterns\n\nA path pattern is a pattern that matches a constant, a\nunit enum variant, or a unit struct constant indicated by a path.\n\nA path pattern expressed as a path expression shall refer to either\nan associated constant, or a constant.\n\nWhen a path pattern refers to an associated constant or a\nconstant, the associated constant or constant shall not be of a\nunion type.\n\nWhen a path pattern refers to an associated constant or a\nconstant, the type of the associated constant or constant\nshall be structurally equal.\n\nWhen a path pattern refers to an associated constant or a\nconstant, the constant must not contain any references to\n[mutable static]s, [static]s with interior mutability,\nor [external static]s.\n\nWhen the type of the path pattern is of an enum type or\nstruct type, then the enum type or struct type shall be subject\nto attribute derive with arguments core::cmp::Eq and\ncore::cmp::PartialEq.\n\nA path pattern expressed as a qualified path expression shall refer\nto an associated constant.\n\nA path pattern is an irrefutable pattern when it refers to:\n\n* An irrefutable constant,\n\n* An enum variant of an enum type with zero or more [visible empty enum variant]s and one non-visible empty enum variant where the [type]s of all [field]s are not subject to visible emptiness\n\n* A struct where the [type]s of all [field]s are\n [irrefutable pattern]s.\n\nThe type of a path pattern is the type of the constant,\nunit enum variant, or unit struct constant the path resolved to.\n\nSee :p:`fls_sfyfdxhvhk44` for the declaration of x.",
      "paragraph_ids": [
        "fls_1crq0mexo5r1",
        "fls_xz5otkhogn31",
        "fls_t8sjzsif2ilf",
        "fls_zCswsyuitexI",
        "fls_wJ9f906BlBvg",
        "fls_hF19K8sWU8FF",
        "fls_bv9psmitxfuw",
        "fls_sl47k9oj5p7t",
        "fls_cfoy86mkmqa4",
        "fls_rnppz6y5z8pi",
        "fls_ag6m4mvpturw",
        "fls_pedy2pqrvnx7",
        "fls_u59rilepu8z9"
      ],
      "position": 9288,
      "parent_fls_id": "fls_uh76pw6ykd57",
      "sibling_fls_ids": [
        "fls_7bxv8lybxm18",
        "fls_2krxnq8q9ef1",
        "fls_1xit18et4ohh",
        "fls_6tl1fx99yn6c",
        "fls_d2sc9hl3v0mk",
        "fls_7wpgnp4kjq82",
        "fls_qte70mgzpras"
      ]
    },
    {
      "fls_id": "fls_6tl1fx99yn6c",
      "title": "Range Patterns",
      "level": 3,
      "file": "patterns",
      "content": "Range Patterns\n\n HalfOpenRangePattern ::=\n RangePatternLowBound $$..$$\n\n InclusiveRangePattern ::=\n RangePatternLowBound $$..=$$ RangePatternHighBound\n\n ExclusiveRangePattern ::=\n RangePatternLowBound $$..$$ RangePatternHighBound\n\n ObsoleteRangePattern ::=\n RangePatternLowBound $$...$$ RangePatternHighBound\n\n RangePatternLowBound ::=\n RangePatternBound\n\n RangePatternHighBound ::=\n RangePatternBound\n\n RangePatternBound ::=\n ByteLiteral\n | CharacterLiteral\n | $$-$$? NumericLiteral\n | PathExpression\n | QualifiedPathExpression\n\nA range pattern is a pattern that matches [value]s which fall\nwithin a range.\n\nA half-open range pattern is a range pattern with only a\nrange pattern low bound.\n\nAn inclusive range pattern is a range pattern with both a\nrange pattern low bound and a range pattern high bound.\n\nAn exclusive range pattern is a range pattern with both a\nrange pattern low bound and a range pattern high bound.\n\nAn obsolete range pattern is a range pattern that uses obsolete syntax\nto express an inclusive range pattern.\n\nA range pattern bound is a constraint on the range of a range pattern.\n\nA range pattern low bound is a range pattern bound that specifies the\nstart of a range.\n\nA range pattern high bound is a range pattern bound that specifies the\nend of a range.\n\nA half-open range pattern shall appear within a parenthesized pattern\nwhen the context is a slice pattern.\n\nThe range pattern low bound of an inclusive range pattern shall be\nless than or equal to its range pattern high bound.\n\nThe range pattern low bound of an exclusive range pattern shall be\nless than its range pattern high bound.\n\nAn obsolete range pattern is equivalent to an inclusive range pattern.\n\nA range pattern is an irrefutable pattern only when it spans the\nentire set of possible [value]s of a type.\n\nThe [type]s of the range pattern low bound and the\nrange pattern high bound of a range pattern shall be unifiable.\n\nThe type of a range pattern is determined as follows:\n\n* If the range pattern is expressed as an inclusive range pattern, an\n exclusive range pattern, or an obsolete range pattern, then the\n type is the unified type of the [type]s of the\n range pattern low bound and the range pattern high bound.\n\n* Otherwise the type is the type of the range pattern low bound.\n\nA path expression of a range pattern shall refer to a constant\nof a scalar type.\n\nA qualified path expression of a range pattern shall refer to an\nassociated constant of a scalar type.\n\nTwo range patterns in the context of a match expression.\nSee :p:`fls_sfyfdxhvhk44` for the declaration of x.",
      "paragraph_ids": [
        "fls_okupyoav13rm",
        "fls_jhchm7dy927k",
        "fls_q86j23iiqv8w",
        "fls_3PyquOKjA7SI",
        "fls_akf9x5r6e0ta",
        "fls_vrpr6ttpfpal",
        "fls_nk48gregn3me",
        "fls_83v1xqbebs58",
        "fls_2hpuccwh2xml",
        "fls_9kk81isk0mlp",
        "fls_8bdOqkO1NuJW",
        "fls_s2b5n4snc4d7",
        "fls_4o4ge6x9a8rs",
        "fls_6o995ak4hywq",
        "fls_3js1645tgh31",
        "fls_8Q6NfRx4j5V7",
        "fls_rgr7t33s0m7m",
        "fls_5ey5mj8t8knd",
        "fls_z4js96mchcsv",
        "fls_3wwpq8i6mo2a"
      ],
      "position": 11872,
      "parent_fls_id": "fls_uh76pw6ykd57",
      "sibling_fls_ids": [
        "fls_7bxv8lybxm18",
        "fls_2krxnq8q9ef1",
        "fls_1xit18et4ohh",
        "fls_uloyjbaso8pz",
        "fls_d2sc9hl3v0mk",
        "fls_7wpgnp4kjq82",
        "fls_qte70mgzpras"
      ]
    },
    {
      "fls_id": "fls_d2sc9hl3v0mk",
      "title": "Reference Patterns",
      "level": 3,
      "file": "patterns",
      "content": "Reference Patterns\n\nA reference pattern is a pattern that dereferences a pointer that\nis being matched.\n\nA reference pattern is an irrefutable pattern when its nested pattern itself is an irrefutable pattern.\n\nThe type of a reference pattern is determined as follows:\n\n* If the reference pattern appears with keyword mut,\n then the type is &mut pattern_without_range_type,\n where pattern_without_range_type is the type of the\n :s:`PatternWithoutRange`.\n\n* If the reference pattern appears without keyword\n mut, then the type is & pattern_without_range_type,\n where pattern_without_range_type is the type of the\n :s:`PatternWithoutRange`.\n\nA reference pattern in the context of a match expression.\nSee :p:`fls_2xq8852gihn9` for the declaration of ref_x.",
      "paragraph_ids": [
        "fls_fhahcc1mz2qh",
        "fls_x0bmzl1315gq",
        "fls_fedo8zhgpla5",
        "fls_30u9ij164ww3",
        "fls_d1kc73hpncpo",
        "fls_mpeuhov0umfa"
      ],
      "position": 15672,
      "parent_fls_id": "fls_uh76pw6ykd57",
      "sibling_fls_ids": [
        "fls_7bxv8lybxm18",
        "fls_2krxnq8q9ef1",
        "fls_1xit18et4ohh",
        "fls_uloyjbaso8pz",
        "fls_6tl1fx99yn6c",
        "fls_7wpgnp4kjq82",
        "fls_qte70mgzpras"
      ]
    },
    {
      "fls_id": "fls_7wpgnp4kjq82",
      "title": "Rest Patterns",
      "level": 3,
      "file": "patterns",
      "content": "Rest Patterns\n\nA rest pattern is a pattern that matches zero or more elements that\nhave not already been matched.\n\nA rest pattern shall appear at most once within a slice pattern, an\nidentifier pattern of a slice pattern, a tuple pattern, and a\ntuple struct pattern.\n\nA rest pattern is an irrefutable pattern.\n\nIf a rest pattern appears within a slice pattern or the\nidentifier pattern of a slice pattern, then the type of the\nrest pattern is determined as follows:\n\n* If the type of the slice pattern is an array type, then the\n type is [T; N] where T is the element type of the\n array type, and N is the [array type]'s size minus the number\n of matched elements of the slice pattern.\n\n* If the type of the slice pattern is a slice type, then the\n type is that slice type.\n\nA rest pattern in an identifier pattern of a slice pattern, followed by a rest\npattern in a slice pattern.\n\nRest patterns in tuple patterns.",
      "paragraph_ids": [
        "fls_eso51epfofxb",
        "fls_5a75a2y43uev",
        "fls_rsqyza99vl3x",
        "fls_w1pw40phsv2o",
        "fls_x8ylgxrf9ca",
        "fls_zgoke73xrhk3",
        "fls_bdcv6rwx0fsv",
        "fls_qz9guhlg19j3"
      ],
      "position": 16958,
      "parent_fls_id": "fls_uh76pw6ykd57",
      "sibling_fls_ids": [
        "fls_7bxv8lybxm18",
        "fls_2krxnq8q9ef1",
        "fls_1xit18et4ohh",
        "fls_uloyjbaso8pz",
        "fls_6tl1fx99yn6c",
        "fls_d2sc9hl3v0mk",
        "fls_qte70mgzpras"
      ]
    },
    {
      "fls_id": "fls_qte70mgzpras",
      "title": "Slice Patterns",
      "level": 3,
      "file": "patterns",
      "content": "Slice Patterns\n\nA slice pattern is a pattern that matches [array]s of fixed size\nand [slice]s of dynamic size.\n\nA slice pattern is an irrefutable pattern when it refers to:\n\n* An array, where each subpattern is an irrefutable pattern, or\n\n* A slice, where the :s:`PatternList` consists of a single\n rest pattern, or a single possibly nested identifier pattern whose\n last bound pattern is a rest pattern.\n\nThe type of a slice pattern is the same as the expected type.\n\nA slice pattern in the context of a match expression.",
      "paragraph_ids": [
        "fls_qqiu594hki8g",
        "fls_h6x9xlxi7y5n",
        "fls_jbmxu7y5fnm6",
        "fls_r78zzw7yyg34",
        "fls_ndor56nou676",
        "fls_9yuobz1jsehf"
      ],
      "position": 18584,
      "parent_fls_id": "fls_uh76pw6ykd57",
      "sibling_fls_ids": [
        "fls_7bxv8lybxm18",
        "fls_2krxnq8q9ef1",
        "fls_1xit18et4ohh",
        "fls_uloyjbaso8pz",
        "fls_6tl1fx99yn6c",
        "fls_d2sc9hl3v0mk",
        "fls_7wpgnp4kjq82"
      ]
    },
    {
      "fls_id": "fls_7dbd5t2750ce",
      "title": "Struct Patterns",
      "level": 2,
      "file": "patterns",
      "content": "Struct Patterns\n\n Deconstructee ::=\n PathExpression\n\nA struct pattern is a pattern that matches an enum value, a\nstruct value, or a union value.\n\nA deconstructee indicates the enum variant or type that is being\ndeconstructed by a struct pattern.\n\nA struct pattern is interpreted based on the deconstructee. It is a\nstatic error if a struct pattern cannot be interpreted.\n\nA struct pattern is an irrefutable pattern if\n\n* All of its [subpattern]s are [irrefutable pattern]s, and\n\n* The deconstructee is either:\n\n * A struct type or a union type, or\n\n * An enum variant of an enum type with zero or more [visible empty enum variant]s and one non-visible empty enum variant where the [type]s of all [field]s are not subject to visible emptiness.",
      "paragraph_ids": [
        "fls_vjdkpr3zml51",
        "fls_6o3x101wo478",
        "fls_k9zih9s0oe5h",
        "fls_r8rat3qmc4hy",
        "fls_hUX723DmLg2a",
        "fls_p4OplpUvS04l",
        "fls_pre3YwAv01FE",
        "fls_MK83WE0iDqNf"
      ],
      "position": 19633,
      "parent_fls_id": "fls_xgqh0ju6bmbn",
      "sibling_fls_ids": [
        "fls_uh76pw6ykd57",
        "fls_qssijtofa9i8",
        "fls_jm6l7b90h6wa"
      ]
    },
    {
      "fls_id": "fls_nruvg0es3kx7",
      "title": "Record Struct Patterns",
      "level": 3,
      "file": "patterns",
      "content": "Record Struct Patterns\n\n RecordStructPatternContent ::=\n RecordStructRestPattern\n | FieldDeconstructorList ($$,$$ RecordStructRestPattern | $$,$$?)\n\n RecordStructRestPattern ::=\n OuterAttributeOrDoc* RestPattern\n\n FieldDeconstructorList ::=\n FieldDeconstructor ($$,$$ FieldDeconstructor)*\n\n FieldDeconstructor ::=\n OuterAttributeOrDoc* (\n IndexedDeconstructor\n | NamedDeconstructor\n | ShorthandDeconstructor\n )\n\n IndexedDeconstructor ::=\n FieldIndex $$:$$ Pattern\n\n NamedDeconstructor ::=\n Identifier $$:$$ Pattern\n\n ShorthandDeconstructor ::=\n $$ref$$? $$mut$$? Binding\n\n FieldIndex ::=\n DecimalLiteral\n\nA record struct pattern is a pattern that matches a\nenum variant value, a struct value, or a union value.\n\nThe deconstructee of a record struct pattern shall resolve to an\nenum variant, a struct type, or a union type.\n\nAn indexed deconstructor is a construct that matches the position of\na field.\n\nAn indexed deconstructor matches a field of the deconstructee\nwhen its field index and the position of the field in the\ndeconstructee are the same. Such an indexed deconstructor is a\nmatched indexed deconstructor.\n\nThe type of a matched indexed deconstructor and the type of the\nmatched field shall be unifiable.\n\nA named deconstructor is a construct that matches the name of\na field.\n\nA named deconstructor matches a field of the deconstructee when\nits identifier and the name of the field are the same. Such a\nnamed deconstructor is a matched named deconstructor.\n\nThe type of a matched named deconstructor and the type of the\nmatched field shall be unifiable.\n\nA shorthand deconstructor is a construct that matches the name\nof a field and binds the value of the matched field to a\nbinding.\n\nA shorthand deconstructor with keyword mut yields a\nmutable binding.\n\nIt is a static error if a shorthand deconstructor has only keyword\nref or [keyword]s ref mut, and its binding shadows a\nconstant, a unit enum variant, or a unit struct constant.\n\nA shorthand deconstructor is equivalent to a named deconstructor where\nthe name of the shorthand deconstructor denotes the identifier\nof the named deconstructor and the entire content of the shorthand\ndeconstructor denotes the pattern of the named deconstructor.\n\nA shorthand deconstructor matches a field of the deconstructee\nwhen its name and the name of the field are the same. Such a\nshorthand deconstructor is a matched shorthand deconstructor.\n\nThe type of a matched shorthand deconstructor and the type of the\nmatched field shall be unifiable.\n\nIf the deconstructee of a record struct pattern is a\nrecord enum variant or a record struct, then\n\n* For each field of the deconstructee, the record struct pattern\n shall either:\n\n * Contain at most one matched named deconstructor, or\n\n * Contain at most one matched shorthand deconstructor, or\n\n * Have exactly one :s:`RecordStructRestPattern`.\n\n* A :s:`RecordStructRestPattern` is allowed even if all [field]s of the\n deconstructee have been matched.\n\nIf the deconstructee of a record struct pattern is a\ntuple enum variant or a tuple struct type, then\n\n* For each field of the deconstructee, the record struct pattern\n shall either:\n\n * Contain at most one matched indexed deconstructor, or\n\n * Have exactly one RecordStructRestPattern.\n\n* A :s:`RecordStructRestPattern` is allowed even if all [field]s of the\n deconstructee have been matched.\n\nIf the deconstructee of a record struct pattern is a union type,\nthen\n\n* The :s:`RecordStructPatternContent` of the record struct\n pattern shall contain exactly one :s:`FieldDeconstructor`.\n\n* The record struct pattern shall not contain a\n :s:`RecordStructRestPattern`.\n\n* For the single field of the deconstructee, the\n record struct pattern shall either:\n\n * Contain exactly one matched named deconstructor, or\n\n * Contain exactly one matched shorthand deconstructor.\n\n* The record struct pattern shall require unsafe context.\n\nIf the deconstructee of a record struct pattern is a\nunit enum variant or a unit struct, then the\nrecord struct pattern shall have at most one :s:`RecordStructRestPattern`.\n\nIt is undefined behavior reading the field of a deconstructee that is\na union type when the field contains data that is invalid for the\nfield's type.\n\nA record struct pattern deconstructing a record struct.\n\nA record struct pattern deconstructing a tuple struct.\n\nA record struct pattern deconstructing a union.",
      "paragraph_ids": [
        "fls_g6dytd6aq62d",
        "fls_3px4oiweg9dm",
        "fls_mnh35ehva8tx",
        "fls_p2rjnlbvifaa",
        "fls_23be2x50at14",
        "fls_46u4ddj0yf93",
        "fls_qu3dvfdq6oy7",
        "fls_4b2hchdzv30u",
        "fls_9wfizujx0szd",
        "fls_jTh9Hur0qsIb",
        "fls_as54u97xis8z",
        "fls_8364ueejn5y3",
        "fls_7t0be1w2hq3c",
        "fls_3vgmkm2mzwwy",
        "fls_m91ith3rjy79",
        "fls_c09jf2vpcr58",
        "fls_4h00oqypa8qg",
        "fls_195mqijyrnam",
        "fls_ta0vdoqmt2k1",
        "fls_f0u0j4q90lpl",
        "fls_8bi8q3usubby",
        "fls_1x0o71kxj3yq",
        "fls_1thgpx95lfg5",
        "fls_rpo1wimbmzhc",
        "fls_brhtaaxt1s3s",
        "fls_jwz3arnfkxwn",
        "fls_pfz8xlwezbw1",
        "fls_XFKBJZe6k1o2",
        "fls_mu166csowj71",
        "fls_y09fygnglu3n",
        "fls_2tadaatmauzk",
        "fls_oq30xkmvyz72",
        "fls_9y1gbv47z23o",
        "fls_dHtV2BPRFVBB",
        "fls_zRCiKnhQebyp",
        "fls_D5tAGzrjXFTu",
        "fls_FhvMzLPRlY7p"
      ],
      "position": 20888,
      "parent_fls_id": "fls_7dbd5t2750ce",
      "sibling_fls_ids": [
        "fls_vlrto778v49m",
        "fls_urbr5rg9206v",
        "fls_qfsfnql1t7m"
      ]
    },
    {
      "fls_id": "fls_vlrto778v49m",
      "title": "Tuple Struct Patterns",
      "level": 3,
      "file": "patterns",
      "content": "Tuple Struct Patterns\n\nA tuple struct pattern is a pattern that matches a\ntuple enum variant value, or a tuple struct value.\n\nThe deconstructee of a tuple struct pattern shall resolve to a\ntuple enum variant or a tuple struct type.\n\nA subpattern of a tuple struct pattern matches a field of the\ndeconstructee when its position and the position of the field in\nthe deconstructee are the same. Such a subpattern is a\nmatched tuple struct subpattern.\n\nThe position of a subpattern is determined as follows:\n\n* If the tuple struct pattern has a :s:`RecordStructRestPattern`, then\n\n * If the subpattern precedes the :s:`RecordStructRestPattern`, then its\n position is the position within the :s:`PatternList` in left-to-right order,\n starting from zero.\n\n * If the subpattern succeeds the :s:`RecordStructRestPattern`, then its\n position is the position within the :s:`PatternList` list in right-to-left\n order, starting from the arity of the deconstructee minus one.\n\n* Otherwise the position is the position within the :s:`PatternList` in\n left-to-right order, starting from zero.\n\nThe type of the subpattern of a tuple struct pattern and the\ntype of the matched field shall be unifiable.\n\nFor each field of the deconstructee, the tuple struct pattern\nshall either:\n\n* Contain at most one matched tuple struct subpattern, or\n\n* Have exactly one :s:`RecordStructRestPattern`.\n\nA :s:`RecordStructRestPattern` is allowed even if all [field]s of the\ndeconstructee have been matched.\n\nSee :p:`fls_D5tAGzrjXFTu` for the declarations of TupleStruct and\ntuple_struct_value.",
      "paragraph_ids": [
        "fls_ks6y1syab2bp",
        "fls_t1mrijw16k9a",
        "fls_ryfcrqrkp28y",
        "fls_ehf9r6halgh1",
        "fls_5lo1hs8wzz0t",
        "fls_gwuc2xffosu",
        "fls_w369n8lmwr7g",
        "fls_4is6h95jj3gd",
        "fls_budf0rpsa4lx",
        "fls_vo6mtauh4qhb",
        "fls_rco3fwlx2a76",
        "fls_4vrnxslad09e",
        "fls_qgilaqy5zx7q",
        "fls_2u99arsbnlnk"
      ],
      "position": 28058,
      "parent_fls_id": "fls_7dbd5t2750ce",
      "sibling_fls_ids": [
        "fls_nruvg0es3kx7",
        "fls_urbr5rg9206v",
        "fls_qfsfnql1t7m"
      ]
    },
    {
      "fls_id": "fls_urbr5rg9206v",
      "title": "Tuple Patterns",
      "level": 3,
      "file": "patterns",
      "content": "Tuple Patterns\n\nA tuple pattern is a pattern that matches a tuple which satisfies\nall criteria defined by its [subpattern]s.\n\nA tuple pattern is an irrefutable pattern when all of its\n[subpattern]s are [irrefutable pattern]s.\n\nThe type of a tuple pattern is the type of the tuple being\ndestructured.\n\nA subpattern of a tuple pattern matches a tuple field of the\ntuple type when its position and the position of the tuple field in\nthe tuple type are the same. Such a subpattern is a\nmatched tuple subpattern.\n\nThe position of a subpattern is determined as follows:\n\n* If the tuple pattern has a :s:`RestPattern`, then\n\n * If the subpattern precedes the :s:`RestPattern`, then its\n position is the position within the :s:`PatternList` in left-to-right order,\n starting from zero.\n\n * If the subpattern succeeds the :s:`RestPattern`, then its\n position is the position within the :s:`PatternList` list in right-to-left\n order, starting from the arity of the tuple type minus one.\n\n* Otherwise the position is the position within the :s:`PatternList` in\n left-to-right order, starting from zero.\n\nThe type of the subpattern of a tuple pattern and the\ntype of the matched tuple field shall be unifiable.\n\nFor each tuple field of the tuple type, the tuple pattern shall\neither:\n\n* Contain at most one matched tuple subpattern, or\n\n* Have exactly one :s:`RestPattern`.\n\nA :s:`RestPattern` is allowed even if all [tuple field]s of the\ntuple type have been matched.\n\nA tuple pattern in the context of a let statement.",
      "paragraph_ids": [
        "fls_e2manugp4e0b",
        "fls_xk8udu4k61kj",
        "fls_yhcaz6v49ub2",
        "fls_6WCm0Ra8NQl4",
        "fls_a3qvQjyilORx",
        "fls_KmIHFxlBYelZ",
        "fls_5bXqIaKiFcLg",
        "fls_soHCAVfGlv5f",
        "fls_iiKvYs61959S",
        "fls_F4k6ljuP8Amf",
        "fls_GjjCDkVJPQS8",
        "fls_9Qw9N87swwNe",
        "fls_CQ84wkLyrAJv",
        "fls_cC6ohNuiltfL",
        "fls_8r81vtv5hnrd"
      ],
      "position": 30597,
      "parent_fls_id": "fls_7dbd5t2750ce",
      "sibling_fls_ids": [
        "fls_nruvg0es3kx7",
        "fls_vlrto778v49m",
        "fls_qfsfnql1t7m"
      ]
    },
    {
      "fls_id": "fls_qfsfnql1t7m",
      "title": "Underscore Patterns",
      "level": 3,
      "file": "patterns",
      "content": "Underscore Patterns\n\nAn underscore pattern is a pattern that matches any single value.\n\nAn underscore pattern is an irrefutable pattern.\n\nThe type of an underscore pattern is the type of the value\nit matches.\n\nAn underscore pattern in the context of a let statement.\nSee :p:`fls_8r81vtv5hnrd` for the declaration of pair.",
      "paragraph_ids": [
        "fls_dreny9e0ei6r",
        "fls_42fye1v0th8l",
        "fls_b87mvrcc13f2",
        "fls_j3u6x1ensrbe"
      ],
      "position": 32928,
      "parent_fls_id": "fls_7dbd5t2750ce",
      "sibling_fls_ids": [
        "fls_nruvg0es3kx7",
        "fls_vlrto778v49m",
        "fls_urbr5rg9206v"
      ]
    },
    {
      "fls_id": "fls_qssijtofa9i8",
      "title": "Binding Modes",
      "level": 2,
      "file": "patterns",
      "content": "Binding Modes\n\nA binding pattern is either an identifier pattern or a\nshorthand deconstructor.\n\nA binding of a binding pattern binds a matched value to a\nname.\n\nA binding with binding mode by value binds the matched\nvalue by passing <passing convention> the value to the place\nindicated by the name.\n\nA binding with binding mode by reference binds an\nimmutable reference to the matched value to the name.\n\nA binding with binding mode by mutable reference binds a\nmutable reference to the matched value to the name.\n\nA non-reference pattern is any pattern except\nnon-[binding pattern]s, [path pattern]s, [reference pattern]s,\nand [underscore pattern]s.\n\nIf a binding pattern does not explicitly specify keyword ref,\nkeyword mut, or [keyword]s ref mut, then its binding mode\nuses the current binding mode of pattern matching.\n\nInitially, the binding mode of a binding is by value.\n\nDuring the process of pattern matching, each time a reference\nis matched against a non-[reference pattern], the reference is\ndereferenced and the binding mode is updated as follows:\n\n* If the reference is an immutable reference, then the\n binding mode is updated to by reference.\n\n* If the reference is a mutable reference and the binding mode\n is by value, then the binding mode is updated to\n by mutable reference.\n\nThe process repeats if the dereferenced value is a reference.\n\nA [binding pattern]s binds its binding to a matched value as\nfollows:\n\n* If the binding mode is by reference or the binding pattern\n appears only with keyword ref, then the binding is bound to a\n reference of the matched value.\n\n* If the binding mode is by mutable reference or the binding\n pattern appears with keywords ref mut, then the binding is bound\n to a mutable reference of the matched value.\n\n* If the binding mode is by value, then the binding is\n bound to a copy of the matched value if its type implements the\n core::marker::Copy trait, otherwise the binding is bound to\n the move of the matched value.",
      "paragraph_ids": [
        "fls_7xby6d1903kw",
        "fls_vnh9wfrvumdz",
        "fls_RViC5UEZPQUV",
        "fls_6lXtoxebD5It",
        "fls_xNxQN8sgpZ3O",
        "fls_dqe75i8h2fie",
        "fls_y3wuvj1y5j20",
        "fls_55jtzh6a292x",
        "fls_qcaf2kup7zn0",
        "fls_6acdqz8rwnn",
        "fls_tv0avib387bv",
        "fls_dbgmwldye42e",
        "fls_t34oqarwcusu",
        "fls_7gxb74u1np36",
        "fls_7y56d0ulxomf",
        "fls_pxvtqxke1enp"
      ],
      "position": 33605,
      "parent_fls_id": "fls_xgqh0ju6bmbn",
      "sibling_fls_ids": [
        "fls_uh76pw6ykd57",
        "fls_7dbd5t2750ce",
        "fls_jm6l7b90h6wa"
      ]
    },
    {
      "fls_id": "fls_jm6l7b90h6wa",
      "title": "Pattern Matching",
      "level": 2,
      "file": "patterns",
      "content": "Pattern Matching\n\nPattern matching that involves a pattern and a context value\nproceeds as follows:\n\n#. For each pattern-without-alternation of the pattern:\n\n #. If the pattern-without-alternation is an identifier pattern,\n then perform identifier pattern matching.\n\n #. If the pattern-without-alternation is a literal pattern, then\n perform literal pattern matching.\n\n #. If the pattern-without-alternation is a parenthesized pattern,\n then perform parenthesized pattern matching.\n\n #. If the pattern-without-alternation is a path pattern, then\n perform path pattern matching.\n\n #. If the pattern-without-alternation is a range pattern, then\n perform range pattern matching.\n\n #. If the pattern-without-alternation is a reference pattern, then\n perform reference pattern matching.\n\n #. If the pattern-without-alternation is a slice pattern, then\n perform slice pattern matching.\n\n #. If the pattern-without-alternation is a record struct pattern,\n then perform record struct pattern matching.\n\n #. If the pattern-without-alternation is a tuple struct pattern,\n then perform tuple struct pattern matching.\n\n #. If the pattern-without-alternation is a tuple pattern, then\n perform tuple pattern matching.\n\n #. If the pattern-without-alternation is an underscore pattern,\n then perform underscore pattern matching.\n\n #. Otherwise pattern matching fails.\n\nOnly the [binding]s of a matched pattern-without-alternation are\nintroduced into a binding scope.",
      "paragraph_ids": [
        "fls_tlwr4u7bjhh5",
        "fls_67ajub7d2b4c",
        "fls_62626ws222op",
        "fls_q0z46h1gnzez",
        "fls_1r0vm6rg13o9",
        "fls_am5h8r887bz5",
        "fls_eppmiloh7bgg",
        "fls_gwc08xayno7q",
        "fls_19iygu12s315",
        "fls_r307spfk6cs9",
        "fls_qhdofvbso3gl",
        "fls_drb114dtvlpt",
        "fls_uxysntb3u03j",
        "fls_wh201rmh6u6d",
        "fls_vstdqifqipbh"
      ],
      "position": 36581,
      "parent_fls_id": "fls_xgqh0ju6bmbn",
      "sibling_fls_ids": [
        "fls_uh76pw6ykd57",
        "fls_7dbd5t2750ce",
        "fls_qssijtofa9i8"
      ]
    },
    {
      "fls_id": "fls_vnai6ag4qrdb",
      "title": "Identifier Pattern Matching",
      "level": 3,
      "file": "patterns",
      "content": "Identifier Pattern Matching\n\nAn identifier pattern with keyword mut shall require that the\ncontext value is a mutable place expression.\n\nIdentifier pattern matching proceeds as follows:\n\n#. If the identifier pattern has a bound pattern, then\n\n #. Performed pattern matching with the bound pattern and the same\n context value.\n\n #. If matching the bound pattern fails, then matching fails.\n\n#. The context value is bound to the binding of the\n identifier pattern according to the binding mode.\n\n#. Matching succeeds.",
      "paragraph_ids": [
        "fls_4f3lzw64myhk",
        "fls_wauqwmdbcpna",
        "fls_3jyog8n6x2aa",
        "fls_w637uvlbzsyo",
        "fls_arz8ik3gf6u4",
        "fls_u6o5ndnezwbe",
        "fls_h1er04t0yta7"
      ],
      "position": 38810,
      "parent_fls_id": "fls_jm6l7b90h6wa",
      "sibling_fls_ids": [
        "fls_azzf1llv3wf",
        "fls_5loglxds6zik",
        "fls_d44aflefat88",
        "fls_fyskeih6twyb",
        "fls_org6hqv397fp",
        "fls_57ic33pwdvp3",
        "fls_asj8rgccvkoe",
        "fls_eexupzdsu7f",
        "fls_rce8bb7nz2jy",
        "fls_yc4xm4hrfyw7"
      ]
    },
    {
      "fls_id": "fls_azzf1llv3wf",
      "title": "Literal Pattern Matching",
      "level": 3,
      "file": "patterns",
      "content": "Literal Pattern Matching\n\nLiteral pattern matching proceeds as follows:\n\n#. If the literal of the literal pattern and the context value\n are equal, then matching succeeds.\n\n#. Otherwise matching fails.",
      "paragraph_ids": [
        "fls_fqkhhgushje9",
        "fls_m01eo9sa55s",
        "fls_294jtwbfq3p9"
      ],
      "position": 39710,
      "parent_fls_id": "fls_jm6l7b90h6wa",
      "sibling_fls_ids": [
        "fls_vnai6ag4qrdb",
        "fls_5loglxds6zik",
        "fls_d44aflefat88",
        "fls_fyskeih6twyb",
        "fls_org6hqv397fp",
        "fls_57ic33pwdvp3",
        "fls_asj8rgccvkoe",
        "fls_eexupzdsu7f",
        "fls_rce8bb7nz2jy",
        "fls_yc4xm4hrfyw7"
      ]
    },
    {
      "fls_id": "fls_5loglxds6zik",
      "title": "Parenthesized Pattern Matching",
      "level": 3,
      "file": "patterns",
      "content": "Parenthesized Pattern Matching\n\nParenthesized pattern matching performs pattern matching with its\nsubpattern and the same context value.",
      "paragraph_ids": [
        "fls_jajvvwoy3399"
      ],
      "position": 40088,
      "parent_fls_id": "fls_jm6l7b90h6wa",
      "sibling_fls_ids": [
        "fls_vnai6ag4qrdb",
        "fls_azzf1llv3wf",
        "fls_d44aflefat88",
        "fls_fyskeih6twyb",
        "fls_org6hqv397fp",
        "fls_57ic33pwdvp3",
        "fls_asj8rgccvkoe",
        "fls_eexupzdsu7f",
        "fls_rce8bb7nz2jy",
        "fls_yc4xm4hrfyw7"
      ]
    },
    {
      "fls_id": "fls_d44aflefat88",
      "title": "Path Pattern Matching",
      "level": 3,
      "file": "patterns",
      "content": "Path Pattern Matching\n\nPath pattern matching proceeds as follows:\n\n#. If the constant, unit enum variant or unit struct the\n path of the path pattern resolved to and the context value\n are equal, then matching succeeds.\n\n#. Otherwise matching fails.",
      "paragraph_ids": [
        "fls_4faltss0xbn4",
        "fls_fqt5w3qsykca",
        "fls_h3y8r4298s53"
      ],
      "position": 40355,
      "parent_fls_id": "fls_jm6l7b90h6wa",
      "sibling_fls_ids": [
        "fls_vnai6ag4qrdb",
        "fls_azzf1llv3wf",
        "fls_5loglxds6zik",
        "fls_fyskeih6twyb",
        "fls_org6hqv397fp",
        "fls_57ic33pwdvp3",
        "fls_asj8rgccvkoe",
        "fls_eexupzdsu7f",
        "fls_rce8bb7nz2jy",
        "fls_yc4xm4hrfyw7"
      ]
    },
    {
      "fls_id": "fls_fyskeih6twyb",
      "title": "Range Pattern Matching",
      "level": 3,
      "file": "patterns",
      "content": "Range Pattern Matching\n\nRange pattern matching proceeds as follows:\n\n#. If the range pattern is expressed as a half-open range pattern and\n the context value is in the inclusive range from the\n range pattern low bound to the maximum value of the\n range pattern low bound's type, then matching succeeds.\n\n#. If the range pattern is expressed as either an inclusive range\n pattern or an obsolete range pattern and the context value is in\n the inclusive range from the range pattern low bound to the\n range pattern high bound, then matching succeeds.\n\n#. If the range pattern is expressed as an exclusive range pattern\n and the context value is in the exclusive range from the\n range pattern low bound to the range pattern high bound, then\n matching succeeds.\n\n#. Otherwise matching fails.",
      "paragraph_ids": [
        "fls_mrh9vfdek5fi",
        "fls_7nxkgls0a5os",
        "fls_6kgj2fjccoig",
        "fls_EDL1Pi56KQ2H",
        "fls_n4t3xah1pk7i"
      ],
      "position": 40797,
      "parent_fls_id": "fls_jm6l7b90h6wa",
      "sibling_fls_ids": [
        "fls_vnai6ag4qrdb",
        "fls_azzf1llv3wf",
        "fls_5loglxds6zik",
        "fls_d44aflefat88",
        "fls_org6hqv397fp",
        "fls_57ic33pwdvp3",
        "fls_asj8rgccvkoe",
        "fls_eexupzdsu7f",
        "fls_rce8bb7nz2jy",
        "fls_yc4xm4hrfyw7"
      ]
    },
    {
      "fls_id": "fls_org6hqv397fp",
      "title": "Reference Pattern Matching",
      "level": 3,
      "file": "patterns",
      "content": "Reference Pattern Matching\n\nReference pattern matching proceeds as follows:\n\n#. Dereference the context value.\n\n#. Perform pattern matching with its subpattern and the dereferenced\n value.",
      "paragraph_ids": [
        "fls_ysfgdzaiww8z",
        "fls_7rxnxd4ybxbt",
        "fls_l2nwz166curc"
      ],
      "position": 41903,
      "parent_fls_id": "fls_jm6l7b90h6wa",
      "sibling_fls_ids": [
        "fls_vnai6ag4qrdb",
        "fls_azzf1llv3wf",
        "fls_5loglxds6zik",
        "fls_d44aflefat88",
        "fls_fyskeih6twyb",
        "fls_57ic33pwdvp3",
        "fls_asj8rgccvkoe",
        "fls_eexupzdsu7f",
        "fls_rce8bb7nz2jy",
        "fls_yc4xm4hrfyw7"
      ]
    },
    {
      "fls_id": "fls_57ic33pwdvp3",
      "title": "Slice Pattern Matching",
      "level": 3,
      "file": "patterns",
      "content": "Slice Pattern Matching\n\nSlice pattern matching proceeds as follows:\n\n#. If the expected type is a slice type then,\n\n #. If the number of [subpattern]s of the slice pattern is greater\n than the length of the context value, then matching fails.\n\n #. If the number of [subpattern]s of the slice pattern is less than\n the size of the context value and one of those [subpattern]s is\n not a rest pattern, then matching fails.\n\n #. For each subpattern of the slice pattern:\n\n #. Perform pattern matching with the subpattern and the\n corresponding value from the context value, ignoring\n [rest pattern]s.\n\n #. If matching the subpattern fails, then matching fails.\n\n#. Otherwise, if the expected type is an array type, then\n\n #. For each subpattern of the slice pattern:\n\n #. Perform pattern matching with the subpattern and the\n corresponding value from the context value, ignoring\n [rest pattern]s.\n\n #. If matching the subpattern fails, then matching fails.",
      "paragraph_ids": [
        "fls_hzyv4ofu0ny",
        "fls_x10AKxoXXbs8",
        "fls_69bnxrtj0nar",
        "fls_twhwiy213ibf",
        "fls_ei7y4ul6n6hu",
        "fls_ad2jud5h1rfp",
        "fls_pc97m47p34wq",
        "fls_kwQyiSoyAwZ8",
        "fls_zAdtysiuUwBX",
        "fls_SezcYXcSlEq7",
        "fls_6xRXEt2pGnZi"
      ],
      "position": 42277,
      "parent_fls_id": "fls_jm6l7b90h6wa",
      "sibling_fls_ids": [
        "fls_vnai6ag4qrdb",
        "fls_azzf1llv3wf",
        "fls_5loglxds6zik",
        "fls_d44aflefat88",
        "fls_fyskeih6twyb",
        "fls_org6hqv397fp",
        "fls_asj8rgccvkoe",
        "fls_eexupzdsu7f",
        "fls_rce8bb7nz2jy",
        "fls_yc4xm4hrfyw7"
      ]
    },
    {
      "fls_id": "fls_asj8rgccvkoe",
      "title": "Record Struct Pattern Matching",
      "level": 3,
      "file": "patterns",
      "content": "Record Struct Pattern Matching\n\nRecord struct pattern matching proceeds as follows:\n\n#. If the number of [subpattern]s of the record struct pattern is less\n than the number of [field]s of the context value and one of those\n [subpattern]s is not a rest pattern, then matching fails.\n\n#. For each subpattern of the struct pattern\n\n #. If the subpattern is a shorthand deconstructor, then the\n corresponding field of the context value is bound to the\n binding of the shorthand deconstructor according to the\n binding mode.\n\n #. Otherwise perform pattern matching with the subpattern and the\n corresponding field from the context value, ignoring [rest\n pattern]s.\n\n #. If matching the subpattern fails, then matching fails.",
      "paragraph_ids": [
        "fls_evuhau2rwm8i",
        "fls_bde1hpvrosui",
        "fls_447s4hc07ozn",
        "fls_vfdb1i5l41yk",
        "fls_yfk52fr7trw3",
        "fls_6sdcykdrpe5d"
      ],
      "position": 43847,
      "parent_fls_id": "fls_jm6l7b90h6wa",
      "sibling_fls_ids": [
        "fls_vnai6ag4qrdb",
        "fls_azzf1llv3wf",
        "fls_5loglxds6zik",
        "fls_d44aflefat88",
        "fls_fyskeih6twyb",
        "fls_org6hqv397fp",
        "fls_57ic33pwdvp3",
        "fls_eexupzdsu7f",
        "fls_rce8bb7nz2jy",
        "fls_yc4xm4hrfyw7"
      ]
    },
    {
      "fls_id": "fls_eexupzdsu7f",
      "title": "Tuple Struct Pattern Matching",
      "level": 3,
      "file": "patterns",
      "content": "Tuple Struct Pattern Matching\n\nTuple struct pattern matching proceeds as follows:\n\n#. For each subpattern of the tuple struct pattern\n\n #. Otherwise perform pattern matching with the subpattern and the\n corresponding field from the context value, ignoring\n [rest pattern]s.\n\n #. If matching the subpattern fails, then matching fails.",
      "paragraph_ids": [
        "fls_dexg9g9cct30",
        "fls_boc7juqj69hw",
        "fls_4dr1stiw82v9",
        "fls_h14emtt6iyk3"
      ],
      "position": 44961,
      "parent_fls_id": "fls_jm6l7b90h6wa",
      "sibling_fls_ids": [
        "fls_vnai6ag4qrdb",
        "fls_azzf1llv3wf",
        "fls_5loglxds6zik",
        "fls_d44aflefat88",
        "fls_fyskeih6twyb",
        "fls_org6hqv397fp",
        "fls_57ic33pwdvp3",
        "fls_asj8rgccvkoe",
        "fls_rce8bb7nz2jy",
        "fls_yc4xm4hrfyw7"
      ]
    },
    {
      "fls_id": "fls_rce8bb7nz2jy",
      "title": "Tuple Pattern Matching",
      "level": 3,
      "file": "patterns",
      "content": "Tuple Pattern Matching\n\nTuple pattern matching proceeds as follows:\n\n#. For each subpattern of the tuple pattern\n\n #. Perform pattern matching with the subpattern and the\n corresponding field from the context value, ignoring\n [rest pattern]s.\n\n #. If matching the subpattern fails, then matching fails.",
      "paragraph_ids": [
        "fls_w4xypnrnhycb",
        "fls_vnx1bpval595",
        "fls_dzf32f40y7fr",
        "fls_krl32txvxxkz"
      ],
      "position": 45546,
      "parent_fls_id": "fls_jm6l7b90h6wa",
      "sibling_fls_ids": [
        "fls_vnai6ag4qrdb",
        "fls_azzf1llv3wf",
        "fls_5loglxds6zik",
        "fls_d44aflefat88",
        "fls_fyskeih6twyb",
        "fls_org6hqv397fp",
        "fls_57ic33pwdvp3",
        "fls_asj8rgccvkoe",
        "fls_eexupzdsu7f",
        "fls_yc4xm4hrfyw7"
      ]
    },
    {
      "fls_id": "fls_yc4xm4hrfyw7",
      "title": "Underscore Pattern Matching",
      "level": 3,
      "file": "patterns",
      "content": "Underscore Pattern Matching\n\nUnderscore pattern matching proceeds as follows:\n\n#. The context value is matched unconditionally.\n\n#. Matching succeeds.",
      "paragraph_ids": [
        "fls_dvk7r1gf7pwp",
        "fls_e0uprihqn1y6",
        "fls_ljcq2vyo052q"
      ],
      "position": 46094,
      "parent_fls_id": "fls_jm6l7b90h6wa",
      "sibling_fls_ids": [
        "fls_vnai6ag4qrdb",
        "fls_azzf1llv3wf",
        "fls_5loglxds6zik",
        "fls_d44aflefat88",
        "fls_fyskeih6twyb",
        "fls_org6hqv397fp",
        "fls_57ic33pwdvp3",
        "fls_asj8rgccvkoe",
        "fls_eexupzdsu7f",
        "fls_rce8bb7nz2jy"
      ]
    },
    {
      "fls_id": "fls_hdwwrsyunir",
      "title": "Program Structure and Compilation",
      "level": 1,
      "file": "program-structure-and-compilation",
      "content": "Program Structure and Compilation",
      "paragraph_ids": [],
      "position": 125,
      "parent_fls_id": null,
      "sibling_fls_ids": [
        "fls_l21tjqjkkaa0",
        "fls_gvwd0kf72jt",
        "fls_3v733mnewssy",
        "fls_gdeyap4or1db",
        "fls_dzq9cdz4ibsz",
        "fls_ckvjj4tt1hh2",
        "fls_osd6c4utyjb3",
        "fls_qcb1n9c0e5hz",
        "fls_48qldfwwh493",
        "fls_y2k5paj8m8ug",
        "fls_fk2m2irwpeof",
        "fls_z1il3w9nulzy",
        "fls_wb86edg02t6a",
        "fls_411up5z0b6n6",
        "fls_83182bfa9uqb",
        "fls_ronnwodjjjsh",
        "fls_xgqh0ju6bmbn",
        "fls_wdicg3sqa98e",
        "fls_vgb6ev541b2r",
        "fls_EBwqH60SUHiN",
        "fls_jep7p27kaqlp",
        "fls_94a8v54bufn8"
      ]
    },
    {
      "fls_id": "fls_s35hob3i7lr",
      "title": "Source Files",
      "level": 2,
      "file": "program-structure-and-compilation",
      "content": "Source Files\n\n ZeroWidthNoBreakSpace ::=\n $$\\u{FEFF}$$\n\n Shebang ::=\n $$#!$$ ~[NewLine]*\n\n NewLine ::=\n $$\\n$$\n\nA source file contains the program text consisting of [inner\nattribute]s, [inner doc comment]s, and [item]s. The location of a\nsource file is tool defined.\n\nA :s:`Shebang` does not have an effect on the compilation.",
      "paragraph_ids": [
        "fls_4vicosdeaqmp",
        "fls_ann3cha1xpek"
      ],
      "position": 216,
      "parent_fls_id": "fls_hdwwrsyunir",
      "sibling_fls_ids": [
        "fls_e9hwvqsib5d5",
        "fls_maw4u1o8q37u",
        "fls_gklst7joeo33",
        "fls_5w50kf83oo1u",
        "fls_u1afezy1ye99",
        "fls_8JB3SJqamdpU"
      ]
    },
    {
      "fls_id": "fls_e9hwvqsib5d5",
      "title": "Modules",
      "level": 2,
      "file": "program-structure-and-compilation",
      "content": "Modules\n\n ModuleSpecification ::=\n InlineModuleSpecification\n | OutlineModuleSpecification\n\n InlineModuleSpecification ::=\n $${$$\n InnerAttributeOrDoc*\n Item*\n $$}$$\n\n OutlineModuleSpecification ::=\n $$;$$\n\nA module is a container for zero or more [item]s.\n\nThe unsafe keyword of a module is rejected, but may still\nbe consumed by [macro]s.\n\nAn inline module is a module with an :s:`InlineModuleSpecification`.\n\nAn outline module is a module with an :s:`OutlineModuleSpecification`.\n\nAn outline module loads a source file and considers the text of the\nsource file to be inlined within the context of the outline module.\n\nThe location of a module source file can be specified using\nattribute path.",
      "paragraph_ids": [
        "fls_odd1hj3y1mgu",
        "fls_whgv72emrm47",
        "fls_qypjjpcf8uwq",
        "fls_cavwpr1ybk37",
        "fls_plepew2319g4",
        "fls_1aruwps62c4p"
      ],
      "position": 842,
      "parent_fls_id": "fls_hdwwrsyunir",
      "sibling_fls_ids": [
        "fls_s35hob3i7lr",
        "fls_maw4u1o8q37u",
        "fls_gklst7joeo33",
        "fls_5w50kf83oo1u",
        "fls_u1afezy1ye99",
        "fls_8JB3SJqamdpU"
      ]
    },
    {
      "fls_id": "fls_maw4u1o8q37u",
      "title": "Crates",
      "level": 2,
      "file": "program-structure-and-compilation",
      "content": "Crates\n\nA crate is a unit of compilation and linking that contains a tree of\nnested [module]s.\n\nThe crate type of a crate is the value of the attribute\ncrate_type of a crate or the value of --crate-type flag passed to\nthe tool compiling the crate.\n\nThe crate type of a crate if not specified is bin.\n\nA crate may be subject to multiple [crate type]s, treating each type\nas a separate crate.\n\nA binary crate is a crate whose crate type is bin.\n\nA binary crate that is not subject to attribute no_main shall have\na function in scope of its crate root module under the name\nmain with a main function signature.\n\nThe function in scope of a binary crate's crate root module under\nthe name main with a main function signature is the binary\ncrate's program entry point.\n\nA library crate is a crate whose crate type is lib, rlib,\nstaticlib, dylib, or cdylib.\n\nA proc-macro crate is a crate whose crate type is proc-macro.\n\nA proc-macro crate shall not declare [item]s in its crate root\nmodule with public visibility unless the item is a procedural\nmacro.\n\nOnly a proc-macro crate shall declare [procedural macro]s.",
      "paragraph_ids": [
        "fls_qwghk79ok5h0",
        "fls_unxalgMqIr3v",
        "fls_e7jGvXvTsFpC",
        "fls_kQiJPwb2Hjcc",
        "fls_9ub6ks8qrang",
        "fls_OyFwBtDGVimT",
        "fls_jQqXxPyND1ds",
        "fls_d9nn4yuiw1ja",
        "fls_Mf62VqAhoZ3c",
        "fls_RJJmN4tP7j4m",
        "fls_h93C3wfbAoz1"
      ],
      "position": 2159,
      "parent_fls_id": "fls_hdwwrsyunir",
      "sibling_fls_ids": [
        "fls_s35hob3i7lr",
        "fls_e9hwvqsib5d5",
        "fls_gklst7joeo33",
        "fls_5w50kf83oo1u",
        "fls_u1afezy1ye99",
        "fls_8JB3SJqamdpU"
      ]
    },
    {
      "fls_id": "fls_gklst7joeo33",
      "title": "Crate Imports",
      "level": 2,
      "file": "program-structure-and-compilation",
      "content": "Crate Imports\n\n CrateIndication ::=\n Identifier\n | $$self$$\n\nA crate import specifies a required dependency on an external crate.\n\nA crate indication is a construct that indicates a crate.\n\nA crate import binds an external crate to its crate indication.\n\nCrate indication self shall require a renaming.\n\nA crate import with a renaming with an identifier binds the\nexternal crate to a local name and introduces the local name into\nthe enclosing scope.\n\nIf a crate import appears at the crate root module, then the\ncrate indication is added to the external prelude.\n\nA crate indication shall resolve to an external crate. The process of\nresolving a crate indication to an external crate is tool-defined.",
      "paragraph_ids": [
        "fls_d0pa807s5d5h",
        "fls_vfam3wzeAiah",
        "fls_ft860vkz0lkc",
        "fls_k90qtnf8kgu1",
        "fls_siv8bl6s2ndu",
        "fls_7vz5n3x6jo1s",
        "fls_3bgpc8m8yk4p"
      ],
      "position": 3841,
      "parent_fls_id": "fls_hdwwrsyunir",
      "sibling_fls_ids": [
        "fls_s35hob3i7lr",
        "fls_e9hwvqsib5d5",
        "fls_maw4u1o8q37u",
        "fls_5w50kf83oo1u",
        "fls_u1afezy1ye99",
        "fls_8JB3SJqamdpU"
      ]
    },
    {
      "fls_id": "fls_5w50kf83oo1u",
      "title": "Compilation Roots",
      "level": 2,
      "file": "program-structure-and-compilation",
      "content": "Compilation Roots\n\nA crate root module is the root of the nested module tree of a\ncrate.\n\nA tool can define a crate root module for a single crate.\n\nA compilation root is an input to a compilation performed by a tool. A\ncrate root module is a compilation root.",
      "paragraph_ids": [
        "fls_fhiqvgdamq5",
        "fls_tk8tl2e0a34",
        "fls_bsyfxdk3ap1t"
      ],
      "position": 5032,
      "parent_fls_id": "fls_hdwwrsyunir",
      "sibling_fls_ids": [
        "fls_s35hob3i7lr",
        "fls_e9hwvqsib5d5",
        "fls_maw4u1o8q37u",
        "fls_gklst7joeo33",
        "fls_u1afezy1ye99",
        "fls_8JB3SJqamdpU"
      ]
    },
    {
      "fls_id": "fls_u1afezy1ye99",
      "title": "Conditional Compilation",
      "level": 2,
      "file": "program-structure-and-compilation",
      "content": "Conditional Compilation\n\nConditionally-compiled source code is source code that may or may\nnot be considered a part of a Rust program depending on\n[configuration predicate]s.\n\nConditional compilation is the process of compiling\nconditionally-compiled source code.\n\nA construct subject to attribute cfg where the related\nconfiguration predicate evaluates to false is not considered part of a\nRust program.\n\nA crate root module subject to attribute cfg where the related\nconfiguration predicate evaluates to false is considered empty except\nfor all [attribute]s up to the invoked attribute cfg.\n\nAn attribute cfg_attr where the related configuration predicate\nevaluates to false is not considered part of a Rust program.",
      "paragraph_ids": [
        "fls_9stc6nul6vq9",
        "fls_a0u9nnaf6drz",
        "fls_pf1v89h7pjhh",
        "fls_y56RGw3cbFex",
        "fls_h6b1fuw4nvi1"
      ],
      "position": 5470,
      "parent_fls_id": "fls_hdwwrsyunir",
      "sibling_fls_ids": [
        "fls_s35hob3i7lr",
        "fls_e9hwvqsib5d5",
        "fls_maw4u1o8q37u",
        "fls_gklst7joeo33",
        "fls_5w50kf83oo1u",
        "fls_8JB3SJqamdpU"
      ]
    },
    {
      "fls_id": "fls_8JB3SJqamdpU",
      "title": "Program Entry Point",
      "level": 2,
      "file": "program-structure-and-compilation",
      "content": "Program Entry Point\n\nA program entry point is a function that is invoked at the start of\na Rust program.\n\nA main function signature is a function signature subject to the\nfollowing restrictions:\n\n* It lacks [function qualifier]s async and unsafe,\n\n* Its ABI is Rust,\n\n* It lacks [generic parameter]s,\n\n* It lacks [function parameter]s,\n\n* It lacks a return type,\n\n* It lacks a where clause,\n\n* It has a function body.",
      "paragraph_ids": [
        "fls_dp64b08em9BJ",
        "fls_sbGnkm8Ephiu",
        "fls_o4fxok23134r",
        "fls_bk755pvc1l53",
        "fls_a3je4wc53bmo",
        "fls_w8q15zp7kyl0",
        "fls_4psnfphsgdek",
        "fls_m7xfrhqif74",
        "fls_qq9fzrw4aykd"
      ],
      "position": 6483,
      "parent_fls_id": "fls_hdwwrsyunir",
      "sibling_fls_ids": [
        "fls_s35hob3i7lr",
        "fls_e9hwvqsib5d5",
        "fls_maw4u1o8q37u",
        "fls_gklst7joeo33",
        "fls_5w50kf83oo1u",
        "fls_u1afezy1ye99"
      ]
    },
    {
      "fls_id": "fls_wdicg3sqa98e",
      "title": "Statements",
      "level": 1,
      "file": "statements",
      "content": "Statements\n\nAn expression statement is an expression whose result is ignored.\n\nAn item statement is a statement that is expressed as an item.\n\nAn empty statement is a statement expressed as character 0x3B\n(semicolon).\n\nA macro statement is a statement expressed as a\nterminated macro invocation.\n\nExecution is the process by which a statement achieves its runtime\neffects.\n\nThe execution of an empty statement has no effect.",
      "paragraph_ids": [
        "fls_7zh6ziglo5iy",
        "fls_kdxe1ukmgl1",
        "fls_fftdnwe22xrb",
        "fls_or125cqtxg9j",
        "fls_estqu395zxgk",
        "fls_dl763ssb54q1"
      ],
      "position": 125,
      "parent_fls_id": null,
      "sibling_fls_ids": [
        "fls_l21tjqjkkaa0",
        "fls_gvwd0kf72jt",
        "fls_3v733mnewssy",
        "fls_gdeyap4or1db",
        "fls_dzq9cdz4ibsz",
        "fls_ckvjj4tt1hh2",
        "fls_osd6c4utyjb3",
        "fls_qcb1n9c0e5hz",
        "fls_48qldfwwh493",
        "fls_y2k5paj8m8ug",
        "fls_fk2m2irwpeof",
        "fls_z1il3w9nulzy",
        "fls_wb86edg02t6a",
        "fls_411up5z0b6n6",
        "fls_83182bfa9uqb",
        "fls_ronnwodjjjsh",
        "fls_xgqh0ju6bmbn",
        "fls_hdwwrsyunir",
        "fls_vgb6ev541b2r",
        "fls_EBwqH60SUHiN",
        "fls_jep7p27kaqlp",
        "fls_94a8v54bufn8"
      ]
    },
    {
      "fls_id": "fls_yivm43r5wnp1",
      "title": "Let Statements",
      "level": 2,
      "file": "statements",
      "content": "Let Statements\n\n LetInitializer ::=\n $$=$$ Expression ($$else$$ BlockExpression)?\n\nA let statement is a statement that introduces new [binding]s\nproduced by its pattern-without-alternation that are optionally\ninitialized to a value.\n\nA let initializer is a construct that provides the value of\nthe [binding]s of the let statement using an expression, or\nalternatively executes a block expression.\n\nIf a let statement lacks a block expression, then the pattern of\nthe let statement shall be an irrefutable pattern.\n\nIf a let statement has a block expression, then the :s:`Expression` of\nthe :s:`LetInitializer` shall not be a :s:`LazyBooleanExpression` or end with\ntoken }.\n\nThe expected type of the pattern of the let statement is determined as follows:\n\n* If the let statement lacks a type ascription and a let initializer, then the expected type is the inferred type.\n\n* If the let statement lacks a type ascription, then the expected type is the type of the let initializer.\n\n* Otherwise the expected type is the type specified by the type ascription.\n\nThe type of a binding introduced by a let statement is\ndetermined as follows:\n\n* If the let statement appears with a type ascription, then the\n type is the type specified by the type ascription.\n\n* If the let statement lacks a type ascription, then the type is\n inferred using type inference.\n\nThe type of the block expression of a let statement shall be the\nnever type.\n\nThe value of a binding introduced by a let statement is\ndetermined as follows:\n\n* If the let statement appears with a let initializer, then the\n value is the value of the expression of the\n let initializer.\n\n* Otherwise the binding is uninitialized.\n\nThe execution of a let statement with a let initializer proceeds\nas follows:\n\n#. The expression of the let initializer is evaluated.\n\n#. If the value of the expression is matched successfully against the\n pattern of the let statement, then the value is assigned to\n each binding introduced by the let statement.\n\n#. Otherwise the block expression of the let initializer is evaluated.",
      "paragraph_ids": [
        "fls_ct7pp7jnfr86",
        "fls_SR3dIgR5K0Kq",
        "fls_iqar7vvtw22c",
        "fls_1s1UikGU5YQb",
        "fls_iB25BeFys0j8",
        "fls_zObyLdya4DYc",
        "fls_r38TXWKQPjxv",
        "fls_6QSdwF4pzjoe",
        "fls_1prqh1trybwz",
        "fls_djkm8r2iuu6u",
        "fls_ppj9gvhp8wcj",
        "fls_1eBQDZdBuDsN",
        "fls_m8a7gesa4oim",
        "fls_oaxnre7m9s10",
        "fls_t5bjwluyv8za",
        "fls_4j9riqyf4p9",
        "fls_t53g5hlabqw1",
        "fls_7j4qlwg72ege",
        "fls_ea9bRFZjH8Im"
      ],
      "position": 1007,
      "parent_fls_id": "fls_wdicg3sqa98e",
      "sibling_fls_ids": [
        "fls_1pg5ig740tg1"
      ]
    },
    {
      "fls_id": "fls_1pg5ig740tg1",
      "title": "Expression Statements",
      "level": 2,
      "file": "statements",
      "content": "Expression Statements\n\nAn expression statement is an expression whose result is ignored.\n\nThe expected type of an expression statement without character 0x3B\n(semicolon) is the unit type.\n\nThe execution of an expression statement proceeds as follows:\n\n#. The operand is evaluated.\n\n#. The value of the operand is dropped.\n\nThe following expression statement ignores the result from pop().\n\nThe following expression statement does not require a semicolon.\n\nThe following expression statement is not an index expression.",
      "paragraph_ids": [
        "fls_xmdj8uj7ixoe",
        "fls_gzzmudc1hl6s",
        "fls_kc99n8qrszxh",
        "fls_r8poocwqaglf",
        "fls_88e6s3erk8tj",
        "fls_4q90jb39apwr",
        "fls_xqtztcu8ibwq",
        "fls_2p9xnt519nbw"
      ],
      "position": 4346,
      "parent_fls_id": "fls_wdicg3sqa98e",
      "sibling_fls_ids": [
        "fls_yivm43r5wnp1"
      ]
    },
    {
      "fls_id": "fls_vgb6ev541b2r",
      "title": "Types and Traits",
      "level": 1,
      "file": "types-and-traits",
      "content": "Types and Traits",
      "paragraph_ids": [],
      "position": 125,
      "parent_fls_id": null,
      "sibling_fls_ids": [
        "fls_l21tjqjkkaa0",
        "fls_gvwd0kf72jt",
        "fls_3v733mnewssy",
        "fls_gdeyap4or1db",
        "fls_dzq9cdz4ibsz",
        "fls_ckvjj4tt1hh2",
        "fls_osd6c4utyjb3",
        "fls_qcb1n9c0e5hz",
        "fls_48qldfwwh493",
        "fls_y2k5paj8m8ug",
        "fls_fk2m2irwpeof",
        "fls_z1il3w9nulzy",
        "fls_wb86edg02t6a",
        "fls_411up5z0b6n6",
        "fls_83182bfa9uqb",
        "fls_ronnwodjjjsh",
        "fls_xgqh0ju6bmbn",
        "fls_hdwwrsyunir",
        "fls_wdicg3sqa98e",
        "fls_EBwqH60SUHiN",
        "fls_jep7p27kaqlp",
        "fls_94a8v54bufn8"
      ]
    },
    {
      "fls_id": "fls_kwsBxMQNTRnL",
      "title": "Types",
      "level": 2,
      "file": "types-and-traits",
      "content": "Types\n\n TypeSpecificationList ::=\n TypeSpecification ($$,$$ TypeSpecification)* $$,$$?\n\n TypeSpecificationWithoutBounds ::=\n ArrayTypeSpecification\n | FunctionPointerTypeSpecification\n | ImplTraitTypeSpecificationOneBound\n | InferredType\n | MacroInvocation\n | NeverType\n | ParenthesizedTypeSpecification\n | QualifiedTypePath\n | RawPointerTypeSpecification\n | ReferenceTypeSpecification\n | SliceTypeSpecification\n | TraitObjectTypeSpecificationOneBound\n | TupleTypeSpecification\n | TypePath\n\n TypeAscription ::=\n $$:$$ TypeSpecification\n\nA type defines a set of [value]s and a set of operations that act on\nthose [value]s.\n\nA local type is a type that is defined in the current crate.",
      "paragraph_ids": [
        "fls_4rhjpdu4zfqj",
        "fls_0yaYKnFrJkhG"
      ],
      "position": 183,
      "parent_fls_id": "fls_vgb6ev541b2r",
      "sibling_fls_ids": [
        "fls_963gsjp2jas2",
        "fls_id66vnaqw0zt",
        "fls_fbchw64p6n2x",
        "fls_wdec78luqh5b",
        "fls_hbbek3z4wtcs",
        "fls_3i4ou0dq64ny",
        "fls_1ompd93w7c9f",
        "fls_3pbipk8ki18d",
        "fls_kgvleup5mdhq",
        "fls_7pby13muw48o",
        "fls_j02707n615z0",
        "fls_85vx1qfa061i",
        "fls_jeoas4n6su4"
      ]
    },
    {
      "fls_id": "fls_963gsjp2jas2",
      "title": "Type Classification",
      "level": 2,
      "file": "types-and-traits",
      "content": "Type Classification\n\n[Type]s are organized in the following categories:\n\n* [Scalar type]s\n\n * Bool type\n\n * Char type\n\n * [Numeric type]s\n\n * Floating-point type\n\n * Integer type\n\n* [Sequence type]s\n\n * [Array type]s\n\n * [Slice type]s\n\n * Str type\n\n * [Tuple type]s\n\n* [Abstract data type]s\n\n * [Enum type]s\n\n * [Struct type]s\n\n * [Union type]s\n\n* [Function type]s\n\n * [Closure type]s\n\n * [Function item type]s\n\n* [Indirection type]s\n\n * [Function pointer type]s\n\n * [Raw pointer type]s\n\n * [Reference type]s\n\n* [Trait type]s\n\n * [Impl trait type]s\n\n * [Trait object type]s\n\n* Other [type]s\n\n * [Inferred type]s\n\n * Never type\n\n * [Parenthesized type]s",
      "paragraph_ids": [
        "fls_c4xe3pkn0n3o",
        "fls_69zyas59o8ff",
        "fls_65hcyqizo1da",
        "fls_zge99l49az8w",
        "fls_vizoconv3ir",
        "fls_ne6bgnh1eyrj",
        "fls_jvj8l8366kl2",
        "fls_eek1jn1rwjh9",
        "fls_s0aduyvz4i7f",
        "fls_zb5e79ai7w5i",
        "fls_yjp19vt46asy",
        "fls_xflj5df6upc7",
        "fls_u43jnp9jnw29",
        "fls_lric8bf631nw",
        "fls_98djh9avlqc0",
        "fls_b3ymsm8dmo4",
        "fls_9x5atvhdq0j2",
        "fls_n5rgqgnxk9to",
        "fls_s7ndqc5sizdy",
        "fls_jrohsv7hx7yw",
        "fls_1kg1mknf4yx7",
        "fls_bw8zutjcteki",
        "fls_nqezuc9u6wpn",
        "fls_lh52q6f6snfh",
        "fls_qqg0uixrd1a4",
        "fls_b8ecqp2argmn",
        "fls_m5vtcars8aga",
        "fls_lw38557rqikt",
        "fls_jxn63ow9xby3",
        "fls_a81tweobvm0p"
      ],
      "position": 1244,
      "parent_fls_id": "fls_vgb6ev541b2r",
      "sibling_fls_ids": [
        "fls_kwsBxMQNTRnL",
        "fls_id66vnaqw0zt",
        "fls_fbchw64p6n2x",
        "fls_wdec78luqh5b",
        "fls_hbbek3z4wtcs",
        "fls_3i4ou0dq64ny",
        "fls_1ompd93w7c9f",
        "fls_3pbipk8ki18d",
        "fls_kgvleup5mdhq",
        "fls_7pby13muw48o",
        "fls_j02707n615z0",
        "fls_85vx1qfa061i",
        "fls_jeoas4n6su4"
      ]
    },
    {
      "fls_id": "fls_id66vnaqw0zt",
      "title": "Scalar Types",
      "level": 2,
      "file": "types-and-traits",
      "content": "Scalar Types",
      "paragraph_ids": [],
      "position": 2982,
      "parent_fls_id": "fls_vgb6ev541b2r",
      "sibling_fls_ids": [
        "fls_kwsBxMQNTRnL",
        "fls_963gsjp2jas2",
        "fls_fbchw64p6n2x",
        "fls_wdec78luqh5b",
        "fls_hbbek3z4wtcs",
        "fls_3i4ou0dq64ny",
        "fls_1ompd93w7c9f",
        "fls_3pbipk8ki18d",
        "fls_kgvleup5mdhq",
        "fls_7pby13muw48o",
        "fls_j02707n615z0",
        "fls_85vx1qfa061i",
        "fls_jeoas4n6su4"
      ]
    },
    {
      "fls_id": "fls_tiqp1gxf116z",
      "title": "Bool Type",
      "level": 3,
      "file": "types-and-traits",
      "content": "Bool Type\n\nBool is a type whose [value]s denote the truth [value]s of\nlogic and Boolean algebra.\n\nType bool appears in the language prelude under the name\nbool.\n\nBoolean value false has bit pattern 0x00. Boolean value\ntrue has bit pattern 0x01.\n\nThe following operations are defined on type bool:\n\n**Logical not**\n\n**Logical and**\n\n**Logical or**\n\n**Logical exclusive or (xor)**\n\n**Equality**\n\n**Greater than**\n\nOperation a != b is equivalent to !(a == b).\n\nOperation a >= b is equivalent to a == b | a > b.\n\nOperation a < b is equivalent to !(a >= b).\n\nOperation a <= b is equivalent to a == b | a < b.\n\nIt is a validity invariant for a value of type bool to have\na bit pattern of 0x00 and 0x01.",
      "paragraph_ids": [
        "fls_h5994su1yft3",
        "fls_v8atmrwz6wzk",
        "fls_iye7ho2ynyhn",
        "fls_7nd5tixyqir8",
        "fls_w2dzqq54fjhb",
        "fls_ufmd38hi9t9y",
        "fls_5allcjkjnon2",
        "fls_3bibysz95ktn",
        "fls_fxq19dqtmifj",
        "fls_drhpcwoblcux",
        "fls_v86qrsqcs3nd",
        "fls_dd49lb2k3erc",
        "fls_t6ef5x4x5poi",
        "fls_kqtgjgn1hqrj",
        "fls_ws15ilzf8n6z",
        "fls_ni4mgq3mouek",
        "fls_6c9ax4qsr1gy",
        "fls_sqcgvpr4egtx",
        "fls_9ys0itbp4okd",
        "fls_b46gbyid15zx",
        "fls_f8ag276ecbze",
        "fls_twwjcrcfirdi",
        "fls_wovu7330vdrq",
        "fls_7xopdco6iy74",
        "fls_nb5cb6en2p5w",
        "fls_gd28wfcfs2pv",
        "fls_67a7p57nzbul",
        "fls_cq0qunw51m94",
        "fls_o1e4tnh7v3db",
        "fls_6vnv3ygisjr",
        "fls_s6m9abmmtc9i",
        "fls_s19vu65z96y5",
        "fls_2d4aqspw0wlt",
        "fls_msjo2zd67zn1",
        "fls_w1oti03tm1y6",
        "fls_9gqd7eevbknt",
        "fls_r4o2rmhqg4br",
        "fls_1n7p6ij1dpm",
        "fls_4x27kfiodb8",
        "fls_me6bf9m2ypt",
        "fls_2j659ns8wop4",
        "fls_d09l2rl0161l",
        "fls_2sd39mj05mb9"
      ],
      "position": 3032,
      "parent_fls_id": "fls_id66vnaqw0zt",
      "sibling_fls_ids": [
        "fls_wrvjizrqf3po",
        "fls_qwljwqr07slp"
      ]
    },
    {
      "fls_id": "fls_wrvjizrqf3po",
      "title": "Char Type",
      "level": 3,
      "file": "types-and-traits",
      "content": "Char Type\n\nChar is a type whose [value]s are represented as a 32-bit\nunsigned word in the 0x000 - 0xD7FF or the 0xE000 - 0x10FFFF inclusive ranges\nof Unicode.\n\nIt is a validity invariant for a value of type char to be\ninside the 0x000 - 0xD7FF or the 0xE000 - 0x10FFFF inclusive ranges of\nUnicode.",
      "paragraph_ids": [
        "fls_vnwbs0exbwcn",
        "fls_juysxea25owj"
      ],
      "position": 6547,
      "parent_fls_id": "fls_id66vnaqw0zt",
      "sibling_fls_ids": [
        "fls_tiqp1gxf116z",
        "fls_qwljwqr07slp"
      ]
    },
    {
      "fls_id": "fls_qwljwqr07slp",
      "title": "Numeric Types",
      "level": 3,
      "file": "types-and-traits",
      "content": "Numeric Types",
      "paragraph_ids": [],
      "position": 7030,
      "parent_fls_id": "fls_id66vnaqw0zt",
      "sibling_fls_ids": [
        "fls_tiqp1gxf116z",
        "fls_wrvjizrqf3po"
      ]
    },
    {
      "fls_id": "fls_b4xporvr64s",
      "title": "Floating Point Types",
      "level": 4,
      "file": "types-and-traits",
      "content": "Floating Point Types\n\nType f32 is equivalent to the IEEE 754-2008 binary32 type.\n\nType f64 is equivalent to the IEEE 754-2008 binary64 type.\n\nOperations on values of [floating point type]s may not preserve the sign bit in case of the value being a IEEE floating-point NaN.",
      "paragraph_ids": [
        "fls_30yny2xb9b6b",
        "fls_yqflrq9s6p6n",
        "fls_nuFAwLHOdQBx"
      ],
      "position": 7082,
      "parent_fls_id": "fls_qwljwqr07slp",
      "sibling_fls_ids": [
        "fls_3qnpv2z7yjil"
      ]
    },
    {
      "fls_id": "fls_3qnpv2z7yjil",
      "title": "Integer Types",
      "level": 4,
      "file": "types-and-traits",
      "content": "Integer Types\n\n[Unsigned integer type]s define the following inclusive ranges over the\ndomain of whole numbers:\n\nType usize has the same number of bits as the platform's\npointer type, and is at least 16-bits wide.\n\n[Signed integer type]s define the following inclusive ranges over the\ndomain of whole numbers:\n\nType isize has the same number of bits as the platform's\npointer type, and is at least 16-bits wide.",
      "paragraph_ids": [
        "fls_cokwseo3nnr",
        "fls_vk1skn6ek36u",
        "fls_iikexw8ps6mk",
        "fls_cavasxxlgs7g",
        "fls_7sx92xsjx3pl",
        "fls_q9f95uet7gq4",
        "fls_yjb3kzijd19v",
        "fls_75lntwhg20l",
        "fls_p2shoji3xg5a",
        "fls_fsyt05u9y4sl",
        "fls_p9ffvtajr832",
        "fls_j6xan9f8udw7",
        "fls_4t39p3ibkzu7",
        "fls_egfoxke0lzje",
        "fls_4c4qpel1tbqs",
        "fls_t9oyfmgqka6u"
      ],
      "position": 7566,
      "parent_fls_id": "fls_qwljwqr07slp",
      "sibling_fls_ids": [
        "fls_b4xporvr64s"
      ]
    },
    {
      "fls_id": "fls_fbchw64p6n2x",
      "title": "Sequence Types",
      "level": 2,
      "file": "types-and-traits",
      "content": "Sequence Types",
      "paragraph_ids": [],
      "position": 9248,
      "parent_fls_id": "fls_vgb6ev541b2r",
      "sibling_fls_ids": [
        "fls_kwsBxMQNTRnL",
        "fls_963gsjp2jas2",
        "fls_id66vnaqw0zt",
        "fls_wdec78luqh5b",
        "fls_hbbek3z4wtcs",
        "fls_3i4ou0dq64ny",
        "fls_1ompd93w7c9f",
        "fls_3pbipk8ki18d",
        "fls_kgvleup5mdhq",
        "fls_7pby13muw48o",
        "fls_j02707n615z0",
        "fls_85vx1qfa061i",
        "fls_jeoas4n6su4"
      ]
    },
    {
      "fls_id": "fls_uj0kpjwyld60",
      "title": "Array Types",
      "level": 3,
      "file": "types-and-traits",
      "content": "Array Types\n\n ElementType ::=\n TypeSpecification\n\nAn array type is a sequence type that represents a fixed sequence\nof elements.\n\nThe element type shall be a fixed sized type.\n\nThe size operand shall be a constant expression\nor an inferred constant.\n\nThe type of the size operand is type usize.\n\nAn array type in the context of a let statement:",
      "paragraph_ids": [
        "fls_fx7b3qv3ghca",
        "fls_pkts1p2dnxo",
        "fls_imr2jx6cbuzq",
        "fls_r8nqxry2dlww",
        "fls_9vjijqi9w8wn"
      ],
      "position": 9302,
      "parent_fls_id": "fls_fbchw64p6n2x",
      "sibling_fls_ids": [
        "fls_vpbikb73dw4k",
        "fls_4agmmu5al6gt",
        "fls_4ckl3n2ko3i4"
      ]
    },
    {
      "fls_id": "fls_vpbikb73dw4k",
      "title": "Slice Types",
      "level": 3,
      "file": "types-and-traits",
      "content": "Slice Types\n\nA slice type is a sequence type that provides a view into a sequence\nof elements.\n\nThe element type shall be a fixed sized type.\n\nA slice type is a dynamically sized type.\n\nA slice type in the context of a let statement:",
      "paragraph_ids": [
        "fls_ftvua2hlvr08",
        "fls_acgtczhk8ci0",
        "fls_5gl67ftc3m21",
        "fls_nsny832ap4v1"
      ],
      "position": 10082,
      "parent_fls_id": "fls_fbchw64p6n2x",
      "sibling_fls_ids": [
        "fls_uj0kpjwyld60",
        "fls_4agmmu5al6gt",
        "fls_4ckl3n2ko3i4"
      ]
    },
    {
      "fls_id": "fls_4agmmu5al6gt",
      "title": "Str Type",
      "level": 3,
      "file": "types-and-traits",
      "content": "Str Type\n\nStr is a sequence type that represents a slice of 8-bit unsigned\nbytes.\n\nType str is a dynamically sized type.\n\nA value of type str shall denote a valid UTF-8 sequence of\ncharacters.\n\nIt is a safety invariant for a value of type str to denote\na valid UTF-8 sequence of characters.",
      "paragraph_ids": [
        "fls_wlnoq1qoq2kr",
        "fls_1xa6fas6laha",
        "fls_yu7r2077n9m7",
        "fls_wacoqrtzvrwu"
      ],
      "position": 10715,
      "parent_fls_id": "fls_fbchw64p6n2x",
      "sibling_fls_ids": [
        "fls_uj0kpjwyld60",
        "fls_vpbikb73dw4k",
        "fls_4ckl3n2ko3i4"
      ]
    },
    {
      "fls_id": "fls_4ckl3n2ko3i4",
      "title": "Tuple Types",
      "level": 3,
      "file": "types-and-traits",
      "content": "Tuple Types\n\n TupleFieldList ::=\n TupleField ($$,$$ TupleField)* $$,$$?\n\n TupleField ::=\n TypeSpecification\n\nA tuple type is a sequence type that represents a heterogeneous list\nof other [type]s.\n\nIf the type of a tuple field is a dynamically-sized type, then\nthe tuple field shall be the last tuple field in the\n:s:`TupleFieldList`.",
      "paragraph_ids": [
        "fls_bn7wmf681ngt",
        "fls_s9a36zsrfqew"
      ],
      "position": 11256,
      "parent_fls_id": "fls_fbchw64p6n2x",
      "sibling_fls_ids": [
        "fls_uj0kpjwyld60",
        "fls_vpbikb73dw4k",
        "fls_4agmmu5al6gt"
      ]
    },
    {
      "fls_id": "fls_wdec78luqh5b",
      "title": "Abstract Data Types",
      "level": 2,
      "file": "types-and-traits",
      "content": "Abstract Data Types",
      "paragraph_ids": [],
      "position": 11944,
      "parent_fls_id": "fls_vgb6ev541b2r",
      "sibling_fls_ids": [
        "fls_kwsBxMQNTRnL",
        "fls_963gsjp2jas2",
        "fls_id66vnaqw0zt",
        "fls_fbchw64p6n2x",
        "fls_hbbek3z4wtcs",
        "fls_3i4ou0dq64ny",
        "fls_1ompd93w7c9f",
        "fls_3pbipk8ki18d",
        "fls_kgvleup5mdhq",
        "fls_7pby13muw48o",
        "fls_j02707n615z0",
        "fls_85vx1qfa061i",
        "fls_jeoas4n6su4"
      ]
    },
    {
      "fls_id": "fls_szibmtfv117b",
      "title": "Enum Types",
      "level": 3,
      "file": "types-and-traits",
      "content": "Enum Types\n\n EnumVariantList ::=\n EnumVariant ($$,$$ EnumVariant)* $$,$$?\n\n EnumVariant ::=\n OuterAttributeOrDoc* VisibilityModifier? Name EnumVariantKind?\n\n EnumVariantKind ::=\n DiscriminantInitializer\n | RecordStructFieldList\n | TupleStructFieldList\n\n DiscriminantInitializer ::=\n $$=$$ Expression\n\nAn enum type is an abstract data type that contains\n[enum variant]s.\n\nA zero-variant enum type has no [value]s.\n\nAn enum variant is a construct that declares one of the\npossible variations of an enum.\n\nThe name of an enum variant shall be unique within the related\n:s:`EnumDeclaration`.\n\nA discriminant is an opaque integer that identifies an enum variant.\n\nA discriminant initializer shall be specified only when all [enum\nvariant]s appear without an :s:`EnumVariantKind`.\n\nThe type of the expression of a discriminant initializer shall\nbe either:\n\n* The type of the primitive representation specified by attribute\n repr, or\n\n* Type isize.\n\nThe value of the expression of a discriminant initializer shall\nbe a constant expression.\n\nThe value of a discriminant of an enum variant is determined\nas follows:\n\n#. If the enum variant contains a discriminant initializer, then the\n value is the value of its expression.\n\n#. Otherwise, if the enum variant is the first enum variant in the\n :s:`EnumVariantList`, then the value is zero.\n\n#. Otherwise the value is one greater than the value of the\n discriminant of the previous enum variant.\n\nIt is a static error if two [enum variant]s have [discriminant]s\nwith the same value.\n\nIt is a static error if the value of a discriminant exceeds the\nmaximum value of the type of the expression of a discriminant\ninitializer.\n\nIt is a validity invariant for a value of an enum type to have a\ndiscriminant specified by the enum type.",
      "paragraph_ids": [
        "fls_gbdd37seqoab",
        "fls_il9a1olqmu38",
        "fls_wQTFwl88VujQ",
        "fls_g5qle7xzaoif",
        "fls_t4yeovFm83Wo",
        "fls_hp5frc752dam",
        "fls_pijczoq4k9ij",
        "fls_x7nh42on06bg",
        "fls_duqbzvpuehvv",
        "fls_ly183pj4fkgh",
        "fls_w7sggezgq9o4",
        "fls_93l5o6qar5p2",
        "fls_t36rk3wikq28",
        "fls_8ajw5trd23wi",
        "fls_w9xj26ej869w",
        "fls_wqbuof7kxsrg",
        "fls_f046du2fkgr6"
      ],
      "position": 12008,
      "parent_fls_id": "fls_wdec78luqh5b",
      "sibling_fls_ids": [
        "fls_9ucqbbd0s2yo",
        "fls_fmdn7n7s413d"
      ]
    },
    {
      "fls_id": "fls_9ucqbbd0s2yo",
      "title": "Struct Types",
      "level": 3,
      "file": "types-and-traits",
      "content": "Struct Types\n\n RecordStructDeclaration ::=\n $$struct$$ Name GenericParameterList? WhereClause? RecordStructFieldList\n\n RecordStructFieldList ::=\n $${$$ (RecordStructField ($$,$$ RecordStructField)* $$,$$?)? $$}$$\n\n RecordStructField ::=\n OuterAttributeOrDoc* VisibilityModifier? Name TypeAscription\n\n TupleStructDeclaration ::=\n $$struct$$ Name GenericParameterList? TupleStructFieldList WhereClause? $$;$$\n\n TupleStructFieldList ::=\n $$($$ (TupleStructField ($$,$$ TupleStructField)* $$,$$?)? $$)$$\n\n TupleStructField ::=\n OuterAttributeOrDoc* VisibilityModifier? TypeSpecification\n\n UnitStructDeclaration ::=\n $$struct$$ Name GenericParameterList? WhereClause? $$;$$\n\nA struct type is an abstract data type that is a product of other\n[type]s.\n\nThe name of a record struct field shall be unique within the\nrelated :s:`RecordStructDeclaration`.\n\nIf the type of a record struct field is a dynamically sized type,\nthen the record struct field shall be the last record struct field in\nthe :s:`RecordStructFieldList`.\n\nIf the type of a tuple struct field is a dynamically sized type,\nthen the tuple struct field shall be the last tuple struct field in\nthe :s:`TupleStructFieldList`.",
      "paragraph_ids": [
        "fls_g1azfj548136",
        "fls_r885av95eivp",
        "fls_auurdv1zvzb",
        "fls_vce7w0904du5"
      ],
      "position": 15231,
      "parent_fls_id": "fls_wdec78luqh5b",
      "sibling_fls_ids": [
        "fls_szibmtfv117b",
        "fls_fmdn7n7s413d"
      ]
    },
    {
      "fls_id": "fls_fmdn7n7s413d",
      "title": "Union Types",
      "level": 3,
      "file": "types-and-traits",
      "content": "Union Types\n\nA union type is an abstract data type that is a sum of other\n[type]s.\n\nA union without any [union field]s is rejected, but may still be consumed by\n[macro]s.\n\nThe name of a union field shall be unique within the related\n:s:`RecordStructDeclaration`.\n\nThe type of a union field shall be either:\n\n* A copy type, or\n\n* A mutable reference type, or\n\n* core::mem::ManuallyDrop, or\n\n* A tuple type whose [tuple field]s' [type]s are all valid\n union field [type]s, or\n\n* An array type whose element type is a valid union field\n [type]s.",
      "paragraph_ids": [
        "fls_nskmnzq95yqm",
        "fls_I5fN5Fmo5CyK",
        "fls_1caus8ybmfli",
        "fls_ZJG2Q6lJYXhY",
        "fls_hLTnHnZuaHve",
        "fls_JWgSckDtN13c",
        "fls_sXZknxozJxtC",
        "fls_vgNK01SXacnx",
        "fls_bQhh3zHAKjSu"
      ],
      "position": 17080,
      "parent_fls_id": "fls_wdec78luqh5b",
      "sibling_fls_ids": [
        "fls_szibmtfv117b",
        "fls_9ucqbbd0s2yo"
      ]
    },
    {
      "fls_id": "fls_hbbek3z4wtcs",
      "title": "Function Types",
      "level": 2,
      "file": "types-and-traits",
      "content": "Function Types",
      "paragraph_ids": [],
      "position": 18280,
      "parent_fls_id": "fls_vgb6ev541b2r",
      "sibling_fls_ids": [
        "fls_kwsBxMQNTRnL",
        "fls_963gsjp2jas2",
        "fls_id66vnaqw0zt",
        "fls_fbchw64p6n2x",
        "fls_wdec78luqh5b",
        "fls_3i4ou0dq64ny",
        "fls_1ompd93w7c9f",
        "fls_3pbipk8ki18d",
        "fls_kgvleup5mdhq",
        "fls_7pby13muw48o",
        "fls_j02707n615z0",
        "fls_85vx1qfa061i",
        "fls_jeoas4n6su4"
      ]
    },
    {
      "fls_id": "fls_xd2oxlebhs14",
      "title": "Closure Types",
      "level": 3,
      "file": "types-and-traits",
      "content": "Closure Types\n\nA closure type is a unique anonymous function type that encapsulates\nall [capture target]s of a closure expression.\n\nA closure type implements the core::ops::FnOnce trait.\n\nA closure type that does not move out its [capture target]s\nimplements the core::ops::FnMut trait.\n\nA closure type that does not move out or mutate its [capture target]s\nimplements the core::ops::Fn trait.\n\nA closure type that does not encapsulate [capture target]s is\ncoercible to a function pointer type.\n\nA closure type implicitly implements the core::marker::Copy\ntrait if all the [type]s of the [value]s of the\ncapturing environment implement the core::marker::Copy trait.\n\nA closure type implicitly implements the core::clone::Clone\ntrait if all the [type]s of the [value]s of the\ncapturing environment implement the core::clone::Clone trait.\n\nA closure type implicitly implements the core::marker::Send\ntrait if all the [type]s of the [value]s of the\ncapturing environment implement the core::marker::Send trait.\n\nA closure type implicitly implements the core::marker::Sync\ntrait if all the [type]s of the [value]s of the capturing\nenvironment implement the core::marker::Send trait.",
      "paragraph_ids": [
        "fls_bsykgnbatpmi",
        "fls_zfj4l8bigdg0",
        "fls_bn0ueivujnqk",
        "fls_u01kt5glbuz8",
        "fls_3jeootwe6ucu",
        "fls_63jqtyw0rz8c",
        "fls_3c4g9njja5s5",
        "fls_2nuhy0ujgq18",
        "fls_5jh07heok8sy"
      ],
      "position": 18334,
      "parent_fls_id": "fls_hbbek3z4wtcs",
      "sibling_fls_ids": [
        "fls_airvr79xkcag"
      ]
    },
    {
      "fls_id": "fls_airvr79xkcag",
      "title": "Function Item Types",
      "level": 3,
      "file": "types-and-traits",
      "content": "Function Item Types\n\nA function item type is a unique anonymous function type that\nidentifies a function.\n\nAn external function item type is a function item type where the\nrelated function is an external function.\n\nAn unsafe function item type is a function item type where the related\nfunction is an unsafe function.\n\nA function item type is coercible to a function pointer type.\n\nA function item type implements the core::clone::Clone trait,\nthe core::marker::Copy trait, the core::ops::Fn trait,\nthe core::ops::FnMut trait, the core::ops::FnOnce trait,\nthe core::marker::Send trait, and the core::marker::Sync\ntrait.",
      "paragraph_ids": [
        "fls_t24iojx7yc23",
        "fls_sas3ahcshnrh",
        "fls_liwnzwu1el1i",
        "fls_e9x4f7qxvvjv",
        "fls_1941wid94hlg"
      ],
      "position": 20058,
      "parent_fls_id": "fls_hbbek3z4wtcs",
      "sibling_fls_ids": [
        "fls_xd2oxlebhs14"
      ]
    },
    {
      "fls_id": "fls_3i4ou0dq64ny",
      "title": "Indirection Types",
      "level": 2,
      "file": "types-and-traits",
      "content": "Indirection Types",
      "paragraph_ids": [],
      "position": 21019,
      "parent_fls_id": "fls_vgb6ev541b2r",
      "sibling_fls_ids": [
        "fls_kwsBxMQNTRnL",
        "fls_963gsjp2jas2",
        "fls_id66vnaqw0zt",
        "fls_fbchw64p6n2x",
        "fls_wdec78luqh5b",
        "fls_hbbek3z4wtcs",
        "fls_1ompd93w7c9f",
        "fls_3pbipk8ki18d",
        "fls_kgvleup5mdhq",
        "fls_7pby13muw48o",
        "fls_j02707n615z0",
        "fls_85vx1qfa061i",
        "fls_jeoas4n6su4"
      ]
    },
    {
      "fls_id": "fls_xztr1kebz8bo",
      "title": "Function Pointer Types",
      "level": 3,
      "file": "types-and-traits",
      "content": "Function Pointer Types\n\n FunctionPointerTypeQualifierList ::=\n $$unsafe$$? AbiSpecification?\n\n FunctionPointerTypeParameterList ::=\n FunctionPointerTypeParameter ($$,$$ FunctionPointerTypeParameter)*\n ($$,$$ VariadicPart | $$,$$?)\n\n VariadicPart ::=\n OuterAttributeOrDoc* $$...$$\n\n FunctionPointerTypeParameter ::=\n OuterAttributeOrDoc* (IdentifierOrUnderscore $$:$$)? TypeSpecification\n\nA function pointer type is an indirection type that refers to a\nfunction.\n\nAn unsafe function pointer type is a function pointer type subject to\nkeyword unsafe.\n\nA variadic part indicates the presence of C-like optional\nparameters.\n\nA variadic part can only be used in a variadic function.\n\nThe return type of a function pointer type is determined as follows:\n\n* If the function pointer type specifies a :s:`ReturnTypeWithoutBounds`, then the return type is the specified :s:`ReturnTypeWithoutBounds`.\n\n* Otherwise the return type is the unit type.\n\nIt is a validity invariant for a value of a function pointer type\nto be not null.",
      "paragraph_ids": [
        "fls_v2wrytr3t04h",
        "fls_5dd7icjcl3nt",
        "fls_B0SMXRqQMS1E",
        "fls_hbn1l42xmr3h",
        "fls_g1iYVw7upBnH",
        "fls_8gpvNJfVlyaD",
        "fls_KcI6yK0P8Onn",
        "fls_52thmi9hnoks"
      ],
      "position": 21079,
      "parent_fls_id": "fls_3i4ou0dq64ny",
      "sibling_fls_ids": [
        "fls_ppd1xwve3tr7",
        "fls_142vncdktbin"
      ]
    },
    {
      "fls_id": "fls_ppd1xwve3tr7",
      "title": "Raw Pointer Types",
      "level": 3,
      "file": "types-and-traits",
      "content": "Raw Pointer Types\n\nA raw pointer type is an indirection type without validity guarantees.\n\nA mutable raw pointer type is a raw pointer type subject to\nkeyword mut.\n\nAn immutable raw pointer type is a raw pointer type subject to\nkeyword const.\n\nComparing two [value]s of [raw pointer type]s compares the addresses\nof the [value]s.\n\nComparing a value of a raw pointer type to a value of a\ndynamically sized type compares the data being pointed to.",
      "paragraph_ids": [
        "fls_rpbhr0xukbx9",
        "fls_bYWfGDAQcWfA",
        "fls_8uWfFAsZeRCs",
        "fls_hrum767l6dte",
        "fls_k6ues2936pjq"
      ],
      "position": 22853,
      "parent_fls_id": "fls_3i4ou0dq64ny",
      "sibling_fls_ids": [
        "fls_xztr1kebz8bo",
        "fls_142vncdktbin"
      ]
    },
    {
      "fls_id": "fls_142vncdktbin",
      "title": "Reference Types",
      "level": 3,
      "file": "types-and-traits",
      "content": "Reference Types\n\nA reference type is an indirection type with ownership.\n\nA shared reference type is a reference type not subject to\nkeyword mut.\n\nA shared reference type prevents the direct mutation of a referenced\nvalue.\n\nA shared reference type implements the core::marker::Copy\ntrait. Copying a shared reference performs a shallow copy.\n\nReleasing a shared reference has no effect on the value it refers to.\n\nA mutable reference type is a reference type subject to keyword\nmut.\n\nA mutable reference type allows the direct mutation of a referenced\nvalue.\n\nA mutable reference type does not implement the copy::marker::Copy\ntrait.\n\nIt is validity invariant for a value of a reference type to be\nnot null.",
      "paragraph_ids": [
        "fls_twhq24s8kchh",
        "fls_w4NbA7WhZfR2",
        "fls_ie0avzljmxfm",
        "fls_15zdiqsm1q3p",
        "fls_csdjfwczlzfd",
        "fls_GUZuiST7ucib",
        "fls_vaas9kns4zo6",
        "fls_n6ffcms5pr0r",
        "fls_ezh8aq6fmdvz"
      ],
      "position": 23775,
      "parent_fls_id": "fls_3i4ou0dq64ny",
      "sibling_fls_ids": [
        "fls_xztr1kebz8bo",
        "fls_ppd1xwve3tr7"
      ]
    },
    {
      "fls_id": "fls_1ompd93w7c9f",
      "title": "Trait Types",
      "level": 2,
      "file": "types-and-traits",
      "content": "Trait Types",
      "paragraph_ids": [],
      "position": 25140,
      "parent_fls_id": "fls_vgb6ev541b2r",
      "sibling_fls_ids": [
        "fls_kwsBxMQNTRnL",
        "fls_963gsjp2jas2",
        "fls_id66vnaqw0zt",
        "fls_fbchw64p6n2x",
        "fls_wdec78luqh5b",
        "fls_hbbek3z4wtcs",
        "fls_3i4ou0dq64ny",
        "fls_3pbipk8ki18d",
        "fls_kgvleup5mdhq",
        "fls_7pby13muw48o",
        "fls_j02707n615z0",
        "fls_85vx1qfa061i",
        "fls_jeoas4n6su4"
      ]
    },
    {
      "fls_id": "fls_3xqobbu7wfsf",
      "title": "Impl Trait Types",
      "level": 3,
      "file": "types-and-traits",
      "content": "Impl Trait Types\n\n ImplTraitTypeSpecificationOneBound ::=\n $$impl$$ UseCaptures? TraitBound\n\n UseCaptures ::=\n $$use$$ $$<$$ UseCapturesGenericArgs? $$>$$\n\n UseCapturesGenericArgs ::=\n UseCapturesGenericArg ($$,$$ UseCapturesGenericArg)* $$,$$?\n\n UseCapturesGenericArg ::=\n Lifetime\n | Identifier\n\nAn impl trait type is a type that implements a trait, where the\ntype is known at compile time.\n\nAn impl trait type shall appear only within a function parameter or\nthe return type of a function.\n\nAn anonymous return type is an impl trait type ascribed to a\nfunction return type.\n\nAn anonymous return type behaves as if it contained all declared [type\nparameter]s of the return type's function and its parent trait\nor implementation.\n\nAn anonymous return type derived from an async function behaves as if\nit contained all declared [type parameter]s and [lifetime parameter]s\nof the return type's function and its parent trait or\nimplementation.\n\nAn impl trait type shall not contain [opt-out trait bound]s.\n\nAn use capture is a generic parameter referenced within an anonymous return type.\n\nAn anonymous return type that does not specify a list of [use capture]s implicitly [use capture]s all [type parameter]s and [constant parameter]s that are in scope.\n\nAn anonymous return type behaves as if it contained all its [use capture]s.",
      "paragraph_ids": [
        "fls_a6zlvyxpgsew",
        "fls_ieyqx5vzas2m",
        "fls_3aKZB0ILIkZw",
        "fls_Xo1ODwOyX7Vm",
        "fls_kTGFLFymTWch",
        "fls_ECjhEI7eCwAj",
        "fls_69hqMjvNno9u",
        "fls_KgH6c5cC4S0G",
        "fls_iT9WCNfUZQnC"
      ],
      "position": 25188,
      "parent_fls_id": "fls_1ompd93w7c9f",
      "sibling_fls_ids": [
        "fls_qa98qdi42orq"
      ]
    },
    {
      "fls_id": "fls_qa98qdi42orq",
      "title": "Trait Object Types",
      "level": 3,
      "file": "types-and-traits",
      "content": "Trait Object Types\n\n TraitObjectTypeSpecificationOneBound ::=\n $$dyn$$ TraitBound\n\nA trait object type is a type that implements a trait, where the\ntype is not known at compile time.\n\nThe principal trait of trait object type is the first trait bound.\n\nThe principal trait shall denote an object safe trait.\n\nAll non-principal trait [trait bound]s shall denote [auto trait]s.\n\nA trait object type shall not contain [opt-out trait bound]s.\n\nA trait object type shall contain at most one lifetime bound.\n\nA trait object type is a dynamically sized type. A\ntrait object type permits late binding of [method]s. A method\ninvoked via a trait object type involves dynamic dispatching.",
      "paragraph_ids": [
        "fls_sgrvona1nb6h",
        "fls_eWac7zOda3lh",
        "fls_9z8oleh0wdel",
        "fls_hJII8XYAtZeY",
        "fls_s0oy2c8t4yz9",
        "fls_CcoUug6b9ohU",
        "fls_88b9bmhra55f"
      ],
      "position": 27314,
      "parent_fls_id": "fls_1ompd93w7c9f",
      "sibling_fls_ids": [
        "fls_3xqobbu7wfsf"
      ]
    },
    {
      "fls_id": "fls_3pbipk8ki18d",
      "title": "Other Types",
      "level": 2,
      "file": "types-and-traits",
      "content": "Other Types",
      "paragraph_ids": [],
      "position": 28559,
      "parent_fls_id": "fls_vgb6ev541b2r",
      "sibling_fls_ids": [
        "fls_kwsBxMQNTRnL",
        "fls_963gsjp2jas2",
        "fls_id66vnaqw0zt",
        "fls_fbchw64p6n2x",
        "fls_wdec78luqh5b",
        "fls_hbbek3z4wtcs",
        "fls_3i4ou0dq64ny",
        "fls_1ompd93w7c9f",
        "fls_kgvleup5mdhq",
        "fls_7pby13muw48o",
        "fls_j02707n615z0",
        "fls_85vx1qfa061i",
        "fls_jeoas4n6su4"
      ]
    },
    {
      "fls_id": "fls_s45k21yn4qur",
      "title": "Inferred Types",
      "level": 3,
      "file": "types-and-traits",
      "content": "Inferred Types\n\nAn inferred type is a placeholder for a type deduced by\ntype inference.\n\nAn inferred type shall not appear in the following positions:\n\n* Within the :s:`InitializationType` of a :s:`TypeAliasDeclaration`,\n\n* Within the :s:`ReturnType` of a :s:`FunctionDeclaration`,\n\n* Within the :s:`TypeAscription` of a :s:`ConstantDeclaration`, a\n :s:`ConstantParameter`, a :s:`FunctionParameterPattern`, a\n :s:`RecordStructField`, a :s:`StaticDeclaration`, or a :s:`TypedSelf`,\n\n* Within the :s:`TypeSpecification` of a :s:`FunctionParameter`, an\n :s:`ImplementingType`, a :s:`TupleStructField`, a :s:`TypeBoundPredicate`, or\n a :s:`TypeParameter`.\n\nAn inferred type forces a tool to deduce a type, if possible.",
      "paragraph_ids": [
        "fls_xdtgr5toulpb",
        "fls_3abhsuaa8nas",
        "fls_hBXlJhbhuoHY",
        "fls_Vxlr9ZcqiOvY",
        "fls_gE9VC8JXrl1N",
        "fls_ybyQjFamI1Q5",
        "fls_9d8wbugmar1m"
      ],
      "position": 28607,
      "parent_fls_id": "fls_3pbipk8ki18d",
      "sibling_fls_ids": [
        "fls_XJCXBAJHzP3D",
        "fls_98lnexk53ru4",
        "fls_olbj67eyxz2k"
      ]
    },
    {
      "fls_id": "fls_XJCXBAJHzP3D",
      "title": "Type Parameters",
      "level": 3,
      "file": "types-and-traits",
      "content": "Type Parameters\n\nA type parameter type is a placeholder type of a type parameter\nto be substituted by generic substitution.",
      "paragraph_ids": [
        "fls_dCIIVXGhXDlO"
      ],
      "position": 29749,
      "parent_fls_id": "fls_3pbipk8ki18d",
      "sibling_fls_ids": [
        "fls_s45k21yn4qur",
        "fls_98lnexk53ru4",
        "fls_olbj67eyxz2k"
      ]
    },
    {
      "fls_id": "fls_98lnexk53ru4",
      "title": "Never Type",
      "level": 3,
      "file": "types-and-traits",
      "content": "Never Type\n\nThe never type is a type that represents the result of a computation\nthat never completes.\n\nThe never type has no [value]s.\n\nIt is validity invariant to not have a value of the never type.",
      "paragraph_ids": [
        "fls_4u0v5uy95pyf",
        "fls_xmtc10qzw0ui",
        "fls_22e8quna7ed5"
      ],
      "position": 30070,
      "parent_fls_id": "fls_3pbipk8ki18d",
      "sibling_fls_ids": [
        "fls_s45k21yn4qur",
        "fls_XJCXBAJHzP3D",
        "fls_olbj67eyxz2k"
      ]
    },
    {
      "fls_id": "fls_olbj67eyxz2k",
      "title": "Parenthesized Types",
      "level": 3,
      "file": "types-and-traits",
      "content": "Parenthesized Types\n\nA parenthesized type is a type that disambiguates the interpretation\nof [lexical element]s.",
      "paragraph_ids": [
        "fls_1dvo1epstrdv"
      ],
      "position": 30617,
      "parent_fls_id": "fls_3pbipk8ki18d",
      "sibling_fls_ids": [
        "fls_s45k21yn4qur",
        "fls_XJCXBAJHzP3D",
        "fls_98lnexk53ru4"
      ]
    },
    {
      "fls_id": "fls_kgvleup5mdhq",
      "title": "Type Aliases",
      "level": 2,
      "file": "types-and-traits",
      "content": "Type Aliases\n\n InitializationType ::=\n TypeSpecification\n\nA type alias is an item that defines a name for a type.\n\nA type alias shall not have a :s:`TypeBoundList` unless it is an\nassociated item.\n\nThe last where clause is rejected, but may still be consumed by\n[macro]s.",
      "paragraph_ids": [
        "fls_bibigic4jjad",
        "fls_rosdkeck5ax2",
        "fls_drxl7u3etfp9"
      ],
      "position": 31022,
      "parent_fls_id": "fls_vgb6ev541b2r",
      "sibling_fls_ids": [
        "fls_kwsBxMQNTRnL",
        "fls_963gsjp2jas2",
        "fls_id66vnaqw0zt",
        "fls_fbchw64p6n2x",
        "fls_wdec78luqh5b",
        "fls_hbbek3z4wtcs",
        "fls_3i4ou0dq64ny",
        "fls_1ompd93w7c9f",
        "fls_3pbipk8ki18d",
        "fls_7pby13muw48o",
        "fls_j02707n615z0",
        "fls_85vx1qfa061i",
        "fls_jeoas4n6su4"
      ]
    },
    {
      "fls_id": "fls_7pby13muw48o",
      "title": "Representation",
      "level": 2,
      "file": "types-and-traits",
      "content": "Representation",
      "paragraph_ids": [],
      "position": 31746,
      "parent_fls_id": "fls_vgb6ev541b2r",
      "sibling_fls_ids": [
        "fls_kwsBxMQNTRnL",
        "fls_963gsjp2jas2",
        "fls_id66vnaqw0zt",
        "fls_fbchw64p6n2x",
        "fls_wdec78luqh5b",
        "fls_hbbek3z4wtcs",
        "fls_3i4ou0dq64ny",
        "fls_1ompd93w7c9f",
        "fls_3pbipk8ki18d",
        "fls_kgvleup5mdhq",
        "fls_j02707n615z0",
        "fls_85vx1qfa061i",
        "fls_jeoas4n6su4"
      ]
    },
    {
      "fls_id": "fls_g1z6bpyjqxkz",
      "title": "Type Layout",
      "level": 3,
      "file": "types-and-traits",
      "content": "Type Layout\n\nAll [value]s have an alignment and a size.\n\nA dynamically sized type is a type that does not implement the core::marker::Sized trait.\n\nA fat pointer type is an indirection type whose contained type specification is a dynamically sized type.\n\nThe alignment of a value specifies which addresses are valid for\nstoring the value. Alignment is measured in bytes, is at least one,\nand always a power of two. A value of alignment N is stored at an\naddress that is a multiple of N.\n\nThe size of a type is the offset in bytes between successive elements\nin array type [T, N] where T is the type of the value,\nincluding any padding for alignment. Size is a multiple of the\nalignment.\n\nThe size of [scalar type]s is as follows:\n\nTypes usize and isize have size big enough to contain every\naddress on the target platform.\n\nFor type str, the layout is that of slice type\n[u8].\n\nFor array type [T; N] where T is the element type and N\nis size operand, the alignment is that of T, and the size is\ncalculated as core::mem::size_of::<T>() * N.\n\nFor a slice type, the layout is that of the array type it slices.\n\nFor a tuple type, the layout is tool-defined. For a unit tuple,\nthe size is zero and the alignment is one.\n\nFor a closure type, the layout is tool-defined.\n\nFor a thin pointer, the size and alignment are those of type\nusize.\n\nFor a function pointer type, the size and alignment are those of\na thin pointer.\n\nFor a fat pointer type, the size and alignment are tool-defined, but\nare at least those of a thin pointer.\nFor a fat pointer type whose contained type is that of a slice or trait object type the size is that of two times the size of type usize and the alignment is that of type usize.\n\nFor a trait object type, the layout is the same as the value\nbeing coerced into the trait object type at runtime.\n\nFor a struct type, the memory layout is undefined, unless the\nstruct type is subject to attribute repr.\n\nFor a union type, the memory layout is undefined, unless the\nunion type is subject to attribute repr. All [union field]s\nshare a common storage.\n\nThe size of a recursive type shall be finite.",
      "paragraph_ids": [
        "fls_kdbq02iguzgl",
        "fls_26Xgem831Nqg",
        "fls_ozYgHEHFTT5c",
        "fls_muxfn9soi47l",
        "fls_1pbwigq6f3ha",
        "fls_bk3nm2n47afu",
        "fls_z3i758jshvhx",
        "fls_uixe1ruv52be",
        "fls_7at60xlxm9u4",
        "fls_395247pkxv48",
        "fls_tbe9sc75timc",
        "fls_7jaqx33re3hg",
        "fls_asys0iz6m0md",
        "fls_wfv5vcxl2lc7",
        "fls_x8dfw50z9c",
        "fls_nyxnnlwmt5gu",
        "fls_lwmrljw9m0pb",
        "fls_pzi6izljfv0f",
        "fls_7cjbxleo998q",
        "fls_veotnstzigw2",
        "fls_nmoqk7jo1kzf",
        "fls_gd7wozpn2ecp",
        "fls_18ke90udyp67",
        "fls_nrqG8i3fmpm4",
        "fls_e5hivr6m5s3h",
        "fls_hlbsjggfxnt2",
        "fls_sdrb0k2r18my",
        "fls_gt3tkbn4bsa6",
        "fls_njvdevz0xqc0"
      ],
      "position": 31800,
      "parent_fls_id": "fls_7pby13muw48o",
      "sibling_fls_ids": [
        "fls_ohhsmifo0urd"
      ]
    },
    {
      "fls_id": "fls_ohhsmifo0urd",
      "title": "Type Representation",
      "level": 3,
      "file": "types-and-traits",
      "content": "Type Representation\n\nType representation specifies the layout of [field]s of\n[abstract data type]s. Type representation changes the bit padding\nbetween [field]s of [abstract data type]s as well as their order, but\ndoes not change the layout of the [field]s themselves.\n\nType representation is classified into:\n\n* C representation,\n\n* Default representation,\n\n* Primitive representation,\n\n* Transparent representation.\n\nC representation lays out a type such that the type is\ninteroperable with the C language.\n\nDefault representation makes no guarantees about the layout.\n\nPrimitive representation is the type representation of individual\n[integer type]s. Primitive representation applies only to an\nenum type that is not a zero-variant enum type. It is possible to\ncombine C representation and primitive representation.\n\nTransparent representation applies only to an enum type with a\nsingle enum variant or a struct type where the struct type or\nenum variant has a single field of non-zero size and any number\nof [field]s of size zero and alignment one.\n\n[Type]s subject to transparent representation have the same\ntype representation as the type of their field with non-zero\nsize.\n\nType representation may be specified using attribute repr. An\nenum type, a struct type, or a union type that is not subject to\nattribute repr has default representation.\n\nType representation may be specified using attribute [repr] and\nmodified further using attribute [repr]'s :s:`Alignment`\n[representation modifier]s. A representation modifier shall apply only\nto a struct type or a union type subject to C representation or\ndefault representation.",
      "paragraph_ids": [
        "fls_mpqlyi3lgrfv",
        "fls_9dhnanv21y9z",
        "fls_3dwtkr7vzha0",
        "fls_q465p1xuzxi",
        "fls_hrsdn21jmgx2",
        "fls_ergdb18tpx25",
        "fls_8s1vddh8vdhy",
        "fls_b005bktrkrxy",
        "fls_7plbkqlmed0r",
        "fls_ml4khttq3w5k",
        "fls_9q2iqzbup8oy",
        "fls_fsbf6ist38ix",
        "fls_qkkc8x2oghst"
      ],
      "position": 35520,
      "parent_fls_id": "fls_7pby13muw48o",
      "sibling_fls_ids": [
        "fls_g1z6bpyjqxkz"
      ]
    },
    {
      "fls_id": "fls_xc1hof4qbf6p",
      "title": "Enum Type Representation",
      "level": 4,
      "file": "types-and-traits",
      "content": "Enum Type Representation\n\n[Zero-variant enum type]s shall not be subject to C representation.\n\nThe size and alignment of an enum type without [field]s\nsubject to C representation, default representation, or\nprimitive representation are those of its discriminant.\n\nThe discriminant type of an enum type with C representation is\nthe corresponding c signed int type for the target platform's C\nABI.\n\nThe discriminant type of an enum type with default representation\nis tool-defined.\n\nThe discriminant type of an enum type with\nprimitive representation is the integer type specified by the\nprimitive representation.\n\nIt is a static error if the discriminant type cannot hold all the\ndiscriminant [value]s of an enum type.\n\nAn enum type subject to transparent representation shall have a single\nenum variant with\n\n* a single field of non-zero size, or\n\n* any number of [field]s of zero size and alignment one.\n\nAn enum type subject to C representation or primitive\nrepresentation has the same type representation as a union type with\nC representation that is laid out as follows:\n\n* Each enum variant corresponds to a struct whose struct type is\n subject to C representation and laid out as follows:\n\n * The type of the first field of the struct type is the\n discriminant type of the enum type.\n\n * The remaining [field]s of the struct type are the [field]s of\n the enum variant, in the same declarative order.\n\nAn enum type subject to transparent representation has the same\ntype representation as the single field of non-zero size of its\nenum variant if one is present, otherwise the enum type has size\nzero and alignment one.",
      "paragraph_ids": [
        "fls_p0c62ejo1u1t",
        "fls_efp1kfgkpba8",
        "fls_s9c0a0lg6c0p",
        "fls_slhvf3gmqz4h",
        "fls_u1zy06510m56",
        "fls_ryvqkcx48u74",
        "fls_zhle0rb0vhpc",
        "fls_45f57s1gmmh5",
        "fls_hz012yus6b4g",
        "fls_q5akku2idrwh",
        "fls_r6o1wv76yw6m",
        "fls_3k1tcfxp0g63",
        "fls_ebs77rxvk9st",
        "fls_k907i6w83s2"
      ],
      "position": 37857,
      "parent_fls_id": "fls_ohhsmifo0urd",
      "sibling_fls_ids": [
        "fls_rjxpof29a3nl",
        "fls_cmq8ogs84ivh"
      ]
    },
    {
      "fls_id": "fls_rjxpof29a3nl",
      "title": "Struct Type Representation",
      "level": 4,
      "file": "types-and-traits",
      "content": "Struct Type Representation\n\nThe alignment of a struct type subject to C representation is\nthe alignment of the most-aligned field in it.\n\nThe size of a struct type subject to C representation is\ndetermined as follows:\n\n#. Initialize a current offset to zero.\n\n#. For each field of the struct type in declarative order:\n\n #. Calculate the size and alignment of the field.\n\n #. If the current offset is not a multiple of the [field]'s\n alignment, add byte padding to the current offset until it is a\n multiple of the alignment. The offset of the field is the\n current offset.\n\n #. Increase the current offset by the size of the field.\n\n #. Proceed with the next field.\n\n#. Round up the current offset to the nearest multiple of the [struct\n type]'s alignment.\n\n#. The size of the struct type is the current offset.\n\nA struct type subject to transparent representation shall have:\n\n* A single field of non-zero size, or\n\n* Any number of [field]s of size zero and alignment one.\n\nA struct type subject to transparent representation has the same\ntype representation as the single field of non-zero size if one\nis present, otherwise the struct type has size zero and alignment\none.",
      "paragraph_ids": [
        "fls_jr9dykj6rydn",
        "fls_6ck71twmnbg5",
        "fls_hydq3pvm00bn",
        "fls_yzcdffahxcz",
        "fls_t2yqmphfd6he",
        "fls_fa5nkvu07jlp",
        "fls_x2pkmgbp63xx",
        "fls_y6dwc1ndm395",
        "fls_2npku94ookdn",
        "fls_h7nvs25rsi0y",
        "fls_iu93vpyihrpj",
        "fls_7sjkej5otxo",
        "fls_gwhceoy0m3or",
        "fls_hvkalvr4e2v0"
      ],
      "position": 40222,
      "parent_fls_id": "fls_ohhsmifo0urd",
      "sibling_fls_ids": [
        "fls_xc1hof4qbf6p",
        "fls_cmq8ogs84ivh"
      ]
    },
    {
      "fls_id": "fls_cmq8ogs84ivh",
      "title": "Union Type Representation",
      "level": 4,
      "file": "types-and-traits",
      "content": "Union Type Representation\n\nThe size of a union type subject to C representation is\nthe maximum of the [size]s of all its [field]s, rounded up to\nalignment of the union type.\n\nThe alignment of a union type subject to C representation is the\nmaximum of the [alignment]s of all of its [field]s.",
      "paragraph_ids": [
        "fls_opz1p1neldsg",
        "fls_y5qtvbx5m90g"
      ],
      "position": 42057,
      "parent_fls_id": "fls_ohhsmifo0urd",
      "sibling_fls_ids": [
        "fls_xc1hof4qbf6p",
        "fls_rjxpof29a3nl"
      ]
    },
    {
      "fls_id": "fls_j02707n615z0",
      "title": "Type Model",
      "level": 2,
      "file": "types-and-traits",
      "content": "Type Model",
      "paragraph_ids": [],
      "position": 42533,
      "parent_fls_id": "fls_vgb6ev541b2r",
      "sibling_fls_ids": [
        "fls_kwsBxMQNTRnL",
        "fls_963gsjp2jas2",
        "fls_id66vnaqw0zt",
        "fls_fbchw64p6n2x",
        "fls_wdec78luqh5b",
        "fls_hbbek3z4wtcs",
        "fls_3i4ou0dq64ny",
        "fls_1ompd93w7c9f",
        "fls_3pbipk8ki18d",
        "fls_kgvleup5mdhq",
        "fls_7pby13muw48o",
        "fls_85vx1qfa061i",
        "fls_jeoas4n6su4"
      ]
    },
    {
      "fls_id": "fls_3gapgqys3ceb",
      "title": "Recursive Types",
      "level": 3,
      "file": "types-and-traits",
      "content": "Recursive Types\n\nA recursive type is a type whose contained [type]s refer back to\nthe containing type, either directly or by referring to another type\nwhich refers back to the original recursive type.\n\nA type that is not an abstract data type shall not be recursive.",
      "paragraph_ids": [
        "fls_z22std1crl49",
        "fls_eddnwlr0rz59"
      ],
      "position": 42579,
      "parent_fls_id": "fls_j02707n615z0",
      "sibling_fls_ids": [
        "fls_exe4zodlwfez",
        "fls_dw33yt5g6m0k",
        "fls_wsfw8xF3vniL",
        "fls_omaq7psg83n3",
        "fls_mcxF9y5u66sZ",
        "fls_lv7w7aalpwm5"
      ]
    },
    {
      "fls_id": "fls_exe4zodlwfez",
      "title": "Type Unification",
      "level": 3,
      "file": "types-and-traits",
      "content": "Type Unification\n\nType unification is the process by which type inference propagates\nknown [type]s across the type inference root and assigns concrete\n[type]s to [type variable]s, as well as a general mechanism to check\nfor compatibility between two [type]s during method resolution.\n\nA type is said to unify with another type when the domains,\nranges, and structures of both [type]s are compatible according to the\nrules detailed below.\n\nTwo types that unify are said to be [unifiable type]s.\n\nType unification is a symmetric operation. If type A unifies\nwith type B, then B also unifies with A and such\ntype unification results in the same observable effects.\n\nIf one of the two [type]s is a type variable, type unification\nproceeds as follows:\n\n#. If either type is a global type variable, the\n global type variable is assigned the type of the other unification\n operand.\n\n#. Otherwise, if either type is a diverging type variable, the\n diverging type variable is assigned the type of the other\n unification operand.\n\n#. Otherwise, if one type T is an integer type variable, behavior\n depends on the other type U:\n\n #. If U is an integer type or an integer type variable, the\n integer type variable T is assigned type U.\n\n #. Otherwise, type unification fails.\n\n#. Otherwise, if one type T is a floating-point type variable,\n behavior depends on the other type U:\n\n #. If U is a floating-point type or an\n floating-point type variable, the floating-point type variable\n T is assigned type U.\n\n #. Otherwise, type unification fails.\n\n#. Otherwise, neither type is a type variable, and the rules below\n are in effect.\n\nA scalar type is unifiable only with itself.\n\nThe never type is unifiable with any other type.\n\nAn array type is unifiable only with another array type when\n\n* The [element type]s of both [array type]s are unifiable, and\n\n* The sizes of both [array type]s are the same.\n\nA slice type is unifiable only with another slice type when the\n[element type]s of both [slice type]s are unifiable.\n\nType str is unifiable only with itself.\n\nA tuple type is unifiable only with another tuple type when:\n\n* The arity of both [tuple type]s is the same, and\n\n* The [type]s of the corresponding [tuple field]s are unifiable.\n\nAn abstract data type is unifiable only with another\nabstract data type when:\n\n* The two [abstract data type]s are the same type, and\n\n* The corresponding [generic substitution]s are unifiable.\n\nA closure type is unifiable only with another closure type when:\n\n* The two [closure type]s are the same closure, and\n\n* The corresponding [generic substitution]s are unifiable.\n\nA function item type is unifiable only with another function item type\nwhen:\n\n* The two [function item type]s are the same function, and\n\n* The corresponding [generic substitution]s are unifiable.\n\nA function pointer type is unifiable only with another\nfunction pointer type when:\n\n* The [lifetime]s are variance-conformant, and\n\n* The unsafety is the same, and\n\n* The ABI is the same, and\n\n* The number of [function parameter]s is the same, and\n\n* The [type]s of the corresponding [function parameter]s are\n unifiable, and\n\n* The presence of a variadic part is the same, and\n\n* The [return type]s are unifiable.\n\nA raw pointer type is unifiable only with another raw pointer type\nwhen:\n\n* The mutability is the same, and\n\n* The [target type]s are unifiable.\n\nA reference type is unifiable only with another reference type when:\n\n* The mutability is the same, and\n\n* The [target type]s are unifiable.\n\nAn anonymous return type is unifiable with another type when:\n\n* The [lifetime]s are variance-conformant, and\n\n* The other type implements all [trait]s specified by the\n anonymous return type.\n\nAn impl trait type is unifiable only with itself.\n\nA trait object type is unifiable only with another trait object type\nwhen:\n\n* The [bound]s are unifiable, and\n\n* The [lifetime]s are unifiable.\n\nA type alias is unifiable with another type when the aliased type\nis unifiable with the other type.",
      "paragraph_ids": [
        "fls_ryvdhkgm7vzj",
        "fls_67VZrx6dw68H",
        "fls_aie0tr62vhw5",
        "fls_3U7Ue6Xzuv9M",
        "fls_tIiw5WkTRNf7",
        "fls_EoEbldkKBQW0",
        "fls_16ZDp8PaKi5P",
        "fls_pGRLTACDvzv2",
        "fls_fTy3FVt0fK9g",
        "fls_7IsrfUoPXSZU",
        "fls_Hb95CPyUpCmc",
        "fls_jEZVWlfVPevb",
        "fls_nKcqFo7yIDBe",
        "fls_jkaiBnApJAtt",
        "fls_dhksyjrvx9a",
        "fls_hf0cfkrmt655",
        "fls_k9dag68qpe93",
        "fls_m6d9qj9q9u1i",
        "fls_gg3x25qvymmq",
        "fls_ni296ev8x9v9",
        "fls_i1m41c4wkfc0",
        "fls_mpq64eal9jo3",
        "fls_kcr8npsmy0e5",
        "fls_kq3lv1zbangz",
        "fls_so2cgqmawlm7",
        "fls_vsax8w6y794m",
        "fls_1j1wc3uxs7h6",
        "fls_9dpea9ty0c2l",
        "fls_42oj1ekjihq1",
        "fls_gebpqqqvvklf",
        "fls_i221hm7rssik",
        "fls_74cug5zfv2wv",
        "fls_keezxl8v4snf",
        "fls_wz2etmkpvxed",
        "fls_rmqcbb5ja4va",
        "fls_uu8je75y5pss",
        "fls_oksjiq3nmq2k",
        "fls_52ymp79ert2",
        "fls_g2u1dfhphrrg",
        "fls_2xgq66qp3h95",
        "fls_5dh8c5gg0hmk",
        "fls_ismr7wwvek4q",
        "fls_x9933rjecrna",
        "fls_mizmcykgdisb",
        "fls_paoh0wttde2z",
        "fls_akko4dmp4nkw",
        "fls_8gldjjxbyyb4",
        "fls_8jad1ztcuxha",
        "fls_j3w9ap9zaqud",
        "fls_yvllot5qnc4s",
        "fls_hza5n5eb18ta",
        "fls_ww16urcjrj6i",
        "fls_bnp6or49voxp",
        "fls_hdo4c849q3lo",
        "fls_w9dx5h7m31sj"
      ],
      "position": 43109,
      "parent_fls_id": "fls_j02707n615z0",
      "sibling_fls_ids": [
        "fls_3gapgqys3ceb",
        "fls_dw33yt5g6m0k",
        "fls_wsfw8xF3vniL",
        "fls_omaq7psg83n3",
        "fls_mcxF9y5u66sZ",
        "fls_lv7w7aalpwm5"
      ]
    },
    {
      "fls_id": "fls_dw33yt5g6m0k",
      "title": "Type Coercion",
      "level": 3,
      "file": "types-and-traits",
      "content": "Type Coercion\n\nType coercion is an implicit operation that changes the type of a\nvalue. Any implicit conversion allowed by type coercion can be made\nexplicit using a type cast expression.\n\nA type coercion takes place at a coercion site or within a\ncoercion-propagating expression.\n\nThe following [construct]s constitute a coercion site:\n\n* The [argument operand]s of a call expression or a\n method call expression.\n\n* A constant declaration.\n\n* A field of an abstract data type.\n\n* A function result.\n\n* A let statement with an explicit type specification.\n\n* A static declaration.\n\nThe following [expression]s constitute a\ncoercion-propagating expression:\n\n* Each operand of an array expression.\n\n* The tail expression of a block expression.\n\n* The operand of a parenthesized expression.\n\n* Each operand of a tuple expression.\n\nType coercion from a source type to a target type is allowed to\noccur when:\n\n* The source type is a subtype of the target type.\n\n* The source type T coerces to intermediate type W, and\n intermediate type W coerces to target type U.\n\n* The source type is &T and the target type is *const T.\n\n* The source type is &T and the target type is &U, where T\n implements the core::ops::Deref<Target = U> trait.\n\n* The source type is &mut T and the target type is &T.\n\n* The source type is &mut T and the target type is *mut T.\n\n* The source type is &mut T and the target type is &U, where\n T implements the core::ops::Deref<Target = U> trait.\n\n* The source type is &mut T and the target type is &mut U,\n where T implements the core::ops::DerefMut<Target = U> trait.\n\n* The source type is *mut T and the target type is *const T.\n\n* The source type is type_constructor(T) and the target type is\n type_constructor(U), where type_constructor is one of &W,\n &mut W, *const W, or *mut W, and U can be obtained from T\n using unsized coercion.\n\n* The source type is a function item type, the target type is\n a function pointer type and the source's function signature is a subtype of the target's function signature.\n\n* The source type is a non-capturing closure type, the target\n type is a function pointer type and the source's function signature is a subtype of the target's function signature.\n\n* The source type is the never type and the target type is any\n type.\n\n* The source type is a trait object type and the target type is a trait object type with the same or no principal trait, and the target type has the same or less non-principal trait [trait bound]s.\n\n* The source type is a trait object type with some principal trait T\n and the target type is a trait object type with some principal trait U,\n where U is a supertrait of T.\n\nAn unsized coercion is a type coercion that converts a sized type\ninto an unsized type. Unsized coercion from a source type to a\ntarget type is allowed to occur when:\n\n* The source type is array type [T; N] and the target type is\n slice type [T].\n\n* The source type is T and the target type is dyn U, where\n T implements U + core::marker::Sized, and U is object safe.\n\n* The source type is\n\nwhere\n\n* S is a struct type,\n\n* T implements core::marker::Unsize<U>,\n\n* last_field is a struct field of S,\n\n* The type of last_field involves T and if the type of\n last_field is W<T>, then W<T> implements\n core::marker::Unsize<W<U>>,\n\n* T is not part of any other struct field of S.\n\nand the target type is S<..., U, ...>.\n\nLeast upper bound coercion is a multi-[type coercion] that is used in\nthe following scenarios:\n\n* To find the common type of multiple if expression branches.\n\n* To find the common type of multiple if let expression branches.\n\n* To find the common type for multiple match expression\n [match arm]s.\n\n* To find the common type of array expression [operand]s.\n\n* To find the return type of a closure expression with multiple\n [return expression]s.\n\n* To find the return type of a function with multiple\n [return expression]s.\n\nLeast upper bound coercion considers a set of source [type]s T1,\nT2, ..., TN and target type U. The target type is\nobtained as follows:\n\n#. Initialize target type U to source type T1.\n\n#. For each current source type TC in the inclusive range T1 to\n TN\n\n #. If TC can be coerced to U, then continue with the next source\n type.\n\n #. Otherwise, if U can be coerced to TC, make TC the target\n type U.\n\n #. Otherwise, if TC and U are non-capturing [closure type]s,\n [function item type]s, [function pointer type]s, or a\n combination of those [type]s, and a function pointer type exists\n that both TC and U can coerce to, make that\n function pointer type be target type U.\n\n #. Otherwise, no coercion is performed.\n\n #. Continue with the next source type.",
      "paragraph_ids": [
        "fls_w5pjcj9qmgbv",
        "fls_5v0n2a32bk95",
        "fls_j3kbaf43sgpj",
        "fls_wxrugvlazy6v",
        "fls_bhzmble1itog",
        "fls_eu4bt3dw1b8c",
        "fls_apstt4elv2k7",
        "fls_sp794uzfiofr",
        "fls_xfqny6bwzsu9",
        "fls_u0e42y7nvn7e",
        "fls_p8hp5y506nam",
        "fls_fjc9xev8rcu6",
        "fls_n1kh3z8d4q8y",
        "fls_dgoypa3hcxc0",
        "fls_h8dkehit8rza",
        "fls_z00wtlna6grk",
        "fls_rfjdh79k0wou",
        "fls_e3lgrtqb7jwe",
        "fls_fwy2z11c1sji",
        "fls_aujb44849tq1",
        "fls_p3ym3ycrnd5m",
        "fls_jmo42qgix5uw",
        "fls_tbt4236igdzb",
        "fls_7ri4jk2dydfn",
        "fls_6r3kn0nk5b8o",
        "fls_ulcdetwp6x96",
        "fls_2uv1r0gni1fk",
        "fls_sf0c3fbx8z57",
        "fls_SYnFJBhi0IWj",
        "fls_QB4c6FNKxaPl",
        "fls_iiiu2q7pym4p",
        "fls_jte6n2js32af",
        "fls_20pvqqayzqra",
        "fls_j8rcy0xvd155",
        "fls_wuka4uyo3oj7",
        "fls_w15yo8yvuxq3",
        "fls_7aw3ifbvfgbd",
        "fls_cnkth59djwgl",
        "fls_4wbk7pqj010i",
        "fls_47u0039t0l8f",
        "fls_bmh6g3jju7eq",
        "fls_da4w32rsrwxc",
        "fls_zi5311z1w7re",
        "fls_zst5pa29rpt",
        "fls_agw1aej616vf",
        "fls_tnbga5dl4gz8",
        "fls_yoreux8tn65x",
        "fls_r11shke69uu6",
        "fls_ky7ykpufb95t",
        "fls_8kvme0u4u8r6",
        "fls_rl9yrdfwnu03",
        "fls_iqtmhn8flws7",
        "fls_sr8d5har4s03",
        "fls_92pwnd1xbp5r",
        "fls_bWHQIL4DSN4S",
        "fls_ju4ypa5ysga0"
      ],
      "position": 49196,
      "parent_fls_id": "fls_j02707n615z0",
      "sibling_fls_ids": [
        "fls_3gapgqys3ceb",
        "fls_exe4zodlwfez",
        "fls_wsfw8xF3vniL",
        "fls_omaq7psg83n3",
        "fls_mcxF9y5u66sZ",
        "fls_lv7w7aalpwm5"
      ]
    },
    {
      "fls_id": "fls_wsfw8xF3vniL",
      "title": "Structural Equality",
      "level": 3,
      "file": "types-and-traits",
      "content": "Structural Equality\n\nA type is structurally equal when its [value]s can be compared\nfor equality by structure.\n\nThe following [type]s are structurally equal:\n\n* Bool, char, [function pointer type]s, [integer type]s,\n str, and [raw pointer type]s.\n\n* An abstract data type, if it implements the\n core::cmp::Eq and core::cmp::PartialEq [trait]s using\n [derive macro]s core::cmp::Eq and core::cmp::PartialEq.\n\n* [Array type]s and [slice type]s, if the [element type] is\n structurally equal.\n\n* [Reference type]s, if their inner type is structurally equal.\n\n* [Tuple type]s, if the [type]s of the [tuple field]s are\n structurally equal.",
      "paragraph_ids": [
        "fls_uVTpA7gbLCYX",
        "fls_2DZAP6JJjJ9h",
        "fls_emcNJzl2tHSA",
        "fls_HpWSAfaTA1Dz",
        "fls_5RcnETrW6f9m",
        "fls_jMeWhn4sNTPF",
        "fls_hBFlaUrrhqZ6"
      ],
      "position": 56557,
      "parent_fls_id": "fls_j02707n615z0",
      "sibling_fls_ids": [
        "fls_3gapgqys3ceb",
        "fls_exe4zodlwfez",
        "fls_dw33yt5g6m0k",
        "fls_omaq7psg83n3",
        "fls_mcxF9y5u66sZ",
        "fls_lv7w7aalpwm5"
      ]
    },
    {
      "fls_id": "fls_omaq7psg83n3",
      "title": "Interior Mutability",
      "level": 3,
      "file": "types-and-traits",
      "content": "Interior Mutability\n\nInterior mutability is a property of [type]s whose [value]s can\nbe modified through [immutable reference]s.\n\nA type is subject to interior mutability when it contains a\ncore::cell::UnsafeCell.",
      "paragraph_ids": [
        "fls_khy2e23i9o7z",
        "fls_sWiU26n2xS3r"
      ],
      "position": 57592,
      "parent_fls_id": "fls_j02707n615z0",
      "sibling_fls_ids": [
        "fls_3gapgqys3ceb",
        "fls_exe4zodlwfez",
        "fls_dw33yt5g6m0k",
        "fls_wsfw8xF3vniL",
        "fls_mcxF9y5u66sZ",
        "fls_lv7w7aalpwm5"
      ]
    },
    {
      "fls_id": "fls_mcxF9y5u66sZ",
      "title": "Visible Emptiness",
      "level": 3,
      "file": "types-and-traits",
      "content": "Visible Emptiness\n\nVisible emptiness <visible emptiness> is a property of [type]s and [enum variant]s that have no [value]s that are fully observable.\n\nA visible empty type is a type subject to visible emptiness.\n\nA visible empty enum variant is an enum variant subject to visible emptiness.\n\nA type is subject to visible emptiness as follows:\n\n* The type is the never type.\n\n* The type is a zero-variant enum type.\n\n* The type is an enum type not subject to attribute non_exhaustive where all [enum variant]s are subject to visible emptiness.\n\n* The type is a struct type with at least one visible <visibility> field whose type is subject to visible emptiness.\n\n* The type is a tuple type with at least one of the contained [type]s is subject to visible emptiness.\n\n* The type is an array type with a non-zero size operand and an element type that is subject to visible emptiness.\n\nA enum variant is subject to visible emptiness when the type of at least one of the enum variant's visible <visibility> [field]s is subject to visible emptiness.",
      "paragraph_ids": [
        "fls_SD4yUEQ9hHa3",
        "fls_GeoneCP5TYwf",
        "fls_A2W4v53ihTGx",
        "fls_AXOtKdSQR4AF",
        "fls_ZfnYORORz40y",
        "fls_TE2GBnZX2YFW",
        "fls_GNFzLMH8RBUC",
        "fls_fSNrRsgzLd0E",
        "fls_R65LmGTvSlIm",
        "fls_yiPv3wKYkSRl",
        "fls_S9QL6yVF5LFI"
      ],
      "position": 57961,
      "parent_fls_id": "fls_j02707n615z0",
      "sibling_fls_ids": [
        "fls_3gapgqys3ceb",
        "fls_exe4zodlwfez",
        "fls_dw33yt5g6m0k",
        "fls_wsfw8xF3vniL",
        "fls_omaq7psg83n3",
        "fls_lv7w7aalpwm5"
      ]
    },
    {
      "fls_id": "fls_lv7w7aalpwm5",
      "title": "Type Inference",
      "level": 3,
      "file": "types-and-traits",
      "content": "Type Inference\n\nType inference is the process of automatically determining the type of\n[expression]s and [pattern]s within a type inference root.\n\nA type inference root is an expression whose inner [expression]s\nand [pattern]s are subject to type inference independently of those\nfound in other [type inference root]s.\n\nThe following [expression]s are considered [type inference root]s:\n\n* A constant argument.\n\n* The expression of a constant initializer.\n\n* The expression of a static initializer.\n\n* The expression of a discriminant initializer.\n\n* The expression of a constant parameter initializer.\n\n* The expression of a constant argument.\n\n* A function body.\n\n* The size operand of an array expression or an array type.\n\nA type inference root imposes an expected type on its expression\ndepending on the type inference root as follows:\n\n* The expected type of a constant argument is the type ascription\n of the constant parameter.\n\n* The expected type of the expression of a constant initializer\n is the type specified by the type ascription of the related\n constant.\n\n* The expected type of the expression of a static initializer is\n the type specified by the type ascription of the related\n static.\n\n* The expected type of the expression of a\n discriminant initializer is determined as follows:\n\n * If the enum type that contains the discriminant is subject to\n attribute repr that specifies a primitive representation, the\n expected type is the specified integer type.\n\n * Otherwise, the expected type is isize.\n\n* The expected type of a function body is the return type of the\n function.\n\n* The expected type of a size operand of an array expression or\n an array type is usize.\n\nA type variable is a placeholder used during type inference to stand\nin for an undetermined type of an expression or a pattern.\n\nA global type variable is a type variable that can refer to any\ntype.\n\nAn integer type variable is a type variable that can refer only to\n[integer type]s.\n\nA floating-point type variable is a type variable that can refer only\nto [floating-point type]s.\n\nA diverging type variable is a type variable that can refer to any\ntype and originates from a diverging expression.\n\nA lifetime variable is a placeholder used during type inference to\nstand in for an undetermined lifetime of a type.\n\nThe type inference algorithm uses type unification to propagate known\n[type]s of [expression]s and [pattern]s across the\ntype inference root being inferred. In the rules detailed below, a static\nerror occurs when type unification fails.\n\nPerforming type inference may introduce a requirement that some type\nmust implement a trait, or that a type or lifetime must outlive\nsome other lifetime. Such requirements are referred to as\n[obligation]s and are detailed in the inference rules below.\n\nIf insufficient type information is available at the time an\nobligation is introduced, it may be deferred to be resolved later.\nAny time new type information is derived during type inference, the\ntool attempts to resolve all outstanding [obligation]s and propagate\nany resulting type information via type unification.\n\nWhen an associated type <Type as Trait>::Assoc is referenced within a\ntype inference root (either explicitly within the source code, or via the\ninference rules below), an obligation requiring that Type implements\nTrait is introduced.\n\nType inference for a type inference root proceeds as follows:\n\n#. Recursively process all [expression]s and [statement]s in the\n type inference root in program order.\n\n #. For each statement, apply the statement inference rules outlined below.\n\n #. For each expression, apply the expression inference rules outlined below.\n\n#. If there are any remaining [integer type variable]s that have not been\n unified with a concrete integer type, perform integer type fallback by\n unifying them with i32.\n\n#. If there are any remaining [floating-point type variable]s that have not\n been unified with a concrete floating-point type, perform floating-point\n type fallback by unifying them with f64.\n\n#. If there are any remaining [diverging type variable]s that have not been\n unified with a concrete type, unify them with the unit type.\n\n#. If there are any remaining [global type variable]s that have not been\n unified with a concrete type, raise a static error.\n\n#. If there are any remaining [obligation]s that do not hold or cannot be\n resolved with the available type information, raise a static error.\n\nThe type inference rules for [statement]s are as follows:\n\n* [Item statement]s are not subject to type inference.\n\n* [Expression statement]s apply the expression inference rules outlined below\n to the related expression, with the expected type set to the\n unit type if the expression statement lacks the character 0x3B\n (semicolon), unset otherwise.\n\n* [Let statement]s are inferred as follows:\n\n #. If the let statement has a type ascription, unify that\n type with the type of the pattern.\n\n #. If the let statement has a let initializer, apply the\n expression inference rules outlined below to the contained expression,\n with the expected type set to the type of the pattern.\n\n #. If the let statement has a let initializer with a\n block expression, apply the expression inference rules outlined below to\n the contained block expression, with the expected type set to\n the never type.\n\nType inference of [expression]s may incorporate an expected type,\nderived from the context the expression appears in. If the expression\nis a coercion site or a coercion-propagating expression, the type\nderived via type inference may be coerced to the expected type. If no\ntype coercion to the expected type is possible, or the expression\nis not a coercion site or a coercion-propagating expression, the\ninferred expression type is unified with the expected type.\n\nThe type inference rules for [expression]s are as follows:\n\n* An if expression is inferred by inferring its subject expression\n with an expected type of bool, then inferring its\n block expression with the expected type of the if expression.\n Then, if the if expression has an else expression, apply the\n inference rules below to it.\n\n* An if let expression is inferred by inferring its\n subject let expression with the expected type set to the type\n of its pattern, then inferring its block expression with the\n expected type of the if-let expression. If the\n if let expression has an else expression, apply the inference rules\n below to it.\n\n* An else expression that is part of an if expression or\n if let expression is inferred as follows:\n\n * If the else expression has a block expression, infer the\n block expression with the expected type of the if expression\n or if let expression.\n\n * If the else expression has an if expression, infer that nested\n if expression with the expected type of the original\n if expression, then unify its type with the type of\n the original if expression or if let expression.\n\n * Otherwise, the else expression has an if let expression. Infer\n that nested if let expression with the expected type of the\n original if expression, then unify its type with the\n type of the original if expression or if let expression.\n\n* A match expression is inferred as follows:\n\n #. Unify the [type]s of the [pattern]s of every match arm,\n then infer the subject expression with the expected type set to\n the type of the [pattern]s.\n\n #. Infer the [operand]s of all [match arm guard]s with\n expected type bool.\n\n #. Infer the match arm body of every match arm with the\n expected type of the match expression.\n\n* A for loop expression is inferred by unifying the type of its\n pattern with the type <T as core::iter::IntoIterator>::Item,\n where T is the type of the subject expression, and then\n inferring its loop body.\n\n* A while let loop expression is inferred by unifying the type of its\n subject let expression with the type of its pattern, and then\n inferring its loop body.\n\n* An array expression using an array element constructor is inferred\n by attempting a least upper bound coercion from each element type to\n the expected type. If no such type coercion is possible, all element\n [type]s are unified instead.\n\n* A negation expression is inferred as follows:\n\n #. Determine the trait corresponding to the operator according to the\n following table:\n\n \n\n* A bit expression or arithmetic expression is inferred as follows:\n\n #. Determine the trait corresponding to the operator according to the\n following table:\n\n \n\n* A compound assignment expression is inferred as follows:\n\n #. Determine the trait corresponding to the operator according to the\n following table:\n\n \n\n* A comparison expression is inferred by introducing an obligation\n L: PartialEq<R>, where L is the type of the left operand,\n and R is the type of the right operand. The type of the\n expression is bool.\n\n* An assignment expression is inferred by unifying the type of its\n assignee operand with the type of its value operand.\n\n* A closure expression is inferred by deducing its signature from the\n surrounding context, unifying the deduced closure parameter [type]s\n and return type with the user-written closure parameter\n [pattern]s and [type ascription]s and return type, and then\n inferring the closure body with the expected type set to the\n closure's return type. The closure signature is deduced as follows:\n\n * If the expected type is a function pointer type, the closure\n signature is the signature of that function pointer type.\n\n * Otherwise, if there is a pending obligation requiring that the\n expected type implements core::ops::FnOnce or a trait that\n has core::ops::FnOnce as one of its [supertrait]s, derive the\n closure signature from the parameters and return type of the\n core::ops::FnOnce bound or supertrait.\n\n * Otherwise, the closure signature remains undeduced. No outside type\n information is provided and the parameter [type]s and return type\n are subject to regular type inference.\n\n* Other [expression]s are inferred by applying the typing rules specified\n in the section for that expression.\n\nIf an expression is a diverging expression, its type is a new\ndiverging type variable.",
      "paragraph_ids": [
        "fls_h8sedxew0d4u",
        "fls_ybvrhh96fc7y",
        "fls_EWBilpepaDcX",
        "fls_NYSzcvf5nQpi",
        "fls_htLp5J5ObgNh",
        "fls_cPlCLGCcl7EK",
        "fls_KphY5qHev0Dc",
        "fls_67Bf5kR5OtYW",
        "fls_sAS3vQpkjksr",
        "fls_Sowatt1V988J",
        "fls_A1NVYkepoaMk",
        "fls_J77VeAlD8rsv",
        "fls_P9uiamxA4HE3",
        "fls_5d4hw3gj4w4n",
        "fls_qlovdtcj1v1b",
        "fls_Z5gKFjZW5rRA",
        "fls_vYvumjTQH9Xg",
        "fls_QaGKt99CmvF6",
        "fls_RJIeW597XRvS",
        "fls_veG2D64fIXvo",
        "fls_uvvn4usfsbhr",
        "fls_gDalJm1XS0mi",
        "fls_7ov36fpd9mwe",
        "fls_3hv3wxkhjjp1",
        "fls_bXQ63GYYDuMp",
        "fls_JryXiKBIFvF3",
        "fls_rvj3XspFZ1u3",
        "fls_6GrNr2izovRN",
        "fls_9dSltJ6U98Fo",
        "fls_v5dWGuBKvQSJ",
        "fls_SZgixDCAx6PQ",
        "fls_XYY1U9h9HlAa",
        "fls_1rnssw39aRWn",
        "fls_aYJaZXcOVVyk",
        "fls_X8kLC7JwiF0A",
        "fls_ZFQhOxO3jpby",
        "fls_l1G52a0qqEes",
        "fls_Tx4Sx4Qy8y2d",
        "fls_Nbdth8N0PSRq",
        "fls_hISRWZUuqE4Q",
        "fls_ygi1ACJ0RkfS",
        "fls_97Fxlv2KN6QF",
        "fls_hzXqj6YT1mFr",
        "fls_Kv0dzoMODtdy",
        "fls_5v6TR7oqOwFM",
        "fls_Gwx0Kfx68DXL",
        "fls_J6ydUCCJp1Sn",
        "fls_FSQqHs8T4bUx",
        "fls_0HHC1iOk5dwz",
        "fls_QZWTS0Giy3I3",
        "fls_KJsIu1lgVZxP",
        "fls_KRQxdSav1KBA",
        "fls_Mcpwyvz47SoG",
        "fls_34AQ9g7xhdUj",
        "fls_4ZT35povCL04",
        "fls_62OcWZaVN9hh",
        "fls_st9onPgDrc8y",
        "fls_F999gqcBfff9",
        "fls_Esa4ST7lLp8T",
        "fls_9GDElCkL1UbH",
        "fls_0eATa6RtDNtA",
        "fls_q1JZZMxqWXCk",
        "fls_hH58ftCxBYzm",
        "fls_aiSI99pbAYqT",
        "fls_zRdxowO4eDMN",
        "fls_IoceMi7HfqsK",
        "fls_lDkPMB5UI58B",
        "fls_JKZHF3ZDHshw",
        "fls_rT6zpG3cYhaF",
        "fls_UFMyHzk6ucsT",
        "fls_hPZmcfQiNasT",
        "fls_rgC3Iea5p9Kr",
        "fls_5jDBPymVKzDv",
        "fls_f21GNntBOxaz",
        "fls_NpwLzJJH9cGw",
        "fls_56J8BlLOuvr4",
        "fls_jK2pIVxOmtJ8",
        "fls_fjV22WcosNnt",
        "fls_h3OVuCdsKPhV",
        "fls_be2djziKJw3I",
        "fls_nHt0LVSiwTB3",
        "fls_sLCBZ3vG1AWs",
        "fls_mCISAdm7sjRs",
        "fls_Fv8fj9R8prUV",
        "fls_QDWVv2nTufX7",
        "fls_O2r51Xrmmj38",
        "fls_b96Zca6oFn82",
        "fls_07AIc06bGnZt",
        "fls_A36NBOl1FTCb",
        "fls_h3mmmIBR72kV",
        "fls_8edzBBIo7jF7",
        "fls_lUg26vFuSePP",
        "fls_21ay7EUUUmhx",
        "fls_8VgAhOgDOk0y",
        "fls_OVVY9CE0pGtJ",
        "fls_FojOvB6l3lAh",
        "fls_CVfHkJq1PixR",
        "fls_0RZ7w0YqmzE3",
        "fls_YppNCEPMYqWJ",
        "fls_SZmiJjI43fQL",
        "fls_ipWTrhF4xakC",
        "fls_zgRFKbfdI6ro",
        "fls_z2UkZX5Qdmws",
        "fls_U46IXItEKMCB",
        "fls_TAJ3JJwIeDbQ",
        "fls_VrpaTruoBwtF"
      ],
      "position": 59561,
      "parent_fls_id": "fls_j02707n615z0",
      "sibling_fls_ids": [
        "fls_3gapgqys3ceb",
        "fls_exe4zodlwfez",
        "fls_dw33yt5g6m0k",
        "fls_wsfw8xF3vniL",
        "fls_omaq7psg83n3",
        "fls_mcxF9y5u66sZ"
      ]
    },
    {
      "fls_id": "fls_85vx1qfa061i",
      "title": "Traits",
      "level": 2,
      "file": "types-and-traits",
      "content": "Traits\n\n SupertraitList ::=\n TypeBoundList\n\n TraitBody ::=\n $${$$\n InnerAttributeOrDoc*\n AssociatedItem*\n $$}$$\n\nA trait is an item that describes an interface a type can\nimplement.\n\nA trait body is a construct that encapsulates the\n[associated item]s, [inner attribute]s, and\n[inner doc comment]s of a trait.\n\nWithin a trait, the type Self acts as a placeholder for a\ntype implementing the trait, and behaves like a type parameter.\n\nA local trait is a trait that is defined in the current crate.\n\nA subtrait is a trait with a supertrait.\n\nA supertrait is a transitive trait that a type must additionally\nimplement.\n\nA subtrait shall not be its own supertrait.\n\nA trait of the form\n\nis equivalent to a where clause of the following form:\n\nAn auto trait is a trait that is implicitly and automatically\nimplemented by a type when the types of its constituent [field]s\nimplement the trait.\n\nA type that has no [field]s implements all [auto trait]s.\n\nIf determining whether a type T implements an auto trait\nwould recursively depend on whether T implements said auto trait, this\nrequirement is ignored and assumed to hold.\n\nThe following [trait]s are [auto trait]s:\n\n* core::marker::Send\n\n* core::marker::Sync\n\n* core::marker::Unpin\n\n* core::panic::UnwindSafe\n\n* core::panic::RefUnwindSafe\n\nNo other [trait]s are [auto trait]s.\n\nShape is a supertrait of Circle.\n\nCircle is a subtrait of Shape.",
      "paragraph_ids": [
        "fls_tani6lesan9u",
        "fls_PiAR1B26SoZV",
        "fls_Y28596CVBzDG",
        "fls_AdbbUZZgMEsQ",
        "fls_I9JaKZelMiby",
        "fls_CYtxPjK3zq2T",
        "fls_ytn5cdonytyn",
        "fls_vucd1u38sq7i",
        "fls_kyr81mi01me2",
        "fls_YynbrIceKmsJ",
        "fls_Bd4HwdrRuXMm",
        "fls_UzfG5ic8PUIH",
        "fls_02D6ku4Sd6yL",
        "fls_RLFIzQeAPhG6",
        "fls_avSxO0LEka2x",
        "fls_ft8axGGOe3aL",
        "fls_M4EoT1NMyxJS",
        "fls_Tir2kpKNP1KC",
        "fls_WxHiKr8BGGvz",
        "fls_mjg7yrq66hh0",
        "fls_ydowwijzirmm"
      ],
      "position": 77245,
      "parent_fls_id": "fls_vgb6ev541b2r",
      "sibling_fls_ids": [
        "fls_kwsBxMQNTRnL",
        "fls_963gsjp2jas2",
        "fls_id66vnaqw0zt",
        "fls_fbchw64p6n2x",
        "fls_wdec78luqh5b",
        "fls_hbbek3z4wtcs",
        "fls_3i4ou0dq64ny",
        "fls_1ompd93w7c9f",
        "fls_3pbipk8ki18d",
        "fls_kgvleup5mdhq",
        "fls_7pby13muw48o",
        "fls_j02707n615z0",
        "fls_jeoas4n6su4"
      ]
    },
    {
      "fls_id": "fls_4ikc07mfrez5",
      "title": "Object Safety",
      "level": 3,
      "file": "types-and-traits",
      "content": "Object Safety\n\nA trait is object safe when:\n\n* Its [supertrait]s are object safe, and\n\n* core::marker::Sized is not a supertrait, and\n\n* It lacks [associated constant]s, and\n\n* Its [associated function]s are object safe, and\n\n* Its [associated type]s specify a core::marker::Sized\n [trait bound] for Self in a type bound predicate.\n\nAn associated function is object safe when it is either an\nobject safe dispatchable function or an object safe\nnon-dispatchable function.\n\nA dispatchable function is object safe when:\n\n* It lacks [generic parameter]s, and\n\n* Is a method that does not use Self in its function signature\n except in the type of its self parameter or as the type of a\n type bound predicate, and\n\n* It lacks [type bound predicate]s with Self as the predicate's\n type and [trait]s as the predicate's [trait bound]s other than\n core::marker::Send, core::marker::Sync and\n core::marker::Unpin\n\nA function is object safe when it specifies a\ncore::marker::Sized [trait bound] for Self in a\ntype bound predicate.",
      "paragraph_ids": [
        "fls_lrdki56hpc3k",
        "fls_5wlltclogfkw",
        "fls_droy0w5gtqaw",
        "fls_46gd1q80c6bn",
        "fls_kwo4cknx0yat",
        "fls_vmLLL82EQasI",
        "fls_uixekv82g2e5",
        "fls_72tvfoemwpyy",
        "fls_j7nb34o87l1z",
        "fls_k1vc9vd8at92",
        "fls_kqylg31sm5wv",
        "fls_aer3gaur7avp"
      ],
      "position": 80060,
      "parent_fls_id": "fls_85vx1qfa061i",
      "sibling_fls_ids": []
    },
    {
      "fls_id": "fls_jeoas4n6su4",
      "title": "Trait and Lifetime Bounds",
      "level": 2,
      "file": "types-and-traits",
      "content": "Trait and Lifetime Bounds\n\n TypeBound ::=\n LifetimeIndication\n | ParenthesizedTraitBound\n | TraitBound\n | UseCaptures\n\n LifetimeIndication ::=\n Lifetime\n | $$'_$$\n | $$'static$$\n\n LifetimeIndicationList ::=\n LifetimeIndication ($$+$$ LifetimeIndication)* $$+$$?\n\n ParenthesizedTraitBound ::=\n $$($$ TraitBound $$)$$\n\n TraitBound ::=\n ($$?$$ | ForGenericParameterList)? TypePath\n\n ForGenericParameterList ::=\n $$for$$ GenericParameterList\n\nA bound imposes a constraint on a generic parameter by limiting the\nset of possible [generic substitution]s.\n\nA bound does not impose a constraint on a generic parameter of a\ntype alias unless it is an associated item.\n\nA lifetime bound is a bound that imposes a constraint on the\n[lifetime]s of [generic parameter]s.\n\nA trait bound is a bound that imposes a constraint on the\n[trait]s of [generic parameter]s.\n\nA :s:`ForGenericParameterList` shall not specify :s:`[ConstantParameter]s` or\n:s:`[TypeParameter]s`.\n\nA higher-ranked trait bound is a bound that specifies an infinite\nlist of [bound]s for all possible [lifetime]s specified by the\n:s:`ForGenericParameterList`.\n\nAn opt-out trait bound is a trait bound with :s:`Punctuation` ?\nthat nullifies an implicitly added trait bound.\n\nAn outlives bound is a trait bound which requires that a\nlifetime parameter or type outlives a lifetime parameter.\n\nOutlives bound 'a: 'b indicates that 'a outlives 'b.\n\nOutlives bound T: 'a indicates that all [lifetime parameter]s of\nT outlive 'a.\n\nAn implied bound is a bound that is not expressed in syntax, but is\nis the byproduct of relations between [lifetime parameter]s and\n[function parameter]s, between [lifetime parameter]s and a\nreturn type, and between [lifetime parameter]s and [field]s.\n\nA reference of the form &'a T, where 'a is a\nlifetime parameter and T is a type, yields implied bound\nT: 'a.\n\nIf an outlives bound applies to the type of a field, then this\nbound also applies to the related abstract data type as an\nimplied bound.\n\nIf an outlives bound applies to the type of a function parameter\nor to a return type, then this bound also applies to the related\nfunction as an implied bound.\n\n[Use capture] [bound]s shall only be used within [anonymous return type]s.",
      "paragraph_ids": [
        "fls_5g508z6c7q5f",
        "fls_BqLPVaSyyXRG",
        "fls_grby8tmmd8sb",
        "fls_knut10hoz6wc",
        "fls_sf6zg0ez9hbb",
        "fls_vujl3fblz6x2",
        "fls_AzuZmR9DXSQh",
        "fls_1Sm2Yq1Ow76f",
        "fls_tx4uspewnk7w",
        "fls_5kj8bmvb8xfc",
        "fls_J9DEsd06Ttu9",
        "fls_IfHRxSasGAih",
        "fls_K8nPGP5xbLb7",
        "fls_Uw6y5ZlaK6RY",
        "fls_OnyR0Wsfk7KI"
      ],
      "position": 81675,
      "parent_fls_id": "fls_vgb6ev541b2r",
      "sibling_fls_ids": [
        "fls_kwsBxMQNTRnL",
        "fls_963gsjp2jas2",
        "fls_id66vnaqw0zt",
        "fls_fbchw64p6n2x",
        "fls_wdec78luqh5b",
        "fls_hbbek3z4wtcs",
        "fls_3i4ou0dq64ny",
        "fls_1ompd93w7c9f",
        "fls_3pbipk8ki18d",
        "fls_kgvleup5mdhq",
        "fls_7pby13muw48o",
        "fls_j02707n615z0",
        "fls_85vx1qfa061i"
      ]
    },
    {
      "fls_id": "fls_yqcygq3y6m5j",
      "title": "Lifetimes",
      "level": 3,
      "file": "types-and-traits",
      "content": "Lifetimes\n\n AttributedLifetime ::=\n OuterAttributeOrDoc* Lifetime\n\n AttributedLifetimeList ::=\n AttributedLifetime ($$,$$ AttributedLifetime)* $$,$$?\n\nA lifetime specifies the expected longevity of a value.\n\nA lifetime bound shall apply to [type]s and other [lifetime]s.\n\nSee :p:`fls_85vx1qfa061i` for the declaration of Shape.",
      "paragraph_ids": [
        "fls_nne91at3143t",
        "fls_vbclxg9dq4yo",
        "fls_gcszhqg6hnva"
      ],
      "position": 84884,
      "parent_fls_id": "fls_jeoas4n6su4",
      "sibling_fls_ids": [
        "fls_ikfvbeewame7",
        "fls_l9ebxrlxyawd"
      ]
    },
    {
      "fls_id": "fls_ikfvbeewame7",
      "title": "Subtyping and Variance",
      "level": 3,
      "file": "types-and-traits",
      "content": "Subtyping and Variance\n\nSubtyping is a property of [type]s, allowing one type to be used\nwhere another type is expected.\n\nVariance is a property of [lifetime parameter]s and\n[type parameter]s that describes the circumstances under which a\ngeneric type is a subtype of an instantiation of itself with\ndifferent [generic argument]s.\n\nA type is its own subtype.\n\nF<T> is said to be\n\n* Covariant over T, when T being a subtype of U implies\n that F<T> is a subtype of F<U>, or\n\n* Contravariant over T, when T being a subtype of U\n implies that F<U> is a subtype of F<T>, or\n\n* Invariant over T.\n\nVariance is determined as follows:\n\nA trait is invariant in all inputs, including the Self parameter.\n\n[Lifetime parameter]s and [type parameter]s are subject to\nvariance.\n\nThe variance of a generic parameter of an abstract data type or\na tuple type is determined as follows:\n\n#. For each generic parameter G:\n\n #. Initialize variance V of the generic parameter to any.\n\n #. For each field of the abstract data type or the\n tuple type:\n\n #. If field type T uses G, then\n\n #. If V is any, set V to the variance of T over\n G.\n\n #. Otherwise if V and the variance of T over G differ,\n set V to invariant.\n\n #. It is a static error if variance V is any.\n\n[Expression]s and [statement]s may impose subtyping requirements\non their [subexpression]s. Such requirements are applied after\ntype inference, on the [inferred type]s of the respective\n[expression]s and [pattern]s.\n\nIt is a static error if any subtyping requirements are not met.\n\nThe subtyping requirements for [statement]s are as follows:\n\n* [Item statement]s impose no additional subtyping requirements.\n\n* [Let statement]s require that the type of the expression of the\n let initializer (if any) is a subtype of the type of the\n let statement's pattern.\n\n* [Expression statement]s impose the subtyping requirements for the\n contained expression, as outlined below.\n\nThe subtyping requirements for [expression]s are as follows:\n\n* The requirements for any arithmetic expression, bit expression,\n comparison expression, compound assignment expression,\n index expression, or negation expression are the same requirements\n as for an explicit invocation of the corresponding operator trait\n method.\n\n* An assignment expression requires that the type of its\n value operand is a subtype of the type of its\n assignee operand.\n\n* A type cast expression requires that the type of its operand is\n a subtype of its target type.\n\n* A call expression or method call expression requires that the\n [type]s of its [argument operand]s are [subtype]s of the\n [type]s of the corresponding parameter.\n\n* A return expression requires that the type of its operand is\n a subtype of the return type of the containing function or\n closure expression.\n\n* A break expression requires that its break type is a subtype of\n the type of the block expression or loop expression that the\n break expression breaks out of.\n\n* Other [expression]s do not impose any additional subtyping\n requirements.\n\nAny type coercion resulting in a method invocation imposes the same\nsubtyping requirements as an explicit invocation of that method would.",
      "paragraph_ids": [
        "fls_atq2cltx487m",
        "fls_df87d44kgwcv",
        "fls_7ex941yysuhq",
        "fls_7qud6i05ze2",
        "fls_wpm0p0gtctvi",
        "fls_3rfs58i2kg6l",
        "fls_kbo3e3bosr0m",
        "fls_n36p6w2a75sm",
        "fls_xw7eo3us0ow4",
        "fls_qc6jma5g9vpn",
        "fls_hpiiwxzg16rj",
        "fls_aspdlqluwh9w",
        "fls_8ohuze7hqtc1",
        "fls_7pkqgxabojkn",
        "fls_ln9pqd4xu5e",
        "fls_z4jo3ojkcu9v",
        "fls_67w6yslr3e25",
        "fls_ojal3qytkqql",
        "fls_owp42z12l4lc",
        "fls_i1vuix3gj9ej",
        "fls_mlf39pl0b931",
        "fls_yknymnlsasyw",
        "fls_xkzo7nj40rbn",
        "fls_abn5ycx11zpm",
        "fls_hvfyog9ygn6q",
        "fls_mduolmcawb30",
        "fls_y81gmqweqc9w",
        "fls_etgfvgvymn8o",
        "fls_4kjxxrsk1igf",
        "fls_y4zmb3vrym7p",
        "fls_9ae3idezsths",
        "fls_WD6uyTCziRac",
        "fls_xURR0owesaIE",
        "fls_CvZNYIfnOUcc",
        "fls_xrLYQX7W9OnR",
        "fls_DWPN8DRysgMa",
        "fls_tOn5oKtp300J",
        "fls_HqXTVi7gr9wR",
        "fls_lxfPvK7NDNlj",
        "fls_awJeqcAHn5O3",
        "fls_AD1IXzsnlwyg",
        "fls_p2II8E6cc9zt",
        "fls_pN5C4FHWEWdK",
        "fls_RdqV0hI8h8BI",
        "fls_Uv5CcMHPX79J",
        "fls_LyvV4pOG7E4l"
      ],
      "position": 85571,
      "parent_fls_id": "fls_jeoas4n6su4",
      "sibling_fls_ids": [
        "fls_yqcygq3y6m5j",
        "fls_l9ebxrlxyawd"
      ]
    },
    {
      "fls_id": "fls_l9ebxrlxyawd",
      "title": "Lifetime Elision",
      "level": 3,
      "file": "types-and-traits",
      "content": "Lifetime Elision\n\nLifetime elision is a set of rules that automatically insert\n[lifetime parameter]s and/or [lifetime argument]s when they are\nelided in the source code.\n\nA lifetime may be elided either implicitly or explicitly.\n\nA lifetime is elided explicitly if it is the '_ lifetime.\n\nA lifetime is elided implicitly if it is absent.\n\nLifetime elision rules are introduced by certain [construct]s and may\nbe nested.\n\nAn elided lifetime is subject to the set of lifetime elision rules\nintroduced by the innermost construct containing the elided lifetime.\n\nIt is a static error to elide a lifetime in a position where no\nlifetime elision rules are active.\n\n[Lifetime]s cannot be implicitly elided within [impl trait type]s.\nIf no lifetime bound is present, the impl trait type is not considered\nto be bound by any lifetime.",
      "paragraph_ids": [
        "fls_9wtuclhm7yz5",
        "fls_JmP6O9zj8fkV",
        "fls_5ZAQ9p7jQuc2",
        "fls_YmUQ8ZiQuycp",
        "fls_sIMN6Sd8xUZz",
        "fls_dIyisjNIx9dC",
        "fls_cD0ZYi23VqWg",
        "fls_sA4Lqc5o6cX3"
      ],
      "position": 91540,
      "parent_fls_id": "fls_jeoas4n6su4",
      "sibling_fls_ids": [
        "fls_yqcygq3y6m5j",
        "fls_ikfvbeewame7"
      ]
    },
    {
      "fls_id": "fls_HEtHxXBcg7JA",
      "title": "Function Lifetime Elision",
      "level": 4,
      "file": "types-and-traits",
      "content": "Function Lifetime Elision\n\nFunction lifetime elision is a form of lifetime elision that applies\nto [function]s, [function pointer type parameter]s, and [path]s\nthat resolve to one of the core::ops::Fn, core::ops::FnMut, and\ncore::ops::FnOnce [trait]s.\n\nAn input lifetime is one of the following [lifetime]s:\n\n* Any lifetime related to a function parameter.\n\n* Any lifetime related to a function pointer type parameter.\n\n* Any lifetime related to the [function parameter]s of the\n core::ops::Fn, core::ops::FnMut, and core::ops::FnOnce\n [trait]s.\n\nA self input lifetime is an input lifetime of a self parameter\nthat is a lifetime of a reference type whose referent is Self.\n\n* Any lifetime related to an implementing type and an\n implemented trait of an implementation.\n\nAn output lifetime is one of the following [lifetime]s:\n\n* Any lifetime related to the return type of a function.\n\n* Any lifetime related to the return type of a\n function pointer type.\n\n* Any lifetime related to the [return type]s of the\n core::ops::Fn, core::ops::FnMut, and core::ops::FnOnce\n [trait]s.\n\nLifetime elision proceeds as follows:\n\n#. Each elided input lifetime is a distinct lifetime parameter in\n its related construct.\n\n#. If a construct has exactly one input lifetime, then that\n lifetime is assigned to all elided [output lifetime]s.\n\n#. If a function has a self parameter with exactly 1\n self input lifetime, then the lifetime of the\n self input lifetime is assigned to all elided\n [output lifetime]s.\n\n#. Otherwise this is a static error.\n\nGiven function f of the form\n\nits lifetime elided form is",
      "paragraph_ids": [
        "fls_lAdIRCFFlydD",
        "fls_dpudys82dhdc",
        "fls_pjil71kk0r25",
        "fls_1jnn9bsb71k7",
        "fls_2p29p1fvi182",
        "fls_d4u3y82hdadc",
        "fls_ks8wlufmhz6d",
        "fls_hsg9kfyvh35m",
        "fls_ofqy10q4a9jk",
        "fls_yofbo96tjppf",
        "fls_vf7cxiir91ps",
        "fls_g56br27hq2zj",
        "fls_1j204m1wy333",
        "fls_6km3cbchuxr2",
        "fls_crb6m6b3cdwh",
        "fls_ac9tdlfwp5et",
        "fls_qtjc7334wzhj",
        "fls_vcmmkp9uruhr"
      ],
      "position": 92723,
      "parent_fls_id": "fls_l9ebxrlxyawd",
      "sibling_fls_ids": [
        "fls_u5lQkU2rS6uV",
        "fls_XTBOhK2Yk4lA",
        "fls_ZQPv1ybdDsE1"
      ]
    },
    {
      "fls_id": "fls_u5lQkU2rS6uV",
      "title": "Static Lifetime Elision",
      "level": 4,
      "file": "types-and-traits",
      "content": "Static Lifetime Elision\n\nStatic lifetime elision is a form of lifetime elision that applies to\nthe type ascription of [constant]s and [static]s.\n\nAn elided lifetime of a reference type or path in the\ntype specification of a constant or static is inferred to be the\n'static' lifetime.\n\nThe lifetime of an associated implementation constant shall not be\nelided.\n\nThe lifetime of an associated trait constant shall not be elided.\n\nGiven static S of the form\n\nits lifetime elided form is",
      "paragraph_ids": [
        "fls_l4RDXaFwnQZ6",
        "fls_8irr97rZWfSC",
        "fls_37udexenqv3p",
        "fls_xi86he5vvill",
        "fls_2GKCEI9MwMn9",
        "fls_f3yZ31dRuTPG"
      ],
      "position": 95401,
      "parent_fls_id": "fls_l9ebxrlxyawd",
      "sibling_fls_ids": [
        "fls_HEtHxXBcg7JA",
        "fls_XTBOhK2Yk4lA",
        "fls_ZQPv1ybdDsE1"
      ]
    },
    {
      "fls_id": "fls_XTBOhK2Yk4lA",
      "title": "Trait Object Lifetime Elision",
      "level": 4,
      "file": "types-and-traits",
      "content": "Trait Object Lifetime Elision\n\nTrait object lifetime elision is a form of lifetime elision that\napplies to [trait object type]s.\n\nAn elided lifetime of a trait object type is inferred as follows:\n\n* If the trait object type is used as the type specification of a\n reference type, then the lifetime of the reference type is the\n elided lifetime,\n\n* If the trait object type is used as a generic argument and\n\n * if the corresponding generic parameter has exactly one\n lifetime bound, then the lifetime of that bound is the\n elided lifetime,\n\n * Otherwise it is a static error to infer the lifetime bound.\n\n* If the trait of the trait object type has exactly one\n lifetime bound specified, then the lifetime of that bound is\n the inferred lifetime,\n\n* If the trait of the trait object type has no [lifetime bound]s\n specified, then the elided lifetime is the 'static\n lifetime unless it is elided in [expression]s where it is\n instead inferred,\n\n* Otherwise it is a static error to infer the lifetime bound.\n\nGiven type alias T of the form\n\nits lifetime elided form is",
      "paragraph_ids": [
        "fls_fuBYWRrgxlbQ",
        "fls_URl9CeIVsiWs",
        "fls_SHhw6lYHeYyQ",
        "fls_lC2rwdPLRwaf",
        "fls_e36Hh4oJvfhv",
        "fls_ptejalcnIQtm",
        "fls_rGbdKtTijby4",
        "fls_JhmQpUoExiNZ",
        "fls_cglZigwAnASl",
        "fls_MipY2emZFF6d",
        "fls_YPesUZqYHVUX"
      ],
      "position": 96356,
      "parent_fls_id": "fls_l9ebxrlxyawd",
      "sibling_fls_ids": [
        "fls_HEtHxXBcg7JA",
        "fls_u5lQkU2rS6uV",
        "fls_ZQPv1ybdDsE1"
      ]
    },
    {
      "fls_id": "fls_ZQPv1ybdDsE1",
      "title": "Impl Header Lifetime Elision",
      "level": 4,
      "file": "types-and-traits",
      "content": "Impl Header Lifetime Elision\n\nImpl header lifetime elision is a form of lifetime elision that\napplies to the implementing type and implemented trait (if any) of an\nimplementation.\n\nThe impl header lifetime elision rules are as follows:\n\n* Every explicitly elided lifetime is replaced with a new\n lifetime parameter defined on the implementation.\n\n* An implicitly elided lifetime of a reference is also replaced with a\n new lifetime parameter defined on the implementation.\n\n* An implicitly elided lifetime in any other type is a static error.\n\nGiven an implementation of the form\n\nits lifetime elided form is\n\nwhere 'a, 'b, and 'c are anonymous [lifetime parameter]s that\ncannot be named by user-written code.",
      "paragraph_ids": [
        "fls_FUdsmzN0T8XP",
        "fls_3p5BdLn3JbKz",
        "fls_PfS5AlkN6ANl",
        "fls_QV6zE5Mdor5E",
        "fls_P2V1DqrdCjCi",
        "fls_MBa35hfS8J9l",
        "fls_w0vwdmO8qV9j",
        "fls_vImY3BrpNvNY"
      ],
      "position": 98141,
      "parent_fls_id": "fls_l9ebxrlxyawd",
      "sibling_fls_ids": [
        "fls_HEtHxXBcg7JA",
        "fls_u5lQkU2rS6uV",
        "fls_XTBOhK2Yk4lA"
      ]
    },
    {
      "fls_id": "fls_EBwqH60SUHiN",
      "title": "List of undefined behavior",
      "level": 1,
      "file": "undefined-behavior",
      "content": "List of undefined behavior\n\nThe following sections of the FLS document undefined behavior:\n\n.. items-with-rubric:: Undefined Behavior",
      "paragraph_ids": [
        "fls_f9mkI99mzPxY"
      ],
      "position": 206,
      "parent_fls_id": null,
      "sibling_fls_ids": [
        "fls_l21tjqjkkaa0",
        "fls_gvwd0kf72jt",
        "fls_3v733mnewssy",
        "fls_gdeyap4or1db",
        "fls_dzq9cdz4ibsz",
        "fls_ckvjj4tt1hh2",
        "fls_osd6c4utyjb3",
        "fls_qcb1n9c0e5hz",
        "fls_48qldfwwh493",
        "fls_y2k5paj8m8ug",
        "fls_fk2m2irwpeof",
        "fls_z1il3w9nulzy",
        "fls_wb86edg02t6a",
        "fls_411up5z0b6n6",
        "fls_83182bfa9uqb",
        "fls_ronnwodjjjsh",
        "fls_xgqh0ju6bmbn",
        "fls_hdwwrsyunir",
        "fls_wdicg3sqa98e",
        "fls_vgb6ev541b2r",
        "fls_jep7p27kaqlp",
        "fls_94a8v54bufn8"
      ]
    },
    {
      "fls_id": "fls_jep7p27kaqlp",
      "title": "Unsafety",
      "level": 1,
      "file": "unsafety",
      "content": "Unsafety\n\nUnsafety is the presence of [unsafe operation]s and [unsafe trait\nimplementation]s in program text.\n\nAn unsafe operation is an operation that may result in\nundefined behavior that is not diagnosed as a static error.\n[Unsafe operation]s are referred to as unsafe Rust.\n\nThe [unsafe operation]s are:\n\n* Dereferencing a value of a raw pointer type.\n\n* Reading or writing an external static.\n\n* Reading or writing a mutable static.\n\n* Accessing a field of a union, other than to assign to it.\n\n* Calling an unsafe function.\n\n* Calling macro core::arch::asm.\n\nAn unsafe context is either an unsafe block or an\nunsafe function.\n\nAn unsafe operation shall be used only within an unsafe context.",
      "paragraph_ids": [
        "fls_8kqo952gjhaf",
        "fls_ovn9czwnwxue",
        "fls_pfhmcafsjyf7",
        "fls_jd1inwz7ulyw",
        "fls_3ra8s1v1vbek",
        "fls_6ipl0xo5qjyl",
        "fls_ucghxcnpaq2t",
        "fls_ljocmnaz2m49",
        "fls_s5nfhBFOk8Bu",
        "fls_jb6krd90tjmc",
        "fls_ybnpe7ppq1vh"
      ],
      "position": 125,
      "parent_fls_id": null,
      "sibling_fls_ids": [
        "fls_l21tjqjkkaa0",
        "fls_gvwd0kf72jt",
        "fls_3v733mnewssy",
        "fls_gdeyap4or1db",
        "fls_dzq9cdz4ibsz",
        "fls_ckvjj4tt1hh2",
        "fls_osd6c4utyjb3",
        "fls_qcb1n9c0e5hz",
        "fls_48qldfwwh493",
        "fls_y2k5paj8m8ug",
        "fls_fk2m2irwpeof",
        "fls_z1il3w9nulzy",
        "fls_wb86edg02t6a",
        "fls_411up5z0b6n6",
        "fls_83182bfa9uqb",
        "fls_ronnwodjjjsh",
        "fls_xgqh0ju6bmbn",
        "fls_hdwwrsyunir",
        "fls_wdicg3sqa98e",
        "fls_vgb6ev541b2r",
        "fls_EBwqH60SUHiN",
        "fls_94a8v54bufn8"
      ]
    },
    {
      "fls_id": "fls_94a8v54bufn8",
      "title": "Values",
      "level": 1,
      "file": "values",
      "content": "Values\n\nA value is either a literal or the result of a computation, that may\nbe stored in a memory location, and interpreted based on some type.\n\nAn allocated object is a value stored at some memory address.\n\nThe base address of an allocated object is the memory address where\nthe object is stored.\n\nAn [allocated object]s memory size is the number of bytes the object\nspans in memory from its base address.\n\nTwo [value]s overlap when\n\n* Both [value]s are the same, or\n\n* One value is of an abstract data type and the other denotes a\n field of the same value, or\n\n* One value denotes an array and the other denotes an element of the\n same value, or\n\n* Both [value]s are elements of the same array.\n\nIt is undefined behavior to create a value from uninitialized memory unless\nthe type of the value is a union type.\n\nIt is undefined behavior to create an allocated object at base address\nnull.\n\nIt is undefined behavior to create an allocated object with memory\nsize size at a base address base where base + size is greater\nthan the architectures maximum usize value.\n\nIt is undefined behavior to create an allocated object with memory\nsize size where size is greater than the architectures maximum\nisize value.",
      "paragraph_ids": [
        "fls_buyaqara7am4",
        "fls_CUJyMj0Sj8NS",
        "fls_kaomYy0Ml4Nh",
        "fls_B5cmkWfD5GNt",
        "fls_rixdyyc525xp",
        "fls_m6ctqq70vcxr",
        "fls_s231d18x5eay",
        "fls_dfr4yqo93fsn",
        "fls_eoak5mdl6ma",
        "fls_6lg0oaaopc26",
        "fls_oqhQ62mDLckN",
        "fls_uhwpuv6cx4ip",
        "fls_xuuFKmm181bs"
      ],
      "position": 125,
      "parent_fls_id": null,
      "sibling_fls_ids": [
        "fls_l21tjqjkkaa0",
        "fls_gvwd0kf72jt",
        "fls_3v733mnewssy",
        "fls_gdeyap4or1db",
        "fls_dzq9cdz4ibsz",
        "fls_ckvjj4tt1hh2",
        "fls_osd6c4utyjb3",
        "fls_qcb1n9c0e5hz",
        "fls_48qldfwwh493",
        "fls_y2k5paj8m8ug",
        "fls_fk2m2irwpeof",
        "fls_z1il3w9nulzy",
        "fls_wb86edg02t6a",
        "fls_411up5z0b6n6",
        "fls_83182bfa9uqb",
        "fls_ronnwodjjjsh",
        "fls_xgqh0ju6bmbn",
        "fls_hdwwrsyunir",
        "fls_wdicg3sqa98e",
        "fls_vgb6ev541b2r",
        "fls_EBwqH60SUHiN",
        "fls_jep7p27kaqlp"
      ]
    },
    {
      "fls_id": "fls_ixjc5jaamx84",
      "title": "Constants",
      "level": 2,
      "file": "values",
      "content": "Constants\n\n ConstantInitializer ::=\n $$=$$ Expression\n\nA constant is an immutable value expression whose uses are substituted by\nthe value.\n\nAn unnamed constant is a constant declared with character 0x5F (low\nline).\n\nThe type specification of a constant shall have 'static\nlifetime.\n\nThe type of a constant shall implement the core::marker::Sized\ntrait.\n\nA constant initializer is a construct that provides the value of\nits related constant.\n\nA constant shall have a constant initializer, unless it is an\nassociated trait constant.\n\nThe expression of a constant initializer shall be a\nconstant expression.\n\nThe value of a constant is determined by evaluating its\nconstant initializer.\n\nAfter type coercion, the value of the constant cannot contain any\n[mutable reference]s, except when\n\n- The mutable reference is contained within an external static, or\n\n- The mutable reference is contained within a mutable static, or\n\n- The mutable reference is contained within a static\n whose type is subject to interior mutability, or\n\n- The mutable reference is contained within an union, or\n\n- The referent is a value of a zero-sized type.\n\nThe elaboration of a constant evaluates its constant initializer.\n\nA path that refers to a constant is replaced with the value of\nthe constant.",
      "paragraph_ids": [
        "fls_5o5iu4j8in4l",
        "fls_3mhj0kkupwuz",
        "fls_ka4y2yd100dx",
        "fls_vt9tlkd676ql",
        "fls_ndmfqxjpvsqy",
        "fls_6rxwbbhf5tc5",
        "fls_vnc3ttnid1qr",
        "fls_deuo1pn8cjd6",
        "fls_ooOYxhVh8hZo",
        "fls_zkNFeBLy80UA",
        "fls_VhzGfnWg7YrG",
        "fls_qC6L0km0ZMFI",
        "fls_ibYKKQdB2tDn",
        "fls_dQdSxf8kOgbi",
        "fls_xezt9hl069h4",
        "fls_ndobth7s92if"
      ],
      "position": 1937,
      "parent_fls_id": "fls_94a8v54bufn8",
      "sibling_fls_ids": [
        "fls_xdvdl2ssnhlo",
        "fls_cleoffpn5ew6",
        "fls_gho955gmob73"
      ]
    },
    {
      "fls_id": "fls_xdvdl2ssnhlo",
      "title": "Statics",
      "level": 2,
      "file": "values",
      "content": "Statics\n\n StaticInitializer ::=\n $$=$$ Expression\n\nA static is a value that is associated with a specific memory\nlocation.\n\nA static defined within a generic function exists once in the\noutput executable or library.\n\nThe type specification of a static shall have 'static\nlifetime.\n\nThe type of a static shall implement the core::marker::Sized\ntrait.\n\nA static shall only be subject to an :s:`ItemSafety` if it is an external static in an unsafe external block.\n\nA mutable static is a static with keyword mut whose\nvalue can be modified.\n\nAccess to a mutable static shall require unsafe context.\n\nAn immutable static is a static whose value cannot be modified.\n\nThe type of an immutable static shall implement the\ncore::marker::Sync trait.\n\nA static initializer is a construct that provides the value of\nits related static.\n\nA static shall have a static initializer, unless it is an\nexternal static.\n\nThe expression of a static initializer shall be a\nconstant expression.\n\nA use of a static is a place expression referring to the unique\nlocation of the static.\n\nThe elaboration of a static evaluates its static initializer.\n\nAll [path]s that refer to a static refer to the same memory location.\n\nA static is not dropped during destruction.\n\nAn immutable static whose type is not subject to\ninterior mutability may reside in read-only memory.\n\nIt is undefined behavior to mutate an immutable static whose type is\nnot subject to interior mutability.",
      "paragraph_ids": [
        "fls_ibrmiwfypldh",
        "fls_mt94jvoot9dx",
        "fls_k0r2c6uq29tu",
        "fls_b6ods85htuyn",
        "fls_WRpcVF1fLEpr",
        "fls_doi4z6u55bi7",
        "fls_74hp208pto22",
        "fls_jfde2vg6mtww",
        "fls_k4tyqb1j6zjo",
        "fls_t17h5h6a6v4c",
        "fls_yq0hpy4jx2qb",
        "fls_vgidvfwzm4ks",
        "fls_8dcldbvu7lav",
        "fls_w0nb0mphho7b",
        "fls_eeocxst9vafn",
        "fls_47khd5ljsxeq",
        "fls_dowxbphqvk3n",
        "fls_b5wsmii7vz3v"
      ],
      "position": 4128,
      "parent_fls_id": "fls_94a8v54bufn8",
      "sibling_fls_ids": [
        "fls_ixjc5jaamx84",
        "fls_cleoffpn5ew6",
        "fls_gho955gmob73"
      ]
    },
    {
      "fls_id": "fls_cleoffpn5ew6",
      "title": "Temporaries",
      "level": 2,
      "file": "values",
      "content": "Temporaries\n\nA temporary is an anonymous variable produced by some intermediate\ncomputation.",
      "paragraph_ids": [
        "fls_awpw61yofckz"
      ],
      "position": 6616,
      "parent_fls_id": "fls_94a8v54bufn8",
      "sibling_fls_ids": [
        "fls_ixjc5jaamx84",
        "fls_xdvdl2ssnhlo",
        "fls_gho955gmob73"
      ]
    },
    {
      "fls_id": "fls_gho955gmob73",
      "title": "Variables",
      "level": 2,
      "file": "values",
      "content": "Variables\n\nA variable is a placeholder for a value that is allocated on the\nstack.\n\nThe following [construct]s are [variable]s:\n\n* A binding.\n\n* A temporary.\n\nA variable shall be used only after it has been initialized through all\n[reachable control flow path]s up to the point of its usage.\n\nA variable is not initialized when allocated.",
      "paragraph_ids": [
        "fls_hl5tnd9yy252",
        "fls_vgi0gh5zmoiu",
        "fls_81dlbula47nu",
        "fls_3p0sb9ppmg3w",
        "fls_r9km9f969bu8",
        "fls_g8etd5lsgn9j"
      ],
      "position": 6806,
      "parent_fls_id": "fls_94a8v54bufn8",
      "sibling_fls_ids": [
        "fls_ixjc5jaamx84",
        "fls_xdvdl2ssnhlo",
        "fls_cleoffpn5ew6"
      ]
    },
    {
      "fls_id": "fls_wttihxen35as",
      "title": "Constant Promotion",
      "level": 3,
      "file": "values",
      "content": "Constant Promotion\n\nConstant promotion is the process of converting a value expression\ninto a constant.\n\nConstant promotion is possible only when\n\n* The value expression is a constant expression, and\n\n* The type of the value expression does not have a destructor,\n and\n\n* The value expression does not employ a struct expression\n constructing a core::cell::UnsafeCell, and\n\n* The value expression only consists of operations that will always succeed\n evaluation, and\n\n* The value expression is the operand of an\n immutable borrow expression.\n\nConstant promotion is always possible for expression &mut [],\npromoting the produced mutable borrow to have 'static lifetime.\n\nConstant promotion proceeds as follows:\n\n#. An anonymous constant is created, whose constant initializer holds\n the result of the value expression.\n\n#. The value of the anonymous constant is borrowed with\n 'static lifetime.",
      "paragraph_ids": [
        "fls_udn9lyf3m0z6",
        "fls_yvkdcs4pmxjf",
        "fls_n570za6a9nqd",
        "fls_tms5r9f5ogcb",
        "fls_bysv5r7iuf5j",
        "fls_3h5vr7xk2rrt",
        "fls_3BGncWvMumEt",
        "fls_m690b8qg9d9r",
        "fls_uf0sg25awre6",
        "fls_o7cqfdnr253y",
        "fls_ap85svxyuhvg"
      ],
      "position": 7425,
      "parent_fls_id": "fls_gho955gmob73",
      "sibling_fls_ids": []
    }
  ]
}