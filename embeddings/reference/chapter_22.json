{
  "source": "Rust Reference",
  "source_repo": "https://github.com/rust-lang/reference",
  "extraction_date": "2026-01-03",
  "chapter": 22,
  "title": "Appendices",
  "file": "appendices.md",
  "sections": [
    {
      "id": "appendices",
      "title": "Appendices",
      "level": 1,
      "content": "# Appendices",
      "parent_id": null,
      "paragraphs": {
        "appendices_p1": "# Appendices"
      }
    },
    {
      "id": "grammar_summary",
      "title": "Grammar summary",
      "level": 1,
      "content": "# Grammar summary\n\nThe following is a summary of the grammar production rules. For details on the syntax of this grammar, see *[notation.grammar.syntax]*.\n\n{{ grammar-summary }}",
      "parent_id": null,
      "paragraphs": {
        "grammar_summary_p1": "# Grammar summary\n\nThe following is a summary of the grammar production rules. For details on the syntax of this grammar, see *[notation.grammar.syntax]*.\n\n{{ grammar-summary }}"
      }
    },
    {
      "id": "syntax_index",
      "title": "Syntax index",
      "level": 1,
      "content": "# Syntax index\n\nThis appendix provides an index of tokens and common forms with links to where those elements are defined.\n\n## Keywords\n\n| Keyword       | Use |\n|---------------|-----|\n| `_`           | [wildcard pattern], [inferred const], [inferred type], [placeholder lifetime], [constant items], [extern crate], [use declarations], [destructuring assignment] |\n| `abstract`    | [reserved keyword] |\n| `as`          | extern crate, use declarations, [type cast expressions], [qualified paths] |\n| `async`       | [async functions], [async blocks], [async closures] |\n| `await`       | [await expressions] |\n| `become`      | [reserved keyword] |\n| `box`         | [reserved keyword] |\n| `break`       | [break expressions] |\n| `const`       | [const functions], [const items], [const generics], [const blocks], [raw borrow operator], [raw pointer type], [const assembly operands] |\n| `continue`    | [continue expressions] |\n| `crate`       | [extern crate], [visibility], [paths] |\n| `do`          | [reserved keyword] |\n| `dyn`         | [trait objects] |\n| `else`        | [let statements], [if expressions] |\n| `enum`        | [enumerations] |\n| `extern`      | [extern crate], [extern function qualifier], [external blocks], [extern function pointer types] |\n| `false`       | [boolean type], [boolean expressions], [configuration predicates] |\n| `final`       | [reserved keyword] |\n| `fn`          | [functions], [function pointer types] |\n| `for`         | [trait implementations], [iterator loops], [higher-ranked trait bounds] |\n| `gen`         | [reserved keyword] |\n| `if`          | [if expressions], [match guards] |\n| `impl`        | [inherent impls], [trait impls], [impl trait types], [anonymous type parameters] |\n| `in`          | [visibility], [iterator loops], [assembly operands] |\n| `let`         | [let statements], [`if let` patterns] |\n| `loop`        | [infinite loops] |\n| `macro_rules` | [macros by example] |\n| `macro`       | [reserved keyword] |\n| `match`       | [match expressions] |\n| `mod`         | [modules] |\n| `move`        | [closure expressions], [async blocks] |\n| `mut`         | [borrow expressions], [identifier patterns], [reference patterns], [struct patterns], [reference types], [raw pointer types], [self parameters], [static items] |\n| `override`    | [reserved keyword] |\n| `priv`        | [reserved keyword] |\n| `pub`         | [visibility] |\n| `raw`         | [borrow expressions], [raw assembly] |\n| `ref`         | [identifier patterns], [struct patterns] |\n| `return`      | [return expressions] |\n| `safe`        | [external block functions], [external block statics] |\n| `self`        | extern crate, [self parameters], [visibility], [`self` paths] |\n| `Self`        | [`Self` type paths], [use bounds] |\n| `static`      | [static items], [`'static` lifetimes] |\n| `struct`      | [structs] |\n| `super`       | [super paths], [visibility] |\n| `trait`       | [trait items] |\n| `true`        | [boolean type], [boolean expressions], [configuration predicates] |\n| `try`         | [reserved keyword] |\n| `type`        | [type aliases] |\n| `typeof`      | [reserved keyword] |\n| `union`       | [union items] |\n| `unsafe`      | [unsafe blocks], [unsafe attributes], [unsafe modules], [unsafe functions], [unsafe external blocks], [unsafe external functions], [unsafe external statics], [unsafe traits], [unsafe trait implementations] |\n| `unsized`     | [reserved keyword] |\n| `use`         | [use items], [use bounds] |\n| `virtual`     | [reserved keyword] |\n| `where`       | [where clauses] |\n| `while`       | [predicate loops] |\n| `yield`       | [reserved keyword] |\n\n## Operators and punctuation\n\n| Symbol | Name        | Use |\n|--------|-------------|-----|\n| `+`    | Plus        | addition, [trait bounds], [macro Kleene matcher] |\n| `-`    | Minus       | subtraction, [negation] |\n| `*`    | Star        | multiplication, [dereference], [raw pointers], [macro Kleene matcher], [glob imports] |\n| `/`    | Slash       | division |\n| `%`    | Percent     | remainder |\n| `^`    | Caret       | bitwise and logical XOR |\n| `!`    | Not         | bitwise and logical NOT, [macro calls], inner attributes, [never type], [negative impls] |\n| `&`    | And         | bitwise and logical AND, [borrow], [references], [reference patterns] |\n| `\\|`   | Or | bitwise and logical OR, [closures], [or patterns], [if let], [while let] |\n| `&&`   | AndAnd      | lazy AND, [borrow], [references], [reference patterns] |\n| `\\|\\|` | OrOr | lazy OR, [closures] |\n| `<<`   | Shl         | shift left, nested generics |\n| `>>`   | Shr         | shift right, nested generics |\n| `+=`   | PlusEq      | addition assignment |\n| `-=`   | MinusEq     | subtraction assignment |\n| `*=`   | StarEq      | multiplication assignment |\n| `/=`   | SlashEq     | division assignment |\n| `%=`   | PercentEq   | remainder assignment |\n| `^=`   | CaretEq     | bitwise XOR assignment |\n| `&=`   | AndEq       | bitwise AND assignment |\n| `\\|=`  | OrEq | bitwise OR assignment |\n| `<<=`  | ShlEq       | shift left assignment |\n| `>>=`  | ShrEq       | shift right assignment, nested generics |\n| `=`    | Eq          | [assignment], [let statements], [attributes], various type definitions |\n| `==`   | EqEq        | equal |\n| `!=`   | Ne          | not equal |\n| `>`    | Gt          | greater than, [generics], [paths], [use bounds] |\n| `<`    | Lt          | less than, [generics], [paths], [use bounds] |\n| `>=`   | Ge          | greater than or equal to, [generics] |\n| `<=`   | Le          | less than or equal to |\n| `@`    | At          | [subpattern binding] |\n| `.`    | Dot         | field access, [tuple index] |\n| `..`   | DotDot      | range expressions, [struct expressions], [rest pattern], [range patterns], [struct patterns] |\n| `...`  | DotDotDot   | [variadic functions], [range patterns] |\n| `..=`  | DotDotEq    | inclusive range expressions, [range patterns] |\n| `,`    | Comma       | various separators |\n| `;`    | Semi        | terminator for various items and statements, [array expressions], [array types] |\n| `:`    | Colon       | various separators |\n| `::`   | PathSep     | path separator |\n| `->`   | RArrow      | [functions], [closures], [function pointer type] |\n| `=>`   | FatArrow    | match arms, [macros] |\n| `<-`   | LArrow      | The left arrow symbol has been unused since before Rust 1.0, but it is still treated as a single token. |\n| `#`    | Pound       | [attributes], [raw string literals], [raw byte string literals], [raw C string literals] |\n| `$`    | Dollar      | [macros] |\n| `?`    | Question    | try propagation expressions, [relaxed trait bounds], [macro Kleene matcher] |\n| `~`    | Tilde       | The tilde operator has been unused since before Rust 1.0, but its token may still be used. |\n\n## Comments\n\n| Comment  | Use |\n|----------|-----|\n| `//`     | line comment |\n| `//!`    | inner line comment |\n| `///`    | outer line doc comment |\n| `/*\u2026*/`  | block comment |\n| `/*!\u2026*/` | inner block doc comment |\n| `/**\u2026*/` | outer block doc comment |\n\n## Other tokens\n\n| Token        | Use |\n|--------------|-----|\n| `ident`      | [identifiers] |\n| `r#ident`    | [raw identifiers] |\n| `'ident`     | [lifetimes and loop labels] |\n| `'r#ident`   | [raw lifetimes and loop labels] |\n| `\u2026u8`, `\u2026i32`, `\u2026f64`, `\u2026usize`, \u2026 | [number literals] |\n| `\"\u2026\"`        | [string literals] |\n| `r\"\u2026\"`, `r#\"\u2026\"#`, `r##\"\u2026\"##`, \u2026 | [raw string literals] |\n| `b\"\u2026\"`       | [byte string literals] |\n| `br\"\u2026\"`, `br#\"\u2026\"#`, `br##\"\u2026\"##`, \u2026 | [raw byte string literals] |\n| `'\u2026'`        | [character literals] |\n| `b'\u2026'`       | [byte literals] |\n| `c\"\u2026\"`       | [C string literals] |\n| `cr\"\u2026\"`, `cr#\"\u2026\"#`, `cr##\"\u2026\"##`, \u2026 | [raw C string literals] |\n\n## Macros\n\n| Syntax                                     | Use |\n|--------------------------------------------|-----|\n| `ident!(\u2026)`<br>`ident! {\u2026}`<br>`ident![\u2026]` | [macro invocations] |\n| `$ident`                                   | [macro metavariable] |\n| `$ident:kind`                              | [macro matcher fragment specifier] |\n| `$(\u2026)\u2026`                                    | [macro repetition] |\n\n## Attributes\n\n| Syntax     | Use |\n|------------|-----|\n| `#[meta]`  | [outer attribute] |\n| `#![meta]` | [inner attribute] |\n\n## Expressions\n\n| Expression                | Use |\n|---------------------------|-----|\n| `\\|\u2026\\| expr`<br>`\\|\u2026\\| -> Type { \u2026 }` | [closures] |\n| `ident::\u2026`                | [paths] |\n| `::crate_name::\u2026`         | [explicit crate paths] |\n| `crate::\u2026`                | [crate-relative paths] |\n| `self::\u2026`                 | [module-relative paths] |\n| `super::\u2026`                | [parent module paths] |\n| `Type::\u2026`<br>`<Type as Trait>::ident` | [associated items] |\n| `<Type>::\u2026`               | [qualified paths] which can be used for types without names such as `<&T>::\u2026`, `<[T]>::\u2026`, etc. |\n| `Trait::method(\u2026)`<br>`Type::method(\u2026)`<br>`<Type as Trait>::method(\u2026)` | [disambiguated method calls] |\n| `method::<\u2026>(\u2026)`<br>`path::<\u2026>` | [generic arguments], aka turbofish |\n| `()`                      | [unit] |\n| `(expr)`                  | [parenthesized expressions] |\n| `(expr,)`                 | [single-element tuple expressions] |\n| `(expr, \u2026)`               | [tuple expressions] |\n| `expr(expr, \u2026)`           | [call expressions] |\n| `expr.0`, `expr.1`, \u2026     | [tuple indexing expressions] |\n| `expr.ident`              | [field access expressions] |\n| `{\u2026}`                     | [block expressions] |\n| `Type {\u2026}`                | [struct expressions] |\n| `Type(\u2026)`                 | [tuple struct constructors] |\n| `[\u2026]`                     | [array expressions] |\n| `[expr; len]`             | [repeat array expressions] |\n| `expr[..]`, `expr[a..]`, `expr[..b]`, `expr[a..b]`, `expr[a..=b]`, `expr[..=b]` | [array and slice indexing expressions] |\n| `if expr {\u2026} else {\u2026}`    | [if expressions] |\n| `match expr { pattern => {\u2026} }` | [match expressions] |\n| `loop {\u2026}`                | [infinite loop expressions] |\n| `while expr {\u2026}`          | [predicate loop expressions] |\n| `for pattern in expr {\u2026}` | [iterator loops] |\n| `&expr`<br>`&mut expr`    | [borrow expressions] |\n| `&raw const expr`<br>`&raw mut expr` | [raw borrow expressions] |\n| `*expr`                   | [dereference expressions] |\n| `expr?`                   | [try propagation expressions] |\n| `-expr`                   | [negation expressions] |\n| `!expr`                   | [bitwise and logical NOT expressions] |\n| `expr as Type`            | [type cast expressions] |\n\n## Items\n\n[Items] are the components of a crate.\n\n| Item                          | Use |\n|-------------------------------|-----|\n| `mod ident;`<br>`mod ident {\u2026}` | [modules] |\n| `use path;`                   | [use declarations] |\n| `fn ident(\u2026) {\u2026}`             | [functions] |\n| `type Type = Type;`           | [type aliases] |\n| `struct ident {\u2026}`            | [structs] |\n| `enum ident {\u2026}`              | [enumerations] |\n| `union ident {\u2026}`             | [unions] |\n| `trait ident {\u2026}`             | [traits] |\n| `impl Type {\u2026}`<br>`impl Type for Trait {\u2026}` | [implementations] |\n| `const ident = expr;`         | [constant items] |\n| `static ident = expr;`        | [static items] |\n| `extern \"C\" {\u2026}`              | [external blocks] |\n| `fn ident<\u2026>(\u2026) \u2026`<br>`struct ident<\u2026> {\u2026}`<br>`enum ident<\u2026> {\u2026}`<br>`impl<\u2026> Type<\u2026> {\u2026}` | [generic definitions] |\n\n## Type expressions\n\n[Type expressions] are used to refer to types.\n\n| Type                                  | Use |\n|---------------------------------------|-----|\n| `bool`, `u8`, `f64`, `str`, \u2026         | [primitive types] |\n| `for<\u2026>`                              | [higher-ranked trait bounds] |\n| `T: TraitA + TraitB`                  | [trait bounds] |\n| `T: 'a + 'b`                          | [lifetime bounds] |\n| `T: TraitA + 'a`                      | [trait and lifetime bounds] |\n| `T: ?Sized`                           | [relaxed trait bounds] |\n| `[Type; len]`                         | [array types] |\n| `(Type, \u2026)`                           | [tuple types] |\n| `[Type]`                              | [slice types] |\n| `(Type)`                              | [parenthesized types] |\n| `impl Trait`                          | [impl trait types], [anonymous type parameters] |\n| `dyn Trait`                           | [trait object types] |\n| `ident`<br>`ident::\u2026`                 | [type paths] (can refer to [structs], [enumerations], [unions], [type aliases], [traits], [generics], etc.) |\n| `Type<\u2026>`<br>`Trait<\u2026>`               | [generic arguments] (e.g. `Vec<u8>`) |\n| `Trait<ident = Type>`                 | [associated type bindings] (e.g. `Iterator<Item = T>`) |\n| `Trait<ident: \u2026>`                     | [associated type bounds] (e.g. `Iterator<Item: Send>`) |\n| `&Type`<br>`&mut Type`                | [reference types] |\n| `*mut Type`<br>`*const Type`          | [raw pointer types] |\n| `fn(\u2026) -> Type`                       | [function pointer types] |\n| `_`                                   | [inferred type], [inferred const] |\n| `'_`                                  | [placeholder lifetime] |\n| `!`                                   | [never type] |\n\n## Patterns\n\n[Patterns] are used to match values.\n\n| Pattern                           | Use |\n|-----------------------------------|-----|\n| `\"foo\"`, `'a'`, `123`, `2.4`, \u2026   | [literal patterns] |\n| `ident`                           | [identifier patterns] |\n| `_`                               | [wildcard pattern] |\n| `..`                              | [rest pattern] |\n| `a..`, `..b`, `a..b`, `a..=b`, `..=b` | [range patterns] |\n| `&pattern`<br>`&mut pattern`      | [reference patterns] |\n| `path {\u2026}`                        | [struct patterns] |\n| `path(\u2026)`                         | [tuple struct patterns] |\n| `(pattern, \u2026)`                    | [tuple patterns] |\n| `(pattern)`                       | [grouped patterns] |\n| `[pattern, \u2026]`                    | [slice patterns] |\n| `CONST`, `Enum::Variant`, \u2026       | [path patterns] |\n\n[`'static` lifetimes]: bound\n[`if let` patterns]: expr.if.let\n[`self` paths]: paths.qualifiers.mod-self\n[`Self` type paths]: paths.qualifiers.type-self\n[anonymous type parameters]: type.impl-trait.param\n[arith]: expr.arith-logic\n[array and slice indexing expressions]: expr.array.index\n[array expressions]: expr.array\n[array types]: type.array\n[assembly operands]: asm.operand-type.supported-operands.in\n[assignment]: expr.assign\n[associated items]: items.associated\n[associated type bindings]: paths.expr\n[associated type bounds]: paths.expr\n[async blocks]: expr.block.async\n[async closures]: expr.closure.async\n[async functions]: items.fn.async\n[await expressions]: expr.await\n[bitwise and logical NOT expressions]: expr.negate\n[block expressions]: expr.block\n[boolean expressions]: expr.literal\n[boolean type]: type.bool\n[borrow expressions]: expr.operator.borrow\n[borrow]: expr.operator.borrow\n[break expressions]: expr.loop.break\n[byte literals]: lex.token.byte\n[byte string literals]: lex.token.str-byte\n[C string literals]: lex.token.str-c\n[call expressions]: expr.call\n[character literals]: lex.token.literal.char\n[closure expressions]: expr.closure\n[closures]: expr.closure\n[comparison]: expr.cmp\n[compound]: expr.compound-assign\n[configuration predicates]: cfg\n[const assembly operands]: asm.operand-type.supported-operands.const\n[const blocks]: expr.block.const\n[const functions]: const-eval.const-fn\n[const generics]: items.generics.const\n[const items]: items.const\n[constant items]: items.const\n[continue expressions]: expr.loop.continue\n[crate-relative paths]: paths.qualifiers.crate\n[dereference expressions]: expr.deref\n[dereference]: expr.deref\n[destructuring assignment]: expr.placeholder\n[disambiguated method calls]: expr.call.desugar\n[enumerations]: items.enum\n[explicit crate paths]: paths.qualifiers.global-root\n[extern crate]: items.extern-crate\n[extern function pointer types]: type.fn-pointer.qualifiers\n[extern function qualifier]: items.fn.extern\n[external block functions]: items.extern.fn\n[external block statics]: items.extern.static\n[external blocks]: items.extern\n[field access expressions]: expr.field\n[field]: expr.field\n[function pointer type]: type.fn-pointer\n[function pointer types]: type.fn-pointer\n[functions]: items.fn\n[generic arguments]: items.generics\n[generic definitions]: items.generics\n[generics]: items.generics\n[glob imports]: items.use.glob\n[grouped patterns]: patterns.paren\n[higher-ranked trait bounds]: bound.higher-ranked\n[identifier patterns]: patterns.ident\n[identifiers]: ident\n[if expressions]: expr.if\n[if let]: expr.if.let\n[impl trait types]: type.impl-trait.return\n[implementations]: items.impl\n[inferred const]: items.generics.const.inferred\n[inferred type]: type.inferred\n[infinite loop expressions]: expr.loop.infinite\n[infinite loops]: expr.loop.infinite\n[inherent impls]: items.impl.inherent\n[inner attribute]: attributes.inner\n[iterator loops]: expr.loop.for\n[lazy-bool]: expr.bool-logic\n[let statements]: statement.let\n[lifetime bounds]: bound.lifetime\n[lifetimes and loop labels]: lex.token.life\n[literal patterns]: patterns.literal\n[macro calls]: macro.invocation\n[macro invocations]: macro.invocation\n[macro Kleene matcher]: macro.decl.repetition\n[macro matcher fragment specifier]: macro.decl.meta.specifier\n[macro metavariable]: macro.decl.meta\n[macro repetition]: macro.decl.repetition\n[macros by example]: macro.decl\n[macros]: macro.decl\n[match expressions]: expr.match\n[match guards]: expr.match.guard\n[match]: expr.match\n[module-relative paths]: paths.qualifiers.mod-self\n[modules]: items.mod\n[negation expressions]: expr.negate\n[negation]: expr.negate\n[negative impls]: items.impl\n[never type]: type.never\n[number literals]: lex.token.literal.num\n[or patterns]: patterns.or\n[outer attribute]: attributes.outer\n[parent module paths]: paths.qualifiers.super\n[parenthesized expressions]: expr.paren\n[parenthesized types]: type.name.parenthesized\n[path patterns]: patterns.path\n[placeholder lifetime]: lifetime-elision.function.explicit-placeholder\n[predicate loop expressions]: expr.loop.while\n[predicate loops]: expr.loop.while\n[primitive types]: type.kinds\n[qualified paths]: paths.qualified\n[question]: expr.try\n[range patterns]: patterns.range\n[raw assembly]: asm.options.supported-options.raw\n[raw borrow expressions]: expr.borrow.raw\n[raw borrow operator]: expr.borrow.raw\n[raw byte string literals]: lex.token.str-byte-raw\n[raw C string literals]: lex.token.str-c-raw\n[raw identifiers]: ident.raw\n[raw lifetimes and loop labels]: lex.token.life\n[raw pointer type]: type.pointer.raw\n[raw pointer types]: type.pointer.raw\n[raw pointers]: type.pointer.raw\n[raw string literals]: lex.token.literal.str-raw\n[reference patterns]: patterns.ref\n[reference types]: type.pointer.reference\n[references]: type.pointer.reference\n[relaxed trait bounds]: bound.sized\n[repeat array expressions]: expr.array\n[reserved keyword]: lex.keywords.reserved\n[rest pattern]: patterns.rest\n[return expressions]: expr.return\n[self parameters]: items.fn.params.self-pat\n[single-element tuple expressions]: expr.tuple\n[slice patterns]: patterns.slice\n[slice types]: type.slice\n[static items]: items.static\n[string literals]: lex.token.literal.str\n[struct expressions]: expr.struct\n[struct patterns]: patterns.struct\n[structs]: items.struct\n[subpattern binding]: patterns.ident.scrutinized\n[super paths]: paths.qualifiers.super\n[trait and lifetime bounds]: bound\n[trait bounds]: bound\n[trait implementations]: items.impl.trait\n[trait impls]: items.impl.trait\n[trait items]: items.traits\n[trait object types]: type.trait-object\n[trait objects]: type.trait-object\n[traits]: items.traits\n[try propagation expressions]: expr.try\n[tuple expressions]: expr.tuple\n[tuple index]: expr.tuple-index\n[tuple indexing expressions]: expr.tuple-index\n[tuple patterns]: patterns.tuple\n[tuple struct constructors]: items.struct.tuple\n[tuple struct patterns]: patterns.tuple-struct\n[tuple types]: type.tuple\n[type aliases]: items.type\n[type cast expressions]: expr.as\n[Type expressions]: type.name\n[type paths]: type.name.path\n[union items]: items.union\n[unions]: items.union\n[unit]: type.tuple.unit\n[unsafe attributes]: attributes.safety\n[unsafe blocks]: expr.block.unsafe\n[unsafe external blocks]: unsafe.extern\n[unsafe external functions]: items.extern.fn.safety\n[unsafe external statics]: items.extern.static.safety\n[unsafe functions]: unsafe.fn\n[unsafe modules]: items.mod.unsafe\n[unsafe trait implementations]: items.impl.trait.safety\n[unsafe traits]: items.traits.safety\n[use bounds]: bound.use\n[use declarations]: items.use\n[use items]: items.use\n[variadic functions]: items.extern.variadic\n[visibility]: vis\n[where clauses]: items.generics.where\n[while let]: expr.loop.while.let\n[wildcard pattern]: patterns.wildcard",
      "parent_id": null,
      "paragraphs": {
        "syntax_index_p1": "# Syntax index\n\nThis appendix provides an index of tokens and common forms with links to where those elements are defined.\n\n## Keywords\n\n| Keyword       | Use |\n|---------------|-----|\n| `_`           | [wildcard pattern], [inferred const], [inferred type], [placeholder lifetime], [constant items], [extern crate], [use declarations], [destructuring assignment] |\n| `abstract`    | [reserved keyword] |\n| `as`          | extern crate, use declarations, [type cast expressions], [qualified paths] |\n| `async`       | [async functions], [async blocks], [async closures] |\n| `await`       | [await expressions] |\n| `become`      | [reserved keyword] |\n| `box`         | [reserved keyword] |\n| `break`       | [break expressions] |\n| `const`       | [const functions], [const items], [const generics], [const blocks], [raw borrow operator], [raw pointer type], [const assembly operands] |\n| `continue`    | [continue expressions] |\n| `crate`       | [extern crate], [visibility], [paths] |\n| `do`          | [reserved keyword] |\n| `dyn`         | [trait objects] |\n| `else`        | [let statements], [if expressions] |\n| `enum`        | [enumerations] |\n| `extern`      | [extern crate], [extern function qualifier], [external blocks], [extern function pointer types] |\n| `false`       | [boolean type], [boolean expressions], [configuration predicates] |\n| `final`       | [reserved keyword] |\n| `fn`          | [functions], [function pointer types] |\n| `for`         | [trait implementations], [iterator loops], [higher-ranked trait bounds] |\n| `gen`         | [reserved keyword] |\n| `if`          | [if expressions], [match guards] |\n| `impl`        | [inherent impls], [trait impls], [impl trait types], [anonymous type parameters] |\n| `in`          | [visibility], [iterator loops], [assembly operands] |\n| `let`         | [let statements], [`if let` patterns] |\n| `loop`        | [infinite loops] |\n| `macro_rules` | [macros by example] |\n| `macro`       | [reserved keyword] |\n| `match`       | [match expressions] |\n| `mod`         | [modules] |\n| `move`        | [closure expressions], [async blocks] |\n| `mut`         | [borrow expressions], [identifier patterns], [reference patterns], [struct patterns], [reference types], [raw pointer types], [self parameters], [static items] |\n| `override`    | [reserved keyword] |\n| `priv`        | [reserved keyword] |\n| `pub`         | [visibility] |\n| `raw`         | [borrow expressions], [raw assembly] |\n| `ref`         | [identifier patterns], [struct patterns] |\n| `return`      | [return expressions] |\n| `safe`        | [external block functions], [external block statics] |\n| `self`        | extern crate, [self parameters], [visibility], [`self` paths] |\n| `Self`        | [`Self` type paths], [use bounds] |\n| `static`      | [static items], [`'static` lifetimes] |\n| `struct`      | [structs] |\n| `super`       | [super paths], [visibility] |\n| `trait`       | [trait items] |\n| `true`        | [boolean type], [boolean expressions], [configuration predicates] |\n| `try`         | [reserved keyword] |\n| `type`        | [type aliases] |\n| `typeof`      | [reserved keyword] |\n| `union`       | [union items] |\n| `unsafe`      | [unsafe blocks], [unsafe attributes], [unsafe modules], [unsafe functions], [unsafe external blocks], [unsafe external functions], [unsafe external statics], [unsafe traits], [unsafe trait implementations] |\n| `unsized`     | [reserved keyword] |\n| `use`         | [use items], [use bounds] |\n| `virtual`     | [reserved keyword] |\n| `where`       | [where clauses] |\n| `while`       | [predicate loops] |\n| `yield`       | [reserved keyword] |\n\n## Operators and punctuation\n\n| Symbol | Name        | Use |\n|--------|-------------|-----|\n| `+`    | Plus        | addition, [trait bounds], [macro Kleene matcher] |\n| `-`    | Minus       | subtraction, [negation] |\n| `*`    | Star        | multiplication, [dereference], [raw pointers], [macro Kleene matcher], [glob imports] |\n| `/`    | Slash       | division |\n| `%`    | Percent     | remainder |\n| `^`    | Caret       | bitwise and logical XOR |\n| `!`    | Not         | bitwise and logical NOT, [macro calls], inner attributes, [never type], [negative impls] |\n| `&`    | And         | bitwise and logical AND, [borrow], [references], [reference patterns] |\n| `\\|`   | Or | bitwise and logical OR, [closures], [or patterns], [if let], [while let] |\n| `&&`   | AndAnd      | lazy AND, [borrow], [references], [reference patterns] |\n| `\\|\\|` | OrOr | lazy OR, [closures] |\n| `<<`   | Shl         | shift left, nested generics |\n| `>>`   | Shr         | shift right, nested generics |\n| `+=`   | PlusEq      | addition assignment |\n| `-=`   | MinusEq     | subtraction assignment |\n| `*=`   | StarEq      | multiplication assignment |\n| `/=`   | SlashEq     | division assignment |\n| `%=`   | PercentEq   | remainder assignment |\n| `^=`   | CaretEq     | bitwise XOR assignment |\n| `&=`   | AndEq       | bitwise AND assignment |\n| `\\|=`  | OrEq | bitwise OR assignment |\n| `<<=`  | ShlEq       | shift left assignment |\n| `>>=`  | ShrEq       | shift right assignment, nested generics |\n| `=`    | Eq          | [assignment], [let statements], [attributes], various type definitions |\n| `==`   | EqEq        | equal |\n| `!=`   | Ne          | not equal |\n| `>`    | Gt          | greater than, [generics], [paths], [use bounds] |\n| `<`    | Lt          | less than, [generics], [paths], [use bounds] |\n| `>=`   | Ge          | greater than or equal to, [generics] |\n| `<=`   | Le          | less than or equal to |\n| `@`    | At          | [subpattern binding] |\n| `.`    | Dot         | field access, [tuple index] |\n| `..`   | DotDot      | range expressions, [struct expressions], [rest pattern], [range patterns], [struct patterns] |\n| `...`  | DotDotDot   | [variadic functions], [range patterns] |\n| `..=`  | DotDotEq    | inclusive range expressions, [range patterns] |\n| `,`    | Comma       | various separators |\n| `;`    | Semi        | terminator for various items and statements, [array expressions], [array types] |\n| `:`    | Colon       | various separators |\n| `::`   | PathSep     | path separator |\n| `->`   | RArrow      | [functions], [closures], [function pointer type] |\n| `=>`   | FatArrow    | match arms, [macros] |\n| `<-`   | LArrow      | The left arrow symbol has been unused since before Rust 1.0, but it is still treated as a single token. |\n| `#`    | Pound       | [attributes], [raw string literals], [raw byte string literals], [raw C string literals] |\n| `$`    | Dollar      | [macros] |\n| `?`    | Question    | try propagation expressions, [relaxed trait bounds], [macro Kleene matcher] |\n| `~`    | Tilde       | The tilde operator has been unused since before Rust 1.0, but its token may still be used. |\n\n## Comments\n\n| Comment  | Use |\n|----------|-----|\n| `//`     | line comment |\n| `//!`    | inner line comment |\n| `///`    | outer line doc comment |\n| `/*\u2026*/`  | block comment |\n| `/*!\u2026*/` | inner block doc comment |\n| `/**\u2026*/` | outer block doc comment |\n\n## Other tokens\n\n| Token        | Use |\n|--------------|-----|\n| `ident`      | [identifiers] |\n| `r#ident`    | [raw identifiers] |\n| `'ident`     | [lifetimes and loop labels] |\n| `'r#ident`   | [raw lifetimes and loop labels] |\n| `\u2026u8`, `\u2026i32`, `\u2026f64`, `\u2026usize`, \u2026 | [number literals] |\n| `\"\u2026\"`        | [string literals] |\n| `r\"\u2026\"`, `r#\"\u2026\"#`, `r##\"\u2026\"##`, \u2026 | [raw string literals] |\n| `b\"\u2026\"`       | [byte string literals] |\n| `br\"\u2026\"`, `br#\"\u2026\"#`, `br##\"\u2026\"##`, \u2026 | [raw byte string literals] |\n| `'\u2026'`        | [character literals] |\n| `b'\u2026'`       | [byte literals] |\n| `c\"\u2026\"`       | [C string literals] |\n| `cr\"\u2026\"`, `cr#\"\u2026\"#`, `cr##\"\u2026\"##`, \u2026 | [raw C string literals] |\n\n## Macros\n\n| Syntax                                     | Use |\n|--------------------------------------------|-----|\n| `ident!(\u2026)`<br>`ident! {\u2026}`<br>`ident![\u2026]` | [macro invocations] |\n| `$ident`                                   | [macro metavariable] |\n| `$ident:kind`                              | [macro matcher fragment specifier] |\n| `$(\u2026)\u2026`                                    | [macro repetition] |\n\n## Attributes\n\n| Syntax     | Use |\n|------------|-----|\n| `#[meta]`  | [outer attribute] |\n| `#![meta]` | [inner attribute] |\n\n## Expressions\n\n| Expression                | Use |\n|---------------------------|-----|\n| `\\|\u2026\\| expr`<br>`\\|\u2026\\| -> Type { \u2026 }` | [closures] |\n| `ident::\u2026`                | [paths] |\n| `::crate_name::\u2026`         | [explicit crate paths] |\n| `crate::\u2026`                | [crate-relative paths] |\n| `self::\u2026`                 | [module-relative paths] |\n| `super::\u2026`                | [parent module paths] |\n| `Type::\u2026`<br>`<Type as Trait>::ident` | [associated items] |\n| `<Type>::\u2026`               | [qualified paths] which can be used for types without names such as `<&T>::\u2026`, `<[T]>::\u2026`, etc. |\n| `Trait::method(\u2026)`<br>`Type::method(\u2026)`<br>`<Type as Trait>::method(\u2026)` | [disambiguated method calls] |\n| `method::<\u2026>(\u2026)`<br>`path::<\u2026>` | [generic arguments], aka turbofish |\n| `()`                      | [unit] |\n| `(expr)`                  | [parenthesized expressions] |\n| `(expr,)`                 | [single-element tuple expressions] |\n| `(expr, \u2026)`               | [tuple expressions] |\n| `expr(expr, \u2026)`           | [call expressions] |\n| `expr.0`, `expr.1`, \u2026     | [tuple indexing expressions] |\n| `expr.ident`              | [field access expressions] |\n| `{\u2026}`                     | [block expressions] |\n| `Type {\u2026}`                | [struct expressions] |\n| `Type(\u2026)`                 | [tuple struct constructors] |\n| `[\u2026]`                     | [array expressions] |\n| `[expr; len]`             | [repeat array expressions] |\n| `expr[..]`, `expr[a..]`, `expr[..b]`, `expr[a..b]`, `expr[a..=b]`, `expr[..=b]` | [array and slice indexing expressions] |\n| `if expr {\u2026} else {\u2026}`    | [if expressions] |\n| `match expr { pattern => {\u2026} }` | [match expressions] |\n| `loop {\u2026}`                | [infinite loop expressions] |\n| `while expr {\u2026}`          | [predicate loop expressions] |\n| `for pattern in expr {\u2026}` | [iterator loops] |\n| `&expr`<br>`&mut expr`    | [borrow expressions] |\n| `&raw const expr`<br>`&raw mut expr` | [raw borrow expressions] |\n| `*expr`                   | [dereference expressions] |\n| `expr?`                   | [try propagation expressions] |\n| `-expr`                   | [negation expressions] |\n| `!expr`                   | [bitwise and logical NOT expressions] |\n| `expr as Type`            | [type cast expressions] |\n\n## Items\n\n[Items] are the components of a crate.\n\n| Item                          | Use |\n|-------------------------------|-----|\n| `mod ident;`<br>`mod ident {\u2026}` | [modules] |\n| `use path;`                   | [use declarations] |\n| `fn ident(\u2026) {\u2026}`             | [functions] |\n| `type Type = Type;`           | [type aliases] |\n| `struct ident {\u2026}`            | [structs] |\n| `enum ident {\u2026}`              | [enumerations] |\n| `union ident {\u2026}`             | [unions] |\n| `trait ident {\u2026}`             | [traits] |\n| `impl Type {\u2026}`<br>`impl Type for Trait {\u2026}` | [implementations] |\n| `const ident = expr;`         | [constant items] |\n| `static ident = expr;`        | [static items] |\n| `extern \"C\" {\u2026}`              | [external blocks] |\n| `fn ident<\u2026>(\u2026) \u2026`<br>`struct ident<\u2026> {\u2026}`<br>`enum ident<\u2026> {\u2026}`<br>`impl<\u2026> Type<\u2026> {\u2026}` | [generic definitions] |\n\n## Type expressions\n\n[Type expressions] are used to refer to types.\n\n| Type                                  | Use |\n|---------------------------------------|-----|\n| `bool`, `u8`, `f64`, `str`, \u2026         | [primitive types] |\n| `for<\u2026>`                              | [higher-ranked trait bounds] |\n| `T: TraitA + TraitB`                  | [trait bounds] |\n| `T: 'a + 'b`                          | [lifetime bounds] |\n| `T: TraitA + 'a`                      | [trait and lifetime bounds] |\n| `T: ?Sized`                           | [relaxed trait bounds] |\n| `[Type; len]`                         | [array types] |\n| `(Type, \u2026)`                           | [tuple types] |\n| `[Type]`                              | [slice types] |\n| `(Type)`                              | [parenthesized types] |\n| `impl Trait`                          | [impl trait types], [anonymous type parameters] |\n| `dyn Trait`                           | [trait object types] |\n| `ident`<br>`ident::\u2026`                 | [type paths] (can refer to [structs], [enumerations], [unions], [type aliases], [traits], [generics], etc.) |\n| `Type<\u2026>`<br>`Trait<\u2026>`               | [generic arguments] (e.g. `Vec<u8>`) |\n| `Trait<ident = Type>`                 | [associated type bindings] (e.g. `Iterator<Item = T>`) |\n| `Trait<ident: \u2026>`                     | [associated type bounds] (e.g. `Iterator<Item: Send>`) |\n| `&Type`<br>`&mut Type`                | [reference types] |\n| `*mut Type`<br>`*const Type`          | [raw pointer types] |\n| `fn(\u2026) -> Type`                       | [function pointer types] |\n| `_`                                   | [inferred type], [inferred const] |\n| `'_`                                  | [placeholder lifetime] |\n| `!`                                   | [never type] |\n\n## Patterns\n\n[Patterns] are used to match values.\n\n| Pattern                           | Use |\n|-----------------------------------|-----|\n| `\"foo\"`, `'a'`, `123`, `2.4`, \u2026   | [literal patterns] |\n| `ident`                           | [identifier patterns] |\n| `_`                               | [wildcard pattern] |\n| `..`                              | [rest pattern] |\n| `a..`, `..b`, `a..b`, `a..=b`, `..=b` | [range patterns] |\n| `&pattern`<br>`&mut pattern`      | [reference patterns] |\n| `path {\u2026}`                        | [struct patterns] |\n| `path(\u2026)`                         | [tuple struct patterns] |\n| `(pattern, \u2026)`                    | [tuple patterns] |\n| `(pattern)`                       | [grouped patterns] |\n| `[pattern, \u2026]`                    | [slice patterns] |\n| `CONST`, `Enum::Variant`, \u2026       | [path patterns] |\n\n[`'static` lifetimes]: bound\n[`if let` patterns]: expr.if.let\n[`self` paths]: paths.qualifiers.mod-self\n[`Self` type paths]: paths.qualifiers.type-self\n[anonymous type parameters]: type.impl-trait.param\n[arith]: expr.arith-logic\n[array and slice indexing expressions]: expr.array.index\n[array expressions]: expr.array\n[array types]: type.array\n[assembly operands]: asm.operand-type.supported-operands.in\n[assignment]: expr.assign\n[associated items]: items.associated\n[associated type bindings]: paths.expr\n[associated type bounds]: paths.expr\n[async blocks]: expr.block.async\n[async closures]: expr.closure.async\n[async functions]: items.fn.async\n[await expressions]: expr.await\n[bitwise and logical NOT expressions]: expr.negate\n[block expressions]: expr.block\n[boolean expressions]: expr.literal\n[boolean type]: type.bool\n[borrow expressions]: expr.operator.borrow\n[borrow]: expr.operator.borrow\n[break expressions]: expr.loop.break\n[byte literals]: lex.token.byte\n[byte string literals]: lex.token.str-byte\n[C string literals]: lex.token.str-c\n[call expressions]: expr.call\n[character literals]: lex.token.literal.char\n[closure expressions]: expr.closure\n[closures]: expr.closure\n[comparison]: expr.cmp\n[compound]: expr.compound-assign\n[configuration predicates]: cfg\n[const assembly operands]: asm.operand-type.supported-operands.const\n[const blocks]: expr.block.const\n[const functions]: const-eval.const-fn\n[const generics]: items.generics.const\n[const items]: items.const\n[constant items]: items.const\n[continue expressions]: expr.loop.continue\n[crate-relative paths]: paths.qualifiers.crate\n[dereference expressions]: expr.deref\n[dereference]: expr.deref\n[destructuring assignment]: expr.placeholder\n[disambiguated method calls]: expr.call.desugar\n[enumerations]: items.enum\n[explicit crate paths]: paths.qualifiers.global-root\n[extern crate]: items.extern-crate\n[extern function pointer types]: type.fn-pointer.qualifiers\n[extern function qualifier]: items.fn.extern\n[external block functions]: items.extern.fn\n[external block statics]: items.extern.static\n[external blocks]: items.extern\n[field access expressions]: expr.field\n[field]: expr.field\n[function pointer type]: type.fn-pointer\n[function pointer types]: type.fn-pointer\n[functions]: items.fn\n[generic arguments]: items.generics\n[generic definitions]: items.generics\n[generics]: items.generics\n[glob imports]: items.use.glob\n[grouped patterns]: patterns.paren\n[higher-ranked trait bounds]: bound.higher-ranked\n[identifier patterns]: patterns.ident\n[identifiers]: ident\n[if expressions]: expr.if\n[if let]: expr.if.let\n[impl trait types]: type.impl-trait.return\n[implementations]: items.impl\n[inferred const]: items.generics.const.inferred\n[inferred type]: type.inferred\n[infinite loop expressions]: expr.loop.infinite\n[infinite loops]: expr.loop.infinite\n[inherent impls]: items.impl.inherent\n[inner attribute]: attributes.inner\n[iterator loops]: expr.loop.for\n[lazy-bool]: expr.bool-logic\n[let statements]: statement.let\n[lifetime bounds]: bound.lifetime\n[lifetimes and loop labels]: lex.token.life\n[literal patterns]: patterns.literal\n[macro calls]: macro.invocation\n[macro invocations]: macro.invocation\n[macro Kleene matcher]: macro.decl.repetition\n[macro matcher fragment specifier]: macro.decl.meta.specifier\n[macro metavariable]: macro.decl.meta\n[macro repetition]: macro.decl.repetition\n[macros by example]: macro.decl\n[macros]: macro.decl\n[match expressions]: expr.match\n[match guards]: expr.match.guard\n[match]: expr.match\n[module-relative paths]: paths.qualifiers.mod-self\n[modules]: items.mod\n[negation expressions]: expr.negate\n[negation]: expr.negate\n[negative impls]: items.impl\n[never type]: type.never\n[number literals]: lex.token.literal.num\n[or patterns]: patterns.or\n[outer attribute]: attributes.outer\n[parent module paths]: paths.qualifiers.super\n[parenthesized expressions]: expr.paren\n[parenthesized types]: type.name.parenthesized\n[path patterns]: patterns.path\n[placeholder lifetime]: lifetime-elision.function.explicit-placeholder\n[predicate loop expressions]: expr.loop.while\n[predicate loops]: expr.loop.while\n[primitive types]: type.kinds\n[qualified paths]: paths.qualified\n[question]: expr.try\n[range patterns]: patterns.range\n[raw assembly]: asm.options.supported-options.raw\n[raw borrow expressions]: expr.borrow.raw\n[raw borrow operator]: expr.borrow.raw\n[raw byte string literals]: lex.token.str-byte-raw\n[raw C string literals]: lex.token.str-c-raw\n[raw identifiers]: ident.raw\n[raw lifetimes and loop labels]: lex.token.life\n[raw pointer type]: type.pointer.raw\n[raw pointer types]: type.pointer.raw\n[raw pointers]: type.pointer.raw\n[raw string literals]: lex.token.literal.str-raw\n[reference patterns]: patterns.ref\n[reference types]: type.pointer.reference\n[references]: type.pointer.reference\n[relaxed trait bounds]: bound.sized\n[repeat array expressions]: expr.array\n[reserved keyword]: lex.keywords.reserved\n[rest pattern]: patterns.rest\n[return expressions]: expr.return\n[self parameters]: items.fn.params.self-pat\n[single-element tuple expressions]: expr.tuple\n[slice patterns]: patterns.slice\n[slice types]: type.slice\n[static items]: items.static\n[string literals]: lex.token.literal.str\n[struct expressions]: expr.struct\n[struct patterns]: patterns.struct\n[structs]: items.struct\n[subpattern binding]: patterns.ident.scrutinized\n[super paths]: paths.qualifiers.super\n[trait and lifetime bounds]: bound\n[trait bounds]: bound\n[trait implementations]: items.impl.trait\n[trait impls]: items.impl.trait\n[trait items]: items.traits\n[trait object types]: type.trait-object\n[trait objects]: type.trait-object\n[traits]: items.traits\n[try propagation expressions]: expr.try\n[tuple expressions]: expr.tuple\n[tuple index]: expr.tuple-index\n[tuple indexing expressions]: expr.tuple-index\n[tuple patterns]: patterns.tuple\n[tuple struct constructors]: items.struct.tuple\n[tuple struct patterns]: patterns.tuple-struct\n[tuple types]: type.tuple\n[type aliases]: items.type\n[type cast expressions]: expr.as\n[Type expressions]: type.name\n[type paths]: type.name.path\n[union items]: items.union\n[unions]: items.union\n[unit]: type.tuple.unit\n[unsafe attributes]: attributes.safety\n[unsafe blocks]: expr.block.unsafe\n[unsafe external blocks]: unsafe.extern\n[unsafe external functions]: items.extern.fn.safety\n[unsafe external statics]: items.extern.static.safety\n[unsafe functions]: unsafe.fn\n[unsafe modules]: items.mod.unsafe\n[unsafe trait implementations]: items.impl.trait.safety\n[unsafe traits]: items.traits.safety\n[use bounds]: bound.use\n[use declarations]: items.use\n[use items]: items.use\n[variadic functions]: items.extern.variadic\n[visibility]: vis\n[where clauses]: items.generics.where\n[while let]: expr.loop.while.let\n[wildcard pattern]: patterns.wildcard"
      }
    },
    {
      "id": "macro.ambiguity",
      "title": "Appendix: Macro follow-set ambiguity formal specification",
      "level": 1,
      "content": "This page documents the formal specification of the follow rules for [Macros\nBy Example]. They were originally specified in [RFC 550], from which the bulk\nof this text is copied, and expanded upon in subsequent RFCs.",
      "parent_id": null,
      "paragraphs": {
        "macro.ambiguity": "This page documents the formal specification of the follow rules for [Macros\nBy Example]. They were originally specified in [RFC 550], from which the bulk\nof this text is copied, and expanded upon in subsequent RFCs."
      }
    },
    {
      "id": "macro.ambiguity.convention",
      "title": "Definitions & conventions",
      "level": 1,
      "content": "- `macro`: anything invocable as `foo!(...)` in source code.\n  - `MBE`: macro-by-example, a macro defined by `macro_rules`.\n  - `matcher`: the left-hand-side of a rule in a `macro_rules` invocation, or a\n    subportion thereof.\n  - `macro parser`: the bit of code in the Rust parser that will parse the\n    input using a grammar derived from all of the matchers.\n  - `fragment`: The class of Rust syntax that a given matcher will accept (or\n    \"match\").\n  - `repetition` : a fragment that follows a regular repeating pattern\n  - `NT`: non-terminal, the various \"meta-variables\" or repetition matchers\n    that can appear in a matcher, specified in MBE syntax with a leading `$`\n    character.\n  - `simple NT`: a \"meta-variable\" non-terminal (further discussion below).\n  - `complex NT`: a repetition matching non-terminal, specified via repetition\n    operators (`*`, `+`, `?`).\n  - `token`: an atomic element of a matcher; i.e. identifiers, operators,\n    open/close delimiters, *and* simple NT's.\n  - `token tree`: a tree structure formed from tokens (the leaves), complex\n    NT's, and finite sequences of token trees.\n  - `delimiter token`: a token that is meant to divide the end of one fragment\n    and the start of the next fragment.\n  - `separator token`: an optional delimiter token in an complex NT that\n    separates each pair of elements in the matched repetition.\n  - `separated complex NT`: a complex NT that has its own separator token.\n  - `delimited sequence`: a sequence of token trees with appropriate open- and\n    close-delimiters at the start and end of the sequence.\n  - `empty fragment`: The class of invisible Rust syntax that separates tokens,\n    i.e. whitespace, or (in some lexical contexts), the empty token sequence.\n  - `fragment specifier`: The identifier in a simple NT that specifies which\n    fragment the NT accepts.\n  - `language`: a context-free language.\n\nExample:\n\n,compile_fail\nmacro_rules! i_am_an_mbe {\n    (start $foo:expr $($i:ident),* end) => ($foo)\n}\n\n`(start $foo:expr $($i:ident),* end)` is a matcher. The whole matcher is a\ndelimited sequence (with open- and close-delimiters `(` and `)`), and `$foo`\nand `$i` are simple NT's with `expr` and `ident` as their respective fragment\nspecifiers.\n\n`$(i:ident),*` is *also* an NT; it is a complex NT that matches a\ncomma-separated repetition of identifiers. The `,` is the separator token for\nthe complex NT; it occurs in between each pair of elements (if any) of the\nmatched fragment.\n\nAnother example of a complex NT is `$(hi $e:expr ;)+`, which matches any\nfragment of the form `hi <expr>; hi <expr>; ...` where `hi <expr>;` occurs at\nleast once. Note that this complex NT does not have a dedicated separator\ntoken.\n\n(Note that Rust's parser ensures that delimited sequences always occur with\nproper nesting of token tree structure and correct matching of open- and\nclose-delimiters.)\n\nWe will tend to use the variable \"M\" to stand for a matcher, variables \"t\" and\n\"u\" for arbitrary individual tokens, and the variables \"tt\" and \"uu\" for\narbitrary token trees. (The use of \"tt\" does present potential ambiguity with\nits additional role as a fragment specifier; but it will be clear from context\nwhich interpretation is meant.)\n\n\"SEP\" will range over separator tokens, \"OP\" over the repetition operators\n`*`, `+`, and `?`, \"OPEN\"/\"CLOSE\" over matching token pairs surrounding a\ndelimited sequence (e.g. `[` and `]`).\n\nGreek letters \"\u03b1\" \"\u03b2\" \"\u03b3\" \"\u03b4\"  stand for potentially empty token-tree sequences.\n(However, the Greek letter \"\u03b5\" (epsilon) has a special role in the presentation\nand does not stand for a token-tree sequence.)\n\n  * This Greek letter convention is usually just employed when the presence of\n    a sequence is a technical detail; in particular, when we wish to *emphasize*\n    that we are operating on a sequence of token-trees, we will use the notation\n    \"tt ...\" for the sequence, not a Greek letter.\n\nNote that a matcher is merely a token tree. A \"simple NT\", as mentioned above,\nis an meta-variable NT; thus it is a non-repetition. For example, `$foo:ty` is\na simple NT but `$($foo:ty)+` is a complex NT.\n\nNote also that in the context of this formalism, the term \"token\" generally\n*includes* simple NTs.\n\nFinally, it is useful for the reader to keep in mind that according to the\ndefinitions of this formalism, no simple NT matches the empty fragment, and\nlikewise no token matches the empty fragment of Rust syntax. (Thus, the *only*\nNT that can match the empty fragment is a complex NT.) This is not actually\ntrue, because the `vis` matcher can match an empty fragment. Thus, for the\npurposes of the formalism, we will treat `$v:vis` as actually being\n`$($v:vis)?`, with a requirement that the matcher match an empty fragment.",
      "parent_id": null,
      "paragraphs": {
        "macro.ambiguity.convention.defs": "- `macro`: anything invocable as `foo!(...)` in source code.\n  - `MBE`: macro-by-example, a macro defined by `macro_rules`.\n  - `matcher`: the left-hand-side of a rule in a `macro_rules` invocation, or a\n    subportion thereof.\n  - `macro parser`: the bit of code in the Rust parser that will parse the\n    input using a grammar derived from all of the matchers.\n  - `fragment`: The class of Rust syntax that a given matcher will accept (or\n    \"match\").\n  - `repetition` : a fragment that follows a regular repeating pattern\n  - `NT`: non-terminal, the various \"meta-variables\" or repetition matchers\n    that can appear in a matcher, specified in MBE syntax with a leading `$`\n    character.\n  - `simple NT`: a \"meta-variable\" non-terminal (further discussion below).\n  - `complex NT`: a repetition matching non-terminal, specified via repetition\n    operators (`*`, `+`, `?`).\n  - `token`: an atomic element of a matcher; i.e. identifiers, operators,\n    open/close delimiters, *and* simple NT's.\n  - `token tree`: a tree structure formed from tokens (the leaves), complex\n    NT's, and finite sequences of token trees.\n  - `delimiter token`: a token that is meant to divide the end of one fragment\n    and the start of the next fragment.\n  - `separator token`: an optional delimiter token in an complex NT that\n    separates each pair of elements in the matched repetition.\n  - `separated complex NT`: a complex NT that has its own separator token.\n  - `delimited sequence`: a sequence of token trees with appropriate open- and\n    close-delimiters at the start and end of the sequence.\n  - `empty fragment`: The class of invisible Rust syntax that separates tokens,\n    i.e. whitespace, or (in some lexical contexts), the empty token sequence.\n  - `fragment specifier`: The identifier in a simple NT that specifies which\n    fragment the NT accepts.\n  - `language`: a context-free language.\n\nExample:\n\n,compile_fail\nmacro_rules! i_am_an_mbe {\n    (start $foo:expr $($i:ident),* end) => ($foo)\n}",
        "macro.ambiguity.convention.matcher": "`(start $foo:expr $($i:ident),* end)` is a matcher. The whole matcher is a\ndelimited sequence (with open- and close-delimiters `(` and `)`), and `$foo`\nand `$i` are simple NT's with `expr` and `ident` as their respective fragment\nspecifiers.",
        "macro.ambiguity.convention.complex-nt": "`$(i:ident),*` is *also* an NT; it is a complex NT that matches a\ncomma-separated repetition of identifiers. The `,` is the separator token for\nthe complex NT; it occurs in between each pair of elements (if any) of the\nmatched fragment.\n\nAnother example of a complex NT is `$(hi $e:expr ;)+`, which matches any\nfragment of the form `hi <expr>; hi <expr>; ...` where `hi <expr>;` occurs at\nleast once. Note that this complex NT does not have a dedicated separator\ntoken.\n\n(Note that Rust's parser ensures that delimited sequences always occur with\nproper nesting of token tree structure and correct matching of open- and\nclose-delimiters.)",
        "macro.ambiguity.convention.vars": "We will tend to use the variable \"M\" to stand for a matcher, variables \"t\" and\n\"u\" for arbitrary individual tokens, and the variables \"tt\" and \"uu\" for\narbitrary token trees. (The use of \"tt\" does present potential ambiguity with\nits additional role as a fragment specifier; but it will be clear from context\nwhich interpretation is meant.)",
        "macro.ambiguity.convention.set": "\"SEP\" will range over separator tokens, \"OP\" over the repetition operators\n`*`, `+`, and `?`, \"OPEN\"/\"CLOSE\" over matching token pairs surrounding a\ndelimited sequence (e.g. `[` and `]`).",
        "macro.ambiguity.convention.sequence-vars": "Greek letters \"\u03b1\" \"\u03b2\" \"\u03b3\" \"\u03b4\"  stand for potentially empty token-tree sequences.\n(However, the Greek letter \"\u03b5\" (epsilon) has a special role in the presentation\nand does not stand for a token-tree sequence.)\n\n  * This Greek letter convention is usually just employed when the presence of\n    a sequence is a technical detail; in particular, when we wish to *emphasize*\n    that we are operating on a sequence of token-trees, we will use the notation\n    \"tt ...\" for the sequence, not a Greek letter.\n\nNote that a matcher is merely a token tree. A \"simple NT\", as mentioned above,\nis an meta-variable NT; thus it is a non-repetition. For example, `$foo:ty` is\na simple NT but `$($foo:ty)+` is a complex NT.\n\nNote also that in the context of this formalism, the term \"token\" generally\n*includes* simple NTs.\n\nFinally, it is useful for the reader to keep in mind that according to the\ndefinitions of this formalism, no simple NT matches the empty fragment, and\nlikewise no token matches the empty fragment of Rust syntax. (Thus, the *only*\nNT that can match the empty fragment is a complex NT.) This is not actually\ntrue, because the `vis` matcher can match an empty fragment. Thus, for the\npurposes of the formalism, we will treat `$v:vis` as actually being\n`$($v:vis)?`, with a requirement that the matcher match an empty fragment."
      }
    },
    {
      "id": "macro.ambiguity.invariant",
      "title": "The matcher invariants",
      "level": 2,
      "content": "To be valid, a matcher must meet the following three invariants. The definitions\nof FIRST and FOLLOW are described later.\n\n1.  For any two successive token tree sequences in a matcher `M` (i.e. `M = ...\n    tt uu ...`) with `uu ...` nonempty, we must have FOLLOW(`... tt`) \u222a {\u03b5} \u2287\n    FIRST(`uu ...`).\n1.  For any separated complex NT in a matcher, `M = ... $(tt ...) SEP OP ...`,\n    we must have `SEP` \u2208 FOLLOW(`tt ...`).\n1.  For an unseparated complex NT in a matcher, `M = ... $(tt ...) OP ...`, if\n    OP = `*` or `+`, we must have FOLLOW(`tt ...`) \u2287 FIRST(`tt ...`).\n\nThe first invariant says that whatever actual token that comes after a matcher,\nif any, must be somewhere in the predetermined follow set.  This ensures that a\nlegal macro definition will continue to assign the same determination as to\nwhere `... tt` ends and `uu ...` begins, even as new syntactic forms are added\nto the language.\n\nThe second invariant says that a separated complex NT must use a separator token\nthat is part of the predetermined follow set for the internal contents of the\nNT. This ensures that a legal macro definition will continue to parse an input\nfragment into the same delimited sequence of `tt ...`'s, even as new syntactic\nforms are added to the language.\n\nThe third invariant says that when we have a complex NT that can match two or\nmore copies of the same thing with no separation in between, it must be\npermissible for them to be placed next to each other as per the first invariant.\nThis invariant also requires they be nonempty, which eliminates a possible\nambiguity.\n\n**NOTE: The third invariant is currently unenforced due to historical oversight\nand significant reliance on the behaviour. It is currently undecided what to do\nabout this going forward. Macros that do not respect the behaviour may become\ninvalid in a future edition of Rust. See the [tracking issue].**",
      "parent_id": null,
      "paragraphs": {
        "macro.ambiguity.invariant.list": "To be valid, a matcher must meet the following three invariants. The definitions\nof FIRST and FOLLOW are described later.\n\n1.  For any two successive token tree sequences in a matcher `M` (i.e. `M = ...\n    tt uu ...`) with `uu ...` nonempty, we must have FOLLOW(`... tt`) \u222a {\u03b5} \u2287\n    FIRST(`uu ...`).\n1.  For any separated complex NT in a matcher, `M = ... $(tt ...) SEP OP ...`,\n    we must have `SEP` \u2208 FOLLOW(`tt ...`).\n1.  For an unseparated complex NT in a matcher, `M = ... $(tt ...) OP ...`, if\n    OP = `*` or `+`, we must have FOLLOW(`tt ...`) \u2287 FIRST(`tt ...`).",
        "macro.ambiguity.invariant.follow-matcher": "The first invariant says that whatever actual token that comes after a matcher,\nif any, must be somewhere in the predetermined follow set.  This ensures that a\nlegal macro definition will continue to assign the same determination as to\nwhere `... tt` ends and `uu ...` begins, even as new syntactic forms are added\nto the language.",
        "macro.ambiguity.invariant.separated-complex-nt": "The second invariant says that a separated complex NT must use a separator token\nthat is part of the predetermined follow set for the internal contents of the\nNT. This ensures that a legal macro definition will continue to parse an input\nfragment into the same delimited sequence of `tt ...`'s, even as new syntactic\nforms are added to the language.",
        "macro.ambiguity.invariant.unseparated-complex-nt": "The third invariant says that when we have a complex NT that can match two or\nmore copies of the same thing with no separation in between, it must be\npermissible for them to be placed next to each other as per the first invariant.\nThis invariant also requires they be nonempty, which eliminates a possible\nambiguity.\n\n**NOTE: The third invariant is currently unenforced due to historical oversight\nand significant reliance on the behaviour. It is currently undecided what to do\nabout this going forward. Macros that do not respect the behaviour may become\ninvalid in a future edition of Rust. See the [tracking issue].**"
      }
    },
    {
      "id": "macro.ambiguity.sets",
      "title": "FIRST and FOLLOW, informally",
      "level": 3,
      "content": "A given matcher M maps to three sets: FIRST(M), LAST(M) and FOLLOW(M).\n\nEach of the three sets is made up of tokens. FIRST(M) and LAST(M) may also\ncontain a distinguished non-token element \u03b5 (\"epsilon\"), which indicates that M\ncan match the empty fragment. (But FOLLOW(M) is always just a set of tokens.)\n\nInformally:\n\n* FIRST(M): collects the tokens potentially used first when matching a\n    fragment to M.\n\n* LAST(M): collects the tokens potentially used last when matching a fragment\n    to M.\n\n* FOLLOW(M): the set of tokens allowed to follow immediately after some\n    fragment matched by M.\n\n    In other words: t \u2208 FOLLOW(M) if and only if there exists (potentially\n    empty) token sequences \u03b1, \u03b2, \u03b3, \u03b4 where:\n\n      * M matches \u03b2,\n\n      * t matches \u03b3, and\n\n      * The concatenation \u03b1 \u03b2 \u03b3 \u03b4 is a parseable Rust program.\n\nWe use the shorthand ANYTOKEN to denote the set of all tokens (including simple\nNTs). For example, if any token is legal after a matcher M, then FOLLOW(M) =\nANYTOKEN.\n\n(To review one's understanding of the above informal descriptions, the reader\nat this point may want to jump ahead to the examples of\nFIRST/LAST before reading their formal\ndefinitions.)",
      "parent_id": null,
      "paragraphs": {
        "macro.ambiguity.sets.intro": "A given matcher M maps to three sets: FIRST(M), LAST(M) and FOLLOW(M).\n\nEach of the three sets is made up of tokens. FIRST(M) and LAST(M) may also\ncontain a distinguished non-token element \u03b5 (\"epsilon\"), which indicates that M\ncan match the empty fragment. (But FOLLOW(M) is always just a set of tokens.)\n\nInformally:",
        "macro.ambiguity.sets.first": "* FIRST(M): collects the tokens potentially used first when matching a\n    fragment to M.",
        "macro.ambiguity.sets.last": "* LAST(M): collects the tokens potentially used last when matching a fragment\n    to M.",
        "macro.ambiguity.sets.follow": "* FOLLOW(M): the set of tokens allowed to follow immediately after some\n    fragment matched by M.\n\n    In other words: t \u2208 FOLLOW(M) if and only if there exists (potentially\n    empty) token sequences \u03b1, \u03b2, \u03b3, \u03b4 where:\n\n      * M matches \u03b2,\n\n      * t matches \u03b3, and\n\n      * The concatenation \u03b1 \u03b2 \u03b3 \u03b4 is a parseable Rust program.",
        "macro.ambiguity.sets.universe": "We use the shorthand ANYTOKEN to denote the set of all tokens (including simple\nNTs). For example, if any token is legal after a matcher M, then FOLLOW(M) =\nANYTOKEN.\n\n(To review one's understanding of the above informal descriptions, the reader\nat this point may want to jump ahead to the examples of\nFIRST/LAST before reading their formal\ndefinitions.)"
      }
    },
    {
      "id": "macro.ambiguity.sets.def",
      "title": "FIRST, LAST",
      "level": 3,
      "content": "Below are formal inductive definitions for FIRST and LAST.\n\n\"A \u222a B\" denotes set union, \"A \u2229 B\" denotes set intersection, and \"A \\ B\"\ndenotes set difference (i.e. all elements of A that are not present in B).",
      "parent_id": null,
      "paragraphs": {
        "macro.ambiguity.sets.def.intro": "Below are formal inductive definitions for FIRST and LAST.",
        "macro.ambiguity.sets.def.notation": "\"A \u222a B\" denotes set union, \"A \u2229 B\" denotes set intersection, and \"A \\ B\"\ndenotes set difference (i.e. all elements of A that are not present in B)."
      }
    },
    {
      "id": "macro.ambiguity.sets.def.first",
      "title": "FIRST",
      "level": 3,
      "content": "FIRST(M) is defined by case analysis on the sequence M and the structure of its\nfirst token-tree (if any):\n\n* if M is the empty sequence, then FIRST(M) = { \u03b5 },\n\n* if M starts with a token t, then FIRST(M) = { t },\n\n    (Note: this covers the case where M starts with a delimited token-tree\n    sequence, `M = OPEN tt ... CLOSE ...`, in which case `t = OPEN` and thus\n    FIRST(M) = { `OPEN` }.)\n\n    (Note: this critically relies on the property that no simple NT matches the\n    empty fragment.)\n\n* Otherwise, M is a token-tree sequence starting with a complex NT: `M = $( tt\n    ... ) OP \u03b1`, or `M = $( tt ... ) SEP OP \u03b1`, (where `\u03b1` is the (potentially\n    empty) sequence of token trees for the rest of the matcher).\n\n      * Let SEP\\_SET(M) = { SEP } if SEP is present and \u03b5 \u2208 FIRST(`tt ...`);\n        otherwise SEP\\_SET(M) = {}.\n\n  * Let ALPHA\\_SET(M) = FIRST(`\u03b1`) if OP = `*` or `?` and ALPHA\\_SET(M) = {} if\n    OP = `+`.\n  * FIRST(M) = (FIRST(`tt ...`) \\\\ {\u03b5}) \u222a SEP\\_SET(M) \u222a ALPHA\\_SET(M).\n\nThe definition for complex NTs deserves some justification. SEP\\_SET(M) defines\nthe possibility that the separator could be a valid first token for M, which\nhappens when there is a separator defined and the repeated fragment could be\nempty. ALPHA\\_SET(M) defines the possibility that the complex NT could be empty,\nmeaning that M's valid first tokens are those of the following token-tree\nsequences `\u03b1`. This occurs when either `*` or `?` is used, in which case there\ncould be zero repetitions. In theory, this could also occur if `+` was used with\na potentially-empty repeating fragment, but this is forbidden by the third\ninvariant.\n\nFrom there, clearly FIRST(M) can include any token from SEP\\_SET(M) or\nALPHA\\_SET(M), and if the complex NT match is nonempty, then any token starting\nFIRST(`tt ...`) could work too. The last piece to consider is \u03b5. SEP\\_SET(M) and\nFIRST(`tt ...`) \\ {\u03b5} cannot contain \u03b5, but ALPHA\\_SET(M) could. Hence, this\ndefinition allows M to accept \u03b5 if and only if \u03b5 \u2208 ALPHA\\_SET(M) does. This is\ncorrect because for M to accept \u03b5 in the complex NT case, both the complex NT\nand \u03b1 must accept it. If OP = `+`, meaning that the complex NT cannot be empty,\nthen by definition \u03b5 \u2209 ALPHA\\_SET(M). Otherwise, the complex NT can accept zero\nrepetitions, and then ALPHA\\_SET(M) = FOLLOW(`\u03b1`). So this definition is correct\nwith respect to \\varepsilon as well.",
      "parent_id": null,
      "paragraphs": {
        "macro.ambiguity.sets.def.first.intro": "FIRST(M) is defined by case analysis on the sequence M and the structure of its\nfirst token-tree (if any):",
        "macro.ambiguity.sets.def.first.epsilon": "* if M is the empty sequence, then FIRST(M) = { \u03b5 },",
        "macro.ambiguity.sets.def.first.token": "* if M starts with a token t, then FIRST(M) = { t },\n\n    (Note: this covers the case where M starts with a delimited token-tree\n    sequence, `M = OPEN tt ... CLOSE ...`, in which case `t = OPEN` and thus\n    FIRST(M) = { `OPEN` }.)\n\n    (Note: this critically relies on the property that no simple NT matches the\n    empty fragment.)",
        "macro.ambiguity.sets.def.first.complex": "* Otherwise, M is a token-tree sequence starting with a complex NT: `M = $( tt\n    ... ) OP \u03b1`, or `M = $( tt ... ) SEP OP \u03b1`, (where `\u03b1` is the (potentially\n    empty) sequence of token trees for the rest of the matcher).\n\n      * Let SEP\\_SET(M) = { SEP } if SEP is present and \u03b5 \u2208 FIRST(`tt ...`);\n        otherwise SEP\\_SET(M) = {}.\n\n  * Let ALPHA\\_SET(M) = FIRST(`\u03b1`) if OP = `*` or `?` and ALPHA\\_SET(M) = {} if\n    OP = `+`.\n  * FIRST(M) = (FIRST(`tt ...`) \\\\ {\u03b5}) \u222a SEP\\_SET(M) \u222a ALPHA\\_SET(M).\n\nThe definition for complex NTs deserves some justification. SEP\\_SET(M) defines\nthe possibility that the separator could be a valid first token for M, which\nhappens when there is a separator defined and the repeated fragment could be\nempty. ALPHA\\_SET(M) defines the possibility that the complex NT could be empty,\nmeaning that M's valid first tokens are those of the following token-tree\nsequences `\u03b1`. This occurs when either `*` or `?` is used, in which case there\ncould be zero repetitions. In theory, this could also occur if `+` was used with\na potentially-empty repeating fragment, but this is forbidden by the third\ninvariant.\n\nFrom there, clearly FIRST(M) can include any token from SEP\\_SET(M) or\nALPHA\\_SET(M), and if the complex NT match is nonempty, then any token starting\nFIRST(`tt ...`) could work too. The last piece to consider is \u03b5. SEP\\_SET(M) and\nFIRST(`tt ...`) \\ {\u03b5} cannot contain \u03b5, but ALPHA\\_SET(M) could. Hence, this\ndefinition allows M to accept \u03b5 if and only if \u03b5 \u2208 ALPHA\\_SET(M) does. This is\ncorrect because for M to accept \u03b5 in the complex NT case, both the complex NT\nand \u03b1 must accept it. If OP = `+`, meaning that the complex NT cannot be empty,\nthen by definition \u03b5 \u2209 ALPHA\\_SET(M). Otherwise, the complex NT can accept zero\nrepetitions, and then ALPHA\\_SET(M) = FOLLOW(`\u03b1`). So this definition is correct\nwith respect to \\varepsilon as well."
      }
    },
    {
      "id": "macro.ambiguity.sets.def.last",
      "title": "LAST",
      "level": 4,
      "content": "LAST(M), defined by case analysis on M itself (a sequence of token-trees):\n\n* if M is the empty sequence, then LAST(M) = { \u03b5 }\n\n* if M is a singleton token t, then LAST(M) = { t }\n\n* if M is the singleton complex NT repeating zero or more times, `M = $( tt\n    ... ) *`, or `M = $( tt ... ) SEP *`\n\n      * Let sep_set = { SEP } if SEP present; otherwise sep_set = {}.\n\n      * if \u03b5 \u2208 LAST(`tt ...`) then LAST(M) = LAST(`tt ...`) \u222a sep_set\n\n      * otherwise, the sequence `tt ...` must be non-empty; LAST(M) = LAST(`tt\n        ...`) \u222a {\u03b5}.\n\n* if M is the singleton complex NT repeating one or more times, `M = $( tt ...\n    ) +`, or `M = $( tt ... ) SEP +`\n\n      * Let sep_set = { SEP } if SEP present; otherwise sep_set = {}.\n\n      * if \u03b5 \u2208 LAST(`tt ...`) then LAST(M) = LAST(`tt ...`) \u222a sep_set\n\n      * otherwise, the sequence `tt ...` must be non-empty; LAST(M) = LAST(`tt\n        ...`)\n\n* if M is the singleton complex NT repeating zero or one time, `M = $( tt ...)\n    ?`, then LAST(M) = LAST(`tt ...`) \u222a {\u03b5}.\n\n* if M is a delimited token-tree sequence `OPEN tt ... CLOSE`, then LAST(M) =\n    { `CLOSE` }.\n\n* if M is a non-empty sequence of token-trees `tt uu ...`,\n\n      * If \u03b5 \u2208 LAST(`uu ...`), then LAST(M) = LAST(`tt`) \u222a (LAST(`uu ...`) \\ { \u03b5 }).\n\n      * Otherwise, the sequence `uu ...` must be non-empty; then LAST(M) =\n        LAST(`uu ...`).\n\n### Examples of FIRST and LAST\n\nBelow are some examples of FIRST and LAST.\n(Note in particular how the special \u03b5 element is introduced and\neliminated based on the interaction between the pieces of the input.)\n\nOur first example is presented in a tree structure to elaborate on how\nthe analysis of the matcher composes. (Some of the simpler subtrees\nhave been elided.)\n\nINPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+   g\n            ~~~~~~~~   ~~~~~~~                ~\n                |         |                   |\nFIRST:   { $d:ident }  { $e:expr }          { h }\n\nINPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+\n            ~~~~~~~~~~~~~~~~~~             ~~~~~~~           ~~~\n                        |                      |               |\nFIRST:          { $d:ident }               { h, \u03b5 }         { f }\n\nINPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+   g\n        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~    ~~~~~~~~~~~~~~    ~~~~~~~~~   ~\n                        |                       |              |       |\nFIRST:        { $d:ident, \u03b5 }            {  h, \u03b5, ;  }      { f }   { g }\n\nINPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+   g\n        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n                                        |\nFIRST:                       { $d:ident, h, ;,  f }\n\nThus:\n\n * FIRST(`$($d:ident $e:expr );* $( $(h)* );* $( f ;)+ g`) = { `$d:ident`, `h`, `;`, `f` }\n\nNote however that:\n\n * FIRST(`$($d:ident $e:expr );* $( $(h)* );* $($( f ;)+ g)*`) = { `$d:ident`, `h`, `;`, `f`, \u03b5 }\n\nHere are similar examples but now for LAST.\n\n * LAST(`$d:ident $e:expr`) = { `$e:expr` }\n * LAST(`$( $d:ident $e:expr );*`) = { `$e:expr`, \u03b5 }\n * LAST(`$( $d:ident $e:expr );* $(h)*`) = { `$e:expr`, \u03b5, `h` }\n * LAST(`$( $d:ident $e:expr );* $(h)* $( f ;)+`) = { `;` }\n * LAST(`$( $d:ident $e:expr );* $(h)* $( f ;)+ g`) = { `g` }",
      "parent_id": null,
      "paragraphs": {
        "macro.ambiguity.sets.def.last.intro": "LAST(M), defined by case analysis on M itself (a sequence of token-trees):",
        "macro.ambiguity.sets.def.last.empty": "* if M is the empty sequence, then LAST(M) = { \u03b5 }",
        "macro.ambiguity.sets.def.last.token": "* if M is a singleton token t, then LAST(M) = { t }",
        "macro.ambiguity.sets.def.last.rep-star": "* if M is the singleton complex NT repeating zero or more times, `M = $( tt\n    ... ) *`, or `M = $( tt ... ) SEP *`\n\n      * Let sep_set = { SEP } if SEP present; otherwise sep_set = {}.\n\n      * if \u03b5 \u2208 LAST(`tt ...`) then LAST(M) = LAST(`tt ...`) \u222a sep_set\n\n      * otherwise, the sequence `tt ...` must be non-empty; LAST(M) = LAST(`tt\n        ...`) \u222a {\u03b5}.",
        "macro.ambiguity.sets.def.last.rep-plus": "* if M is the singleton complex NT repeating one or more times, `M = $( tt ...\n    ) +`, or `M = $( tt ... ) SEP +`\n\n      * Let sep_set = { SEP } if SEP present; otherwise sep_set = {}.\n\n      * if \u03b5 \u2208 LAST(`tt ...`) then LAST(M) = LAST(`tt ...`) \u222a sep_set\n\n      * otherwise, the sequence `tt ...` must be non-empty; LAST(M) = LAST(`tt\n        ...`)",
        "macro.ambiguity.sets.def.last.rep-question": "* if M is the singleton complex NT repeating zero or one time, `M = $( tt ...)\n    ?`, then LAST(M) = LAST(`tt ...`) \u222a {\u03b5}.",
        "macro.ambiguity.sets.def.last.delim": "* if M is a delimited token-tree sequence `OPEN tt ... CLOSE`, then LAST(M) =\n    { `CLOSE` }.",
        "macro.ambiguity.sets.def.last.sequence": "* if M is a non-empty sequence of token-trees `tt uu ...`,\n\n      * If \u03b5 \u2208 LAST(`uu ...`), then LAST(M) = LAST(`tt`) \u222a (LAST(`uu ...`) \\ { \u03b5 }).\n\n      * Otherwise, the sequence `uu ...` must be non-empty; then LAST(M) =\n        LAST(`uu ...`).\n\n### Examples of FIRST and LAST\n\nBelow are some examples of FIRST and LAST.\n(Note in particular how the special \u03b5 element is introduced and\neliminated based on the interaction between the pieces of the input.)\n\nOur first example is presented in a tree structure to elaborate on how\nthe analysis of the matcher composes. (Some of the simpler subtrees\nhave been elided.)\n\nINPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+   g\n            ~~~~~~~~   ~~~~~~~                ~\n                |         |                   |\nFIRST:   { $d:ident }  { $e:expr }          { h }\n\nINPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+\n            ~~~~~~~~~~~~~~~~~~             ~~~~~~~           ~~~\n                        |                      |               |\nFIRST:          { $d:ident }               { h, \u03b5 }         { f }\n\nINPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+   g\n        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~    ~~~~~~~~~~~~~~    ~~~~~~~~~   ~\n                        |                       |              |       |\nFIRST:        { $d:ident, \u03b5 }            {  h, \u03b5, ;  }      { f }   { g }\n\nINPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+   g\n        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n                                        |\nFIRST:                       { $d:ident, h, ;,  f }\n\nThus:\n\n * FIRST(`$($d:ident $e:expr );* $( $(h)* );* $( f ;)+ g`) = { `$d:ident`, `h`, `;`, `f` }\n\nNote however that:\n\n * FIRST(`$($d:ident $e:expr );* $( $(h)* );* $($( f ;)+ g)*`) = { `$d:ident`, `h`, `;`, `f`, \u03b5 }\n\nHere are similar examples but now for LAST.\n\n * LAST(`$d:ident $e:expr`) = { `$e:expr` }\n * LAST(`$( $d:ident $e:expr );*`) = { `$e:expr`, \u03b5 }\n * LAST(`$( $d:ident $e:expr );* $(h)*`) = { `$e:expr`, \u03b5, `h` }\n * LAST(`$( $d:ident $e:expr );* $(h)* $( f ;)+`) = { `;` }\n * LAST(`$( $d:ident $e:expr );* $(h)* $( f ;)+ g`) = { `g` }"
      }
    },
    {
      "id": "macro.ambiguity.sets.def.follow",
      "title": "FOLLOW(M)",
      "level": 3,
      "content": "Finally, the definition for FOLLOW(M) is built up as follows. pat, expr, etc.\nrepresent simple nonterminals with the given fragment specifier.\n\n* FOLLOW(pat) = {`=>`, `,`, `=`, `|`, `if`, `in`}`.\n\n* FOLLOW(expr) = FOLLOW(expr_2021) = FOLLOW(stmt) =  {`=>`, `,`, `;`}`.\n\n* FOLLOW(ty) = FOLLOW(path) = {`{`, `[`, `,`, `=>`, `:`, `=`, `>`, `>>`, `;`,\n    `|`, `as`, `where`, block nonterminals}.\n\n* FOLLOW(vis) = {`,`l any keyword or identifier except a non-raw `priv`; any\n    token that can begin a type; ident, ty, and path nonterminals}.\n\n* FOLLOW(t) = ANYTOKEN for any other simple token, including block, ident,\n    tt, item, lifetime, literal and meta simple nonterminals, and all terminals.\n\n* FOLLOW(M), for any other M, is defined as the intersection, as t ranges over\n    (LAST(M) \\ {\u03b5}), of FOLLOW(t).\n\nThe tokens that can begin a type are, as of this writing, {`(`, `[`, `!`, `*`,\n`&`, `&&`, `?`, lifetimes, `>`, `>>`, `::`, any non-keyword identifier, `super`,\n`self`, `Self`, `extern`, `crate`, `$crate`, `_`, `for`, `impl`, `fn`, `unsafe`,\n`typeof`, `dyn`}, although this list may not be complete because people won't\nalways remember to update the appendix when new ones are added.\n\nExamples of FOLLOW for complex M:\n\n * FOLLOW(`$( $d:ident $e:expr )*`) = FOLLOW(`$e:expr`)\n * FOLLOW(`$( $d:ident $e:expr )* $(;)*`) = FOLLOW(`$e:expr`) \u2229 ANYTOKEN = FOLLOW(`$e:expr`)\n * FOLLOW(`$( $d:ident $e:expr )* $(;)* $( f |)+`) = ANYTOKEN\n\n### Examples of valid and invalid matchers\n\nWith the above specification in hand, we can present arguments for\nwhy particular matchers are legal and others are not.\n\n * `($ty:ty < foo ,)` : illegal, because FIRST(`< foo ,`) = { `<` } \u2288 FOLLOW(`ty`)\n\n * `($ty:ty , foo <)` : legal, because FIRST(`, foo <`) = { `,` }  is \u2286 FOLLOW(`ty`).\n\n * `($pa:pat $pb:pat $ty:ty ,)` : illegal, because FIRST(`$pb:pat $ty:ty ,`) = { `$pb:pat` } \u2288 FOLLOW(`pat`), and also FIRST(`$ty:ty ,`) = { `$ty:ty` } \u2288 FOLLOW(`pat`).\n\n * `( $($a:tt $b:tt)* ; )` : legal, because FIRST(`$b:tt`) = { `$b:tt` } is \u2286 FOLLOW(`tt`) = ANYTOKEN, as is FIRST(`;`) = { `;` }.\n\n * `( $($t:tt),* , $(t:tt),* )` : legal,  (though any attempt to actually use this macro will signal a local ambiguity error during expansion).\n\n * `($ty:ty $(; not sep)* -)` : illegal, because FIRST(`$(; not sep)* -`) = { `;`, `-` } is not in FOLLOW(`ty`).\n\n * `($($ty:ty)-+)` : illegal, because separator `-` is not in FOLLOW(`ty`).\n\n * `($($e:expr)*)` : illegal, because expr NTs are not in FOLLOW(expr NT).\n\n[Macros by Example]: macros-by-example.md\n[RFC 550]: https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.md\n[tracking issue]: https://github.com/rust-lang/rust/issues/56575",
      "parent_id": null,
      "paragraphs": {
        "macro.ambiguity.sets.def.follow.intro": "Finally, the definition for FOLLOW(M) is built up as follows. pat, expr, etc.\nrepresent simple nonterminals with the given fragment specifier.",
        "macro.ambiguity.sets.def.follow.pat": "* FOLLOW(pat) = {`=>`, `,`, `=`, `|`, `if`, `in`}`.",
        "macro.ambiguity.sets.def.follow.expr-stmt": "* FOLLOW(expr) = FOLLOW(expr_2021) = FOLLOW(stmt) =  {`=>`, `,`, `;`}`.",
        "macro.ambiguity.sets.def.follow.ty-path": "* FOLLOW(ty) = FOLLOW(path) = {`{`, `[`, `,`, `=>`, `:`, `=`, `>`, `>>`, `;`,\n    `|`, `as`, `where`, block nonterminals}.",
        "macro.ambiguity.sets.def.follow.vis": "* FOLLOW(vis) = {`,`l any keyword or identifier except a non-raw `priv`; any\n    token that can begin a type; ident, ty, and path nonterminals}.",
        "macro.ambiguity.sets.def.follow.simple": "* FOLLOW(t) = ANYTOKEN for any other simple token, including block, ident,\n    tt, item, lifetime, literal and meta simple nonterminals, and all terminals.",
        "macro.ambiguity.sets.def.follow.other-matcher": "* FOLLOW(M), for any other M, is defined as the intersection, as t ranges over\n    (LAST(M) \\ {\u03b5}), of FOLLOW(t).",
        "macro.ambiguity.sets.def.follow.type-first": "The tokens that can begin a type are, as of this writing, {`(`, `[`, `!`, `*`,\n`&`, `&&`, `?`, lifetimes, `>`, `>>`, `::`, any non-keyword identifier, `super`,\n`self`, `Self`, `extern`, `crate`, `$crate`, `_`, `for`, `impl`, `fn`, `unsafe`,\n`typeof`, `dyn`}, although this list may not be complete because people won't\nalways remember to update the appendix when new ones are added.\n\nExamples of FOLLOW for complex M:\n\n * FOLLOW(`$( $d:ident $e:expr )*`) = FOLLOW(`$e:expr`)\n * FOLLOW(`$( $d:ident $e:expr )* $(;)*`) = FOLLOW(`$e:expr`) \u2229 ANYTOKEN = FOLLOW(`$e:expr`)\n * FOLLOW(`$( $d:ident $e:expr )* $(;)* $( f |)+`) = ANYTOKEN\n\n### Examples of valid and invalid matchers\n\nWith the above specification in hand, we can present arguments for\nwhy particular matchers are legal and others are not.\n\n * `($ty:ty < foo ,)` : illegal, because FIRST(`< foo ,`) = { `<` } \u2288 FOLLOW(`ty`)\n\n * `($ty:ty , foo <)` : legal, because FIRST(`, foo <`) = { `,` }  is \u2286 FOLLOW(`ty`).\n\n * `($pa:pat $pb:pat $ty:ty ,)` : illegal, because FIRST(`$pb:pat $ty:ty ,`) = { `$pb:pat` } \u2288 FOLLOW(`pat`), and also FIRST(`$ty:ty ,`) = { `$ty:ty` } \u2288 FOLLOW(`pat`).\n\n * `( $($a:tt $b:tt)* ; )` : legal, because FIRST(`$b:tt`) = { `$b:tt` } is \u2286 FOLLOW(`tt`) = ANYTOKEN, as is FIRST(`;`) = { `;` }.\n\n * `( $($t:tt),* , $(t:tt),* )` : legal,  (though any attempt to actually use this macro will signal a local ambiguity error during expansion).\n\n * `($ty:ty $(; not sep)* -)` : illegal, because FIRST(`$(; not sep)* -`) = { `;`, `-` } is not in FOLLOW(`ty`).\n\n * `($($ty:ty)-+)` : illegal, because separator `-` is not in FOLLOW(`ty`).\n\n * `($($e:expr)*)` : illegal, because expr NTs are not in FOLLOW(expr NT).\n\n[Macros by Example]: macros-by-example.md\n[RFC 550]: https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.md\n[tracking issue]: https://github.com/rust-lang/rust/issues/56575"
      }
    },
    {
      "id": "influences",
      "title": "Influences",
      "level": 1,
      "content": "# Influences\n\nRust is not a particularly original language, with design elements coming from\na wide range of sources. Some of these are listed below (including elements\nthat have since been removed):\n\n* SML, OCaml: algebraic data types, pattern matching, type inference,\n  semicolon statement separation\n* C++: references, RAII, smart pointers, move semantics, monomorphization,\n  memory model\n* ML Kit, Cyclone: region based memory management\n* Haskell (GHC): typeclasses, type families\n* Newsqueak, Alef, Limbo: channels, concurrency\n* Erlang: message passing, thread failure, ~~linked thread failure~~,\n  ~~lightweight concurrency~~\n* Swift: optional bindings\n* Scheme: hygienic macros\n* C#: attributes\n* Ruby: closure syntax, ~~block syntax~~\n* NIL, Hermes: ~~typestate~~\n* Unicode Annex #31: identifier and\n  pattern syntax",
      "parent_id": null,
      "paragraphs": {
        "influences_p1": "# Influences\n\nRust is not a particularly original language, with design elements coming from\na wide range of sources. Some of these are listed below (including elements\nthat have since been removed):\n\n* SML, OCaml: algebraic data types, pattern matching, type inference,\n  semicolon statement separation\n* C++: references, RAII, smart pointers, move semantics, monomorphization,\n  memory model\n* ML Kit, Cyclone: region based memory management\n* Haskell (GHC): typeclasses, type families\n* Newsqueak, Alef, Limbo: channels, concurrency\n* Erlang: message passing, thread failure, ~~linked thread failure~~,\n  ~~lightweight concurrency~~\n* Swift: optional bindings\n* Scheme: hygienic macros\n* C#: attributes\n* Ruby: closure syntax, ~~block syntax~~\n* NIL, Hermes: ~~typestate~~\n* Unicode Annex #31: identifier and\n  pattern syntax"
      }
    },
    {
      "id": "test_summary",
      "title": "Test summary",
      "level": 1,
      "content": "# Test summary\n\nThe following is a summary of the total tests that are linked to individual rule identifiers within the reference.\n\n{{summary-table}}",
      "parent_id": null,
      "paragraphs": {
        "test_summary_p1": "# Test summary\n\nThe following is a summary of the total tests that are linked to individual rule identifiers within the reference.\n\n{{summary-table}}"
      }
    },
    {
      "id": "glossary.ast",
      "title": "Abstract syntax tree",
      "level": 1,
      "content": "An \u2018abstract syntax tree\u2019, or \u2018AST\u2019, is an intermediate representation of\nthe structure of the program when the compiler is compiling it.\n\n### Alignment\n\nThe alignment of a value specifies what addresses values are preferred to\nstart at. Always a power of two. References to a value must be aligned.\nMore.",
      "parent_id": null,
      "paragraphs": {
        "glossary.ast": "An \u2018abstract syntax tree\u2019, or \u2018AST\u2019, is an intermediate representation of\nthe structure of the program when the compiler is compiling it.\n\n### Alignment\n\nThe alignment of a value specifies what addresses values are preferred to\nstart at. Always a power of two. References to a value must be aligned.\nMore."
      }
    },
    {
      "id": "glossary.abi",
      "title": "Application binary interface (ABI)",
      "level": 3,
      "content": "An *application binary interface* (ABI) defines how compiled code interacts with other compiled code. With [`extern` blocks] and [`extern fn`], *ABI strings* affect:\n\n- **Calling convention**: How function arguments are passed, values are returned (e.g., in registers or on the stack), and who is responsible for cleaning up the stack.\n- **Unwinding**: Whether stack unwinding is allowed. For example, the `\"C-unwind\"` ABI allows unwinding across the FFI boundary, while the `\"C\"` ABI does not.\n\n### Arity\n\nArity refers to the number of arguments a function or operator takes.\nFor some examples, `f(2, 3)` and `g(4, 6)` have arity 2, while `h(8, 2, 6)`\nhas arity 3. The `!` operator has arity 1.\n\n### Array\n\nAn array, sometimes also called a fixed-size array or an inline array, is a value\ndescribing a collection of elements, each selected by an index that can be computed\nat run time by the program. It occupies a contiguous region of memory.\n\n### Associated item\n\nAn associated item is an item that is associated with another item. Associated\nitems are defined in [implementations] and declared in [traits]. Only\nfunctions, constants, and type aliases can be associated. Contrast to a [free\nitem].\n\n### Blanket implementation\n\nAny implementation where a type appears uncovered. `impl<T> Foo\nfor T`, `impl<T> Bar<T> for T`, `impl<T> Bar<Vec<T>> for T`, and `impl<T> Bar<T>\nfor Vec<T>` are considered blanket impls. However, `impl<T> Bar<Vec<T>> for\nVec<T>` is not a blanket impl, as all instances of `T` which appear in this `impl`\nare covered by `Vec`.\n\n### Bound\n\nBounds are constraints on a type or trait. For example, if a bound\nis placed on the argument a function takes, types passed to that function\nmust abide by that constraint.\n\n### Combinator\n\nCombinators are higher-order functions that apply only functions and\nearlier defined combinators to provide a result from its arguments.\nThey can be used to manage control flow in a modular fashion.\n\n### Crate\n\nA crate is the unit of compilation and linking. There are different [types of\ncrates], such as libraries or executables. Crates may link and refer to other\nlibrary crates, called external crates. A crate has a self-contained tree of\n[modules], starting from an unnamed root module called the crate root. [Items]\nmay be made visible to other crates by marking them as public in the crate\nroot, including through [paths] of public modules.\nMore.\n\n### Dispatch\n\nDispatch is the mechanism to determine which specific version of code is actually run when it involves polymorphism. Two major forms of dispatch are static dispatch and dynamic dispatch. Rust supports dynamic dispatch through the use of trait objects.\n\n### Dynamically sized type\n\nA dynamically sized type (DST) is a type without a statically known size or alignment.\n\n### Entity\n\nAn [*entity*] is a language construct that can be referred to in some way\nwithin the source program, usually via a path. Entities include\n[types], [items], [generic parameters], [variable bindings], [loop labels],\n[lifetimes], [fields], [attributes], and [lints].\n\n### Expression\n\nAn expression is a combination of values, constants, variables, operators\nand functions that evaluate to a single value, with or without side-effects.\n\nFor example, `2 + (3 * 4)` is an expression that returns the value 14.\n\n### Free item\n\nAn [item] that is not a member of an [implementation], such as a *free\nfunction* or a *free const*. Contrast to an [associated item].\n\n### Fundamental traits\n\nA fundamental trait is one where adding an impl of it for an existing type is a breaking change.\nThe `Fn` traits and `Sized` are fundamental.\n\n### Fundamental type constructors\n\nA fundamental type constructor is a type where implementing a blanket implementation over it\nis a breaking change. `&`, `&mut`, `Box`, and `Pin`  are fundamental.\n\nAny time a type `T` is considered local, `&T`, `&mut T`, `Box<T>`, and `Pin<T>`\nare also considered local. Fundamental type constructors cannot cover other types.\nAny time the term \"covered type\" is used,\nthe `T` in `&T`, `&mut T`, `Box<T>`, and `Pin<T>` is not considered covered.\n\n### Inhabited\n\nA type is inhabited if it has constructors and therefore can be instantiated. An inhabited type is\nnot \"empty\" in the sense that there can be values of the type. Opposite of\nUninhabited.\n\n### Inherent implementation\n\nAn [implementation] that applies to a nominal type, not to a trait-type pair.\nMore.\n\n### Inherent method\n\nA [method] defined in an [inherent implementation], not in a trait\nimplementation.\n\n### Initialized\n\nA variable is initialized if it has been assigned a value and hasn't since been\nmoved from. All other memory locations are assumed to be uninitialized. Only\nunsafe Rust can create a memory location without initializing it.\n\n### Local trait\n\nA `trait` which was defined in the current crate. A trait definition is local\nor not independent of applied type arguments. Given `trait Foo<T, U>`,\n`Foo` is always local, regardless of the types substituted for `T` and `U`.\n\n### Local type\n\nA `struct`, `enum`, or `union` which was defined in the current crate.\nThis is not affected by applied type arguments. `struct Foo` is considered local, but\n`Vec<Foo>` is not. `LocalType<ForeignType>` is local. Type aliases do not\naffect locality.\n\n### Module\n\nA module is a container for zero or more [items]. Modules are organized in a\ntree, starting from an unnamed module at the root called the crate root or the\nroot module. [Paths] may be used to refer to items from other modules, which\nmay be restricted by [visibility rules].\nMore\n\n### Name\n\nA [*name*] is an [identifier] or [lifetime or loop label] that refers to an\nentity. A *name binding* is when an entity declaration introduces\nan identifier or label associated with that entity. [Paths],\nidentifiers, and labels are used to refer to an entity.\n\n### Name resolution\n\n[*Name resolution*] is the compile-time process of tying [paths],\n[identifiers], and [labels] to entity declarations.\n\n### Namespace\n\nA *namespace* is a logical grouping of declared names based on the\nkind of entity the name refers to. Namespaces allow the occurrence\nof a name in one namespace to not conflict with the same name in another\nnamespace.\n\nWithin a namespace, names are organized in a hierarchy, where each level of\nthe hierarchy has its own collection of named entities.\n\n### Nominal types\n\nTypes that can be referred to by a path directly. Specifically [enums],\n[structs], [unions], and [trait object types].\n\n### Dyn-compatible traits\n\n[Traits] that can be used in [trait object types] (`dyn Trait`).\nOnly traits that follow specific rules are *dyn compatible*.\n\nThese were formerly known as *object safe* traits.\n\n### Path\n\nA [*path*] is a sequence of one or more path segments used to refer to an\nentity in the current scope or other levels of a\nnamespace hierarchy.\n\n### Prelude\n\nPrelude, or The Rust Prelude, is a small collection of items - mostly traits - that are\nimported into every module of every crate. The traits in the prelude are pervasive.\n\n### Scope\n\nA [*scope*] is the region of source text where a named entity may\nbe referenced with that name.\n\n### Scrutinee\n\nA scrutinee is the expression that is matched on in `match` expressions and\nsimilar pattern matching constructs. For example, in `match x { A => 1, B => 2 }`,\nthe expression `x` is the scrutinee.\n\n### Size\n\nThe size of a value has two definitions.\n\nThe first is that it is how much memory must be allocated to store that value.\n\nThe second is that it is the offset in bytes between successive elements in an\narray with that item type.\n\nIt is a multiple of the alignment, including zero. The size can change\ndepending on compiler version (as new optimizations are made) and target\nplatform (similar to how `usize` varies per-platform).\n\nMore.\n\n### Slice\n\nA slice is dynamically-sized view into a contiguous sequence, written as `[T]`.\n\nIt is often seen in its borrowed forms, either mutable or shared. The shared\nslice type is `&[T]`, while the mutable slice type is `&mut [T]`, where `T` represents\nthe element type.\n\n### Statement\n\nA statement is the smallest standalone element of a programming language\nthat commands a computer to perform an action.\n\n### String literal\n\nA string literal is a string stored directly in the final binary, and so will be\nvalid for the `'static` duration.\n\nIts type is `'static` duration borrowed string slice, `&'static str`.\n\n### String slice\n\nA string slice is the most primitive string type in Rust, written as `str`. It is\noften seen in its borrowed forms, either mutable or shared. The shared\nstring slice type is `&str`, while the mutable string slice type is `&mut str`.\n\nStrings slices are always valid UTF-8.\n\n### Trait\n\nA trait is a language item that is used for describing the functionalities a type must provide.\nIt allows a type to make certain promises about its behavior.\n\nGeneric functions and generic structs can use traits to constrain, or bound, the types they accept.\n\n### Turbofish\n\nPaths with generic parameters in expressions must prefix the opening brackets with a `::`.\nCombined with the angular brackets for generics, this looks like a fish `::<>`.\nAs such, this syntax is colloquially referred to as turbofish syntax.\n\nExamples:\n\nlet ok_num = Ok::<_, ()>(5);\nlet vec = [1, 2, 3].iter().map(|n| n * 2).collect::<Vec<_>>();\n\nThis `::` prefix is required to disambiguate generic paths with multiple comparisons in a comma-separate list.\nSee the bastion of the turbofish for an example where not having the prefix would be ambiguous.\n\n### Uncovered type\n\nA type which does not appear as an argument to another type. For example,\n`T` is uncovered, but the `T` in `Vec<T>` is covered. This is only relevant for\ntype arguments.\n\n### Undefined behavior\n\nCompile-time or run-time behavior that is not specified. This may result in,\nbut is not limited to: process termination or corruption; improper, incorrect,\nor unintended computation; or platform-specific results.\nMore.\n\n### Uninhabited\n\nA type is uninhabited if it has no constructors and therefore can never be instantiated. An\nuninhabited type is \"empty\" in the sense that there are no values of the type. The canonical\nexample of an uninhabited type is the [never type] `!`, or an enum with no variants\n`enum Never { }`. Opposite of Inhabited.\n\n[`extern` blocks]: items.extern\n[`extern fn`]: items.fn.extern\n[alignment]: type-layout.md#size-and-alignment\n\n[attributes]: attributes.md\n[*entity*]: names.md\n[crate]: crates-and-source-files.md\n[dyn compatibility]: items/traits.md#dyn-compatibility\n[enums]: items/enumerations.md\n[fields]: expressions/field-expr.md\n\n[generic parameters]: items/generics.md\n[identifier]: identifiers.md\n[identifiers]: identifiers.md\n[implementation]: items/implementations.md\n[implementations]: items/implementations.md\n[inherent implementation]: items/implementations.md#inherent-implementations\n[item]: items.md\n[items]: items.md\n[labels]: tokens.md#lifetimes-and-loop-labels\n[lifetime or loop label]: tokens.md#lifetimes-and-loop-labels\n[lifetimes]: tokens.md#lifetimes-and-loop-labels\n[lints]: attributes/diagnostics.md#lint-check-attributes\n[loop labels]: tokens.md#lifetimes-and-loop-labels\n[method]: items/associated-items.md#methods\n[modules]: items/modules.md\n[*Name resolution*]: names/name-resolution.md\n[*name*]: names.md\n[*namespace*]: names/namespaces.md\n[never type]: types/never.md\n[*path*]: paths.md\n[Paths]: paths.md\n[*scope*]: names/scopes.md\n[structs]: items/structs.md\n[trait object types]: types/trait-object.md\n[traits]: items/traits.md\n[turbofish test]: https://github.com/rust-lang/rust/blob/1.58.0/src/test/ui/parser/bastion-of-the-turbofish.rs\n[types of crates]: linkage.md\n[types]: types.md\n[undefined-behavior]: behavior-considered-undefined.md\n[unions]: items/unions.md\n[variable bindings]: patterns.md\n[visibility rules]: visibility-and-privacy.md",
      "parent_id": null,
      "paragraphs": {
        "glossary.abi": "An *application binary interface* (ABI) defines how compiled code interacts with other compiled code. With [`extern` blocks] and [`extern fn`], *ABI strings* affect:\n\n- **Calling convention**: How function arguments are passed, values are returned (e.g., in registers or on the stack), and who is responsible for cleaning up the stack.\n- **Unwinding**: Whether stack unwinding is allowed. For example, the `\"C-unwind\"` ABI allows unwinding across the FFI boundary, while the `\"C\"` ABI does not.\n\n### Arity\n\nArity refers to the number of arguments a function or operator takes.\nFor some examples, `f(2, 3)` and `g(4, 6)` have arity 2, while `h(8, 2, 6)`\nhas arity 3. The `!` operator has arity 1.\n\n### Array\n\nAn array, sometimes also called a fixed-size array or an inline array, is a value\ndescribing a collection of elements, each selected by an index that can be computed\nat run time by the program. It occupies a contiguous region of memory.\n\n### Associated item\n\nAn associated item is an item that is associated with another item. Associated\nitems are defined in [implementations] and declared in [traits]. Only\nfunctions, constants, and type aliases can be associated. Contrast to a [free\nitem].\n\n### Blanket implementation\n\nAny implementation where a type appears uncovered. `impl<T> Foo\nfor T`, `impl<T> Bar<T> for T`, `impl<T> Bar<Vec<T>> for T`, and `impl<T> Bar<T>\nfor Vec<T>` are considered blanket impls. However, `impl<T> Bar<Vec<T>> for\nVec<T>` is not a blanket impl, as all instances of `T` which appear in this `impl`\nare covered by `Vec`.\n\n### Bound\n\nBounds are constraints on a type or trait. For example, if a bound\nis placed on the argument a function takes, types passed to that function\nmust abide by that constraint.\n\n### Combinator\n\nCombinators are higher-order functions that apply only functions and\nearlier defined combinators to provide a result from its arguments.\nThey can be used to manage control flow in a modular fashion.\n\n### Crate\n\nA crate is the unit of compilation and linking. There are different [types of\ncrates], such as libraries or executables. Crates may link and refer to other\nlibrary crates, called external crates. A crate has a self-contained tree of\n[modules], starting from an unnamed root module called the crate root. [Items]\nmay be made visible to other crates by marking them as public in the crate\nroot, including through [paths] of public modules.\nMore.\n\n### Dispatch\n\nDispatch is the mechanism to determine which specific version of code is actually run when it involves polymorphism. Two major forms of dispatch are static dispatch and dynamic dispatch. Rust supports dynamic dispatch through the use of trait objects.\n\n### Dynamically sized type\n\nA dynamically sized type (DST) is a type without a statically known size or alignment.\n\n### Entity\n\nAn [*entity*] is a language construct that can be referred to in some way\nwithin the source program, usually via a path. Entities include\n[types], [items], [generic parameters], [variable bindings], [loop labels],\n[lifetimes], [fields], [attributes], and [lints].\n\n### Expression\n\nAn expression is a combination of values, constants, variables, operators\nand functions that evaluate to a single value, with or without side-effects.\n\nFor example, `2 + (3 * 4)` is an expression that returns the value 14.\n\n### Free item\n\nAn [item] that is not a member of an [implementation], such as a *free\nfunction* or a *free const*. Contrast to an [associated item].\n\n### Fundamental traits\n\nA fundamental trait is one where adding an impl of it for an existing type is a breaking change.\nThe `Fn` traits and `Sized` are fundamental.\n\n### Fundamental type constructors\n\nA fundamental type constructor is a type where implementing a blanket implementation over it\nis a breaking change. `&`, `&mut`, `Box`, and `Pin`  are fundamental.\n\nAny time a type `T` is considered local, `&T`, `&mut T`, `Box<T>`, and `Pin<T>`\nare also considered local. Fundamental type constructors cannot cover other types.\nAny time the term \"covered type\" is used,\nthe `T` in `&T`, `&mut T`, `Box<T>`, and `Pin<T>` is not considered covered.\n\n### Inhabited\n\nA type is inhabited if it has constructors and therefore can be instantiated. An inhabited type is\nnot \"empty\" in the sense that there can be values of the type. Opposite of\nUninhabited.\n\n### Inherent implementation\n\nAn [implementation] that applies to a nominal type, not to a trait-type pair.\nMore.\n\n### Inherent method\n\nA [method] defined in an [inherent implementation], not in a trait\nimplementation.\n\n### Initialized\n\nA variable is initialized if it has been assigned a value and hasn't since been\nmoved from. All other memory locations are assumed to be uninitialized. Only\nunsafe Rust can create a memory location without initializing it.\n\n### Local trait\n\nA `trait` which was defined in the current crate. A trait definition is local\nor not independent of applied type arguments. Given `trait Foo<T, U>`,\n`Foo` is always local, regardless of the types substituted for `T` and `U`.\n\n### Local type\n\nA `struct`, `enum`, or `union` which was defined in the current crate.\nThis is not affected by applied type arguments. `struct Foo` is considered local, but\n`Vec<Foo>` is not. `LocalType<ForeignType>` is local. Type aliases do not\naffect locality.\n\n### Module\n\nA module is a container for zero or more [items]. Modules are organized in a\ntree, starting from an unnamed module at the root called the crate root or the\nroot module. [Paths] may be used to refer to items from other modules, which\nmay be restricted by [visibility rules].\nMore\n\n### Name\n\nA [*name*] is an [identifier] or [lifetime or loop label] that refers to an\nentity. A *name binding* is when an entity declaration introduces\nan identifier or label associated with that entity. [Paths],\nidentifiers, and labels are used to refer to an entity.\n\n### Name resolution\n\n[*Name resolution*] is the compile-time process of tying [paths],\n[identifiers], and [labels] to entity declarations.\n\n### Namespace\n\nA *namespace* is a logical grouping of declared names based on the\nkind of entity the name refers to. Namespaces allow the occurrence\nof a name in one namespace to not conflict with the same name in another\nnamespace.\n\nWithin a namespace, names are organized in a hierarchy, where each level of\nthe hierarchy has its own collection of named entities.\n\n### Nominal types\n\nTypes that can be referred to by a path directly. Specifically [enums],\n[structs], [unions], and [trait object types].\n\n### Dyn-compatible traits\n\n[Traits] that can be used in [trait object types] (`dyn Trait`).\nOnly traits that follow specific rules are *dyn compatible*.\n\nThese were formerly known as *object safe* traits.\n\n### Path\n\nA [*path*] is a sequence of one or more path segments used to refer to an\nentity in the current scope or other levels of a\nnamespace hierarchy.\n\n### Prelude\n\nPrelude, or The Rust Prelude, is a small collection of items - mostly traits - that are\nimported into every module of every crate. The traits in the prelude are pervasive.\n\n### Scope\n\nA [*scope*] is the region of source text where a named entity may\nbe referenced with that name.\n\n### Scrutinee\n\nA scrutinee is the expression that is matched on in `match` expressions and\nsimilar pattern matching constructs. For example, in `match x { A => 1, B => 2 }`,\nthe expression `x` is the scrutinee.\n\n### Size\n\nThe size of a value has two definitions.\n\nThe first is that it is how much memory must be allocated to store that value.\n\nThe second is that it is the offset in bytes between successive elements in an\narray with that item type.\n\nIt is a multiple of the alignment, including zero. The size can change\ndepending on compiler version (as new optimizations are made) and target\nplatform (similar to how `usize` varies per-platform).\n\nMore.\n\n### Slice\n\nA slice is dynamically-sized view into a contiguous sequence, written as `[T]`.\n\nIt is often seen in its borrowed forms, either mutable or shared. The shared\nslice type is `&[T]`, while the mutable slice type is `&mut [T]`, where `T` represents\nthe element type.\n\n### Statement\n\nA statement is the smallest standalone element of a programming language\nthat commands a computer to perform an action.\n\n### String literal\n\nA string literal is a string stored directly in the final binary, and so will be\nvalid for the `'static` duration.\n\nIts type is `'static` duration borrowed string slice, `&'static str`.\n\n### String slice\n\nA string slice is the most primitive string type in Rust, written as `str`. It is\noften seen in its borrowed forms, either mutable or shared. The shared\nstring slice type is `&str`, while the mutable string slice type is `&mut str`.\n\nStrings slices are always valid UTF-8.\n\n### Trait\n\nA trait is a language item that is used for describing the functionalities a type must provide.\nIt allows a type to make certain promises about its behavior.\n\nGeneric functions and generic structs can use traits to constrain, or bound, the types they accept.\n\n### Turbofish\n\nPaths with generic parameters in expressions must prefix the opening brackets with a `::`.\nCombined with the angular brackets for generics, this looks like a fish `::<>`.\nAs such, this syntax is colloquially referred to as turbofish syntax.\n\nExamples:\n\nlet ok_num = Ok::<_, ()>(5);\nlet vec = [1, 2, 3].iter().map(|n| n * 2).collect::<Vec<_>>();\n\nThis `::` prefix is required to disambiguate generic paths with multiple comparisons in a comma-separate list.\nSee the bastion of the turbofish for an example where not having the prefix would be ambiguous.\n\n### Uncovered type\n\nA type which does not appear as an argument to another type. For example,\n`T` is uncovered, but the `T` in `Vec<T>` is covered. This is only relevant for\ntype arguments.\n\n### Undefined behavior\n\nCompile-time or run-time behavior that is not specified. This may result in,\nbut is not limited to: process termination or corruption; improper, incorrect,\nor unintended computation; or platform-specific results.\nMore.\n\n### Uninhabited\n\nA type is uninhabited if it has no constructors and therefore can never be instantiated. An\nuninhabited type is \"empty\" in the sense that there are no values of the type. The canonical\nexample of an uninhabited type is the [never type] `!`, or an enum with no variants\n`enum Never { }`. Opposite of Inhabited.\n\n[`extern` blocks]: items.extern\n[`extern fn`]: items.fn.extern\n[alignment]: type-layout.md#size-and-alignment\n\n[attributes]: attributes.md\n[*entity*]: names.md\n[crate]: crates-and-source-files.md\n[dyn compatibility]: items/traits.md#dyn-compatibility\n[enums]: items/enumerations.md\n[fields]: expressions/field-expr.md\n\n[generic parameters]: items/generics.md\n[identifier]: identifiers.md\n[identifiers]: identifiers.md\n[implementation]: items/implementations.md\n[implementations]: items/implementations.md\n[inherent implementation]: items/implementations.md#inherent-implementations\n[item]: items.md\n[items]: items.md\n[labels]: tokens.md#lifetimes-and-loop-labels\n[lifetime or loop label]: tokens.md#lifetimes-and-loop-labels\n[lifetimes]: tokens.md#lifetimes-and-loop-labels\n[lints]: attributes/diagnostics.md#lint-check-attributes\n[loop labels]: tokens.md#lifetimes-and-loop-labels\n[method]: items/associated-items.md#methods\n[modules]: items/modules.md\n[*Name resolution*]: names/name-resolution.md\n[*name*]: names.md\n[*namespace*]: names/namespaces.md\n[never type]: types/never.md\n[*path*]: paths.md\n[Paths]: paths.md\n[*scope*]: names/scopes.md\n[structs]: items/structs.md\n[trait object types]: types/trait-object.md\n[traits]: items/traits.md\n[turbofish test]: https://github.com/rust-lang/rust/blob/1.58.0/src/test/ui/parser/bastion-of-the-turbofish.rs\n[types of crates]: linkage.md\n[types]: types.md\n[undefined-behavior]: behavior-considered-undefined.md\n[unions]: items/unions.md\n[variable bindings]: patterns.md\n[visibility rules]: visibility-and-privacy.md"
      }
    }
  ],
  "ids": [
    "macro.ambiguity.sets.def.follow.pat",
    "macro.ambiguity.sets.def.first.epsilon",
    "macro.ambiguity.sets.def.first.token",
    "macro.ambiguity.convention.sequence-vars",
    "macro.ambiguity.sets.def.last.delim",
    "macro.ambiguity.invariant",
    "macro.ambiguity.sets.def.last.rep-plus",
    "macro.ambiguity.sets.def.follow.ty-path",
    "macro.ambiguity.sets.def.last.intro",
    "macro.ambiguity.sets.def.first.complex",
    "influences",
    "grammar_summary",
    "syntax_index_p1",
    "macro.ambiguity.sets.def.follow.simple",
    "macro.ambiguity.sets.def.follow.vis",
    "appendices",
    "macro.ambiguity.invariant.separated-complex-nt",
    "macro.ambiguity.sets.def",
    "macro.ambiguity.sets.def.last.rep-star",
    "macro.ambiguity.sets.def.follow.expr-stmt",
    "influences_p1",
    "test_summary",
    "macro.ambiguity",
    "macro.ambiguity.sets.def.intro",
    "test_summary_p1",
    "macro.ambiguity.convention.complex-nt",
    "macro.ambiguity.sets",
    "macro.ambiguity.sets.universe",
    "macro.ambiguity.convention.matcher",
    "macro.ambiguity.sets.def.first",
    "macro.ambiguity.sets.follow",
    "macro.ambiguity.sets.last",
    "macro.ambiguity.sets.def.last",
    "macro.ambiguity.invariant.list",
    "macro.ambiguity.sets.def.last.token",
    "macro.ambiguity.sets.def.follow.intro",
    "macro.ambiguity.sets.def.last.sequence",
    "macro.ambiguity.sets.def.last.rep-question",
    "macro.ambiguity.convention",
    "macro.ambiguity.sets.def.last.empty",
    "macro.ambiguity.sets.def.follow",
    "glossary.abi",
    "macro.ambiguity.sets.def.first.intro",
    "glossary.ast",
    "macro.ambiguity.invariant.follow-matcher",
    "grammar_summary_p1",
    "macro.ambiguity.invariant.unseparated-complex-nt",
    "macro.ambiguity.sets.def.notation",
    "macro.ambiguity.convention.vars",
    "macro.ambiguity.sets.def.follow.type-first",
    "macro.ambiguity.sets.def.follow.other-matcher",
    "syntax_index",
    "macro.ambiguity.convention.set",
    "macro.ambiguity.sets.intro",
    "macro.ambiguity.convention.defs",
    "macro.ambiguity.sets.first",
    "appendices_p1"
  ]
}
