{
  "source": "Rust Reference",
  "source_repo": "https://github.com/rust-lang/reference",
  "extraction_date": "2026-01-03",
  "chapter": 9,
  "title": "Statements and expressions",
  "file": "statements-and-expressions.md",
  "sections": [
    {
      "id": "stmt-expr",
      "title": "Statements and expressions",
      "level": 1,
      "content": "Rust is _primarily_ an expression language.\nThis means that most forms of value-producing or effect-causing evaluation are directed by the uniform syntax category of _expressions_.\nEach kind of expression can typically _nest_ within each other kind of expression, and rules for evaluation of expressions involve specifying both the value produced by the expression and the order in which its sub-expressions are themselves evaluated.\n\nIn contrast, statements serve _mostly_ to contain and explicitly sequence expression evaluation.",
      "parent_id": null,
      "paragraphs": {
        "stmt-expr": "Rust is _primarily_ an expression language.\nThis means that most forms of value-producing or effect-causing evaluation are directed by the uniform syntax category of _expressions_.\nEach kind of expression can typically _nest_ within each other kind of expression, and rules for evaluation of expressions involve specifying both the value produced by the expression and the order in which its sub-expressions are themselves evaluated.\n\nIn contrast, statements serve _mostly_ to contain and explicitly sequence expression evaluation."
      }
    },
    {
      "id": "statement",
      "title": "Statements",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "statement.syntax",
      "title": "Statements",
      "level": 1,
      "content": ",statements\nStatement ->\n      `;`\n    | Item\n    | LetStatement\n    | ExpressionStatement\n    | OuterAttribute* MacroInvocationSemi",
      "parent_id": null,
      "paragraphs": {
        "statement.syntax": ",statements\nStatement ->\n      `;`\n    | Item\n    | LetStatement\n    | ExpressionStatement\n    | OuterAttribute* MacroInvocationSemi"
      }
    },
    {
      "id": "statement.intro",
      "title": "Statements",
      "level": 1,
      "content": "A *statement* is a component of a [block], which is in turn a component of an outer [expression] or [function].",
      "parent_id": null,
      "paragraphs": {
        "statement.intro": "A *statement* is a component of a [block], which is in turn a component of an outer [expression] or [function]."
      }
    },
    {
      "id": "statement.kind",
      "title": "Statements",
      "level": 1,
      "content": "Rust has two kinds of statement: declaration statements and expression statements.",
      "parent_id": null,
      "paragraphs": {
        "statement.kind": "Rust has two kinds of statement: declaration statements and expression statements."
      }
    },
    {
      "id": "statement.decl",
      "title": "Declaration statements",
      "level": 1,
      "content": "A *declaration statement* is one that introduces one or more *names* into the enclosing statement block.\nThe declared names may denote new variables or new items.\n\nThe two kinds of declaration statements are item declarations and `let` statements.",
      "parent_id": null,
      "paragraphs": {
        "statement.decl": "A *declaration statement* is one that introduces one or more *names* into the enclosing statement block.\nThe declared names may denote new variables or new items.\n\nThe two kinds of declaration statements are item declarations and `let` statements."
      }
    },
    {
      "id": "statement.item",
      "title": "Item declarations",
      "level": 2,
      "content": "An *item declaration statement* has a syntactic form identical to an item declaration within a [module].\n\nDeclaring an item within a statement block restricts its [scope] to the block containing the statement.\nThe item is not given a [canonical path] nor are any sub-items it may declare.\n\nThe exception to this is that associated items defined by [implementations] are still accessible in outer scopes as long as the item and, if applicable, trait are accessible.\nIt is otherwise identical in meaning to declaring the item inside a module.\n\nThere is no implicit capture of the containing function's generic parameters, parameters, and local variables.\nFor example, `inner` may not access `outer_var`.\n\nfn outer() {\n  let outer_var = true;\n\n  fn inner() { /* outer_var is not in scope here */ }\n\n  inner();\n}",
      "parent_id": null,
      "paragraphs": {
        "statement.item.intro": "An *item declaration statement* has a syntactic form identical to an item declaration within a [module].",
        "statement.item.scope": "Declaring an item within a statement block restricts its [scope] to the block containing the statement.\nThe item is not given a [canonical path] nor are any sub-items it may declare.",
        "statement.item.associated-scope": "The exception to this is that associated items defined by [implementations] are still accessible in outer scopes as long as the item and, if applicable, trait are accessible.\nIt is otherwise identical in meaning to declaring the item inside a module.",
        "statement.item.outer-generics": "There is no implicit capture of the containing function's generic parameters, parameters, and local variables.\nFor example, `inner` may not access `outer_var`.\n\nfn outer() {\n  let outer_var = true;\n\n  fn inner() { /* outer_var is not in scope here */ }\n\n  inner();\n}"
      }
    },
    {
      "id": "statement.let",
      "title": "`let` statements",
      "level": 3,
      "content": ",statements\nLetStatement ->\n    OuterAttribute* `let` PatternNoTopAlt ( `:` Type )?\n    (\n          `=` Expression\n        | `=` Expression _except [LazyBooleanExpression] or end with a `}`_ `else` BlockExpression\n    )? `;`\n\nA *`let` statement* introduces a new set of [variables], given by a [pattern].\nThe pattern is followed optionally by a type annotation and then either ends, or is followed by an initializer expression plus an optional `else` block.\n\nWhen no type annotation is given, the compiler will infer the type, or signal an error if insufficient type information is available for definite inference.\n\nAny variables introduced by a variable declaration are visible from the point of declaration until the end of the enclosing block scope, except when they are shadowed by another variable declaration.\n\nIf an `else` block is not present, the pattern must be irrefutable.\nIf an `else` block is present, the pattern may be refutable.\n\nIf the pattern does not match (this requires it to be refutable), the `else` block is executed.\nThe `else` block must always diverge (evaluate to the [never type]).\n\nlet (mut v, w) = (vec![1, 2, 3], 42); // The bindings may be mut or const\nlet Some(t) = v.pop() else { // Refutable patterns require an else block\n    panic!(); // The else block must diverge\n};\nlet [u, v] = [v[0], v[1]] else { // This pattern is irrefutable, so the compiler\n                                 // will lint as the else block is redundant.\n    panic!();\n};",
      "parent_id": null,
      "paragraphs": {
        "statement.let.syntax": ",statements\nLetStatement ->\n    OuterAttribute* `let` PatternNoTopAlt ( `:` Type )?\n    (\n          `=` Expression\n        | `=` Expression _except [LazyBooleanExpression] or end with a `}`_ `else` BlockExpression\n    )? `;`",
        "statement.let.intro": "A *`let` statement* introduces a new set of [variables], given by a [pattern].\nThe pattern is followed optionally by a type annotation and then either ends, or is followed by an initializer expression plus an optional `else` block.",
        "statement.let.inference": "When no type annotation is given, the compiler will infer the type, or signal an error if insufficient type information is available for definite inference.",
        "statement.let.scope": "Any variables introduced by a variable declaration are visible from the point of declaration until the end of the enclosing block scope, except when they are shadowed by another variable declaration.",
        "statement.let.constraint": "If an `else` block is not present, the pattern must be irrefutable.\nIf an `else` block is present, the pattern may be refutable.",
        "statement.let.behavior": "If the pattern does not match (this requires it to be refutable), the `else` block is executed.\nThe `else` block must always diverge (evaluate to the [never type]).\n\nlet (mut v, w) = (vec![1, 2, 3], 42); // The bindings may be mut or const\nlet Some(t) = v.pop() else { // Refutable patterns require an else block\n    panic!(); // The else block must diverge\n};\nlet [u, v] = [v[0], v[1]] else { // This pattern is irrefutable, so the compiler\n                                 // will lint as the else block is redundant.\n    panic!();\n};"
      }
    },
    {
      "id": "statement.expr",
      "title": "Expression statements",
      "level": 3,
      "content": ",statements\nExpressionStatement ->\n      ExpressionWithoutBlock `;`\n    | ExpressionWithBlock `;`?\n\nAn *expression statement* is one that evaluates an [expression] and ignores its result.\nAs a rule, an expression statement's purpose is to trigger the effects of evaluating its expression.\n\nAn expression that consists of only a block expression or control flow expression, if used in a context where a statement is permitted, can omit the trailing semicolon.\nThis can cause an ambiguity between it being parsed as a standalone statement and as a part of another expression;\nin this case, it is parsed as a statement.\n\nThe type of [ExpressionWithBlock] expressions when used as statements must be the unit type.\n\n# let mut v = vec![1, 2, 3];\nv.pop();          // Ignore the element returned from pop\nif v.is_empty() {\n    v.push(5);\n} else {\n    v.remove(0);\n}                 // Semicolon can be omitted.\n[1];              // Separate expression statement, not an indexing expression.\n\nWhen the trailing semicolon is omitted, the result must be type `()`.\n\n// bad: the block's type is i32, not ()\n// Error: expected `()` because of default return type\n// if true {\n//   1\n// }\n\n// good: the block's type is i32\nif true {\n  1\n} else {\n  2\n};",
      "parent_id": null,
      "paragraphs": {
        "statement.expr.syntax": ",statements\nExpressionStatement ->\n      ExpressionWithoutBlock `;`\n    | ExpressionWithBlock `;`?",
        "statement.expr.intro": "An *expression statement* is one that evaluates an [expression] and ignores its result.\nAs a rule, an expression statement's purpose is to trigger the effects of evaluating its expression.",
        "statement.expr.restriction-semicolon": "An expression that consists of only a block expression or control flow expression, if used in a context where a statement is permitted, can omit the trailing semicolon.\nThis can cause an ambiguity between it being parsed as a standalone statement and as a part of another expression;\nin this case, it is parsed as a statement.",
        "statement.expr.constraint-block": "The type of [ExpressionWithBlock] expressions when used as statements must be the unit type.\n\n# let mut v = vec![1, 2, 3];\nv.pop();          // Ignore the element returned from pop\nif v.is_empty() {\n    v.push(5);\n} else {\n    v.remove(0);\n}                 // Semicolon can be omitted.\n[1];              // Separate expression statement, not an indexing expression.\n\nWhen the trailing semicolon is omitted, the result must be type `()`.\n\n// bad: the block's type is i32, not ()\n// Error: expected `()` because of default return type\n// if true {\n//   1\n// }\n\n// good: the block's type is i32\nif true {\n  1\n} else {\n  2\n};"
      }
    },
    {
      "id": "statement.attribute",
      "title": "Attributes on statements",
      "level": 1,
      "content": "Statements accept [outer attributes].\nThe attributes that have meaning on a statement are [`cfg`], and [the lint check attributes].\n\n[block]: expressions/block-expr.md\n[expression]: expressions.md\n[function]: items/functions.md\n[item]: items.md\n[module]: items/modules.md\n[never type]: types/never.md\n[canonical path]: paths.md#canonical-paths\n[implementations]: items/implementations.md\n[variables]: variables.md\n[outer attributes]: attributes.md\n[`cfg`]: conditional-compilation.md\n[the lint check attributes]: attributes/diagnostics.md#lint-check-attributes\n[pattern]: patterns.md\n[scope]: names/scopes.md",
      "parent_id": null,
      "paragraphs": {
        "statement.attribute": "Statements accept [outer attributes].\nThe attributes that have meaning on a statement are [`cfg`], and [the lint check attributes].\n\n[block]: expressions/block-expr.md\n[expression]: expressions.md\n[function]: items/functions.md\n[item]: items.md\n[module]: items/modules.md\n[never type]: types/never.md\n[canonical path]: paths.md#canonical-paths\n[implementations]: items/implementations.md\n[variables]: variables.md\n[outer attributes]: attributes.md\n[`cfg`]: conditional-compilation.md\n[the lint check attributes]: attributes/diagnostics.md#lint-check-attributes\n[pattern]: patterns.md\n[scope]: names/scopes.md"
      }
    },
    {
      "id": "expr",
      "title": "Expressions",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "expr.syntax",
      "title": "Expressions",
      "level": 1,
      "content": ",expressions\nExpression ->\n      ExpressionWithoutBlock\n    | ExpressionWithBlock\n\nExpressionWithoutBlock ->\n    OuterAttribute*\n    (\n        LiteralExpression\n      | PathExpression\n      | OperatorExpression\n      | GroupedExpression\n      | ArrayExpression\n      | AwaitExpression\n      | IndexExpression\n      | TupleExpression\n      | TupleIndexingExpression\n      | StructExpression\n      | CallExpression\n      | MethodCallExpression\n      | FieldExpression\n      | ClosureExpression\n      | AsyncBlockExpression\n      | ContinueExpression\n      | BreakExpression\n      | RangeExpression\n      | ReturnExpression\n      | UnderscoreExpression\n      | MacroInvocation\n    )\n\nExpressionWithBlock ->\n    OuterAttribute*\n    (\n        BlockExpression\n      | ConstBlockExpression\n      | UnsafeBlockExpression\n      | LoopExpression\n      | IfExpression\n      | MatchExpression\n    )",
      "parent_id": null,
      "paragraphs": {
        "expr.syntax": ",expressions\nExpression ->\n      ExpressionWithoutBlock\n    | ExpressionWithBlock\n\nExpressionWithoutBlock ->\n    OuterAttribute*\n    (\n        LiteralExpression\n      | PathExpression\n      | OperatorExpression\n      | GroupedExpression\n      | ArrayExpression\n      | AwaitExpression\n      | IndexExpression\n      | TupleExpression\n      | TupleIndexingExpression\n      | StructExpression\n      | CallExpression\n      | MethodCallExpression\n      | FieldExpression\n      | ClosureExpression\n      | AsyncBlockExpression\n      | ContinueExpression\n      | BreakExpression\n      | RangeExpression\n      | ReturnExpression\n      | UnderscoreExpression\n      | MacroInvocation\n    )\n\nExpressionWithBlock ->\n    OuterAttribute*\n    (\n        BlockExpression\n      | ConstBlockExpression\n      | UnsafeBlockExpression\n      | LoopExpression\n      | IfExpression\n      | MatchExpression\n    )"
      }
    },
    {
      "id": "expr.intro",
      "title": "Expressions",
      "level": 1,
      "content": "An expression may have two roles: it always produces a *value*, and it may have *effects* (otherwise known as \"side effects\").",
      "parent_id": null,
      "paragraphs": {
        "expr.intro": "An expression may have two roles: it always produces a *value*, and it may have *effects* (otherwise known as \"side effects\")."
      }
    },
    {
      "id": "expr.evaluation",
      "title": "Expressions",
      "level": 1,
      "content": "An expression *evaluates to* a value, and has effects during *evaluation*.",
      "parent_id": null,
      "paragraphs": {
        "expr.evaluation": "An expression *evaluates to* a value, and has effects during *evaluation*."
      }
    },
    {
      "id": "expr.operands",
      "title": "Expressions",
      "level": 1,
      "content": "Many expressions contain sub-expressions, called the *operands* of the expression.",
      "parent_id": null,
      "paragraphs": {
        "expr.operands": "Many expressions contain sub-expressions, called the *operands* of the expression."
      }
    },
    {
      "id": "expr.behavior",
      "title": "Expressions",
      "level": 1,
      "content": "The meaning of each kind of expression dictates several things:\n\n* Whether or not to evaluate the operands when evaluating the expression\n* The order in which to evaluate the operands\n* How to combine the operands' values to obtain the value of the expression",
      "parent_id": null,
      "paragraphs": {
        "expr.behavior": "The meaning of each kind of expression dictates several things:\n\n* Whether or not to evaluate the operands when evaluating the expression\n* The order in which to evaluate the operands\n* How to combine the operands' values to obtain the value of the expression"
      }
    },
    {
      "id": "expr.structure",
      "title": "Expressions",
      "level": 1,
      "content": "In this way, the structure of expressions dictates the structure of execution.\nBlocks are just another kind of expression, so blocks, statements, expressions, and blocks again can recursively nest inside each other to an arbitrary depth.\n\n> [!NOTE]\n> We give names to the operands of expressions so that we may discuss them, but these names are not stable and may be changed.",
      "parent_id": null,
      "paragraphs": {
        "expr.structure": "In this way, the structure of expressions dictates the structure of execution.\nBlocks are just another kind of expression, so blocks, statements, expressions, and blocks again can recursively nest inside each other to an arbitrary depth.\n\n> [!NOTE]\n> We give names to the operands of expressions so that we may discuss them, but these names are not stable and may be changed."
      }
    },
    {
      "id": "expr.precedence",
      "title": "Expression precedence",
      "level": 1,
      "content": "The precedence of Rust operators and expressions is ordered as follows, going from strong to weak.\nBinary Operators at the same precedence level are grouped in the order given by their associativity.\n\n| Operator/Expression         | Associativity       |\n|-----------------------------|---------------------|\n| Paths          |                     |\n| Method calls |                     |\n| Field expressions | left to right   |\n| Function calls, array indexing | |\n| `?`             |                     |\n| Unary `-` `!` `*` borrow | |\n| `as`             | left to right       |\n| `*` `/` `%` | left to right       |\n| `+` `-` | left to right       |\n| `<<` `>>` | left to right     |\n| `&`     | left to right       |\n| `^`     | left to right       |\n| <code>&#124;</code> | left to right       |\n| `==` `!=` `<` `>` `<=` `>=` | Require parentheses |\n| `&&`     | left to right       |\n| <code>&#124;&#124;</code> | left to right       |\n| `..` `..=` | Require parentheses |\n| `=` `+=` `-=` `*=` `/=` `%=` <br> `&=` <code>&#124;=</code> `^=` `<<=` `>>=` | right to left |\n| `return` `break` closures  | |",
      "parent_id": null,
      "paragraphs": {
        "expr.precedence": "The precedence of Rust operators and expressions is ordered as follows, going from strong to weak.\nBinary Operators at the same precedence level are grouped in the order given by their associativity.\n\n| Operator/Expression         | Associativity       |\n|-----------------------------|---------------------|\n| Paths          |                     |\n| Method calls |                     |\n| Field expressions | left to right   |\n| Function calls, array indexing | |\n| `?`             |                     |\n| Unary `-` `!` `*` borrow | |\n| `as`             | left to right       |\n| `*` `/` `%` | left to right       |\n| `+` `-` | left to right       |\n| `<<` `>>` | left to right     |\n| `&`     | left to right       |\n| `^`     | left to right       |\n| <code>&#124;</code> | left to right       |\n| `==` `!=` `<` `>` `<=` `>=` | Require parentheses |\n| `&&`     | left to right       |\n| <code>&#124;&#124;</code> | left to right       |\n| `..` `..=` | Require parentheses |\n| `=` `+=` `-=` `*=` `/=` `%=` <br> `&=` <code>&#124;=</code> `^=` `<<=` `>>=` | right to left |\n| `return` `break` closures  | |"
      }
    },
    {
      "id": "expr.operand-order",
      "title": "Evaluation order of operands",
      "level": 2,
      "content": "The following list of expressions all evaluate their operands the same way, as described after the list.\nOther expressions either don't take operands or evaluate them conditionally as described on their respective pages.\n\n* Dereference expression\n* Error propagation expression\n* Negation expression\n* Arithmetic and logical binary operators\n* Comparison operators\n* Type cast expression\n* Grouped expression\n* Array expression\n* Await expression\n* Index expression\n* Tuple expression\n* Tuple index expression\n* Struct expression\n* Call expression\n* Method call expression\n* Field expression\n* Break expression\n* Range expression\n* Return expression\n\nThe operands of these expressions are evaluated prior to applying the effects of the expression.\nExpressions taking multiple operands are evaluated left to right as written in the source code.\n\n> [!NOTE]\n> Which subexpressions are the operands of an expression is determined by expression precedence as per the previous section.\n\nFor example, the two `next` method calls will always be called in the same order:\n\n# // Using vec instead of array to avoid references\n# // since there is no stable owned array iterator\n# // at the time this example was written.\nlet mut one_two = vec![1, 2].into_iter();\nassert_eq!(\n    (1, 2),\n    (one_two.next().unwrap(), one_two.next().unwrap())\n);\n\n> [!NOTE]\n> Since this is applied recursively, these expressions are also evaluated from innermost to outermost, ignoring siblings until there are no inner subexpressions.",
      "parent_id": null,
      "paragraphs": {
        "expr.operand-order.default": "The following list of expressions all evaluate their operands the same way, as described after the list.\nOther expressions either don't take operands or evaluate them conditionally as described on their respective pages.\n\n* Dereference expression\n* Error propagation expression\n* Negation expression\n* Arithmetic and logical binary operators\n* Comparison operators\n* Type cast expression\n* Grouped expression\n* Array expression\n* Await expression\n* Index expression\n* Tuple expression\n* Tuple index expression\n* Struct expression\n* Call expression\n* Method call expression\n* Field expression\n* Break expression\n* Range expression\n* Return expression",
        "expr.operand-order.operands-before-primary": "The operands of these expressions are evaluated prior to applying the effects of the expression.\nExpressions taking multiple operands are evaluated left to right as written in the source code.\n\n> [!NOTE]\n> Which subexpressions are the operands of an expression is determined by expression precedence as per the previous section.\n\nFor example, the two `next` method calls will always be called in the same order:\n\n# // Using vec instead of array to avoid references\n# // since there is no stable owned array iterator\n# // at the time this example was written.\nlet mut one_two = vec![1, 2].into_iter();\nassert_eq!(\n    (1, 2),\n    (one_two.next().unwrap(), one_two.next().unwrap())\n);\n\n> [!NOTE]\n> Since this is applied recursively, these expressions are also evaluated from innermost to outermost, ignoring siblings until there are no inner subexpressions."
      }
    },
    {
      "id": "expr.place-value",
      "title": "Place expressions and value expressions",
      "level": 1,
      "content": "Expressions are divided into two main categories: place expressions and value expressions;\nthere is also a third, minor category of expressions called assignee expressions.\nWithin each expression, operands may likewise occur in either place context or value context.\nThe evaluation of an expression depends both on its own category and the context it occurs within.\n\nA *place expression* is an expression that represents a memory location.\n\nThese expressions are [paths] which refer to local variables, [static variables], dereferences (`*expr`), [array indexing] expressions (`expr[expr]`), [field] references (`expr.f`) and parenthesized place expressions.\n\nAll other expressions are value expressions.\n\nA *value expression* is an expression that represents an actual value.\n\nThe following contexts are *place expression* contexts:\n\n* The left operand of a [compound assignment] expression.\n* The operand of a unary [borrow], [raw borrow] or dereference operator.\n* The operand of a field expression.\n* The indexed operand of an array indexing expression.\n* The operand of any [implicit borrow].\n* The initializer of a [let statement].\n* The [scrutinee] of an [`if let`], `match`, or [`while let`]\n  expression.\n* The base of a [functional update] struct expression.\n\n> [!NOTE]\n> Historically, place expressions were called *lvalues* and value expressions were called *rvalues*.\n\nAn *assignee expression* is an expression that appears in the left operand of an assignment expression.\nExplicitly, the assignee expressions are:\n\n- Place expressions.\n- [Underscores].\n- [Tuples] of assignee expressions.\n- Slices of assignee expressions.\n- [Tuple structs] of assignee expressions.\n- [Structs] of assignee expressions (with optionally named\n  fields).\n- [Unit structs]\n\nArbitrary parenthesisation is permitted inside assignee expressions.",
      "parent_id": null,
      "paragraphs": {
        "expr.place-value.intro": "Expressions are divided into two main categories: place expressions and value expressions;\nthere is also a third, minor category of expressions called assignee expressions.\nWithin each expression, operands may likewise occur in either place context or value context.\nThe evaluation of an expression depends both on its own category and the context it occurs within.",
        "expr.place-value.place-memory-location": "A *place expression* is an expression that represents a memory location.",
        "expr.place-value.place-expr-kinds": "These expressions are [paths] which refer to local variables, [static variables], dereferences (`*expr`), [array indexing] expressions (`expr[expr]`), [field] references (`expr.f`) and parenthesized place expressions.",
        "expr.place-value.value-expr-kinds": "All other expressions are value expressions.",
        "expr.place-value.value-result": "A *value expression* is an expression that represents an actual value.",
        "expr.place-value.place-context": "The following contexts are *place expression* contexts:\n\n* The left operand of a [compound assignment] expression.\n* The operand of a unary [borrow], [raw borrow] or dereference operator.\n* The operand of a field expression.\n* The indexed operand of an array indexing expression.\n* The operand of any [implicit borrow].\n* The initializer of a [let statement].\n* The [scrutinee] of an [`if let`], `match`, or [`while let`]\n  expression.\n* The base of a [functional update] struct expression.\n\n> [!NOTE]\n> Historically, place expressions were called *lvalues* and value expressions were called *rvalues*.",
        "expr.place-value.assignee": "An *assignee expression* is an expression that appears in the left operand of an assignment expression.\nExplicitly, the assignee expressions are:\n\n- Place expressions.\n- [Underscores].\n- [Tuples] of assignee expressions.\n- Slices of assignee expressions.\n- [Tuple structs] of assignee expressions.\n- [Structs] of assignee expressions (with optionally named\n  fields).\n- [Unit structs]",
        "expr.place-value.parenthesis": "Arbitrary parenthesisation is permitted inside assignee expressions."
      }
    },
    {
      "id": "expr.move",
      "title": "Moved and copied types",
      "level": 2,
      "content": "When a place expression is evaluated in a value expression context, or is bound by value in a pattern, it denotes the value held _in_ that memory location.\n\nIf the type of that value implements [`Copy`], then the value will be copied.\n\nIn the remaining situations, if that type is [`Sized`], then it may be possible to move the value.\n\nOnly the following place expressions may be moved out of:\n\n* [Variables] which are not currently borrowed.\n* Temporary values.\n* Fields of a place expression which can be moved out of and don't implement [`Drop`].\n* The result of dereferencing an expression with type [`Box<T>`] and that can also be moved out of.\n\nAfter moving out of a place expression that evaluates to a local variable, the location is deinitialized and cannot be read from again until it is reinitialized.\n\nIn all other cases, trying to use a place expression in a value expression context is an error.",
      "parent_id": null,
      "paragraphs": {
        "expr.move.intro": "When a place expression is evaluated in a value expression context, or is bound by value in a pattern, it denotes the value held _in_ that memory location.",
        "expr.move.copy": "If the type of that value implements [`Copy`], then the value will be copied.",
        "expr.move.requires-sized": "In the remaining situations, if that type is [`Sized`], then it may be possible to move the value.",
        "expr.move.movable-place": "Only the following place expressions may be moved out of:\n\n* [Variables] which are not currently borrowed.\n* Temporary values.\n* Fields of a place expression which can be moved out of and don't implement [`Drop`].\n* The result of dereferencing an expression with type [`Box<T>`] and that can also be moved out of.",
        "expr.move.deinitialization": "After moving out of a place expression that evaluates to a local variable, the location is deinitialized and cannot be read from again until it is reinitialized.",
        "expr.move.place-invalid": "In all other cases, trying to use a place expression in a value expression context is an error."
      }
    },
    {
      "id": "expr.mut",
      "title": "Mutability",
      "level": 3,
      "content": "For a place expression to be assigned to, mutably borrowed, [implicitly mutably borrowed], or bound to a pattern containing `ref mut`, it must be _mutable_.\nWe call these *mutable place expressions*.\nIn contrast, other place expressions are called *immutable place expressions*.\n\nThe following expressions can be mutable place expression contexts:\n\n* Mutable [variables] which are not currently borrowed.\n* [Mutable `static` items].\n* [Temporary values].\n* Fields: this evaluates the subexpression in a mutable place expression context.\n* Dereferences of a `*mut T` pointer.\n* Dereference of a variable, or field of a variable, with type `&mut T`.\n  Note: This is an exception to the requirement of the next rule.\n* Dereferences of a type that implements `DerefMut`:\n  this then requires that the value being dereferenced is evaluated in a mutable place expression context.\n* [Array indexing] of a type that implements `IndexMut`:\n  this then evaluates the value being indexed, but not the index, in mutable place expression context.",
      "parent_id": null,
      "paragraphs": {
        "expr.mut.intro": "For a place expression to be assigned to, mutably borrowed, [implicitly mutably borrowed], or bound to a pattern containing `ref mut`, it must be _mutable_.\nWe call these *mutable place expressions*.\nIn contrast, other place expressions are called *immutable place expressions*.",
        "expr.mut.valid-places": "The following expressions can be mutable place expression contexts:\n\n* Mutable [variables] which are not currently borrowed.\n* [Mutable `static` items].\n* [Temporary values].\n* Fields: this evaluates the subexpression in a mutable place expression context.\n* Dereferences of a `*mut T` pointer.\n* Dereference of a variable, or field of a variable, with type `&mut T`.\n  Note: This is an exception to the requirement of the next rule.\n* Dereferences of a type that implements `DerefMut`:\n  this then requires that the value being dereferenced is evaluated in a mutable place expression context.\n* [Array indexing] of a type that implements `IndexMut`:\n  this then evaluates the value being indexed, but not the index, in mutable place expression context."
      }
    },
    {
      "id": "expr.temporary",
      "title": "Temporaries",
      "level": 3,
      "content": "When using a value expression in most place expression contexts, a temporary unnamed memory location is created and initialized to that value.\nThe expression evaluates to that location instead, except if [promoted] to a `static`.\nThe [drop scope] of the temporary is usually the end of the enclosing statement.",
      "parent_id": null,
      "paragraphs": {
        "expr.temporary": "When using a value expression in most place expression contexts, a temporary unnamed memory location is created and initialized to that value.\nThe expression evaluates to that location instead, except if [promoted] to a `static`.\nThe [drop scope] of the temporary is usually the end of the enclosing statement."
      }
    },
    {
      "id": "expr.super-macros",
      "title": "Super macros",
      "level": 3,
      "content": "Certain built-in macros may create [temporaries] whose scopes may be [extended]. These temporaries are *super temporaries* and these macros are *super macros*. Invocations of these macros are *super macro call expressions*. Arguments to these macros may be *super operands*.\n\n> [!NOTE]\n> When a super macro call expression is an [extending expression], its super operands are [extending expressions] and the scopes of the super temporaries are [extended]. See [destructors.scope.lifetime-extension.exprs].",
      "parent_id": null,
      "paragraphs": {
        "expr.super-macros.intro": "Certain built-in macros may create [temporaries] whose scopes may be [extended]. These temporaries are *super temporaries* and these macros are *super macros*. Invocations of these macros are *super macro call expressions*. Arguments to these macros may be *super operands*.\n\n> [!NOTE]\n> When a super macro call expression is an [extending expression], its super operands are [extending expressions] and the scopes of the super temporaries are [extended]. See [destructors.scope.lifetime-extension.exprs]."
      }
    },
    {
      "id": "expr.super-macros.format_args",
      "title": "`format_args!`",
      "level": 3,
      "content": "Except for the format string argument, all arguments passed to [`format_args!`] are *super operands*.\n\n,edition2024\n# fn temp() -> String { String::from(\"\") }\n// Due to the call being an extending expression and the argument\n// being a super operand, the inner block is an extending expression,\n// so the scope of the temporary created in its trailing expression\n// is extended.\nlet _ = format_args!(\"{}\", { &temp() }); // OK\n\nThe super operands of [`format_args!`] are [implicitly borrowed] and are therefore [place expression contexts]. When a [value expression] is passed as an argument, it creates a *super temporary*.\n\n# fn temp() -> String { String::from(\"\") }\nlet x = format_args!(\"{}\", temp());\nx; // <-- The temporary is extended, allowing use here.\n\nThe expansion of a call to [`format_args!`] sometimes creates other internal *super temporaries*.\n\n,compile_fail,E0716\nlet x = {\n    // This call creates an internal temporary.\n    let x = format_args!(\"{:?}\", 0);\n    x // <-- The temporary is extended, allowing its use here.\n}; // <-- The temporary is dropped here.\nx; // ERROR\n\n// This call doesn't create an internal temporary.\nlet x = { let x = format_args!(\"{}\", 0); x };\nx; // OK\n\n> [!NOTE]\n> The details of when [`format_args!`] does or does not create internal temporaries are currently unspecified.",
      "parent_id": null,
      "paragraphs": {
        "expr.super-macros.format_args.super-operands": "Except for the format string argument, all arguments passed to [`format_args!`] are *super operands*.\n\n,edition2024\n# fn temp() -> String { String::from(\"\") }\n// Due to the call being an extending expression and the argument\n// being a super operand, the inner block is an extending expression,\n// so the scope of the temporary created in its trailing expression\n// is extended.\nlet _ = format_args!(\"{}\", { &temp() }); // OK",
        "expr.super-macros.format_args.super-temporaries": "The super operands of [`format_args!`] are [implicitly borrowed] and are therefore [place expression contexts]. When a [value expression] is passed as an argument, it creates a *super temporary*.\n\n# fn temp() -> String { String::from(\"\") }\nlet x = format_args!(\"{}\", temp());\nx; // <-- The temporary is extended, allowing use here.\n\nThe expansion of a call to [`format_args!`] sometimes creates other internal *super temporaries*.\n\n,compile_fail,E0716\nlet x = {\n    // This call creates an internal temporary.\n    let x = format_args!(\"{:?}\", 0);\n    x // <-- The temporary is extended, allowing its use here.\n}; // <-- The temporary is dropped here.\nx; // ERROR\n\n// This call doesn't create an internal temporary.\nlet x = { let x = format_args!(\"{}\", 0); x };\nx; // OK\n\n> [!NOTE]\n> The details of when [`format_args!`] does or does not create internal temporaries are currently unspecified."
      }
    },
    {
      "id": "expr.super-macros.pin",
      "title": "`pin!`",
      "level": 1,
      "content": "The argument to [`pin!`] is a *super operand*.\n\n,edition2024\n# use core::pin::pin;\n# fn temp() {}\n// As above for `format_args!`.\nlet _ = pin!({ &temp() }); // OK\n\nThe argument to [`pin!`] is a [value expression context] and creates a *super temporary*.\n\n# use core::pin::pin;\n# fn temp() {}\n// The argument is evaluated into a super temporary.\nlet x = pin!(temp());\n// The temporary is extended, allowing its use here.\nx; // OK",
      "parent_id": null,
      "paragraphs": {
        "expr.super-macros.pin.super-operands": "The argument to [`pin!`] is a *super operand*.\n\n,edition2024\n# use core::pin::pin;\n# fn temp() {}\n// As above for `format_args!`.\nlet _ = pin!({ &temp() }); // OK",
        "expr.super-macros.pin.super-temporaries": "The argument to [`pin!`] is a [value expression context] and creates a *super temporary*.\n\n# use core::pin::pin;\n# fn temp() {}\n// The argument is evaluated into a super temporary.\nlet x = pin!(temp());\n// The temporary is extended, allowing its use here.\nx; // OK"
      }
    },
    {
      "id": "expr.implicit-borrow",
      "title": "Implicit borrows",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "expr.implicit-borrow-intro",
      "title": "Implicit borrows",
      "level": 3,
      "content": "Certain expressions will treat an expression as a place expression by implicitly borrowing it.\nFor example, it is possible to compare two unsized slices for equality directly, because the `==` operator implicitly borrows its operands:\n\n# let c = [1, 2, 3];\n# let d = vec![1, 2, 3];\nlet a: &[i32];\nlet b: &[i32];\n# a = &c;\n# b = &d;\n// ...\n*a == *b;\n// Equivalent form:\n::std::cmp::PartialEq::eq(&*a, &*b);\n\nImplicit borrows may be taken in the following expressions:\n\n* Left operand in [method-call] expressions.\n* Left operand in [field] expressions.\n* Left operand in [call expressions].\n* Left operand in [array indexing] expressions.\n* Operand of the dereference operator (`*`).\n* Operands of [comparison].\n* Left operands of the [compound assignment].\n* Arguments to [`format_args!`] except the format string.",
      "parent_id": null,
      "paragraphs": {
        "expr.implicit-borrow-intro": "Certain expressions will treat an expression as a place expression by implicitly borrowing it.\nFor example, it is possible to compare two unsized slices for equality directly, because the `==` operator implicitly borrows its operands:\n\n# let c = [1, 2, 3];\n# let d = vec![1, 2, 3];\nlet a: &[i32];\nlet b: &[i32];\n# a = &c;\n# b = &d;\n// ...\n*a == *b;\n// Equivalent form:\n::std::cmp::PartialEq::eq(&*a, &*b);",
        "expr.implicit-borrow.application": "Implicit borrows may be taken in the following expressions:\n\n* Left operand in [method-call] expressions.\n* Left operand in [field] expressions.\n* Left operand in [call expressions].\n* Left operand in [array indexing] expressions.\n* Operand of the dereference operator (`*`).\n* Operands of [comparison].\n* Left operands of the [compound assignment].\n* Arguments to [`format_args!`] except the format string."
      }
    },
    {
      "id": "expr.overload",
      "title": "Overloading traits",
      "level": 1,
      "content": "Many of the following operators and expressions can also be overloaded for other types using traits in `std::ops` or `std::cmp`.\nThese traits also exist in `core::ops` and `core::cmp` with the same names.",
      "parent_id": null,
      "paragraphs": {
        "expr.overload": "Many of the following operators and expressions can also be overloaded for other types using traits in `std::ops` or `std::cmp`.\nThese traits also exist in `core::ops` and `core::cmp` with the same names."
      }
    },
    {
      "id": "expr.attr",
      "title": "Expression attributes",
      "level": 2,
      "content": "[Outer attributes] before an expression are allowed only in a few specific cases:\n\n* Before an expression used as a [statement].\n* Elements of [array expressions], [tuple expressions], [call expressions], and tuple-style [struct] expressions.\n* The tail expression of [block expressions].\n<!-- Keep list in sync with block-expr.md -->\n\nThey are never allowed before:\n* [Range] expressions.\n* Binary operator expressions ([ArithmeticOrLogicalExpression], [ComparisonExpression], [LazyBooleanExpression], [TypeCastExpression], [AssignmentExpression], [CompoundAssignmentExpression]).\n\n[`Copy`]:               special-types-and-traits.md#copy\n[`Drop`]:               special-types-and-traits.md#drop\n[`if let`]:             expressions/if-expr.md#if-let-patterns\n[`format_args!`]:       core::format_args\n[`pin!`]:               core::pin::pin\n[`Sized`]:              special-types-and-traits.md#sized\n[`while let`]:          expressions/loop-expr.md#while-let-patterns\n[array expressions]:    expressions/array-expr.md\n[array indexing]:       expressions/array-expr.md#array-and-slice-indexing-expressions\n[assign]:               expressions/operator-expr.md#assignment-expressions\n[block expressions]:    expressions/block-expr.md\n[borrow]:               expressions/operator-expr.md#borrow-operators\n[call expressions]:     expressions/call-expr.md\n[comparison]:           expressions/operator-expr.md#comparison-operators\n[compound assignment]:  expressions/operator-expr.md#compound-assignment-expressions\n[deref]:                expressions/operator-expr.md#the-dereference-operator\n[destructors]:          destructors.md\n[drop scope]:           destructors.md#drop-scopes\n[extended]:             destructors.scope.lifetime-extension\n[extending expression]: destructors.scope.lifetime-extension.exprs\n[extending expressions]: destructors.scope.lifetime-extension.exprs\n[field]:                expressions/field-expr.md\n[functional update]:    expressions/struct-expr.md#functional-update-syntax\n\n[implicitly borrowed]:  expr.implicit-borrow\n\n[interior mutability]:  interior-mutability.md\n[let statement]:        statements.md#let-statements\n[macro invocations]:    macro.invocation\n[match]:                expressions/match-expr.md\n[method-call]:          expressions/method-call-expr.md\n[Mutable `static` items]: items/static-items.md#mutable-statics\n[Outer attributes]:     attributes.md\n[paths]:                expressions/path-expr.md\n[place expression contexts]: expr.place-value\n[promoted]:             destructors.md#constant-promotion\n[Range]:                expressions/range-expr.md\n[raw borrow]:           expressions/operator-expr.md#raw-borrow-operators\n[scrutinee]:            glossary.md#scrutinee\n[slice]:                types/slice.md\n[statement]:            statements.md\n[static variables]:     items/static-items.md\n[struct]:               expressions/struct-expr.md\n[Structs]:              expr.struct\n[temporaries]:          expr.temporary\n[temporary scopes]:     destructors.scope.temporary\n\n[tuple expressions]:    expressions/tuple-expr.md\n[Tuple structs]:        items.struct.tuple\n[Tuples]:               expressions/tuple-expr.md\n[Underscores]:          expressions/underscore-expr.md\n[Unit structs]:         items.struct.unit\n[value expression context]: expr.place-value\n[value expression]:     expr.place-value\n[Variables]:            variables.md",
      "parent_id": null,
      "paragraphs": {
        "expr.attr.restriction": "[Outer attributes] before an expression are allowed only in a few specific cases:\n\n* Before an expression used as a [statement].\n* Elements of [array expressions], [tuple expressions], [call expressions], and tuple-style [struct] expressions.\n* The tail expression of [block expressions].\n<!-- Keep list in sync with block-expr.md -->",
        "expr.attr.never-before": "They are never allowed before:\n* [Range] expressions.\n* Binary operator expressions ([ArithmeticOrLogicalExpression], [ComparisonExpression], [LazyBooleanExpression], [TypeCastExpression], [AssignmentExpression], [CompoundAssignmentExpression]).\n\n[`Copy`]:               special-types-and-traits.md#copy\n[`Drop`]:               special-types-and-traits.md#drop\n[`if let`]:             expressions/if-expr.md#if-let-patterns\n[`format_args!`]:       core::format_args\n[`pin!`]:               core::pin::pin\n[`Sized`]:              special-types-and-traits.md#sized\n[`while let`]:          expressions/loop-expr.md#while-let-patterns\n[array expressions]:    expressions/array-expr.md\n[array indexing]:       expressions/array-expr.md#array-and-slice-indexing-expressions\n[assign]:               expressions/operator-expr.md#assignment-expressions\n[block expressions]:    expressions/block-expr.md\n[borrow]:               expressions/operator-expr.md#borrow-operators\n[call expressions]:     expressions/call-expr.md\n[comparison]:           expressions/operator-expr.md#comparison-operators\n[compound assignment]:  expressions/operator-expr.md#compound-assignment-expressions\n[deref]:                expressions/operator-expr.md#the-dereference-operator\n[destructors]:          destructors.md\n[drop scope]:           destructors.md#drop-scopes\n[extended]:             destructors.scope.lifetime-extension\n[extending expression]: destructors.scope.lifetime-extension.exprs\n[extending expressions]: destructors.scope.lifetime-extension.exprs\n[field]:                expressions/field-expr.md\n[functional update]:    expressions/struct-expr.md#functional-update-syntax\n\n[implicitly borrowed]:  expr.implicit-borrow\n\n[interior mutability]:  interior-mutability.md\n[let statement]:        statements.md#let-statements\n[macro invocations]:    macro.invocation\n[match]:                expressions/match-expr.md\n[method-call]:          expressions/method-call-expr.md\n[Mutable `static` items]: items/static-items.md#mutable-statics\n[Outer attributes]:     attributes.md\n[paths]:                expressions/path-expr.md\n[place expression contexts]: expr.place-value\n[promoted]:             destructors.md#constant-promotion\n[Range]:                expressions/range-expr.md\n[raw borrow]:           expressions/operator-expr.md#raw-borrow-operators\n[scrutinee]:            glossary.md#scrutinee\n[slice]:                types/slice.md\n[statement]:            statements.md\n[static variables]:     items/static-items.md\n[struct]:               expressions/struct-expr.md\n[Structs]:              expr.struct\n[temporaries]:          expr.temporary\n[temporary scopes]:     destructors.scope.temporary\n\n[tuple expressions]:    expressions/tuple-expr.md\n[Tuple structs]:        items.struct.tuple\n[Tuples]:               expressions/tuple-expr.md\n[Underscores]:          expressions/underscore-expr.md\n[Unit structs]:         items.struct.unit\n[value expression context]: expr.place-value\n[value expression]:     expr.place-value\n[Variables]:            variables.md"
      }
    },
    {
      "id": "expr.literal",
      "title": "Literal expressions",
      "level": 1,
      "content": ",expressions\nLiteralExpression ->\n      CHAR_LITERAL\n    | STRING_LITERAL\n    | RAW_STRING_LITERAL\n    | BYTE_LITERAL\n    | BYTE_STRING_LITERAL\n    | RAW_BYTE_STRING_LITERAL\n    | C_STRING_LITERAL\n    | RAW_C_STRING_LITERAL\n    | INTEGER_LITERAL\n    | FLOAT_LITERAL\n    | `true`\n    | `false`\n\nA _literal expression_ is an expression consisting of a single token, rather than a sequence of tokens, that immediately and directly denotes the value it evaluates to, rather than referring to it by name or some other evaluation rule.\n\nA literal is a form of [constant expression], so is evaluated (primarily) at compile time.\n\nEach of the lexical literal forms described earlier can make up a literal expression, as can the keywords `true` and `false`.\n\n\"hello\";   // string type\n'5';       // character type\n5;         // integer type\n\nIn the descriptions below, the _string representation_ of a token is the sequence of characters from the input which matched the token's production in a *Lexer* grammar snippet.\n\n> [!NOTE]\n> This string representation never includes a character `U+000D` (CR) immediately followed by `U+000A` (LF): this pair would have been previously transformed into a single `U+000A` (LF).",
      "parent_id": null,
      "paragraphs": {
        "expr.literal.syntax": ",expressions\nLiteralExpression ->\n      CHAR_LITERAL\n    | STRING_LITERAL\n    | RAW_STRING_LITERAL\n    | BYTE_LITERAL\n    | BYTE_STRING_LITERAL\n    | RAW_BYTE_STRING_LITERAL\n    | C_STRING_LITERAL\n    | RAW_C_STRING_LITERAL\n    | INTEGER_LITERAL\n    | FLOAT_LITERAL\n    | `true`\n    | `false`",
        "expr.literal.intro": "A _literal expression_ is an expression consisting of a single token, rather than a sequence of tokens, that immediately and directly denotes the value it evaluates to, rather than referring to it by name or some other evaluation rule.",
        "expr.literal.const-expr": "A literal is a form of [constant expression], so is evaluated (primarily) at compile time.",
        "expr.literal.literal-token": "Each of the lexical literal forms described earlier can make up a literal expression, as can the keywords `true` and `false`.\n\n\"hello\";   // string type\n'5';       // character type\n5;         // integer type",
        "expr.literal.string-representation": "In the descriptions below, the _string representation_ of a token is the sequence of characters from the input which matched the token's production in a *Lexer* grammar snippet.\n\n> [!NOTE]\n> This string representation never includes a character `U+000D` (CR) immediately followed by `U+000A` (LF): this pair would have been previously transformed into a single `U+000A` (LF)."
      }
    },
    {
      "id": "expr.literal.escape",
      "title": "Escapes",
      "level": 1,
      "content": "The descriptions of textual literal expressions below make use of several forms of _escape_.\n\nEach form of escape is characterised by:\n * an _escape sequence_: a sequence of characters, which always begins with `U+005C` (`\\`)\n * an _escaped value_: either a single character or an empty sequence of characters\n\nIn the definitions of escapes below:\n * An _octal digit_ is any of the characters in the range \\[`0`-`7`].\n * A _hexadecimal digit_ is any of the characters in the ranges \\[`0`-`9`], \\[`a`-`f`], or \\[`A`-`F`].",
      "parent_id": null,
      "paragraphs": {
        "expr.literal.escape.intro": "The descriptions of textual literal expressions below make use of several forms of _escape_.",
        "expr.literal.escape.sequence": "Each form of escape is characterised by:\n * an _escape sequence_: a sequence of characters, which always begins with `U+005C` (`\\`)\n * an _escaped value_: either a single character or an empty sequence of characters\n\nIn the definitions of escapes below:\n * An _octal digit_ is any of the characters in the range \\[`0`-`7`].\n * A _hexadecimal digit_ is any of the characters in the ranges \\[`0`-`9`], \\[`a`-`f`], or \\[`A`-`F`]."
      }
    },
    {
      "id": "expr.literal.escape.simple",
      "title": "Simple escapes",
      "level": 2,
      "content": "Each sequence of characters occurring in the first column of the following table is an escape sequence.\n\nIn each case, the escaped value is the character given in the corresponding entry in the second column.\n\n| Escape sequence | Escaped value            |\n|-----------------|--------------------------|\n| `\\0`            | U+0000 (NUL)             |\n| `\\t`            | U+0009 (HT)              |\n| `\\n`            | U+000A (LF)              |\n| `\\r`            | U+000D (CR)              |\n| `\\\"`            | U+0022 (QUOTATION MARK)  |\n| `\\'`            | U+0027 (APOSTROPHE)      |\n| `\\\\`            | U+005C (REVERSE SOLIDUS) |",
      "parent_id": null,
      "paragraphs": {
        "expr.literal.escape.simple": "Each sequence of characters occurring in the first column of the following table is an escape sequence.\n\nIn each case, the escaped value is the character given in the corresponding entry in the second column.\n\n| Escape sequence | Escaped value            |\n|-----------------|--------------------------|\n| `\\0`            | U+0000 (NUL)             |\n| `\\t`            | U+0009 (HT)              |\n| `\\n`            | U+000A (LF)              |\n| `\\r`            | U+000D (CR)              |\n| `\\\"`            | U+0022 (QUOTATION MARK)  |\n| `\\'`            | U+0027 (APOSTROPHE)      |\n| `\\\\`            | U+005C (REVERSE SOLIDUS) |"
      }
    },
    {
      "id": "expr.literal.escape.hex-octet",
      "title": "8-bit escapes",
      "level": 3,
      "content": "The escape sequence consists of `\\x` followed by two hexadecimal digits.\n\nThe escaped value is the character whose [Unicode scalar value] is the result of interpreting the final two characters in the escape sequence as a hexadecimal integer, as if by [`u8::from_str_radix`] with radix 16.\n\n> [!NOTE]\n> The escaped value therefore has a [Unicode scalar value] in the range of `u8`.",
      "parent_id": null,
      "paragraphs": {
        "expr.literal.escape.hex-octet": "The escape sequence consists of `\\x` followed by two hexadecimal digits.\n\nThe escaped value is the character whose [Unicode scalar value] is the result of interpreting the final two characters in the escape sequence as a hexadecimal integer, as if by [`u8::from_str_radix`] with radix 16.\n\n> [!NOTE]\n> The escaped value therefore has a [Unicode scalar value] in the range of `u8`."
      }
    },
    {
      "id": "expr.literal.escape.hex-ascii",
      "title": "7-bit escapes",
      "level": 3,
      "content": "The escape sequence consists of `\\x` followed by an octal digit then a hexadecimal digit.\n\nThe escaped value is the character whose [Unicode scalar value] is the result of interpreting the final two characters in the escape sequence as a hexadecimal integer, as if by [`u8::from_str_radix`] with radix 16.",
      "parent_id": null,
      "paragraphs": {
        "expr.literal.escape.hex-ascii": "The escape sequence consists of `\\x` followed by an octal digit then a hexadecimal digit.\n\nThe escaped value is the character whose [Unicode scalar value] is the result of interpreting the final two characters in the escape sequence as a hexadecimal integer, as if by [`u8::from_str_radix`] with radix 16."
      }
    },
    {
      "id": "expr.literal.escape.unicode",
      "title": "Unicode escapes",
      "level": 3,
      "content": "The escape sequence consists of `\\u{`, followed by a sequence of characters each of which is a hexadecimal digit or `_`, followed by `}`.\n\nThe escaped value is the character whose [Unicode scalar value] is the result of interpreting the hexadecimal digits contained in the escape sequence as a hexadecimal integer, as if by [`u32::from_str_radix`] with radix 16.\n\n> [!NOTE]\n> The permitted forms of a [CHAR_LITERAL] or [STRING_LITERAL] token ensure that there is such a character.",
      "parent_id": null,
      "paragraphs": {
        "expr.literal.escape.unicode": "The escape sequence consists of `\\u{`, followed by a sequence of characters each of which is a hexadecimal digit or `_`, followed by `}`.\n\nThe escaped value is the character whose [Unicode scalar value] is the result of interpreting the hexadecimal digits contained in the escape sequence as a hexadecimal integer, as if by [`u32::from_str_radix`] with radix 16.\n\n> [!NOTE]\n> The permitted forms of a [CHAR_LITERAL] or [STRING_LITERAL] token ensure that there is such a character."
      }
    },
    {
      "id": "expr.literal.continuation",
      "title": "String continuation escapes",
      "level": 3,
      "content": "The escape sequence consists of `\\` followed immediately by `U+000A` (LF), and all following whitespace characters before the next non-whitespace character.\nFor this purpose, the whitespace characters are `U+0009` (HT), `U+000A` (LF), `U+000D` (CR), and `U+0020` (SPACE).\n\nThe escaped value is an empty sequence of characters.\n\n> [!NOTE]\n> The effect of this form of escape is that a string continuation skips following whitespace, including additional newlines. Thus `a`, `b` and `c` are equal:\n>\n> ```rust\n> let a = \"foobar\";\n> let b = \"foo\\\n>          bar\";\n> let c = \"foo\\\n>\n>      bar\";\n>\n> assert_eq!(a, b);\n> assert_eq!(b, c);\n> ```\n>\n> Skipping additional newlines (as in example c) is potentially confusing and unexpected. This behavior may be adjusted in the future. Until a decision is made, it is recommended to avoid relying on skipping multiple newlines with line continuations. See this issue for more information.",
      "parent_id": null,
      "paragraphs": {
        "expr.literal.continuation": "The escape sequence consists of `\\` followed immediately by `U+000A` (LF), and all following whitespace characters before the next non-whitespace character.\nFor this purpose, the whitespace characters are `U+0009` (HT), `U+000A` (LF), `U+000D` (CR), and `U+0020` (SPACE).\n\nThe escaped value is an empty sequence of characters.\n\n> [!NOTE]\n> The effect of this form of escape is that a string continuation skips following whitespace, including additional newlines. Thus `a`, `b` and `c` are equal:\n>\n> ```rust\n> let a = \"foobar\";\n> let b = \"foo\\\n>          bar\";\n> let c = \"foo\\\n>\n>      bar\";\n>\n> assert_eq!(a, b);\n> assert_eq!(b, c);\n> ```\n>\n> Skipping additional newlines (as in example c) is potentially confusing and unexpected. This behavior may be adjusted in the future. Until a decision is made, it is recommended to avoid relying on skipping multiple newlines with line continuations. See this issue for more information."
      }
    },
    {
      "id": "expr.literal.char",
      "title": "Character literal expressions",
      "level": 3,
      "content": "A character literal expression consists of a single [CHAR_LITERAL] token.\n\nThe expression's type is the primitive `char` type.\n\nThe token must not have a suffix.\n\nThe token's _literal content_ is the sequence of characters following the first `U+0027` (`'`) and preceding the last `U+0027` (`'`) in the string representation of the token.\n\nThe literal expression's _represented character_ is derived from the literal content as follows:\n\n* If the literal content is one of the following forms of escape sequence, the represented character is the escape sequence's escaped value:\n    * [Simple escapes]\n    * [7-bit escapes]\n    * [Unicode escapes]\n\n* Otherwise the represented character is the single character that makes up the literal content.\n\nThe expression's value is the `char` corresponding to the represented character's [Unicode scalar value].\n\n> [!NOTE]\n> The permitted forms of a [CHAR_LITERAL] token ensure that these rules always produce a single character.\n\nExamples of character literal expressions:\n\n'R';                               // R\n'\\'';                              // '\n'\\x52';                            // R\n'\\u{00E6}';                        // LATIN SMALL LETTER AE (U+00E6)",
      "parent_id": null,
      "paragraphs": {
        "expr.literal.char.intro": "A character literal expression consists of a single [CHAR_LITERAL] token.",
        "expr.literal.char.type": "The expression's type is the primitive `char` type.",
        "expr.literal.char.no-suffix": "The token must not have a suffix.",
        "expr.literal.char.literal-content": "The token's _literal content_ is the sequence of characters following the first `U+0027` (`'`) and preceding the last `U+0027` (`'`) in the string representation of the token.",
        "expr.literal.char.represented": "The literal expression's _represented character_ is derived from the literal content as follows:",
        "expr.literal.char.escape": "* If the literal content is one of the following forms of escape sequence, the represented character is the escape sequence's escaped value:\n    * [Simple escapes]\n    * [7-bit escapes]\n    * [Unicode escapes]",
        "expr.literal.char.single": "* Otherwise the represented character is the single character that makes up the literal content.",
        "expr.literal.char.result": "The expression's value is the `char` corresponding to the represented character's [Unicode scalar value].\n\n> [!NOTE]\n> The permitted forms of a [CHAR_LITERAL] token ensure that these rules always produce a single character.\n\nExamples of character literal expressions:\n\n'R';                               // R\n'\\'';                              // '\n'\\x52';                            // R\n'\\u{00E6}';                        // LATIN SMALL LETTER AE (U+00E6)"
      }
    },
    {
      "id": "expr.literal.string",
      "title": "String literal expressions",
      "level": 2,
      "content": "A string literal expression consists of a single [STRING_LITERAL] or [RAW_STRING_LITERAL] token.\n\nThe expression's type is a shared reference (with `static` lifetime) to the primitive `str` type.\nThat is, the type is `&'static str`.\n\nThe token must not have a suffix.\n\nThe token's _literal content_ is the sequence of characters following the first `U+0022` (`\"`) and preceding the last `U+0022` (`\"`) in the string representation of the token.\n\nThe literal expression's _represented string_ is a sequence of characters derived from the literal content as follows:\n\n* If the token is a [STRING_LITERAL], each escape sequence of any of the following forms occurring in the literal content is replaced by the escape sequence's escaped value.\n    * [Simple escapes]\n    * [7-bit escapes]\n    * [Unicode escapes]\n    * [String continuation escapes]\n\n  These replacements take place in left-to-right order.\n  For example, the token `\"\\\\x41\"` is converted to the characters `\\` `x` `4` `1`.\n\n* If the token is a [RAW_STRING_LITERAL], the represented string is identical to the literal content.\n\nThe expression's value is a reference to a statically allocated `str` containing the UTF-8 encoding of the represented string.\n\nExamples of string literal expressions:\n\n\"foo\"; r\"foo\";                     // foo\n\"\\\"foo\\\"\"; r#\"\"foo\"\"#;             // \"foo\"\n\n\"foo #\\\"# bar\";\nr##\"foo #\"# bar\"##;                // foo #\"# bar\n\n\"\\x52\"; \"R\"; r\"R\";                 // R\n\"\\\\x52\"; r\"\\x52\";                  // \\x52",
      "parent_id": null,
      "paragraphs": {
        "expr.literal.string.intro": "A string literal expression consists of a single [STRING_LITERAL] or [RAW_STRING_LITERAL] token.",
        "expr.literal.string.type": "The expression's type is a shared reference (with `static` lifetime) to the primitive `str` type.\nThat is, the type is `&'static str`.",
        "expr.literal.string.no-suffix": "The token must not have a suffix.",
        "expr.literal.string.literal-content": "The token's _literal content_ is the sequence of characters following the first `U+0022` (`\"`) and preceding the last `U+0022` (`\"`) in the string representation of the token.",
        "expr.literal.string.represented": "The literal expression's _represented string_ is a sequence of characters derived from the literal content as follows:",
        "expr.literal.string.escape": "* If the token is a [STRING_LITERAL], each escape sequence of any of the following forms occurring in the literal content is replaced by the escape sequence's escaped value.\n    * [Simple escapes]\n    * [7-bit escapes]\n    * [Unicode escapes]\n    * [String continuation escapes]\n\n  These replacements take place in left-to-right order.\n  For example, the token `\"\\\\x41\"` is converted to the characters `\\` `x` `4` `1`.",
        "expr.literal.string.raw": "* If the token is a [RAW_STRING_LITERAL], the represented string is identical to the literal content.",
        "expr.literal.string.result": "The expression's value is a reference to a statically allocated `str` containing the UTF-8 encoding of the represented string.\n\nExamples of string literal expressions:\n\n\"foo\"; r\"foo\";                     // foo\n\"\\\"foo\\\"\"; r#\"\"foo\"\"#;             // \"foo\"\n\n\"foo #\\\"# bar\";\nr##\"foo #\"# bar\"##;                // foo #\"# bar\n\n\"\\x52\"; \"R\"; r\"R\";                 // R\n\"\\\\x52\"; r\"\\x52\";                  // \\x52"
      }
    },
    {
      "id": "expr.literal.byte-char",
      "title": "Byte literal expressions",
      "level": 2,
      "content": "A byte literal expression consists of a single [BYTE_LITERAL] token.\n\nThe expression's type is the primitive `u8` type.\n\nThe token must not have a suffix.\n\nThe token's _literal content_ is the sequence of characters following the first `U+0027` (`'`) and preceding the last `U+0027` (`'`) in the string representation of the token.\n\nThe literal expression's _represented character_ is derived from the literal content as follows:\n\n* If the literal content is one of the following forms of escape sequence, the represented character is the escape sequence's escaped value:\n    * [Simple escapes]\n    * [8-bit escapes]\n\n* Otherwise the represented character is the single character that makes up the literal content.\n\nThe expression's value is the represented character's [Unicode scalar value].\n\n> [!NOTE]\n> The permitted forms of a [BYTE_LITERAL] token ensure that these rules always produce a single character, whose Unicode scalar value is in the range of `u8`.\n\nExamples of byte literal expressions:\n\nb'R';                              // 82\nb'\\'';                             // 39\nb'\\x52';                           // 82\nb'\\xA0';                           // 160",
      "parent_id": null,
      "paragraphs": {
        "expr.literal.byte-char.intro": "A byte literal expression consists of a single [BYTE_LITERAL] token.",
        "expr.literal.byte-char.literal": "The expression's type is the primitive `u8` type.",
        "expr.literal.byte-char.no-suffix": "The token must not have a suffix.",
        "expr.literal.byte-char.literal-content": "The token's _literal content_ is the sequence of characters following the first `U+0027` (`'`) and preceding the last `U+0027` (`'`) in the string representation of the token.",
        "expr.literal.byte-char.represented": "The literal expression's _represented character_ is derived from the literal content as follows:",
        "expr.literal.byte-char.escape": "* If the literal content is one of the following forms of escape sequence, the represented character is the escape sequence's escaped value:\n    * [Simple escapes]\n    * [8-bit escapes]",
        "expr.literal.byte-char.single": "* Otherwise the represented character is the single character that makes up the literal content.",
        "expr.literal.byte-char.result": "The expression's value is the represented character's [Unicode scalar value].\n\n> [!NOTE]\n> The permitted forms of a [BYTE_LITERAL] token ensure that these rules always produce a single character, whose Unicode scalar value is in the range of `u8`.\n\nExamples of byte literal expressions:\n\nb'R';                              // 82\nb'\\'';                             // 39\nb'\\x52';                           // 82\nb'\\xA0';                           // 160"
      }
    },
    {
      "id": "expr.literal.byte-string",
      "title": "Byte string literal expressions",
      "level": 2,
      "content": "A byte string literal expression consists of a single [BYTE_STRING_LITERAL] or [RAW_BYTE_STRING_LITERAL] token.\n\nThe expression's type is a shared reference (with `static` lifetime) to an array whose element type is `u8`.\nThat is, the type is `&'static [u8; N]`, where `N` is the number of bytes in the represented string described below.\n\nThe token must not have a suffix.\n\nThe token's _literal content_ is the sequence of characters following the first `U+0022` (`\"`) and preceding the last `U+0022` (`\"`) in the string representation of the token.\n\nThe literal expression's _represented string_ is a sequence of characters derived from the literal content as follows:\n\n* If the token is a [BYTE_STRING_LITERAL], each escape sequence of any of the following forms occurring in the literal content is replaced by the escape sequence's escaped value.\n    * [Simple escapes]\n    * [8-bit escapes]\n    * [String continuation escapes]\n\n  These replacements take place in left-to-right order.\n  For example, the token `b\"\\\\x41\"` is converted to the characters `\\` `x` `4` `1`.\n\n* If the token is a [RAW_BYTE_STRING_LITERAL], the represented string is identical to the literal content.\n\nThe expression's value is a reference to a statically allocated array containing the [Unicode scalar values] of the characters in the represented string, in the same order.\n\n> [!NOTE]\n> The permitted forms of [BYTE_STRING_LITERAL] and [RAW_BYTE_STRING_LITERAL] tokens ensure that these rules always produce array element values in the range of `u8`.\n\nExamples of byte string literal expressions:\n\nb\"foo\"; br\"foo\";                     // foo\nb\"\\\"foo\\\"\"; br#\"\"foo\"\"#;             // \"foo\"\n\nb\"foo #\\\"# bar\";\nbr##\"foo #\"# bar\"##;                 // foo #\"# bar\n\nb\"\\x52\"; b\"R\"; br\"R\";                // R\nb\"\\\\x52\"; br\"\\x52\";                  // \\x52",
      "parent_id": null,
      "paragraphs": {
        "expr.literal.byte-string.intro": "A byte string literal expression consists of a single [BYTE_STRING_LITERAL] or [RAW_BYTE_STRING_LITERAL] token.",
        "expr.literal.byte-string.type": "The expression's type is a shared reference (with `static` lifetime) to an array whose element type is `u8`.\nThat is, the type is `&'static [u8; N]`, where `N` is the number of bytes in the represented string described below.",
        "expr.literal.byte-string.no-suffix": "The token must not have a suffix.",
        "expr.literal.byte-string.literal-content": "The token's _literal content_ is the sequence of characters following the first `U+0022` (`\"`) and preceding the last `U+0022` (`\"`) in the string representation of the token.",
        "expr.literal.byte-string.represented": "The literal expression's _represented string_ is a sequence of characters derived from the literal content as follows:",
        "expr.literal.byte-string.escape": "* If the token is a [BYTE_STRING_LITERAL], each escape sequence of any of the following forms occurring in the literal content is replaced by the escape sequence's escaped value.\n    * [Simple escapes]\n    * [8-bit escapes]\n    * [String continuation escapes]\n\n  These replacements take place in left-to-right order.\n  For example, the token `b\"\\\\x41\"` is converted to the characters `\\` `x` `4` `1`.",
        "expr.literal.byte-string.raw": "* If the token is a [RAW_BYTE_STRING_LITERAL], the represented string is identical to the literal content.",
        "expr.literal.byte-string.result": "The expression's value is a reference to a statically allocated array containing the [Unicode scalar values] of the characters in the represented string, in the same order.\n\n> [!NOTE]\n> The permitted forms of [BYTE_STRING_LITERAL] and [RAW_BYTE_STRING_LITERAL] tokens ensure that these rules always produce array element values in the range of `u8`.\n\nExamples of byte string literal expressions:\n\nb\"foo\"; br\"foo\";                     // foo\nb\"\\\"foo\\\"\"; br#\"\"foo\"\"#;             // \"foo\"\n\nb\"foo #\\\"# bar\";\nbr##\"foo #\"# bar\"##;                 // foo #\"# bar\n\nb\"\\x52\"; b\"R\"; br\"R\";                // R\nb\"\\\\x52\"; br\"\\x52\";                  // \\x52"
      }
    },
    {
      "id": "expr.literal.c-string",
      "title": "C string literal expressions",
      "level": 2,
      "content": "A C string literal expression consists of a single [C_STRING_LITERAL] or [RAW_C_STRING_LITERAL] token.\n\nThe expression's type is a shared reference (with `static` lifetime) to the standard library [CStr] type.\nThat is, the type is `&'static core::ffi::CStr`.\n\nThe token must not have a suffix.\n\nThe token's _literal content_ is the sequence of characters following the first `\"` and preceding the last `\"` in the string representation of the token.\n\nThe literal expression's _represented bytes_ are a sequence of bytes derived from the literal content as follows:\n\n* If the token is a [C_STRING_LITERAL], the literal content is treated as a sequence of items, each of which is either a single Unicode character other than `\\` or an [escape].\nThe sequence of items is converted to a sequence of bytes as follows:\n  * Each single Unicode character contributes its UTF-8 representation.\n  * Each [simple escape] contributes the [Unicode scalar value] of its escaped value.\n  * Each [8-bit escape] contributes a single byte containing the [Unicode scalar value] of its escaped value.\n  * Each [unicode escape] contributes the UTF-8 representation of its escaped value.\n  * Each [string continuation escape] contributes no bytes.\n\n* If the token is a [RAW_C_STRING_LITERAL], the represented bytes are the UTF-8 encoding of the literal content.\n\n> [!NOTE]\n> The permitted forms of [C_STRING_LITERAL] and [RAW_C_STRING_LITERAL] tokens ensure that the represented bytes never include a null byte.\n\nThe expression's value is a reference to a statically allocated [CStr] whose array of bytes contains the represented bytes followed by a null byte.\n\nExamples of C string literal expressions:\n\nc\"foo\"; cr\"foo\";                     // foo\nc\"\\\"foo\\\"\"; cr#\"\"foo\"\"#;             // \"foo\"\n\nc\"foo #\\\"# bar\";\ncr##\"foo #\"# bar\"##;                 // foo #\"# bar\n\nc\"\\x52\"; c\"R\"; cr\"R\";                // R\nc\"\\\\x52\"; cr\"\\x52\";                  // \\x52\n\nc\"\u00e6\";                                // LATIN SMALL LETTER AE (U+00E6)\nc\"\\u{00E6}\";                         // LATIN SMALL LETTER AE (U+00E6)\nc\"\\xC3\\xA6\";                         // LATIN SMALL LETTER AE (U+00E6)\n\nc\"\\xE6\".to_bytes();                  // [230]\nc\"\\u{00E6}\".to_bytes();              // [195, 166]",
      "parent_id": null,
      "paragraphs": {
        "expr.literal.c-string.intro": "A C string literal expression consists of a single [C_STRING_LITERAL] or [RAW_C_STRING_LITERAL] token.",
        "expr.literal.c-string.type": "The expression's type is a shared reference (with `static` lifetime) to the standard library [CStr] type.\nThat is, the type is `&'static core::ffi::CStr`.",
        "expr.literal.c-string.no-suffix": "The token must not have a suffix.",
        "expr.literal.c-string.literal-content": "The token's _literal content_ is the sequence of characters following the first `\"` and preceding the last `\"` in the string representation of the token.",
        "expr.literal.c-string.represented": "The literal expression's _represented bytes_ are a sequence of bytes derived from the literal content as follows:",
        "expr.literal.c-string.escape": "* If the token is a [C_STRING_LITERAL], the literal content is treated as a sequence of items, each of which is either a single Unicode character other than `\\` or an [escape].\nThe sequence of items is converted to a sequence of bytes as follows:\n  * Each single Unicode character contributes its UTF-8 representation.\n  * Each [simple escape] contributes the [Unicode scalar value] of its escaped value.\n  * Each [8-bit escape] contributes a single byte containing the [Unicode scalar value] of its escaped value.\n  * Each [unicode escape] contributes the UTF-8 representation of its escaped value.\n  * Each [string continuation escape] contributes no bytes.",
        "expr.literal.c-string.raw": "* If the token is a [RAW_C_STRING_LITERAL], the represented bytes are the UTF-8 encoding of the literal content.\n\n> [!NOTE]\n> The permitted forms of [C_STRING_LITERAL] and [RAW_C_STRING_LITERAL] tokens ensure that the represented bytes never include a null byte.",
        "expr.literal.c-string.result": "The expression's value is a reference to a statically allocated [CStr] whose array of bytes contains the represented bytes followed by a null byte.\n\nExamples of C string literal expressions:\n\nc\"foo\"; cr\"foo\";                     // foo\nc\"\\\"foo\\\"\"; cr#\"\"foo\"\"#;             // \"foo\"\n\nc\"foo #\\\"# bar\";\ncr##\"foo #\"# bar\"##;                 // foo #\"# bar\n\nc\"\\x52\"; c\"R\"; cr\"R\";                // R\nc\"\\\\x52\"; cr\"\\x52\";                  // \\x52\n\nc\"\u00e6\";                                // LATIN SMALL LETTER AE (U+00E6)\nc\"\\u{00E6}\";                         // LATIN SMALL LETTER AE (U+00E6)\nc\"\\xC3\\xA6\";                         // LATIN SMALL LETTER AE (U+00E6)\n\nc\"\\xE6\".to_bytes();                  // [230]\nc\"\\u{00E6}\".to_bytes();              // [195, 166]"
      }
    },
    {
      "id": "expr.literal.int",
      "title": "Integer literal expressions",
      "level": 2,
      "content": "An integer literal expression consists of a single [INTEGER_LITERAL] token.\n\nIf the token has a [suffix], the suffix must be the name of one of the primitive integer types: `u8`, `i8`, `u16`, `i16`, `u32`, `i32`, `u64`, `i64`, `u128`, `i128`, `usize`, or `isize`, and the expression has that type.\n\nIf the token has no suffix, the expression's type is determined by type inference:\n\n* If an integer type can be _uniquely_ determined from the surrounding program context, the expression has that type.\n\n* If the program context under-constrains the type, it defaults to the signed 32-bit integer `i32`.\n\n* If the program context over-constrains the type, it is considered a static type error.\n\nExamples of integer literal expressions:\n\n123;                               // type i32\n123i32;                            // type i32\n123u32;                            // type u32\n123_u32;                           // type u32\nlet a: u64 = 123;                  // type u64\n\n0xff;                              // type i32\n0xff_u8;                           // type u8\n\n0o70;                              // type i32\n0o70_i16;                          // type i16\n\n0b1111_1111_1001_0000;             // type i32\n0b1111_1111_1001_0000i64;          // type i64\n\n0usize;                            // type usize\n\nThe value of the expression is determined from the string representation of the token as follows:\n\n* An integer radix is chosen by inspecting the first two characters of the string, as follows:\n\n    * `0b` indicates radix 2\n    * `0o` indicates radix 8\n    * `0x` indicates radix 16\n    * otherwise the radix is 10.\n\n* If the radix is not 10, the first two characters are removed from the string.\n\n* Any suffix is removed from the string.\n\n* Any underscores are removed from the string.\n\n* The string is converted to a `u128` value as if by [`u128::from_str_radix`] with the chosen radix.\nIf the value does not fit in `u128`, it is a compiler error.\n\n* The `u128` value is converted to the expression's type via a [numeric cast].\n\n> [!NOTE]\n> The final cast will truncate the value of the literal if it does not fit in the expression's type. `rustc` includes a [lint check] named `overflowing_literals`, defaulting to `deny`, which rejects expressions where this occurs.\n\n> [!NOTE]\n> `-1i8`, for example, is an application of the [negation operator] to the literal expression `1i8`, not a single integer literal expression. See [Overflow] for notes on representing the most negative value for a signed type.",
      "parent_id": null,
      "paragraphs": {
        "expr.literal.int.intro": "An integer literal expression consists of a single [INTEGER_LITERAL] token.",
        "expr.literal.int.suffix": "If the token has a [suffix], the suffix must be the name of one of the primitive integer types: `u8`, `i8`, `u16`, `i16`, `u32`, `i32`, `u64`, `i64`, `u128`, `i128`, `usize`, or `isize`, and the expression has that type.",
        "expr.literal.int.infer": "If the token has no suffix, the expression's type is determined by type inference:",
        "expr.literal.int.inference-unique-type": "* If an integer type can be _uniquely_ determined from the surrounding program context, the expression has that type.",
        "expr.literal.int.inference-default": "* If the program context under-constrains the type, it defaults to the signed 32-bit integer `i32`.",
        "expr.literal.int.inference-error": "* If the program context over-constrains the type, it is considered a static type error.\n\nExamples of integer literal expressions:\n\n123;                               // type i32\n123i32;                            // type i32\n123u32;                            // type u32\n123_u32;                           // type u32\nlet a: u64 = 123;                  // type u64\n\n0xff;                              // type i32\n0xff_u8;                           // type u8\n\n0o70;                              // type i32\n0o70_i16;                          // type i16\n\n0b1111_1111_1001_0000;             // type i32\n0b1111_1111_1001_0000i64;          // type i64\n\n0usize;                            // type usize",
        "expr.literal.int.representation": "The value of the expression is determined from the string representation of the token as follows:",
        "expr.literal.int.radix": "* An integer radix is chosen by inspecting the first two characters of the string, as follows:\n\n    * `0b` indicates radix 2\n    * `0o` indicates radix 8\n    * `0x` indicates radix 16\n    * otherwise the radix is 10.",
        "expr.literal.int.radix-prefix-stripped": "* If the radix is not 10, the first two characters are removed from the string.",
        "expr.literal.int.type-suffix-stripped": "* Any suffix is removed from the string.",
        "expr.literal.int.separators-stripped": "* Any underscores are removed from the string.",
        "expr.literal.int.u128-value": "* The string is converted to a `u128` value as if by [`u128::from_str_radix`] with the chosen radix.\nIf the value does not fit in `u128`, it is a compiler error.",
        "expr.literal.int.cast": "* The `u128` value is converted to the expression's type via a [numeric cast].\n\n> [!NOTE]\n> The final cast will truncate the value of the literal if it does not fit in the expression's type. `rustc` includes a [lint check] named `overflowing_literals`, defaulting to `deny`, which rejects expressions where this occurs.\n\n> [!NOTE]\n> `-1i8`, for example, is an application of the [negation operator] to the literal expression `1i8`, not a single integer literal expression. See [Overflow] for notes on representing the most negative value for a signed type."
      }
    },
    {
      "id": "expr.literal.float",
      "title": "Floating-point literal expressions",
      "level": 2,
      "content": "A floating-point literal expression has one of two forms:\n * a single [FLOAT_LITERAL] token\n * a single [INTEGER_LITERAL] token which has a suffix and no radix indicator\n\nIf the token has a [suffix], the suffix must be the name of one of the primitive floating-point types: `f32` or `f64`, and the expression has that type.\n\nIf the token has no suffix, the expression's type is determined by type inference:\n\n* If a floating-point type can be _uniquely_ determined from the surrounding program context, the expression has that type.\n\n* If the program context under-constrains the type, it defaults to `f64`.\n\n* If the program context over-constrains the type, it is considered a static type error.\n\nExamples of floating-point literal expressions:\n\n123.0f64;        // type f64\n0.1f64;          // type f64\n0.1f32;          // type f32\n12E+99_f64;      // type f64\n5f32;            // type f32\nlet x: f64 = 2.; // type f64\n\nThe value of the expression is determined from the string representation of the token as follows:\n\n* Any suffix is removed from the string.\n\n* Any underscores are removed from the string.\n\n* The string is converted to the expression's type as if by [`f32::from_str`] or [`f64::from_str`].\n\n> [!NOTE]\n> `-1.0`, for example, is an application of the [negation operator] to the literal expression `1.0`, not a single floating-point literal expression.\n\n> [!NOTE]\n> `inf` and `NaN` are not literal tokens. The [`f32::INFINITY`], [`f64::INFINITY`], [`f32::NAN`], and [`f64::NAN`] constants can be used instead of literal expressions. In `rustc`, a literal large enough to be evaluated as infinite will trigger the `overflowing_literals` lint check.",
      "parent_id": null,
      "paragraphs": {
        "expr.literal.float.intro": "A floating-point literal expression has one of two forms:\n * a single [FLOAT_LITERAL] token\n * a single [INTEGER_LITERAL] token which has a suffix and no radix indicator",
        "expr.literal.float.suffix": "If the token has a [suffix], the suffix must be the name of one of the primitive floating-point types: `f32` or `f64`, and the expression has that type.",
        "expr.literal.float.infer": "If the token has no suffix, the expression's type is determined by type inference:",
        "expr.literal.float.inference-unique-type": "* If a floating-point type can be _uniquely_ determined from the surrounding program context, the expression has that type.",
        "expr.literal.float.inference-default": "* If the program context under-constrains the type, it defaults to `f64`.",
        "expr.literal.float.inference-error": "* If the program context over-constrains the type, it is considered a static type error.\n\nExamples of floating-point literal expressions:\n\n123.0f64;        // type f64\n0.1f64;          // type f64\n0.1f32;          // type f32\n12E+99_f64;      // type f64\n5f32;            // type f32\nlet x: f64 = 2.; // type f64",
        "expr.literal.float.result": "The value of the expression is determined from the string representation of the token as follows:",
        "expr.literal.float.type-suffix-stripped": "* Any suffix is removed from the string.",
        "expr.literal.float.separators-stripped": "* Any underscores are removed from the string.",
        "expr.literal.float.value": "* The string is converted to the expression's type as if by [`f32::from_str`] or [`f64::from_str`].\n\n> [!NOTE]\n> `-1.0`, for example, is an application of the [negation operator] to the literal expression `1.0`, not a single floating-point literal expression.\n\n> [!NOTE]\n> `inf` and `NaN` are not literal tokens. The [`f32::INFINITY`], [`f64::INFINITY`], [`f32::NAN`], and [`f64::NAN`] constants can be used instead of literal expressions. In `rustc`, a literal large enough to be evaluated as infinite will trigger the `overflowing_literals` lint check."
      }
    },
    {
      "id": "expr.literal.bool",
      "title": "Boolean literal expressions",
      "level": 2,
      "content": "A boolean literal expression consists of one of the keywords `true` or `false`.\n\nThe expression's type is the primitive [boolean type], and its value is:\n * true if the keyword is `true`\n * false if the keyword is `false`\n\n[boolean type]: ../types/boolean.md\n[constant expression]: ../const_eval.md#constant-expressions\n[CStr]: core::ffi::CStr\n[floating-point types]: ../types/numeric.md#floating-point-types\n[lint check]: ../attributes/diagnostics.md#lint-check-attributes\n[literal tokens]: ../tokens.md#literals\n[numeric cast]: operator-expr.md#numeric-cast\n[numeric types]: ../types/numeric.md\n[suffix]: ../tokens.md#suffixes\n[negation operator]: operator-expr.md#negation-operators\n[overflow]: operator-expr.md#overflow\n[textual types]: ../types/textual.md\n[Unicode scalar value]: http://www.unicode.org/glossary/#unicode_scalar_value\n[Unicode scalar values]: http://www.unicode.org/glossary/#unicode_scalar_value\n[`f32::from_str`]: ../../core/primitive.f32.md#method.from_str\n[`f64::from_str`]: ../../core/primitive.f64.md#method.from_str",
      "parent_id": null,
      "paragraphs": {
        "expr.literal.bool.intro": "A boolean literal expression consists of one of the keywords `true` or `false`.",
        "expr.literal.bool.result": "The expression's type is the primitive [boolean type], and its value is:\n * true if the keyword is `true`\n * false if the keyword is `false`\n\n[boolean type]: ../types/boolean.md\n[constant expression]: ../const_eval.md#constant-expressions\n[CStr]: core::ffi::CStr\n[floating-point types]: ../types/numeric.md#floating-point-types\n[lint check]: ../attributes/diagnostics.md#lint-check-attributes\n[literal tokens]: ../tokens.md#literals\n[numeric cast]: operator-expr.md#numeric-cast\n[numeric types]: ../types/numeric.md\n[suffix]: ../tokens.md#suffixes\n[negation operator]: operator-expr.md#negation-operators\n[overflow]: operator-expr.md#overflow\n[textual types]: ../types/textual.md\n[Unicode scalar value]: http://www.unicode.org/glossary/#unicode_scalar_value\n[Unicode scalar values]: http://www.unicode.org/glossary/#unicode_scalar_value\n[`f32::from_str`]: ../../core/primitive.f32.md#method.from_str\n[`f64::from_str`]: ../../core/primitive.f64.md#method.from_str"
      }
    },
    {
      "id": "expr.path",
      "title": "Path expressions",
      "level": 1,
      "content": ",expressions\nPathExpression ->\n      PathInExpression\n    | QualifiedPathInExpression\n\nA [path] used as an expression context denotes either a local variable or an item.\n\nPath expressions that resolve to local or static variables are [place expressions]; other paths are [value expressions].\n\nUsing a [`static mut`] variable requires an [`unsafe` block].\n\n# mod globals {\n#     pub static STATIC_VAR: i32 = 5;\n#     pub static mut STATIC_MUT_VAR: i32 = 7;\n# }\n# let local_var = 3;\nlocal_var;\nglobals::STATIC_VAR;\nunsafe { globals::STATIC_MUT_VAR };\nlet some_constructor = Some::<i32>;\nlet push_integer = Vec::<i32>::push;\nlet slice_reverse = <[i32]>::reverse;\n\nEvaluation of associated constants is handled the same way as [`const` blocks].\n\n[place expressions]: ../expressions.md#place-expressions-and-value-expressions\n[value expressions]: ../expressions.md#place-expressions-and-value-expressions\n[path]: ../paths.md\n[`static mut`]: ../items/static-items.md#mutable-statics\n[`unsafe` block]: block-expr.md#unsafe-blocks\n[`const` blocks]: block-expr.md#const-blocks",
      "parent_id": null,
      "paragraphs": {
        "expr.path.syntax": ",expressions\nPathExpression ->\n      PathInExpression\n    | QualifiedPathInExpression",
        "expr.path.intro": "A [path] used as an expression context denotes either a local variable or an item.",
        "expr.path.place": "Path expressions that resolve to local or static variables are [place expressions]; other paths are [value expressions].",
        "expr.path.safety": "Using a [`static mut`] variable requires an [`unsafe` block].\n\n# mod globals {\n#     pub static STATIC_VAR: i32 = 5;\n#     pub static mut STATIC_MUT_VAR: i32 = 7;\n# }\n# let local_var = 3;\nlocal_var;\nglobals::STATIC_VAR;\nunsafe { globals::STATIC_MUT_VAR };\nlet some_constructor = Some::<i32>;\nlet push_integer = Vec::<i32>::push;\nlet slice_reverse = <[i32]>::reverse;",
        "expr.path.const": "Evaluation of associated constants is handled the same way as [`const` blocks].\n\n[place expressions]: ../expressions.md#place-expressions-and-value-expressions\n[value expressions]: ../expressions.md#place-expressions-and-value-expressions\n[path]: ../paths.md\n[`static mut`]: ../items/static-items.md#mutable-statics\n[`unsafe` block]: block-expr.md#unsafe-blocks\n[`const` blocks]: block-expr.md#const-blocks"
      }
    },
    {
      "id": "expr.block",
      "title": "Block expressions",
      "level": 1,
      "content": ",expressions\nBlockExpression ->\n    `{`\n        InnerAttribute*\n        Statements?\n    `}`\n\nStatements ->\n      Statement+\n    | Statement+ ExpressionWithoutBlock\n    | ExpressionWithoutBlock\n\nA *block expression*, or *block*, is a control flow expression and anonymous namespace scope for items and variable declarations.\n\nAs a control flow expression, a block sequentially executes its component non-item declaration statements and then its final optional expression.\n\nAs an anonymous namespace scope, item declarations are only in scope inside the block itself and variables declared by `let` statements are in scope from the next statement until the end of the block.\nSee the [scopes] chapter for more details.\n\nThe syntax for a block is `{`, then any [inner attributes], then any number of [statements], then an optional expression, called the final operand, and finally a `}`.\n\nStatements are usually required to be followed by a semicolon, with two exceptions:\n\n1. Item declaration statements do not need to be followed by a semicolon.\n2. Expression statements usually require a following semicolon except if its outer expression is a flow control expression.\n\nFurthermore, extra semicolons between statements are allowed, but these semicolons do not affect semantics.\n\nWhen evaluating a block expression, each statement, except for item declaration statements, is executed sequentially.\n\nThen the final operand is executed, if given.\n\nThe type of a block is the type of the final operand, or `()` if the final operand is omitted.\n\n# fn fn_call() {}\nlet _: () = {\n    fn_call();\n};\n\nlet five: i32 = {\n    fn_call();\n    5\n};\n\nassert_eq!(5, five);\n\n> [!NOTE]\n> As a control flow expression, if a block expression is the outer expression of an expression statement, the expected type is `()` unless it is followed immediately by a semicolon.\n\nBlocks are always [value expressions] and evaluate the last operand in value expression context.\n\n> [!NOTE]\n> This can be used to force moving a value if really needed. For example, the following example fails on the call to `consume_self` because the struct was moved out of `s` in the block expression.\n>\n> ```rust,compile_fail\n> struct Struct;\n>\n> impl Struct {\n>     fn consume_self(self) {}\n>     fn borrow_self(&self) {}\n> }\n>\n> fn move_by_block_expression() {\n>     let s = Struct;\n>\n>     // Move the value out of `s` in the block expression.\n>     (&{ s }).borrow_self();\n>\n>     // Fails to execute because `s` is moved out of.\n>     s.consume_self();\n> }\n> ```",
      "parent_id": null,
      "paragraphs": {
        "expr.block.syntax": ",expressions\nBlockExpression ->\n    `{`\n        InnerAttribute*\n        Statements?\n    `}`\n\nStatements ->\n      Statement+\n    | Statement+ ExpressionWithoutBlock\n    | ExpressionWithoutBlock",
        "expr.block.intro": "A *block expression*, or *block*, is a control flow expression and anonymous namespace scope for items and variable declarations.",
        "expr.block.sequential-evaluation": "As a control flow expression, a block sequentially executes its component non-item declaration statements and then its final optional expression.",
        "expr.block.namespace": "As an anonymous namespace scope, item declarations are only in scope inside the block itself and variables declared by `let` statements are in scope from the next statement until the end of the block.\nSee the [scopes] chapter for more details.",
        "expr.block.inner-attributes": "The syntax for a block is `{`, then any [inner attributes], then any number of [statements], then an optional expression, called the final operand, and finally a `}`.",
        "expr.block.statements": "Statements are usually required to be followed by a semicolon, with two exceptions:\n\n1. Item declaration statements do not need to be followed by a semicolon.\n2. Expression statements usually require a following semicolon except if its outer expression is a flow control expression.",
        "expr.block.null-statement": "Furthermore, extra semicolons between statements are allowed, but these semicolons do not affect semantics.",
        "expr.block.evaluation": "When evaluating a block expression, each statement, except for item declaration statements, is executed sequentially.",
        "expr.block.result": "Then the final operand is executed, if given.",
        "expr.block.type": "The type of a block is the type of the final operand, or `()` if the final operand is omitted.\n\n# fn fn_call() {}\nlet _: () = {\n    fn_call();\n};\n\nlet five: i32 = {\n    fn_call();\n    5\n};\n\nassert_eq!(5, five);\n\n> [!NOTE]\n> As a control flow expression, if a block expression is the outer expression of an expression statement, the expected type is `()` unless it is followed immediately by a semicolon.",
        "expr.block.value": "Blocks are always [value expressions] and evaluate the last operand in value expression context.\n\n> [!NOTE]\n> This can be used to force moving a value if really needed. For example, the following example fails on the call to `consume_self` because the struct was moved out of `s` in the block expression.\n>\n> ```rust,compile_fail\n> struct Struct;\n>\n> impl Struct {\n>     fn consume_self(self) {}\n>     fn borrow_self(&self) {}\n> }\n>\n> fn move_by_block_expression() {\n>     let s = Struct;\n>\n>     // Move the value out of `s` in the block expression.\n>     (&{ s }).borrow_self();\n>\n>     // Fails to execute because `s` is moved out of.\n>     s.consume_self();\n> }\n> ```"
      }
    },
    {
      "id": "expr.block.async",
      "title": "`async` blocks",
      "level": 1,
      "content": ",expressions\nAsyncBlockExpression -> `async` `move`? BlockExpression\n\nAn *async block* is a variant of a block expression which evaluates to a future.\n\nThe final expression of the block, if present, determines the result value of the future.\n\nExecuting an async block is similar to executing a closure expression:\nits immediate effect is to produce and return an anonymous type.\n\nWhereas closures return a type that implements one or more of the [`std::ops::Fn`] traits, however, the type returned for an async block implements the [`std::future::Future`] trait.\n\nThe actual data format for this type is unspecified.\n\n> [!NOTE]\n> The future type that rustc generates is roughly equivalent to an enum with one variant per `await` point, where each variant stores the data needed to resume from its corresponding point.\n\n> [!EDITION-2018]\n> Async blocks are only available beginning with Rust 2018.",
      "parent_id": null,
      "paragraphs": {
        "expr.block.async.syntax": ",expressions\nAsyncBlockExpression -> `async` `move`? BlockExpression",
        "expr.block.async.intro": "An *async block* is a variant of a block expression which evaluates to a future.",
        "expr.block.async.future-result": "The final expression of the block, if present, determines the result value of the future.",
        "expr.block.async.anonymous-type": "Executing an async block is similar to executing a closure expression:\nits immediate effect is to produce and return an anonymous type.",
        "expr.block.async.future": "Whereas closures return a type that implements one or more of the [`std::ops::Fn`] traits, however, the type returned for an async block implements the [`std::future::Future`] trait.",
        "expr.block.async.layout-unspecified": "The actual data format for this type is unspecified.\n\n> [!NOTE]\n> The future type that rustc generates is roughly equivalent to an enum with one variant per `await` point, where each variant stores the data needed to resume from its corresponding point.",
        "expr.block.async.edition2018": "> [!EDITION-2018]\n> Async blocks are only available beginning with Rust 2018."
      }
    },
    {
      "id": "expr.block.async.capture",
      "title": "Capture modes",
      "level": 2,
      "content": "Async blocks capture variables from their environment using the same [capture modes] as closures.\nLike closures, when written `async { .. }` the capture mode for each variable will be inferred from the content of the block.\n`async move { .. }` blocks however will move all referenced variables into the resulting future.",
      "parent_id": null,
      "paragraphs": {
        "expr.block.async.capture": "Async blocks capture variables from their environment using the same [capture modes] as closures.\nLike closures, when written `async { .. }` the capture mode for each variable will be inferred from the content of the block.\n`async move { .. }` blocks however will move all referenced variables into the resulting future."
      }
    },
    {
      "id": "expr.block.async.context",
      "title": "Async context",
      "level": 3,
      "content": "Because async blocks construct a future, they define an **async context** which can in turn contain [`await` expressions].\nAsync contexts are established by async blocks as well as the bodies of async functions, whose semantics are defined in terms of async blocks.",
      "parent_id": null,
      "paragraphs": {
        "expr.block.async.context": "Because async blocks construct a future, they define an **async context** which can in turn contain [`await` expressions].\nAsync contexts are established by async blocks as well as the bodies of async functions, whose semantics are defined in terms of async blocks."
      }
    },
    {
      "id": "expr.block.async.function",
      "title": "Control-flow operators",
      "level": 3,
      "content": "Async blocks act like a function boundary, much like closures.\n\nTherefore, the `?` operator and `return` expressions both affect the output of the future, not the enclosing function or other context.\nThat is, `return <expr>` from within an async block will return the result of `<expr>` as the output of the future.\nSimilarly, if `<expr>?` propagates an error, that error is propagated as the result of the future.\n\nFinally, the `break` and `continue` keywords cannot be used to branch out from an async block.\nTherefore the following is illegal:\n\n,compile_fail\nloop {\n    async move {\n        break; // error[E0267]: `break` inside of an `async` block\n    }\n}",
      "parent_id": null,
      "paragraphs": {
        "expr.block.async.function.intro": "Async blocks act like a function boundary, much like closures.",
        "expr.block.async.function.return-try": "Therefore, the `?` operator and `return` expressions both affect the output of the future, not the enclosing function or other context.\nThat is, `return <expr>` from within an async block will return the result of `<expr>` as the output of the future.\nSimilarly, if `<expr>?` propagates an error, that error is propagated as the result of the future.",
        "expr.block.async.function.control-flow": "Finally, the `break` and `continue` keywords cannot be used to branch out from an async block.\nTherefore the following is illegal:\n\n,compile_fail\nloop {\n    async move {\n        break; // error[E0267]: `break` inside of an `async` block\n    }\n}"
      }
    },
    {
      "id": "expr.block.const",
      "title": "`const` blocks",
      "level": 3,
      "content": ",expressions\nConstBlockExpression -> `const` BlockExpression\n\nA *const block* is a variant of a block expression whose body evaluates at compile-time instead of at runtime.\n\nConst blocks allows you to define a constant value without having to define new [constant items], and thus they are also sometimes referred as *inline consts*.\nIt also supports type inference so there is no need to specify the type, unlike [constant items].\n\nConst blocks have the ability to reference generic parameters in scope, unlike free constant items.\nThey are desugared to constant items with generic parameters in scope (similar to associated constants, but without a trait or type they are associated with).\nFor example, this code:\n\nfn foo<T>() -> usize {\n    const { std::mem::size_of::<T>() + 1 }\n}\n\nis equivalent to:\n\nfn foo<T>() -> usize {\n    {\n        struct Const<T>(T);\n        impl<T> Const<T> {\n            const CONST: usize = std::mem::size_of::<T>() + 1;\n        }\n        Const::<T>::CONST\n    }\n}\n\nIf the const block expression is executed at runtime, then the constant is guaranteed to be evaluated, even if its return value is ignored:\n\nfn foo<T>() -> usize {\n    // If this code ever gets executed, then the assertion has definitely\n    // been evaluated at compile-time.\n    const { assert!(std::mem::size_of::<T>() > 0); }\n    // Here we can have unsafe code relying on the type being non-zero-sized.\n    /* ... */\n    42\n}\n\nIf the const block expression is not executed at runtime, it may or may not be evaluated:\n,compile_fail\nif false {\n    // The panic may or may not occur when the program is built.\n    const { panic!(); }\n}",
      "parent_id": null,
      "paragraphs": {
        "expr.block.const.syntax": ",expressions\nConstBlockExpression -> `const` BlockExpression",
        "expr.block.const.intro": "A *const block* is a variant of a block expression whose body evaluates at compile-time instead of at runtime.",
        "expr.block.const.context": "Const blocks allows you to define a constant value without having to define new [constant items], and thus they are also sometimes referred as *inline consts*.\nIt also supports type inference so there is no need to specify the type, unlike [constant items].",
        "expr.block.const.generic-params": "Const blocks have the ability to reference generic parameters in scope, unlike free constant items.\nThey are desugared to constant items with generic parameters in scope (similar to associated constants, but without a trait or type they are associated with).\nFor example, this code:\n\nfn foo<T>() -> usize {\n    const { std::mem::size_of::<T>() + 1 }\n}\n\nis equivalent to:\n\nfn foo<T>() -> usize {\n    {\n        struct Const<T>(T);\n        impl<T> Const<T> {\n            const CONST: usize = std::mem::size_of::<T>() + 1;\n        }\n        Const::<T>::CONST\n    }\n}",
        "expr.block.const.evaluation": "If the const block expression is executed at runtime, then the constant is guaranteed to be evaluated, even if its return value is ignored:\n\nfn foo<T>() -> usize {\n    // If this code ever gets executed, then the assertion has definitely\n    // been evaluated at compile-time.\n    const { assert!(std::mem::size_of::<T>() > 0); }\n    // Here we can have unsafe code relying on the type being non-zero-sized.\n    /* ... */\n    42\n}",
        "expr.block.const.not-executed": "If the const block expression is not executed at runtime, it may or may not be evaluated:\n,compile_fail\nif false {\n    // The panic may or may not occur when the program is built.\n    const { panic!(); }\n}"
      }
    },
    {
      "id": "expr.block.unsafe",
      "title": "`unsafe` blocks",
      "level": 2,
      "content": ",expressions\nUnsafeBlockExpression -> `unsafe` BlockExpression\n\n_See [`unsafe` blocks] for more information on when to use `unsafe`_.\n\nA block of code can be prefixed with the `unsafe` keyword to permit [unsafe operations].\nExamples:\n\nunsafe {\n    let b = [13u8, 17u8];\n    let a = &b[0] as *const u8;\n    assert_eq!(*a, 13);\n    assert_eq!(*a.offset(1), 17);\n}\n\n# unsafe fn an_unsafe_fn() -> i32 { 10 }\nlet a = unsafe { an_unsafe_fn() };",
      "parent_id": null,
      "paragraphs": {
        "expr.block.unsafe.syntax": ",expressions\nUnsafeBlockExpression -> `unsafe` BlockExpression",
        "expr.block.unsafe.intro": "_See [`unsafe` blocks] for more information on when to use `unsafe`_.\n\nA block of code can be prefixed with the `unsafe` keyword to permit [unsafe operations].\nExamples:\n\nunsafe {\n    let b = [13u8, 17u8];\n    let a = &b[0] as *const u8;\n    assert_eq!(*a, 13);\n    assert_eq!(*a.offset(1), 17);\n}\n\n# unsafe fn an_unsafe_fn() -> i32 { 10 }\nlet a = unsafe { an_unsafe_fn() };"
      }
    },
    {
      "id": "expr.block.label",
      "title": "Labeled block expressions",
      "level": 1,
      "content": "Labeled block expressions are documented in the [Loops and other breakable expressions] section.",
      "parent_id": null,
      "paragraphs": {
        "expr.block.label": "Labeled block expressions are documented in the [Loops and other breakable expressions] section."
      }
    },
    {
      "id": "expr.block.attributes",
      "title": "Attributes on block expressions",
      "level": 2,
      "content": "[Inner attributes] are allowed directly after the opening brace of a block expression in the following situations:\n\n* [Function] and [method] bodies.\n* Loop bodies ([`loop`], [`while`], and [`for`]).\n* Block expressions used as a [statement].\n* Block expressions as elements of [array expressions], [tuple expressions],\n  [call expressions], and tuple-style [struct] expressions.\n* A block expression as the tail expression of another block expression.\n<!-- Keep list in sync with expressions.md -->\n\nThe attributes that have meaning on a block expression are [`cfg`] and [the lint check attributes].\n\nFor example, this function returns `true` on unix platforms and `false` on other platforms.\n\nfn is_unix_platform() -> bool {\n    #[cfg(unix)] { true }\n    #[cfg(not(unix))] { false }\n}\n\n[`await` expressions]: await-expr.md\n[`cfg`]: ../conditional-compilation.md\n[`for`]: loop-expr.md#iterator-loops\n[`loop`]: loop-expr.md#infinite-loops\n[`unsafe` blocks]: ../unsafe-keyword.md#unsafe-blocks-unsafe-\n[`while`]: loop-expr.md#predicate-loops\n[array expressions]: array-expr.md\n[call expressions]: call-expr.md\n[capture modes]: ../types/closure.md#capture-modes\n[constant items]: ../items/constant-items.md\n[free item]: ../glossary.md#free-item\n[function]: ../items/functions.md\n[inner attributes]: ../attributes.md\n[method]: ../items/associated-items.md#methods\n[mutable reference]: ../types/pointer.md#mutables-references-\n[scopes]: ../names/scopes.md\n[shared references]: ../types/pointer.md#shared-references-\n[statement]: ../statements.md\n[statements]: ../statements.md\n[struct]: struct-expr.md\n[the lint check attributes]: ../attributes/diagnostics.md#lint-check-attributes\n[tuple expressions]: tuple-expr.md\n[unsafe operations]: ../unsafety.md\n[value expressions]: ../expressions.md#place-expressions-and-value-expressions\n[Loops and other breakable expressions]: expr.loop.block-labels",
      "parent_id": null,
      "paragraphs": {
        "expr.block.attributes.inner-attributes": "[Inner attributes] are allowed directly after the opening brace of a block expression in the following situations:\n\n* [Function] and [method] bodies.\n* Loop bodies ([`loop`], [`while`], and [`for`]).\n* Block expressions used as a [statement].\n* Block expressions as elements of [array expressions], [tuple expressions],\n  [call expressions], and tuple-style [struct] expressions.\n* A block expression as the tail expression of another block expression.\n<!-- Keep list in sync with expressions.md -->",
        "expr.block.attributes.valid": "The attributes that have meaning on a block expression are [`cfg`] and [the lint check attributes].\n\nFor example, this function returns `true` on unix platforms and `false` on other platforms.\n\nfn is_unix_platform() -> bool {\n    #[cfg(unix)] { true }\n    #[cfg(not(unix))] { false }\n}\n\n[`await` expressions]: await-expr.md\n[`cfg`]: ../conditional-compilation.md\n[`for`]: loop-expr.md#iterator-loops\n[`loop`]: loop-expr.md#infinite-loops\n[`unsafe` blocks]: ../unsafe-keyword.md#unsafe-blocks-unsafe-\n[`while`]: loop-expr.md#predicate-loops\n[array expressions]: array-expr.md\n[call expressions]: call-expr.md\n[capture modes]: ../types/closure.md#capture-modes\n[constant items]: ../items/constant-items.md\n[free item]: ../glossary.md#free-item\n[function]: ../items/functions.md\n[inner attributes]: ../attributes.md\n[method]: ../items/associated-items.md#methods\n[mutable reference]: ../types/pointer.md#mutables-references-\n[scopes]: ../names/scopes.md\n[shared references]: ../types/pointer.md#shared-references-\n[statement]: ../statements.md\n[statements]: ../statements.md\n[struct]: struct-expr.md\n[the lint check attributes]: ../attributes/diagnostics.md#lint-check-attributes\n[tuple expressions]: tuple-expr.md\n[unsafe operations]: ../unsafety.md\n[value expressions]: ../expressions.md#place-expressions-and-value-expressions\n[Loops and other breakable expressions]: expr.loop.block-labels"
      }
    },
    {
      "id": "expr.operator",
      "title": "Operator expressions",
      "level": 1,
      "content": ",expressions\nOperatorExpression ->\n      BorrowExpression\n    | DereferenceExpression\n    | TryPropagationExpression\n    | NegationExpression\n    | ArithmeticOrLogicalExpression\n    | ComparisonExpression\n    | LazyBooleanExpression\n    | TypeCastExpression\n    | AssignmentExpression\n    | CompoundAssignmentExpression\n\nOperators are defined for built in types by the Rust language.\n\nMany of the following operators can also be overloaded using traits in `std::ops` or `std::cmp`.",
      "parent_id": null,
      "paragraphs": {
        "expr.operator.syntax": ",expressions\nOperatorExpression ->\n      BorrowExpression\n    | DereferenceExpression\n    | TryPropagationExpression\n    | NegationExpression\n    | ArithmeticOrLogicalExpression\n    | ComparisonExpression\n    | LazyBooleanExpression\n    | TypeCastExpression\n    | AssignmentExpression\n    | CompoundAssignmentExpression",
        "expr.operator.intro": "Operators are defined for built in types by the Rust language.",
        "expr.operator.trait": "Many of the following operators can also be overloaded using traits in `std::ops` or `std::cmp`."
      }
    },
    {
      "id": "expr.operator.int-overflow",
      "title": "Overflow",
      "level": 1,
      "content": "Integer operators will panic when they overflow when compiled in debug mode.\nThe `-C debug-assertions` and `-C overflow-checks` compiler flags can be used to control this more directly.\nThe following things are considered to be overflow:\n\n* When `+`, `*` or binary `-` create a value greater than the maximum value, or less than the minimum value that can be stored.\n\n* Applying unary `-` to the most negative value of any signed integer type, unless the operand is a [literal expression] (or a literal expression standing alone inside one or more grouped expressions).\n\n* Using `/` or `%`, where the left-hand argument is the smallest integer of a signed integer type and the right-hand argument is `-1`.\n  These checks occur even when `-C overflow-checks` is disabled, for legacy reasons.\n\n* Using `<<` or `>>` where the right-hand argument is greater than or equal to the number of bits in the type of the left-hand argument, or is negative.\n\n> [!NOTE]\n> The exception for literal expressions behind unary `-` means that forms such as `-128_i8` or `let j: i8 = -(128)` never cause a panic and have the expected value of -128.\n>\n> In these cases, the literal expression already has the most negative value for its type (for example, `128_i8` has the value -128) because integer literals are truncated to their type per the description in Integer literal expressions.\n>\n> Negation of these most negative values leaves the value unchanged due to two's complement overflow conventions.\n>\n> In `rustc`, these most negative expressions are also ignored by the `overflowing_literals` lint check.",
      "parent_id": null,
      "paragraphs": {
        "expr.operator.int-overflow.intro": "Integer operators will panic when they overflow when compiled in debug mode.\nThe `-C debug-assertions` and `-C overflow-checks` compiler flags can be used to control this more directly.\nThe following things are considered to be overflow:",
        "expr.operator.int-overflow.binary-arith": "* When `+`, `*` or binary `-` create a value greater than the maximum value, or less than the minimum value that can be stored.",
        "expr.operator.int-overflow.unary-neg": "* Applying unary `-` to the most negative value of any signed integer type, unless the operand is a [literal expression] (or a literal expression standing alone inside one or more grouped expressions).",
        "expr.operator.int-overflow.div": "* Using `/` or `%`, where the left-hand argument is the smallest integer of a signed integer type and the right-hand argument is `-1`.\n  These checks occur even when `-C overflow-checks` is disabled, for legacy reasons.",
        "expr.operator.int-overflow.shift": "* Using `<<` or `>>` where the right-hand argument is greater than or equal to the number of bits in the type of the left-hand argument, or is negative.\n\n> [!NOTE]\n> The exception for literal expressions behind unary `-` means that forms such as `-128_i8` or `let j: i8 = -(128)` never cause a panic and have the expected value of -128.\n>\n> In these cases, the literal expression already has the most negative value for its type (for example, `128_i8` has the value -128) because integer literals are truncated to their type per the description in Integer literal expressions.\n>\n> Negation of these most negative values leaves the value unchanged due to two's complement overflow conventions.\n>\n> In `rustc`, these most negative expressions are also ignored by the `overflowing_literals` lint check."
      }
    },
    {
      "id": "expr.operator.borrow",
      "title": "Borrow operators",
      "level": 2,
      "content": ",expressions\nBorrowExpression ->\n      (`&`|`&&`) Expression\n    | (`&`|`&&`) `mut` Expression\n    | (`&`|`&&`) `raw` `const` Expression\n    | (`&`|`&&`) `raw` `mut` Expression\n\nThe `&` (shared borrow) and `&mut` (mutable borrow) operators are unary prefix operators.\n\nWhen applied to a [place expression], this expressions produces a reference (pointer) to the location that the value refers to.\n\nThe memory location is also placed into a borrowed state for the duration of the reference.\nFor a shared borrow (`&`), this implies that the place may not be mutated, but it may be read or shared again.\nFor a mutable borrow (`&mut`), the place may not be accessed in any way until the borrow expires.\n\n`&mut` evaluates its operand in a mutable place expression context.\n\nIf the `&` or `&mut` operators are applied to a [value expression], then a [temporary value] is created.\n\nThese operators cannot be overloaded.\n\n{\n    // a temporary with value 7 is created that lasts for this scope.\n    let shared_reference = &7;\n}\nlet mut array = [-2, 3, 9];\n{\n    // Mutably borrows `array` for this scope.\n    // `array` may only be used through `mutable_reference`.\n    let mutable_reference = &mut array;\n}\n\nEven though `&&` is a single token (the lazy 'and' operator), when used in the context of borrow expressions it works as two borrows:\n\n// same meanings:\nlet a = &&  10;\nlet a = & & 10;\n\n// same meanings:\nlet a = &&&&  mut 10;\nlet a = && && mut 10;\nlet a = & & & & mut 10;",
      "parent_id": null,
      "paragraphs": {
        "expr.operator.borrow.syntax": ",expressions\nBorrowExpression ->\n      (`&`|`&&`) Expression\n    | (`&`|`&&`) `mut` Expression\n    | (`&`|`&&`) `raw` `const` Expression\n    | (`&`|`&&`) `raw` `mut` Expression",
        "expr.operator.borrow.intro": "The `&` (shared borrow) and `&mut` (mutable borrow) operators are unary prefix operators.",
        "expr.operator.borrow.result": "When applied to a [place expression], this expressions produces a reference (pointer) to the location that the value refers to.",
        "expr.operator.borrow.lifetime": "The memory location is also placed into a borrowed state for the duration of the reference.\nFor a shared borrow (`&`), this implies that the place may not be mutated, but it may be read or shared again.\nFor a mutable borrow (`&mut`), the place may not be accessed in any way until the borrow expires.",
        "expr.operator.borrow.mut": "`&mut` evaluates its operand in a mutable place expression context.",
        "expr.operator.borrow.temporary": "If the `&` or `&mut` operators are applied to a [value expression], then a [temporary value] is created.\n\nThese operators cannot be overloaded.\n\n{\n    // a temporary with value 7 is created that lasts for this scope.\n    let shared_reference = &7;\n}\nlet mut array = [-2, 3, 9];\n{\n    // Mutably borrows `array` for this scope.\n    // `array` may only be used through `mutable_reference`.\n    let mutable_reference = &mut array;\n}",
        "expr.borrow.and-and-syntax": "Even though `&&` is a single token (the lazy 'and' operator), when used in the context of borrow expressions it works as two borrows:\n\n// same meanings:\nlet a = &&  10;\nlet a = & & 10;\n\n// same meanings:\nlet a = &&&&  mut 10;\nlet a = && && mut 10;\nlet a = & & & & mut 10;"
      }
    },
    {
      "id": "expr.borrow.raw",
      "title": "Raw borrow operators",
      "level": 2,
      "content": "`&raw const` and `&raw mut` are the *raw borrow operators*.\n\nThe operand expression of these operators is evaluated in place expression context.\n\n`&raw const expr` then creates a const raw pointer of type `*const T` to the given place, and `&raw mut expr` creates a mutable raw pointer of type `*mut T`.\n\nThe raw borrow operators must be used instead of a borrow operator whenever the place expression could evaluate to a place that is not properly aligned or does not store a valid value as determined by its type, or whenever creating a reference would introduce incorrect aliasing assumptions.\nIn those situations, using a borrow operator would cause [undefined behavior] by creating an invalid reference, but a raw pointer may still be constructed.\n\nThe following is an example of creating a raw pointer to an unaligned place through a `packed` struct:\n\n#[repr(packed)]\nstruct Packed {\n    f1: u8,\n    f2: u16,\n}\n\nlet packed = Packed { f1: 1, f2: 2 };\n// `&packed.f2` would create an unaligned reference, and thus be undefined behavior!\nlet raw_f2 = &raw const packed.f2;\nassert_eq!(unsafe { raw_f2.read_unaligned() }, 2);\n\nThe following is an example of creating a raw pointer to a place that does not contain a valid value:\n\nuse std::mem::MaybeUninit;\n\nstruct Demo {\n    field: bool,\n}\n\nlet mut uninit = MaybeUninit::<Demo>::uninit();\n// `&uninit.as_mut().field` would create a reference to an uninitialized `bool`,\n// and thus be undefined behavior!\nlet f1_ptr = unsafe { &raw mut (*uninit.as_mut_ptr()).field };\nunsafe { f1_ptr.write(true); }\nlet init = unsafe { uninit.assume_init() };",
      "parent_id": null,
      "paragraphs": {
        "expr.borrow.raw.intro": "`&raw const` and `&raw mut` are the *raw borrow operators*.",
        "expr.borrow.raw.place": "The operand expression of these operators is evaluated in place expression context.",
        "expr.borrow.raw.result": "`&raw const expr` then creates a const raw pointer of type `*const T` to the given place, and `&raw mut expr` creates a mutable raw pointer of type `*mut T`.",
        "expr.borrow.raw.invalid-ref": "The raw borrow operators must be used instead of a borrow operator whenever the place expression could evaluate to a place that is not properly aligned or does not store a valid value as determined by its type, or whenever creating a reference would introduce incorrect aliasing assumptions.\nIn those situations, using a borrow operator would cause [undefined behavior] by creating an invalid reference, but a raw pointer may still be constructed.\n\nThe following is an example of creating a raw pointer to an unaligned place through a `packed` struct:\n\n#[repr(packed)]\nstruct Packed {\n    f1: u8,\n    f2: u16,\n}\n\nlet packed = Packed { f1: 1, f2: 2 };\n// `&packed.f2` would create an unaligned reference, and thus be undefined behavior!\nlet raw_f2 = &raw const packed.f2;\nassert_eq!(unsafe { raw_f2.read_unaligned() }, 2);\n\nThe following is an example of creating a raw pointer to a place that does not contain a valid value:\n\nuse std::mem::MaybeUninit;\n\nstruct Demo {\n    field: bool,\n}\n\nlet mut uninit = MaybeUninit::<Demo>::uninit();\n// `&uninit.as_mut().field` would create a reference to an uninitialized `bool`,\n// and thus be undefined behavior!\nlet f1_ptr = unsafe { &raw mut (*uninit.as_mut_ptr()).field };\nunsafe { f1_ptr.write(true); }\nlet init = unsafe { uninit.assume_init() };"
      }
    },
    {
      "id": "expr.deref",
      "title": "The dereference operator",
      "level": 3,
      "content": ",expressions\nDereferenceExpression -> `*` Expression\n\nThe `*` (dereference) operator is also a unary prefix operator.\n\nWhen applied to a pointer it denotes the pointed-to location.\n\nIf the expression is of type `&mut T` or `*mut T`, and is either a local variable, a (nested) field of a local variable or is a mutable [place expression], then the resulting memory location can be assigned to.\n\nDereferencing a raw pointer requires `unsafe`.\n\nOn non-pointer types `*x` is equivalent to `*std::ops::Deref::deref(&x)` in an immutable place expression context and `*std::ops::DerefMut::deref_mut(&mut x)` in a mutable place expression context.\n\nlet x = &7;\nassert_eq!(*x, 7);\nlet y = &mut 9;\n*y = 11;\nassert_eq!(*y, 11);",
      "parent_id": null,
      "paragraphs": {
        "expr.deref.syntax": ",expressions\nDereferenceExpression -> `*` Expression",
        "expr.deref.intro": "The `*` (dereference) operator is also a unary prefix operator.",
        "expr.deref.result": "When applied to a pointer it denotes the pointed-to location.",
        "expr.deref.mut": "If the expression is of type `&mut T` or `*mut T`, and is either a local variable, a (nested) field of a local variable or is a mutable [place expression], then the resulting memory location can be assigned to.",
        "expr.deref.safety": "Dereferencing a raw pointer requires `unsafe`.",
        "expr.deref.traits": "On non-pointer types `*x` is equivalent to `*std::ops::Deref::deref(&x)` in an immutable place expression context and `*std::ops::DerefMut::deref_mut(&mut x)` in a mutable place expression context.\n\nlet x = &7;\nassert_eq!(*x, 7);\nlet y = &mut 9;\n*y = 11;\nassert_eq!(*y, 11);"
      }
    },
    {
      "id": "expr.try",
      "title": "The try propagation expression",
      "level": 2,
      "content": ",expressions\nTryPropagationExpression -> Expression `?`\n\nThe try propagation expression uses the value of the inner expression and the [`Try`] trait to decide whether to produce a value, and if so, what value to produce, or whether to return a value to the caller, and if so, what value to return.\n\n> [!EXAMPLE]\n> ```rust\n> # use std::num::ParseIntError;\n> fn try_to_parse() -> Result<i32, ParseIntError> {\n>     let x: i32 = \"123\".parse()?; // `x` is `123`.\n>     let y: i32 = \"24a\".parse()?; // Returns an `Err()` immediately.\n>     Ok(x + y)                    // Doesn't run.\n> }\n>\n> let res = try_to_parse();\n> println!(\"{res:?}\");\n> # assert!(res.is_err())\n> ```\n>\n> ```rust\n> fn try_option_some() -> Option<u8> {\n>     let val = Some(1)?;\n>     Some(val)\n> }\n> assert_eq!(try_option_some(), Some(1));\n>\n> fn try_option_none() -> Option<u8> {\n>     let val = None?;\n>     Some(val)\n> }\n> assert_eq!(try_option_none(), None);\n> ```\n>\n> ```rust\n> use std::ops::ControlFlow;\n>\n> pub struct TreeNode<T> {\n>     value: T,\n>     left: Option<Box<TreeNode<T>>>,\n>     right: Option<Box<TreeNode<T>>>,\n> }\n>\n> impl<T> TreeNode<T> {\n>     pub fn traverse_inorder<B>(&self, f: &mut impl FnMut(&T) -> ControlFlow<B>) -> ControlFlow<B> {\n>         if let Some(left) = &self.left {\n>             left.traverse_inorder(f)?;\n>         }\n>         f(&self.value)?;\n>         if let Some(right) = &self.right {\n>             right.traverse_inorder(f)?;\n>         }\n>         ControlFlow::Continue(())\n>     }\n> }\n> #\n> # fn main() {\n> #     let n = TreeNode {\n> #         value: 1,\n> #         left: Some(Box::new(TreeNode{value: 2, left: None, right: None})),\n> #         right: None,\n> #     };\n> #     let v = n.traverse_inorder(&mut |t| {\n> #         if *t == 2 {\n> #             ControlFlow::Break(\"found\")\n> #         } else {\n> #             ControlFlow::Continue(())\n> #         }\n> #     });\n> #     assert_eq!(v, ControlFlow::Break(\"found\"));\n> # }\n> ```\n\n> [!NOTE]\n> The [`Try`] trait is currently unstable, and thus cannot be implemented for user types.\n>\n> The try propagation expression is currently roughly equivalent to:\n>\n> ```rust\n> # #![ feature(try_trait_v2) ]\n> # fn example() -> Result<(), ()> {\n> # let expr = Ok(());\n> match core::ops::Try::branch(expr) {\n>     core::ops::ControlFlow::Continue(val) => val,\n>     core::ops::ControlFlow::Break(residual) =>\n>         return core::ops::FromResidual::from_residual(residual),\n> }\n> # Ok(())\n> # }\n> ```\n\n> [!NOTE]\n> The try propagation operator is sometimes called *the question mark operator*, *the `?` operator*, or *the try operator*.\n\nThe try propagation operator can be applied to expressions with the type of:\n\n- [`Result<T, E>`]\n    - `Result::Ok(val)` evaluates to `val`.\n    - `Result::Err(e)` returns `Result::Err(From::from(e))`.\n- [`Option<T>`]\n    - `Option::Some(val)` evaluates to `val`.\n    - `Option::None` returns `Option::None`.\n- `ControlFlow<B, C>`\n    - `ControlFlow::Continue(c)` evaluates to `c`.\n    - `ControlFlow::Break(b)` returns `ControlFlow::Break(b)`.\n- `Poll<Result<T, E>>`\n    - `Poll::Ready(Ok(val))` evaluates to `Poll::Ready(val)`.\n    - `Poll::Ready(Err(e))` returns `Poll::Ready(Err(From::from(e)))`.\n    - `Poll::Pending` evaluates to `Poll::Pending`.\n- `Poll<Option<Result<T, E>>>`\n    - `Poll::Ready(Some(Ok(val)))` evaluates to `Poll::Ready(Some(val))`.\n    - `Poll::Ready(Some(Err(e)))` returns `Poll::Ready(Some(Err(From::from(e))))`.\n    - `Poll::Ready(None)` evaluates to `Poll::Ready(None)`.\n    - `Poll::Pending` evaluates to `Poll::Pending`.",
      "parent_id": null,
      "paragraphs": {
        "expr.try.syntax": ",expressions\nTryPropagationExpression -> Expression `?`",
        "expr.try.intro": "The try propagation expression uses the value of the inner expression and the [`Try`] trait to decide whether to produce a value, and if so, what value to produce, or whether to return a value to the caller, and if so, what value to return.\n\n> [!EXAMPLE]\n> ```rust\n> # use std::num::ParseIntError;\n> fn try_to_parse() -> Result<i32, ParseIntError> {\n>     let x: i32 = \"123\".parse()?; // `x` is `123`.\n>     let y: i32 = \"24a\".parse()?; // Returns an `Err()` immediately.\n>     Ok(x + y)                    // Doesn't run.\n> }\n>\n> let res = try_to_parse();\n> println!(\"{res:?}\");\n> # assert!(res.is_err())\n> ```\n>\n> ```rust\n> fn try_option_some() -> Option<u8> {\n>     let val = Some(1)?;\n>     Some(val)\n> }\n> assert_eq!(try_option_some(), Some(1));\n>\n> fn try_option_none() -> Option<u8> {\n>     let val = None?;\n>     Some(val)\n> }\n> assert_eq!(try_option_none(), None);\n> ```\n>\n> ```rust\n> use std::ops::ControlFlow;\n>\n> pub struct TreeNode<T> {\n>     value: T,\n>     left: Option<Box<TreeNode<T>>>,\n>     right: Option<Box<TreeNode<T>>>,\n> }\n>\n> impl<T> TreeNode<T> {\n>     pub fn traverse_inorder<B>(&self, f: &mut impl FnMut(&T) -> ControlFlow<B>) -> ControlFlow<B> {\n>         if let Some(left) = &self.left {\n>             left.traverse_inorder(f)?;\n>         }\n>         f(&self.value)?;\n>         if let Some(right) = &self.right {\n>             right.traverse_inorder(f)?;\n>         }\n>         ControlFlow::Continue(())\n>     }\n> }\n> #\n> # fn main() {\n> #     let n = TreeNode {\n> #         value: 1,\n> #         left: Some(Box::new(TreeNode{value: 2, left: None, right: None})),\n> #         right: None,\n> #     };\n> #     let v = n.traverse_inorder(&mut |t| {\n> #         if *t == 2 {\n> #             ControlFlow::Break(\"found\")\n> #         } else {\n> #             ControlFlow::Continue(())\n> #         }\n> #     });\n> #     assert_eq!(v, ControlFlow::Break(\"found\"));\n> # }\n> ```\n\n> [!NOTE]\n> The [`Try`] trait is currently unstable, and thus cannot be implemented for user types.\n>\n> The try propagation expression is currently roughly equivalent to:\n>\n> ```rust\n> # #![ feature(try_trait_v2) ]\n> # fn example() -> Result<(), ()> {\n> # let expr = Ok(());\n> match core::ops::Try::branch(expr) {\n>     core::ops::ControlFlow::Continue(val) => val,\n>     core::ops::ControlFlow::Break(residual) =>\n>         return core::ops::FromResidual::from_residual(residual),\n> }\n> # Ok(())\n> # }\n> ```\n\n> [!NOTE]\n> The try propagation operator is sometimes called *the question mark operator*, *the `?` operator*, or *the try operator*.",
        "expr.try.restricted-types": "The try propagation operator can be applied to expressions with the type of:\n\n- [`Result<T, E>`]\n    - `Result::Ok(val)` evaluates to `val`.\n    - `Result::Err(e)` returns `Result::Err(From::from(e))`.\n- [`Option<T>`]\n    - `Option::Some(val)` evaluates to `val`.\n    - `Option::None` returns `Option::None`.\n- `ControlFlow<B, C>`\n    - `ControlFlow::Continue(c)` evaluates to `c`.\n    - `ControlFlow::Break(b)` returns `ControlFlow::Break(b)`.\n- `Poll<Result<T, E>>`\n    - `Poll::Ready(Ok(val))` evaluates to `Poll::Ready(val)`.\n    - `Poll::Ready(Err(e))` returns `Poll::Ready(Err(From::from(e)))`.\n    - `Poll::Pending` evaluates to `Poll::Pending`.\n- `Poll<Option<Result<T, E>>>`\n    - `Poll::Ready(Some(Ok(val)))` evaluates to `Poll::Ready(Some(val))`.\n    - `Poll::Ready(Some(Err(e)))` returns `Poll::Ready(Some(Err(From::from(e))))`.\n    - `Poll::Ready(None)` evaluates to `Poll::Ready(None)`.\n    - `Poll::Pending` evaluates to `Poll::Pending`."
      }
    },
    {
      "id": "expr.negate",
      "title": "Negation operators",
      "level": 2,
      "content": ",expressions\nNegationExpression ->\n      `-` Expression\n    | `!` Expression\n\nThese are the last two unary operators.\n\nThis table summarizes the behavior of them on primitive types and which traits are used to overload these operators for other types.\nRemember that signed integers are always represented using two's complement.\nThe operands of all of these operators are evaluated in value expression context so are moved or copied.\n\n| Symbol | Integer     | `bool`        | Floating Point | Overloading Trait  |\n|--------|-------------|-------------- |----------------|--------------------|\n| `-`    | Negation*   |               | Negation       | `std::ops::Neg`    |\n| `!`    | Bitwise NOT | [Logical NOT] |                | `std::ops::Not`    |\n\n\\* Only for signed integer types.\n\nHere are some example of these operators\n\nlet x = 6;\nassert_eq!(-x, -6);\nassert_eq!(!x, -7);\nassert_eq!(true, !false);",
      "parent_id": null,
      "paragraphs": {
        "expr.negate.syntax": ",expressions\nNegationExpression ->\n      `-` Expression\n    | `!` Expression",
        "expr.negate.intro": "These are the last two unary operators.",
        "expr.negate.results": "This table summarizes the behavior of them on primitive types and which traits are used to overload these operators for other types.\nRemember that signed integers are always represented using two's complement.\nThe operands of all of these operators are evaluated in value expression context so are moved or copied.\n\n| Symbol | Integer     | `bool`        | Floating Point | Overloading Trait  |\n|--------|-------------|-------------- |----------------|--------------------|\n| `-`    | Negation*   |               | Negation       | `std::ops::Neg`    |\n| `!`    | Bitwise NOT | [Logical NOT] |                | `std::ops::Not`    |\n\n\\* Only for signed integer types.\n\nHere are some example of these operators\n\nlet x = 6;\nassert_eq!(-x, -6);\nassert_eq!(!x, -7);\nassert_eq!(true, !false);"
      }
    },
    {
      "id": "expr.arith-logic",
      "title": "Arithmetic and logical binary operators",
      "level": 2,
      "content": ",expressions\nArithmeticOrLogicalExpression ->\n      Expression `+` Expression\n    | Expression `-` Expression\n    | Expression `*` Expression\n    | Expression `/` Expression\n    | Expression `%` Expression\n    | Expression `&` Expression\n    | Expression `|` Expression\n    | Expression `^` Expression\n    | Expression `<<` Expression\n    | Expression `>>` Expression\n\nBinary operators expressions are all written with infix notation.\n\nThis table summarizes the behavior of arithmetic and logical binary operators on primitive types and which traits are used to overload these operators for other types.\nRemember that signed integers are always represented using two's complement.\nThe operands of all of these operators are evaluated in value expression context so are moved or copied.\n\n| Symbol | Integer                 | `bool`        | Floating Point | Overloading Trait  | Overloading Compound Assignment Trait |\n|--------|-------------------------|---------------|----------------|--------------------| ------------------------------------- |\n| `+`    | Addition                |               | Addition       | `std::ops::Add`    | `std::ops::AddAssign`                 |\n| `-`    | Subtraction             |               | Subtraction    | `std::ops::Sub`    | `std::ops::SubAssign`                 |\n| `*`    | Multiplication          |               | Multiplication | `std::ops::Mul`    | `std::ops::MulAssign`                 |\n| `/`    | Division*\u2020              |               | Division       | `std::ops::Div`    | `std::ops::DivAssign`                 |\n| `%`    | Remainder**\u2020            |               | Remainder      | `std::ops::Rem`    | `std::ops::RemAssign`                 |\n| `&`    | Bitwise AND             | [Logical AND] |                | `std::ops::BitAnd` | `std::ops::BitAndAssign`              |\n| `\\|` | Bitwise OR | [Logical OR]  |                | `std::ops::BitOr`  | `std::ops::BitOrAssign`               |\n| `^`    | Bitwise XOR             | [Logical XOR] |                | `std::ops::BitXor` | `std::ops::BitXorAssign`              |\n| `<<`   | Left Shift              |               |                | `std::ops::Shl`    | `std::ops::ShlAssign`                 |\n| `>>`   | Right Shift***          |               |                | `std::ops::Shr`    |  `std::ops::ShrAssign`                |\n\n\\* Integer division rounds towards zero.\n\n\\*\\* Rust uses a remainder defined with truncating division. Given `remainder = dividend % divisor`, the remainder will have the same sign as the dividend.\n\n\\*\\*\\* Arithmetic right shift on signed integer types, logical right shift on\nunsigned integer types.\n\n\u2020 For integer types, division by zero panics.\n\nHere are examples of these operators being used.\n\nassert_eq!(3 + 6, 9);\nassert_eq!(5.5 - 1.25, 4.25);\nassert_eq!(-5 * 14, -70);\nassert_eq!(14 / 3, 4);\nassert_eq!(100 % 7, 2);\nassert_eq!(0b1010 & 0b1100, 0b1000);\nassert_eq!(0b1010 | 0b1100, 0b1110);\nassert_eq!(0b1010 ^ 0b1100, 0b110);\nassert_eq!(13 << 3, 104);\nassert_eq!(-10 >> 2, -3);",
      "parent_id": null,
      "paragraphs": {
        "expr.arith-logic.syntax": ",expressions\nArithmeticOrLogicalExpression ->\n      Expression `+` Expression\n    | Expression `-` Expression\n    | Expression `*` Expression\n    | Expression `/` Expression\n    | Expression `%` Expression\n    | Expression `&` Expression\n    | Expression `|` Expression\n    | Expression `^` Expression\n    | Expression `<<` Expression\n    | Expression `>>` Expression",
        "expr.arith-logic.intro": "Binary operators expressions are all written with infix notation.",
        "expr.arith-logic.behavior": "This table summarizes the behavior of arithmetic and logical binary operators on primitive types and which traits are used to overload these operators for other types.\nRemember that signed integers are always represented using two's complement.\nThe operands of all of these operators are evaluated in value expression context so are moved or copied.\n\n| Symbol | Integer                 | `bool`        | Floating Point | Overloading Trait  | Overloading Compound Assignment Trait |\n|--------|-------------------------|---------------|----------------|--------------------| ------------------------------------- |\n| `+`    | Addition                |               | Addition       | `std::ops::Add`    | `std::ops::AddAssign`                 |\n| `-`    | Subtraction             |               | Subtraction    | `std::ops::Sub`    | `std::ops::SubAssign`                 |\n| `*`    | Multiplication          |               | Multiplication | `std::ops::Mul`    | `std::ops::MulAssign`                 |\n| `/`    | Division*\u2020              |               | Division       | `std::ops::Div`    | `std::ops::DivAssign`                 |\n| `%`    | Remainder**\u2020            |               | Remainder      | `std::ops::Rem`    | `std::ops::RemAssign`                 |\n| `&`    | Bitwise AND             | [Logical AND] |                | `std::ops::BitAnd` | `std::ops::BitAndAssign`              |\n| `\\|` | Bitwise OR | [Logical OR]  |                | `std::ops::BitOr`  | `std::ops::BitOrAssign`               |\n| `^`    | Bitwise XOR             | [Logical XOR] |                | `std::ops::BitXor` | `std::ops::BitXorAssign`              |\n| `<<`   | Left Shift              |               |                | `std::ops::Shl`    | `std::ops::ShlAssign`                 |\n| `>>`   | Right Shift***          |               |                | `std::ops::Shr`    |  `std::ops::ShrAssign`                |\n\n\\* Integer division rounds towards zero.\n\n\\*\\* Rust uses a remainder defined with truncating division. Given `remainder = dividend % divisor`, the remainder will have the same sign as the dividend.\n\n\\*\\*\\* Arithmetic right shift on signed integer types, logical right shift on\nunsigned integer types.\n\n\u2020 For integer types, division by zero panics.\n\nHere are examples of these operators being used.\n\nassert_eq!(3 + 6, 9);\nassert_eq!(5.5 - 1.25, 4.25);\nassert_eq!(-5 * 14, -70);\nassert_eq!(14 / 3, 4);\nassert_eq!(100 % 7, 2);\nassert_eq!(0b1010 & 0b1100, 0b1000);\nassert_eq!(0b1010 | 0b1100, 0b1110);\nassert_eq!(0b1010 ^ 0b1100, 0b110);\nassert_eq!(13 << 3, 104);\nassert_eq!(-10 >> 2, -3);"
      }
    },
    {
      "id": "expr.cmp",
      "title": "Comparison operators",
      "level": 2,
      "content": ",expressions\nComparisonExpression ->\n      Expression `==` Expression\n    | Expression `!=` Expression\n    | Expression `>` Expression\n    | Expression `<` Expression\n    | Expression `>=` Expression\n    | Expression `<=` Expression\n\nComparison operators are also defined both for primitive types and many types in the standard library.\n\nParentheses are required when chaining comparison operators. For example, the expression `a == b == c` is invalid and may be written as `(a == b) == c`.\n\nUnlike arithmetic and logical operators, the traits for overloading these operators are used more generally to show how a type may be compared and will likely be assumed to define actual comparisons by functions that use these traits as bounds.\nMany functions and macros in the standard library can then use that assumption (although not to ensure safety).\n\nUnlike the arithmetic and logical operators above, these operators implicitly take shared borrows of their operands, evaluating them in place expression context:\n\n# let a = 1;\n# let b = 1;\na == b;\n// is equivalent to\n::std::cmp::PartialEq::eq(&a, &b);\n\nThis means that the operands don't have to be moved out of.\n\n| Symbol | Meaning                  | Overloading method         |\n|--------|--------------------------|----------------------------|\n| `==`   | Equal                    | `std::cmp::PartialEq::eq`  |\n| `!=`   | Not equal                | `std::cmp::PartialEq::ne`  |\n| `>`    | Greater than             | `std::cmp::PartialOrd::gt` |\n| `<`    | Less than                | `std::cmp::PartialOrd::lt` |\n| `>=`   | Greater than or equal to | `std::cmp::PartialOrd::ge` |\n| `<=`   | Less than or equal to    | `std::cmp::PartialOrd::le` |\n\nHere are examples of the comparison operators being used.\n\nassert!(123 == 123);\nassert!(23 != -12);\nassert!(12.5 > 12.2);\nassert!([1, 2, 3] < [1, 3, 4]);\nassert!('A' <= 'B');\nassert!(\"World\" >= \"Hello\");",
      "parent_id": null,
      "paragraphs": {
        "expr.cmp.syntax": ",expressions\nComparisonExpression ->\n      Expression `==` Expression\n    | Expression `!=` Expression\n    | Expression `>` Expression\n    | Expression `<` Expression\n    | Expression `>=` Expression\n    | Expression `<=` Expression",
        "expr.cmp.intro": "Comparison operators are also defined both for primitive types and many types in the standard library.",
        "expr.cmp.paren-chaining": "Parentheses are required when chaining comparison operators. For example, the expression `a == b == c` is invalid and may be written as `(a == b) == c`.",
        "expr.cmp.trait": "Unlike arithmetic and logical operators, the traits for overloading these operators are used more generally to show how a type may be compared and will likely be assumed to define actual comparisons by functions that use these traits as bounds.\nMany functions and macros in the standard library can then use that assumption (although not to ensure safety).",
        "expr.cmp.place": "Unlike the arithmetic and logical operators above, these operators implicitly take shared borrows of their operands, evaluating them in place expression context:\n\n# let a = 1;\n# let b = 1;\na == b;\n// is equivalent to\n::std::cmp::PartialEq::eq(&a, &b);\n\nThis means that the operands don't have to be moved out of.",
        "expr.cmp.behavior": "| Symbol | Meaning                  | Overloading method         |\n|--------|--------------------------|----------------------------|\n| `==`   | Equal                    | `std::cmp::PartialEq::eq`  |\n| `!=`   | Not equal                | `std::cmp::PartialEq::ne`  |\n| `>`    | Greater than             | `std::cmp::PartialOrd::gt` |\n| `<`    | Less than                | `std::cmp::PartialOrd::lt` |\n| `>=`   | Greater than or equal to | `std::cmp::PartialOrd::ge` |\n| `<=`   | Less than or equal to    | `std::cmp::PartialOrd::le` |\n\nHere are examples of the comparison operators being used.\n\nassert!(123 == 123);\nassert!(23 != -12);\nassert!(12.5 > 12.2);\nassert!([1, 2, 3] < [1, 3, 4]);\nassert!('A' <= 'B');\nassert!(\"World\" >= \"Hello\");"
      }
    },
    {
      "id": "expr.bool-logic",
      "title": "Lazy boolean operators",
      "level": 1,
      "content": ",expressions\nLazyBooleanExpression ->\n      Expression `||` Expression\n    | Expression `&&` Expression\n\nThe operators `||` and `&&` may be applied to operands of boolean type.\nThe `||` operator denotes logical 'or', and the `&&` operator denotes logical 'and'.\n\nThey differ from `|` and `&` in that the right-hand operand is only evaluated when the left-hand operand does not already determine the result of the expression.\nThat is, `||` only evaluates its right-hand operand when the left-hand operand evaluates to `false`, and `&&` only when it evaluates to `true`.\n\nlet x = false || true; // true\nlet y = false && panic!(); // false, doesn't evaluate `panic!()`",
      "parent_id": null,
      "paragraphs": {
        "expr.bool-logic.syntax": ",expressions\nLazyBooleanExpression ->\n      Expression `||` Expression\n    | Expression `&&` Expression",
        "expr.bool-logic.intro": "The operators `||` and `&&` may be applied to operands of boolean type.\nThe `||` operator denotes logical 'or', and the `&&` operator denotes logical 'and'.",
        "expr.bool-logic.conditional-evaluation": "They differ from `|` and `&` in that the right-hand operand is only evaluated when the left-hand operand does not already determine the result of the expression.\nThat is, `||` only evaluates its right-hand operand when the left-hand operand evaluates to `false`, and `&&` only when it evaluates to `true`.\n\nlet x = false || true; // true\nlet y = false && panic!(); // false, doesn't evaluate `panic!()`"
      }
    },
    {
      "id": "expr.as",
      "title": "Type cast expressions",
      "level": 2,
      "content": ",expressions\nTypeCastExpression -> Expression `as` TypeNoBounds\n\nA type cast expression is denoted with the binary operator `as`.\n\nExecuting an `as` expression casts the value on the left-hand side to the type on the right-hand side.\n\nAn example of an `as` expression:\n\n# fn sum(values: &[f64]) -> f64 { 0.0 }\n# fn len(values: &[f64]) -> i32 { 0 }\nfn average(values: &[f64]) -> f64 {\n    let sum: f64 = sum(values);\n    let size: f64 = len(values) as f64;\n    sum / size\n}\n\n`as` can be used to explicitly perform coercions, as well as the following additional casts.\nAny cast that does not fit either a coercion rule or an entry in the table is a compiler error.\nHere `*T` means either `*const T` or `*mut T`. `m` stands for optional `mut` in\nreference types and `mut` or `const` in pointer types.\n\n| Type of `e`           | `U`                   | Cast performed by `e as U`                            |\n|-----------------------|-----------------------|-------------------------------------------------------|\n| Integer or Float type | Integer or Float type | Numeric cast                       |\n| Enumeration           | Integer type          | Enum cast                             |\n| `bool` or `char`      | Integer type          | Primitive to integer cast |\n| `u8`                  | `char`                | `u8` to `char` cast             |\n| `*T`                  | `*V` [^meta-compat]   | Pointer to pointer cast            |\n| `*T` where `T: Sized` | Integer type          | Pointer to address cast     |\n| Integer type          | `*V` where `V: Sized` | Address to pointer cast     |\n| `&m\u2081 [T; n]`          | `*m\u2082 T` [^lessmut]    | Array to pointer cast                                 |\n| `*m\u2081 [T; n]`          | `*m\u2082 T` [^lessmut]    | Array to pointer cast                                 |\n| [Function item]       | [Function pointer]    | Function item to function pointer cast                |\n| [Function item]       | `*V` where `V: Sized` | Function item to pointer cast                         |\n| [Function item]       | Integer               | Function item to address cast                         |\n| [Function pointer]    | `*V` where `V: Sized` | Function pointer to pointer cast                      |\n| [Function pointer]    | Integer               | Function pointer to address cast                      |\n| Closure [^no-capture] | Function pointer      | Closure to function pointer cast                      |\n\n[^meta-compat]: Where `T` and `V` have compatible metadata:\n      * `V: Sized`, or\n      * Both slice metadata (`*[u16]` -> `*[u8]`, `*str` -> `*(u8, [u32])`), or\n      * Both the same trait object metadata, modulo dropping auto traits (`*dyn Debug` -> `*(u16, dyn Debug)`, `*dyn Debug + Send` -> `*dyn Debug`)\n          * **Note**: *adding* auto traits is only allowed if the principal trait has the auto trait as a super trait (given `trait T: Send {}`, `*dyn T` -> `*dyn T + Send` is valid, but `*dyn Debug` -> `*dyn Debug + Send` is not)\n          * **Note**: Generics (including lifetimes) must match (`*dyn T<'a, A>` -> `*dyn T<'b, B>` requires `'a = 'b` and `A = B`)\n\n[^lessmut]: Only when `m\u2081` is `mut` or `m\u2082` is `const`. Casting `mut` reference/pointer to\n`const` pointer is allowed.\n\n[^no-capture]: Only closures that do not capture (close over) any local variables can be cast to function pointers.\n\n### Semantics",
      "parent_id": null,
      "paragraphs": {
        "expr.as.syntax": ",expressions\nTypeCastExpression -> Expression `as` TypeNoBounds",
        "expr.as.intro": "A type cast expression is denoted with the binary operator `as`.",
        "expr.as.result": "Executing an `as` expression casts the value on the left-hand side to the type on the right-hand side.\n\nAn example of an `as` expression:\n\n# fn sum(values: &[f64]) -> f64 { 0.0 }\n# fn len(values: &[f64]) -> i32 { 0 }\nfn average(values: &[f64]) -> f64 {\n    let sum: f64 = sum(values);\n    let size: f64 = len(values) as f64;\n    sum / size\n}",
        "expr.as.coercions": "`as` can be used to explicitly perform coercions, as well as the following additional casts.\nAny cast that does not fit either a coercion rule or an entry in the table is a compiler error.\nHere `*T` means either `*const T` or `*mut T`. `m` stands for optional `mut` in\nreference types and `mut` or `const` in pointer types.\n\n| Type of `e`           | `U`                   | Cast performed by `e as U`                            |\n|-----------------------|-----------------------|-------------------------------------------------------|\n| Integer or Float type | Integer or Float type | Numeric cast                       |\n| Enumeration           | Integer type          | Enum cast                             |\n| `bool` or `char`      | Integer type          | Primitive to integer cast |\n| `u8`                  | `char`                | `u8` to `char` cast             |\n| `*T`                  | `*V` [^meta-compat]   | Pointer to pointer cast            |\n| `*T` where `T: Sized` | Integer type          | Pointer to address cast     |\n| Integer type          | `*V` where `V: Sized` | Address to pointer cast     |\n| `&m\u2081 [T; n]`          | `*m\u2082 T` [^lessmut]    | Array to pointer cast                                 |\n| `*m\u2081 [T; n]`          | `*m\u2082 T` [^lessmut]    | Array to pointer cast                                 |\n| [Function item]       | [Function pointer]    | Function item to function pointer cast                |\n| [Function item]       | `*V` where `V: Sized` | Function item to pointer cast                         |\n| [Function item]       | Integer               | Function item to address cast                         |\n| [Function pointer]    | `*V` where `V: Sized` | Function pointer to pointer cast                      |\n| [Function pointer]    | Integer               | Function pointer to address cast                      |\n| Closure [^no-capture] | Function pointer      | Closure to function pointer cast                      |\n\n[^meta-compat]: Where `T` and `V` have compatible metadata:\n      * `V: Sized`, or\n      * Both slice metadata (`*[u16]` -> `*[u8]`, `*str` -> `*(u8, [u32])`), or\n      * Both the same trait object metadata, modulo dropping auto traits (`*dyn Debug` -> `*(u16, dyn Debug)`, `*dyn Debug + Send` -> `*dyn Debug`)\n          * **Note**: *adding* auto traits is only allowed if the principal trait has the auto trait as a super trait (given `trait T: Send {}`, `*dyn T` -> `*dyn T + Send` is valid, but `*dyn Debug` -> `*dyn Debug + Send` is not)\n          * **Note**: Generics (including lifetimes) must match (`*dyn T<'a, A>` -> `*dyn T<'b, B>` requires `'a = 'b` and `A = B`)\n\n[^lessmut]: Only when `m\u2081` is `mut` or `m\u2082` is `const`. Casting `mut` reference/pointer to\n`const` pointer is allowed.\n\n[^no-capture]: Only closures that do not capture (close over) any local variables can be cast to function pointers.\n\n### Semantics"
      }
    },
    {
      "id": "expr.as.numeric",
      "title": "Numeric cast",
      "level": 3,
      "content": "* Casting between two integers of the same size (e.g. i32 -> u32) is a no-op\n  (Rust uses 2's complement for negative values of fixed integers)\n\n  ```rust\n  assert_eq!(42i8 as u8, 42u8);\n  assert_eq!(-1i8 as u8, 255u8);\n  assert_eq!(255u8 as i8, -1i8);\n  assert_eq!(-1i16 as u16, 65535u16);\n  ```\n\n* Casting from a larger integer to a smaller integer (e.g. u32 -> u8) will\n  truncate\n\n  ```rust\n  assert_eq!(42u16 as u8, 42u8);\n  assert_eq!(1234u16 as u8, 210u8);\n  assert_eq!(0xabcdu16 as u8, 0xcdu8);\n\n  assert_eq!(-42i16 as i8, -42i8);\n  assert_eq!(1234u16 as i8, -46i8);\n  assert_eq!(0xabcdi32 as i8, -51i8);\n  ```\n\n* Casting from a smaller integer to a larger integer (e.g. u8 -> u32) will\n    * zero-extend if the source is unsigned\n    * sign-extend if the source is signed\n\n  ```rust\n  assert_eq!(42i8 as i16, 42i16);\n  assert_eq!(-17i8 as i16, -17i16);\n  assert_eq!(0b1000_1010u8 as u16, 0b0000_0000_1000_1010u16, \"Zero-extend\");\n  assert_eq!(0b0000_1010i8 as i16, 0b0000_0000_0000_1010i16, \"Sign-extend 0\");\n  assert_eq!(0b1000_1010u8 as i8 as i16, 0b1111_1111_1000_1010u16 as i16, \"Sign-extend 1\");\n  ```\n\n* Casting from a float to an integer will round the float towards zero\n    * `NaN` will return `0`\n    * Values larger than the maximum integer value, including `INFINITY`, will saturate to the maximum value of the integer type.\n    * Values smaller than the minimum integer value, including `NEG_INFINITY`, will saturate to the minimum value of the integer type.\n\n  ```rust\n  assert_eq!(42.9f32 as i32, 42);\n  assert_eq!(-42.9f32 as i32, -42);\n  assert_eq!(42_000_000f32 as i32, 42_000_000);\n  assert_eq!(std::f32::NAN as i32, 0);\n  assert_eq!(1_000_000_000_000_000f32 as i32, 0x7fffffffi32);\n  assert_eq!(std::f32::NEG_INFINITY as i32, -0x80000000i32);\n  ```\n\n* Casting from an integer to float will produce the closest possible float \\*\n    * if necessary, rounding is according to `roundTiesToEven` mode \\*\\*\\*\n    * on overflow, infinity (of the same sign as the input) is produced\n    * note: with the current set of numeric types, overflow can only happen\n      on `u128 as f32` for values greater or equal to `f32::MAX + (0.5 ULP)`\n\n  ```rust\n  assert_eq!(1337i32 as f32, 1337f32);\n  assert_eq!(123_456_789i32 as f32, 123_456_790f32, \"Rounded\");\n  assert_eq!(0xffffffff_ffffffff_ffffffff_ffffffff_u128 as f32, std::f32::INFINITY);\n  ```\n\n* Casting from an f32 to an f64 is perfect and lossless\n\n  ```rust\n  assert_eq!(1_234.5f32 as f64, 1_234.5f64);\n  assert_eq!(std::f32::INFINITY as f64, std::f64::INFINITY);\n  assert!((std::f32::NAN as f64).is_nan());\n  ```\n\n* Casting from an f64 to an f32 will produce the closest possible f32 \\*\\*\n    * if necessary, rounding is according to `roundTiesToEven` mode \\*\\*\\*\n    * on overflow, infinity (of the same sign as the input) is produced\n\n  ```rust\n  assert_eq!(1_234.5f64 as f32, 1_234.5f32);\n  assert_eq!(1_234_567_891.123f64 as f32, 1_234_567_890f32, \"Rounded\");\n  assert_eq!(std::f64::INFINITY as f32, std::f32::INFINITY);\n  assert!((std::f64::NAN as f32).is_nan());\n  ```\n\n\\* if integer-to-float casts with this rounding mode and overflow behavior are\nnot supported natively by the hardware, these casts will likely be slower than\nexpected.\n\n\\*\\* if f64-to-f32 casts with this rounding mode and overflow behavior are not\nsupported natively by the hardware, these casts will likely be slower than\nexpected.\n\n\\*\\*\\* as defined in IEEE 754-2008 &sect;4.3.1: pick the nearest floating point\nnumber, preferring the one with an even least significant digit if exactly\nhalfway between two floating point numbers.",
      "parent_id": null,
      "paragraphs": {
        "expr.as.numeric.int-same-size": "* Casting between two integers of the same size (e.g. i32 -> u32) is a no-op\n  (Rust uses 2's complement for negative values of fixed integers)\n\n  ```rust\n  assert_eq!(42i8 as u8, 42u8);\n  assert_eq!(-1i8 as u8, 255u8);\n  assert_eq!(255u8 as i8, -1i8);\n  assert_eq!(-1i16 as u16, 65535u16);\n  ```",
        "expr.as.numeric.int-truncation": "* Casting from a larger integer to a smaller integer (e.g. u32 -> u8) will\n  truncate\n\n  ```rust\n  assert_eq!(42u16 as u8, 42u8);\n  assert_eq!(1234u16 as u8, 210u8);\n  assert_eq!(0xabcdu16 as u8, 0xcdu8);\n\n  assert_eq!(-42i16 as i8, -42i8);\n  assert_eq!(1234u16 as i8, -46i8);\n  assert_eq!(0xabcdi32 as i8, -51i8);\n  ```",
        "expr.as.numeric.int-extension": "* Casting from a smaller integer to a larger integer (e.g. u8 -> u32) will\n    * zero-extend if the source is unsigned\n    * sign-extend if the source is signed\n\n  ```rust\n  assert_eq!(42i8 as i16, 42i16);\n  assert_eq!(-17i8 as i16, -17i16);\n  assert_eq!(0b1000_1010u8 as u16, 0b0000_0000_1000_1010u16, \"Zero-extend\");\n  assert_eq!(0b0000_1010i8 as i16, 0b0000_0000_0000_1010i16, \"Sign-extend 0\");\n  assert_eq!(0b1000_1010u8 as i8 as i16, 0b1111_1111_1000_1010u16 as i16, \"Sign-extend 1\");\n  ```",
        "expr.as.numeric.float-as-int": "* Casting from a float to an integer will round the float towards zero\n    * `NaN` will return `0`\n    * Values larger than the maximum integer value, including `INFINITY`, will saturate to the maximum value of the integer type.\n    * Values smaller than the minimum integer value, including `NEG_INFINITY`, will saturate to the minimum value of the integer type.\n\n  ```rust\n  assert_eq!(42.9f32 as i32, 42);\n  assert_eq!(-42.9f32 as i32, -42);\n  assert_eq!(42_000_000f32 as i32, 42_000_000);\n  assert_eq!(std::f32::NAN as i32, 0);\n  assert_eq!(1_000_000_000_000_000f32 as i32, 0x7fffffffi32);\n  assert_eq!(std::f32::NEG_INFINITY as i32, -0x80000000i32);\n  ```",
        "expr.as.numeric.int-as-float": "* Casting from an integer to float will produce the closest possible float \\*\n    * if necessary, rounding is according to `roundTiesToEven` mode \\*\\*\\*\n    * on overflow, infinity (of the same sign as the input) is produced\n    * note: with the current set of numeric types, overflow can only happen\n      on `u128 as f32` for values greater or equal to `f32::MAX + (0.5 ULP)`\n\n  ```rust\n  assert_eq!(1337i32 as f32, 1337f32);\n  assert_eq!(123_456_789i32 as f32, 123_456_790f32, \"Rounded\");\n  assert_eq!(0xffffffff_ffffffff_ffffffff_ffffffff_u128 as f32, std::f32::INFINITY);\n  ```",
        "expr.as.numeric.float-widening": "* Casting from an f32 to an f64 is perfect and lossless\n\n  ```rust\n  assert_eq!(1_234.5f32 as f64, 1_234.5f64);\n  assert_eq!(std::f32::INFINITY as f64, std::f64::INFINITY);\n  assert!((std::f32::NAN as f64).is_nan());\n  ```",
        "expr.as.numeric.float-narrowing": "* Casting from an f64 to an f32 will produce the closest possible f32 \\*\\*\n    * if necessary, rounding is according to `roundTiesToEven` mode \\*\\*\\*\n    * on overflow, infinity (of the same sign as the input) is produced\n\n  ```rust\n  assert_eq!(1_234.5f64 as f32, 1_234.5f32);\n  assert_eq!(1_234_567_891.123f64 as f32, 1_234_567_890f32, \"Rounded\");\n  assert_eq!(std::f64::INFINITY as f32, std::f32::INFINITY);\n  assert!((std::f64::NAN as f32).is_nan());\n  ```\n\n\\* if integer-to-float casts with this rounding mode and overflow behavior are\nnot supported natively by the hardware, these casts will likely be slower than\nexpected.\n\n\\*\\* if f64-to-f32 casts with this rounding mode and overflow behavior are not\nsupported natively by the hardware, these casts will likely be slower than\nexpected.\n\n\\*\\*\\* as defined in IEEE 754-2008 &sect;4.3.1: pick the nearest floating point\nnumber, preferring the one with an even least significant digit if exactly\nhalfway between two floating point numbers."
      }
    },
    {
      "id": "expr.as.enum",
      "title": "Enum cast",
      "level": 4,
      "content": "Casts an enum to its discriminant, then uses a numeric cast if needed.\nCasting is limited to the following kinds of enumerations:\n\n* [Unit-only enums]\n* [Field-less enums] without [explicit discriminants], or where only unit-variants have explicit discriminants\n\nenum Enum { A, B, C }\nassert_eq!(Enum::A as i32, 0);\nassert_eq!(Enum::B as i32, 1);\nassert_eq!(Enum::C as i32, 2);\n\nCasting is not allowed if the enum implements [`Drop`].",
      "parent_id": null,
      "paragraphs": {
        "expr.as.enum.discriminant": "Casts an enum to its discriminant, then uses a numeric cast if needed.\nCasting is limited to the following kinds of enumerations:\n\n* [Unit-only enums]\n* [Field-less enums] without [explicit discriminants], or where only unit-variants have explicit discriminants\n\nenum Enum { A, B, C }\nassert_eq!(Enum::A as i32, 0);\nassert_eq!(Enum::B as i32, 1);\nassert_eq!(Enum::C as i32, 2);",
        "expr.as.enum.no-drop": "Casting is not allowed if the enum implements [`Drop`]."
      }
    },
    {
      "id": "expr.as.bool-char-as-int",
      "title": "Primitive to integer cast",
      "level": 4,
      "content": "* `false` casts to `0`, `true` casts to `1`\n* `char` casts to the value of the code point, then uses a numeric cast if needed.\n\nassert_eq!(false as i32, 0);\nassert_eq!(true as i32, 1);\nassert_eq!('A' as i32, 65);\nassert_eq!('\u00d6' as i32, 214);",
      "parent_id": null,
      "paragraphs": {
        "expr.as.bool-char-as-int": "* `false` casts to `0`, `true` casts to `1`\n* `char` casts to the value of the code point, then uses a numeric cast if needed.\n\nassert_eq!(false as i32, 0);\nassert_eq!(true as i32, 1);\nassert_eq!('A' as i32, 65);\nassert_eq!('\u00d6' as i32, 214);"
      }
    },
    {
      "id": "expr.as.u8-as-char",
      "title": "`u8` to `char` cast",
      "level": 4,
      "content": "Casts to the `char` with the corresponding code point.\n\nassert_eq!(65u8 as char, 'A');\nassert_eq!(214u8 as char, '\u00d6');",
      "parent_id": null,
      "paragraphs": {
        "expr.as.u8-as-char": "Casts to the `char` with the corresponding code point.\n\nassert_eq!(65u8 as char, 'A');\nassert_eq!(214u8 as char, '\u00d6');"
      }
    },
    {
      "id": "expr.as.pointer-as-int",
      "title": "Pointer to address cast",
      "level": 4,
      "content": "Casting from a raw pointer to an integer produces the machine address of the referenced memory.\nIf the integer type is smaller than the pointer type, the address may be truncated; using `usize` avoids this.",
      "parent_id": null,
      "paragraphs": {
        "expr.as.pointer-as-int": "Casting from a raw pointer to an integer produces the machine address of the referenced memory.\nIf the integer type is smaller than the pointer type, the address may be truncated; using `usize` avoids this."
      }
    },
    {
      "id": "expr.as.int-as-pointer",
      "title": "Address to pointer cast",
      "level": 4,
      "content": "Casting from an integer to a raw pointer interprets the integer as a memory address and produces a pointer referencing that memory.\n\n> [!WARNING]\n> This interacts with the Rust memory model, which is still under development.\n> A pointer obtained from this cast may suffer additional restrictions even if it is bitwise equal to a valid pointer.\n> Dereferencing such a pointer may be [undefined behavior] if aliasing rules are not followed.\n\nA trivial example of sound address arithmetic:\n\nlet mut values: [i32; 2] = [1, 2];\nlet p1: *mut i32 = values.as_mut_ptr();\nlet first_address = p1 as usize;\nlet second_address = first_address + 4; // 4 == size_of::<i32>()\nlet p2 = second_address as *mut i32;\nunsafe {\n    *p2 += 1;\n}\nassert_eq!(values[1], 3);",
      "parent_id": null,
      "paragraphs": {
        "expr.as.int-as-pointer": "Casting from an integer to a raw pointer interprets the integer as a memory address and produces a pointer referencing that memory.\n\n> [!WARNING]\n> This interacts with the Rust memory model, which is still under development.\n> A pointer obtained from this cast may suffer additional restrictions even if it is bitwise equal to a valid pointer.\n> Dereferencing such a pointer may be [undefined behavior] if aliasing rules are not followed.\n\nA trivial example of sound address arithmetic:\n\nlet mut values: [i32; 2] = [1, 2];\nlet p1: *mut i32 = values.as_mut_ptr();\nlet first_address = p1 as usize;\nlet second_address = first_address + 4; // 4 == size_of::<i32>()\nlet p2 = second_address as *mut i32;\nunsafe {\n    *p2 += 1;\n}\nassert_eq!(values[1], 3);"
      }
    },
    {
      "id": "expr.as.pointer",
      "title": "Pointer-to-pointer cast",
      "level": 4,
      "content": "`*const T` / `*mut T` can be cast to `*const U` / `*mut U` with the following behavior:\n\n- If `T` and `U` are both sized, the pointer is returned unchanged.\n\n- If `T` and `U` are both unsized, the pointer is also returned unchanged.\n  In particular, the metadata is preserved exactly.\n\n  For instance, a cast from `*const [T]` to `*const [U]` preserves the number of elements.\n  Note that, as a consequence, such casts do not necessarily preserve the size of the pointer's referent\n  (e.g., casting `*const [u16]` to `*const [u8]` will result in a raw pointer which refers to an object of half the size of the original).\n  The same holds for `str` and any compound type whose unsized tail is a slice type,\n  such as `struct Foo(i32, [u8])` or `(u64, Foo)`.\n\n- If `T` is unsized and `U` is sized, the cast discards all metadata that completes the wide pointer `T` and produces a thin pointer `U` consisting of the data part of the unsized pointer.",
      "parent_id": null,
      "paragraphs": {
        "expr.as.pointer.behavior": "`*const T` / `*mut T` can be cast to `*const U` / `*mut U` with the following behavior:",
        "expr.as.pointer.sized": "- If `T` and `U` are both sized, the pointer is returned unchanged.",
        "expr.as.pointer.unsized": "- If `T` and `U` are both unsized, the pointer is also returned unchanged.\n  In particular, the metadata is preserved exactly.\n\n  For instance, a cast from `*const [T]` to `*const [U]` preserves the number of elements.\n  Note that, as a consequence, such casts do not necessarily preserve the size of the pointer's referent\n  (e.g., casting `*const [u16]` to `*const [u8]` will result in a raw pointer which refers to an object of half the size of the original).\n  The same holds for `str` and any compound type whose unsized tail is a slice type,\n  such as `struct Foo(i32, [u8])` or `(u64, Foo)`.",
        "expr.as.pointer.discard-metadata": "- If `T` is unsized and `U` is sized, the cast discards all metadata that completes the wide pointer `T` and produces a thin pointer `U` consisting of the data part of the unsized pointer."
      }
    },
    {
      "id": "expr.assign",
      "title": "Assignment expressions",
      "level": 4,
      "content": ",expressions\nAssignmentExpression -> Expression `=` Expression\n\nAn *assignment expression* moves a value into a specified place.\n\nAn assignment expression consists of a [mutable] [assignee expression], the *assignee operand*, followed by an equals sign (`=`) and a [value expression], the *assigned value operand*.\n\nIn its most basic form, an assignee expression is a [place expression], and we discuss this case first.\n\nThe more general case of destructuring assignment is discussed below, but this case always decomposes into sequential assignments to place expressions, which may be considered the more fundamental case.",
      "parent_id": null,
      "paragraphs": {
        "expr.assign.syntax": ",expressions\nAssignmentExpression -> Expression `=` Expression",
        "expr.assign.intro": "An *assignment expression* moves a value into a specified place.",
        "expr.assign.assignee": "An assignment expression consists of a [mutable] [assignee expression], the *assignee operand*, followed by an equals sign (`=`) and a [value expression], the *assigned value operand*.",
        "expr.assign.behavior-basic": "In its most basic form, an assignee expression is a [place expression], and we discuss this case first.",
        "expr.assign.behavior-destructuring": "The more general case of destructuring assignment is discussed below, but this case always decomposes into sequential assignments to place expressions, which may be considered the more fundamental case."
      }
    },
    {
      "id": "expr.assign.basic",
      "title": "Basic assignments",
      "level": 2,
      "content": "Evaluating assignment expressions begins by evaluating its operands.\nThe assigned value operand is evaluated first, followed by the assignee expression.\n\nFor destructuring assignment, subexpressions of the assignee expression are evaluated left-to-right.\n\n> [!NOTE]\n> This is different than other expressions in that the right operand is evaluated before the left one.\n\nIt then has the effect of first [dropping] the value at the assigned place, unless the place is an uninitialized local variable or an uninitialized field of a local variable.\n\nNext it either [copies or moves] the assigned value to the assigned place.\n\nAn assignment expression always produces the unit value.\n\nExample:\n\nlet mut x = 0;\nlet y = 0;\nx = y;",
      "parent_id": null,
      "paragraphs": {
        "expr.assign.evaluation-order": "Evaluating assignment expressions begins by evaluating its operands.\nThe assigned value operand is evaluated first, followed by the assignee expression.",
        "expr.assign.destructuring-order": "For destructuring assignment, subexpressions of the assignee expression are evaluated left-to-right.\n\n> [!NOTE]\n> This is different than other expressions in that the right operand is evaluated before the left one.",
        "expr.assign.drop-target": "It then has the effect of first [dropping] the value at the assigned place, unless the place is an uninitialized local variable or an uninitialized field of a local variable.",
        "expr.assign.behavior": "Next it either [copies or moves] the assigned value to the assigned place.",
        "expr.assign.result": "An assignment expression always produces the unit value.\n\nExample:\n\nlet mut x = 0;\nlet y = 0;\nx = y;"
      }
    },
    {
      "id": "expr.assign.destructure",
      "title": "Destructuring assignments",
      "level": 3,
      "content": "Destructuring assignment is a counterpart to destructuring pattern matches for variable declaration, permitting assignment to complex values, such as tuples or structs.\nFor instance, we may swap two mutable variables:\n\nlet (mut a, mut b) = (0, 1);\n// Swap `a` and `b` using destructuring assignment.\n(b, a) = (a, b);\n\nIn contrast to destructuring declarations using `let`, patterns may not appear on the left-hand side of an assignment due to syntactic ambiguities.\nInstead, a group of expressions that correspond to patterns are designated to be assignee expressions, and permitted on the left-hand side of an assignment.\nAssignee expressions are then desugared to pattern matches followed by sequential assignment.\n\nThe desugared patterns must be irrefutable: in particular, this means that only slice patterns whose length is known at compile-time, and the trivial slice `[..]`, are permitted for destructuring assignment.\n\nThe desugaring method is straightforward, and is illustrated best by example.\n\n# struct Struct { x: u32, y: u32 }\n# let (mut a, mut b) = (0, 0);\n(a, b) = (3, 4);\n\n[a, b] = [3, 4];\n\nStruct { x: a, y: b } = Struct { x: 3, y: 4};\n\n// desugars to:\n\n{\n    let (_a, _b) = (3, 4);\n    a = _a;\n    b = _b;\n}\n\n{\n    let [_a, _b] = [3, 4];\n    a = _a;\n    b = _b;\n}\n\n{\n    let Struct { x: _a, y: _b } = Struct { x: 3, y: 4};\n    a = _a;\n    b = _b;\n}\n\nIdentifiers are not forbidden from being used multiple times in a single assignee expression.\n\n[Underscore expressions] and empty [range expressions] may be used to ignore certain values, without binding them.\n\nNote that default binding modes do not apply for the desugared expression.\n\n> [!NOTE]\n> The desugaring restricts the [temporary scope] of the assigned value operand (the RHS) of a destructuring assignment.\n>\n> In a basic assignment, the [temporary] is dropped at the end of the enclosing temporary scope. Below, that's the statement. Therefore, the assignment and use is allowed.\n>\n> ```rust\n> # fn temp() {}\n> fn f<T>(x: T) -> T { x }\n> let x;\n> (x = f(&temp()), x); // OK\n> ```\n>\n> Conversely, in a destructuring assignment, the temporary is dropped at the end of the `let` statement in the desugaring. As that happens before we try to assign to `x`, below, it fails.\n>\n> ```rust,compile_fail,E0716\n> # fn temp() {}\n> # fn f<T>(x: T) -> T { x }\n> # let x;\n> [x] = [f(&temp())]; // ERROR\n> ```\n>\n> This desugars to:\n>\n> ```rust,compile_fail,E0716\n> # fn temp() {}\n> # fn f<T>(x: T) -> T { x }\n> # let x;\n> {\n>     let [_x] = [f(&temp())];\n>     //                     ^\n>     //      The temporary is dropped here.\n>     x = _x; // ERROR\n> }\n> ```\n\n> [!NOTE]\n> Due to the desugaring, the assigned value operand (the RHS) of a destructuring assignment is an [extending expression] within a newly-introduced block.\n>\n> Below, because the [temporary scope] is extended to the end of this introduced block, the assignment is allowed.\n>\n> ```rust\n> # fn temp() {}\n> # let x;\n> [x] = [&temp()]; // OK\n> ```\n>\n> This desugars to:\n>\n> ```rust\n> # fn temp() {}\n> # let x;\n> { let [_x] = [&temp()]; x = _x; } // OK\n> ```\n>\n> However, if we try to use `x`, even within the same statement, we'll get an error because the [temporary] is dropped at the end of this introduced block.\n>\n> ```rust,compile_fail,E0716\n> # fn temp() {}\n> # let x;\n> ([x] = [&temp()], x); // ERROR\n> ```\n>\n> This desugars to:\n>\n> ```rust,compile_fail,E0716\n> # fn temp() {}\n> # let x;\n> (\n>     {\n>         let [_x] = [&temp()];\n>         x = _x;\n>     }, // <-- The temporary is dropped here.\n>     x, // ERROR\n> );\n> ```",
      "parent_id": null,
      "paragraphs": {
        "expr.assign.destructure.intro": "Destructuring assignment is a counterpart to destructuring pattern matches for variable declaration, permitting assignment to complex values, such as tuples or structs.\nFor instance, we may swap two mutable variables:\n\nlet (mut a, mut b) = (0, 1);\n// Swap `a` and `b` using destructuring assignment.\n(b, a) = (a, b);",
        "expr.assign.destructure.assignee": "In contrast to destructuring declarations using `let`, patterns may not appear on the left-hand side of an assignment due to syntactic ambiguities.\nInstead, a group of expressions that correspond to patterns are designated to be assignee expressions, and permitted on the left-hand side of an assignment.\nAssignee expressions are then desugared to pattern matches followed by sequential assignment.",
        "expr.assign.destructure.irrefutable": "The desugared patterns must be irrefutable: in particular, this means that only slice patterns whose length is known at compile-time, and the trivial slice `[..]`, are permitted for destructuring assignment.\n\nThe desugaring method is straightforward, and is illustrated best by example.\n\n# struct Struct { x: u32, y: u32 }\n# let (mut a, mut b) = (0, 0);\n(a, b) = (3, 4);\n\n[a, b] = [3, 4];\n\nStruct { x: a, y: b } = Struct { x: 3, y: 4};\n\n// desugars to:\n\n{\n    let (_a, _b) = (3, 4);\n    a = _a;\n    b = _b;\n}\n\n{\n    let [_a, _b] = [3, 4];\n    a = _a;\n    b = _b;\n}\n\n{\n    let Struct { x: _a, y: _b } = Struct { x: 3, y: 4};\n    a = _a;\n    b = _b;\n}",
        "expr.assign.destructure.repeat-ident": "Identifiers are not forbidden from being used multiple times in a single assignee expression.",
        "expr.assign.destructure.discard-value": "[Underscore expressions] and empty [range expressions] may be used to ignore certain values, without binding them.",
        "expr.assign.destructure.default-binding": "Note that default binding modes do not apply for the desugared expression.",
        "expr.assign.destructure.tmp-scopes": "> [!NOTE]\n> The desugaring restricts the [temporary scope] of the assigned value operand (the RHS) of a destructuring assignment.\n>\n> In a basic assignment, the [temporary] is dropped at the end of the enclosing temporary scope. Below, that's the statement. Therefore, the assignment and use is allowed.\n>\n> ```rust\n> # fn temp() {}\n> fn f<T>(x: T) -> T { x }\n> let x;\n> (x = f(&temp()), x); // OK\n> ```\n>\n> Conversely, in a destructuring assignment, the temporary is dropped at the end of the `let` statement in the desugaring. As that happens before we try to assign to `x`, below, it fails.\n>\n> ```rust,compile_fail,E0716\n> # fn temp() {}\n> # fn f<T>(x: T) -> T { x }\n> # let x;\n> [x] = [f(&temp())]; // ERROR\n> ```\n>\n> This desugars to:\n>\n> ```rust,compile_fail,E0716\n> # fn temp() {}\n> # fn f<T>(x: T) -> T { x }\n> # let x;\n> {\n>     let [_x] = [f(&temp())];\n>     //                     ^\n>     //      The temporary is dropped here.\n>     x = _x; // ERROR\n> }\n> ```",
        "expr.assign.destructure.tmp-ext": "> [!NOTE]\n> Due to the desugaring, the assigned value operand (the RHS) of a destructuring assignment is an [extending expression] within a newly-introduced block.\n>\n> Below, because the [temporary scope] is extended to the end of this introduced block, the assignment is allowed.\n>\n> ```rust\n> # fn temp() {}\n> # let x;\n> [x] = [&temp()]; // OK\n> ```\n>\n> This desugars to:\n>\n> ```rust\n> # fn temp() {}\n> # let x;\n> { let [_x] = [&temp()]; x = _x; } // OK\n> ```\n>\n> However, if we try to use `x`, even within the same statement, we'll get an error because the [temporary] is dropped at the end of this introduced block.\n>\n> ```rust,compile_fail,E0716\n> # fn temp() {}\n> # let x;\n> ([x] = [&temp()], x); // ERROR\n> ```\n>\n> This desugars to:\n>\n> ```rust,compile_fail,E0716\n> # fn temp() {}\n> # let x;\n> (\n>     {\n>         let [_x] = [&temp()];\n>         x = _x;\n>     }, // <-- The temporary is dropped here.\n>     x, // ERROR\n> );\n> ```"
      }
    },
    {
      "id": "expr.compound-assign",
      "title": "Compound assignment expressions",
      "level": 1,
      "content": ",expressions\nCompoundAssignmentExpression ->\n      Expression `+=` Expression\n    | Expression `-=` Expression\n    | Expression `*=` Expression\n    | Expression `/=` Expression\n    | Expression `%=` Expression\n    | Expression `&=` Expression\n    | Expression `|=` Expression\n    | Expression `^=` Expression\n    | Expression `<<=` Expression\n    | Expression `>>=` Expression\n\n*Compound assignment expressions* combine arithmetic and logical binary operators with assignment expressions.\n\nFor example:\n\nlet mut x = 5;\nx += 1;\nassert!(x == 6);\n\nThe syntax of compound assignment is a [mutable] [place expression], the *assigned operand*, then one of the operators followed by an `=` as a single token (no whitespace), and then a [value expression], the *modifying operand*.\n\nUnlike other place operands, the assigned place operand must be a place expression.\n\nAttempting to use a value expression is a compiler error rather than promoting it to a temporary.\n\nEvaluation of compound assignment expressions depends on the types of the operands.\n\nIf the types of both operands are known, prior to monomorphization, to be primitive, the right hand side is evaluated first, the left hand side is evaluated next, and the place given by the evaluation of the left hand side is mutated by applying the operator to the values of both sides.\n\n# use core::{num::Wrapping, ops::AddAssign};\n#\ntrait Equate {}\nimpl<T> Equate for (T, T) {}\n\nfn f1(x: (u8,)) {\n    let mut order = vec![];\n    // The RHS is evaluated first as both operands are of primitive\n    // type.\n    { order.push(2); x }.0 += { order.push(1); x }.0;\n    assert!(order.is_sorted());\n}\n\nfn f2(x: (Wrapping<u8>,)) {\n    let mut order = vec![];\n    // The LHS is evaluated first as `Wrapping<_>` is not a primitive\n    // type.\n    { order.push(1); x }.0 += { order.push(2); (0u8,) }.0;\n    assert!(order.is_sorted());\n}\n\nfn f3<T: AddAssign<u8> + Copy>(x: (T,)) where (T, u8): Equate {\n    let mut order = vec![];\n    // The LHS is evaluated first as one of the operands is a generic\n    // parameter, even though that generic parameter can be unified\n    // with a primitive type due to the where clause bound.\n    { order.push(1); x }.0 += { order.push(2); (0u8,) }.0;\n    assert!(order.is_sorted());\n}\n\nfn main() {\n    f1((0u8,));\n    f2((Wrapping(0u8),));\n    // We supply a primitive type as the generic argument, but this\n    // does not affect the evaluation order in `f3` when\n    // monomorphized.\n    f3::<u8>((0u8,));\n}\n\n> [!NOTE]\n> This is unusual. Elsewhere left to right evaluation is the norm.\n>\n> See the [eval order test] for more examples.\n\nOtherwise, this expression is syntactic sugar for using the corresponding trait for the operator (see [expr.arith-logic.behavior]) and calling its method with the left hand side as the [receiver] and the right hand side as the next argument.\n\nFor example, the following two statements are equivalent:\n\n# use std::ops::AddAssign;\nfn f<T: AddAssign + Copy>(mut x: T, y: T) {\n    x += y; // Statement 1.\n    x.add_assign(y); // Statement 2.\n}\n\n> [!NOTE]\n> Surprisingly, desugaring this further to a fully qualified method call is not equivalent, as there is special borrow checker behavior when the mutable reference to the first operand is taken via [autoref].\n>\n> ```rust\n> # use std::ops::AddAssign;\n> fn f<T: AddAssign + Copy>(mut x: T) {\n>     // Here we used `x` as both the LHS and the RHS. Because the\n>     // mutable borrow of the LHS needed to call the trait method\n>     // is taken implicitly by autoref, this is OK.\n>     x += x; //~ OK\n>     x.add_assign(x); //~ OK\n> }\n> ```\n>\n> ```rust,compile_fail,E0503\n> # use std::ops::AddAssign;\n> fn f<T: AddAssign + Copy>(mut x: T) {\n>     // We can't desugar the above to the below, as once we take the\n>     // mutable borrow of `x` to pass the first argument, we can't\n>     // pass `x` by value in the second argument because the mutable\n>     // reference is still live.\n>     <T as AddAssign>::add_assign(&mut x, x);\n>     //~^ ERROR cannot use `x` because it was mutably borrowed\n> }\n> ```\n>\n> ```rust,compile_fail,E0503\n> # use std::ops::AddAssign;\n> fn f<T: AddAssign + Copy>(mut x: T) {\n>     // As above.\n>     (&mut x).add_assign(x);\n>     //~^ ERROR cannot use `x` because it was mutably borrowed\n> }\n> ```\n\nAs with normal assignment expressions, compound assignment expressions always produce the unit value.\n\n> [!WARNING]\n> Avoid writing code that depends on the evaluation order of operands in compound assignments as it can be unusual and surprising.\n\n[`Try`]: core::ops::Try\n[autoref]: expr.method.candidate-receivers-refs\n[copies or moves]: ../expressions.md#moved-and-copied-types\n[dropping]: ../destructors.md\n[eval order test]: https://github.com/rust-lang/rust/blob/1.58.0/src/test/ui/expr/compound-assignment/eval-order.rs\n[explicit discriminants]: ../items/enumerations.md#explicit-discriminants\n[extending expression]: destructors.scope.lifetime-extension.exprs\n[field-less enums]: ../items/enumerations.md#field-less-enum\n[grouped expression]: grouped-expr.md\n[literal expression]: literal-expr.md#integer-literal-expressions\n[logical and]: ../types/boolean.md#logical-and\n[logical not]: ../types/boolean.md#logical-not\n[logical or]: ../types/boolean.md#logical-or\n[logical xor]: ../types/boolean.md#logical-xor\n[mutable]: ../expressions.md#mutability\n[place expression]: ../expressions.md#place-expressions-and-value-expressions\n[assignee expression]: ../expressions.md#place-expressions-and-value-expressions\n[undefined behavior]: ../behavior-considered-undefined.md\n[unit]: ../types/tuple.md\n[Unit-only enums]: ../items/enumerations.md#unit-only-enum\n[value expression]: ../expressions.md#place-expressions-and-value-expressions\n[temporary lifetime extension]: destructors.scope.lifetime-extension\n[temporary scope]: destructors.scope.temporary\n[temporary value]: ../expressions.md#temporaries\n[float-float]: https://github.com/rust-lang/rust/issues/15536\n[Function pointer]: ../types/function-pointer.md\n[Function item]: ../types/function-item.md\n[receiver]: expr.method.intro\n[temporary]: expr.temporary\n[undefined behavior]: ../behavior-considered-undefined.md\n[Underscore expressions]: ./underscore-expr.md\n[range expressions]: ./range-expr.md",
      "parent_id": null,
      "paragraphs": {
        "expr.compound-assign.syntax": ",expressions\nCompoundAssignmentExpression ->\n      Expression `+=` Expression\n    | Expression `-=` Expression\n    | Expression `*=` Expression\n    | Expression `/=` Expression\n    | Expression `%=` Expression\n    | Expression `&=` Expression\n    | Expression `|=` Expression\n    | Expression `^=` Expression\n    | Expression `<<=` Expression\n    | Expression `>>=` Expression",
        "expr.compound-assign.intro": "*Compound assignment expressions* combine arithmetic and logical binary operators with assignment expressions.\n\nFor example:\n\nlet mut x = 5;\nx += 1;\nassert!(x == 6);\n\nThe syntax of compound assignment is a [mutable] [place expression], the *assigned operand*, then one of the operators followed by an `=` as a single token (no whitespace), and then a [value expression], the *modifying operand*.",
        "expr.compound-assign.place": "Unlike other place operands, the assigned place operand must be a place expression.",
        "expr.compound-assign.no-value": "Attempting to use a value expression is a compiler error rather than promoting it to a temporary.",
        "expr.compound-assign.operand-order": "Evaluation of compound assignment expressions depends on the types of the operands.",
        "expr.compound-assign.primitives": "If the types of both operands are known, prior to monomorphization, to be primitive, the right hand side is evaluated first, the left hand side is evaluated next, and the place given by the evaluation of the left hand side is mutated by applying the operator to the values of both sides.\n\n# use core::{num::Wrapping, ops::AddAssign};\n#\ntrait Equate {}\nimpl<T> Equate for (T, T) {}\n\nfn f1(x: (u8,)) {\n    let mut order = vec![];\n    // The RHS is evaluated first as both operands are of primitive\n    // type.\n    { order.push(2); x }.0 += { order.push(1); x }.0;\n    assert!(order.is_sorted());\n}\n\nfn f2(x: (Wrapping<u8>,)) {\n    let mut order = vec![];\n    // The LHS is evaluated first as `Wrapping<_>` is not a primitive\n    // type.\n    { order.push(1); x }.0 += { order.push(2); (0u8,) }.0;\n    assert!(order.is_sorted());\n}\n\nfn f3<T: AddAssign<u8> + Copy>(x: (T,)) where (T, u8): Equate {\n    let mut order = vec![];\n    // The LHS is evaluated first as one of the operands is a generic\n    // parameter, even though that generic parameter can be unified\n    // with a primitive type due to the where clause bound.\n    { order.push(1); x }.0 += { order.push(2); (0u8,) }.0;\n    assert!(order.is_sorted());\n}\n\nfn main() {\n    f1((0u8,));\n    f2((Wrapping(0u8),));\n    // We supply a primitive type as the generic argument, but this\n    // does not affect the evaluation order in `f3` when\n    // monomorphized.\n    f3::<u8>((0u8,));\n}\n\n> [!NOTE]\n> This is unusual. Elsewhere left to right evaluation is the norm.\n>\n> See the [eval order test] for more examples.",
        "expr.compound-assign.trait": "Otherwise, this expression is syntactic sugar for using the corresponding trait for the operator (see [expr.arith-logic.behavior]) and calling its method with the left hand side as the [receiver] and the right hand side as the next argument.\n\nFor example, the following two statements are equivalent:\n\n# use std::ops::AddAssign;\nfn f<T: AddAssign + Copy>(mut x: T, y: T) {\n    x += y; // Statement 1.\n    x.add_assign(y); // Statement 2.\n}\n\n> [!NOTE]\n> Surprisingly, desugaring this further to a fully qualified method call is not equivalent, as there is special borrow checker behavior when the mutable reference to the first operand is taken via [autoref].\n>\n> ```rust\n> # use std::ops::AddAssign;\n> fn f<T: AddAssign + Copy>(mut x: T) {\n>     // Here we used `x` as both the LHS and the RHS. Because the\n>     // mutable borrow of the LHS needed to call the trait method\n>     // is taken implicitly by autoref, this is OK.\n>     x += x; //~ OK\n>     x.add_assign(x); //~ OK\n> }\n> ```\n>\n> ```rust,compile_fail,E0503\n> # use std::ops::AddAssign;\n> fn f<T: AddAssign + Copy>(mut x: T) {\n>     // We can't desugar the above to the below, as once we take the\n>     // mutable borrow of `x` to pass the first argument, we can't\n>     // pass `x` by value in the second argument because the mutable\n>     // reference is still live.\n>     <T as AddAssign>::add_assign(&mut x, x);\n>     //~^ ERROR cannot use `x` because it was mutably borrowed\n> }\n> ```\n>\n> ```rust,compile_fail,E0503\n> # use std::ops::AddAssign;\n> fn f<T: AddAssign + Copy>(mut x: T) {\n>     // As above.\n>     (&mut x).add_assign(x);\n>     //~^ ERROR cannot use `x` because it was mutably borrowed\n> }\n> ```",
        "expr.compound-assign.result": "As with normal assignment expressions, compound assignment expressions always produce the unit value.\n\n> [!WARNING]\n> Avoid writing code that depends on the evaluation order of operands in compound assignments as it can be unusual and surprising.\n\n[`Try`]: core::ops::Try\n[autoref]: expr.method.candidate-receivers-refs\n[copies or moves]: ../expressions.md#moved-and-copied-types\n[dropping]: ../destructors.md\n[eval order test]: https://github.com/rust-lang/rust/blob/1.58.0/src/test/ui/expr/compound-assignment/eval-order.rs\n[explicit discriminants]: ../items/enumerations.md#explicit-discriminants\n[extending expression]: destructors.scope.lifetime-extension.exprs\n[field-less enums]: ../items/enumerations.md#field-less-enum\n[grouped expression]: grouped-expr.md\n[literal expression]: literal-expr.md#integer-literal-expressions\n[logical and]: ../types/boolean.md#logical-and\n[logical not]: ../types/boolean.md#logical-not\n[logical or]: ../types/boolean.md#logical-or\n[logical xor]: ../types/boolean.md#logical-xor\n[mutable]: ../expressions.md#mutability\n[place expression]: ../expressions.md#place-expressions-and-value-expressions\n[assignee expression]: ../expressions.md#place-expressions-and-value-expressions\n[undefined behavior]: ../behavior-considered-undefined.md\n[unit]: ../types/tuple.md\n[Unit-only enums]: ../items/enumerations.md#unit-only-enum\n[value expression]: ../expressions.md#place-expressions-and-value-expressions\n[temporary lifetime extension]: destructors.scope.lifetime-extension\n[temporary scope]: destructors.scope.temporary\n[temporary value]: ../expressions.md#temporaries\n[float-float]: https://github.com/rust-lang/rust/issues/15536\n[Function pointer]: ../types/function-pointer.md\n[Function item]: ../types/function-item.md\n[receiver]: expr.method.intro\n[temporary]: expr.temporary\n[undefined behavior]: ../behavior-considered-undefined.md\n[Underscore expressions]: ./underscore-expr.md\n[range expressions]: ./range-expr.md"
      }
    },
    {
      "id": "expr.paren",
      "title": "Grouped expressions",
      "level": 1,
      "content": ",expressions\nGroupedExpression -> `(` Expression `)`\n\nA *parenthesized expression* wraps a single expression, evaluating to that expression.\nThe syntax for a parenthesized expression is a `(`, then an expression, called the *enclosed operand*, and then a `)`.\n\nParenthesized expressions evaluate to the value of the enclosed operand.\n\nUnlike other expressions, parenthesized expressions are both place expressions and value expressions.\nWhen the enclosed operand is a place expression, it is a place expression and when the enclosed operand is a value expression, it is a value expression.\n\nParentheses can be used to explicitly modify the precedence order of subexpressions within an expression.\n\nAn example of a parenthesized expression:\n\nlet x: i32 = 2 + 3 * 4; // not parenthesized\nlet y: i32 = (2 + 3) * 4; // parenthesized\nassert_eq!(x, 14);\nassert_eq!(y, 20);\n\nAn example of a necessary use of parentheses is when calling a function pointer that is a member of a struct:\n\n# struct A {\n#    f: fn() -> &'static str\n# }\n# impl A {\n#    fn f(&self) -> &'static str {\n#        \"The method f\"\n#    }\n# }\n# let a = A{f: || \"The field f\"};\n#\nassert_eq!( a.f (), \"The method f\");\nassert_eq!((a.f)(), \"The field f\");\n\n[place]: ../expressions.md#place-expressions-and-value-expressions",
      "parent_id": null,
      "paragraphs": {
        "expr.paren.syntax": ",expressions\nGroupedExpression -> `(` Expression `)`",
        "expr.paren.intro": "A *parenthesized expression* wraps a single expression, evaluating to that expression.\nThe syntax for a parenthesized expression is a `(`, then an expression, called the *enclosed operand*, and then a `)`.",
        "expr.paren.evaluation": "Parenthesized expressions evaluate to the value of the enclosed operand.",
        "expr.paren.place-or-value": "Unlike other expressions, parenthesized expressions are both place expressions and value expressions.\nWhen the enclosed operand is a place expression, it is a place expression and when the enclosed operand is a value expression, it is a value expression.",
        "expr.paren.override-precedence": "Parentheses can be used to explicitly modify the precedence order of subexpressions within an expression.\n\nAn example of a parenthesized expression:\n\nlet x: i32 = 2 + 3 * 4; // not parenthesized\nlet y: i32 = (2 + 3) * 4; // parenthesized\nassert_eq!(x, 14);\nassert_eq!(y, 20);\n\nAn example of a necessary use of parentheses is when calling a function pointer that is a member of a struct:\n\n# struct A {\n#    f: fn() -> &'static str\n# }\n# impl A {\n#    fn f(&self) -> &'static str {\n#        \"The method f\"\n#    }\n# }\n# let a = A{f: || \"The field f\"};\n#\nassert_eq!( a.f (), \"The method f\");\nassert_eq!((a.f)(), \"The field f\");\n\n[place]: ../expressions.md#place-expressions-and-value-expressions"
      }
    },
    {
      "id": "expr.array",
      "title": "Array and array index expressions",
      "level": 1,
      "content": "## Array expressions\n\n,expressions\nArrayExpression -> `[` ArrayElements? `]`\n\nArrayElements ->\n      Expression ( `,` Expression )* `,`?\n    | Expression `;` Expression\n\n*Array expressions* construct arrays.\nArray expressions come in two forms.\n\nThe first form lists out every value in the array.\n\nThe syntax for this form is a comma-separated list of expressions of uniform type enclosed in square brackets.\n\nThis produces an array containing each of these values in the order they are written.\n\nThe syntax for the second form is two expressions separated by a semicolon (`;`) enclosed in square brackets.\n\nThe expression before the `;` is called the *repeat operand*.\n\nThe expression after the `;` is called the *length operand*.\n\nThe length operand must either be an [inferred const] or be a [constant expression] of type `usize` (e.g. a [literal] or a [constant item]).\n\nconst C: usize = 1;\nlet _: [u8; C] = [0; 1]; // Literal.\nlet _: [u8; C] = [0; C]; // Constant item.\nlet _: [u8; C] = [0; _]; // Inferred const.\nlet _: [u8; C] = [0; (((_)))]; // Inferred const.\n\n> [!NOTE]\n> In an array expression, an [inferred const] is parsed as an expression but then semantically treated as a separate kind of [const generic argument].\n\nAn array expression of this form creates an array with the length of the value of the length operand with each element being a copy of the repeat operand.\nThat is, `[a; b]` creates an array containing `b` copies of the value of `a`.\n\nIf the length operand has a value greater than 1 then this requires the repeat operand to have a type that implements [`Copy`], to be a [const block expression], or to be a [path] to a constant item.\n\nWhen the repeat operand is a const block or a path to a constant item, it is evaluated the number of times specified in the length operand.\n\nIf that value is `0`, then the const block or constant item is not evaluated at all.\n\nFor expressions that are neither a const block nor a path to a constant item, it is evaluated exactly once, and then the result is copied the length operand's value times.\n\n[1, 2, 3, 4];\n[\"a\", \"b\", \"c\", \"d\"];\n[0; 128];              // array with 128 zeros\n[0u8, 0u8, 0u8, 0u8,];\n[[1, 0, 0], [0, 1, 0], [0, 0, 1]]; // 2D array\nconst EMPTY: Vec<i32> = Vec::new();\n[EMPTY; 2];",
      "parent_id": null,
      "paragraphs": {
        "expr.array": "## Array expressions",
        "expr.array.syntax": ",expressions\nArrayExpression -> `[` ArrayElements? `]`\n\nArrayElements ->\n      Expression ( `,` Expression )* `,`?\n    | Expression `;` Expression",
        "expr.array.constructor": "*Array expressions* construct arrays.\nArray expressions come in two forms.",
        "expr.array.array": "The first form lists out every value in the array.",
        "expr.array.array-syntax": "The syntax for this form is a comma-separated list of expressions of uniform type enclosed in square brackets.",
        "expr.array.array-behavior": "This produces an array containing each of these values in the order they are written.",
        "expr.array.repeat": "The syntax for the second form is two expressions separated by a semicolon (`;`) enclosed in square brackets.",
        "expr.array.repeat-operand": "The expression before the `;` is called the *repeat operand*.",
        "expr.array.length-operand": "The expression after the `;` is called the *length operand*.",
        "expr.array.length-restriction": "The length operand must either be an [inferred const] or be a [constant expression] of type `usize` (e.g. a [literal] or a [constant item]).\n\nconst C: usize = 1;\nlet _: [u8; C] = [0; 1]; // Literal.\nlet _: [u8; C] = [0; C]; // Constant item.\nlet _: [u8; C] = [0; _]; // Inferred const.\nlet _: [u8; C] = [0; (((_)))]; // Inferred const.\n\n> [!NOTE]\n> In an array expression, an [inferred const] is parsed as an expression but then semantically treated as a separate kind of [const generic argument].",
        "expr.array.repeat-behavior": "An array expression of this form creates an array with the length of the value of the length operand with each element being a copy of the repeat operand.\nThat is, `[a; b]` creates an array containing `b` copies of the value of `a`.",
        "expr.array.repeat-copy": "If the length operand has a value greater than 1 then this requires the repeat operand to have a type that implements [`Copy`], to be a [const block expression], or to be a [path] to a constant item.",
        "expr.array.repeat-const-item": "When the repeat operand is a const block or a path to a constant item, it is evaluated the number of times specified in the length operand.",
        "expr.array.repeat-evaluation-zero": "If that value is `0`, then the const block or constant item is not evaluated at all.",
        "expr.array.repeat-non-const": "For expressions that are neither a const block nor a path to a constant item, it is evaluated exactly once, and then the result is copied the length operand's value times.\n\n[1, 2, 3, 4];\n[\"a\", \"b\", \"c\", \"d\"];\n[0; 128];              // array with 128 zeros\n[0u8, 0u8, 0u8, 0u8,];\n[[1, 0, 0], [0, 1, 0], [0, 0, 1]]; // 2D array\nconst EMPTY: Vec<i32> = Vec::new();\n[EMPTY; 2];"
      }
    },
    {
      "id": "expr.array.index",
      "title": "Array and slice indexing expressions",
      "level": 2,
      "content": ",expressions\nIndexExpression -> Expression `[` Expression `]`\n\n[Array] and [slice]-typed values can be indexed by writing a square-bracket-enclosed expression of type `usize` (the index) after them.\nWhen the array is mutable, the resulting [memory location] can be assigned to.\n\nFor other types an index expression `a[b]` is equivalent to `*std::ops::Index::index(&a, b)`, or `*std::ops::IndexMut::index_mut(&mut a, b)` in a mutable place expression context.\nJust as with methods, Rust will also insert dereference operations on `a` repeatedly to find an implementation.\n\nIndices are zero-based for arrays and slices.\n\nArray access is a [constant expression], so bounds can be checked at compile-time with a constant index value.\nOtherwise a check will be performed at run-time that will put the thread in a _panicked state_ if it fails.\n\n,should_panic\n// lint is deny by default.\n#![warn(unconditional_panic)]\n\n([1, 2, 3, 4])[2];        // Evaluates to 3\n\nlet b = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];\nb1;                  // multidimensional array indexing\n\nlet x = ([\"a\", \"b\"])[10]; // warning: index out of bounds\n\nlet n = 10;\nlet y = ([\"a\", \"b\"])[n];  // panics\n\nlet arr = [\"a\", \"b\"];\narr[10];                  // warning: index out of bounds\n\nThe array index expression can be implemented for types other than arrays and slices by implementing the [Index] and [IndexMut] traits.\n\n[`Copy`]: ../special-types-and-traits.md#copy\n[IndexMut]: std::ops::IndexMut\n[Index]: std::ops::Index\n[array]: ../types/array.md\n[const generic argument]: items.generics.const.argument\n[const block expression]: expr.block.const\n[constant expression]: ../const_eval.md#constant-expressions\n[constant item]: ../items/constant-items.md\n[inferred const]: items.generics.const.inferred\n[literal]: ../tokens.md#literals\n[memory location]: ../expressions.md#place-expressions-and-value-expressions\n[panic]: ../panic.md\n[path]: path-expr.md\n[slice]: ../types/slice.md",
      "parent_id": null,
      "paragraphs": {
        "expr.array.index.syntax": ",expressions\nIndexExpression -> Expression `[` Expression `]`",
        "expr.array.index.array": "[Array] and [slice]-typed values can be indexed by writing a square-bracket-enclosed expression of type `usize` (the index) after them.\nWhen the array is mutable, the resulting [memory location] can be assigned to.",
        "expr.array.index.trait": "For other types an index expression `a[b]` is equivalent to `*std::ops::Index::index(&a, b)`, or `*std::ops::IndexMut::index_mut(&mut a, b)` in a mutable place expression context.\nJust as with methods, Rust will also insert dereference operations on `a` repeatedly to find an implementation.",
        "expr.array.index.zero-index": "Indices are zero-based for arrays and slices.",
        "expr.array.index.const": "Array access is a [constant expression], so bounds can be checked at compile-time with a constant index value.\nOtherwise a check will be performed at run-time that will put the thread in a _panicked state_ if it fails.\n\n,should_panic\n// lint is deny by default.\n#![warn(unconditional_panic)]\n\n([1, 2, 3, 4])[2];        // Evaluates to 3\n\nlet b = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];\nb1;                  // multidimensional array indexing\n\nlet x = ([\"a\", \"b\"])[10]; // warning: index out of bounds\n\nlet n = 10;\nlet y = ([\"a\", \"b\"])[n];  // panics\n\nlet arr = [\"a\", \"b\"];\narr[10];                  // warning: index out of bounds",
        "expr.array.index.trait-impl": "The array index expression can be implemented for types other than arrays and slices by implementing the [Index] and [IndexMut] traits.\n\n[`Copy`]: ../special-types-and-traits.md#copy\n[IndexMut]: std::ops::IndexMut\n[Index]: std::ops::Index\n[array]: ../types/array.md\n[const generic argument]: items.generics.const.argument\n[const block expression]: expr.block.const\n[constant expression]: ../const_eval.md#constant-expressions\n[constant item]: ../items/constant-items.md\n[inferred const]: items.generics.const.inferred\n[literal]: ../tokens.md#literals\n[memory location]: ../expressions.md#place-expressions-and-value-expressions\n[panic]: ../panic.md\n[path]: path-expr.md\n[slice]: ../types/slice.md"
      }
    },
    {
      "id": "expr.tuple",
      "title": "Tuple and tuple indexing expressions",
      "level": 1,
      "content": "## Tuple expressions\n\n,expressions\nTupleExpression -> `(` TupleElements? `)`\n\nTupleElements -> ( Expression `,` )+ Expression?\n\nA *tuple expression* constructs tuple values.\n\nThe syntax for tuple expressions is a parenthesized, comma separated list of expressions, called the *tuple initializer operands*.\n\n1-ary tuple expressions require a comma after their tuple initializer operand to be disambiguated with a [parenthetical expression].\n\nTuple expressions are a [value expression] that evaluate into a newly constructed value of a tuple type.\n\nThe number of tuple initializer operands is the arity of the constructed tuple.\n\nTuple expressions without any tuple initializer operands produce the unit tuple.\n\nFor other tuple expressions, the first written tuple initializer operand initializes the field `0` and subsequent operands initializes the next highest field.\nFor example, in the tuple expression `('a', 'b', 'c')`, `'a'` initializes the value of the field `0`, `'b'` field `1`, and `'c'` field `2`.\n\nExamples of tuple expressions and their types:\n\n| Expression           | Type         |\n| -------------------- | ------------ |\n| `()`                 | `()` (unit)  |\n| `(0.0, 4.5)`         | `(f64, f64)` |\n| `(\"x\".to_string(), )` | `(String, )`  |\n| `(\"a\", 4usize, true)`| `(&'static str, usize, bool)` |",
      "parent_id": null,
      "paragraphs": {
        "expr.tuple": "## Tuple expressions",
        "expr.tuple.syntax": ",expressions\nTupleExpression -> `(` TupleElements? `)`\n\nTupleElements -> ( Expression `,` )+ Expression?",
        "expr.tuple.result": "A *tuple expression* constructs tuple values.",
        "expr.tuple.intro": "The syntax for tuple expressions is a parenthesized, comma separated list of expressions, called the *tuple initializer operands*.",
        "expr.tuple.unary-tuple-restriction": "1-ary tuple expressions require a comma after their tuple initializer operand to be disambiguated with a [parenthetical expression].",
        "expr.tuple.value": "Tuple expressions are a [value expression] that evaluate into a newly constructed value of a tuple type.",
        "expr.tuple.type": "The number of tuple initializer operands is the arity of the constructed tuple.",
        "expr.tuple.unit": "Tuple expressions without any tuple initializer operands produce the unit tuple.",
        "expr.tuple.fields": "For other tuple expressions, the first written tuple initializer operand initializes the field `0` and subsequent operands initializes the next highest field.\nFor example, in the tuple expression `('a', 'b', 'c')`, `'a'` initializes the value of the field `0`, `'b'` field `1`, and `'c'` field `2`.\n\nExamples of tuple expressions and their types:\n\n| Expression           | Type         |\n| -------------------- | ------------ |\n| `()`                 | `()` (unit)  |\n| `(0.0, 4.5)`         | `(f64, f64)` |\n| `(\"x\".to_string(), )` | `(String, )`  |\n| `(\"a\", 4usize, true)`| `(&'static str, usize, bool)` |"
      }
    },
    {
      "id": "expr.tuple-index",
      "title": "Tuple indexing expressions",
      "level": 2,
      "content": ",expressions\nTupleIndexingExpression -> Expression `.` TUPLE_INDEX\n\nA *tuple indexing expression* accesses fields of tuples and tuple structs.\n\nThe syntax for a tuple index expression is an expression, called the *tuple operand*, then a `.`, then finally a tuple index.\n\nThe syntax for the *tuple index* is a [decimal literal] with no leading zeros, underscores, or suffix.\nFor example `0` and `2` are valid tuple indices but not `01`, `0_`, nor `0i32`.\n\nThe type of the tuple operand must be a [tuple type] or a [tuple struct].\n\nThe tuple index must be a name of a field of the type of the tuple operand.\n\nEvaluation of tuple index expressions has no side effects beyond evaluation of its tuple operand.\nAs a [place expression], it evaluates to the location of the field of the tuple operand with the same name as the tuple index.\n\nExamples of tuple indexing expressions:\n\n// Indexing a tuple\nlet pair = (\"a string\", 2);\nassert_eq!(pair.1, 2);\n\n// Indexing a tuple struct\n# struct Point(f32, f32);\nlet point = Point(1.0, 0.0);\nassert_eq!(point.0, 1.0);\nassert_eq!(point.1, 0.0);\n\n> [!NOTE]\n> Unlike field access expressions, tuple index expressions can be the function operand of a [call expression] as it cannot be confused with a method call since method names cannot be numbers.\n\n> [!NOTE]\n> Although arrays and slices also have elements, you must use an [array or slice indexing expression] or a [slice pattern] to access their elements.\n\n[array or slice indexing expression]: array-expr.md#array-and-slice-indexing-expressions\n[call expression]: ./call-expr.md\n[decimal literal]: ../tokens.md#integer-literals\n[field access expressions]: ./field-expr.html#field-access-expressions\n[operands]: ../expressions.md\n[parenthetical expression]: grouped-expr.md\n[place expression]: ../expressions.md#place-expressions-and-value-expressions\n[slice pattern]: ../patterns.md#slice-patterns\n[tuple type]: ../types/tuple.md\n[tuple struct]: ../types/struct.md\n[value expression]: ../expressions.md#place-expressions-and-value-expressions",
      "parent_id": null,
      "paragraphs": {
        "expr.tuple-index.syntax": ",expressions\nTupleIndexingExpression -> Expression `.` TUPLE_INDEX",
        "expr.tuple-index.intro": "A *tuple indexing expression* accesses fields of tuples and tuple structs.\n\nThe syntax for a tuple index expression is an expression, called the *tuple operand*, then a `.`, then finally a tuple index.",
        "expr.tuple-index.index-syntax": "The syntax for the *tuple index* is a [decimal literal] with no leading zeros, underscores, or suffix.\nFor example `0` and `2` are valid tuple indices but not `01`, `0_`, nor `0i32`.",
        "expr.tuple-index.required-type": "The type of the tuple operand must be a [tuple type] or a [tuple struct].",
        "expr.tuple-index.index-name-operand": "The tuple index must be a name of a field of the type of the tuple operand.",
        "expr.tuple-index.result": "Evaluation of tuple index expressions has no side effects beyond evaluation of its tuple operand.\nAs a [place expression], it evaluates to the location of the field of the tuple operand with the same name as the tuple index.\n\nExamples of tuple indexing expressions:\n\n// Indexing a tuple\nlet pair = (\"a string\", 2);\nassert_eq!(pair.1, 2);\n\n// Indexing a tuple struct\n# struct Point(f32, f32);\nlet point = Point(1.0, 0.0);\nassert_eq!(point.0, 1.0);\nassert_eq!(point.1, 0.0);\n\n> [!NOTE]\n> Unlike field access expressions, tuple index expressions can be the function operand of a [call expression] as it cannot be confused with a method call since method names cannot be numbers.\n\n> [!NOTE]\n> Although arrays and slices also have elements, you must use an [array or slice indexing expression] or a [slice pattern] to access their elements.\n\n[array or slice indexing expression]: array-expr.md#array-and-slice-indexing-expressions\n[call expression]: ./call-expr.md\n[decimal literal]: ../tokens.md#integer-literals\n[field access expressions]: ./field-expr.html#field-access-expressions\n[operands]: ../expressions.md\n[parenthetical expression]: grouped-expr.md\n[place expression]: ../expressions.md#place-expressions-and-value-expressions\n[slice pattern]: ../patterns.md#slice-patterns\n[tuple type]: ../types/tuple.md\n[tuple struct]: ../types/struct.md\n[value expression]: ../expressions.md#place-expressions-and-value-expressions"
      }
    },
    {
      "id": "expr.struct",
      "title": "Struct expressions",
      "level": 1,
      "content": ",expressions\nStructExpression ->\n    PathInExpression `{` (StructExprFields | StructBase)? `}`\n\nStructExprFields ->\n    StructExprField (`,` StructExprField)* (`,` StructBase | `,`?)\n\nStructExprField ->\n    OuterAttribute*\n    (\n        IDENTIFIER\n      | (IDENTIFIER | TUPLE_INDEX) `:` Expression\n    )\n\nStructBase -> `..` Expression\n\nA *struct expression* creates a struct, enum, or union value.\nIt consists of a path to a [struct], [enum variant], or [union] item followed by the values for the fields of the item.\n\nThe following are examples of struct expressions:\n\n# struct Point { x: f64, y: f64 }\n# struct NothingInMe { }\n# mod game { pub struct User<'a> { pub name: &'a str, pub age: u32, pub score: usize } }\n# enum Enum { Variant {} }\nPoint {x: 10.0, y: 20.0};\nNothingInMe {};\nlet u = game::User {name: \"Joe\", age: 35, score: 100_000};\nEnum::Variant {};\n\n> [!NOTE]\n> Tuple structs and tuple enum variants are typically instantiated using a call expression referring to the constructor in the value namespace. These are distinct from a struct expression using curly braces referring to the constructor in the type namespace.\n>\n> ```rust\n> struct Position(i32, i32, i32);\n> Position(0, 0, 0);  // Typical way of creating a tuple struct.\n> let c = Position;  // `c` is a function that takes 3 arguments.\n> let pos = c(8, 6, 7);  // Creates a `Position` value.\n>\n> enum Version { Triple(i32, i32, i32) };\n> Version::Triple(0, 0, 0);\n> let f = Version::Triple;\n> let ver = f(8, 6, 7);\n> ```\n>\n> The last segment of the call path cannot refer to a type alias:\n>\n> ```rust\n> trait Tr { type T; }\n> impl<T> Tr for T { type T = T; }\n>\n> struct Tuple();\n> enum Enum { Tuple() }\n>\n> // <Unit as Tr>::T(); // causes an error -- `::T` is a type, not a value\n> <Enum as Tr>::T::Tuple(); // OK\n> ```\n>\n> ----\n>\n> Unit structs and unit enum variants are typically instantiated using a path expression referring to the constant in the value namespace.\n>\n> ```rust\n> struct Gamma;\n> // Gamma unit value, referring to the const in the value namespace.\n> let a = Gamma;\n> // Exact same value as `a`, but constructed using a struct expression\n> // referring to the type namespace.\n> let b = Gamma {};\n>\n> enum ColorSpace { Oklch }\n> let c = ColorSpace::Oklch;\n> let d = ColorSpace::Oklch {};\n> ```",
      "parent_id": null,
      "paragraphs": {
        "expr.struct.syntax": ",expressions\nStructExpression ->\n    PathInExpression `{` (StructExprFields | StructBase)? `}`\n\nStructExprFields ->\n    StructExprField (`,` StructExprField)* (`,` StructBase | `,`?)\n\nStructExprField ->\n    OuterAttribute*\n    (\n        IDENTIFIER\n      | (IDENTIFIER | TUPLE_INDEX) `:` Expression\n    )\n\nStructBase -> `..` Expression",
        "expr.struct.intro": "A *struct expression* creates a struct, enum, or union value.\nIt consists of a path to a [struct], [enum variant], or [union] item followed by the values for the fields of the item.\n\nThe following are examples of struct expressions:\n\n# struct Point { x: f64, y: f64 }\n# struct NothingInMe { }\n# mod game { pub struct User<'a> { pub name: &'a str, pub age: u32, pub score: usize } }\n# enum Enum { Variant {} }\nPoint {x: 10.0, y: 20.0};\nNothingInMe {};\nlet u = game::User {name: \"Joe\", age: 35, score: 100_000};\nEnum::Variant {};\n\n> [!NOTE]\n> Tuple structs and tuple enum variants are typically instantiated using a call expression referring to the constructor in the value namespace. These are distinct from a struct expression using curly braces referring to the constructor in the type namespace.\n>\n> ```rust\n> struct Position(i32, i32, i32);\n> Position(0, 0, 0);  // Typical way of creating a tuple struct.\n> let c = Position;  // `c` is a function that takes 3 arguments.\n> let pos = c(8, 6, 7);  // Creates a `Position` value.\n>\n> enum Version { Triple(i32, i32, i32) };\n> Version::Triple(0, 0, 0);\n> let f = Version::Triple;\n> let ver = f(8, 6, 7);\n> ```\n>\n> The last segment of the call path cannot refer to a type alias:\n>\n> ```rust\n> trait Tr { type T; }\n> impl<T> Tr for T { type T = T; }\n>\n> struct Tuple();\n> enum Enum { Tuple() }\n>\n> // <Unit as Tr>::T(); // causes an error -- `::T` is a type, not a value\n> <Enum as Tr>::T::Tuple(); // OK\n> ```\n>\n> ----\n>\n> Unit structs and unit enum variants are typically instantiated using a path expression referring to the constant in the value namespace.\n>\n> ```rust\n> struct Gamma;\n> // Gamma unit value, referring to the const in the value namespace.\n> let a = Gamma;\n> // Exact same value as `a`, but constructed using a struct expression\n> // referring to the type namespace.\n> let b = Gamma {};\n>\n> enum ColorSpace { Oklch }\n> let c = ColorSpace::Oklch;\n> let d = ColorSpace::Oklch {};\n> ```"
      }
    },
    {
      "id": "expr.struct.field",
      "title": "Field struct expression",
      "level": 1,
      "content": "A struct expression with fields enclosed in curly braces allows you to specify the value for each individual field in any order.\nThe field name is separated from its value with a colon.\n\nA value of a [union] type can only be created using this syntax, and it must specify exactly one field.",
      "parent_id": null,
      "paragraphs": {
        "expr.struct.field.intro": "A struct expression with fields enclosed in curly braces allows you to specify the value for each individual field in any order.\nThe field name is separated from its value with a colon.",
        "expr.struct.field.union-constraint": "A value of a [union] type can only be created using this syntax, and it must specify exactly one field."
      }
    },
    {
      "id": "expr.struct.update",
      "title": "Functional update syntax",
      "level": 2,
      "content": "A struct expression that constructs a value of a struct type can terminate with the syntax `..` followed by an expression to denote a functional update.\n\nThe expression following `..` (the base) must have the same struct type as the new struct type being formed.\n\nThe entire expression uses the given values for the fields that were specified and moves or copies the remaining fields from the base expression.\n\nAs with all struct expressions, all of the fields of the struct must be [visible], even those not explicitly named.\n\n# struct Point3d { x: i32, y: i32, z: i32 }\nlet mut base = Point3d {x: 1, y: 2, z: 3};\nlet y_ref = &mut base.y;\nPoint3d {y: 0, z: 10, .. base}; // OK, only base.x is accessed\ndrop(y_ref);\n\nStruct expressions can't be used directly in a [loop] or [if] expression's head, or in the [scrutinee] of an [if let] or [match] expression.\nHowever, struct expressions can be used in these situations if they are within another expression, for example inside [parentheses].\n\nThe field names can be decimal integer values to specify indices for constructing tuple structs.\nThis can be used with base structs to fill out the remaining indices not specified:\n\nstruct Color(u8, u8, u8);\nlet c1 = Color(0, 0, 0);  // Typical way of creating a tuple struct.\nlet c2 = Color{0: 255, 1: 127, 2: 0};  // Specifying fields by index.\nlet c3 = Color{1: 0, ..c2};  // Fill out all other fields using a base struct.",
      "parent_id": null,
      "paragraphs": {
        "expr.struct.update.intro": "A struct expression that constructs a value of a struct type can terminate with the syntax `..` followed by an expression to denote a functional update.",
        "expr.struct.update.base-same-type": "The expression following `..` (the base) must have the same struct type as the new struct type being formed.",
        "expr.struct.update.fields": "The entire expression uses the given values for the fields that were specified and moves or copies the remaining fields from the base expression.",
        "expr.struct.update.visibility-constraint": "As with all struct expressions, all of the fields of the struct must be [visible], even those not explicitly named.\n\n# struct Point3d { x: i32, y: i32, z: i32 }\nlet mut base = Point3d {x: 1, y: 2, z: 3};\nlet y_ref = &mut base.y;\nPoint3d {y: 0, z: 10, .. base}; // OK, only base.x is accessed\ndrop(y_ref);",
        "expr.struct.brace-restricted-positions": "Struct expressions can't be used directly in a [loop] or [if] expression's head, or in the [scrutinee] of an [if let] or [match] expression.\nHowever, struct expressions can be used in these situations if they are within another expression, for example inside [parentheses].",
        "expr.struct.tuple-field": "The field names can be decimal integer values to specify indices for constructing tuple structs.\nThis can be used with base structs to fill out the remaining indices not specified:\n\nstruct Color(u8, u8, u8);\nlet c1 = Color(0, 0, 0);  // Typical way of creating a tuple struct.\nlet c2 = Color{0: 255, 1: 127, 2: 0};  // Specifying fields by index.\nlet c3 = Color{1: 0, ..c2};  // Fill out all other fields using a base struct."
      }
    },
    {
      "id": "expr.struct.field.named",
      "title": "Struct field init shorthand",
      "level": 1,
      "content": "When initializing a data structure (struct, enum, union) with named (but not numbered) fields, it is allowed to write `fieldname` as a shorthand for `fieldname: fieldname`.\nThis allows a compact syntax with less duplication.\nFor example:\n\n# struct Point3d { x: i32, y: i32, z: i32 }\n# let x = 0;\n# let y_value = 0;\n# let z = 0;\nPoint3d { x: x, y: y_value, z: z };\nPoint3d { x, y: y_value, z };\n\n[enum variant]: ../items/enumerations.md\n[if let]: if-expr.md#if-let-patterns\n[if]: if-expr.md#if-expressions\n[loop]: loop-expr.md\n[match]: match-expr.md\n[parentheses]: grouped-expr.md\n[struct]: ../items/structs.md\n[union]: ../items/unions.md\n[visible]: ../visibility-and-privacy.md\n[scrutinee]: ../glossary.md#scrutinee",
      "parent_id": null,
      "paragraphs": {
        "expr.struct.field.named": "When initializing a data structure (struct, enum, union) with named (but not numbered) fields, it is allowed to write `fieldname` as a shorthand for `fieldname: fieldname`.\nThis allows a compact syntax with less duplication.\nFor example:\n\n# struct Point3d { x: i32, y: i32, z: i32 }\n# let x = 0;\n# let y_value = 0;\n# let z = 0;\nPoint3d { x: x, y: y_value, z: z };\nPoint3d { x, y: y_value, z };\n\n[enum variant]: ../items/enumerations.md\n[if let]: if-expr.md#if-let-patterns\n[if]: if-expr.md#if-expressions\n[loop]: loop-expr.md\n[match]: match-expr.md\n[parentheses]: grouped-expr.md\n[struct]: ../items/structs.md\n[union]: ../items/unions.md\n[visible]: ../visibility-and-privacy.md\n[scrutinee]: ../glossary.md#scrutinee"
      }
    },
    {
      "id": "expr.call",
      "title": "Call expressions",
      "level": 1,
      "content": ",expressions\nCallExpression -> Expression `(` CallParams? `)`\n\nCallParams -> Expression ( `,` Expression )* `,`?\n\nA *call expression* calls a function.\nThe syntax of a call expression is an expression, called the *function operand*, followed by a parenthesized comma-separated list of expression, called the *argument operands*.\n\nIf the function eventually returns, then the expression completes.\n\nFor [non-function types], the expression `f(...)` uses the method on one of the following traits based on the function operand:\n\n- [`Fn`] or [`AsyncFn`] --- shared reference.\n- [`FnMut`] or [`AsyncFnMut`] --- mutable reference.\n- [`FnOnce`] or [`AsyncFnOnce`] --- value.\n\nAn automatic borrow will be taken if needed.\nThe function operand will also be [automatically dereferenced] as required.\n\nSome examples of call expressions:\n\n# fn add(x: i32, y: i32) -> i32 { 0 }\nlet three: i32 = add(1i32, 2i32);\nlet name: &'static str = (|| \"Rust\")();",
      "parent_id": null,
      "paragraphs": {
        "expr.call.syntax": ",expressions\nCallExpression -> Expression `(` CallParams? `)`\n\nCallParams -> Expression ( `,` Expression )* `,`?",
        "expr.call.intro": "A *call expression* calls a function.\nThe syntax of a call expression is an expression, called the *function operand*, followed by a parenthesized comma-separated list of expression, called the *argument operands*.",
        "expr.call.convergence": "If the function eventually returns, then the expression completes.",
        "expr.call.trait": "For [non-function types], the expression `f(...)` uses the method on one of the following traits based on the function operand:\n\n- [`Fn`] or [`AsyncFn`] --- shared reference.\n- [`FnMut`] or [`AsyncFnMut`] --- mutable reference.\n- [`FnOnce`] or [`AsyncFnOnce`] --- value.",
        "expr.call.autoref-deref": "An automatic borrow will be taken if needed.\nThe function operand will also be [automatically dereferenced] as required.\n\nSome examples of call expressions:\n\n# fn add(x: i32, y: i32) -> i32 { 0 }\nlet three: i32 = add(1i32, 2i32);\nlet name: &'static str = (|| \"Rust\")();"
      }
    },
    {
      "id": "expr.call.desugar",
      "title": "Disambiguating function calls",
      "level": 1,
      "content": "All function calls are sugar for a more explicit [fully-qualified syntax].\n\nFunction calls may need to be fully qualified, depending on the ambiguity of a call in light of in-scope items.\n\n> [!NOTE]\n> In the past, the terms \"Unambiguous Function Call Syntax\", \"Universal Function Call Syntax\", or \"UFCS\", have been used in documentation, issues, RFCs, and other community writings. However, these terms lack descriptive power and potentially confuse the issue at hand. We mention them here for searchability's sake.\n\nSeveral situations often occur which result in ambiguities about the receiver or referent of method or associated function calls.\nThese situations may include:\n\n* Multiple in-scope traits define methods with the same name for the same types\n* Auto-`deref` is undesirable; for example, distinguishing between methods on a smart pointer itself and the pointer's referent\n* Methods which take no arguments, like [`default()`], and return properties of a type, like [`size_of()`]\n\nTo resolve the ambiguity, the programmer may refer to their desired method or function using more specific paths, types, or traits.\n\nFor example,\n\ntrait Pretty {\n    fn print(&self);\n}\n\ntrait Ugly {\n    fn print(&self);\n}\n\nstruct Foo;\nimpl Pretty for Foo {\n    fn print(&self) {}\n}\n\nstruct Bar;\nimpl Pretty for Bar {\n    fn print(&self) {}\n}\nimpl Ugly for Bar {\n    fn print(&self) {}\n}\n\nfn main() {\n    let f = Foo;\n    let b = Bar;\n\n    // we can do this because we only have one item called `print` for `Foo`s\n    f.print();\n    // more explicit, and, in the case of `Foo`, not necessary\n    Foo::print(&f);\n    // if you're not into the whole brevity thing\n    <Foo as Pretty>::print(&f);\n\n    // b.print(); // Error: multiple 'print' found\n    // Bar::print(&b); // Still an error: multiple `print` found\n\n    // necessary because of in-scope items defining `print`\n    <Bar as Pretty>::print(&b);\n}\n\nRefer to [RFC 132] for further details and motivations.\n\n[RFC 132]: https://github.com/rust-lang/rfcs/blob/master/text/0132-ufcs.md\n[`default()`]: std::default::Default::default\n[`size_of()`]: std::mem::size_of\n[automatically dereferenced]: field-expr.md#automatic-dereferencing\n[fully-qualified syntax]: ../paths.md#qualified-paths\n[non-function types]: ../types/function-item.md",
      "parent_id": null,
      "paragraphs": {
        "expr.call.desugar.fully-qualified": "All function calls are sugar for a more explicit [fully-qualified syntax].",
        "expr.call.desugar.ambiguity": "Function calls may need to be fully qualified, depending on the ambiguity of a call in light of in-scope items.\n\n> [!NOTE]\n> In the past, the terms \"Unambiguous Function Call Syntax\", \"Universal Function Call Syntax\", or \"UFCS\", have been used in documentation, issues, RFCs, and other community writings. However, these terms lack descriptive power and potentially confuse the issue at hand. We mention them here for searchability's sake.",
        "expr.call.desugar.limits": "Several situations often occur which result in ambiguities about the receiver or referent of method or associated function calls.\nThese situations may include:\n\n* Multiple in-scope traits define methods with the same name for the same types\n* Auto-`deref` is undesirable; for example, distinguishing between methods on a smart pointer itself and the pointer's referent\n* Methods which take no arguments, like [`default()`], and return properties of a type, like [`size_of()`]",
        "expr.call.desugar.explicit-path": "To resolve the ambiguity, the programmer may refer to their desired method or function using more specific paths, types, or traits.\n\nFor example,\n\ntrait Pretty {\n    fn print(&self);\n}\n\ntrait Ugly {\n    fn print(&self);\n}\n\nstruct Foo;\nimpl Pretty for Foo {\n    fn print(&self) {}\n}\n\nstruct Bar;\nimpl Pretty for Bar {\n    fn print(&self) {}\n}\nimpl Ugly for Bar {\n    fn print(&self) {}\n}\n\nfn main() {\n    let f = Foo;\n    let b = Bar;\n\n    // we can do this because we only have one item called `print` for `Foo`s\n    f.print();\n    // more explicit, and, in the case of `Foo`, not necessary\n    Foo::print(&f);\n    // if you're not into the whole brevity thing\n    <Foo as Pretty>::print(&f);\n\n    // b.print(); // Error: multiple 'print' found\n    // Bar::print(&b); // Still an error: multiple `print` found\n\n    // necessary because of in-scope items defining `print`\n    <Bar as Pretty>::print(&b);\n}\n\nRefer to [RFC 132] for further details and motivations.\n\n[RFC 132]: https://github.com/rust-lang/rfcs/blob/master/text/0132-ufcs.md\n[`default()`]: std::default::Default::default\n[`size_of()`]: std::mem::size_of\n[automatically dereferenced]: field-expr.md#automatic-dereferencing\n[fully-qualified syntax]: ../paths.md#qualified-paths\n[non-function types]: ../types/function-item.md"
      }
    },
    {
      "id": "expr.method",
      "title": "Method-call expressions",
      "level": 1,
      "content": ",expressions\nMethodCallExpression -> Expression `.` PathExprSegment `(`CallParams? `)`\n\nA _method call_ consists of an expression (the *receiver*) followed by a single dot, an expression path segment, and a parenthesized expression-list.\n\nMethod calls are resolved to associated [methods] on specific traits, either statically dispatching to a method if the exact `self`-type of the left-hand-side is known, or dynamically dispatching if the left-hand-side expression is an indirect trait object.\n\nlet pi: Result<f32, _> = \"3.14\".parse();\nlet log_pi = pi.unwrap_or(1.0).log(2.72);\n# assert!(1.14 < log_pi && log_pi < 1.15)\n\nWhen looking up a method call, the receiver may be automatically dereferenced or borrowed in order to call a method.\nThis requires a more complex lookup process than for other functions, since there may be a number of possible methods to call.\nThe following procedure is used:\n\nThe first step is to build a list of candidate receiver types.\nObtain these by repeatedly dereferencing the receiver expression's type, adding each type encountered to the list, then finally attempting an [unsized coercion] at the end, and adding the result type if that is successful.\n\nThen, for each candidate `T`, add `&T` and `&mut T` to the list immediately after `T`.\n\nFor instance, if the receiver has type `Box<[i32;2]>`, then the candidate types will be `Box<[i32;2]>`, `&Box<[i32;2]>`, `&mut Box<[i32;2]>`, `[i32; 2]` (by dereferencing), `&[i32; 2]`, `&mut [i32; 2]`, `[i32]` (by unsized coercion), `&[i32]`, and finally `&mut [i32]`.\n\nThen, for each candidate type `T`, search for a [visible] method with a receiver of that type in the following places:\n\n1. `T`'s inherent methods (methods implemented directly on `T`).\n1. Any of the methods provided by a [visible] trait implemented by `T`.\n   If `T` is a type parameter, methods provided by trait bounds on `T` are looked up first.\n   Then all remaining methods in scope are looked up.\n\n> [!NOTE]\n> The lookup is done for each type in order, which can occasionally lead to surprising results. The below code will print \"In trait impl!\", because `&self` methods are looked up first, the trait method is found before the struct's `&mut self` method is found.\n>\n> ```rust\n> struct Foo {}\n>\n> trait Bar {\n>   fn bar(&self);\n> }\n>\n> impl Foo {\n>   fn bar(&mut self) {\n>     println!(\"In struct impl!\")\n>   }\n> }\n>\n> impl Bar for Foo {\n>   fn bar(&self) {\n>     println!(\"In trait impl!\")\n>   }\n> }\n>\n> fn main() {\n>   let mut f = Foo{};\n>   f.bar();\n> }\n> ```\n\nIf this results in multiple possible candidates, then it is an error, and the receiver must be converted to an appropriate receiver type to make the method call.\n\nThis process does not take into account the mutability or lifetime of the receiver, or whether a method is `unsafe`.\nOnce a method is looked up, if it can't be called for one (or more) of those reasons, the result is a compiler error.\n\nIf a step is reached where there is more than one possible method, such as where generic methods or traits are considered the same, then it is a compiler error.\nThese cases require a [disambiguating function call syntax] for method and function invocation.\n\n> [!EDITION-2021]\n> Before the 2021 edition, during the search for visible methods, if the candidate receiver type is an [array type], methods provided by the standard library [`IntoIterator`] trait are ignored.\n>\n> The edition used for this purpose is determined by the token representing the method name.\n>\n> This special case may be removed in the future.\n\n> [!WARNING]\n> For [trait objects], if there is an inherent method of the same name as a trait method, it will give a compiler error when trying to call the method in a method call expression.\n> Instead, you can call the method using [disambiguating function call syntax], in which case it calls the trait method, not the inherent method.\n> There is no way to call the inherent method.\n> Just don't define inherent methods on trait objects with the same name as a trait method and you'll be fine.\n\n[visible]: ../visibility-and-privacy.md\n[array type]: ../types/array.md\n[trait objects]: ../types/trait-object.md\n[disambiguate call]: call-expr.md#disambiguating-function-calls\n[disambiguating function call syntax]: call-expr.md#disambiguating-function-calls\n[dereference]: operator-expr.md#the-dereference-operator\n[methods]: ../items/associated-items.md#methods\n[unsized coercion]: ../type-coercions.md#unsized-coercions\n[`IntoIterator`]: std::iter::IntoIterator",
      "parent_id": null,
      "paragraphs": {
        "expr.method.syntax": ",expressions\nMethodCallExpression -> Expression `.` PathExprSegment `(`CallParams? `)`",
        "expr.method.intro": "A _method call_ consists of an expression (the *receiver*) followed by a single dot, an expression path segment, and a parenthesized expression-list.",
        "expr.method.target": "Method calls are resolved to associated [methods] on specific traits, either statically dispatching to a method if the exact `self`-type of the left-hand-side is known, or dynamically dispatching if the left-hand-side expression is an indirect trait object.\n\nlet pi: Result<f32, _> = \"3.14\".parse();\nlet log_pi = pi.unwrap_or(1.0).log(2.72);\n# assert!(1.14 < log_pi && log_pi < 1.15)",
        "expr.method.autoref-deref": "When looking up a method call, the receiver may be automatically dereferenced or borrowed in order to call a method.\nThis requires a more complex lookup process than for other functions, since there may be a number of possible methods to call.\nThe following procedure is used:",
        "expr.method.candidate-receivers": "The first step is to build a list of candidate receiver types.\nObtain these by repeatedly dereferencing the receiver expression's type, adding each type encountered to the list, then finally attempting an [unsized coercion] at the end, and adding the result type if that is successful.",
        "expr.method.candidate-receivers-refs": "Then, for each candidate `T`, add `&T` and `&mut T` to the list immediately after `T`.\n\nFor instance, if the receiver has type `Box<[i32;2]>`, then the candidate types will be `Box<[i32;2]>`, `&Box<[i32;2]>`, `&mut Box<[i32;2]>`, `[i32; 2]` (by dereferencing), `&[i32; 2]`, `&mut [i32; 2]`, `[i32]` (by unsized coercion), `&[i32]`, and finally `&mut [i32]`.",
        "expr.method.candidate-search": "Then, for each candidate type `T`, search for a [visible] method with a receiver of that type in the following places:\n\n1. `T`'s inherent methods (methods implemented directly on `T`).\n1. Any of the methods provided by a [visible] trait implemented by `T`.\n   If `T` is a type parameter, methods provided by trait bounds on `T` are looked up first.\n   Then all remaining methods in scope are looked up.\n\n> [!NOTE]\n> The lookup is done for each type in order, which can occasionally lead to surprising results. The below code will print \"In trait impl!\", because `&self` methods are looked up first, the trait method is found before the struct's `&mut self` method is found.\n>\n> ```rust\n> struct Foo {}\n>\n> trait Bar {\n>   fn bar(&self);\n> }\n>\n> impl Foo {\n>   fn bar(&mut self) {\n>     println!(\"In struct impl!\")\n>   }\n> }\n>\n> impl Bar for Foo {\n>   fn bar(&self) {\n>     println!(\"In trait impl!\")\n>   }\n> }\n>\n> fn main() {\n>   let mut f = Foo{};\n>   f.bar();\n> }\n> ```",
        "expr.method.ambiguous-target": "If this results in multiple possible candidates, then it is an error, and the receiver must be converted to an appropriate receiver type to make the method call.",
        "expr.method.receiver-constraints": "This process does not take into account the mutability or lifetime of the receiver, or whether a method is `unsafe`.\nOnce a method is looked up, if it can't be called for one (or more) of those reasons, the result is a compiler error.",
        "expr.method.ambiguous-search": "If a step is reached where there is more than one possible method, such as where generic methods or traits are considered the same, then it is a compiler error.\nThese cases require a [disambiguating function call syntax] for method and function invocation.",
        "expr.method.edition2021": "> [!EDITION-2021]\n> Before the 2021 edition, during the search for visible methods, if the candidate receiver type is an [array type], methods provided by the standard library [`IntoIterator`] trait are ignored.\n>\n> The edition used for this purpose is determined by the token representing the method name.\n>\n> This special case may be removed in the future.\n\n> [!WARNING]\n> For [trait objects], if there is an inherent method of the same name as a trait method, it will give a compiler error when trying to call the method in a method call expression.\n> Instead, you can call the method using [disambiguating function call syntax], in which case it calls the trait method, not the inherent method.\n> There is no way to call the inherent method.\n> Just don't define inherent methods on trait objects with the same name as a trait method and you'll be fine.\n\n[visible]: ../visibility-and-privacy.md\n[array type]: ../types/array.md\n[trait objects]: ../types/trait-object.md\n[disambiguate call]: call-expr.md#disambiguating-function-calls\n[disambiguating function call syntax]: call-expr.md#disambiguating-function-calls\n[dereference]: operator-expr.md#the-dereference-operator\n[methods]: ../items/associated-items.md#methods\n[unsized coercion]: ../type-coercions.md#unsized-coercions\n[`IntoIterator`]: std::iter::IntoIterator"
      }
    },
    {
      "id": "expr.field",
      "title": "Field access expressions",
      "level": 1,
      "content": ",expressions\nFieldExpression -> Expression `.` IDENTIFIER\n\nA *field expression* is a [place expression] that evaluates to the location of a field of a [struct] or [union].\n\nWhen the operand is [mutable], the field expression is also mutable.\n\nThe syntax for a field expression is an expression, called the *container operand*, then a `.`, and finally an [identifier].\n\nField expressions cannot be followed by a parenthetical comma-separated list of expressions, as that is instead parsed as a [method call expression].\nThat is, they cannot be the function operand of a [call expression].\n\n> [!NOTE]\n> Wrap the field expression in a [parenthesized expression] to use it in a call expression.\n>\n> ```rust\n> # struct HoldsCallable<F: Fn()> { callable: F }\n> let holds_callable = HoldsCallable { callable: || () };\n>\n> // Invalid: Parsed as calling the method \"callable\"\n> // holds_callable.callable();\n>\n> // Valid\n> (holds_callable.callable)();\n> ```\n\nExamples:\n\n<!-- ignore: needs lots of support code -->\n,ignore\nmystruct.myfield;\nfoo().x;\n(Struct {a: 10, b: 20}).a;\n(mystruct.function_field)() // Call expression containing a field expression",
      "parent_id": null,
      "paragraphs": {
        "expr.field.syntax": ",expressions\nFieldExpression -> Expression `.` IDENTIFIER",
        "expr.field.intro": "A *field expression* is a [place expression] that evaluates to the location of a field of a [struct] or [union].",
        "expr.field.mut": "When the operand is [mutable], the field expression is also mutable.",
        "expr.field.form": "The syntax for a field expression is an expression, called the *container operand*, then a `.`, and finally an [identifier].",
        "expr.field.not-method-call": "Field expressions cannot be followed by a parenthetical comma-separated list of expressions, as that is instead parsed as a [method call expression].\nThat is, they cannot be the function operand of a [call expression].\n\n> [!NOTE]\n> Wrap the field expression in a [parenthesized expression] to use it in a call expression.\n>\n> ```rust\n> # struct HoldsCallable<F: Fn()> { callable: F }\n> let holds_callable = HoldsCallable { callable: || () };\n>\n> // Invalid: Parsed as calling the method \"callable\"\n> // holds_callable.callable();\n>\n> // Valid\n> (holds_callable.callable)();\n> ```\n\nExamples:\n\n<!-- ignore: needs lots of support code -->\n,ignore\nmystruct.myfield;\nfoo().x;\n(Struct {a: 10, b: 20}).a;\n(mystruct.function_field)() // Call expression containing a field expression"
      }
    },
    {
      "id": "expr.field.autoref-deref",
      "title": "Automatic dereferencing",
      "level": 1,
      "content": "If the type of the container operand implements [`Deref`] or `DerefMut` depending on whether the operand is [mutable], it is *automatically dereferenced* as many times as necessary to make the field access possible.\nThis process is also called *autoderef* for short.",
      "parent_id": null,
      "paragraphs": {
        "expr.field.autoref-deref": "If the type of the container operand implements [`Deref`] or `DerefMut` depending on whether the operand is [mutable], it is *automatically dereferenced* as many times as necessary to make the field access possible.\nThis process is also called *autoderef* for short."
      }
    },
    {
      "id": "expr.field.borrow",
      "title": "Borrowing",
      "level": 2,
      "content": "The fields of a struct or a reference to a struct are treated as separate entities when borrowing.\nIf the struct does not implement [`Drop`] and is stored in a local variable, this also applies to moving out of each of its fields.\nThis also does not apply if automatic dereferencing is done through user-defined types other than [`Box`].\n\nstruct A { f1: String, f2: String, f3: String }\nlet mut x: A;\n# x = A {\n#     f1: \"f1\".to_string(),\n#     f2: \"f2\".to_string(),\n#     f3: \"f3\".to_string()\n# };\nlet a: &mut String = &mut x.f1; // x.f1 borrowed mutably\nlet b: &String = &x.f2;         // x.f2 borrowed immutably\nlet c: &String = &x.f2;         // Can borrow again\nlet d: String = x.f3;           // Move out of x.f3\n\n[`Box`]: ../special-types-and-traits.md#boxt\n[`Deref`]: ../special-types-and-traits.md#deref-and-derefmut\n[`drop`]: ../special-types-and-traits.md#drop\n[identifier]: ../identifiers.md\n[call expression]: call-expr.md\n[method call expression]: method-call-expr.md\n[mutable]: ../expressions.md#mutability\n[parenthesized expression]: grouped-expr.md\n[place expression]: ../expressions.md#place-expressions-and-value-expressions\n[struct]: ../items/structs.md\n[union]: ../items/unions.md",
      "parent_id": null,
      "paragraphs": {
        "expr.field.borrow": "The fields of a struct or a reference to a struct are treated as separate entities when borrowing.\nIf the struct does not implement [`Drop`] and is stored in a local variable, this also applies to moving out of each of its fields.\nThis also does not apply if automatic dereferencing is done through user-defined types other than [`Box`].\n\nstruct A { f1: String, f2: String, f3: String }\nlet mut x: A;\n# x = A {\n#     f1: \"f1\".to_string(),\n#     f2: \"f2\".to_string(),\n#     f3: \"f3\".to_string()\n# };\nlet a: &mut String = &mut x.f1; // x.f1 borrowed mutably\nlet b: &String = &x.f2;         // x.f2 borrowed immutably\nlet c: &String = &x.f2;         // Can borrow again\nlet d: String = x.f3;           // Move out of x.f3\n\n[`Box`]: ../special-types-and-traits.md#boxt\n[`Deref`]: ../special-types-and-traits.md#deref-and-derefmut\n[`drop`]: ../special-types-and-traits.md#drop\n[identifier]: ../identifiers.md\n[call expression]: call-expr.md\n[method call expression]: method-call-expr.md\n[mutable]: ../expressions.md#mutability\n[parenthesized expression]: grouped-expr.md\n[place expression]: ../expressions.md#place-expressions-and-value-expressions\n[struct]: ../items/structs.md\n[union]: ../items/unions.md"
      }
    },
    {
      "id": "expr.closure",
      "title": "Closure expressions",
      "level": 1,
      "content": ",expressions\nClosureExpression ->\n    `async`?[^cl-async-edition]\n    `move`?\n    ( `||` | `|` ClosureParameters? `|` )\n    (Expression | `->` TypeNoBounds BlockExpression)\n\nClosureParameters -> ClosureParam (`,` ClosureParam)* `,`?\n\nClosureParam -> OuterAttribute* PatternNoTopAlt ( `:` Type )?\n\n[^cl-async-edition]: The `async` qualifier is not allowed in the 2015 edition.\n\nA *closure expression*, also known as a lambda expression or a lambda, defines a [closure type] and evaluates to a value of that type.\nThe syntax for a closure expression is an optional `async` keyword, an optional `move` keyword, then a pipe-symbol-delimited (`|`) comma-separated list of [patterns], called the *closure parameters* each optionally followed by a `:` and a type, then an optional `->` and type, called the *return type*, and then an expression, called the *closure body operand*.\n\nThe optional type after each pattern is a type annotation for the pattern.\n\nIf there is a return type, the closure body must be a [block].\n\nA closure expression denotes a function that maps a list of parameters onto the expression that follows the parameters.\nJust like a [`let` binding], the closure parameters are irrefutable [patterns], whose type annotation is optional and will be inferred from context if not given.\n\nEach closure expression has a unique, anonymous type.\n\nSignificantly, closure expressions _capture their environment_, which regular [function definitions] do not.\n\nWithout the `move` keyword, the closure expression infers how it captures each variable from its environment, preferring to capture by shared reference, effectively borrowing all outer variables mentioned inside the closure's body.\n\nIf needed the compiler will infer that instead mutable references should be taken, or that the values should be moved or copied (depending on their type) from the environment.\n\nA closure can be forced to capture its environment by copying or moving values by prefixing it with the `move` keyword.\nThis is often used to ensure that the closure's lifetime is `'static`.",
      "parent_id": null,
      "paragraphs": {
        "expr.closure.syntax": ",expressions\nClosureExpression ->\n    `async`?[^cl-async-edition]\n    `move`?\n    ( `||` | `|` ClosureParameters? `|` )\n    (Expression | `->` TypeNoBounds BlockExpression)\n\nClosureParameters -> ClosureParam (`,` ClosureParam)* `,`?\n\nClosureParam -> OuterAttribute* PatternNoTopAlt ( `:` Type )?\n\n[^cl-async-edition]: The `async` qualifier is not allowed in the 2015 edition.",
        "expr.closure.intro": "A *closure expression*, also known as a lambda expression or a lambda, defines a [closure type] and evaluates to a value of that type.\nThe syntax for a closure expression is an optional `async` keyword, an optional `move` keyword, then a pipe-symbol-delimited (`|`) comma-separated list of [patterns], called the *closure parameters* each optionally followed by a `:` and a type, then an optional `->` and type, called the *return type*, and then an expression, called the *closure body operand*.",
        "expr.closure.param-type": "The optional type after each pattern is a type annotation for the pattern.",
        "expr.closure.explicit-type-body": "If there is a return type, the closure body must be a [block].",
        "expr.closure.parameter-restriction": "A closure expression denotes a function that maps a list of parameters onto the expression that follows the parameters.\nJust like a [`let` binding], the closure parameters are irrefutable [patterns], whose type annotation is optional and will be inferred from context if not given.",
        "expr.closure.unique-type": "Each closure expression has a unique, anonymous type.",
        "expr.closure.captures": "Significantly, closure expressions _capture their environment_, which regular [function definitions] do not.",
        "expr.closure.capture-inference": "Without the `move` keyword, the closure expression infers how it captures each variable from its environment, preferring to capture by shared reference, effectively borrowing all outer variables mentioned inside the closure's body.",
        "expr.closure.capture-mut-ref": "If needed the compiler will infer that instead mutable references should be taken, or that the values should be moved or copied (depending on their type) from the environment.",
        "expr.closure.capture-move": "A closure can be forced to capture its environment by copying or moving values by prefixing it with the `move` keyword.\nThis is often used to ensure that the closure's lifetime is `'static`."
      }
    },
    {
      "id": "expr.closure.trait-impl",
      "title": "Closure trait implementations",
      "level": 1,
      "content": "Which traits the closure type implement depends on how variables are captured, the types of the captured variables, and the presence of `async`.\nSee the [call traits and coercions] chapter for how and when a closure implements `Fn`, `FnMut`, and `FnOnce`.\nThe closure type implements [`Send`] and [`Sync`] if the type of every captured variable also implements the trait.",
      "parent_id": null,
      "paragraphs": {
        "expr.closure.trait-impl": "Which traits the closure type implement depends on how variables are captured, the types of the captured variables, and the presence of `async`.\nSee the [call traits and coercions] chapter for how and when a closure implements `Fn`, `FnMut`, and `FnOnce`.\nThe closure type implements [`Send`] and [`Sync`] if the type of every captured variable also implements the trait."
      }
    },
    {
      "id": "expr.closure.async",
      "title": "Async closures",
      "level": 2,
      "content": "Closures marked with the `async` keyword indicate that they are asynchronous in an analogous way to an async function.\n\nCalling the async closure does not perform any work, but instead evaluates to a value that implements [`Future`] that corresponds to the computation of the body of the closure.\n\nasync fn takes_async_callback(f: impl AsyncFn(u64)) {\n    f(0).await;\n    f(1).await;\n}\n\nasync fn example() {\n    takes_async_callback(async |i| {\n        core::future::ready(i).await;\n        println!(\"done with {i}.\");\n    }).await;\n}\n\n> [!EDITION-2018]\n> Async closures are only available beginning with Rust 2018.\n\n## Example\n\nIn this example, we define a function `ten_times` that takes a higher-order function argument, and we then call it with a closure expression as an argument, followed by a closure expression that moves values from its environment.\n\nfn ten_times<F>(f: F) where F: Fn(i32) {\n    for index in 0..10 {\n        f(index);\n    }\n}\n\nten_times(|j| println!(\"hello, {}\", j));\n// With type annotations\nten_times(|j: i32| -> () { println!(\"hello, {}\", j) });\n\nlet word = \"konnichiwa\".to_owned();\nten_times(move |j| println!(\"{}, {}\", word, j));\n\n## Attributes on closure parameters\n\nAttributes on closure parameters follow the same rules and restrictions as [regular function parameters].\n\n[`let` binding]: ../statements.md#let-statements\n[`Send`]: ../special-types-and-traits.md#send\n[`Sync`]: ../special-types-and-traits.md#sync\n[block]: block-expr.md\n[call traits and coercions]: ../types/closure.md#call-traits-and-coercions\n[closure type]: ../types/closure.md\n[function definitions]: ../items/functions.md\n[patterns]: ../patterns.md\n[regular function parameters]: ../items/functions.md#attributes-on-function-parameters",
      "parent_id": null,
      "paragraphs": {
        "expr.closure.async.intro": "Closures marked with the `async` keyword indicate that they are asynchronous in an analogous way to an async function.",
        "expr.closure.async.future": "Calling the async closure does not perform any work, but instead evaluates to a value that implements [`Future`] that corresponds to the computation of the body of the closure.\n\nasync fn takes_async_callback(f: impl AsyncFn(u64)) {\n    f(0).await;\n    f(1).await;\n}\n\nasync fn example() {\n    takes_async_callback(async |i| {\n        core::future::ready(i).await;\n        println!(\"done with {i}.\");\n    }).await;\n}",
        "expr.closure.async.edition2018": "> [!EDITION-2018]\n> Async closures are only available beginning with Rust 2018.\n\n## Example\n\nIn this example, we define a function `ten_times` that takes a higher-order function argument, and we then call it with a closure expression as an argument, followed by a closure expression that moves values from its environment.\n\nfn ten_times<F>(f: F) where F: Fn(i32) {\n    for index in 0..10 {\n        f(index);\n    }\n}\n\nten_times(|j| println!(\"hello, {}\", j));\n// With type annotations\nten_times(|j: i32| -> () { println!(\"hello, {}\", j) });\n\nlet word = \"konnichiwa\".to_owned();\nten_times(move |j| println!(\"{}, {}\", word, j));\n\n## Attributes on closure parameters",
        "expr.closure.param-attributes": "Attributes on closure parameters follow the same rules and restrictions as [regular function parameters].\n\n[`let` binding]: ../statements.md#let-statements\n[`Send`]: ../special-types-and-traits.md#send\n[`Sync`]: ../special-types-and-traits.md#sync\n[block]: block-expr.md\n[call traits and coercions]: ../types/closure.md#call-traits-and-coercions\n[closure type]: ../types/closure.md\n[function definitions]: ../items/functions.md\n[patterns]: ../patterns.md\n[regular function parameters]: ../items/functions.md#attributes-on-function-parameters"
      }
    },
    {
      "id": "expr.loop",
      "title": "Loops and other breakable expressions",
      "level": 1,
      "content": ",expressions\nLoopExpression ->\n    LoopLabel? (\n        InfiniteLoopExpression\n      | PredicateLoopExpression\n      | IteratorLoopExpression\n      | LabelBlockExpression\n    )\n\nRust supports four loop expressions:\n\n*   A `loop` expression denotes an infinite loop.\n*   A `while` expression loops until a predicate is false.\n*   A `for` expression extracts values from an iterator, looping until the iterator is empty.\n*   A labeled block expression runs a loop exactly once, but allows exiting the loop early with `break`.\n\nAll four types of loop support `break` expressions, and labels.\n\nAll except labeled block expressions support `continue` expressions.\n\nOnly `loop` and labeled block expressions support evaluation to non-trivial values.",
      "parent_id": null,
      "paragraphs": {
        "expr.loop.syntax": ",expressions\nLoopExpression ->\n    LoopLabel? (\n        InfiniteLoopExpression\n      | PredicateLoopExpression\n      | IteratorLoopExpression\n      | LabelBlockExpression\n    )",
        "expr.loop.intro": "Rust supports four loop expressions:\n\n*   A `loop` expression denotes an infinite loop.\n*   A `while` expression loops until a predicate is false.\n*   A `for` expression extracts values from an iterator, looping until the iterator is empty.\n*   A labeled block expression runs a loop exactly once, but allows exiting the loop early with `break`.",
        "expr.loop.break-label": "All four types of loop support `break` expressions, and labels.",
        "expr.loop.continue-label": "All except labeled block expressions support `continue` expressions.",
        "expr.loop.explicit-result": "Only `loop` and labeled block expressions support evaluation to non-trivial values."
      }
    },
    {
      "id": "expr.loop.infinite",
      "title": "Infinite loops",
      "level": 1,
      "content": ",expressions\nInfiniteLoopExpression -> `loop` BlockExpression\n\nA `loop` expression repeats execution of its body continuously:\n`loop { println!(\"I live.\"); }`.\n\nA `loop` expression without an associated `break` expression is diverging and has type `!`.\n\nA `loop` expression containing associated `break` expression(s) may terminate, and must have type compatible with the value of the `break` expression(s).",
      "parent_id": null,
      "paragraphs": {
        "expr.loop.infinite.syntax": ",expressions\nInfiniteLoopExpression -> `loop` BlockExpression",
        "expr.loop.infinite.intro": "A `loop` expression repeats execution of its body continuously:\n`loop { println!(\"I live.\"); }`.",
        "expr.loop.infinite.diverging": "A `loop` expression without an associated `break` expression is diverging and has type `!`.",
        "expr.loop.infinite.break": "A `loop` expression containing associated `break` expression(s) may terminate, and must have type compatible with the value of the `break` expression(s)."
      }
    },
    {
      "id": "expr.loop.while",
      "title": "Predicate loops",
      "level": 2,
      "content": ",expressions\nPredicateLoopExpression -> `while` Conditions BlockExpression\n\nA `while` loop expression allows repeating the evaluation of a block while a set of conditions remain true.\n\nThe syntax of a `while` expression is a sequence of one or more condition operands separated by `&&`,\nfollowed by a [BlockExpression].\n\nCondition operands must be either an [Expression] with a [boolean type] or a conditional `let` match.\nIf all of the condition operands evaluate to `true` and all of the `let` patterns successfully match their [scrutinee]s,\nthen the loop body block executes.\n\nAfter the loop body successfully executes, the condition operands are re-evaluated to determine if the body should be executed again.\n\nIf any condition operand evaluates to `false` or any `let` pattern does not match its scrutinee,\nthe body is not executed and execution continues after the `while` expression.\n\nA `while` expression evaluates to `()`.\n\nAn example:\n\nlet mut i = 0;\n\nwhile i < 10 {\n    println!(\"hello\");\n    i = i + 1;\n}",
      "parent_id": null,
      "paragraphs": {
        "expr.loop.while.grammar": ",expressions\nPredicateLoopExpression -> `while` Conditions BlockExpression",
        "expr.loop.while.intro": "A `while` loop expression allows repeating the evaluation of a block while a set of conditions remain true.",
        "expr.loop.while.syntax": "The syntax of a `while` expression is a sequence of one or more condition operands separated by `&&`,\nfollowed by a [BlockExpression].",
        "expr.loop.while.condition": "Condition operands must be either an [Expression] with a [boolean type] or a conditional `let` match.\nIf all of the condition operands evaluate to `true` and all of the `let` patterns successfully match their [scrutinee]s,\nthen the loop body block executes.",
        "expr.loop.while.repeat": "After the loop body successfully executes, the condition operands are re-evaluated to determine if the body should be executed again.",
        "expr.loop.while.exit": "If any condition operand evaluates to `false` or any `let` pattern does not match its scrutinee,\nthe body is not executed and execution continues after the `while` expression.",
        "expr.loop.while.eval": "A `while` expression evaluates to `()`.\n\nAn example:\n\nlet mut i = 0;\n\nwhile i < 10 {\n    println!(\"hello\");\n    i = i + 1;\n}"
      }
    },
    {
      "id": "expr.loop.while.let",
      "title": "`while let` patterns",
      "level": 2,
      "content": "`let` patterns in a `while` condition allow binding new variables into scope when the pattern matches successfully.\nThe following examples illustrate bindings using `let` patterns:\n\nlet mut x = vec![1, 2, 3];\n\nwhile let Some(y) = x.pop() {\n    println!(\"y = {}\", y);\n}\n\nwhile let _ = 5 {\n    println!(\"Irrefutable patterns are always true\");\n    break;\n}\n\nA `while let` loop is equivalent to a `loop` expression containing a [`match` expression] as follows.\n\n<!-- ignore: expansion example -->\n,ignore\n'label: while let PATS = EXPR {\n    /* loop body */\n}\n\nis equivalent to\n\n<!-- ignore: expansion example -->\n,ignore\n'label: loop {\n    match EXPR {\n        PATS => { /* loop body */ },\n        _ => break,\n    }\n}\n\nMultiple patterns may be specified with the `|` operator.\nThis has the same semantics as with `|` in `match` expressions:\n\nlet mut vals = vec![2, 3, 1, 2, 2];\nwhile let Some(v @ 1) | Some(v @ 2) = vals.pop() {\n    // Prints 2, 2, then 1\n    println!(\"{}\", v);\n}",
      "parent_id": null,
      "paragraphs": {
        "expr.loop.while.let.intro": "`let` patterns in a `while` condition allow binding new variables into scope when the pattern matches successfully.\nThe following examples illustrate bindings using `let` patterns:\n\nlet mut x = vec![1, 2, 3];\n\nwhile let Some(y) = x.pop() {\n    println!(\"y = {}\", y);\n}\n\nwhile let _ = 5 {\n    println!(\"Irrefutable patterns are always true\");\n    break;\n}",
        "expr.loop.while.let.desugar": "A `while let` loop is equivalent to a `loop` expression containing a [`match` expression] as follows.\n\n<!-- ignore: expansion example -->\n,ignore\n'label: while let PATS = EXPR {\n    /* loop body */\n}\n\nis equivalent to\n\n<!-- ignore: expansion example -->\n,ignore\n'label: loop {\n    match EXPR {\n        PATS => { /* loop body */ },\n        _ => break,\n    }\n}",
        "expr.loop.while.let.or-pattern": "Multiple patterns may be specified with the `|` operator.\nThis has the same semantics as with `|` in `match` expressions:\n\nlet mut vals = vec![2, 3, 1, 2, 2];\nwhile let Some(v @ 1) | Some(v @ 2) = vals.pop() {\n    // Prints 2, 2, then 1\n    println!(\"{}\", v);\n}"
      }
    },
    {
      "id": "expr.loop.while.chains",
      "title": "`while` condition chains",
      "level": 3,
      "content": "Multiple condition operands can be separated with `&&`.\nThese have the same semantics and restrictions as [`if` condition chains].\n\nThe following is an example of chaining multiple expressions, mixing `let` bindings and boolean expressions, and with expressions able to reference pattern bindings from previous expressions:\n\nfn main() {\n    let outer_opt = Some(Some(1i32));\n\n    while let Some(inner_opt) = outer_opt\n        && let Some(number) = inner_opt\n        && number == 1\n    {\n        println!(\"Peek a boo\");\n        break;\n    }\n}",
      "parent_id": null,
      "paragraphs": {
        "expr.loop.while.chains.intro": "Multiple condition operands can be separated with `&&`.\nThese have the same semantics and restrictions as [`if` condition chains].\n\nThe following is an example of chaining multiple expressions, mixing `let` bindings and boolean expressions, and with expressions able to reference pattern bindings from previous expressions:\n\nfn main() {\n    let outer_opt = Some(Some(1i32));\n\n    while let Some(inner_opt) = outer_opt\n        && let Some(number) = inner_opt\n        && number == 1\n    {\n        println!(\"Peek a boo\");\n        break;\n    }\n}"
      }
    },
    {
      "id": "expr.loop.for",
      "title": "Iterator loops",
      "level": 3,
      "content": ",expressions\nIteratorLoopExpression ->\n    `for` Pattern `in` Expression _except [StructExpression]_ BlockExpression\n<!-- TODO: The exception above isn't accurate, see https://github.com/rust-lang/reference/issues/569 -->\n\nA `for` expression is a syntactic construct for looping over elements provided by an implementation of `std::iter::IntoIterator`.\n\nIf the iterator yields a value, that value is matched against the irrefutable pattern, the body of the loop is executed, and then control returns to the head of the `for` loop.\nIf the iterator is empty, the `for` expression completes.\n\nAn example of a `for` loop over the contents of an array:\n\nlet v = &[\"apples\", \"cake\", \"coffee\"];\n\nfor text in v {\n    println!(\"I like {}.\", text);\n}\n\nAn example of a for loop over a series of integers:\n\nlet mut sum = 0;\nfor n in 1..11 {\n    sum += n;\n}\nassert_eq!(sum, 55);\n\nA `for` loop is equivalent to a `loop` expression containing a [`match` expression] as follows:\n\n<!-- ignore: expansion example -->\n,ignore\n'label: for PATTERN in iter_expr {\n    /* loop body */\n}\n\nis equivalent to\n\n<!-- ignore: expansion example -->\n,ignore\n{\n    let result = match IntoIterator::into_iter(iter_expr) {\n        mut iter => 'label: loop {\n            let mut next;\n            match Iterator::next(&mut iter) {\n                Option::Some(val) => next = val,\n                Option::None => break,\n            };\n            let PATTERN = next;\n            let () = { /* loop body */ };\n        },\n    };\n    result\n}\n\n`IntoIterator`, `Iterator`, and `Option` are always the standard library items here, not whatever those names resolve to in the current scope.\n\nThe variable names `next`, `iter`, and `val` are for exposition only, they do not actually have names the user can type.\n\n> [!NOTE]\n> The outer `match` is used to ensure that any [temporary values] in `iter_expr` don't get dropped before the loop is finished. `next` is declared before being assigned because it results in types being inferred correctly more often.",
      "parent_id": null,
      "paragraphs": {
        "expr.loop.for.syntax": ",expressions\nIteratorLoopExpression ->\n    `for` Pattern `in` Expression _except [StructExpression]_ BlockExpression\n<!-- TODO: The exception above isn't accurate, see https://github.com/rust-lang/reference/issues/569 -->",
        "expr.loop.for.intro": "A `for` expression is a syntactic construct for looping over elements provided by an implementation of `std::iter::IntoIterator`.",
        "expr.loop.for.condition": "If the iterator yields a value, that value is matched against the irrefutable pattern, the body of the loop is executed, and then control returns to the head of the `for` loop.\nIf the iterator is empty, the `for` expression completes.\n\nAn example of a `for` loop over the contents of an array:\n\nlet v = &[\"apples\", \"cake\", \"coffee\"];\n\nfor text in v {\n    println!(\"I like {}.\", text);\n}\n\nAn example of a for loop over a series of integers:\n\nlet mut sum = 0;\nfor n in 1..11 {\n    sum += n;\n}\nassert_eq!(sum, 55);",
        "expr.loop.for.desugar": "A `for` loop is equivalent to a `loop` expression containing a [`match` expression] as follows:\n\n<!-- ignore: expansion example -->\n,ignore\n'label: for PATTERN in iter_expr {\n    /* loop body */\n}\n\nis equivalent to\n\n<!-- ignore: expansion example -->\n,ignore\n{\n    let result = match IntoIterator::into_iter(iter_expr) {\n        mut iter => 'label: loop {\n            let mut next;\n            match Iterator::next(&mut iter) {\n                Option::Some(val) => next = val,\n                Option::None => break,\n            };\n            let PATTERN = next;\n            let () = { /* loop body */ };\n        },\n    };\n    result\n}",
        "expr.loop.for.lang-items": "`IntoIterator`, `Iterator`, and `Option` are always the standard library items here, not whatever those names resolve to in the current scope.\n\nThe variable names `next`, `iter`, and `val` are for exposition only, they do not actually have names the user can type.\n\n> [!NOTE]\n> The outer `match` is used to ensure that any [temporary values] in `iter_expr` don't get dropped before the loop is finished. `next` is declared before being assigned because it results in types being inferred correctly more often."
      }
    },
    {
      "id": "expr.loop.label",
      "title": "Loop labels",
      "level": 2,
      "content": ",expressions\nLoopLabel -> LIFETIME_OR_LABEL `:`\n\nA loop expression may optionally have a _label_. The label is written as a lifetime preceding the loop expression, as in `'foo: loop { break 'foo; }`, `'bar: while false {}`, `'humbug: for _ in 0..0 {}`.\n\nIf a label is present, then labeled `break` and `continue` expressions nested within this loop may exit out of this loop or return control to its head.\nSee break expressions and continue expressions.\n\nLabels follow the hygiene and shadowing rules of local variables. For example, this code will print \"outer loop\":\n\n'a: loop {\n    'a: loop {\n        break 'a;\n    }\n    print!(\"outer loop\");\n    break 'a;\n}\n\n`'_` is not a valid loop label.",
      "parent_id": null,
      "paragraphs": {
        "expr.loop.label.syntax": ",expressions\nLoopLabel -> LIFETIME_OR_LABEL `:`",
        "expr.loop.label.intro": "A loop expression may optionally have a _label_. The label is written as a lifetime preceding the loop expression, as in `'foo: loop { break 'foo; }`, `'bar: while false {}`, `'humbug: for _ in 0..0 {}`.",
        "expr.loop.label.control-flow": "If a label is present, then labeled `break` and `continue` expressions nested within this loop may exit out of this loop or return control to its head.\nSee break expressions and continue expressions.",
        "expr.loop.label.ref": "Labels follow the hygiene and shadowing rules of local variables. For example, this code will print \"outer loop\":\n\n'a: loop {\n    'a: loop {\n        break 'a;\n    }\n    print!(\"outer loop\");\n    break 'a;\n}\n\n`'_` is not a valid loop label."
      }
    },
    {
      "id": "expr.loop.break",
      "title": "`break` expressions",
      "level": 2,
      "content": ",expressions\nBreakExpression -> `break` LIFETIME_OR_LABEL? Expression?\n\nWhen `break` is encountered, execution of the associated loop body is immediately terminated, for example:\n\nlet mut last = 0;\nfor x in 1..100 {\n    if x > 12 {\n        break;\n    }\n    last = x;\n}\nassert_eq!(last, 12);\n\nA `break` expression is normally associated with the innermost `loop`, `for` or `while` loop enclosing the `break` expression,\nbut a label can be used to specify which enclosing loop is affected.\nExample:\n\n'outer: loop {\n    while true {\n        break 'outer;\n    }\n}\n\nA `break` expression is only permitted in the body of a loop, and has one of the forms `break`, `break 'label` or (see below) `break EXPR` or `break 'label EXPR`.",
      "parent_id": null,
      "paragraphs": {
        "expr.loop.break.syntax": ",expressions\nBreakExpression -> `break` LIFETIME_OR_LABEL? Expression?",
        "expr.loop.break.intro": "When `break` is encountered, execution of the associated loop body is immediately terminated, for example:\n\nlet mut last = 0;\nfor x in 1..100 {\n    if x > 12 {\n        break;\n    }\n    last = x;\n}\nassert_eq!(last, 12);",
        "expr.loop.break.label": "A `break` expression is normally associated with the innermost `loop`, `for` or `while` loop enclosing the `break` expression,\nbut a label can be used to specify which enclosing loop is affected.\nExample:\n\n'outer: loop {\n    while true {\n        break 'outer;\n    }\n}",
        "expr.loop.break.value": "A `break` expression is only permitted in the body of a loop, and has one of the forms `break`, `break 'label` or (see below) `break EXPR` or `break 'label EXPR`."
      }
    },
    {
      "id": "expr.loop.block-labels",
      "title": "Labeled block expressions",
      "level": 2,
      "content": ",expressions\nLabelBlockExpression -> BlockExpression\n\nLabeled block expressions are exactly like block expressions, except that they allow using `break` expressions within the block.\n\nUnlike loops, `break` expressions within a labeled block expression *must* have a label (i.e. the label is not optional).\n\nSimilarly, labeled block expressions *must* begin with a label.\n\n# fn do_thing() {}\n# fn condition_not_met() -> bool { true }\n# fn do_next_thing() {}\n# fn do_last_thing() {}\nlet result = 'block: {\n    do_thing();\n    if condition_not_met() {\n        break 'block 1;\n    }\n    do_next_thing();\n    if condition_not_met() {\n        break 'block 2;\n    }\n    do_last_thing();\n    3\n};",
      "parent_id": null,
      "paragraphs": {
        "expr.loop.block-labels.syntax": ",expressions\nLabelBlockExpression -> BlockExpression",
        "expr.loop.block-labels.intro": "Labeled block expressions are exactly like block expressions, except that they allow using `break` expressions within the block.",
        "expr.loop.block-labels.break": "Unlike loops, `break` expressions within a labeled block expression *must* have a label (i.e. the label is not optional).",
        "expr.loop.block-labels.label-required": "Similarly, labeled block expressions *must* begin with a label.\n\n# fn do_thing() {}\n# fn condition_not_met() -> bool { true }\n# fn do_next_thing() {}\n# fn do_last_thing() {}\nlet result = 'block: {\n    do_thing();\n    if condition_not_met() {\n        break 'block 1;\n    }\n    do_next_thing();\n    if condition_not_met() {\n        break 'block 2;\n    }\n    do_last_thing();\n    3\n};"
      }
    },
    {
      "id": "expr.loop.continue",
      "title": "`continue` expressions",
      "level": 1,
      "content": ",expressions\nContinueExpression -> `continue` LIFETIME_OR_LABEL?\n\nWhen `continue` is encountered, the current iteration of the associated loop body is immediately terminated, returning control to the loop *head*.\n\nIn the case of a `while` loop, the head is the conditional operands controlling the loop.\n\nIn the case of a `for` loop, the head is the call-expression controlling the loop.\n\nLike `break`, `continue` is normally associated with the innermost enclosing loop, but `continue 'label` may be used to specify the loop affected.\n\nA `continue` expression is only permitted in the body of a loop.",
      "parent_id": null,
      "paragraphs": {
        "expr.loop.continue.syntax": ",expressions\nContinueExpression -> `continue` LIFETIME_OR_LABEL?",
        "expr.loop.continue.intro": "When `continue` is encountered, the current iteration of the associated loop body is immediately terminated, returning control to the loop *head*.",
        "expr.loop.continue.while": "In the case of a `while` loop, the head is the conditional operands controlling the loop.",
        "expr.loop.continue.for": "In the case of a `for` loop, the head is the call-expression controlling the loop.",
        "expr.loop.continue.label": "Like `break`, `continue` is normally associated with the innermost enclosing loop, but `continue 'label` may be used to specify the loop affected.",
        "expr.loop.continue.in-loop-only": "A `continue` expression is only permitted in the body of a loop."
      }
    },
    {
      "id": "expr.loop.break-value",
      "title": "`break` and loop values",
      "level": 2,
      "content": "When associated with a `loop`, a break expression may be used to return a value from that loop, via one of the forms `break EXPR` or `break 'label EXPR`, where `EXPR` is an expression whose result is returned from the `loop`.\nFor example:\n\nlet (mut a, mut b) = (1, 1);\nlet result = loop {\n    if b > 10 {\n        break b;\n    }\n    let c = a + b;\n    a = b;\n    b = c;\n};\n// first number in Fibonacci sequence over 10:\nassert_eq!(result, 13);\n\nIn the case a `loop` has an associated `break`, it is not considered diverging, and the `loop` must have a type compatible with each `break` expression.\n`break` without an expression is considered identical to `break` with expression `()`.\n\n[`if` condition chains]: if-expr.md#chains-of-conditions\n[`if` expressions]: if-expr.md\n[`match` expression]: match-expr.md\n[boolean type]: ../types/boolean.md\n[scrutinee]: ../glossary.md#scrutinee\n[temporary values]: ../expressions.md#temporaries",
      "parent_id": null,
      "paragraphs": {
        "expr.loop.break-value.intro": "When associated with a `loop`, a break expression may be used to return a value from that loop, via one of the forms `break EXPR` or `break 'label EXPR`, where `EXPR` is an expression whose result is returned from the `loop`.\nFor example:\n\nlet (mut a, mut b) = (1, 1);\nlet result = loop {\n    if b > 10 {\n        break b;\n    }\n    let c = a + b;\n    a = b;\n    b = c;\n};\n// first number in Fibonacci sequence over 10:\nassert_eq!(result, 13);",
        "expr.loop.break-value.loop": "In the case a `loop` has an associated `break`, it is not considered diverging, and the `loop` must have a type compatible with each `break` expression.\n`break` without an expression is considered identical to `break` with expression `()`.\n\n[`if` condition chains]: if-expr.md#chains-of-conditions\n[`if` expressions]: if-expr.md\n[`match` expression]: match-expr.md\n[boolean type]: ../types/boolean.md\n[scrutinee]: ../glossary.md#scrutinee\n[temporary values]: ../expressions.md#temporaries"
      }
    },
    {
      "id": "expr.range",
      "title": "Range expressions",
      "level": 1,
      "content": ",expressions\nRangeExpression ->\n      RangeExpr\n    | RangeFromExpr\n    | RangeToExpr\n    | RangeFullExpr\n    | RangeInclusiveExpr\n    | RangeToInclusiveExpr\n\nRangeExpr -> Expression `..` Expression\n\nRangeFromExpr -> Expression `..`\n\nRangeToExpr -> `..` Expression\n\nRangeFullExpr -> `..`\n\nRangeInclusiveExpr -> Expression `..=` Expression\n\nRangeToInclusiveExpr -> `..=` Expression\n\nThe `..` and `..=` operators will construct an object of one of the `std::ops::Range` (or `core::ops::Range`) variants, according to the following table:\n\n| Production             | Syntax        | Type                         | Range                 |\n|------------------------|---------------|------------------------------|-----------------------|\n| [RangeExpr]            | start`..`end  | [std::ops::Range]            | start &le; x &lt; end |\n| [RangeFromExpr]        | start`..`     | [std::ops::RangeFrom]        | start &le; x          |\n| [RangeToExpr]          | `..`end       | [std::ops::RangeTo]          |            x &lt; end |\n| [RangeFullExpr]        | `..`          | [std::ops::RangeFull]        |            -          |\n| [RangeInclusiveExpr]   | start`..=`end | [std::ops::RangeInclusive]   | start &le; x &le; end |\n| [RangeToInclusiveExpr] | `..=`end      | [std::ops::RangeToInclusive] |            x &le; end |\n\nExamples:\n\n1..2;   // std::ops::Range\n3..;    // std::ops::RangeFrom\n..4;    // std::ops::RangeTo\n..;     // std::ops::RangeFull\n5..=6;  // std::ops::RangeInclusive\n..=7;   // std::ops::RangeToInclusive\n\nThe following expressions are equivalent.\n\nlet x = std::ops::Range {start: 0, end: 10};\nlet y = 0..10;\n\nassert_eq!(x, y);\n\nRanges can be used in `for` loops:\n\nfor i in 1..11 {\n    println!(\"{}\", i);\n}",
      "parent_id": null,
      "paragraphs": {
        "expr.range.syntax": ",expressions\nRangeExpression ->\n      RangeExpr\n    | RangeFromExpr\n    | RangeToExpr\n    | RangeFullExpr\n    | RangeInclusiveExpr\n    | RangeToInclusiveExpr\n\nRangeExpr -> Expression `..` Expression\n\nRangeFromExpr -> Expression `..`\n\nRangeToExpr -> `..` Expression\n\nRangeFullExpr -> `..`\n\nRangeInclusiveExpr -> Expression `..=` Expression\n\nRangeToInclusiveExpr -> `..=` Expression",
        "expr.range.behavior": "The `..` and `..=` operators will construct an object of one of the `std::ops::Range` (or `core::ops::Range`) variants, according to the following table:\n\n| Production             | Syntax        | Type                         | Range                 |\n|------------------------|---------------|------------------------------|-----------------------|\n| [RangeExpr]            | start`..`end  | [std::ops::Range]            | start &le; x &lt; end |\n| [RangeFromExpr]        | start`..`     | [std::ops::RangeFrom]        | start &le; x          |\n| [RangeToExpr]          | `..`end       | [std::ops::RangeTo]          |            x &lt; end |\n| [RangeFullExpr]        | `..`          | [std::ops::RangeFull]        |            -          |\n| [RangeInclusiveExpr]   | start`..=`end | [std::ops::RangeInclusive]   | start &le; x &le; end |\n| [RangeToInclusiveExpr] | `..=`end      | [std::ops::RangeToInclusive] |            x &le; end |\n\nExamples:\n\n1..2;   // std::ops::Range\n3..;    // std::ops::RangeFrom\n..4;    // std::ops::RangeTo\n..;     // std::ops::RangeFull\n5..=6;  // std::ops::RangeInclusive\n..=7;   // std::ops::RangeToInclusive",
        "expr.range.equivalence": "The following expressions are equivalent.\n\nlet x = std::ops::Range {start: 0, end: 10};\nlet y = 0..10;\n\nassert_eq!(x, y);",
        "expr.range.for": "Ranges can be used in `for` loops:\n\nfor i in 1..11 {\n    println!(\"{}\", i);\n}"
      }
    },
    {
      "id": "expr.if",
      "title": "`if` expressions",
      "level": 1,
      "content": ",expressions\nIfExpression ->\n    `if` Conditions BlockExpression\n    (`else` ( BlockExpression | IfExpression ) )?\n\nConditions ->\n      Expression _except [StructExpression]_\n    | LetChain\n\nLetChain -> LetChainCondition ( `&&` LetChainCondition )*\n\nLetChainCondition ->\n      Expression _except [ExcludedConditions]_\n    | OuterAttribute* `let` Pattern `=` Scrutinee _except [ExcludedConditions]_\n\n@root ExcludedConditions ->\n      StructExpression\n    | LazyBooleanExpression\n    | RangeExpr\n    | RangeFromExpr\n    | RangeInclusiveExpr\n    | AssignmentExpression\n    | CompoundAssignmentExpression\n<!-- TODO: The struct exception above needs clarification, see https://github.com/rust-lang/reference/issues/1808\n     The chain grammar could use some work, see https://github.com/rust-lang/reference/issues/1811\n-->\n\nThe syntax of an `if` expression is a sequence of one or more condition operands separated by `&&`,\nfollowed by a consequent block, any number of `else if` conditions and blocks, and an optional trailing `else` block.\n\nCondition operands must be either an [Expression] with a [boolean type] or a conditional `let` match.\n\nIf all of the condition operands evaluate to `true` and all of the `let` patterns successfully match their [scrutinee]s,\nthe consequent block is executed and any subsequent `else if` or `else` block is skipped.\n\nIf any condition operand evaluates to `false` or any `let` pattern does not match its scrutinee,\nthe consequent block is skipped and any subsequent `else if` condition is evaluated.\n\nIf all `if` and `else if` conditions evaluate to `false` then any `else` block is executed.\n\nAn `if` expression evaluates to the same value as the executed block, or `()` if no block is evaluated.\n\nAn `if` expression must have the same type in all situations.\n\n# let x = 3;\nif x == 4 {\n    println!(\"x is four\");\n} else if x == 3 {\n    println!(\"x is three\");\n} else {\n    println!(\"x is something else\");\n}\n\n// `if` can be used as an expression.\nlet y = if 12 * 15 > 150 {\n    \"Bigger\"\n} else {\n    \"Smaller\"\n};\nassert_eq!(y, \"Bigger\");",
      "parent_id": null,
      "paragraphs": {
        "expr.if.syntax": ",expressions\nIfExpression ->\n    `if` Conditions BlockExpression\n    (`else` ( BlockExpression | IfExpression ) )?\n\nConditions ->\n      Expression _except [StructExpression]_\n    | LetChain\n\nLetChain -> LetChainCondition ( `&&` LetChainCondition )*\n\nLetChainCondition ->\n      Expression _except [ExcludedConditions]_\n    | OuterAttribute* `let` Pattern `=` Scrutinee _except [ExcludedConditions]_\n\n@root ExcludedConditions ->\n      StructExpression\n    | LazyBooleanExpression\n    | RangeExpr\n    | RangeFromExpr\n    | RangeInclusiveExpr\n    | AssignmentExpression\n    | CompoundAssignmentExpression\n<!-- TODO: The struct exception above needs clarification, see https://github.com/rust-lang/reference/issues/1808\n     The chain grammar could use some work, see https://github.com/rust-lang/reference/issues/1811\n-->",
        "expr.if.intro": "The syntax of an `if` expression is a sequence of one or more condition operands separated by `&&`,\nfollowed by a consequent block, any number of `else if` conditions and blocks, and an optional trailing `else` block.",
        "expr.if.condition": "Condition operands must be either an [Expression] with a [boolean type] or a conditional `let` match.",
        "expr.if.condition-true": "If all of the condition operands evaluate to `true` and all of the `let` patterns successfully match their [scrutinee]s,\nthe consequent block is executed and any subsequent `else if` or `else` block is skipped.",
        "expr.if.else-if": "If any condition operand evaluates to `false` or any `let` pattern does not match its scrutinee,\nthe consequent block is skipped and any subsequent `else if` condition is evaluated.",
        "expr.if.else": "If all `if` and `else if` conditions evaluate to `false` then any `else` block is executed.",
        "expr.if.result": "An `if` expression evaluates to the same value as the executed block, or `()` if no block is evaluated.",
        "expr.if.type": "An `if` expression must have the same type in all situations.\n\n# let x = 3;\nif x == 4 {\n    println!(\"x is four\");\n} else if x == 3 {\n    println!(\"x is three\");\n} else {\n    println!(\"x is something else\");\n}\n\n// `if` can be used as an expression.\nlet y = if 12 * 15 > 150 {\n    \"Bigger\"\n} else {\n    \"Smaller\"\n};\nassert_eq!(y, \"Bigger\");"
      }
    },
    {
      "id": "expr.if.let",
      "title": "`if let` patterns",
      "level": 1,
      "content": "`let` patterns in an `if` condition allow binding new variables into scope when the pattern matches successfully.\n\nThe following examples illustrate bindings using `let` patterns:\n\nlet dish = (\"Ham\", \"Eggs\");\n\n// This body will be skipped because the pattern is refuted.\nif let (\"Bacon\", b) = dish {\n    println!(\"Bacon is served with {}\", b);\n} else {\n    // This block is evaluated instead.\n    println!(\"No bacon will be served\");\n}\n\n// This body will execute.\nif let (\"Ham\", b) = dish {\n    println!(\"Ham is served with {}\", b);\n}\n\nif let _ = 5 {\n    println!(\"Irrefutable patterns are always true\");\n}\n\nMultiple patterns may be specified with the `|` operator.\nThis has the same semantics as with `|` in [`match` expressions]:\n\nenum E {\n    X(u8),\n    Y(u8),\n    Z(u8),\n}\nlet v = E::Y(12);\nif let E::X(n) | E::Y(n) = v {\n    assert_eq!(n, 12);\n}",
      "parent_id": null,
      "paragraphs": {
        "expr.if.let.intro": "`let` patterns in an `if` condition allow binding new variables into scope when the pattern matches successfully.\n\nThe following examples illustrate bindings using `let` patterns:\n\nlet dish = (\"Ham\", \"Eggs\");\n\n// This body will be skipped because the pattern is refuted.\nif let (\"Bacon\", b) = dish {\n    println!(\"Bacon is served with {}\", b);\n} else {\n    // This block is evaluated instead.\n    println!(\"No bacon will be served\");\n}\n\n// This body will execute.\nif let (\"Ham\", b) = dish {\n    println!(\"Ham is served with {}\", b);\n}\n\nif let _ = 5 {\n    println!(\"Irrefutable patterns are always true\");\n}",
        "expr.if.let.or-pattern": "Multiple patterns may be specified with the `|` operator.\nThis has the same semantics as with `|` in [`match` expressions]:\n\nenum E {\n    X(u8),\n    Y(u8),\n    Z(u8),\n}\nlet v = E::Y(12);\nif let E::X(n) | E::Y(n) = v {\n    assert_eq!(n, 12);\n}"
      }
    },
    {
      "id": "expr.if.chains",
      "title": "Chains of conditions",
      "level": 2,
      "content": "Multiple condition operands can be separated with `&&`.\n\nSimilar to a `&&` [LazyBooleanExpression], each operand is evaluated from left-to-right until an operand evaluates as `false` or a `let` match fails,\nin which case the subsequent operands are not evaluated.\n\nThe bindings of each pattern are put into scope to be available for the next condition operand and the consequent block.\n\nThe following is an example of chaining multiple expressions, mixing `let` bindings and boolean expressions, and with expressions able to reference pattern bindings from previous expressions:\n\nfn single() {\n    let outer_opt = Some(Some(1i32));\n\n    if let Some(inner_opt) = outer_opt\n        && let Some(number) = inner_opt\n        && number == 1\n    {\n        println!(\"Peek a boo\");\n    }\n}\n\nThe above is equivalent to the following without using chains of conditions:\n\nfn nested() {\n    let outer_opt = Some(Some(1i32));\n\n    if let Some(inner_opt) = outer_opt {\n        if let Some(number) = inner_opt {\n            if number == 1 {\n                println!(\"Peek a boo\");\n            }\n        }\n    }\n}\n\nIf any condition operand is a `let` pattern, then none of the condition operands can be a `||` lazy boolean operator expression due to ambiguity and precedence with the `let` scrutinee.\nIf a `||` expression is needed, then parentheses can be used. For example:\n\n# let foo = Some(123);\n# let condition1 = true;\n# let condition2 = false;\n// Parentheses are required here.\nif let Some(x) = foo && (condition1 || condition2) { /*...*/ }\n\n> [!EDITION-2024]\n> Before the 2024 edition, let chains are not supported. That is, the [LetChain] grammar is not allowed in an `if` expression.\n\n[`match` expressions]: match-expr.md\n[boolean type]: ../types/boolean.md\n[scrutinee]: ../glossary.md#scrutinee",
      "parent_id": null,
      "paragraphs": {
        "expr.if.chains.intro": "Multiple condition operands can be separated with `&&`.",
        "expr.if.chains.order": "Similar to a `&&` [LazyBooleanExpression], each operand is evaluated from left-to-right until an operand evaluates as `false` or a `let` match fails,\nin which case the subsequent operands are not evaluated.",
        "expr.if.chains.bindings": "The bindings of each pattern are put into scope to be available for the next condition operand and the consequent block.\n\nThe following is an example of chaining multiple expressions, mixing `let` bindings and boolean expressions, and with expressions able to reference pattern bindings from previous expressions:\n\nfn single() {\n    let outer_opt = Some(Some(1i32));\n\n    if let Some(inner_opt) = outer_opt\n        && let Some(number) = inner_opt\n        && number == 1\n    {\n        println!(\"Peek a boo\");\n    }\n}\n\nThe above is equivalent to the following without using chains of conditions:\n\nfn nested() {\n    let outer_opt = Some(Some(1i32));\n\n    if let Some(inner_opt) = outer_opt {\n        if let Some(number) = inner_opt {\n            if number == 1 {\n                println!(\"Peek a boo\");\n            }\n        }\n    }\n}",
        "expr.if.chains.or": "If any condition operand is a `let` pattern, then none of the condition operands can be a `||` lazy boolean operator expression due to ambiguity and precedence with the `let` scrutinee.\nIf a `||` expression is needed, then parentheses can be used. For example:\n\n# let foo = Some(123);\n# let condition1 = true;\n# let condition2 = false;\n// Parentheses are required here.\nif let Some(x) = foo && (condition1 || condition2) { /*...*/ }",
        "expr.if.edition2024": "> [!EDITION-2024]\n> Before the 2024 edition, let chains are not supported. That is, the [LetChain] grammar is not allowed in an `if` expression.\n\n[`match` expressions]: match-expr.md\n[boolean type]: ../types/boolean.md\n[scrutinee]: ../glossary.md#scrutinee"
      }
    },
    {
      "id": "expr.match",
      "title": "`match` expressions",
      "level": 1,
      "content": ",expressions\nMatchExpression ->\n    `match` Scrutinee `{`\n        InnerAttribute*\n        MatchArms?\n    `}`\n\nScrutinee -> Expression _except [StructExpression]_\n\nMatchArms ->\n    ( MatchArm `=>` ( ExpressionWithoutBlock `,` | ExpressionWithBlock `,`? ) )*\n    MatchArm `=>` Expression `,`?\n\nMatchArm -> OuterAttribute* Pattern MatchArmGuard?\n\nMatchArmGuard -> `if` Expression\n<!-- TODO: The exception above isn't accurate, see https://github.com/rust-lang/reference/issues/569 -->\n\nA *`match` expression* branches on a pattern.\nThe exact form of matching that occurs depends on the [pattern].\n\nA `match` expression has a *[scrutinee] expression*, which is the value to compare to the patterns.\n\nThe scrutinee expression and the patterns must have the same type.\n\nA `match` behaves differently depending on whether or not the scrutinee expression is a place expression or value expression.\n\nIf the scrutinee expression is a [value expression], it is first evaluated into a temporary location, and the resulting value is sequentially compared to the patterns in the arms until a match is found.\nThe first arm with a matching pattern is chosen as the branch target of the `match`, any variables bound by the pattern are assigned to local variables in the arm's block, and control enters the block.\n\nWhen the scrutinee expression is a [place expression], the match does not allocate a temporary location;\nhowever, a by-value binding may copy or move from the memory location.\nWhen possible, it is preferable to match on place expressions, as the lifetime of these matches inherits the lifetime of the place expression rather than being restricted to the inside of the match.\n\nAn example of a `match` expression:\n\nlet x = 1;\n\nmatch x {\n    1 => println!(\"one\"),\n    2 => println!(\"two\"),\n    3 => println!(\"three\"),\n    4 => println!(\"four\"),\n    5 => println!(\"five\"),\n    _ => println!(\"something else\"),\n}\n\nVariables bound within the pattern are scoped to the match guard and the arm's expression.\n\nThe [binding mode] (move, copy, or reference) depends on the pattern.\n\nMultiple match patterns may be joined with the `|` operator.\nEach pattern will be tested in left-to-right sequence until a successful match is found.\n\nlet x = 9;\nlet message = match x {\n    0 | 1  => \"not many\",\n    2 ..= 9 => \"a few\",\n    _      => \"lots\"\n};\n\nassert_eq!(message, \"a few\");\n\n// Demonstration of pattern match order.\nstruct S(i32, i32);\n\nmatch S(1, 2) {\n    S(z @ 1, _) | S(_, z @ 2) => assert_eq!(z, 1),\n    _ => panic!(),\n}\n\n> [!NOTE]\n> The `2..=9` is a [Range Pattern], not a [Range Expression]. Thus, only those types of ranges supported by range patterns can be used in match arms.\n\nEvery binding in each `|` separated pattern must appear in all of the patterns in the arm.\n\nEvery binding of the same name must have the same type, and have the same binding mode.",
      "parent_id": null,
      "paragraphs": {
        "expr.match.syntax": ",expressions\nMatchExpression ->\n    `match` Scrutinee `{`\n        InnerAttribute*\n        MatchArms?\n    `}`\n\nScrutinee -> Expression _except [StructExpression]_\n\nMatchArms ->\n    ( MatchArm `=>` ( ExpressionWithoutBlock `,` | ExpressionWithBlock `,`? ) )*\n    MatchArm `=>` Expression `,`?\n\nMatchArm -> OuterAttribute* Pattern MatchArmGuard?\n\nMatchArmGuard -> `if` Expression\n<!-- TODO: The exception above isn't accurate, see https://github.com/rust-lang/reference/issues/569 -->",
        "expr.match.intro": "A *`match` expression* branches on a pattern.\nThe exact form of matching that occurs depends on the [pattern].",
        "expr.match.scrutinee": "A `match` expression has a *[scrutinee] expression*, which is the value to compare to the patterns.",
        "expr.match.scrutinee-constraint": "The scrutinee expression and the patterns must have the same type.",
        "expr.match.scrutinee-behavior": "A `match` behaves differently depending on whether or not the scrutinee expression is a place expression or value expression.",
        "expr.match.scrutinee-value": "If the scrutinee expression is a [value expression], it is first evaluated into a temporary location, and the resulting value is sequentially compared to the patterns in the arms until a match is found.\nThe first arm with a matching pattern is chosen as the branch target of the `match`, any variables bound by the pattern are assigned to local variables in the arm's block, and control enters the block.",
        "expr.match.scrutinee-place": "When the scrutinee expression is a [place expression], the match does not allocate a temporary location;\nhowever, a by-value binding may copy or move from the memory location.\nWhen possible, it is preferable to match on place expressions, as the lifetime of these matches inherits the lifetime of the place expression rather than being restricted to the inside of the match.\n\nAn example of a `match` expression:\n\nlet x = 1;\n\nmatch x {\n    1 => println!(\"one\"),\n    2 => println!(\"two\"),\n    3 => println!(\"three\"),\n    4 => println!(\"four\"),\n    5 => println!(\"five\"),\n    _ => println!(\"something else\"),\n}",
        "expr.match.pattern-vars": "Variables bound within the pattern are scoped to the match guard and the arm's expression.",
        "expr.match.pattern-var-binding": "The [binding mode] (move, copy, or reference) depends on the pattern.",
        "expr.match.or-pattern": "Multiple match patterns may be joined with the `|` operator.\nEach pattern will be tested in left-to-right sequence until a successful match is found.\n\nlet x = 9;\nlet message = match x {\n    0 | 1  => \"not many\",\n    2 ..= 9 => \"a few\",\n    _      => \"lots\"\n};\n\nassert_eq!(message, \"a few\");\n\n// Demonstration of pattern match order.\nstruct S(i32, i32);\n\nmatch S(1, 2) {\n    S(z @ 1, _) | S(_, z @ 2) => assert_eq!(z, 1),\n    _ => panic!(),\n}\n\n> [!NOTE]\n> The `2..=9` is a [Range Pattern], not a [Range Expression]. Thus, only those types of ranges supported by range patterns can be used in match arms.",
        "expr.match.or-patterns-restriction": "Every binding in each `|` separated pattern must appear in all of the patterns in the arm.",
        "expr.match.binding-restriction": "Every binding of the same name must have the same type, and have the same binding mode."
      }
    },
    {
      "id": "expr.match.guard",
      "title": "Match guards",
      "level": 1,
      "content": "Match arms can accept _match guards_ to further refine the criteria for matching a case.\n\nPattern guards appear after the pattern and consist of a `bool`-typed expression following the `if` keyword.\n\nWhen the pattern matches successfully, the pattern guard expression is executed.\nIf the expression evaluates to true, the pattern is successfully matched against.\n\nOtherwise, the next pattern, including other matches with the `|` operator in the same arm, is tested.\n\n# let maybe_digit = Some(0);\n# fn process_digit(i: i32) { }\n# fn process_other(i: i32) { }\nlet message = match maybe_digit {\n    Some(x) if x < 10 => process_digit(x),\n    Some(x) => process_other(x),\n    None => panic!(),\n};\n\n> [!NOTE]\n> Multiple matches using the `|` operator can cause the pattern guard and the side effects it has to execute multiple times. For example:\n>\n> ```rust\n> # use std::cell::Cell;\n> let i : Cell<i32> = Cell::new(0);\n> match 1 {\n>     1 | _ if { i.set(i.get() + 1); false } => {}\n>     _ => {}\n> }\n> assert_eq!(i.get(), 2);\n> ```\n\nA pattern guard may refer to the variables bound within the pattern they follow.\n\nBefore evaluating the guard, a shared reference is taken to the part of the scrutinee the variable matches on.\nWhile evaluating the guard, this shared reference is then used when accessing the variable.\n\nOnly when the guard evaluates to true is the value moved, or copied, from the scrutinee into the variable.\nThis allows shared borrows to be used inside guards without moving out of the scrutinee in case guard fails to match.\n\nMoreover, by holding a shared reference while evaluating the guard, mutation inside guards is also prevented.",
      "parent_id": null,
      "paragraphs": {
        "expr.match.guard.intro": "Match arms can accept _match guards_ to further refine the criteria for matching a case.",
        "expr.match.guard.type": "Pattern guards appear after the pattern and consist of a `bool`-typed expression following the `if` keyword.",
        "expr.match.guard.behavior": "When the pattern matches successfully, the pattern guard expression is executed.\nIf the expression evaluates to true, the pattern is successfully matched against.",
        "expr.match.guard.next": "Otherwise, the next pattern, including other matches with the `|` operator in the same arm, is tested.\n\n# let maybe_digit = Some(0);\n# fn process_digit(i: i32) { }\n# fn process_other(i: i32) { }\nlet message = match maybe_digit {\n    Some(x) if x < 10 => process_digit(x),\n    Some(x) => process_other(x),\n    None => panic!(),\n};\n\n> [!NOTE]\n> Multiple matches using the `|` operator can cause the pattern guard and the side effects it has to execute multiple times. For example:\n>\n> ```rust\n> # use std::cell::Cell;\n> let i : Cell<i32> = Cell::new(0);\n> match 1 {\n>     1 | _ if { i.set(i.get() + 1); false } => {}\n>     _ => {}\n> }\n> assert_eq!(i.get(), 2);\n> ```",
        "expr.match.guard.bound-variables": "A pattern guard may refer to the variables bound within the pattern they follow.",
        "expr.match.guard.shared-ref": "Before evaluating the guard, a shared reference is taken to the part of the scrutinee the variable matches on.\nWhile evaluating the guard, this shared reference is then used when accessing the variable.",
        "expr.match.guard.value": "Only when the guard evaluates to true is the value moved, or copied, from the scrutinee into the variable.\nThis allows shared borrows to be used inside guards without moving out of the scrutinee in case guard fails to match.",
        "expr.match.guard.no-mutation": "Moreover, by holding a shared reference while evaluating the guard, mutation inside guards is also prevented."
      }
    },
    {
      "id": "expr.match.attributes",
      "title": "Attributes on match arms",
      "level": 1,
      "content": "Outer attributes are allowed on match arms.\nThe only attributes that have meaning on match arms are [`cfg`] and the [lint check attributes].\n\n[Inner attributes] are allowed directly after the opening brace of the match expression in the same expression contexts as [attributes on block expressions].\n\n[`cfg`]: ../conditional-compilation.md\n[attributes on block expressions]: block-expr.md#attributes-on-block-expressions\n[binding mode]: ../patterns.md#binding-modes\n[Inner attributes]: ../attributes.md\n[lint check attributes]: ../attributes/diagnostics.md#lint-check-attributes\n[pattern]: ../patterns.md\n[place expression]: ../expressions.md#place-expressions-and-value-expressions\n[Range Expression]: range-expr.md\n[Range Pattern]: ../patterns.md#range-patterns\n[scrutinee]: ../glossary.md#scrutinee\n[value expression]: ../expressions.md#place-expressions-and-value-expressions",
      "parent_id": null,
      "paragraphs": {
        "expr.match.attributes.outer": "Outer attributes are allowed on match arms.\nThe only attributes that have meaning on match arms are [`cfg`] and the [lint check attributes].",
        "expr.match.attributes.inner": "[Inner attributes] are allowed directly after the opening brace of the match expression in the same expression contexts as [attributes on block expressions].\n\n[`cfg`]: ../conditional-compilation.md\n[attributes on block expressions]: block-expr.md#attributes-on-block-expressions\n[binding mode]: ../patterns.md#binding-modes\n[Inner attributes]: ../attributes.md\n[lint check attributes]: ../attributes/diagnostics.md#lint-check-attributes\n[pattern]: ../patterns.md\n[place expression]: ../expressions.md#place-expressions-and-value-expressions\n[Range Expression]: range-expr.md\n[Range Pattern]: ../patterns.md#range-patterns\n[scrutinee]: ../glossary.md#scrutinee\n[value expression]: ../expressions.md#place-expressions-and-value-expressions"
      }
    },
    {
      "id": "expr.return",
      "title": "`return` expressions",
      "level": 1,
      "content": ",expressions\nReturnExpression -> `return` Expression?\n\nReturn expressions are denoted with the keyword `return`.\n\nEvaluating a `return` expression moves its argument into the designated output location for the current function call, destroys the current function activation frame, and transfers control to the caller frame.\n\nAn example of a `return` expression:\n\nfn max(a: i32, b: i32) -> i32 {\n    if a > b {\n        return a;\n    }\n    return b;\n}",
      "parent_id": null,
      "paragraphs": {
        "expr.return.syntax": ",expressions\nReturnExpression -> `return` Expression?",
        "expr.return.intro": "Return expressions are denoted with the keyword `return`.",
        "expr.return.behavior": "Evaluating a `return` expression moves its argument into the designated output location for the current function call, destroys the current function activation frame, and transfers control to the caller frame.\n\nAn example of a `return` expression:\n\nfn max(a: i32, b: i32) -> i32 {\n    if a > b {\n        return a;\n    }\n    return b;\n}"
      }
    },
    {
      "id": "expr.await",
      "title": "Await expressions",
      "level": 1,
      "content": ",expressions\nAwaitExpression -> Expression `.` `await`\n\nAn `await` expression is a syntactic construct for suspending a computation\nprovided by an implementation of `std::future::IntoFuture` until the given\nfuture is ready to produce a value.\n\nThe syntax for an await expression is an expression with a type that implements the [`IntoFuture`] trait, called the *future operand*, then the token `.`, and then the `await` keyword.\n\nAwait expressions are legal only within an [async context], like an [`async fn`], [`async` closure], or [`async` block].\n\nMore specifically, an await expression has the following effect.\n\n1. Create a future by calling [`IntoFuture::into_future`] on the future operand.\n2. Evaluate the future to a [future] `tmp`;\n3. Pin `tmp` using [`Pin::new_unchecked`];\n4. This pinned future is then polled by calling the [`Future::poll`] method and passing it the current task context;\n5. If the call to `poll` returns [`Poll::Pending`], then the future returns `Poll::Pending`, suspending its state so that, when the surrounding async context is re-polled, execution returns to step 3;\n6. Otherwise the call to `poll` must have returned [`Poll::Ready`], in which case the value contained in the [`Poll::Ready`] variant is used as the result of the `await` expression itself.\n\n> [!EDITION-2018]\n> Await expressions are only available beginning with Rust 2018.",
      "parent_id": null,
      "paragraphs": {
        "expr.await.syntax": ",expressions\nAwaitExpression -> Expression `.` `await`",
        "expr.await.intro": "An `await` expression is a syntactic construct for suspending a computation\nprovided by an implementation of `std::future::IntoFuture` until the given\nfuture is ready to produce a value.",
        "expr.await.construct": "The syntax for an await expression is an expression with a type that implements the [`IntoFuture`] trait, called the *future operand*, then the token `.`, and then the `await` keyword.",
        "expr.await.allowed-positions": "Await expressions are legal only within an [async context], like an [`async fn`], [`async` closure], or [`async` block].",
        "expr.await.effects": "More specifically, an await expression has the following effect.\n\n1. Create a future by calling [`IntoFuture::into_future`] on the future operand.\n2. Evaluate the future to a [future] `tmp`;\n3. Pin `tmp` using [`Pin::new_unchecked`];\n4. This pinned future is then polled by calling the [`Future::poll`] method and passing it the current task context;\n5. If the call to `poll` returns [`Poll::Pending`], then the future returns `Poll::Pending`, suspending its state so that, when the surrounding async context is re-polled, execution returns to step 3;\n6. Otherwise the call to `poll` must have returned [`Poll::Ready`], in which case the value contained in the [`Poll::Ready`] variant is used as the result of the `await` expression itself.",
        "expr.await.edition2018": "> [!EDITION-2018]\n> Await expressions are only available beginning with Rust 2018."
      }
    },
    {
      "id": "expr.await.task",
      "title": "Task context",
      "level": 1,
      "content": "The task context refers to the [`Context`] which was supplied to the current [async context] when the async context itself was polled.\nBecause `await` expressions are only legal in an async context, there must be some task context available.",
      "parent_id": null,
      "paragraphs": {
        "expr.await.task": "The task context refers to the [`Context`] which was supplied to the current [async context] when the async context itself was polled.\nBecause `await` expressions are only legal in an async context, there must be some task context available."
      }
    },
    {
      "id": "expr.await.desugar",
      "title": "Approximate desugaring",
      "level": 2,
      "content": "Effectively, an await expression is roughly equivalent to the following non-normative desugaring:\n\n<!-- ignore: example expansion -->\n,ignore\nmatch operand.into_future() {\n    mut pinned => loop {\n        let mut pin = unsafe { Pin::new_unchecked(&mut pinned) };\n        match Pin::future::poll(Pin::borrow(&mut pin), &mut current_context) {\n            Poll::Ready(r) => break r,\n            Poll::Pending => yield Poll::Pending,\n        }\n    }\n}\n\nwhere the `yield` pseudo-code returns `Poll::Pending` and, when re-invoked, resumes execution from that point.\nThe variable `current_context` refers to the context taken from the async environment.\n\n[`async fn`]: ../items/functions.md#async-functions\n[`async` closure]: closure-expr.md#async-closures\n[`async` block]: block-expr.md#async-blocks\n[`Context`]: std::task::Context\n[`future::poll`]: std::future::Future::poll\n[`pin::new_unchecked`]: std::pin::Pin::new_unchecked\n[`poll::Pending`]: std::task::Poll::Pending\n[`poll::Ready`]: std::task::Poll::Ready\n[async context]: ../expressions/block-expr.md#async-context\n[future]: std::future::Future\n[`IntoFuture`]: std::future::IntoFuture\n[`IntoFuture::into_future`]: std::future::IntoFuture::into_future",
      "parent_id": null,
      "paragraphs": {
        "expr.await.desugar": "Effectively, an await expression is roughly equivalent to the following non-normative desugaring:\n\n<!-- ignore: example expansion -->\n,ignore\nmatch operand.into_future() {\n    mut pinned => loop {\n        let mut pin = unsafe { Pin::new_unchecked(&mut pinned) };\n        match Pin::future::poll(Pin::borrow(&mut pin), &mut current_context) {\n            Poll::Ready(r) => break r,\n            Poll::Pending => yield Poll::Pending,\n        }\n    }\n}\n\nwhere the `yield` pseudo-code returns `Poll::Pending` and, when re-invoked, resumes execution from that point.\nThe variable `current_context` refers to the context taken from the async environment.\n\n[`async fn`]: ../items/functions.md#async-functions\n[`async` closure]: closure-expr.md#async-closures\n[`async` block]: block-expr.md#async-blocks\n[`Context`]: std::task::Context\n[`future::poll`]: std::future::Future::poll\n[`pin::new_unchecked`]: std::pin::Pin::new_unchecked\n[`poll::Pending`]: std::task::Poll::Pending\n[`poll::Ready`]: std::task::Poll::Ready\n[async context]: ../expressions/block-expr.md#async-context\n[future]: std::future::Future\n[`IntoFuture`]: std::future::IntoFuture\n[`IntoFuture::into_future`]: std::future::IntoFuture::into_future"
      }
    },
    {
      "id": "expr.placeholder",
      "title": "`_` expressions",
      "level": 1,
      "content": ",expressions\nUnderscoreExpression -> `_`\n\nUnderscore expressions, denoted with the symbol `_`, are used to signify a\nplaceholder in a destructuring assignment.\n\nThey may only appear in the left-hand side of an assignment.\n\nNote that this is distinct from the wildcard pattern.\n\nExamples of `_` expressions:\n\nlet p = (1, 2);\nlet mut a = 0;\n(_, a) = p;\n\nstruct Position {\n    x: u32,\n    y: u32,\n}\n\nPosition { x: a, y: _ } = Position{ x: 2, y: 3 };\n\n// unused result, assignment to `_` used to declare intent and remove a warning\n_ = 2 + 2;\n// triggers unused_must_use warning\n// 2 + 2;\n\n// equivalent technique using a wildcard pattern in a let-binding\nlet _ = 2 + 2;",
      "parent_id": null,
      "paragraphs": {
        "expr.placeholder.syntax": ",expressions\nUnderscoreExpression -> `_`",
        "expr.placeholder.intro": "Underscore expressions, denoted with the symbol `_`, are used to signify a\nplaceholder in a destructuring assignment.",
        "expr.placeholder.lhs-assignment-only": "They may only appear in the left-hand side of an assignment.",
        "expr.placeholder.pattern": "Note that this is distinct from the wildcard pattern.\n\nExamples of `_` expressions:\n\nlet p = (1, 2);\nlet mut a = 0;\n(_, a) = p;\n\nstruct Position {\n    x: u32,\n    y: u32,\n}\n\nPosition { x: a, y: _ } = Position{ x: 2, y: 3 };\n\n// unused result, assignment to `_` used to declare intent and remove a warning\n_ = 2 + 2;\n// triggers unused_must_use warning\n// 2 + 2;\n\n// equivalent technique using a wildcard pattern in a let-binding\nlet _ = 2 + 2;"
      }
    }
  ],
  "ids": [
    "expr.place-value.value-expr-kinds",
    "expr.literal.int.separators-stripped",
    "expr.literal.byte-string.intro",
    "expr.await",
    "expr.array.repeat",
    "expr.literal.float.value",
    "statement.item",
    "expr.loop.continue.syntax",
    "expr.block.unsafe",
    "expr.compound-assign.result",
    "expr.literal.c-string.no-suffix",
    "expr.method.candidate-receivers",
    "expr.closure.param-attributes",
    "expr.operator.int-overflow.binary-arith",
    "expr.as.pointer",
    "expr.move.intro",
    "expr.loop.continue.label",
    "expr.array.index.trait",
    "expr.move.deinitialization",
    "expr.deref.mut",
    "expr.paren.intro",
    "statement.item.outer-generics",
    "expr.loop.while.condition",
    "expr.loop.while.let.or-pattern",
    "expr.struct.tuple-field",
    "expr.arith-logic",
    "expr.loop.explicit-result",
    "expr.loop",
    "expr.await.construct",
    "expr.block.statements",
    "expr.loop.break-label",
    "expr.literal.byte-string.represented",
    "expr.literal.float.suffix",
    "statement.let.constraint",
    "expr.loop.while.syntax",
    "expr.struct.syntax",
    "expr.match.guard.bound-variables",
    "expr.as.numeric.int-same-size",
    "expr.place-value.place-expr-kinds",
    "expr.loop.block-labels",
    "expr.negate.syntax",
    "expr.literal.escape.sequence",
    "expr.as.numeric.int-extension",
    "expr.await.intro",
    "expr.loop.while.chains.intro",
    "expr.attr.never-before",
    "expr.match.guard",
    "expr.literal.escape.hex-ascii",
    "expr.negate",
    "expr.match.scrutinee-constraint",
    "expr.loop.label.intro",
    "expr.field.form",
    "expr.loop.break-value.loop",
    "expr.paren.evaluation",
    "expr.operands",
    "expr.loop.block-labels.label-required",
    "expr.literal.int.inference-default",
    "expr.cmp.intro",
    "statement.expr.constraint-block",
    "expr.tuple.value",
    "expr.range.syntax",
    "expr.match.scrutinee-behavior",
    "expr.literal.int.radix-prefix-stripped",
    "expr.tuple.intro",
    "expr.deref.result",
    "expr.match.pattern-vars",
    "expr.loop.for.lang-items",
    "expr.literal.c-string.raw",
    "expr.assign.intro",
    "expr.overload",
    "expr.as.enum.no-drop",
    "expr.array",
    "expr.literal.string.type",
    "expr.borrow.and-and-syntax",
    "statement.item.associated-scope",
    "expr.block.value",
    "expr.as.numeric",
    "expr.match.attributes.outer",
    "expr.if.type",
    "expr.if.result",
    "expr.loop.break.label",
    "expr.loop.for.desugar",
    "expr.literal.c-string.intro",
    "expr.array.repeat-behavior",
    "expr.block.const",
    "expr.literal.char.type",
    "expr.super-macros",
    "expr.struct.field",
    "expr.literal.byte-char.result",
    "expr.assign.behavior-basic",
    "expr.operator.borrow.result",
    "expr.call.convergence",
    "expr.as.pointer-as-int",
    "expr.block.null-statement",
    "expr.literal.byte-string",
    "expr.mut",
    "expr.literal.float",
    "expr.tuple",
    "expr.call.desugar.limits",
    "expr.call.autoref-deref",
    "expr.assign.destructure.discard-value",
    "expr.literal.string.raw",
    "expr.block.namespace",
    "expr.array.repeat-evaluation-zero",
    "expr.deref",
    "expr.cmp",
    "expr.paren",
    "statement.item.scope",
    "expr.literal.escape.simple",
    "expr.field.autoref-deref",
    "expr.closure.captures",
    "expr.literal.int.intro",
    "expr.call",
    "expr.literal.escape.intro",
    "expr.literal.escape.unicode",
    "expr.literal.int.inference-unique-type",
    "expr.as.u8-as-char",
    "expr.tuple-index.index-name-operand",
    "statement",
    "expr.literal.string-representation",
    "expr.match.intro",
    "expr.operator.borrow.intro",
    "expr.closure.capture-mut-ref",
    "expr.loop.label.ref",
    "expr.placeholder.intro",
    "expr.move",
    "expr.literal.float.type-suffix-stripped",
    "expr.operator.borrow",
    "expr.loop.while",
    "expr.block.const.context",
    "expr.loop.while.let.intro",
    "expr.literal.char.literal-content",
    "expr.assign.result",
    "expr.literal.byte-char.literal-content",
    "expr.loop.infinite.break",
    "expr.array.index.syntax",
    "expr.arith-logic.behavior",
    "expr.if",
    "expr.mut.intro",
    "expr.await.task",
    "expr.field.syntax",
    "expr.array.repeat-non-const",
    "expr.as.coercions",
    "expr.paren.place-or-value",
    "statement.expr",
    "expr.negate.results",
    "expr.call.desugar.ambiguity",
    "statement.intro",
    "expr.loop.while.let",
    "statement.let.scope",
    "expr.literal.byte-char.intro",
    "expr.match.attributes",
    "expr.literal.int.type-suffix-stripped",
    "expr.method.ambiguous-target",
    "expr.match.guard.shared-ref",
    "expr.method",
    "expr.block.syntax",
    "expr",
    "expr.arith-logic.intro",
    "expr.loop.while.chains",
    "expr.block.const.evaluation",
    "expr.compound-assign.operand-order",
    "expr.place-value",
    "expr.if.chains.order",
    "expr.assign.evaluation-order",
    "expr.if.intro",
    "expr.if.let.or-pattern",
    "expr.try.intro",
    "expr.as.pointer.behavior",
    "expr.loop.while.let.desugar",
    "expr.literal.c-string.represented",
    "expr.loop.continue.in-loop-only",
    "expr.as.int-as-pointer",
    "expr.array.array",
    "expr.literal.bool.intro",
    "expr.loop.break.value",
    "expr.closure.capture-move",
    "expr.block.async.layout-unspecified",
    "expr.literal.escape",
    "expr.literal.float.result",
    "expr.method.candidate-search",
    "expr.field.borrow",
    "expr.struct.field.union-constraint",
    "expr.operator.borrow.syntax",
    "expr.match.binding-restriction",
    "expr.block.evaluation",
    "expr.block.const.generic-params",
    "expr.literal.byte-string.escape",
    "statement.decl",
    "expr.array.index.const",
    "expr.placeholder.lhs-assignment-only",
    "expr.assign.destructuring-order",
    "expr.array.index.trait-impl",
    "expr.assign.destructure",
    "expr.call.desugar",
    "statement.attribute",
    "expr.path",
    "expr.as.enum.discriminant",
    "statement.let.behavior",
    "expr.literal.c-string",
    "expr.compound-assign.intro",
    "expr.struct.field.intro",
    "expr.try",
    "expr.struct.update.visibility-constraint",
    "expr.operator.syntax",
    "expr.compound-assign.no-value",
    "expr.await.desugar",
    "expr.implicit-borrow",
    "expr.literal.c-string.literal-content",
    "expr.literal.int.radix",
    "expr.loop.while.eval",
    "expr.literal.char",
    "expr.method.candidate-receivers-refs",
    "expr.mut.valid-places",
    "expr.path.safety",
    "expr.call.desugar.explicit-path",
    "expr.literal.c-string.escape",
    "expr.placeholder",
    "expr.block.async.edition2018",
    "expr.if.let",
    "expr.behavior",
    "expr.paren.override-precedence",
    "expr.tuple.type",
    "statement.let.intro",
    "expr.block.unsafe.syntax",
    "expr.block.async.intro",
    "expr.struct.field.named",
    "expr.loop.infinite.syntax",
    "statement.expr.syntax",
    "expr.literal.string",
    "expr.block.async.function.return-try",
    "expr.move.requires-sized",
    "expr.literal",
    "expr.path.syntax",
    "statement.syntax",
    "expr.literal.string.represented",
    "expr.closure.syntax",
    "expr.match.guard.no-mutation",
    "expr.block.async.future",
    "expr.loop.break-value.intro",
    "expr.block.sequential-evaluation",
    "expr.move.movable-place",
    "expr.compound-assign.trait",
    "expr.assign.destructure.tmp-scopes",
    "expr.await.effects",
    "expr.literal.string.no-suffix",
    "expr.literal.byte-string.no-suffix",
    "expr.try.restricted-types",
    "expr.attr",
    "expr.deref.safety",
    "expr.struct.intro",
    "expr.implicit-borrow.application",
    "expr.place-value.intro",
    "expr.literal.float.infer",
    "expr.loop.break-value",
    "expr.array.syntax",
    "expr.block.attributes.inner-attributes",
    "expr.closure",
    "expr.block.async.capture",
    "expr.path.intro",
    "expr.range",
    "expr.block.async.syntax",
    "expr.place-value.parenthesis",
    "expr.tuple.unit",
    "expr.if.else-if",
    "expr.compound-assign.place",
    "expr.if.chains.bindings",
    "expr.literal.int.suffix",
    "expr.loop.continue.intro",
    "expr.tuple.syntax",
    "expr.struct.update.base-same-type",
    "expr.return",
    "expr.literal.syntax",
    "expr.literal.char.no-suffix",
    "expr.assign.destructure.assignee",
    "expr.block",
    "expr.bool-logic.intro",
    "expr.if.chains",
    "expr.deref.traits",
    "expr.assign.destructure.default-binding",
    "expr.operator.borrow.mut",
    "expr.operator.int-overflow",
    "statement.expr.intro",
    "expr.tuple-index.result",
    "expr.match.scrutinee-value",
    "expr.as.numeric.int-as-float",
    "expr.bool-logic",
    "expr.array.repeat-copy",
    "expr.match.or-patterns-restriction",
    "expr.loop.infinite.intro",
    "expr.compound-assign.primitives",
    "expr.literal.continuation",
    "expr.literal.float.inference-error",
    "expr.placeholder.pattern",
    "expr.super-macros.format_args",
    "expr.block.const.intro",
    "expr.implicit-borrow-intro",
    "expr.method.target",
    "expr.call.trait",
    "expr.if.condition-true",
    "expr.structure",
    "expr.loop.break.syntax",
    "expr.literal.byte-char.represented",
    "expr.block.async.anonymous-type",
    "expr.operator.int-overflow.div",
    "expr.assign.destructure.repeat-ident",
    "statement.item.intro",
    "expr.struct",
    "expr.operator.int-overflow.unary-neg",
    "expr.cmp.trait",
    "expr.compound-assign",
    "expr.loop.break",
    "expr.cmp.behavior",
    "expr.array.index.zero-index",
    "expr.as.numeric.float-widening",
    "expr.super-macros.format_args.super-temporaries",
    "expr.super-macros.intro",
    "expr.deref.intro",
    "expr.assign.behavior-destructuring",
    "statement.expr.restriction-semicolon",
    "expr.assign.destructure.intro",
    "expr.block.attributes.valid",
    "expr.loop.for.condition",
    "expr.block.const.not-executed",
    "expr.closure.async",
    "expr.array.length-restriction",
    "expr.literal.escape.hex-octet",
    "expr.literal.string.escape",
    "expr.literal.c-string.result",
    "expr.block.label",
    "expr.as.pointer.unsized",
    "expr.precedence",
    "expr.array.array-syntax",
    "expr.loop.for.intro",
    "expr.block.async.function",
    "expr.assign.syntax",
    "expr.borrow.raw",
    "expr.path.const",
    "expr.as.result",
    "expr.range.for",
    "expr.operator.int-overflow.intro",
    "expr.closure.parameter-restriction",
    "expr.literal.byte-char.escape",
    "expr.literal.int",
    "expr.if.edition2024",
    "expr.literal.literal-token",
    "expr.intro",
    "expr.return.intro",
    "expr.range.behavior",
    "expr.tuple-index.syntax",
    "expr.literal.char.intro",
    "expr.call.syntax",
    "expr.closure.trait-impl",
    "expr.match.guard.intro",
    "expr.call.intro",
    "expr.closure.async.intro",
    "expr.as.numeric.float-as-int",
    "expr.compound-assign.syntax",
    "expr.cmp.place",
    "expr.operand-order.operands-before-primary",
    "expr.array.constructor",
    "expr.as.bool-char-as-int",
    "expr.loop.label.control-flow",
    "expr.assign.assignee",
    "expr.literal.byte-char.literal",
    "expr.path.place",
    "expr.literal.bool.result",
    "expr.tuple-index.required-type",
    "expr.borrow.raw.place",
    "expr.cmp.paren-chaining",
    "expr.match.guard.type",
    "expr.operator.intro",
    "expr.operand-order.default",
    "expr.assign.destructure.tmp-ext",
    "expr.paren.syntax",
    "expr.placeholder.syntax",
    "expr.as.numeric.int-truncation",
    "expr.literal.byte-string.literal-content",
    "expr.block.async.future-result",
    "expr.literal.string.literal-content",
    "expr.arith-logic.syntax",
    "expr.match.guard.behavior",
    "expr.loop.continue.while",
    "statement.let.syntax",
    "expr.as.syntax",
    "expr.array.index.array",
    "expr.array.array-behavior",
    "expr.assign.basic",
    "expr.syntax",
    "expr.literal.string.result",
    "expr.block.async",
    "expr.match.pattern-var-binding",
    "expr.assign.drop-target",
    "statement.let.inference",
    "expr.negate.intro",
    "expr.range.equivalence",
    "expr.loop.while.grammar",
    "expr.array.repeat-operand",
    "expr.if.chains.or",
    "expr.try.syntax",
    "expr.match",
    "expr.match.syntax",
    "expr.super-macros.pin.super-operands",
    "expr.match.guard.value",
    "expr.match.scrutinee-place",
    "expr.literal.float.intro",
    "expr.evaluation",
    "expr.literal.byte-string.raw",
    "expr.block.result",
    "expr.array.repeat-const-item",
    "statement.let",
    "expr.as.pointer.discard-metadata",
    "expr.loop.for.syntax",
    "expr.loop.block-labels.break",
    "expr.closure.unique-type",
    "expr.attr.restriction",
    "expr.call.desugar.fully-qualified",
    "expr.field.intro",
    "expr.temporary",
    "expr.as",
    "expr.assign",
    "expr.struct.update",
    "expr.tuple.unary-tuple-restriction",
    "expr.if.syntax",
    "expr.literal.intro",
    "expr.match.or-pattern",
    "expr.literal.int.infer",
    "expr.block.attributes",
    "expr.field",
    "expr.deref.syntax",
    "statement.kind",
    "expr.block.async.function.intro",
    "expr.place-value.assignee",
    "expr.closure.async.future",
    "expr.literal.float.separators-stripped",
    "expr.borrow.raw.intro",
    "expr.closure.intro",
    "expr.tuple.result",
    "expr.array.length-operand",
    "expr.literal.c-string.type",
    "expr.super-macros.pin.super-temporaries",
    "expr.if.else",
    "expr.await.edition2018",
    "expr.super-macros.pin",
    "expr.operator.trait",
    "expr.if.chains.intro",
    "expr.operand-order",
    "expr.array.index",
    "expr.bool-logic.conditional-evaluation",
    "expr.literal.float.inference-default",
    "expr.as.pointer.sized",
    "expr.struct.update.intro",
    "expr.loop.while.repeat",
    "expr.block.unsafe.intro",
    "expr.tuple.fields",
    "expr.operator.borrow.temporary",
    "expr.as.numeric.float-narrowing",
    "expr.literal.byte-char.single",
    "expr.block.inner-attributes",
    "expr.match.guard.next",
    "expr.if.condition",
    "expr.match.attributes.inner",
    "expr.literal.int.inference-error",
    "stmt-expr",
    "expr.closure.param-type",
    "expr.loop.syntax",
    "expr.literal.float.inference-unique-type",
    "expr.literal.char.result",
    "expr.loop.label.syntax",
    "expr.struct.brace-restricted-positions",
    "expr.method.edition2021",
    "expr.block.async.function.control-flow",
    "expr.super-macros.format_args.super-operands",
    "expr.method.receiver-constraints",
    "expr.loop.intro",
    "expr.field.mut",
    "expr.match.scrutinee",
    "expr.place-value.value-result",
    "expr.tuple-index.index-syntax",
    "expr.cmp.syntax",
    "expr.closure.capture-inference",
    "expr.move.copy",
    "expr.literal.byte-string.result",
    "expr.literal.char.represented",
    "expr.literal.const-expr",
    "expr.return.behavior",
    "expr.as.intro",
    "expr.literal.int.u128-value",
    "expr.borrow.raw.result",
    "expr.field.not-method-call",
    "expr.literal.byte-string.type",
    "expr.if.let.intro",
    "expr.operator.borrow.lifetime",
    "expr.literal.bool",
    "expr.block.type",
    "expr.loop.block-labels.syntax",
    "expr.borrow.raw.invalid-ref",
    "expr.loop.for",
    "expr.loop.continue-label",
    "expr.literal.int.cast",
    "expr.operator",
    "expr.operator.int-overflow.shift",
    "expr.move.place-invalid",
    "expr.bool-logic.syntax",
    "expr.loop.block-labels.intro",
    "expr.place-value.place-context",
    "expr.return.syntax",
    "expr.block.const.syntax",
    "expr.method.autoref-deref",
    "expr.struct.update.fields",
    "expr.literal.byte-char.no-suffix",
    "expr.literal.char.escape",
    "expr.literal.byte-char",
    "expr.await.syntax",
    "expr.block.intro",
    "expr.tuple-index",
    "expr.loop.continue.for",
    "expr.method.ambiguous-search",
    "expr.loop.infinite.diverging",
    "expr.literal.char.single",
    "expr.assign.destructure.irrefutable",
    "expr.loop.infinite",
    "expr.block.async.context",
    "expr.loop.while.intro",
    "expr.as.enum",
    "expr.closure.async.edition2018",
    "expr.assign.behavior",
    "expr.method.syntax",
    "expr.loop.continue",
    "expr.loop.label",
    "expr.place-value.place-memory-location",
    "expr.tuple-index.intro",
    "expr.literal.int.representation",
    "expr.method.intro",
    "expr.loop.break.intro",
    "expr.closure.explicit-type-body",
    "expr.await.allowed-positions",
    "expr.literal.string.intro",
    "expr.loop.while.exit"
  ]
}
