{
  "source": "Rust Reference",
  "source_repo": "https://github.com/rust-lang/reference",
  "extraction_date": "2026-01-03",
  "chapter": 7,
  "title": "Items",
  "file": "items.md",
  "sections": [
    {
      "id": "items",
      "title": "Items",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "items.syntax",
      "title": "Items",
      "level": 1,
      "content": ",items\nItem ->\n    OuterAttribute* ( VisItem | MacroItem )\n\nVisItem ->\n    Visibility?\n    (\n        Module\n      | ExternCrate\n      | UseDeclaration\n      | Function\n      | TypeAlias\n      | Struct\n      | Enumeration\n      | Union\n      | ConstantItem\n      | StaticItem\n      | Trait\n      | Implementation\n      | ExternBlock\n    )\n\nMacroItem ->\n      MacroInvocationSemi\n    | MacroRulesDefinition",
      "parent_id": null,
      "paragraphs": {
        "items.syntax": ",items\nItem ->\n    OuterAttribute* ( VisItem | MacroItem )\n\nVisItem ->\n    Visibility?\n    (\n        Module\n      | ExternCrate\n      | UseDeclaration\n      | Function\n      | TypeAlias\n      | Struct\n      | Enumeration\n      | Union\n      | ConstantItem\n      | StaticItem\n      | Trait\n      | Implementation\n      | ExternBlock\n    )\n\nMacroItem ->\n      MacroInvocationSemi\n    | MacroRulesDefinition"
      }
    },
    {
      "id": "items.intro",
      "title": "Items",
      "level": 1,
      "content": "An _item_ is a component of a crate. Items are organized within a crate by a\nnested set of [modules]. Every crate has a single \"outermost\" anonymous module;\nall further items within the crate have [paths] within the module tree of the\ncrate.",
      "parent_id": null,
      "paragraphs": {
        "items.intro": "An _item_ is a component of a crate. Items are organized within a crate by a\nnested set of [modules]. Every crate has a single \"outermost\" anonymous module;\nall further items within the crate have [paths] within the module tree of the\ncrate."
      }
    },
    {
      "id": "items.static-def",
      "title": "Items",
      "level": 1,
      "content": "Items are entirely determined at compile-time, generally remain fixed during\nexecution, and may reside in read-only memory.",
      "parent_id": null,
      "paragraphs": {
        "items.static-def": "Items are entirely determined at compile-time, generally remain fixed during\nexecution, and may reside in read-only memory."
      }
    },
    {
      "id": "items.kinds",
      "title": "Items",
      "level": 1,
      "content": "There are several kinds of items:\n\n* [modules]\n* [`extern crate` declarations]\n* [`use` declarations]\n* [function definitions]\n* [type alias definitions]\n* [struct definitions]\n* [enumeration definitions]\n* [union definitions]\n* [constant items]\n* [static items]\n* [trait definitions]\n* [implementations]\n* [`extern` blocks]",
      "parent_id": null,
      "paragraphs": {
        "items.kinds": "There are several kinds of items:\n\n* [modules]\n* [`extern crate` declarations]\n* [`use` declarations]\n* [function definitions]\n* [type alias definitions]\n* [struct definitions]\n* [enumeration definitions]\n* [union definitions]\n* [constant items]\n* [static items]\n* [trait definitions]\n* [implementations]\n* [`extern` blocks]"
      }
    },
    {
      "id": "items.locations",
      "title": "Items",
      "level": 1,
      "content": "Items may be declared in the [root of the crate], a module, or a [block expression].",
      "parent_id": null,
      "paragraphs": {
        "items.locations": "Items may be declared in the [root of the crate], a module, or a [block expression]."
      }
    },
    {
      "id": "items.associated-locations",
      "title": "Items",
      "level": 1,
      "content": "A subset of items, called [associated items], may be declared in [traits] and [implementations].",
      "parent_id": null,
      "paragraphs": {
        "items.associated-locations": "A subset of items, called [associated items], may be declared in [traits] and [implementations]."
      }
    },
    {
      "id": "items.extern-locations",
      "title": "Items",
      "level": 1,
      "content": "A subset of items, called external items, may be declared in [`extern` blocks].",
      "parent_id": null,
      "paragraphs": {
        "items.extern-locations": "A subset of items, called external items, may be declared in [`extern` blocks]."
      }
    },
    {
      "id": "items.decl-order",
      "title": "Items",
      "level": 1,
      "content": "Items may be defined in any order, with the exception of [`macro_rules`] which has its own scoping behavior.",
      "parent_id": null,
      "paragraphs": {
        "items.decl-order": "Items may be defined in any order, with the exception of [`macro_rules`] which has its own scoping behavior."
      }
    },
    {
      "id": "items.name-resolution",
      "title": "Items",
      "level": 1,
      "content": "[Name resolution] of item names allows items to be defined before or after where the item is referred to in the module or block.\n\nSee [item scopes] for information on the scoping rules of items.\n\n[`extern crate` declarations]: items/extern-crates.md\n[`extern` blocks]: items/external-blocks.md\n[`macro_rules`]: macros-by-example.md\n[`use` declarations]: items/use-declarations.md\n[associated items]: items/associated-items.md\n[block expression]: expressions/block-expr.md\n[constant items]: items/constant-items.md\n[enumeration definitions]: items/enumerations.md\n[function definitions]: items/functions.md\n[implementations]: items/implementations.md\n[item scopes]: names/scopes.md#item-scopes\n[modules]: items/modules.md\n[name resolution]: names/name-resolution.md\n[paths]: paths.md\n[root of the crate]: crates-and-source-files.md\n[statement]: statements.md\n[static items]: items/static-items.md\n[struct definitions]: items/structs.md\n[trait definitions]: items/traits.md\n[traits]: items/traits.md\n[type alias definitions]: items/type-aliases.md\n[union definitions]: items/unions.md",
      "parent_id": null,
      "paragraphs": {
        "items.name-resolution": "[Name resolution] of item names allows items to be defined before or after where the item is referred to in the module or block.\n\nSee [item scopes] for information on the scoping rules of items.\n\n[`extern crate` declarations]: items/extern-crates.md\n[`extern` blocks]: items/external-blocks.md\n[`macro_rules`]: macros-by-example.md\n[`use` declarations]: items/use-declarations.md\n[associated items]: items/associated-items.md\n[block expression]: expressions/block-expr.md\n[constant items]: items/constant-items.md\n[enumeration definitions]: items/enumerations.md\n[function definitions]: items/functions.md\n[implementations]: items/implementations.md\n[item scopes]: names/scopes.md#item-scopes\n[modules]: items/modules.md\n[name resolution]: names/name-resolution.md\n[paths]: paths.md\n[root of the crate]: crates-and-source-files.md\n[statement]: statements.md\n[static items]: items/static-items.md\n[struct definitions]: items/structs.md\n[trait definitions]: items/traits.md\n[traits]: items/traits.md\n[type alias definitions]: items/type-aliases.md\n[union definitions]: items/unions.md"
      }
    },
    {
      "id": "items.mod",
      "title": "Modules",
      "level": 1,
      "content": ",items\nModule ->\n      `unsafe`? `mod` IDENTIFIER `;`\n    | `unsafe`? `mod` IDENTIFIER `{`\n        InnerAttribute*\n        Item*\n      `}`\n\nA module is a container for zero or more [items].\n\nA _module item_ is a module, surrounded in braces, named, and prefixed with the\nkeyword `mod`. A module item introduces a new, named module into the tree of\nmodules making up a crate.\n\nModules can nest arbitrarily.\n\nAn example of a module:\n\nmod math {\n    type Complex = (f64, f64);\n    fn sin(f: f64) -> f64 {\n        /* ... */\n#       unimplemented!();\n    }\n    fn cos(f: f64) -> f64 {\n        /* ... */\n#       unimplemented!();\n    }\n    fn tan(f: f64) -> f64 {\n        /* ... */\n#       unimplemented!();\n    }\n}\n\nModules are defined in the [type namespace] of the module or block where they are located.\n\nIt is an error to define multiple items with the same name in the same namespace within a module.\nSee the [scopes chapter] for more details on restrictions and shadowing behavior.\n\nThe `unsafe` keyword is syntactically allowed to appear before the `mod`\nkeyword, but it is rejected at a semantic level. This allows macros to consume\nthe syntax and make use of the `unsafe` keyword, before removing it from the\ntoken stream.",
      "parent_id": null,
      "paragraphs": {
        "items.mod.syntax": ",items\nModule ->\n      `unsafe`? `mod` IDENTIFIER `;`\n    | `unsafe`? `mod` IDENTIFIER `{`\n        InnerAttribute*\n        Item*\n      `}`",
        "items.mod.intro": "A module is a container for zero or more [items].",
        "items.mod.def": "A _module item_ is a module, surrounded in braces, named, and prefixed with the\nkeyword `mod`. A module item introduces a new, named module into the tree of\nmodules making up a crate.",
        "items.mod.nesting": "Modules can nest arbitrarily.\n\nAn example of a module:\n\nmod math {\n    type Complex = (f64, f64);\n    fn sin(f: f64) -> f64 {\n        /* ... */\n#       unimplemented!();\n    }\n    fn cos(f: f64) -> f64 {\n        /* ... */\n#       unimplemented!();\n    }\n    fn tan(f: f64) -> f64 {\n        /* ... */\n#       unimplemented!();\n    }\n}",
        "items.mod.namespace": "Modules are defined in the [type namespace] of the module or block where they are located.",
        "items.mod.multiple-items": "It is an error to define multiple items with the same name in the same namespace within a module.\nSee the [scopes chapter] for more details on restrictions and shadowing behavior.",
        "items.mod.unsafe": "The `unsafe` keyword is syntactically allowed to appear before the `mod`\nkeyword, but it is rejected at a semantic level. This allows macros to consume\nthe syntax and make use of the `unsafe` keyword, before removing it from the\ntoken stream."
      }
    },
    {
      "id": "items.mod.outlined",
      "title": "Module source filenames",
      "level": 1,
      "content": "A module without a body is loaded from an external file. When the module does\nnot have a `path` attribute, the path to the file mirrors the logical [module\npath].\n\nAncestor module path components are directories, and the module's\ncontents are in a file with the name of the module plus the `.rs` extension.\nFor example, the following module structure can have this corresponding\nfilesystem structure:\n\nModule Path               | Filesystem Path  | File Contents\n------------------------- | ---------------  | -------------\n`crate`                   | `lib.rs`         | `mod util;`\n`crate::util`             | `util.rs`        | `mod config;`\n`crate::util::config`     | `util/config.rs` |\n\nModule filenames may also be the name of the module as a directory with the\ncontents in a file named `mod.rs` within that directory. The above example can\nalternately be expressed with `crate::util`'s contents in a file named\n`util/mod.rs`. It is not allowed to have both `util.rs` and `util/mod.rs`.\n\n> [!NOTE]\n> Prior to `rustc` 1.30, using `mod.rs` files was the way to load a module with nested children. It is encouraged to use the new naming convention as it is more consistent, and avoids having many files named `mod.rs` within a project.",
      "parent_id": null,
      "paragraphs": {
        "items.mod.outlined.intro": "A module without a body is loaded from an external file. When the module does\nnot have a `path` attribute, the path to the file mirrors the logical [module\npath].",
        "items.mod.outlined.search": "Ancestor module path components are directories, and the module's\ncontents are in a file with the name of the module plus the `.rs` extension.\nFor example, the following module structure can have this corresponding\nfilesystem structure:\n\nModule Path               | Filesystem Path  | File Contents\n------------------------- | ---------------  | -------------\n`crate`                   | `lib.rs`         | `mod util;`\n`crate::util`             | `util.rs`        | `mod config;`\n`crate::util::config`     | `util/config.rs` |",
        "items.mod.outlined.search-mod": "Module filenames may also be the name of the module as a directory with the\ncontents in a file named `mod.rs` within that directory. The above example can\nalternately be expressed with `crate::util`'s contents in a file named\n`util/mod.rs`. It is not allowed to have both `util.rs` and `util/mod.rs`.\n\n> [!NOTE]\n> Prior to `rustc` 1.30, using `mod.rs` files was the way to load a module with nested children. It is encouraged to use the new naming convention as it is more consistent, and avoids having many files named `mod.rs` within a project."
      }
    },
    {
      "id": "items.mod.outlined.path",
      "title": "The `path` attribute",
      "level": 2,
      "content": "The directories and files used for loading external file modules can be\ninfluenced with the `path` attribute.\n\nFor `path` attributes on modules not inside inline module blocks, the file\npath is relative to the directory the source file is located. For example, the\nfollowing code snippet would use the paths shown based on where it is located:\n\n<!-- ignore: requires external files -->\n,ignore\n#[path = \"foo.rs\"]\nmod c;\n\nSource File    | `c`'s File Location | `c`'s Module Path\n-------------- | ------------------- | ----------------------\n`src/a/b.rs`   | `src/a/foo.rs`      | `crate::a::b::c`\n`src/a/mod.rs` | `src/a/foo.rs`      | `crate::a::c`\n\nFor `path` attributes inside inline module blocks, the relative location of\nthe file path depends on the kind of source file the `path` attribute is\nlocated in. \"mod-rs\" source files are root modules (such as `lib.rs` or\n`main.rs`) and modules with files named `mod.rs`. \"non-mod-rs\" source files\nare all other module files. Paths for `path` attributes inside inline module\nblocks in a mod-rs file are relative to the directory of the mod-rs file\nincluding the inline module components as directories. For non-mod-rs files,\nit is the same except the path starts with a directory with the name of the\nnon-mod-rs module. For example, the following code snippet would use the paths\nshown based on where it is located:\n\n<!-- ignore: requires external files -->\n,ignore\nmod inline {\n    #[path = \"other.rs\"]\n    mod inner;\n}\n\nSource File    | `inner`'s File Location   | `inner`'s Module Path\n-------------- | --------------------------| ----------------------------\n`src/a/b.rs`   | `src/a/b/inline/other.rs` | `crate::a::b::inline::inner`\n`src/a/mod.rs` | `src/a/inline/other.rs`   | `crate::a::inline::inner`\n\nAn example of combining the above rules of `path` attributes on inline modules\nand nested modules within (applies to both mod-rs and non-mod-rs files):\n\n<!-- ignore: requires external files -->\n,ignore\n#[path = \"thread_files\"]\nmod thread {\n    // Load the `local_data` module from `thread_files/tls.rs` relative to\n    // this source file's directory.\n    #[path = \"tls.rs\"]\n    mod local_data;\n}",
      "parent_id": null,
      "paragraphs": {
        "items.mod.outlined.path.intro": "The directories and files used for loading external file modules can be\ninfluenced with the `path` attribute.",
        "items.mod.outlined.path.search": "For `path` attributes on modules not inside inline module blocks, the file\npath is relative to the directory the source file is located. For example, the\nfollowing code snippet would use the paths shown based on where it is located:\n\n<!-- ignore: requires external files -->\n,ignore\n#[path = \"foo.rs\"]\nmod c;\n\nSource File    | `c`'s File Location | `c`'s Module Path\n-------------- | ------------------- | ----------------------\n`src/a/b.rs`   | `src/a/foo.rs`      | `crate::a::b::c`\n`src/a/mod.rs` | `src/a/foo.rs`      | `crate::a::c`",
        "items.mod.outlined.path.search-nested": "For `path` attributes inside inline module blocks, the relative location of\nthe file path depends on the kind of source file the `path` attribute is\nlocated in. \"mod-rs\" source files are root modules (such as `lib.rs` or\n`main.rs`) and modules with files named `mod.rs`. \"non-mod-rs\" source files\nare all other module files. Paths for `path` attributes inside inline module\nblocks in a mod-rs file are relative to the directory of the mod-rs file\nincluding the inline module components as directories. For non-mod-rs files,\nit is the same except the path starts with a directory with the name of the\nnon-mod-rs module. For example, the following code snippet would use the paths\nshown based on where it is located:\n\n<!-- ignore: requires external files -->\n,ignore\nmod inline {\n    #[path = \"other.rs\"]\n    mod inner;\n}\n\nSource File    | `inner`'s File Location   | `inner`'s Module Path\n-------------- | --------------------------| ----------------------------\n`src/a/b.rs`   | `src/a/b/inline/other.rs` | `crate::a::b::inline::inner`\n`src/a/mod.rs` | `src/a/inline/other.rs`   | `crate::a::inline::inner`\n\nAn example of combining the above rules of `path` attributes on inline modules\nand nested modules within (applies to both mod-rs and non-mod-rs files):\n\n<!-- ignore: requires external files -->\n,ignore\n#[path = \"thread_files\"]\nmod thread {\n    // Load the `local_data` module from `thread_files/tls.rs` relative to\n    // this source file's directory.\n    #[path = \"tls.rs\"]\n    mod local_data;\n}"
      }
    },
    {
      "id": "items.mod.attributes",
      "title": "Attributes on modules",
      "level": 3,
      "content": "Modules, like all items, accept outer attributes. They also accept inner\nattributes: either after `{` for a module with a body, or at the beginning of the\nsource file, after the optional BOM and shebang.\n\nThe built-in attributes that have meaning on a module are [`cfg`],\n[`deprecated`], [`doc`], [the lint check attributes], [`path`], and\n[`no_implicit_prelude`]. Modules also accept macro attributes.\n\n[`cfg`]: ../conditional-compilation.md\n[`deprecated`]: ../attributes/diagnostics.md#the-deprecated-attribute\n[`doc`]: ../../rustdoc/the-doc-attribute.html\n[`no_implicit_prelude`]: ../names/preludes.md#the-no_implicit_prelude-attribute\n\n[attribute]: ../attributes.md\n[items]: ../items.md\n[module path]: ../paths.md\n[scopes chapter]: ../names/scopes.md\n[the lint check attributes]: ../attributes/diagnostics.md#lint-check-attributes\n[type namespace]: ../names/namespaces.md",
      "parent_id": null,
      "paragraphs": {
        "items.mod.attributes.intro": "Modules, like all items, accept outer attributes. They also accept inner\nattributes: either after `{` for a module with a body, or at the beginning of the\nsource file, after the optional BOM and shebang.",
        "items.mod.attributes.supported": "The built-in attributes that have meaning on a module are [`cfg`],\n[`deprecated`], [`doc`], [the lint check attributes], [`path`], and\n[`no_implicit_prelude`]. Modules also accept macro attributes.\n\n[`cfg`]: ../conditional-compilation.md\n[`deprecated`]: ../attributes/diagnostics.md#the-deprecated-attribute\n[`doc`]: ../../rustdoc/the-doc-attribute.html\n[`no_implicit_prelude`]: ../names/preludes.md#the-no_implicit_prelude-attribute\n\n[attribute]: ../attributes.md\n[items]: ../items.md\n[module path]: ../paths.md\n[scopes chapter]: ../names/scopes.md\n[the lint check attributes]: ../attributes/diagnostics.md#lint-check-attributes\n[type namespace]: ../names/namespaces.md"
      }
    },
    {
      "id": "items.extern-crate",
      "title": "Extern crate declarations",
      "level": 1,
      "content": ",items\nExternCrate -> `extern` `crate` CrateRef AsClause? `;`\n\nCrateRef -> IDENTIFIER | `self`\n\nAsClause -> `as` ( IDENTIFIER | `_` )\n\nAn _`extern crate` declaration_ specifies a dependency on an external crate.\n\nThe external crate is then bound into the declaring scope as the given [identifier] in the [type namespace].\n\nAdditionally, if the `extern crate` appears in the crate root, then the crate name is also added to the [extern prelude], making it automatically in scope in all modules.\n\nThe `as` clause can be used to bind the imported crate to a different name.\n\nThe external crate is resolved to a specific `soname` at compile time, and a\nruntime linkage requirement to that `soname` is passed to the linker for\nloading at runtime. The `soname` is resolved at compile time by scanning the\ncompiler's library path and matching the optional `crate_name` provided against\nthe [`crate_name` attributes] that were declared on the external crate when it was\ncompiled. If no `crate_name` is provided, a default `name` attribute is assumed,\nequal to the [identifier] given in the `extern crate` declaration.\n\nThe `self` crate may be imported which creates a binding to the current crate.\nIn this case the `as` clause must be used to specify the name to bind it to.\n\nThree examples of `extern crate` declarations:\n\n<!-- ignore: requires external crates -->\n,ignore\nextern crate pcre;\n\nextern crate std; // equivalent to: extern crate std as std;\n\nextern crate std as ruststd; // linking to 'std' under another name\n\nWhen naming Rust crates, hyphens are disallowed. However, Cargo packages may\nmake use of them. In such case, when `Cargo.toml` doesn't specify a crate name,\nCargo will transparently replace `-` with `_` (Refer to [RFC 940] for more\ndetails).\n\nHere is an example:\n\n<!-- ignore: requires external crates -->\n,ignore\n// Importing the Cargo package hello-world\nextern crate hello_world; // hyphen replaced with an underscore",
      "parent_id": null,
      "paragraphs": {
        "items.extern-crate.syntax": ",items\nExternCrate -> `extern` `crate` CrateRef AsClause? `;`\n\nCrateRef -> IDENTIFIER | `self`\n\nAsClause -> `as` ( IDENTIFIER | `_` )",
        "items.extern-crate.intro": "An _`extern crate` declaration_ specifies a dependency on an external crate.",
        "items.extern-crate.namespace": "The external crate is then bound into the declaring scope as the given [identifier] in the [type namespace].",
        "items.extern-crate.extern-prelude": "Additionally, if the `extern crate` appears in the crate root, then the crate name is also added to the [extern prelude], making it automatically in scope in all modules.",
        "items.extern-crate.as": "The `as` clause can be used to bind the imported crate to a different name.",
        "items.extern-crate.lookup": "The external crate is resolved to a specific `soname` at compile time, and a\nruntime linkage requirement to that `soname` is passed to the linker for\nloading at runtime. The `soname` is resolved at compile time by scanning the\ncompiler's library path and matching the optional `crate_name` provided against\nthe [`crate_name` attributes] that were declared on the external crate when it was\ncompiled. If no `crate_name` is provided, a default `name` attribute is assumed,\nequal to the [identifier] given in the `extern crate` declaration.",
        "items.extern-crate.self": "The `self` crate may be imported which creates a binding to the current crate.\nIn this case the `as` clause must be used to specify the name to bind it to.\n\nThree examples of `extern crate` declarations:\n\n<!-- ignore: requires external crates -->\n,ignore\nextern crate pcre;\n\nextern crate std; // equivalent to: extern crate std as std;\n\nextern crate std as ruststd; // linking to 'std' under another name",
        "items.extern-crate.name-restrictions": "When naming Rust crates, hyphens are disallowed. However, Cargo packages may\nmake use of them. In such case, when `Cargo.toml` doesn't specify a crate name,\nCargo will transparently replace `-` with `_` (Refer to [RFC 940] for more\ndetails).\n\nHere is an example:\n\n<!-- ignore: requires external crates -->\n,ignore\n// Importing the Cargo package hello-world\nextern crate hello_world; // hyphen replaced with an underscore"
      }
    },
    {
      "id": "items.extern-crate.underscore",
      "title": "Underscore imports",
      "level": 1,
      "content": "An external crate dependency can be declared without binding its name in scope\nby using an underscore with the form `extern crate foo as _`. This may be\nuseful for crates that only need to be linked, but are never referenced, and\nwill avoid being reported as unused.\n\nThe [`macro_use` attribute] works as usual and imports the macro names\ninto the [`macro_use` prelude].\n\n<!-- template:attributes -->",
      "parent_id": null,
      "paragraphs": {
        "items.extern-crate.underscore.intro": "An external crate dependency can be declared without binding its name in scope\nby using an underscore with the form `extern crate foo as _`. This may be\nuseful for crates that only need to be linked, but are never referenced, and\nwill avoid being reported as unused.",
        "items.extern-crate.underscore.macro_use": "The [`macro_use` attribute] works as usual and imports the macro names\ninto the [`macro_use` prelude].\n\n<!-- template:attributes -->"
      }
    },
    {
      "id": "items.extern-crate.no_link",
      "title": "The `no_link` attribute",
      "level": 2,
      "content": "The *`no_link` attribute* may be applied to an `extern crate` item to prevent linking the crate.\n\n> [!NOTE]\n> This is helpful, e.g., when only the macros of a crate are needed.\n\n> [!EXAMPLE]\n> <!-- ignore: requires external crates -->\n> ```rust,ignore\n> #[no_link]\n> extern crate other_crate;\n>\n> other_crate::some_macro!();\n> ```\n\nThe `no_link` attribute uses the [MetaWord] syntax.\n\nThe `no_link` attribute may only be applied to an `extern crate` declaration.\n\n> [!NOTE]\n> `rustc` ignores use in other positions but lints against it. This may become an error in the future.\n\nOnly the first use of `no_link` on an `extern crate` declaration has effect.\n\n> [!NOTE]\n> `rustc` lints against any use following the first. This may become an error in the future.\n\n[identifier]: ../identifiers.md\n[RFC 940]: https://github.com/rust-lang/rfcs/blob/master/text/0940-hyphens-considered-harmful.md\n[`macro_use` attribute]: ../macros-by-example.md#the-macro_use-attribute\n[extern prelude]: ../names/preludes.md#extern-prelude\n[`macro_use` prelude]: ../names/preludes.md#macro_use-prelude\n[`crate_name` attributes]: ../crates-and-source-files.md#the-crate_name-attribute\n[type namespace]: ../names/namespaces.md",
      "parent_id": null,
      "paragraphs": {
        "items.extern-crate.no_link.intro": "The *`no_link` attribute* may be applied to an `extern crate` item to prevent linking the crate.\n\n> [!NOTE]\n> This is helpful, e.g., when only the macros of a crate are needed.\n\n> [!EXAMPLE]\n> <!-- ignore: requires external crates -->\n> ```rust,ignore\n> #[no_link]\n> extern crate other_crate;\n>\n> other_crate::some_macro!();\n> ```",
        "items.extern-crate.no_link.syntax": "The `no_link` attribute uses the [MetaWord] syntax.",
        "items.extern-crate.no_link.allowed-positions": "The `no_link` attribute may only be applied to an `extern crate` declaration.\n\n> [!NOTE]\n> `rustc` ignores use in other positions but lints against it. This may become an error in the future.",
        "items.extern-crate.no_link.duplicates": "Only the first use of `no_link` on an `extern crate` declaration has effect.\n\n> [!NOTE]\n> `rustc` lints against any use following the first. This may become an error in the future.\n\n[identifier]: ../identifiers.md\n[RFC 940]: https://github.com/rust-lang/rfcs/blob/master/text/0940-hyphens-considered-harmful.md\n[`macro_use` attribute]: ../macros-by-example.md#the-macro_use-attribute\n[extern prelude]: ../names/preludes.md#extern-prelude\n[`macro_use` prelude]: ../names/preludes.md#macro_use-prelude\n[`crate_name` attributes]: ../crates-and-source-files.md#the-crate_name-attribute\n[type namespace]: ../names/namespaces.md"
      }
    },
    {
      "id": "items.use",
      "title": "Use declarations",
      "level": 1,
      "content": ",items\nUseDeclaration -> `use` UseTree `;`\n\nUseTree ->\n      (SimplePath? `::`)? `*`\n    | (SimplePath? `::`)? `{` (UseTree ( `,`  UseTree )* `,`?)? `}`\n    | SimplePath ( `as` ( IDENTIFIER | `_` ) )?\n\nA _use declaration_ creates one or more local name bindings synonymous with\nsome other [path]. Usually a `use` declaration is used to shorten the path\nrequired to refer to a module item. These declarations may appear in [modules]\nand [blocks], usually at the top.\nA `use` declaration is also sometimes called an _import_, or, if it is public, a _re-export_.\n\n[path]: ../paths.md\n[modules]: modules.md\n[blocks]: ../expressions/block-expr.md\n\nUse declarations support a number of convenient shortcuts:\n\n* Simultaneously binding a list of paths with a common prefix, using the\n  brace syntax `use a::b::{c, d, e::f, g::h::i};`\n\n* Simultaneously binding a list of paths with a common prefix and their common\n  parent module, using the `self` keyword, such as `use a::b::{self, c, d::e};`\n\n* Rebinding the target name as a new local name, using the syntax `use p::q::r\n  as x;`. This can also be used with the last two features:\n  `use a::b::{self as ab, c as abc}`.\n\n* Binding all paths matching a given prefix, using the asterisk wildcard syntax\n  `use a::b::*;`.\n\n* Nesting groups of the previous features multiple times, such as\n  `use a::b::{self as ab, c, d::{*, e::f}};`\n\nAn example of `use` declarations:\n\nuse std::collections::hash_map::{self, HashMap};\n\nfn foo<T>(_: T){}\nfn bar(map1: HashMap<String, usize>, map2: hash_map::HashMap<String, usize>){}\n\nfn main() {\n    // use declarations can also exist inside of functions\n    use std::option::Option::{Some, None};\n\n    // Equivalent to 'foo(vec![std::option::Option::Some(1.0f64),\n    // std::option::Option::None]);'\n    foo(vec![Some(1.0f64), None]);\n\n    // Both `hash_map` and `HashMap` are in scope.\n    let map1 = HashMap::new();\n    let map2 = hash_map::HashMap::new();\n    bar(map1, map2);\n}",
      "parent_id": null,
      "paragraphs": {
        "items.use.syntax": ",items\nUseDeclaration -> `use` UseTree `;`\n\nUseTree ->\n      (SimplePath? `::`)? `*`\n    | (SimplePath? `::`)? `{` (UseTree ( `,`  UseTree )* `,`?)? `}`\n    | SimplePath ( `as` ( IDENTIFIER | `_` ) )?",
        "items.use.intro": "A _use declaration_ creates one or more local name bindings synonymous with\nsome other [path]. Usually a `use` declaration is used to shorten the path\nrequired to refer to a module item. These declarations may appear in [modules]\nand [blocks], usually at the top.\nA `use` declaration is also sometimes called an _import_, or, if it is public, a _re-export_.\n\n[path]: ../paths.md\n[modules]: modules.md\n[blocks]: ../expressions/block-expr.md",
        "items.use.forms": "Use declarations support a number of convenient shortcuts:",
        "items.use.forms.multiple": "* Simultaneously binding a list of paths with a common prefix, using the\n  brace syntax `use a::b::{c, d, e::f, g::h::i};`",
        "items.use.forms.self": "* Simultaneously binding a list of paths with a common prefix and their common\n  parent module, using the `self` keyword, such as `use a::b::{self, c, d::e};`",
        "items.use.forms.as": "* Rebinding the target name as a new local name, using the syntax `use p::q::r\n  as x;`. This can also be used with the last two features:\n  `use a::b::{self as ab, c as abc}`.",
        "items.use.forms.glob": "* Binding all paths matching a given prefix, using the asterisk wildcard syntax\n  `use a::b::*;`.",
        "items.use.forms.nesting": "* Nesting groups of the previous features multiple times, such as\n  `use a::b::{self as ab, c, d::{*, e::f}};`\n\nAn example of `use` declarations:\n\nuse std::collections::hash_map::{self, HashMap};\n\nfn foo<T>(_: T){}\nfn bar(map1: HashMap<String, usize>, map2: hash_map::HashMap<String, usize>){}\n\nfn main() {\n    // use declarations can also exist inside of functions\n    use std::option::Option::{Some, None};\n\n    // Equivalent to 'foo(vec![std::option::Option::Some(1.0f64),\n    // std::option::Option::None]);'\n    foo(vec![Some(1.0f64), None]);\n\n    // Both `hash_map` and `HashMap` are in scope.\n    let map1 = HashMap::new();\n    let map2 = hash_map::HashMap::new();\n    bar(map1, map2);\n}"
      }
    },
    {
      "id": "items.use.visibility",
      "title": "`use` Visibility",
      "level": 1,
      "content": "Like items, `use` declarations are private to the containing module, by\ndefault. Also like items, a `use` declaration can be public, if qualified by\nthe `pub` keyword. Such a `use` declaration serves to _re-export_ a name. A\npublic `use` declaration can therefore _redirect_ some public name to a\ndifferent target definition: even a definition with a private canonical path,\ninside a different module.\n\nIf a sequence of such redirections form a cycle or\ncannot be resolved unambiguously, they represent a compile-time error.\n\nAn example of re-exporting:\n\nmod quux {\n    pub use self::foo::{bar, baz};\n    pub mod foo {\n        pub fn bar() {}\n        pub fn baz() {}\n    }\n}\n\nfn main() {\n    quux::bar();\n    quux::baz();\n}\n\nIn this example, the module `quux` re-exports two public names defined in\n`foo`.",
      "parent_id": null,
      "paragraphs": {
        "items.use.visibility.intro": "Like items, `use` declarations are private to the containing module, by\ndefault. Also like items, a `use` declaration can be public, if qualified by\nthe `pub` keyword. Such a `use` declaration serves to _re-export_ a name. A\npublic `use` declaration can therefore _redirect_ some public name to a\ndifferent target definition: even a definition with a private canonical path,\ninside a different module.",
        "items.use.visibility.unambiguous": "If a sequence of such redirections form a cycle or\ncannot be resolved unambiguously, they represent a compile-time error.\n\nAn example of re-exporting:\n\nmod quux {\n    pub use self::foo::{bar, baz};\n    pub mod foo {\n        pub fn bar() {}\n        pub fn baz() {}\n    }\n}\n\nfn main() {\n    quux::bar();\n    quux::baz();\n}\n\nIn this example, the module `quux` re-exports two public names defined in\n`foo`."
      }
    },
    {
      "id": "items.use.path",
      "title": "`use` Paths",
      "level": 2,
      "content": "The [paths] that are allowed in a `use` item follow the [SimplePath] grammar and are similar to the paths that may be used in an expression.\nThey may create bindings for:\n\n* Nameable [items]\n* [Enum variants]\n* [Built-in types]\n* [Attributes]\n* [Derive macros]\n* [`macro_rules`]\n\nThey cannot import [associated items], [generic parameters], [local variables], paths with [`Self`], or [tool attributes]. More restrictions are described below.\n\n`use` will create bindings for all [namespaces] from the imported entities, with the exception that a `self` import will only import from the type namespace (as described below).\nFor example, the following illustrates creating bindings for the same name in two namespaces:\n\nmod stuff {\n    pub struct Foo(pub i32);\n}\n\n// Imports the `Foo` type and the `Foo` constructor.\nuse stuff::Foo;\n\nfn example() {\n    let ctor = Foo; // Uses `Foo` from the value namespace.\n    let x: Foo = ctor(123); // Uses `Foo` From the type namespace.\n}\n\n> [!EDITION-2018]\n> In the 2015 edition, `use` paths are relative to the crate root. For example:\n>\n> ```rust,edition2015\n> mod foo {\n>     pub mod example { pub mod iter {} }\n>     pub mod baz { pub fn foobaz() {} }\n> }\n> mod bar {\n>     // Resolves `foo` from the crate root.\n>     use foo::example::iter;\n>     // The `::` prefix explicitly resolves `foo`\n>     // from the crate root.\n>     use ::foo::baz::foobaz;\n> }\n>\n> # fn main() {}\n> ```\n>\n> The 2015 edition does not allow use declarations to reference the [extern prelude].\n> Thus, [`extern crate`] declarations are still required in 2015 to reference an external crate in a `use` declaration.\n> Beginning with the 2018 edition, `use` declarations can specify an external crate dependency the same way `extern crate` can.",
      "parent_id": null,
      "paragraphs": {
        "items.use.path.intro": "The [paths] that are allowed in a `use` item follow the [SimplePath] grammar and are similar to the paths that may be used in an expression.\nThey may create bindings for:\n\n* Nameable [items]\n* [Enum variants]\n* [Built-in types]\n* [Attributes]\n* [Derive macros]\n* [`macro_rules`]",
        "items.use.path.disallowed": "They cannot import [associated items], [generic parameters], [local variables], paths with [`Self`], or [tool attributes]. More restrictions are described below.",
        "items.use.path.namespace": "`use` will create bindings for all [namespaces] from the imported entities, with the exception that a `self` import will only import from the type namespace (as described below).\nFor example, the following illustrates creating bindings for the same name in two namespaces:\n\nmod stuff {\n    pub struct Foo(pub i32);\n}\n\n// Imports the `Foo` type and the `Foo` constructor.\nuse stuff::Foo;\n\nfn example() {\n    let ctor = Foo; // Uses `Foo` from the value namespace.\n    let x: Foo = ctor(123); // Uses `Foo` From the type namespace.\n}",
        "items.use.path.edition2018": "> [!EDITION-2018]\n> In the 2015 edition, `use` paths are relative to the crate root. For example:\n>\n> ```rust,edition2015\n> mod foo {\n>     pub mod example { pub mod iter {} }\n>     pub mod baz { pub fn foobaz() {} }\n> }\n> mod bar {\n>     // Resolves `foo` from the crate root.\n>     use foo::example::iter;\n>     // The `::` prefix explicitly resolves `foo`\n>     // from the crate root.\n>     use ::foo::baz::foobaz;\n> }\n>\n> # fn main() {}\n> ```\n>\n> The 2015 edition does not allow use declarations to reference the [extern prelude].\n> Thus, [`extern crate`] declarations are still required in 2015 to reference an external crate in a `use` declaration.\n> Beginning with the 2018 edition, `use` declarations can specify an external crate dependency the same way `extern crate` can."
      }
    },
    {
      "id": "items.use.as",
      "title": "`as` renames",
      "level": 2,
      "content": "The `as` keyword can be used to change the name of an imported entity.\nFor example:\n\n// Creates a non-public alias `bar` for the function `foo`.\nuse inner::foo as bar;\n\nmod inner {\n    pub fn foo() {}\n}",
      "parent_id": null,
      "paragraphs": {
        "items.use.as": "The `as` keyword can be used to change the name of an imported entity.\nFor example:\n\n// Creates a non-public alias `bar` for the function `foo`.\nuse inner::foo as bar;\n\nmod inner {\n    pub fn foo() {}\n}"
      }
    },
    {
      "id": "items.use.multiple-syntax",
      "title": "Brace syntax",
      "level": 2,
      "content": "Braces can be used in the last segment of the path to import multiple entities from the previous segment, or, if there are no previous segments, from the current scope.\nBraces can be nested, creating a tree of paths, where each grouping of segments is logically combined with its parent to create a full path.\n\n// Creates bindings to:\n// - `std::collections::BTreeSet`\n// - `std::collections::hash_map`\n// - `std::collections::hash_map::HashMap`\nuse std::collections::{BTreeSet, hash_map::{self, HashMap}};\n\nAn empty brace does not import anything, though the leading path is validated that it is accessible.\n<!-- This is slightly wrong, see: https://github.com/rust-lang/rust/issues/61826 -->\n\n> [!EDITION-2018]\n> In the 2015 edition, paths are relative to the crate root, so an import such as `use {foo, bar};` will import the names `foo` and `bar` from the crate root, whereas starting in 2018, those names are relative to the current scope.",
      "parent_id": null,
      "paragraphs": {
        "items.use.multiple-syntax.intro": "Braces can be used in the last segment of the path to import multiple entities from the previous segment, or, if there are no previous segments, from the current scope.\nBraces can be nested, creating a tree of paths, where each grouping of segments is logically combined with its parent to create a full path.\n\n// Creates bindings to:\n// - `std::collections::BTreeSet`\n// - `std::collections::hash_map`\n// - `std::collections::hash_map::HashMap`\nuse std::collections::{BTreeSet, hash_map::{self, HashMap}};",
        "items.use.multiple-syntax.empty": "An empty brace does not import anything, though the leading path is validated that it is accessible.\n<!-- This is slightly wrong, see: https://github.com/rust-lang/rust/issues/61826 -->",
        "items.use.multiple-syntax.edition2018": "> [!EDITION-2018]\n> In the 2015 edition, paths are relative to the crate root, so an import such as `use {foo, bar};` will import the names `foo` and `bar` from the crate root, whereas starting in 2018, those names are relative to the current scope."
      }
    },
    {
      "id": "items.use.self",
      "title": "`self` imports",
      "level": 2,
      "content": "The keyword `self` may be used within brace syntax to create a binding of the parent entity under its own name.\n\nmod stuff {\n    pub fn foo() {}\n    pub fn bar() {}\n}\nmod example {\n    // Creates a binding for `stuff` and `foo`.\n    use crate::stuff::{self, foo};\n    pub fn baz() {\n        foo();\n        stuff::bar();\n    }\n}\n# fn main() {}\n\n`self` only creates a binding from the [type namespace] of the parent entity.\nFor example, in the following, only the `foo` mod is imported:\n\n,compile_fail\nmod bar {\n    pub mod foo {}\n    pub fn foo() {}\n}\n\n// This only imports the module `foo`. The function `foo` lives in\n// the value namespace and is not imported.\nuse bar::foo::{self};\n\nfn main() {\n    foo(); //~ ERROR `foo` is a module\n}\n\n> [!NOTE]\n> `self` may also be used as the first segment of a path. The usage of `self` as the first segment and inside a `use` brace is logically the same; it means the current module of the parent segment, or the current module if there is no parent segment. See [`self`] in the paths chapter for more information on the meaning of a leading `self`.",
      "parent_id": null,
      "paragraphs": {
        "items.use.self.intro": "The keyword `self` may be used within brace syntax to create a binding of the parent entity under its own name.\n\nmod stuff {\n    pub fn foo() {}\n    pub fn bar() {}\n}\nmod example {\n    // Creates a binding for `stuff` and `foo`.\n    use crate::stuff::{self, foo};\n    pub fn baz() {\n        foo();\n        stuff::bar();\n    }\n}\n# fn main() {}",
        "items.use.self.namespace": "`self` only creates a binding from the [type namespace] of the parent entity.\nFor example, in the following, only the `foo` mod is imported:\n\n,compile_fail\nmod bar {\n    pub mod foo {}\n    pub fn foo() {}\n}\n\n// This only imports the module `foo`. The function `foo` lives in\n// the value namespace and is not imported.\nuse bar::foo::{self};\n\nfn main() {\n    foo(); //~ ERROR `foo` is a module\n}\n\n> [!NOTE]\n> `self` may also be used as the first segment of a path. The usage of `self` as the first segment and inside a `use` brace is logically the same; it means the current module of the parent segment, or the current module if there is no parent segment. See [`self`] in the paths chapter for more information on the meaning of a leading `self`."
      }
    },
    {
      "id": "items.use.glob",
      "title": "Glob imports",
      "level": 1,
      "content": "The `*` character may be used as the last segment of a `use` path to import all importable entities from the entity of the preceding segment.\nFor example:\n\n// Creates a non-public alias to `bar`.\nuse foo::*;\n\nmod foo {\n    fn i_am_private() {}\n    enum Example {\n        V1,\n        V2,\n    }\n    pub fn bar() {\n        // Creates local aliases to `V1` and `V2`\n        // of the `Example` enum.\n        use Example::*;\n        let x = V1;\n    }\n}\n\nItems and named imports are allowed to shadow names from glob imports in the same [namespace].\nThat is, if there is a name already defined by another item in the same namespace, the glob import will be shadowed.\nFor example:\n\n// This creates a binding to the `clashing::Foo` tuple struct\n// constructor, but does not import its type because that would\n// conflict with the `Foo` struct defined here.\n//\n// Note that the order of definition here is unimportant.\nuse clashing::*;\nstruct Foo {\n    field: f32,\n}\n\nfn do_stuff() {\n    // Uses the constructor from `clashing::Foo`.\n    let f1 = Foo(123);\n    // The struct expression uses the type from\n    // the `Foo` struct defined above.\n    let f2 = Foo { field: 1.0 };\n    // `Bar` is also in scope due to the glob import.\n    let z = Bar {};\n}\n\nmod clashing {\n    pub struct Foo(pub i32);\n    pub struct Bar {}\n}\n\n> [!NOTE]\n> For areas where shadowing is not allowed, see [name resolution ambiguities].\n\n`*` cannot be used as the first or intermediate segments.\n\n`*` cannot be used to import a module's contents into itself (such as `use self::*;`).\n\n> [!EDITION-2018]\n> In the 2015 edition, paths are relative to the crate root, so an import such as `use *;` is valid, and it means to import everything from the crate root. This cannot be used in the crate root itself.",
      "parent_id": null,
      "paragraphs": {
        "items.use.glob.intro": "The `*` character may be used as the last segment of a `use` path to import all importable entities from the entity of the preceding segment.\nFor example:\n\n// Creates a non-public alias to `bar`.\nuse foo::*;\n\nmod foo {\n    fn i_am_private() {}\n    enum Example {\n        V1,\n        V2,\n    }\n    pub fn bar() {\n        // Creates local aliases to `V1` and `V2`\n        // of the `Example` enum.\n        use Example::*;\n        let x = V1;\n    }\n}",
        "items.use.glob.shadowing": "Items and named imports are allowed to shadow names from glob imports in the same [namespace].\nThat is, if there is a name already defined by another item in the same namespace, the glob import will be shadowed.\nFor example:\n\n// This creates a binding to the `clashing::Foo` tuple struct\n// constructor, but does not import its type because that would\n// conflict with the `Foo` struct defined here.\n//\n// Note that the order of definition here is unimportant.\nuse clashing::*;\nstruct Foo {\n    field: f32,\n}\n\nfn do_stuff() {\n    // Uses the constructor from `clashing::Foo`.\n    let f1 = Foo(123);\n    // The struct expression uses the type from\n    // the `Foo` struct defined above.\n    let f2 = Foo { field: 1.0 };\n    // `Bar` is also in scope due to the glob import.\n    let z = Bar {};\n}\n\nmod clashing {\n    pub struct Foo(pub i32);\n    pub struct Bar {}\n}\n\n> [!NOTE]\n> For areas where shadowing is not allowed, see [name resolution ambiguities].",
        "items.use.glob.last-segment-only": "`*` cannot be used as the first or intermediate segments.",
        "items.use.glob.self-import": "`*` cannot be used to import a module's contents into itself (such as `use self::*;`).",
        "items.use.glob.edition2018": "> [!EDITION-2018]\n> In the 2015 edition, paths are relative to the crate root, so an import such as `use *;` is valid, and it means to import everything from the crate root. This cannot be used in the crate root itself."
      }
    },
    {
      "id": "items.use.as-underscore",
      "title": "Underscore imports",
      "level": 2,
      "content": "Items can be imported without binding to a name by using an underscore with\nthe form `use path as _`. This is particularly useful to import a trait so\nthat its methods may be used without importing the trait's symbol, for example\nif the trait's symbol may conflict with another symbol. Another example is to\nlink an external crate without importing its name.\n\nAsterisk glob imports will import items imported with `_` in their unnameable\nform.\n\nmod foo {\n    pub trait Zoo {\n        fn zoo(&self) {}\n    }\n\n    impl<T> Zoo for T {}\n}\n\nuse self::foo::Zoo as _;\nstruct Zoo;  // Underscore import avoids name conflict with this item.\n\nfn main() {\n    let z = Zoo;\n    z.zoo();\n}\n\nThe unique, unnameable symbols are created after macro expansion so that\nmacros may safely emit multiple references to `_` imports. For example, the\nfollowing should not produce an error:\n\nmacro_rules! m {\n    ($item: item) => { $item $item }\n}\n\nm!(use std as _;);\n// This expands to:\n// use std as _;\n// use std as _;",
      "parent_id": null,
      "paragraphs": {
        "items.use.as-underscore.intro": "Items can be imported without binding to a name by using an underscore with\nthe form `use path as _`. This is particularly useful to import a trait so\nthat its methods may be used without importing the trait's symbol, for example\nif the trait's symbol may conflict with another symbol. Another example is to\nlink an external crate without importing its name.",
        "items.use.as-underscore.glob": "Asterisk glob imports will import items imported with `_` in their unnameable\nform.\n\nmod foo {\n    pub trait Zoo {\n        fn zoo(&self) {}\n    }\n\n    impl<T> Zoo for T {}\n}\n\nuse self::foo::Zoo as _;\nstruct Zoo;  // Underscore import avoids name conflict with this item.\n\nfn main() {\n    let z = Zoo;\n    z.zoo();\n}",
        "items.use.as-underscore.macro": "The unique, unnameable symbols are created after macro expansion so that\nmacros may safely emit multiple references to `_` imports. For example, the\nfollowing should not produce an error:\n\nmacro_rules! m {\n    ($item: item) => { $item $item }\n}\n\nm!(use std as _;);\n// This expands to:\n// use std as _;\n// use std as _;"
      }
    },
    {
      "id": "items.use.restrictions",
      "title": "Restrictions",
      "level": 2,
      "content": "The following are restrictions for valid `use` declarations:\n\n* `use crate;` must use `as` to define the name to which to bind the crate root.\n\n* `use {self};` is an error; there must be a leading segment when using `self`.\n\n* As with any item definition, `use` imports cannot create duplicate bindings of the same name in the same namespace in a module or block.\n\n* `use` paths with `$crate` are not allowed in a [`macro_rules`] expansion.\n\n* `use` paths cannot refer to enum variants through a [type alias]. For example:\n  ```rust,compile_fail\n  enum MyEnum {\n      MyVariant\n  }\n  type TypeAlias = MyEnum;\n\n  use MyEnum::MyVariant; //~ OK\n  use TypeAlias::MyVariant; //~ ERROR\n  ```\n\n[Attributes]: ../attributes.md\n[Built-in types]: ../types.md\n[Derive macros]: macro.proc.derive\n[Enum variants]: enumerations.md\n[`extern crate`]: extern-crates.md\n[`macro_rules`]: ../macros-by-example.md\n[`self`]: ../paths.md#self\n[associated items]: associated-items.md\n[extern prelude]: ../names/preludes.md#extern-prelude\n[generic parameters]: generics.md\n[items]: ../items.md\n[local variables]: ../variables.md\n[name resolution ambiguities]: names.resolution.expansion.imports.ambiguity\n[namespace]: ../names/namespaces.md\n[namespaces]: ../names/namespaces.md\n[paths]: ../paths.md\n[tool attributes]: ../attributes.md#tool-attributes\n[type alias]: type-aliases.md\n[type namespace]: ../names/namespaces.md",
      "parent_id": null,
      "paragraphs": {
        "items.use.restrictions": "The following are restrictions for valid `use` declarations:",
        "items.use.restrictions.crate": "* `use crate;` must use `as` to define the name to which to bind the crate root.",
        "items.use.restrictions.self": "* `use {self};` is an error; there must be a leading segment when using `self`.",
        "items.use.restrictions.duplicate-name": "* As with any item definition, `use` imports cannot create duplicate bindings of the same name in the same namespace in a module or block.",
        "items.use.restrictions.macro-crate": "* `use` paths with `$crate` are not allowed in a [`macro_rules`] expansion.",
        "items.use.restrictions.variant": "* `use` paths cannot refer to enum variants through a [type alias]. For example:\n  ```rust,compile_fail\n  enum MyEnum {\n      MyVariant\n  }\n  type TypeAlias = MyEnum;\n\n  use MyEnum::MyVariant; //~ OK\n  use TypeAlias::MyVariant; //~ ERROR\n  ```\n\n[Attributes]: ../attributes.md\n[Built-in types]: ../types.md\n[Derive macros]: macro.proc.derive\n[Enum variants]: enumerations.md\n[`extern crate`]: extern-crates.md\n[`macro_rules`]: ../macros-by-example.md\n[`self`]: ../paths.md#self\n[associated items]: associated-items.md\n[extern prelude]: ../names/preludes.md#extern-prelude\n[generic parameters]: generics.md\n[items]: ../items.md\n[local variables]: ../variables.md\n[name resolution ambiguities]: names.resolution.expansion.imports.ambiguity\n[namespace]: ../names/namespaces.md\n[namespaces]: ../names/namespaces.md\n[paths]: ../paths.md\n[tool attributes]: ../attributes.md#tool-attributes\n[type alias]: type-aliases.md\n[type namespace]: ../names/namespaces.md"
      }
    },
    {
      "id": "items.fn",
      "title": "Functions",
      "level": 1,
      "content": ",items\nFunction ->\n    FunctionQualifiers `fn` IDENTIFIER GenericParams?\n        `(` FunctionParameters? `)`\n        FunctionReturnType? WhereClause?\n        ( BlockExpression | `;` )\n\nFunctionQualifiers -> `const`? `async`?[^async-edition] ItemSafety?[^extern-qualifiers] (`extern` Abi?)?\n\nItemSafety -> `safe`[^extern-safe] | `unsafe`\n\nAbi -> STRING_LITERAL | RAW_STRING_LITERAL\n\nFunctionParameters ->\n      SelfParam `,`?\n    | (SelfParam `,`)? FunctionParam (`,` FunctionParam)* `,`?\n\nSelfParam -> OuterAttribute* ( ShorthandSelf | TypedSelf )\n\nShorthandSelf -> (`&` | `&` Lifetime)? `mut`? `self`\n\nTypedSelf -> `mut`? `self` `:` Type\n\nFunctionParam -> OuterAttribute* ( FunctionParamPattern | `...` | Type[^fn-param-2015] )\n\nFunctionParamPattern -> PatternNoTopAlt `:` ( Type | `...` )\n\nFunctionReturnType -> `->` Type\n\n[^async-edition]: The `async` qualifier is not allowed in the 2015 edition.\n\n[^extern-safe]: The `safe` function qualifier is only allowed semantically within\n  `extern` blocks.\n\n[^extern-qualifiers]: *Relevant to editions earlier than Rust 2024*: Within\n  `extern` blocks, the `safe` or `unsafe` function qualifier is only allowed\n  when the `extern` is qualified as `unsafe`.\n\n[^fn-param-2015]: Function parameters with only a type are only allowed\n  in an associated function of a [trait item] in the 2015 edition.\n\nA _function_ consists of a [block] (that's the _body_ of the function),\nalong with a name, a set of parameters, and an output type.\nOther than a name, all these are optional.\n\nFunctions are declared with the keyword `fn` which defines the given name in the [value namespace] of the module or block where it is located.\n\nFunctions may declare a set of *input* *variables* as parameters, through which the caller passes arguments into the function, and the *output* *type* of the value the function will return to its caller on completion.\n\nIf the output type is not explicitly stated, it is the [unit type].\n\nWhen referred to, a _function_ yields a first-class *value* of the corresponding zero-sized [*function item type*], which when called evaluates to a direct call to the function.\n\nFor example, this is a simple function:\nfn answer_to_life_the_universe_and_everything() -> i32 {\n    return 42;\n}\n\nThe `safe` function is semantically only allowed when used in an [`extern` block].",
      "parent_id": null,
      "paragraphs": {
        "items.fn.syntax": ",items\nFunction ->\n    FunctionQualifiers `fn` IDENTIFIER GenericParams?\n        `(` FunctionParameters? `)`\n        FunctionReturnType? WhereClause?\n        ( BlockExpression | `;` )\n\nFunctionQualifiers -> `const`? `async`?[^async-edition] ItemSafety?[^extern-qualifiers] (`extern` Abi?)?\n\nItemSafety -> `safe`[^extern-safe] | `unsafe`\n\nAbi -> STRING_LITERAL | RAW_STRING_LITERAL\n\nFunctionParameters ->\n      SelfParam `,`?\n    | (SelfParam `,`)? FunctionParam (`,` FunctionParam)* `,`?\n\nSelfParam -> OuterAttribute* ( ShorthandSelf | TypedSelf )\n\nShorthandSelf -> (`&` | `&` Lifetime)? `mut`? `self`\n\nTypedSelf -> `mut`? `self` `:` Type\n\nFunctionParam -> OuterAttribute* ( FunctionParamPattern | `...` | Type[^fn-param-2015] )\n\nFunctionParamPattern -> PatternNoTopAlt `:` ( Type | `...` )\n\nFunctionReturnType -> `->` Type\n\n[^async-edition]: The `async` qualifier is not allowed in the 2015 edition.\n\n[^extern-safe]: The `safe` function qualifier is only allowed semantically within\n  `extern` blocks.\n\n[^extern-qualifiers]: *Relevant to editions earlier than Rust 2024*: Within\n  `extern` blocks, the `safe` or `unsafe` function qualifier is only allowed\n  when the `extern` is qualified as `unsafe`.\n\n[^fn-param-2015]: Function parameters with only a type are only allowed\n  in an associated function of a [trait item] in the 2015 edition.",
        "items.fn.intro": "A _function_ consists of a [block] (that's the _body_ of the function),\nalong with a name, a set of parameters, and an output type.\nOther than a name, all these are optional.",
        "items.fn.namespace": "Functions are declared with the keyword `fn` which defines the given name in the [value namespace] of the module or block where it is located.",
        "items.fn.signature": "Functions may declare a set of *input* *variables* as parameters, through which the caller passes arguments into the function, and the *output* *type* of the value the function will return to its caller on completion.",
        "items.fn.implicit-return": "If the output type is not explicitly stated, it is the [unit type].",
        "items.fn.fn-item-type": "When referred to, a _function_ yields a first-class *value* of the corresponding zero-sized [*function item type*], which when called evaluates to a direct call to the function.\n\nFor example, this is a simple function:\nfn answer_to_life_the_universe_and_everything() -> i32 {\n    return 42;\n}",
        "items.fn.safety-qualifiers": "The `safe` function is semantically only allowed when used in an [`extern` block]."
      }
    },
    {
      "id": "items.fn.params",
      "title": "Function parameters",
      "level": 1,
      "content": "Function parameters are irrefutable [patterns], so any pattern that is valid in\nan else-less `let` binding is also valid as a parameter:\n\nfn first((value, _): (i32, i32)) -> i32 { value }\n\nIf the first parameter is a [SelfParam], this indicates that the function is a\n[method].\n\nFunctions with a self parameter may only appear as an [associated\nfunction] in a [trait] or [implementation].\n\nA parameter with the `...` token indicates a [variadic function], and may only\nbe used as the last parameter of an [external block] function. The variadic\nparameter may have an optional identifier, such as `args: ...`.",
      "parent_id": null,
      "paragraphs": {
        "items.fn.params.intro": "Function parameters are irrefutable [patterns], so any pattern that is valid in\nan else-less `let` binding is also valid as a parameter:\n\nfn first((value, _): (i32, i32)) -> i32 { value }",
        "items.fn.params.self-pat": "If the first parameter is a [SelfParam], this indicates that the function is a\n[method].",
        "items.fn.params.self-restriction": "Functions with a self parameter may only appear as an [associated\nfunction] in a [trait] or [implementation].",
        "items.fn.params.varargs": "A parameter with the `...` token indicates a [variadic function], and may only\nbe used as the last parameter of an [external block] function. The variadic\nparameter may have an optional identifier, such as `args: ...`."
      }
    },
    {
      "id": "items.fn.body",
      "title": "Function body",
      "level": 2,
      "content": "The body block of a function is conceptually wrapped in another block that first binds the\nargument patterns and then `return`s the value of the function's body. This\nmeans that the tail expression of the block, if evaluated, ends up being\nreturned to the caller. As usual, an explicit return expression within\nthe body of the function will short-cut that implicit return, if reached.\n\nFor example, the function above behaves as if it was written as:\n\n<!-- ignore: example expansion -->\n,ignore\n// argument_0 is the actual first argument passed from the caller\nlet (value, _) = argument_0;\nreturn {\n    value\n};\n\nFunctions without a body block are terminated with a semicolon. This form\nmay only appear in a [trait] or [external block].",
      "parent_id": null,
      "paragraphs": {
        "items.fn.body.intro": "The body block of a function is conceptually wrapped in another block that first binds the\nargument patterns and then `return`s the value of the function's body. This\nmeans that the tail expression of the block, if evaluated, ends up being\nreturned to the caller. As usual, an explicit return expression within\nthe body of the function will short-cut that implicit return, if reached.\n\nFor example, the function above behaves as if it was written as:\n\n<!-- ignore: example expansion -->\n,ignore\n// argument_0 is the actual first argument passed from the caller\nlet (value, _) = argument_0;\nreturn {\n    value\n};",
        "items.fn.body.bodyless": "Functions without a body block are terminated with a semicolon. This form\nmay only appear in a [trait] or [external block]."
      }
    },
    {
      "id": "items.fn.generics",
      "title": "Generic functions",
      "level": 2,
      "content": "A _generic function_ allows one or more _parameterized types_ to appear in its\nsignature. Each type parameter must be explicitly declared in an\nangle-bracket-enclosed and comma-separated list, following the function name.\n\n// foo is generic over A and B\n\nfn foo<A, B>(x: A, y: B) {\n# }\n\nInside the function signature and body, the name of the type parameter can be\nused as a type name.\n\n[Trait] bounds can be specified for type\nparameters to allow methods with that trait to be called on values of that\ntype. This is specified using the `where` syntax:\n\n# use std::fmt::Debug;\nfn foo<T>(x: T) where T: Debug {\n# }\n\nWhen a generic function is referenced, its type is instantiated based on the\ncontext of the reference. For example, calling the `foo` function here:\n\nuse std::fmt::Debug;\n\nfn foo<T>(x: &[T]) where T: Debug {\n    // details elided\n}\n\nfoo(&[1, 2]);\n\nwill instantiate type parameter `T` with `i32`.\n\nThe type parameters can also be explicitly supplied in a trailing [path]\ncomponent after the function name. This might be necessary if there is not\nsufficient context to determine the type parameters. For example,\n`mem::size_of::<u32>() == 4`.",
      "parent_id": null,
      "paragraphs": {
        "items.fn.generics.intro": "A _generic function_ allows one or more _parameterized types_ to appear in its\nsignature. Each type parameter must be explicitly declared in an\nangle-bracket-enclosed and comma-separated list, following the function name.\n\n// foo is generic over A and B\n\nfn foo<A, B>(x: A, y: B) {\n# }",
        "items.fn.generics.param-names": "Inside the function signature and body, the name of the type parameter can be\nused as a type name.",
        "items.fn.generics.param-bounds": "[Trait] bounds can be specified for type\nparameters to allow methods with that trait to be called on values of that\ntype. This is specified using the `where` syntax:\n\n# use std::fmt::Debug;\nfn foo<T>(x: T) where T: Debug {\n# }",
        "items.fn.generics.mono": "When a generic function is referenced, its type is instantiated based on the\ncontext of the reference. For example, calling the `foo` function here:\n\nuse std::fmt::Debug;\n\nfn foo<T>(x: &[T]) where T: Debug {\n    // details elided\n}\n\nfoo(&[1, 2]);\n\nwill instantiate type parameter `T` with `i32`.",
        "items.fn.generics.explicit-arguments": "The type parameters can also be explicitly supplied in a trailing [path]\ncomponent after the function name. This might be necessary if there is not\nsufficient context to determine the type parameters. For example,\n`mem::size_of::<u32>() == 4`."
      }
    },
    {
      "id": "items.fn.extern",
      "title": "Extern function qualifier",
      "level": 1,
      "content": "The `extern` function qualifier allows providing function _definitions_ that can\nbe called with a particular ABI:\n\n<!-- ignore: fake ABI -->\n,ignore\nextern \"ABI\" fn foo() { /* ... */ }\n\nThese are often used in combination with [external block] items which provide\nfunction _declarations_ that can be used to call functions without providing\ntheir _definition_:\n\n<!-- ignore: fake ABI -->\n,ignore\nunsafe extern \"ABI\" {\n  unsafe fn foo(); /* no body */\n  safe fn bar(); /* no body */\n}\nunsafe { foo() };\nbar();\n\nWhen `\"extern\" Abi?*` is omitted from `FunctionQualifiers` in function items,\nthe ABI `\"Rust\"` is assigned. For example:\n\nfn foo() {}\n\nis equivalent to:\n\nextern \"Rust\" fn foo() {}\n\nFunctions can be called by foreign code, and using an ABI that\ndiffers from Rust allows, for example, to provide functions that can be\ncalled from other programming languages like C:\n\n// Declares a function with the \"C\" ABI\nextern \"C\" fn new_i32() -> i32 { 0 }\n\n// Declares a function with the \"stdcall\" ABI\n# #[cfg(any(windows, target_arch = \"x86\"))]\nextern \"stdcall\" fn new_i32_stdcall() -> i32 { 0 }\n\nJust as with [external block], when the `extern` keyword is used and the `\"ABI\"`\nis omitted, the ABI used defaults to `\"C\"`. That is, this:\n\nextern fn new_i32() -> i32 { 0 }\nlet fptr: extern fn() -> i32 = new_i32;\n\nis equivalent to:\n\nextern \"C\" fn new_i32() -> i32 { 0 }\nlet fptr: extern \"C\" fn() -> i32 = new_i32;",
      "parent_id": null,
      "paragraphs": {
        "items.fn.extern.intro": "The `extern` function qualifier allows providing function _definitions_ that can\nbe called with a particular ABI:\n\n<!-- ignore: fake ABI -->\n,ignore\nextern \"ABI\" fn foo() { /* ... */ }",
        "items.fn.extern.def": "These are often used in combination with [external block] items which provide\nfunction _declarations_ that can be used to call functions without providing\ntheir _definition_:\n\n<!-- ignore: fake ABI -->\n,ignore\nunsafe extern \"ABI\" {\n  unsafe fn foo(); /* no body */\n  safe fn bar(); /* no body */\n}\nunsafe { foo() };\nbar();",
        "items.fn.extern.default-abi": "When `\"extern\" Abi?*` is omitted from `FunctionQualifiers` in function items,\nthe ABI `\"Rust\"` is assigned. For example:\n\nfn foo() {}\n\nis equivalent to:\n\nextern \"Rust\" fn foo() {}",
        "items.fn.extern.foreign-call": "Functions can be called by foreign code, and using an ABI that\ndiffers from Rust allows, for example, to provide functions that can be\ncalled from other programming languages like C:\n\n// Declares a function with the \"C\" ABI\nextern \"C\" fn new_i32() -> i32 { 0 }\n\n// Declares a function with the \"stdcall\" ABI\n# #[cfg(any(windows, target_arch = \"x86\"))]\nextern \"stdcall\" fn new_i32_stdcall() -> i32 { 0 }",
        "items.fn.extern.default-extern": "Just as with [external block], when the `extern` keyword is used and the `\"ABI\"`\nis omitted, the ABI used defaults to `\"C\"`. That is, this:\n\nextern fn new_i32() -> i32 { 0 }\nlet fptr: extern fn() -> i32 = new_i32;\n\nis equivalent to:\n\nextern \"C\" fn new_i32() -> i32 { 0 }\nlet fptr: extern \"C\" fn() -> i32 = new_i32;"
      }
    },
    {
      "id": "items.fn.extern.unwind",
      "title": "Unwinding",
      "level": 1,
      "content": "Most ABI strings come in two variants, one with an `-unwind` suffix and one without. The `Rust` ABI always permits unwinding, so there is no `Rust-unwind` ABI. The choice of ABI, together with the runtime [panic handler], determines the behavior when unwinding out of a function.\n\nThe table below indicates the behavior of an unwinding operation reaching each type of ABI boundary (function declaration or definition using the corresponding ABI string). Note that the Rust runtime is not affected by, and cannot have an effect on, any unwinding that occurs entirely within another language's runtime, that is, unwinds that are thrown and caught without reaching a Rust ABI boundary.\n\nThe `panic`-unwind column refers to [panicking] via the `panic!` macro and similar standard library mechanisms, as well as to any other Rust operations that cause a panic, such as out-of-bounds array indexing or integer overflow.\n\nThe \"unwinding\" ABI category refers to `\"Rust\"` (the implicit ABI of Rust functions not marked `extern`), `\"C-unwind\"`, and any other ABI with `-unwind` in its name. The \"non-unwinding\" ABI category refers to all other ABI strings, including `\"C\"` and `\"stdcall\"`.\n\nNative unwinding is defined per-target. On targets that support throwing and catching C++ exceptions, it refers to the mechanism used to implement this feature. Some platforms implement a form of unwinding referred to as \"forced unwinding\"; `longjmp` on Windows and `pthread_exit` in `glibc` are implemented this way. Forced unwinding is explicitly excluded from the \"Native unwind\" column in the table.\n\n| panic runtime  | ABI           | `panic`-unwind                        | Native unwind (unforced) |\n| -------------- | ------------  | ------------------------------------- | -----------------------  |\n| `panic=unwind` | unwinding     | unwind                                | unwind                   |\n| `panic=unwind` | non-unwinding | abort (see notes below)               | [undefined behavior]     |\n| `panic=abort`  | unwinding     | `panic` aborts without unwinding      | abort                    |\n| `panic=abort`  | non-unwinding | `panic` aborts without unwinding      | [undefined behavior]     |\n\nWith `panic=unwind`, when a `panic` is turned into an abort by a non-unwinding ABI boundary, either no destructors (`Drop` calls) will run, or all destructors up until the ABI boundary will run. It is unspecified which of those two behaviors will happen.\n\nFor other considerations and limitations regarding unwinding across FFI boundaries, see the relevant section in the Panic documentation.\n\n[forced-unwinding]: https://rust-lang.github.io/rfcs/2945-c-unwind-abi.html#forced-unwinding\n[panic handler]: ../panic.md#the-panic_handler-attribute\n[panic-ffi]: ../panic.md#unwinding-across-ffi-boundaries\n[panicking]: ../panic.md\n[undefined behavior]: ../behavior-considered-undefined.md",
      "parent_id": null,
      "paragraphs": {
        "items.fn.extern.unwind.intro": "Most ABI strings come in two variants, one with an `-unwind` suffix and one without. The `Rust` ABI always permits unwinding, so there is no `Rust-unwind` ABI. The choice of ABI, together with the runtime [panic handler], determines the behavior when unwinding out of a function.",
        "items.fn.extern.unwind.behavior": "The table below indicates the behavior of an unwinding operation reaching each type of ABI boundary (function declaration or definition using the corresponding ABI string). Note that the Rust runtime is not affected by, and cannot have an effect on, any unwinding that occurs entirely within another language's runtime, that is, unwinds that are thrown and caught without reaching a Rust ABI boundary.\n\nThe `panic`-unwind column refers to [panicking] via the `panic!` macro and similar standard library mechanisms, as well as to any other Rust operations that cause a panic, such as out-of-bounds array indexing or integer overflow.\n\nThe \"unwinding\" ABI category refers to `\"Rust\"` (the implicit ABI of Rust functions not marked `extern`), `\"C-unwind\"`, and any other ABI with `-unwind` in its name. The \"non-unwinding\" ABI category refers to all other ABI strings, including `\"C\"` and `\"stdcall\"`.\n\nNative unwinding is defined per-target. On targets that support throwing and catching C++ exceptions, it refers to the mechanism used to implement this feature. Some platforms implement a form of unwinding referred to as \"forced unwinding\"; `longjmp` on Windows and `pthread_exit` in `glibc` are implemented this way. Forced unwinding is explicitly excluded from the \"Native unwind\" column in the table.\n\n| panic runtime  | ABI           | `panic`-unwind                        | Native unwind (unforced) |\n| -------------- | ------------  | ------------------------------------- | -----------------------  |\n| `panic=unwind` | unwinding     | unwind                                | unwind                   |\n| `panic=unwind` | non-unwinding | abort (see notes below)               | [undefined behavior]     |\n| `panic=abort`  | unwinding     | `panic` aborts without unwinding      | abort                    |\n| `panic=abort`  | non-unwinding | `panic` aborts without unwinding      | [undefined behavior]     |",
        "items.fn.extern.abort": "With `panic=unwind`, when a `panic` is turned into an abort by a non-unwinding ABI boundary, either no destructors (`Drop` calls) will run, or all destructors up until the ABI boundary will run. It is unspecified which of those two behaviors will happen.\n\nFor other considerations and limitations regarding unwinding across FFI boundaries, see the relevant section in the Panic documentation.\n\n[forced-unwinding]: https://rust-lang.github.io/rfcs/2945-c-unwind-abi.html#forced-unwinding\n[panic handler]: ../panic.md#the-panic_handler-attribute\n[panic-ffi]: ../panic.md#unwinding-across-ffi-boundaries\n[panicking]: ../panic.md\n[undefined behavior]: ../behavior-considered-undefined.md"
      }
    },
    {
      "id": "items.fn.const",
      "title": "Const functions",
      "level": 3,
      "content": "See [const functions] for the definition of const functions.",
      "parent_id": null,
      "paragraphs": {
        "items.fn.const": "See [const functions] for the definition of const functions."
      }
    },
    {
      "id": "items.fn.async",
      "title": "Async functions",
      "level": 2,
      "content": "Functions may be qualified as async, and this can also be combined with the\n`unsafe` qualifier:\n\nasync fn regular_example() { }\nasync unsafe fn unsafe_example() { }\n\nAsync functions do no work when called: instead, they\ncapture their arguments into a future. When polled, that future will\nexecute the function's body.\n\nAn async function is roughly equivalent to a function\nthat returns [`impl Future`] and with an `async move` block as\nits body:\n\n// Source\nasync fn example(x: &str) -> usize {\n    x.len()\n}\n\nis roughly equivalent to:\n\n# use std::future::Future;\n// Desugared\nfn example<'a>(x: &'a str) -> impl Future<Output = usize> + 'a {\n    async move { x.len() }\n}\n\nThe actual desugaring is more complex:\n\n- The return type in the desugaring is assumed to capture all lifetime\n  parameters from the `async fn` declaration. This can be seen in the\n  desugared example above, which explicitly outlives, and hence\n  captures, `'a`.\n\n- The `async move` block in the body captures all function\n  parameters, including those that are unused or bound to a `_`\n  pattern. This ensures that function parameters are dropped in the\n  same order as they would be if the function were not async, except\n  that the drop occurs when the returned future has been fully\n  awaited.\n\nFor more information on the effect of async, see `async` blocks.\n\n[async-blocks]: ../expressions/block-expr.md#async-blocks\n[`impl Future`]: ../types/impl-trait.md\n\n> [!EDITION-2018]\n> Async functions are only available beginning with Rust 2018.",
      "parent_id": null,
      "paragraphs": {
        "items.fn.async.intro": "Functions may be qualified as async, and this can also be combined with the\n`unsafe` qualifier:\n\nasync fn regular_example() { }\nasync unsafe fn unsafe_example() { }",
        "items.fn.async.future": "Async functions do no work when called: instead, they\ncapture their arguments into a future. When polled, that future will\nexecute the function's body.",
        "items.fn.async.desugar-brief": "An async function is roughly equivalent to a function\nthat returns [`impl Future`] and with an `async move` block as\nits body:\n\n// Source\nasync fn example(x: &str) -> usize {\n    x.len()\n}\n\nis roughly equivalent to:\n\n# use std::future::Future;\n// Desugared\nfn example<'a>(x: &'a str) -> impl Future<Output = usize> + 'a {\n    async move { x.len() }\n}",
        "items.fn.async.desugar": "The actual desugaring is more complex:",
        "items.fn.async.lifetime-capture": "- The return type in the desugaring is assumed to capture all lifetime\n  parameters from the `async fn` declaration. This can be seen in the\n  desugared example above, which explicitly outlives, and hence\n  captures, `'a`.",
        "items.fn.async.param-capture": "- The `async move` block in the body captures all function\n  parameters, including those that are unused or bound to a `_`\n  pattern. This ensures that function parameters are dropped in the\n  same order as they would be if the function were not async, except\n  that the drop occurs when the returned future has been fully\n  awaited.\n\nFor more information on the effect of async, see `async` blocks.\n\n[async-blocks]: ../expressions/block-expr.md#async-blocks\n[`impl Future`]: ../types/impl-trait.md",
        "items.fn.async.edition2018": "> [!EDITION-2018]\n> Async functions are only available beginning with Rust 2018."
      }
    },
    {
      "id": "items.fn.async.safety",
      "title": "Combining `async` and `unsafe`",
      "level": 1,
      "content": "It is legal to declare a function that is both async and unsafe. The\nresulting function is unsafe to call and (like any async function)\nreturns a future. This future is just an ordinary future and thus an\n`unsafe` context is not required to \"await\" it:\n\n// Returns a future that, when awaited, dereferences `x`.\n//\n// Soundness condition: `x` must be safe to dereference until\n// the resulting future is complete.\nasync unsafe fn unsafe_example(x: *const i32) -> i32 {\n  *x\n}\n\nasync fn safe_example() {\n    // An `unsafe` block is required to invoke the function initially:\n    let p = 22;\n    let future = unsafe { unsafe_example(&p) };\n\n    // But no `unsafe` block required here. This will\n    // read the value of `p`:\n    let q = future.await;\n}\n\nNote that this behavior is a consequence of the desugaring to a\nfunction that returns an `impl Future` -- in this case, the function\nwe desugar to is an `unsafe` function, but the return value remains\nthe same.\n\nUnsafe is used on an async function in precisely the same way that it\nis used on other functions: it indicates that the function imposes\nsome additional obligations on its caller to ensure soundness. As in any\nother unsafe function, these conditions may extend beyond the initial\ncall itself -- in the snippet above, for example, the `unsafe_example`\nfunction took a pointer `x` as argument, and then (when awaited)\ndereferenced that pointer. This implies that `x` would have to be\nvalid until the future is finished executing, and it is the caller's\nresponsibility to ensure that.",
      "parent_id": null,
      "paragraphs": {
        "items.fn.async.safety.intro": "It is legal to declare a function that is both async and unsafe. The\nresulting function is unsafe to call and (like any async function)\nreturns a future. This future is just an ordinary future and thus an\n`unsafe` context is not required to \"await\" it:\n\n// Returns a future that, when awaited, dereferences `x`.\n//\n// Soundness condition: `x` must be safe to dereference until\n// the resulting future is complete.\nasync unsafe fn unsafe_example(x: *const i32) -> i32 {\n  *x\n}\n\nasync fn safe_example() {\n    // An `unsafe` block is required to invoke the function initially:\n    let p = 22;\n    let future = unsafe { unsafe_example(&p) };\n\n    // But no `unsafe` block required here. This will\n    // read the value of `p`:\n    let q = future.await;\n}\n\nNote that this behavior is a consequence of the desugaring to a\nfunction that returns an `impl Future` -- in this case, the function\nwe desugar to is an `unsafe` function, but the return value remains\nthe same.\n\nUnsafe is used on an async function in precisely the same way that it\nis used on other functions: it indicates that the function imposes\nsome additional obligations on its caller to ensure soundness. As in any\nother unsafe function, these conditions may extend beyond the initial\ncall itself -- in the snippet above, for example, the `unsafe_example`\nfunction took a pointer `x` as argument, and then (when awaited)\ndereferenced that pointer. This implies that `x` would have to be\nvalid until the future is finished executing, and it is the caller's\nresponsibility to ensure that."
      }
    },
    {
      "id": "items.fn.attributes",
      "title": "Attributes on functions",
      "level": 3,
      "content": "Outer attributes are allowed on functions. Inner\nattributes are allowed directly after the `{` inside its body [block].\n\nThis example shows an inner attribute on a function. The function is documented\nwith just the word \"Example\".\n\nfn documented() {\n    #![doc = \"Example\"]\n}\n\n> [!NOTE]\n> Except for lints, it is idiomatic to only use outer attributes on function items.\n\nThe attributes that have meaning on a function are:\n\n- [`cfg_attr`]\n- [`cfg`]\n- [`cold`]\n- [`deprecated`]\n- [`doc`]\n- [`export_name`]\n- [`inline`]\n- [`link_section`]\n- [`must_use`]\n- [`no_mangle`]\n- [Lint check attributes]\n- [Procedural macro attributes]\n- [Testing attributes]",
      "parent_id": null,
      "paragraphs": {
        "items.fn.attributes.intro": "Outer attributes are allowed on functions. Inner\nattributes are allowed directly after the `{` inside its body [block].\n\nThis example shows an inner attribute on a function. The function is documented\nwith just the word \"Example\".\n\nfn documented() {\n    #![doc = \"Example\"]\n}\n\n> [!NOTE]\n> Except for lints, it is idiomatic to only use outer attributes on function items.",
        "items.fn.attributes.builtin-attributes": "The attributes that have meaning on a function are:\n\n- [`cfg_attr`]\n- [`cfg`]\n- [`cold`]\n- [`deprecated`]\n- [`doc`]\n- [`export_name`]\n- [`inline`]\n- [`link_section`]\n- [`must_use`]\n- [`no_mangle`]\n- [Lint check attributes]\n- [Procedural macro attributes]\n- [Testing attributes]"
      }
    },
    {
      "id": "items.fn.param-attributes",
      "title": "Attributes on function parameters",
      "level": 2,
      "content": "Outer attributes are allowed on function parameters and the\npermitted [built-in attributes] are restricted to `cfg`, `cfg_attr`, `allow`,\n`warn`, `deny`, and `forbid`.\n\nfn len(\n    #[cfg(windows)] slice: &[u16],\n    #[cfg(not(windows))] slice: &[u8],\n) -> usize {\n    slice.len()\n}\n\nInert helper attributes used by procedural macro attributes applied to items are also\nallowed but be careful to not include these inert attributes in your final `TokenStream`.\n\nFor example, the following code defines an inert `some_inert_attribute` attribute that\nis not formally defined anywhere and the `some_proc_macro_attribute` procedural macro is\nresponsible for detecting its presence and removing it from the output token stream.\n\n<!-- ignore: requires proc macro -->\n,ignore\n#[some_proc_macro_attribute]\nfn foo_oof(#[some_inert_attribute] arg: u8) {\n}\n\n[const contexts]: ../const_eval.md#const-context\n[const functions]: ../const_eval.md#const-functions\n[external block]: external-blocks.md\n[path]: ../paths.md\n[block]: ../expressions/block-expr.md\n[variables]: ../variables.md\n[type]: ../types.md#type-expressions\n[unit type]: ../types/tuple.md\n[*function item type*]: ../types/function-item.md\n[Trait]: traits.md\n[attributes]: ../attributes.md\n[`cfg`]: ../conditional-compilation.md#the-cfg-attribute\n[`cfg_attr`]: ../conditional-compilation.md#the-cfg_attr-attribute\n[lint check attributes]: ../attributes/diagnostics.md#lint-check-attributes\n[procedural macro attributes]: macro.proc.attribute\n[testing attributes]: ../attributes/testing.md\n[`cold`]: ../attributes/codegen.md#the-cold-attribute\n[`inline`]: ../attributes/codegen.md#the-inline-attribute\n[`deprecated`]: ../attributes/diagnostics.md#the-deprecated-attribute\n[`doc`]: ../../rustdoc/the-doc-attribute.html\n[`must_use`]: ../attributes/diagnostics.md#the-must_use-attribute\n[patterns]: ../patterns.md\n[`export_name`]: ../abi.md#the-export_name-attribute\n[`link_section`]: ../abi.md#the-link_section-attribute\n[`no_mangle`]: ../abi.md#the-no_mangle-attribute\n[built-in attributes]: ../attributes.md#built-in-attributes-index\n[trait item]: traits.md\n[method]: associated-items.md#methods\n[associated function]: associated-items.md#associated-functions-and-methods\n[implementation]: implementations.md\n[value namespace]: ../names/namespaces.md\n[variadic function]: external-blocks.md#variadic-functions\n[`extern` block]: external-blocks.md",
      "parent_id": null,
      "paragraphs": {
        "items.fn.param-attributes.intro": "Outer attributes are allowed on function parameters and the\npermitted [built-in attributes] are restricted to `cfg`, `cfg_attr`, `allow`,\n`warn`, `deny`, and `forbid`.\n\nfn len(\n    #[cfg(windows)] slice: &[u16],\n    #[cfg(not(windows))] slice: &[u8],\n) -> usize {\n    slice.len()\n}",
        "items.fn.param-attributes.parsed-attributes": "Inert helper attributes used by procedural macro attributes applied to items are also\nallowed but be careful to not include these inert attributes in your final `TokenStream`.\n\nFor example, the following code defines an inert `some_inert_attribute` attribute that\nis not formally defined anywhere and the `some_proc_macro_attribute` procedural macro is\nresponsible for detecting its presence and removing it from the output token stream.\n\n<!-- ignore: requires proc macro -->\n,ignore\n#[some_proc_macro_attribute]\nfn foo_oof(#[some_inert_attribute] arg: u8) {\n}\n\n[const contexts]: ../const_eval.md#const-context\n[const functions]: ../const_eval.md#const-functions\n[external block]: external-blocks.md\n[path]: ../paths.md\n[block]: ../expressions/block-expr.md\n[variables]: ../variables.md\n[type]: ../types.md#type-expressions\n[unit type]: ../types/tuple.md\n[*function item type*]: ../types/function-item.md\n[Trait]: traits.md\n[attributes]: ../attributes.md\n[`cfg`]: ../conditional-compilation.md#the-cfg-attribute\n[`cfg_attr`]: ../conditional-compilation.md#the-cfg_attr-attribute\n[lint check attributes]: ../attributes/diagnostics.md#lint-check-attributes\n[procedural macro attributes]: macro.proc.attribute\n[testing attributes]: ../attributes/testing.md\n[`cold`]: ../attributes/codegen.md#the-cold-attribute\n[`inline`]: ../attributes/codegen.md#the-inline-attribute\n[`deprecated`]: ../attributes/diagnostics.md#the-deprecated-attribute\n[`doc`]: ../../rustdoc/the-doc-attribute.html\n[`must_use`]: ../attributes/diagnostics.md#the-must_use-attribute\n[patterns]: ../patterns.md\n[`export_name`]: ../abi.md#the-export_name-attribute\n[`link_section`]: ../abi.md#the-link_section-attribute\n[`no_mangle`]: ../abi.md#the-no_mangle-attribute\n[built-in attributes]: ../attributes.md#built-in-attributes-index\n[trait item]: traits.md\n[method]: associated-items.md#methods\n[associated function]: associated-items.md#associated-functions-and-methods\n[implementation]: implementations.md\n[value namespace]: ../names/namespaces.md\n[variadic function]: external-blocks.md#variadic-functions\n[`extern` block]: external-blocks.md"
      }
    },
    {
      "id": "items.type",
      "title": "Type aliases",
      "level": 1,
      "content": ",items\nTypeAlias ->\n    `type` IDENTIFIER GenericParams? ( `:` TypeParamBounds )?\n        WhereClause?\n        ( `=` Type WhereClause?)? `;`\n\nA _type alias_ defines a new name for an existing [type] in the [type namespace] of the module or block where it is located.\nType aliases are declared with the keyword `type`.\nEvery value has a single, specific type, but may implement several different traits, and may be compatible with several different type constraints.\n\nFor example, the following defines the type `Point` as a synonym for the type\n`(u8, u8)`, the type of pairs of unsigned 8 bit integers:\n\ntype Point = (u8, u8);\nlet p: Point = (41, 68);\n\nA type alias to a tuple-struct or unit-struct cannot be used to qualify that type's constructor:\n\n,compile_fail\nstruct MyStruct(u32);\n\nuse MyStruct as UseAlias;\ntype TypeAlias = MyStruct;\n\nlet _ = UseAlias(5); // OK\nlet _ = TypeAlias(5); // Doesn't work\n\nA type alias, when not used as an [associated type], must include a Type and\nmay not include [TypeParamBounds].\n\nA type alias, when used as an [associated type] in a [trait], must not include a\nType specification but may include [TypeParamBounds].\n\nA type alias, when used as an [associated type] in a [trait impl], must include\na Type specification and may not include [TypeParamBounds].\n\nWhere clauses before the equals sign on a type alias in a [trait impl] (like\n`type TypeAlias<T> where T: Foo = Bar<T>`) are deprecated. Where clauses after\nthe equals sign (like `type TypeAlias<T> = Bar<T> where T: Foo`) are preferred.\n\n[associated type]: associated-items.md#associated-types\n[trait impl]: implementations.md#trait-implementations\n[trait]: traits.md\n[type namespace]: ../names/namespaces.md\n[type]: ../types.md",
      "parent_id": null,
      "paragraphs": {
        "items.type.syntax": ",items\nTypeAlias ->\n    `type` IDENTIFIER GenericParams? ( `:` TypeParamBounds )?\n        WhereClause?\n        ( `=` Type WhereClause?)? `;`",
        "items.type.intro": "A _type alias_ defines a new name for an existing [type] in the [type namespace] of the module or block where it is located.\nType aliases are declared with the keyword `type`.\nEvery value has a single, specific type, but may implement several different traits, and may be compatible with several different type constraints.\n\nFor example, the following defines the type `Point` as a synonym for the type\n`(u8, u8)`, the type of pairs of unsigned 8 bit integers:\n\ntype Point = (u8, u8);\nlet p: Point = (41, 68);",
        "items.type.constructor-alias": "A type alias to a tuple-struct or unit-struct cannot be used to qualify that type's constructor:\n\n,compile_fail\nstruct MyStruct(u32);\n\nuse MyStruct as UseAlias;\ntype TypeAlias = MyStruct;\n\nlet _ = UseAlias(5); // OK\nlet _ = TypeAlias(5); // Doesn't work",
        "items.type.associated-type": "A type alias, when not used as an [associated type], must include a Type and\nmay not include [TypeParamBounds].",
        "items.type.associated-trait": "A type alias, when used as an [associated type] in a [trait], must not include a\nType specification but may include [TypeParamBounds].",
        "items.type.associated-impl": "A type alias, when used as an [associated type] in a [trait impl], must include\na Type specification and may not include [TypeParamBounds].",
        "items.type.deprecated": "Where clauses before the equals sign on a type alias in a [trait impl] (like\n`type TypeAlias<T> where T: Foo = Bar<T>`) are deprecated. Where clauses after\nthe equals sign (like `type TypeAlias<T> = Bar<T> where T: Foo`) are preferred.\n\n[associated type]: associated-items.md#associated-types\n[trait impl]: implementations.md#trait-implementations\n[trait]: traits.md\n[type namespace]: ../names/namespaces.md\n[type]: ../types.md"
      }
    },
    {
      "id": "items.struct",
      "title": "Structs",
      "level": 1,
      "content": ",items\nStruct ->\n      StructStruct\n    | TupleStruct\n\nStructStruct ->\n    `struct` IDENTIFIER GenericParams? WhereClause? ( `{` StructFields? `}` | `;` )\n\nTupleStruct ->\n    `struct` IDENTIFIER GenericParams? `(` TupleFields? `)` WhereClause? `;`\n\nStructFields -> StructField (`,` StructField)* `,`?\n\nStructField -> OuterAttribute* Visibility? IDENTIFIER `:` Type\n\nTupleFields -> TupleField (`,` TupleField)* `,`?\n\nTupleField -> OuterAttribute* Visibility? Type\n\nA _struct_ is a nominal [struct type] defined with the keyword `struct`.\n\nA struct declaration defines the given name in the [type namespace] of the module or block where it is located.\n\nAn example of a `struct` item and its use:\n\nstruct Point {x: i32, y: i32}\nlet p = Point {x: 10, y: 11};\nlet px: i32 = p.x;\n\nA _tuple struct_ is a nominal [tuple type], and is also defined with the keyword `struct`.\nIn addition to defining a type, it also defines a constructor of the same name in the [value namespace].\nThe constructor is a function which can be called to create a new instance of the struct.\nFor example:\n\nstruct Point(i32, i32);\nlet p = Point(10, 11);\nlet px: i32 = match p { Point(x, _) => x };\n\nA _unit-like struct_ is a struct without any fields, defined by leaving off the\nlist of fields entirely. Such a struct implicitly defines a [constant] of its\ntype with the same name. For example:\n\nstruct Cookie;\nlet c = [Cookie, Cookie {}, Cookie, Cookie {}];\n\nis equivalent to\n\nstruct Cookie {}\nconst Cookie: Cookie = Cookie {};\nlet c = [Cookie, Cookie {}, Cookie, Cookie {}];\n\nThe precise memory layout of a struct is not specified. One can specify a\nparticular layout using the [`repr` attribute].\n\n[`repr` attribute]: ../type-layout.md#representations\n[constant]: constant-items.md\n[struct type]: ../types/struct.md\n[tuple type]: ../types/tuple.md\n[type namespace]: ../names/namespaces.md\n[value namespace]: ../names/namespaces.md",
      "parent_id": null,
      "paragraphs": {
        "items.struct.syntax": ",items\nStruct ->\n      StructStruct\n    | TupleStruct\n\nStructStruct ->\n    `struct` IDENTIFIER GenericParams? WhereClause? ( `{` StructFields? `}` | `;` )\n\nTupleStruct ->\n    `struct` IDENTIFIER GenericParams? `(` TupleFields? `)` WhereClause? `;`\n\nStructFields -> StructField (`,` StructField)* `,`?\n\nStructField -> OuterAttribute* Visibility? IDENTIFIER `:` Type\n\nTupleFields -> TupleField (`,` TupleField)* `,`?\n\nTupleField -> OuterAttribute* Visibility? Type",
        "items.struct.intro": "A _struct_ is a nominal [struct type] defined with the keyword `struct`.",
        "items.struct.namespace": "A struct declaration defines the given name in the [type namespace] of the module or block where it is located.\n\nAn example of a `struct` item and its use:\n\nstruct Point {x: i32, y: i32}\nlet p = Point {x: 10, y: 11};\nlet px: i32 = p.x;",
        "items.struct.tuple": "A _tuple struct_ is a nominal [tuple type], and is also defined with the keyword `struct`.\nIn addition to defining a type, it also defines a constructor of the same name in the [value namespace].\nThe constructor is a function which can be called to create a new instance of the struct.\nFor example:\n\nstruct Point(i32, i32);\nlet p = Point(10, 11);\nlet px: i32 = match p { Point(x, _) => x };",
        "items.struct.unit": "A _unit-like struct_ is a struct without any fields, defined by leaving off the\nlist of fields entirely. Such a struct implicitly defines a [constant] of its\ntype with the same name. For example:\n\nstruct Cookie;\nlet c = [Cookie, Cookie {}, Cookie, Cookie {}];\n\nis equivalent to\n\nstruct Cookie {}\nconst Cookie: Cookie = Cookie {};\nlet c = [Cookie, Cookie {}, Cookie, Cookie {}];",
        "items.struct.layout": "The precise memory layout of a struct is not specified. One can specify a\nparticular layout using the [`repr` attribute].\n\n[`repr` attribute]: ../type-layout.md#representations\n[constant]: constant-items.md\n[struct type]: ../types/struct.md\n[tuple type]: ../types/tuple.md\n[type namespace]: ../names/namespaces.md\n[value namespace]: ../names/namespaces.md"
      }
    },
    {
      "id": "items.enum",
      "title": "Enumerations",
      "level": 1,
      "content": ",items\nEnumeration ->\n    `enum` IDENTIFIER GenericParams? WhereClause? `{` EnumVariants? `}`\n\nEnumVariants -> EnumVariant ( `,` EnumVariant )* `,`?\n\nEnumVariant ->\n    OuterAttribute* Visibility?\n    IDENTIFIER ( EnumVariantTuple | EnumVariantStruct )? EnumVariantDiscriminant?\n\nEnumVariantTuple -> `(` TupleFields? `)`\n\nEnumVariantStruct -> `{` StructFields? `}`\n\nEnumVariantDiscriminant -> `=` Expression\n\nAn *enumeration*, also referred to as an *enum*, is a simultaneous definition of a\nnominal [enumerated type] as well as a set of *constructors*, that can be used\nto create or pattern-match values of the corresponding enumerated type.\n\nEnumerations are declared with the keyword `enum`.\n\nThe `enum` declaration defines the enumeration type in the [type namespace] of the module or block where it is located.\n\nAn example of an `enum` item and its use:\n\nenum Animal {\n    Dog,\n    Cat,\n}\n\nlet mut a: Animal = Animal::Dog;\na = Animal::Cat;\n\nEnum constructors can have either named or unnamed fields:\n\nenum Animal {\n    Dog(String, f64),\n    Cat { name: String, weight: f64 },\n}\n\nlet mut a: Animal = Animal::Dog(\"Cocoa\".to_string(), 37.2);\na = Animal::Cat { name: \"Spotty\".to_string(), weight: 2.7 };\n\nIn this example, `Cat` is a _struct-like enum variant_, whereas `Dog` is simply\ncalled an enum variant.\n\nAn enum where no constructors contain fields is called a\n*<span id=\"field-less-enum\">field-less enum</span>*. For example, this is a fieldless enum:\n\nenum Fieldless {\n    Tuple(),\n    Struct{},\n    Unit,\n}\n\nIf a field-less enum only contains unit variants, the enum is called an\n*<span id=\"unit-only-enum\">unit-only enum</span>*. For example:\n\nenum Enum {\n    Foo = 3,\n    Bar = 2,\n    Baz = 1,\n}\n\nVariant constructors are similar to [struct] definitions, and can be referenced by a path from the enumeration name, including in [use declarations].\n\nEach variant defines its type in the [type namespace], though that type cannot be used as a type specifier.\nTuple-like and unit-like variants also define a constructor in the [value namespace].\n\nA struct-like variant can be instantiated with a [struct expression].\n\nA tuple-like variant can be instantiated with a [call expression] or a [struct expression].\n\nA unit-like variant can be instantiated with a [path expression] or a [struct expression].\nFor example:\n\nenum Examples {\n    UnitLike,\n    TupleLike(i32),\n    StructLike { value: i32 },\n}\n\nuse Examples::*; // Creates aliases to all variants.\nlet x = UnitLike; // Path expression of the const item.\nlet x = UnitLike {}; // Struct expression.\nlet y = TupleLike(123); // Call expression.\nlet y = TupleLike { 0: 123 }; // Struct expression using integer field names.\nlet z = StructLike { value: 123 }; // Struct expression.\n\n<span id=\"custom-discriminant-values-for-fieldless-enumerations\"></span>",
      "parent_id": null,
      "paragraphs": {
        "items.enum.syntax": ",items\nEnumeration ->\n    `enum` IDENTIFIER GenericParams? WhereClause? `{` EnumVariants? `}`\n\nEnumVariants -> EnumVariant ( `,` EnumVariant )* `,`?\n\nEnumVariant ->\n    OuterAttribute* Visibility?\n    IDENTIFIER ( EnumVariantTuple | EnumVariantStruct )? EnumVariantDiscriminant?\n\nEnumVariantTuple -> `(` TupleFields? `)`\n\nEnumVariantStruct -> `{` StructFields? `}`\n\nEnumVariantDiscriminant -> `=` Expression",
        "items.enum.intro": "An *enumeration*, also referred to as an *enum*, is a simultaneous definition of a\nnominal [enumerated type] as well as a set of *constructors*, that can be used\nto create or pattern-match values of the corresponding enumerated type.",
        "items.enum.decl": "Enumerations are declared with the keyword `enum`.",
        "items.enum.namespace": "The `enum` declaration defines the enumeration type in the [type namespace] of the module or block where it is located.\n\nAn example of an `enum` item and its use:\n\nenum Animal {\n    Dog,\n    Cat,\n}\n\nlet mut a: Animal = Animal::Dog;\na = Animal::Cat;",
        "items.enum.constructor": "Enum constructors can have either named or unnamed fields:\n\nenum Animal {\n    Dog(String, f64),\n    Cat { name: String, weight: f64 },\n}\n\nlet mut a: Animal = Animal::Dog(\"Cocoa\".to_string(), 37.2);\na = Animal::Cat { name: \"Spotty\".to_string(), weight: 2.7 };\n\nIn this example, `Cat` is a _struct-like enum variant_, whereas `Dog` is simply\ncalled an enum variant.",
        "items.enum.fieldless": "An enum where no constructors contain fields is called a\n*<span id=\"field-less-enum\">field-less enum</span>*. For example, this is a fieldless enum:\n\nenum Fieldless {\n    Tuple(),\n    Struct{},\n    Unit,\n}",
        "items.enum.unit-only": "If a field-less enum only contains unit variants, the enum is called an\n*<span id=\"unit-only-enum\">unit-only enum</span>*. For example:\n\nenum Enum {\n    Foo = 3,\n    Bar = 2,\n    Baz = 1,\n}",
        "items.enum.constructor-names": "Variant constructors are similar to [struct] definitions, and can be referenced by a path from the enumeration name, including in [use declarations].",
        "items.enum.constructor-namespace": "Each variant defines its type in the [type namespace], though that type cannot be used as a type specifier.\nTuple-like and unit-like variants also define a constructor in the [value namespace].",
        "items.enum.struct-expr": "A struct-like variant can be instantiated with a [struct expression].",
        "items.enum.tuple-expr": "A tuple-like variant can be instantiated with a [call expression] or a [struct expression].",
        "items.enum.path-expr": "A unit-like variant can be instantiated with a [path expression] or a [struct expression].\nFor example:\n\nenum Examples {\n    UnitLike,\n    TupleLike(i32),\n    StructLike { value: i32 },\n}\n\nuse Examples::*; // Creates aliases to all variants.\nlet x = UnitLike; // Path expression of the const item.\nlet x = UnitLike {}; // Struct expression.\nlet y = TupleLike(123); // Call expression.\nlet y = TupleLike { 0: 123 }; // Struct expression using integer field names.\nlet z = StructLike { value: 123 }; // Struct expression.\n\n<span id=\"custom-discriminant-values-for-fieldless-enumerations\"></span>"
      }
    },
    {
      "id": "items.enum.discriminant",
      "title": "Discriminants",
      "level": 1,
      "content": "Each enum instance has a _discriminant_: an integer logically associated to it\nthat is used to determine which variant it holds.\n\nUnder the [`Rust` representation], the discriminant is interpreted as\nan `isize` value. However, the compiler is allowed to use a smaller type (or\nanother means of distinguishing variants) in its actual memory layout.\n\n### Assigning discriminant values",
      "parent_id": null,
      "paragraphs": {
        "items.enum.discriminant.intro": "Each enum instance has a _discriminant_: an integer logically associated to it\nthat is used to determine which variant it holds.",
        "items.enum.discriminant.repr-rust": "Under the [`Rust` representation], the discriminant is interpreted as\nan `isize` value. However, the compiler is allowed to use a smaller type (or\nanother means of distinguishing variants) in its actual memory layout.\n\n### Assigning discriminant values"
      }
    },
    {
      "id": "items.enum.discriminant.explicit",
      "title": "Explicit discriminants",
      "level": 3,
      "content": "In two circumstances, the discriminant of a variant may be explicitly set by\nfollowing the variant name with `=` and a [constant expression]:\n\n1. if the enumeration is \"[unit-only]\".\n\n2. if a [primitive representation] is used. For example:\n\n   ```rust\n   #[repr(u8)]\n   enum Enum {\n       Unit = 3,\n       Tuple(u16),\n       Struct {\n           a: u8,\n           b: u16,\n       } = 1,\n   }\n   ```",
      "parent_id": null,
      "paragraphs": {
        "items.enum.discriminant.explicit.intro": "In two circumstances, the discriminant of a variant may be explicitly set by\nfollowing the variant name with `=` and a [constant expression]:",
        "items.enum.discriminant.explicit.unit-only": "1. if the enumeration is \"[unit-only]\".",
        "items.enum.discriminant.explicit.primitive-repr": "2. if a [primitive representation] is used. For example:\n\n   ```rust\n   #[repr(u8)]\n   enum Enum {\n       Unit = 3,\n       Tuple(u16),\n       Struct {\n           a: u8,\n           b: u16,\n       } = 1,\n   }\n   ```"
      }
    },
    {
      "id": "items.enum.discriminant.implicit",
      "title": "Implicit discriminants",
      "level": 4,
      "content": "If a discriminant for a variant is not specified, then it is set to one higher\nthan the discriminant of the previous variant in the declaration. If the\ndiscriminant of the first variant in the declaration is unspecified, then\nit is set to zero.\n\nenum Foo {\n    Bar,            // 0\n    Baz = 123,      // 123\n    Quux,           // 124\n}\n\nlet baz_discriminant = Foo::Baz as u32;\nassert_eq!(baz_discriminant, 123);",
      "parent_id": null,
      "paragraphs": {
        "items.enum.discriminant.implicit": "If a discriminant for a variant is not specified, then it is set to one higher\nthan the discriminant of the previous variant in the declaration. If the\ndiscriminant of the first variant in the declaration is unspecified, then\nit is set to zero.\n\nenum Foo {\n    Bar,            // 0\n    Baz = 123,      // 123\n    Quux,           // 124\n}\n\nlet baz_discriminant = Foo::Baz as u32;\nassert_eq!(baz_discriminant, 123);"
      }
    },
    {
      "id": "items.enum.discriminant.restrictions",
      "title": "Restrictions",
      "level": 4,
      "content": "It is an error when two variants share the same discriminant.\n\n,compile_fail\nenum SharedDiscriminantError {\n    SharedA = 1,\n    SharedB = 1\n}\n\nenum SharedDiscriminantError2 {\n    Zero,       // 0\n    One,        // 1\n    OneToo = 1  // 1 (collision with previous!)\n}\n\nIt is also an error to have an unspecified discriminant where the previous\ndiscriminant is the maximum value for the size of the discriminant.\n\n,compile_fail\n#[repr(u8)]\nenum OverflowingDiscriminantError {\n    Max = 255,\n    MaxPlusOne // Would be 256, but that overflows the enum.\n}\n\n#[repr(u8)]\nenum OverflowingDiscriminantError2 {\n    MaxMinusOne = 254, // 254\n    Max,               // 255\n    MaxPlusOne         // Would be 256, but that overflows the enum.\n}\n\n### Accessing discriminant\n\n#### Via `mem::discriminant`\n\n[`std::mem::discriminant`] returns an opaque reference to the discriminant of\nan enum value which can be compared. This cannot be used to get the value\nof the discriminant.",
      "parent_id": null,
      "paragraphs": {
        "items.enum.discriminant.restrictions.same-discriminant": "It is an error when two variants share the same discriminant.\n\n,compile_fail\nenum SharedDiscriminantError {\n    SharedA = 1,\n    SharedB = 1\n}\n\nenum SharedDiscriminantError2 {\n    Zero,       // 0\n    One,        // 1\n    OneToo = 1  // 1 (collision with previous!)\n}",
        "items.enum.discriminant.restrictions.above-max-discriminant": "It is also an error to have an unspecified discriminant where the previous\ndiscriminant is the maximum value for the size of the discriminant.\n\n,compile_fail\n#[repr(u8)]\nenum OverflowingDiscriminantError {\n    Max = 255,\n    MaxPlusOne // Would be 256, but that overflows the enum.\n}\n\n#[repr(u8)]\nenum OverflowingDiscriminantError2 {\n    MaxMinusOne = 254, // 254\n    Max,               // 255\n    MaxPlusOne         // Would be 256, but that overflows the enum.\n}\n\n### Accessing discriminant\n\n#### Via `mem::discriminant`",
        "items.enum.discriminant.access-opaque": "[`std::mem::discriminant`] returns an opaque reference to the discriminant of\nan enum value which can be compared. This cannot be used to get the value\nof the discriminant."
      }
    },
    {
      "id": "items.enum.discriminant.coercion",
      "title": "Casting",
      "level": 4,
      "content": "If an enumeration is [unit-only] (with no tuple and struct variants), then its\ndiscriminant can be directly accessed with a [numeric cast]; e.g.:\n\nenum Enum {\n    Foo,\n    Bar,\n    Baz,\n}\n\nassert_eq!(0, Enum::Foo as isize);\nassert_eq!(1, Enum::Bar as isize);\nassert_eq!(2, Enum::Baz as isize);\n\n[Field-less enums] can be cast if they do not have explicit discriminants, or where only unit variants are explicit.\n\nenum Fieldless {\n    Tuple(),\n    Struct{},\n    Unit,\n}\n\nassert_eq!(0, Fieldless::Tuple() as isize);\nassert_eq!(1, Fieldless::Struct{} as isize);\nassert_eq!(2, Fieldless::Unit as isize);\n\n#[repr(u8)]\nenum FieldlessWithDiscriminants {\n    First = 10,\n    Tuple(),\n    Second = 20,\n    Struct{},\n    Unit,\n}\n\nassert_eq!(10, FieldlessWithDiscriminants::First as u8);\nassert_eq!(11, FieldlessWithDiscriminants::Tuple() as u8);\nassert_eq!(20, FieldlessWithDiscriminants::Second as u8);\nassert_eq!(21, FieldlessWithDiscriminants::Struct{} as u8);\nassert_eq!(22, FieldlessWithDiscriminants::Unit as u8);\n\n#### Pointer casting\n\nIf the enumeration specifies a [primitive representation], then the\ndiscriminant may be reliably accessed via unsafe pointer casting:\n\n#[repr(u8)]\nenum Enum {\n    Unit,\n    Tuple(bool),\n    Struct{a: bool},\n}\n\nimpl Enum {\n    fn discriminant(&self) -> u8 {\n        unsafe { *(self as *const Self as *const u8) }\n    }\n}\n\nlet unit_like = Enum::Unit;\nlet tuple_like = Enum::Tuple(true);\nlet struct_like = Enum::Struct{a: false};\n\nassert_eq!(0, unit_like.discriminant());\nassert_eq!(1, tuple_like.discriminant());\nassert_eq!(2, struct_like.discriminant());",
      "parent_id": null,
      "paragraphs": {
        "items.enum.discriminant.coercion.intro": "If an enumeration is [unit-only] (with no tuple and struct variants), then its\ndiscriminant can be directly accessed with a [numeric cast]; e.g.:\n\nenum Enum {\n    Foo,\n    Bar,\n    Baz,\n}\n\nassert_eq!(0, Enum::Foo as isize);\nassert_eq!(1, Enum::Bar as isize);\nassert_eq!(2, Enum::Baz as isize);",
        "items.enum.discriminant.coercion.fieldless": "[Field-less enums] can be cast if they do not have explicit discriminants, or where only unit variants are explicit.\n\nenum Fieldless {\n    Tuple(),\n    Struct{},\n    Unit,\n}\n\nassert_eq!(0, Fieldless::Tuple() as isize);\nassert_eq!(1, Fieldless::Struct{} as isize);\nassert_eq!(2, Fieldless::Unit as isize);\n\n#[repr(u8)]\nenum FieldlessWithDiscriminants {\n    First = 10,\n    Tuple(),\n    Second = 20,\n    Struct{},\n    Unit,\n}\n\nassert_eq!(10, FieldlessWithDiscriminants::First as u8);\nassert_eq!(11, FieldlessWithDiscriminants::Tuple() as u8);\nassert_eq!(20, FieldlessWithDiscriminants::Second as u8);\nassert_eq!(21, FieldlessWithDiscriminants::Struct{} as u8);\nassert_eq!(22, FieldlessWithDiscriminants::Unit as u8);\n\n#### Pointer casting",
        "items.enum.discriminant.access-memory": "If the enumeration specifies a [primitive representation], then the\ndiscriminant may be reliably accessed via unsafe pointer casting:\n\n#[repr(u8)]\nenum Enum {\n    Unit,\n    Tuple(bool),\n    Struct{a: bool},\n}\n\nimpl Enum {\n    fn discriminant(&self) -> u8 {\n        unsafe { *(self as *const Self as *const u8) }\n    }\n}\n\nlet unit_like = Enum::Unit;\nlet tuple_like = Enum::Tuple(true);\nlet struct_like = Enum::Struct{a: false};\n\nassert_eq!(0, unit_like.discriminant());\nassert_eq!(1, tuple_like.discriminant());\nassert_eq!(2, struct_like.discriminant());"
      }
    },
    {
      "id": "items.enum.empty",
      "title": "Zero-variant enums",
      "level": 4,
      "content": "Enums with zero variants are known as *zero-variant enums*. As they have\nno valid values, they cannot be instantiated.\n\nenum ZeroVariants {}\n\nZero-variant enums are equivalent to the [never type], but they cannot be\ncoerced into other types.\n\n,compile_fail\n# enum ZeroVariants {}\nlet x: ZeroVariants = panic!();\nlet y: u32 = x; // mismatched type error",
      "parent_id": null,
      "paragraphs": {
        "items.enum.empty.intro": "Enums with zero variants are known as *zero-variant enums*. As they have\nno valid values, they cannot be instantiated.\n\nenum ZeroVariants {}",
        "items.enum.empty.uninhabited": "Zero-variant enums are equivalent to the [never type], but they cannot be\ncoerced into other types.\n\n,compile_fail\n# enum ZeroVariants {}\nlet x: ZeroVariants = panic!();\nlet y: u32 = x; // mismatched type error"
      }
    },
    {
      "id": "items.enum.variant-visibility",
      "title": "Variant visibility",
      "level": 1,
      "content": "Enum variants syntactically allow a [Visibility] annotation, but this is\nrejected when the enum is validated. This allows items to be parsed with a\nunified syntax across different contexts where they are used.\n\nmacro_rules! mac_variant {\n    ($vis:vis $name:ident) => {\n        enum $name {\n            $vis Unit,\n\n            $vis Tuple(u8, u16),\n\n            $vis Struct { f: u8 },\n        }\n    }\n}\n\n// Empty `vis` is allowed.\nmac_variant! { E }\n\n// This is allowed, since it is removed before being validated.\n#[cfg(false)]\nenum E {\n    pub U,\n    pub(crate) T(u8),\n    pub(super) T { f: String }\n}\n\n[`C` representation]: ../type-layout.md#the-c-representation\n[call expression]: ../expressions/call-expr.md\n[constant expression]: ../const_eval.md#constant-expressions\n[enumerated type]: ../types/enum.md\n\n[never type]: ../types/never.md\n[numeric cast]: ../expressions/operator-expr.md#semantics\n[path expression]: ../expressions/path-expr.md\n[primitive representation]: ../type-layout.md#primitive-representations\n[`Rust` representation]: ../type-layout.md#the-rust-representation\n[struct expression]: ../expressions/struct-expr.md\n[struct]: structs.md\n[type namespace]: ../names/namespaces.md\n\n[use declarations]: use-declarations.md\n[value namespace]: ../names/namespaces.md",
      "parent_id": null,
      "paragraphs": {
        "items.enum.variant-visibility": "Enum variants syntactically allow a [Visibility] annotation, but this is\nrejected when the enum is validated. This allows items to be parsed with a\nunified syntax across different contexts where they are used.\n\nmacro_rules! mac_variant {\n    ($vis:vis $name:ident) => {\n        enum $name {\n            $vis Unit,\n\n            $vis Tuple(u8, u16),\n\n            $vis Struct { f: u8 },\n        }\n    }\n}\n\n// Empty `vis` is allowed.\nmac_variant! { E }\n\n// This is allowed, since it is removed before being validated.\n#[cfg(false)]\nenum E {\n    pub U,\n    pub(crate) T(u8),\n    pub(super) T { f: String }\n}\n\n[`C` representation]: ../type-layout.md#the-c-representation\n[call expression]: ../expressions/call-expr.md\n[constant expression]: ../const_eval.md#constant-expressions\n[enumerated type]: ../types/enum.md\n\n[never type]: ../types/never.md\n[numeric cast]: ../expressions/operator-expr.md#semantics\n[path expression]: ../expressions/path-expr.md\n[primitive representation]: ../type-layout.md#primitive-representations\n[`Rust` representation]: ../type-layout.md#the-rust-representation\n[struct expression]: ../expressions/struct-expr.md\n[struct]: structs.md\n[type namespace]: ../names/namespaces.md\n\n[use declarations]: use-declarations.md\n[value namespace]: ../names/namespaces.md"
      }
    },
    {
      "id": "items.union",
      "title": "Unions",
      "level": 1,
      "content": ",items\nUnion ->\n    `union` IDENTIFIER GenericParams? WhereClause? `{` StructFields? `}`\n\nA union declaration uses the same syntax as a struct declaration, except with\n`union` in place of `struct`.\n\nA union declaration defines the given name in the [type namespace] of the module or block where it is located.\n\n#[repr(C)]\nunion MyUnion {\n    f1: u32,\n    f2: f32,\n}\n\nThe key property of unions is that all fields of a union share common storage.\nAs a result, writes to one field of a union can overwrite its other fields, and\nsize of a union is determined by the size of its largest field.\n\nUnion field types are restricted to the following subset of types:\n\n- `Copy` types\n\n- References (`&T` and `&mut T` for arbitrary `T`)\n\n- `ManuallyDrop<T>` (for arbitrary `T`)\n\n- Tuples and arrays containing only allowed union field types\n\nThis restriction ensures, in particular, that union fields never need to be\ndropped. Like for structs and enums, it is possible to `impl Drop` for a union\nto manually define what happens when it gets dropped.\n\nUnions without any fields are not accepted by the compiler, but can be accepted by macros.",
      "parent_id": null,
      "paragraphs": {
        "items.union.syntax": ",items\nUnion ->\n    `union` IDENTIFIER GenericParams? WhereClause? `{` StructFields? `}`",
        "items.union.intro": "A union declaration uses the same syntax as a struct declaration, except with\n`union` in place of `struct`.",
        "items.union.namespace": "A union declaration defines the given name in the [type namespace] of the module or block where it is located.\n\n#[repr(C)]\nunion MyUnion {\n    f1: u32,\n    f2: f32,\n}",
        "items.union.common-storage": "The key property of unions is that all fields of a union share common storage.\nAs a result, writes to one field of a union can overwrite its other fields, and\nsize of a union is determined by the size of its largest field.",
        "items.union.field-restrictions": "Union field types are restricted to the following subset of types:",
        "items.union.field-copy": "- `Copy` types",
        "items.union.field-references": "- References (`&T` and `&mut T` for arbitrary `T`)",
        "items.union.field-manually-drop": "- `ManuallyDrop<T>` (for arbitrary `T`)",
        "items.union.field-tuple": "- Tuples and arrays containing only allowed union field types",
        "items.union.drop": "This restriction ensures, in particular, that union fields never need to be\ndropped. Like for structs and enums, it is possible to `impl Drop` for a union\nto manually define what happens when it gets dropped.",
        "items.union.fieldless": "Unions without any fields are not accepted by the compiler, but can be accepted by macros."
      }
    },
    {
      "id": "items.union.init",
      "title": "Initialization of a union",
      "level": 1,
      "content": "A value of a union type can be created using the same syntax that is used for\nstruct types, except that it must specify exactly one field:\n\n# union MyUnion { f1: u32, f2: f32 }\n#\nlet u = MyUnion { f1: 1 };\n\nThe expression above creates a value of type `MyUnion` and initializes the\nstorage using field `f1`. The union can be accessed using the same syntax as\nstruct fields:\n\n# union MyUnion { f1: u32, f2: f32 }\n#\n# let u = MyUnion { f1: 1 };\nlet f = unsafe { u.f1 };",
      "parent_id": null,
      "paragraphs": {
        "items.union.init.intro": "A value of a union type can be created using the same syntax that is used for\nstruct types, except that it must specify exactly one field:\n\n# union MyUnion { f1: u32, f2: f32 }\n#\nlet u = MyUnion { f1: 1 };",
        "items.union.init.result": "The expression above creates a value of type `MyUnion` and initializes the\nstorage using field `f1`. The union can be accessed using the same syntax as\nstruct fields:\n\n# union MyUnion { f1: u32, f2: f32 }\n#\n# let u = MyUnion { f1: 1 };\nlet f = unsafe { u.f1 };"
      }
    },
    {
      "id": "items.union.fields",
      "title": "Reading and writing union fields",
      "level": 1,
      "content": "Unions have no notion of an \"active field\". Instead, every union access just\ninterprets the storage as the type of the field used for the access.\n\nReading a union field reads the bits of the union at the field's type.\n\nFields might have a non-zero offset (except when [the C representation] is used); in that case the\nbits starting at the offset of the fields are read\n\nIt is the programmer's responsibility to make sure that the data is valid at the field's type. Failing\nto do so results in [undefined behavior]. For example, reading the value `3`\nfrom a field of the [boolean type] is undefined behavior. Effectively,\nwriting to and then reading from a union with [the C representation] is\nanalogous to a [`transmute`] from the type used for writing to the type used for\nreading.\n\nConsequently, all reads of union fields have to be placed in `unsafe` blocks:\n\n# union MyUnion { f1: u32, f2: f32 }\n# let u = MyUnion { f1: 1 };\n#\nunsafe {\n    let f = u.f1;\n}\n\nCommonly, code using unions will provide safe wrappers around unsafe union\nfield accesses.\n\nIn contrast, writes to union fields are safe, since they just overwrite\narbitrary data, but cannot cause undefined behavior. (Note that union field\ntypes can never have drop glue, so a union field write will never implicitly\ndrop anything.)",
      "parent_id": null,
      "paragraphs": {
        "items.union.fields.intro": "Unions have no notion of an \"active field\". Instead, every union access just\ninterprets the storage as the type of the field used for the access.",
        "items.union.fields.read": "Reading a union field reads the bits of the union at the field's type.",
        "items.union.fields.offset": "Fields might have a non-zero offset (except when [the C representation] is used); in that case the\nbits starting at the offset of the fields are read",
        "items.union.fields.validity": "It is the programmer's responsibility to make sure that the data is valid at the field's type. Failing\nto do so results in [undefined behavior]. For example, reading the value `3`\nfrom a field of the [boolean type] is undefined behavior. Effectively,\nwriting to and then reading from a union with [the C representation] is\nanalogous to a [`transmute`] from the type used for writing to the type used for\nreading.",
        "items.union.fields.read-safety": "Consequently, all reads of union fields have to be placed in `unsafe` blocks:\n\n# union MyUnion { f1: u32, f2: f32 }\n# let u = MyUnion { f1: 1 };\n#\nunsafe {\n    let f = u.f1;\n}\n\nCommonly, code using unions will provide safe wrappers around unsafe union\nfield accesses.",
        "items.union.fields.write-safety": "In contrast, writes to union fields are safe, since they just overwrite\narbitrary data, but cannot cause undefined behavior. (Note that union field\ntypes can never have drop glue, so a union field write will never implicitly\ndrop anything.)"
      }
    },
    {
      "id": "items.union.pattern",
      "title": "Pattern matching on unions",
      "level": 1,
      "content": "Another way to access union fields is to use pattern matching.\n\nPattern matching on union fields uses the same syntax as struct patterns, except that the pattern\nmust specify exactly one field.\n\nSince pattern matching is like reading the union with a particular field, it has to be placed in `unsafe` blocks as well.\n\n# union MyUnion { f1: u32, f2: f32 }\n#\nfn f(u: MyUnion) {\n    unsafe {\n        match u {\n            MyUnion { f1: 10 } => { println!(\"ten\"); }\n            MyUnion { f2 } => { println!(\"{}\", f2); }\n        }\n    }\n}\n\nPattern matching may match a union as a field of a larger structure. In\nparticular, when using a Rust union to implement a C tagged union via FFI, this\nallows matching on the tag and the corresponding field simultaneously:\n\n#[repr(u32)]\nenum Tag { I, F }\n\n#[repr(C)]\nunion U {\n    i: i32,\n    f: f32,\n}\n\n#[repr(C)]\nstruct Value {\n    tag: Tag,\n    u: U,\n}\n\nfn is_zero(v: Value) -> bool {\n    unsafe {\n        match v {\n            Value { tag: Tag::I, u: U { i: 0 } } => true,\n            Value { tag: Tag::F, u: U { f: num } } if num == 0.0 => true,\n            _ => false,\n        }\n    }\n}",
      "parent_id": null,
      "paragraphs": {
        "items.union.pattern.intro": "Another way to access union fields is to use pattern matching.",
        "items.union.pattern.one-field": "Pattern matching on union fields uses the same syntax as struct patterns, except that the pattern\nmust specify exactly one field.",
        "items.union.pattern.safety": "Since pattern matching is like reading the union with a particular field, it has to be placed in `unsafe` blocks as well.\n\n# union MyUnion { f1: u32, f2: f32 }\n#\nfn f(u: MyUnion) {\n    unsafe {\n        match u {\n            MyUnion { f1: 10 } => { println!(\"ten\"); }\n            MyUnion { f2 } => { println!(\"{}\", f2); }\n        }\n    }\n}",
        "items.union.pattern.subpattern": "Pattern matching may match a union as a field of a larger structure. In\nparticular, when using a Rust union to implement a C tagged union via FFI, this\nallows matching on the tag and the corresponding field simultaneously:\n\n#[repr(u32)]\nenum Tag { I, F }\n\n#[repr(C)]\nunion U {\n    i: i32,\n    f: f32,\n}\n\n#[repr(C)]\nstruct Value {\n    tag: Tag,\n    u: U,\n}\n\nfn is_zero(v: Value) -> bool {\n    unsafe {\n        match v {\n            Value { tag: Tag::I, u: U { i: 0 } } => true,\n            Value { tag: Tag::F, u: U { f: num } } if num == 0.0 => true,\n            _ => false,\n        }\n    }\n}"
      }
    },
    {
      "id": "items.union.ref",
      "title": "References to union fields",
      "level": 1,
      "content": "Since union fields share common storage, gaining write access to one field of a\nunion can give write access to all its remaining fields.\n\nBorrow checking rules have to be adjusted to account for this fact. As a result, if one field of a\nunion is borrowed, all its remaining fields are borrowed as well for the same\nlifetime.\n\n,compile_fail\n# union MyUnion { f1: u32, f2: f32 }\n// ERROR: cannot borrow `u` (via `u.f2`) as mutable more than once at a time\nfn test() {\n    let mut u = MyUnion { f1: 1 };\n    unsafe {\n        let b1 = &mut u.f1;\n//                    ---- first mutable borrow occurs here (via `u.f1`)\n        let b2 = &mut u.f2;\n//                    ^^^^ second mutable borrow occurs here (via `u.f2`)\n        *b1 = 5;\n    }\n//  - first borrow ends here\n    assert_eq!(unsafe { u.f1 }, 5);\n}\n\nAs you could see, in many aspects (except for layouts, safety, and ownership)\nunions behave exactly like structs, largely as a consequence of inheriting\ntheir syntactic shape from structs. This is also true for many unmentioned\naspects of Rust language (such as privacy, name resolution, type inference,\ngenerics, trait implementations, inherent implementations, coherence, pattern\nchecking, etc etc etc).\n\n[`transmute`]: std::mem::transmute\n[boolean type]: ../types/boolean.md\n[the C representation]: ../type-layout.md#reprc-unions\n[type namespace]: ../names/namespaces.md\n[undefined behavior]: ../behavior-considered-undefined.md",
      "parent_id": null,
      "paragraphs": {
        "items.union.ref.intro": "Since union fields share common storage, gaining write access to one field of a\nunion can give write access to all its remaining fields.",
        "items.union.ref.borrow": "Borrow checking rules have to be adjusted to account for this fact. As a result, if one field of a\nunion is borrowed, all its remaining fields are borrowed as well for the same\nlifetime.\n\n,compile_fail\n# union MyUnion { f1: u32, f2: f32 }\n// ERROR: cannot borrow `u` (via `u.f2`) as mutable more than once at a time\nfn test() {\n    let mut u = MyUnion { f1: 1 };\n    unsafe {\n        let b1 = &mut u.f1;\n//                    ---- first mutable borrow occurs here (via `u.f1`)\n        let b2 = &mut u.f2;\n//                    ^^^^ second mutable borrow occurs here (via `u.f2`)\n        *b1 = 5;\n    }\n//  - first borrow ends here\n    assert_eq!(unsafe { u.f1 }, 5);\n}",
        "items.union.ref.usage": "As you could see, in many aspects (except for layouts, safety, and ownership)\nunions behave exactly like structs, largely as a consequence of inheriting\ntheir syntactic shape from structs. This is also true for many unmentioned\naspects of Rust language (such as privacy, name resolution, type inference,\ngenerics, trait implementations, inherent implementations, coherence, pattern\nchecking, etc etc etc).\n\n[`transmute`]: std::mem::transmute\n[boolean type]: ../types/boolean.md\n[the C representation]: ../type-layout.md#reprc-unions\n[type namespace]: ../names/namespaces.md\n[undefined behavior]: ../behavior-considered-undefined.md"
      }
    },
    {
      "id": "items.const",
      "title": "Constant items",
      "level": 1,
      "content": ",items\nConstantItem ->\n    `const` ( IDENTIFIER | `_` ) `:` Type ( `=` Expression )? `;`\n\nA *constant item* is an optionally named _[constant value]_ which is not associated\nwith a specific memory location in the program.\n\nConstants are essentially inlined wherever they are used, meaning that they are copied directly into the relevant\ncontext when used. This includes usage of constants from external crates, and\nnon-[`Copy`] types. References to the same constant are not necessarily\nguaranteed to refer to the same memory address.\n\nThe constant declaration defines the constant value in the [value namespace] of the module or block where it is located.\n\nConstants must be explicitly typed. The type must have a `'static` lifetime: any\nreferences in the initializer must have `'static` lifetimes. References\nin the type of a constant default to `'static` lifetime; see [static lifetime\nelision].\n\nA reference to a constant will have `'static` lifetime if the constant value is eligible for\n[promotion]; otherwise, a temporary will be created.\n\nconst BIT1: u32 = 1 << 0;\nconst BIT2: u32 = 1 << 1;\n\nconst BITS: [u32; 2] = [BIT1, BIT2];\nconst STRING: &'static str = \"bitstring\";\n\nstruct BitsNStrings<'a> {\n    mybits: [u32; 2],\n    mystring: &'a str,\n}\n\nconst BITS_N_STRINGS: BitsNStrings<'static> = BitsNStrings {\n    mybits: BITS,\n    mystring: STRING,\n};\n\nThe constant expression may only be omitted in a [trait definition].",
      "parent_id": null,
      "paragraphs": {
        "items.const.syntax": ",items\nConstantItem ->\n    `const` ( IDENTIFIER | `_` ) `:` Type ( `=` Expression )? `;`",
        "items.const.intro": "A *constant item* is an optionally named _[constant value]_ which is not associated\nwith a specific memory location in the program.",
        "items.const.behavior": "Constants are essentially inlined wherever they are used, meaning that they are copied directly into the relevant\ncontext when used. This includes usage of constants from external crates, and\nnon-[`Copy`] types. References to the same constant are not necessarily\nguaranteed to refer to the same memory address.",
        "items.const.namespace": "The constant declaration defines the constant value in the [value namespace] of the module or block where it is located.",
        "items.const.static": "Constants must be explicitly typed. The type must have a `'static` lifetime: any\nreferences in the initializer must have `'static` lifetimes. References\nin the type of a constant default to `'static` lifetime; see [static lifetime\nelision].",
        "items.const.static-temporary": "A reference to a constant will have `'static` lifetime if the constant value is eligible for\n[promotion]; otherwise, a temporary will be created.\n\nconst BIT1: u32 = 1 << 0;\nconst BIT2: u32 = 1 << 1;\n\nconst BITS: [u32; 2] = [BIT1, BIT2];\nconst STRING: &'static str = \"bitstring\";\n\nstruct BitsNStrings<'a> {\n    mybits: [u32; 2],\n    mystring: &'a str,\n}\n\nconst BITS_N_STRINGS: BitsNStrings<'static> = BitsNStrings {\n    mybits: BITS,\n    mystring: STRING,\n};",
        "items.const.expr-omission": "The constant expression may only be omitted in a [trait definition]."
      }
    },
    {
      "id": "items.const.destructor",
      "title": "Constants with destructors",
      "level": 1,
      "content": "Constants can contain destructors. Destructors are run when the value goes out\nof scope.\n\nstruct TypeWithDestructor(i32);\n\nimpl Drop for TypeWithDestructor {\n    fn drop(&mut self) {\n        println!(\"Dropped. Held {}.\", self.0);\n    }\n}\n\nconst ZERO_WITH_DESTRUCTOR: TypeWithDestructor = TypeWithDestructor(0);\n\nfn create_and_drop_zero_with_destructor() {\n    let x = ZERO_WITH_DESTRUCTOR;\n    // x gets dropped at end of function, calling drop.\n    // prints \"Dropped. Held 0.\".\n}",
      "parent_id": null,
      "paragraphs": {
        "items.const.destructor": "Constants can contain destructors. Destructors are run when the value goes out\nof scope.\n\nstruct TypeWithDestructor(i32);\n\nimpl Drop for TypeWithDestructor {\n    fn drop(&mut self) {\n        println!(\"Dropped. Held {}.\", self.0);\n    }\n}\n\nconst ZERO_WITH_DESTRUCTOR: TypeWithDestructor = TypeWithDestructor(0);\n\nfn create_and_drop_zero_with_destructor() {\n    let x = ZERO_WITH_DESTRUCTOR;\n    // x gets dropped at end of function, calling drop.\n    // prints \"Dropped. Held 0.\".\n}"
      }
    },
    {
      "id": "items.const.unnamed",
      "title": "Unnamed constant",
      "level": 2,
      "content": "Unlike an [associated constant], a [free] constant may be unnamed by using\nan underscore instead of the name. For example:\n\nconst _: () =  { struct _SameNameTwice; };\n\n// OK although it is the same name as above:\nconst _: () =  { struct _SameNameTwice; };\n\nAs with [underscore imports], macros may safely emit the same unnamed constant in\nthe same scope more than once. For example, the following should not produce an error:\n\nmacro_rules! m {\n    ($item: item) => { $item $item }\n}\n\nm!(const _: () = (););\n// This expands to:\n// const _: () = ();\n// const _: () = ();",
      "parent_id": null,
      "paragraphs": {
        "items.const.unnamed.intro": "Unlike an [associated constant], a [free] constant may be unnamed by using\nan underscore instead of the name. For example:\n\nconst _: () =  { struct _SameNameTwice; };\n\n// OK although it is the same name as above:\nconst _: () =  { struct _SameNameTwice; };",
        "items.const.unnamed.repetition": "As with [underscore imports], macros may safely emit the same unnamed constant in\nthe same scope more than once. For example, the following should not produce an error:\n\nmacro_rules! m {\n    ($item: item) => { $item $item }\n}\n\nm!(const _: () = (););\n// This expands to:\n// const _: () = ();\n// const _: () = ();"
      }
    },
    {
      "id": "items.const.eval",
      "title": "Evaluation",
      "level": 2,
      "content": "Free constants are always evaluated at compile-time to surface\npanics. This happens even within an unused function:\n\n,compile_fail\n// Compile-time panic\nconst PANIC: () = std::unimplemented!();\n\nfn unused_generic_function<T>() {\n    // A failing compile-time assertion\n    const _: () = assert!(usize::BITS == 0);\n}\n\n[const_eval]: ../const_eval.md\n[associated constant]: ../items/associated-items.md#associated-constants\n[constant value]: ../const_eval.md#constant-expressions\n[free]: ../glossary.md#free-item\n[static lifetime elision]: ../lifetime-elision.md#const-and-static-elision\n[trait definition]: traits.md\n[underscore imports]: use-declarations.md#underscore-imports\n[`Copy`]: ../special-types-and-traits.md#copy\n[value namespace]: ../names/namespaces.md\n[promotion]: destructors.scope.const-promotion",
      "parent_id": null,
      "paragraphs": {
        "items.const.eval": "Free constants are always evaluated at compile-time to surface\npanics. This happens even within an unused function:\n\n,compile_fail\n// Compile-time panic\nconst PANIC: () = std::unimplemented!();\n\nfn unused_generic_function<T>() {\n    // A failing compile-time assertion\n    const _: () = assert!(usize::BITS == 0);\n}\n\n[const_eval]: ../const_eval.md\n[associated constant]: ../items/associated-items.md#associated-constants\n[constant value]: ../const_eval.md#constant-expressions\n[free]: ../glossary.md#free-item\n[static lifetime elision]: ../lifetime-elision.md#const-and-static-elision\n[trait definition]: traits.md\n[underscore imports]: use-declarations.md#underscore-imports\n[`Copy`]: ../special-types-and-traits.md#copy\n[value namespace]: ../names/namespaces.md\n[promotion]: destructors.scope.const-promotion"
      }
    },
    {
      "id": "items.static",
      "title": "Static items",
      "level": 1,
      "content": ",items\nStaticItem ->\n    ItemSafety?[^extern-safety] `static` `mut`? IDENTIFIER `:` Type ( `=` Expression )? `;`\n\n[^extern-safety]: The `safe` and `unsafe` function qualifiers are only allowed semantically within `extern` blocks.\n\nA *static item* is similar to a [constant], except that it represents an allocation in the\nprogram that is initialized with the initializer expression. All references and raw pointers to the\nstatic refer to the same allocation.\n\nStatic items have the `static` lifetime, which outlives all other lifetimes in a Rust program.\nStatic items do not call [`drop`] at the end of the program.\n\nIf the `static` has a size of at least 1 byte, this allocation is disjoint from all other such\n`static` allocations as well as heap allocations and stack-allocated variables. However, the storage of\nimmutable `static` items can overlap with allocations that do not themselves have a unique address, such\nas [promoteds] and `const` items.\n\nThe static declaration defines a static value in the [value namespace] of the module or block where it is located.\n\nThe static initializer is a [constant expression] evaluated at compile time.\nStatic initializers may refer to and read from other statics.\nWhen reading from mutable statics, they read the initial value of that static.\n\nNon-`mut` static items that contain a type that is not [interior mutable] may\nbe placed in read-only memory.\n\nAll access to a static is safe, but there are a number of restrictions on\nstatics:\n\n* The type must have the `Sync` trait bound to allow thread-safe access.\n\nThe initializer expression must be omitted in an [external block], and must be\nprovided for free static items.\n\nThe `safe` and `unsafe` qualifiers are semantically only allowed when used in an [external block].",
      "parent_id": null,
      "paragraphs": {
        "items.static.syntax": ",items\nStaticItem ->\n    ItemSafety?[^extern-safety] `static` `mut`? IDENTIFIER `:` Type ( `=` Expression )? `;`\n\n[^extern-safety]: The `safe` and `unsafe` function qualifiers are only allowed semantically within `extern` blocks.",
        "items.static.intro": "A *static item* is similar to a [constant], except that it represents an allocation in the\nprogram that is initialized with the initializer expression. All references and raw pointers to the\nstatic refer to the same allocation.",
        "items.static.lifetime": "Static items have the `static` lifetime, which outlives all other lifetimes in a Rust program.\nStatic items do not call [`drop`] at the end of the program.",
        "items.static.storage-disjointness": "If the `static` has a size of at least 1 byte, this allocation is disjoint from all other such\n`static` allocations as well as heap allocations and stack-allocated variables. However, the storage of\nimmutable `static` items can overlap with allocations that do not themselves have a unique address, such\nas [promoteds] and `const` items.",
        "items.static.namespace": "The static declaration defines a static value in the [value namespace] of the module or block where it is located.",
        "items.static.init": "The static initializer is a [constant expression] evaluated at compile time.\nStatic initializers may refer to and read from other statics.\nWhen reading from mutable statics, they read the initial value of that static.",
        "items.static.read-only": "Non-`mut` static items that contain a type that is not [interior mutable] may\nbe placed in read-only memory.",
        "items.static.safety": "All access to a static is safe, but there are a number of restrictions on\nstatics:",
        "items.static.sync": "* The type must have the `Sync` trait bound to allow thread-safe access.",
        "items.static.init.omission": "The initializer expression must be omitted in an [external block], and must be\nprovided for free static items.",
        "items.static.safety-qualifiers": "The `safe` and `unsafe` qualifiers are semantically only allowed when used in an [external block]."
      }
    },
    {
      "id": "items.static.generics",
      "title": "Statics & generics",
      "level": 1,
      "content": "A static item defined in a generic scope (for example in a blanket or default\nimplementation) will result in exactly one static item being defined, as if\nthe static definition was pulled out of the current scope into the module.\nThere will *not* be one item per monomorphization.\n\nThis code:\n\nuse std::sync::atomic::{AtomicUsize, Ordering};\n\ntrait Tr {\n    fn default_impl() {\n        static COUNTER: AtomicUsize = AtomicUsize::new(0);\n        println!(\"default_impl: counter was {}\", COUNTER.fetch_add(1, Ordering::Relaxed));\n    }\n\n    fn blanket_impl();\n}\n\nstruct Ty1 {}\nstruct Ty2 {}\n\nimpl<T> Tr for T {\n    fn blanket_impl() {\n        static COUNTER: AtomicUsize = AtomicUsize::new(0);\n        println!(\"blanket_impl: counter was {}\", COUNTER.fetch_add(1, Ordering::Relaxed));\n    }\n}\n\nfn main() {\n    <Ty1 as Tr>::default_impl();\n    <Ty2 as Tr>::default_impl();\n    <Ty1 as Tr>::blanket_impl();\n    <Ty2 as Tr>::blanket_impl();\n}\n\nprints\n\ndefault_impl: counter was 0\ndefault_impl: counter was 1\nblanket_impl: counter was 0\nblanket_impl: counter was 1",
      "parent_id": null,
      "paragraphs": {
        "items.static.generics": "A static item defined in a generic scope (for example in a blanket or default\nimplementation) will result in exactly one static item being defined, as if\nthe static definition was pulled out of the current scope into the module.\nThere will *not* be one item per monomorphization.\n\nThis code:\n\nuse std::sync::atomic::{AtomicUsize, Ordering};\n\ntrait Tr {\n    fn default_impl() {\n        static COUNTER: AtomicUsize = AtomicUsize::new(0);\n        println!(\"default_impl: counter was {}\", COUNTER.fetch_add(1, Ordering::Relaxed));\n    }\n\n    fn blanket_impl();\n}\n\nstruct Ty1 {}\nstruct Ty2 {}\n\nimpl<T> Tr for T {\n    fn blanket_impl() {\n        static COUNTER: AtomicUsize = AtomicUsize::new(0);\n        println!(\"blanket_impl: counter was {}\", COUNTER.fetch_add(1, Ordering::Relaxed));\n    }\n}\n\nfn main() {\n    <Ty1 as Tr>::default_impl();\n    <Ty2 as Tr>::default_impl();\n    <Ty1 as Tr>::blanket_impl();\n    <Ty2 as Tr>::blanket_impl();\n}\n\nprints\n\ndefault_impl: counter was 0\ndefault_impl: counter was 1\nblanket_impl: counter was 0\nblanket_impl: counter was 1"
      }
    },
    {
      "id": "items.static.mut",
      "title": "Mutable statics",
      "level": 2,
      "content": "If a static item is declared with the `mut` keyword, then it is allowed to be\nmodified by the program. One of Rust's goals is to make concurrency bugs hard\nto run into, and this is obviously a very large source of race conditions or\nother bugs.\n\nFor this reason, an `unsafe` block is required when either reading\nor writing a mutable static variable. Care should be taken to ensure that\nmodifications to a mutable static are safe with respect to other threads\nrunning in the same process.\n\nMutable statics are still very useful, however. They can be used with C\nlibraries and can also be bound from C libraries in an `extern` block.\n\n# fn atomic_add(_: *mut u32, _: u32) -> u32 { 2 }\n\nstatic mut LEVELS: u32 = 0;\n\n// This violates the idea of no shared state, and this doesn't internally\n// protect against races, so this function is `unsafe`\nunsafe fn bump_levels_unsafe() -> u32 {\n    unsafe {\n        let ret = LEVELS;\n        LEVELS += 1;\n        return ret;\n    }\n}\n\n// As an alternative to `bump_levels_unsafe`, this function is safe, assuming\n// that we have an atomic_add function which returns the old value. This\n// function is safe only if no other code accesses the static in a non-atomic\n// fashion. If such accesses are possible (such as in `bump_levels_unsafe`),\n// then this would need to be `unsafe` to indicate to the caller that they\n// must still guard against concurrent access.\nfn bump_levels_safe() -> u32 {\n    unsafe {\n        return atomic_add(&raw mut LEVELS, 1);\n    }\n}\n\nMutable statics have the same restrictions as normal statics, except that the\ntype does not have to implement the `Sync` trait.",
      "parent_id": null,
      "paragraphs": {
        "items.static.mut.intro": "If a static item is declared with the `mut` keyword, then it is allowed to be\nmodified by the program. One of Rust's goals is to make concurrency bugs hard\nto run into, and this is obviously a very large source of race conditions or\nother bugs.",
        "items.static.mut.safety": "For this reason, an `unsafe` block is required when either reading\nor writing a mutable static variable. Care should be taken to ensure that\nmodifications to a mutable static are safe with respect to other threads\nrunning in the same process.",
        "items.static.mut.extern": "Mutable statics are still very useful, however. They can be used with C\nlibraries and can also be bound from C libraries in an `extern` block.\n\n# fn atomic_add(_: *mut u32, _: u32) -> u32 { 2 }\n\nstatic mut LEVELS: u32 = 0;\n\n// This violates the idea of no shared state, and this doesn't internally\n// protect against races, so this function is `unsafe`\nunsafe fn bump_levels_unsafe() -> u32 {\n    unsafe {\n        let ret = LEVELS;\n        LEVELS += 1;\n        return ret;\n    }\n}\n\n// As an alternative to `bump_levels_unsafe`, this function is safe, assuming\n// that we have an atomic_add function which returns the old value. This\n// function is safe only if no other code accesses the static in a non-atomic\n// fashion. If such accesses are possible (such as in `bump_levels_unsafe`),\n// then this would need to be `unsafe` to indicate to the caller that they\n// must still guard against concurrent access.\nfn bump_levels_safe() -> u32 {\n    unsafe {\n        return atomic_add(&raw mut LEVELS, 1);\n    }\n}",
        "items.static.mut.sync": "Mutable statics have the same restrictions as normal statics, except that the\ntype does not have to implement the `Sync` trait."
      }
    },
    {
      "id": "items.static.alternate",
      "title": "Using statics or consts",
      "level": 1,
      "content": "It can be confusing whether or not you should use a constant item or a static\nitem. Constants should, in general, be preferred over statics unless one of the\nfollowing are true:\n\n* Large amounts of data are being stored.\n* The single-address property of statics is required.\n* Interior mutability is required.\n\n[constant]: constant-items.md\n[`drop`]: ../destructors.md\n[constant expression]: ../const_eval.md#constant-expressions\n[external block]: external-blocks.md\n[interior mutable]: ../interior-mutability.md\n[value namespace]: ../names/namespaces.md\n[promoteds]: ../destructors.md#constant-promotion",
      "parent_id": null,
      "paragraphs": {
        "items.static.alternate": "It can be confusing whether or not you should use a constant item or a static\nitem. Constants should, in general, be preferred over statics unless one of the\nfollowing are true:\n\n* Large amounts of data are being stored.\n* The single-address property of statics is required.\n* Interior mutability is required.\n\n[constant]: constant-items.md\n[`drop`]: ../destructors.md\n[constant expression]: ../const_eval.md#constant-expressions\n[external block]: external-blocks.md\n[interior mutable]: ../interior-mutability.md\n[value namespace]: ../names/namespaces.md\n[promoteds]: ../destructors.md#constant-promotion"
      }
    },
    {
      "id": "items.traits",
      "title": "Traits",
      "level": 1,
      "content": ",items\nTrait ->\n    `unsafe`? `trait` IDENTIFIER GenericParams? ( `:` TypeParamBounds? )? WhereClause?\n    `{`\n        InnerAttribute*\n        AssociatedItem*\n    `}`\n\nA _trait_ describes an abstract interface that types can implement. This\ninterface consists of [associated items], which come in three varieties:\n\n- functions\n- types\n- constants\n\nThe trait declaration defines a trait in the [type namespace] of the module or block where it is located.\n\nAssociated items are defined as members of the trait within their respective namespaces. Associated types are defined in the type namespace. Associated constants and associated functions are defined in the value namespace.\n\nAll traits define an implicit type parameter `Self` that refers to \"the type\nthat is implementing this interface\". Traits may also contain additional type\nparameters. These type parameters, including `Self`, may be constrained by\nother traits and so forth as usual.\n\nTraits are implemented for specific types through separate [implementations].\n\nTrait functions may omit the function body by replacing it with a semicolon.\nThis indicates that the implementation must define the function. If the trait\nfunction defines a body, this definition acts as a default for any\nimplementation which does not override it. Similarly, associated constants may\nomit the equals sign and expression to indicate implementations must define\nthe constant value. Associated types must never define the type, the type may\nonly be specified in an implementation.\n\n// Examples of associated trait items with and without definitions.\ntrait Example {\n    const CONST_NO_DEFAULT: i32;\n    const CONST_WITH_DEFAULT: i32 = 99;\n    type TypeNoDefault;\n    fn method_without_default(&self);\n    fn method_with_default(&self) {}\n}\n\nTrait functions are not allowed to be [`const`].",
      "parent_id": null,
      "paragraphs": {
        "items.traits.syntax": ",items\nTrait ->\n    `unsafe`? `trait` IDENTIFIER GenericParams? ( `:` TypeParamBounds? )? WhereClause?\n    `{`\n        InnerAttribute*\n        AssociatedItem*\n    `}`",
        "items.traits.intro": "A _trait_ describes an abstract interface that types can implement. This\ninterface consists of [associated items], which come in three varieties:\n\n- functions\n- types\n- constants",
        "items.traits.namespace": "The trait declaration defines a trait in the [type namespace] of the module or block where it is located.",
        "items.traits.associated-item-namespaces": "Associated items are defined as members of the trait within their respective namespaces. Associated types are defined in the type namespace. Associated constants and associated functions are defined in the value namespace.",
        "items.traits.self-param": "All traits define an implicit type parameter `Self` that refers to \"the type\nthat is implementing this interface\". Traits may also contain additional type\nparameters. These type parameters, including `Self`, may be constrained by\nother traits and so forth as usual.",
        "items.traits.impls": "Traits are implemented for specific types through separate [implementations].",
        "items.traits.associated-item-decls": "Trait functions may omit the function body by replacing it with a semicolon.\nThis indicates that the implementation must define the function. If the trait\nfunction defines a body, this definition acts as a default for any\nimplementation which does not override it. Similarly, associated constants may\nomit the equals sign and expression to indicate implementations must define\nthe constant value. Associated types must never define the type, the type may\nonly be specified in an implementation.\n\n// Examples of associated trait items with and without definitions.\ntrait Example {\n    const CONST_NO_DEFAULT: i32;\n    const CONST_WITH_DEFAULT: i32 = 99;\n    type TypeNoDefault;\n    fn method_without_default(&self);\n    fn method_with_default(&self) {}\n}",
        "items.traits.const-fn": "Trait functions are not allowed to be [`const`]."
      }
    },
    {
      "id": "items.traits.bounds",
      "title": "Trait bounds",
      "level": 1,
      "content": "Generic items may use traits as [bounds] on their type parameters.",
      "parent_id": null,
      "paragraphs": {
        "items.traits.bounds": "Generic items may use traits as [bounds] on their type parameters."
      }
    },
    {
      "id": "items.traits.generic",
      "title": "Generic traits",
      "level": 2,
      "content": "Type parameters can be specified for a trait to make it generic. These appear\nafter the trait name, using the same syntax used in [generic functions].\n\ntrait Seq<T> {\n    fn len(&self) -> u32;\n    fn elt_at(&self, n: u32) -> T;\n    fn iter<F>(&self, f: F) where F: Fn(T);\n}\n\n<a id=\"object-safety\"></a>",
      "parent_id": null,
      "paragraphs": {
        "items.traits.generic": "Type parameters can be specified for a trait to make it generic. These appear\nafter the trait name, using the same syntax used in [generic functions].\n\ntrait Seq<T> {\n    fn len(&self) -> u32;\n    fn elt_at(&self, n: u32) -> T;\n    fn iter<F>(&self, f: F) where F: Fn(T);\n}\n\n<a id=\"object-safety\"></a>"
      }
    },
    {
      "id": "items.traits.dyn-compatible",
      "title": "Dyn compatibility",
      "level": 2,
      "content": "A dyn-compatible trait can be the base trait of a [trait object]. A trait is\n*dyn compatible* if it has the following qualities:\n\n* All [supertraits] must also be dyn compatible.\n\n* `Sized` must not be a supertrait. In other words, it must not require `Self: Sized`.\n\n* It must not have any associated constants.\n\n* It must not have any associated types with generics.\n\n* All associated functions must either be dispatchable from a trait object or be explicitly non-dispatchable:\n    * Dispatchable functions must:\n        * Not have any type parameters (although lifetime parameters are allowed).\n        * Be a [method] that does not use `Self` except in the type of the receiver.\n        * Have a receiver with one of the following types:\n            * `&Self` (i.e. `&self`)\n            * `&mut Self` (i.e `&mut self`)\n            * [`Box<Self>`]\n            * [`Rc<Self>`]\n            * [`Arc<Self>`]\n            * [`Pin<P>`] where `P` is one of the types above\n        * Not have an opaque return type; that is,\n            * Not be an `async fn` (which has a hidden `Future` type).\n            * Not have a return position `impl Trait` type (`fn example(&self) -> impl Trait`).\n        * Not have a `where Self: Sized` bound (receiver type of `Self` (i.e. `self`) implies this).\n    * Explicitly non-dispatchable functions require:\n        * Have a `where Self: Sized` bound (receiver type of `Self` (i.e. `self`) implies this).\n\n* The [`AsyncFn`], [`AsyncFnMut`], and [`AsyncFnOnce`] traits are not dyn-compatible.\n\n> [!NOTE]\n> This concept was formerly known as *object safety*.\n\n# use std::rc::Rc;\n# use std::sync::Arc;\n# use std::pin::Pin;\n// Examples of dyn compatible methods.\ntrait TraitMethods {\n    fn by_ref(self: &Self) {}\n    fn by_ref_mut(self: &mut Self) {}\n    fn by_box(self: Box<Self>) {}\n    fn by_rc(self: Rc<Self>) {}\n    fn by_arc(self: Arc<Self>) {}\n    fn by_pin(self: Pin<&Self>) {}\n    fn with_lifetime<'a>(self: &'a Self) {}\n    fn nested_pin(self: Pin<Arc<Self>>) {}\n}\n# struct S;\n# impl TraitMethods for S {}\n# let t: Box<dyn TraitMethods> = Box::new(S);\n\n,compile_fail\n// This trait is dyn compatible, but these methods cannot be dispatched on a trait object.\ntrait NonDispatchable {\n    // Non-methods cannot be dispatched.\n    fn foo() where Self: Sized {}\n    // Self type isn't known until runtime.\n    fn returns(&self) -> Self where Self: Sized;\n    // `other` may be a different concrete type of the receiver.\n    fn param(&self, other: Self) where Self: Sized {}\n    // Generics are not compatible with vtables.\n    fn typed<T>(&self, x: T) where Self: Sized {}\n}\n\nstruct S;\nimpl NonDispatchable for S {\n    fn returns(&self) -> Self where Self: Sized { S }\n}\nlet obj: Box<dyn NonDispatchable> = Box::new(S);\nobj.returns(); // ERROR: cannot call with Self return\nobj.param(S);  // ERROR: cannot call with Self parameter\nobj.typed(1);  // ERROR: cannot call with generic type\n\n,compile_fail\n# use std::rc::Rc;\n// Examples of dyn-incompatible traits.\ntrait DynIncompatible {\n    const CONST: i32 = 1;  // ERROR: cannot have associated const\n\n    fn foo() {}  // ERROR: associated function without Sized\n    fn returns(&self) -> Self; // ERROR: Self in return type\n    fn typed<T>(&self, x: T) {} // ERROR: has generic type parameters\n    fn nested(self: Rc<Box<Self>>) {} // ERROR: nested receiver cannot be dispatched on\n}\n\nstruct S;\nimpl DynIncompatible for S {\n    fn returns(&self) -> Self { S }\n}\nlet obj: Box<dyn DynIncompatible> = Box::new(S); // ERROR\n\n,compile_fail\n// `Self: Sized` traits are dyn-incompatible.\ntrait TraitWithSize where Self: Sized {}\n\nstruct S;\nimpl TraitWithSize for S {}\nlet obj: Box<dyn TraitWithSize> = Box::new(S); // ERROR\n\n,compile_fail\n// Dyn-incompatible if `Self` is a type argument.\ntrait Super<A> {}\ntrait WithSelf: Super<Self> where Self: Sized {}\n\nstruct S;\nimpl<A> Super<A> for S {}\nimpl WithSelf for S {}\nlet obj: Box<dyn WithSelf> = Box::new(S); // ERROR: cannot use `Self` type parameter",
      "parent_id": null,
      "paragraphs": {
        "items.traits.dyn-compatible.intro": "A dyn-compatible trait can be the base trait of a [trait object]. A trait is\n*dyn compatible* if it has the following qualities:",
        "items.traits.dyn-compatible.supertraits": "* All [supertraits] must also be dyn compatible.",
        "items.traits.dyn-compatible.sized": "* `Sized` must not be a supertrait. In other words, it must not require `Self: Sized`.",
        "items.traits.dyn-compatible.associated-consts": "* It must not have any associated constants.",
        "items.traits.dyn-compatible.associated-types": "* It must not have any associated types with generics.",
        "items.traits.dyn-compatible.associated-functions": "* All associated functions must either be dispatchable from a trait object or be explicitly non-dispatchable:\n    * Dispatchable functions must:\n        * Not have any type parameters (although lifetime parameters are allowed).\n        * Be a [method] that does not use `Self` except in the type of the receiver.\n        * Have a receiver with one of the following types:\n            * `&Self` (i.e. `&self`)\n            * `&mut Self` (i.e `&mut self`)\n            * [`Box<Self>`]\n            * [`Rc<Self>`]\n            * [`Arc<Self>`]\n            * [`Pin<P>`] where `P` is one of the types above\n        * Not have an opaque return type; that is,\n            * Not be an `async fn` (which has a hidden `Future` type).\n            * Not have a return position `impl Trait` type (`fn example(&self) -> impl Trait`).\n        * Not have a `where Self: Sized` bound (receiver type of `Self` (i.e. `self`) implies this).\n    * Explicitly non-dispatchable functions require:\n        * Have a `where Self: Sized` bound (receiver type of `Self` (i.e. `self`) implies this).",
        "items.traits.dyn-compatible.async-traits": "* The [`AsyncFn`], [`AsyncFnMut`], and [`AsyncFnOnce`] traits are not dyn-compatible.\n\n> [!NOTE]\n> This concept was formerly known as *object safety*.\n\n# use std::rc::Rc;\n# use std::sync::Arc;\n# use std::pin::Pin;\n// Examples of dyn compatible methods.\ntrait TraitMethods {\n    fn by_ref(self: &Self) {}\n    fn by_ref_mut(self: &mut Self) {}\n    fn by_box(self: Box<Self>) {}\n    fn by_rc(self: Rc<Self>) {}\n    fn by_arc(self: Arc<Self>) {}\n    fn by_pin(self: Pin<&Self>) {}\n    fn with_lifetime<'a>(self: &'a Self) {}\n    fn nested_pin(self: Pin<Arc<Self>>) {}\n}\n# struct S;\n# impl TraitMethods for S {}\n# let t: Box<dyn TraitMethods> = Box::new(S);\n\n,compile_fail\n// This trait is dyn compatible, but these methods cannot be dispatched on a trait object.\ntrait NonDispatchable {\n    // Non-methods cannot be dispatched.\n    fn foo() where Self: Sized {}\n    // Self type isn't known until runtime.\n    fn returns(&self) -> Self where Self: Sized;\n    // `other` may be a different concrete type of the receiver.\n    fn param(&self, other: Self) where Self: Sized {}\n    // Generics are not compatible with vtables.\n    fn typed<T>(&self, x: T) where Self: Sized {}\n}\n\nstruct S;\nimpl NonDispatchable for S {\n    fn returns(&self) -> Self where Self: Sized { S }\n}\nlet obj: Box<dyn NonDispatchable> = Box::new(S);\nobj.returns(); // ERROR: cannot call with Self return\nobj.param(S);  // ERROR: cannot call with Self parameter\nobj.typed(1);  // ERROR: cannot call with generic type\n\n,compile_fail\n# use std::rc::Rc;\n// Examples of dyn-incompatible traits.\ntrait DynIncompatible {\n    const CONST: i32 = 1;  // ERROR: cannot have associated const\n\n    fn foo() {}  // ERROR: associated function without Sized\n    fn returns(&self) -> Self; // ERROR: Self in return type\n    fn typed<T>(&self, x: T) {} // ERROR: has generic type parameters\n    fn nested(self: Rc<Box<Self>>) {} // ERROR: nested receiver cannot be dispatched on\n}\n\nstruct S;\nimpl DynIncompatible for S {\n    fn returns(&self) -> Self { S }\n}\nlet obj: Box<dyn DynIncompatible> = Box::new(S); // ERROR\n\n,compile_fail\n// `Self: Sized` traits are dyn-incompatible.\ntrait TraitWithSize where Self: Sized {}\n\nstruct S;\nimpl TraitWithSize for S {}\nlet obj: Box<dyn TraitWithSize> = Box::new(S); // ERROR\n\n,compile_fail\n// Dyn-incompatible if `Self` is a type argument.\ntrait Super<A> {}\ntrait WithSelf: Super<Self> where Self: Sized {}\n\nstruct S;\nimpl<A> Super<A> for S {}\nimpl WithSelf for S {}\nlet obj: Box<dyn WithSelf> = Box::new(S); // ERROR: cannot use `Self` type parameter"
      }
    },
    {
      "id": "items.traits.supertraits",
      "title": "Supertraits",
      "level": 1,
      "content": "**Supertraits** are traits that are required to be implemented for a type to\nimplement a specific trait. Furthermore, anywhere a generic or [trait object]\nis bounded by a trait, it has access to the associated items of its supertraits.\n\nSupertraits are declared by trait bounds on the `Self` type of a trait and\ntransitively the supertraits of the traits declared in those trait bounds. It is\nan error for a trait to be its own supertrait.\n\nThe trait with a supertrait is called a **subtrait** of its supertrait.\n\nThe following is an example of declaring `Shape` to be a supertrait of `Circle`.\n\ntrait Shape { fn area(&self) -> f64; }\ntrait Circle: Shape { fn radius(&self) -> f64; }\n\nAnd the following is the same example, except using [where clauses].\n\ntrait Shape { fn area(&self) -> f64; }\ntrait Circle where Self: Shape { fn radius(&self) -> f64; }\n\nThis next example gives `radius` a default implementation using the `area`\nfunction from `Shape`.\n\n# trait Shape { fn area(&self) -> f64; }\ntrait Circle where Self: Shape {\n    fn radius(&self) -> f64 {\n        // A = pi * r^2\n        // so algebraically,\n        // r = sqrt(A / pi)\n        (self.area() / std::f64::consts::PI).sqrt()\n    }\n}\n\nThis next example calls a supertrait method on a generic parameter.\n\n# trait Shape { fn area(&self) -> f64; }\n# trait Circle: Shape { fn radius(&self) -> f64; }\nfn print_area_and_radius<C: Circle>(c: C) {\n    // Here we call the area method from the supertrait `Shape` of `Circle`.\n    println!(\"Area: {}\", c.area());\n    println!(\"Radius: {}\", c.radius());\n}\n\nSimilarly, here is an example of calling supertrait methods on trait objects.\n\n# trait Shape { fn area(&self) -> f64; }\n# trait Circle: Shape { fn radius(&self) -> f64; }\n# struct UnitCircle;\n# impl Shape for UnitCircle { fn area(&self) -> f64 { std::f64::consts::PI } }\n# impl Circle for UnitCircle { fn radius(&self) -> f64 { 1.0 } }\n# let circle = UnitCircle;\nlet circle = Box::new(circle) as Box<dyn Circle>;\nlet nonsense = circle.radius() * circle.area();",
      "parent_id": null,
      "paragraphs": {
        "items.traits.supertraits.intro": "**Supertraits** are traits that are required to be implemented for a type to\nimplement a specific trait. Furthermore, anywhere a generic or [trait object]\nis bounded by a trait, it has access to the associated items of its supertraits.",
        "items.traits.supertraits.decl": "Supertraits are declared by trait bounds on the `Self` type of a trait and\ntransitively the supertraits of the traits declared in those trait bounds. It is\nan error for a trait to be its own supertrait.",
        "items.traits.supertraits.subtrait": "The trait with a supertrait is called a **subtrait** of its supertrait.\n\nThe following is an example of declaring `Shape` to be a supertrait of `Circle`.\n\ntrait Shape { fn area(&self) -> f64; }\ntrait Circle: Shape { fn radius(&self) -> f64; }\n\nAnd the following is the same example, except using [where clauses].\n\ntrait Shape { fn area(&self) -> f64; }\ntrait Circle where Self: Shape { fn radius(&self) -> f64; }\n\nThis next example gives `radius` a default implementation using the `area`\nfunction from `Shape`.\n\n# trait Shape { fn area(&self) -> f64; }\ntrait Circle where Self: Shape {\n    fn radius(&self) -> f64 {\n        // A = pi * r^2\n        // so algebraically,\n        // r = sqrt(A / pi)\n        (self.area() / std::f64::consts::PI).sqrt()\n    }\n}\n\nThis next example calls a supertrait method on a generic parameter.\n\n# trait Shape { fn area(&self) -> f64; }\n# trait Circle: Shape { fn radius(&self) -> f64; }\nfn print_area_and_radius<C: Circle>(c: C) {\n    // Here we call the area method from the supertrait `Shape` of `Circle`.\n    println!(\"Area: {}\", c.area());\n    println!(\"Radius: {}\", c.radius());\n}\n\nSimilarly, here is an example of calling supertrait methods on trait objects.\n\n# trait Shape { fn area(&self) -> f64; }\n# trait Circle: Shape { fn radius(&self) -> f64; }\n# struct UnitCircle;\n# impl Shape for UnitCircle { fn area(&self) -> f64 { std::f64::consts::PI } }\n# impl Circle for UnitCircle { fn radius(&self) -> f64 { 1.0 } }\n# let circle = UnitCircle;\nlet circle = Box::new(circle) as Box<dyn Circle>;\nlet nonsense = circle.radius() * circle.area();"
      }
    },
    {
      "id": "items.traits.safety",
      "title": "Unsafe traits",
      "level": 1,
      "content": "Traits items that begin with the `unsafe` keyword indicate that *implementing* the\ntrait may be [unsafe]. It is safe to use a correctly implemented unsafe trait.\nThe [trait implementation] must also begin with the `unsafe` keyword.\n\n[`Sync`] and [`Send`] are examples of unsafe traits.",
      "parent_id": null,
      "paragraphs": {
        "items.traits.safety.intro": "Traits items that begin with the `unsafe` keyword indicate that *implementing* the\ntrait may be [unsafe]. It is safe to use a correctly implemented unsafe trait.\nThe [trait implementation] must also begin with the `unsafe` keyword.\n\n[`Sync`] and [`Send`] are examples of unsafe traits."
      }
    },
    {
      "id": "items.traits.params",
      "title": "Parameter patterns",
      "level": 2,
      "content": "Parameters in associated functions without a body only allow [IDENTIFIER] or `_` wild card patterns, as well as the form allowed by [SelfParam]. `mut` [IDENTIFIER] is currently allowed, but it is deprecated and will become a hard error in the future.\n<!-- https://github.com/rust-lang/rust/issues/35203 -->\n\ntrait T {\n    fn f1(&self);\n    fn f2(x: Self, _: i32);\n}\n\n,compile_fail,E0642\ntrait T {\n    fn f2(&x: &i32); // ERROR: patterns aren't allowed in functions without bodies\n}\n\nParameters in associated functions with a body only allow irrefutable patterns.\n\ntrait T {\n    fn f1((a, b): (i32, i32)) {} // OK: is irrefutable\n}\n\n,compile_fail,E0005\ntrait T {\n    fn f1(123: i32) {} // ERROR: pattern is refutable\n    fn f2(Some(x): Option<i32>) {} // ERROR: pattern is refutable\n}\n\n> [!EDITION-2018]\n> Prior to the 2018 edition, the pattern for an associated function parameter is optional:\n>\n> ```rust,edition2015\n> // 2015 Edition\n> trait T {\n>     fn f(i32); // OK: parameter identifiers are not required\n> }\n> ```\n>\n> Beginning in the 2018 edition, patterns are no longer optional.\n\n> [!EDITION-2018]\n> Prior to the 2018 edition, parameters in associated functions with a body are limited to the following kinds of patterns:\n>\n> * [IDENTIFIER]\n> * `mut` [IDENTIFIER]\n> * `_`\n> * `&` [IDENTIFIER]\n> * `&&` [IDENTIFIER]\n>\n> ```rust,edition2015,compile_fail,E0642\n> // 2015 Edition\n> trait T {\n>     fn f1((a, b): (i32, i32)) {} // ERROR: pattern not allowed\n> }\n> ```\n>\n> Beginning in 2018, all irrefutable patterns are allowed as described in [items.traits.params.patterns-with-body].",
      "parent_id": null,
      "paragraphs": {
        "items.traits.params.patterns-no-body": "Parameters in associated functions without a body only allow [IDENTIFIER] or `_` wild card patterns, as well as the form allowed by [SelfParam]. `mut` [IDENTIFIER] is currently allowed, but it is deprecated and will become a hard error in the future.\n<!-- https://github.com/rust-lang/rust/issues/35203 -->\n\ntrait T {\n    fn f1(&self);\n    fn f2(x: Self, _: i32);\n}\n\n,compile_fail,E0642\ntrait T {\n    fn f2(&x: &i32); // ERROR: patterns aren't allowed in functions without bodies\n}",
        "items.traits.params.patterns-with-body": "Parameters in associated functions with a body only allow irrefutable patterns.\n\ntrait T {\n    fn f1((a, b): (i32, i32)) {} // OK: is irrefutable\n}\n\n,compile_fail,E0005\ntrait T {\n    fn f1(123: i32) {} // ERROR: pattern is refutable\n    fn f2(Some(x): Option<i32>) {} // ERROR: pattern is refutable\n}",
        "items.traits.params.pattern-required.edition2018": "> [!EDITION-2018]\n> Prior to the 2018 edition, the pattern for an associated function parameter is optional:\n>\n> ```rust,edition2015\n> // 2015 Edition\n> trait T {\n>     fn f(i32); // OK: parameter identifiers are not required\n> }\n> ```\n>\n> Beginning in the 2018 edition, patterns are no longer optional.",
        "items.traits.params.restriction-patterns.edition2018": "> [!EDITION-2018]\n> Prior to the 2018 edition, parameters in associated functions with a body are limited to the following kinds of patterns:\n>\n> * [IDENTIFIER]\n> * `mut` [IDENTIFIER]\n> * `_`\n> * `&` [IDENTIFIER]\n> * `&&` [IDENTIFIER]\n>\n> ```rust,edition2015,compile_fail,E0642\n> // 2015 Edition\n> trait T {\n>     fn f1((a, b): (i32, i32)) {} // ERROR: pattern not allowed\n> }\n> ```\n>\n> Beginning in 2018, all irrefutable patterns are allowed as described in [items.traits.params.patterns-with-body]."
      }
    },
    {
      "id": "items.traits.associated-visibility",
      "title": "Item visibility",
      "level": 2,
      "content": "Trait items syntactically allow a [Visibility] annotation, but this is\nrejected when the trait is validated. This allows items to be parsed with a\nunified syntax across different contexts where they are used. As an example,\nan empty `vis` macro fragment specifier can be used for trait items, where the\nmacro rule may be used in other situations where visibility is allowed.\n\nmacro_rules! create_method {\n    ($vis:vis $name:ident) => {\n        $vis fn $name(&self) {}\n    };\n}\n\ntrait T1 {\n    // Empty `vis` is allowed.\n    create_method! { method_of_t1 }\n}\n\nstruct S;\n\nimpl S {\n    // Visibility is allowed here.\n    create_method! { pub method_of_s }\n}\n\nimpl T1 for S {}\n\nfn main() {\n    let s = S;\n    s.method_of_t1();\n    s.method_of_s();\n}\n\n[WildcardPattern]: ../patterns.md#wildcard-pattern\n[bounds]: ../trait-bounds.md\n[trait object]: ../types/trait-object.md\n[associated items]: associated-items.md\n[method]: associated-items.md#methods\n\n[implementations]: implementations.md\n[generics]: generics.md\n[where clauses]: generics.md#where-clauses\n[generic functions]: functions.md#generic-functions\n[unsafe]: ../unsafety.md\n[trait implementation]: implementations.md#trait-implementations\n[`Send`]: ../special-types-and-traits.md#send\n[`Sync`]: ../special-types-and-traits.md#sync\n[`Arc<Self>`]: ../special-types-and-traits.md#arct\n[`Box<Self>`]: ../special-types-and-traits.md#boxt\n[`Pin<P>`]: ../special-types-and-traits.md#pinp\n[`Rc<Self>`]: ../special-types-and-traits.md#rct\n[`async`]: functions.md#async-functions\n[`const`]: functions.md#const-functions\n[type namespace]: ../names/namespaces.md",
      "parent_id": null,
      "paragraphs": {
        "items.traits.associated-visibility.intro": "Trait items syntactically allow a [Visibility] annotation, but this is\nrejected when the trait is validated. This allows items to be parsed with a\nunified syntax across different contexts where they are used. As an example,\nan empty `vis` macro fragment specifier can be used for trait items, where the\nmacro rule may be used in other situations where visibility is allowed.\n\nmacro_rules! create_method {\n    ($vis:vis $name:ident) => {\n        $vis fn $name(&self) {}\n    };\n}\n\ntrait T1 {\n    // Empty `vis` is allowed.\n    create_method! { method_of_t1 }\n}\n\nstruct S;\n\nimpl S {\n    // Visibility is allowed here.\n    create_method! { pub method_of_s }\n}\n\nimpl T1 for S {}\n\nfn main() {\n    let s = S;\n    s.method_of_t1();\n    s.method_of_s();\n}\n\n[WildcardPattern]: ../patterns.md#wildcard-pattern\n[bounds]: ../trait-bounds.md\n[trait object]: ../types/trait-object.md\n[associated items]: associated-items.md\n[method]: associated-items.md#methods\n\n[implementations]: implementations.md\n[generics]: generics.md\n[where clauses]: generics.md#where-clauses\n[generic functions]: functions.md#generic-functions\n[unsafe]: ../unsafety.md\n[trait implementation]: implementations.md#trait-implementations\n[`Send`]: ../special-types-and-traits.md#send\n[`Sync`]: ../special-types-and-traits.md#sync\n[`Arc<Self>`]: ../special-types-and-traits.md#arct\n[`Box<Self>`]: ../special-types-and-traits.md#boxt\n[`Pin<P>`]: ../special-types-and-traits.md#pinp\n[`Rc<Self>`]: ../special-types-and-traits.md#rct\n[`async`]: functions.md#async-functions\n[`const`]: functions.md#const-functions\n[type namespace]: ../names/namespaces.md"
      }
    },
    {
      "id": "items.impl",
      "title": "Implementations",
      "level": 1,
      "content": ",items\nImplementation -> InherentImpl | TraitImpl\n\nInherentImpl ->\n    `impl` GenericParams? Type WhereClause? `{`\n        InnerAttribute*\n        AssociatedItem*\n    `}`\n\nTraitImpl ->\n    `unsafe`? `impl` GenericParams? `!`? TypePath `for` Type\n    WhereClause?\n    `{`\n        InnerAttribute*\n        AssociatedItem*\n    `}`\n\nAn _implementation_ is an item that associates items with an _implementing type_.\nImplementations are defined with the keyword `impl` and contain functions\nthat belong to an instance of the type that is being implemented or to the\ntype statically.\n\nThere are two types of implementations:\n\n- inherent implementations\n- [trait] implementations",
      "parent_id": null,
      "paragraphs": {
        "items.impl.syntax": ",items\nImplementation -> InherentImpl | TraitImpl\n\nInherentImpl ->\n    `impl` GenericParams? Type WhereClause? `{`\n        InnerAttribute*\n        AssociatedItem*\n    `}`\n\nTraitImpl ->\n    `unsafe`? `impl` GenericParams? `!`? TypePath `for` Type\n    WhereClause?\n    `{`\n        InnerAttribute*\n        AssociatedItem*\n    `}`",
        "items.impl.intro": "An _implementation_ is an item that associates items with an _implementing type_.\nImplementations are defined with the keyword `impl` and contain functions\nthat belong to an instance of the type that is being implemented or to the\ntype statically.",
        "items.impl.kinds": "There are two types of implementations:\n\n- inherent implementations\n- [trait] implementations"
      }
    },
    {
      "id": "items.impl.inherent",
      "title": "Inherent implementations",
      "level": 1,
      "content": "An inherent implementation is defined as the sequence of the `impl` keyword,\ngeneric type declarations, a path to a nominal type, a where clause, and a\nbracketed set of associable items.\n\nThe nominal type is called the _implementing type_ and the associable items are\nthe _associated items_ to the implementing type.\n\nInherent implementations associate the contained items to the\nimplementing type.\n\nInherent implementations can contain [associated functions] (including [methods]) and [associated constants].\n\nThey cannot contain associated type aliases.\n\nThe [path] to an associated item is any path to the implementing type,\nfollowed by the associated item's identifier as the final path\ncomponent.\n\nA type can also have multiple inherent implementations. An implementing type\nmust be defined within the same crate as the original type definition.\n\n rust\npub mod color {\n    pub struct Color(pub u8, pub u8, pub u8);\n\n    impl Color {\n        pub const WHITE: Color = Color(255, 255, 255);\n    }\n}\n\nmod values {\n    use super::color::Color;\n    impl Color {\n        pub fn red() -> Color {\n            Color(255, 0, 0)\n        }\n    }\n}\n\npub use self::color::Color;\nfn main() {\n    // Actual path to the implementing type and impl in the same module.\n    color::Color::WHITE;\n\n    // Impl blocks in different modules are still accessed through a path to the type.\n    color::Color::red();\n\n    // Re-exported paths to the implementing type also work.\n    Color::red();\n\n    // Does not work, because use in `values` is not pub.\n    // values::Color::red();\n}",
      "parent_id": null,
      "paragraphs": {
        "items.impl.inherent.intro": "An inherent implementation is defined as the sequence of the `impl` keyword,\ngeneric type declarations, a path to a nominal type, a where clause, and a\nbracketed set of associable items.",
        "items.impl.inherent.implementing-type": "The nominal type is called the _implementing type_ and the associable items are\nthe _associated items_ to the implementing type.",
        "items.impl.inherent.associated-items": "Inherent implementations associate the contained items to the\nimplementing type.",
        "items.impl.inherent.associated-items.allowed-items": "Inherent implementations can contain [associated functions] (including [methods]) and [associated constants].",
        "items.impl.inherent.type-alias": "They cannot contain associated type aliases.",
        "items.impl.inherent.associated-item-path": "The [path] to an associated item is any path to the implementing type,\nfollowed by the associated item's identifier as the final path\ncomponent.",
        "items.impl.inherent.coherence": "A type can also have multiple inherent implementations. An implementing type\nmust be defined within the same crate as the original type definition.\n\n rust\npub mod color {\n    pub struct Color(pub u8, pub u8, pub u8);\n\n    impl Color {\n        pub const WHITE: Color = Color(255, 255, 255);\n    }\n}\n\nmod values {\n    use super::color::Color;\n    impl Color {\n        pub fn red() -> Color {\n            Color(255, 0, 0)\n        }\n    }\n}\n\npub use self::color::Color;\nfn main() {\n    // Actual path to the implementing type and impl in the same module.\n    color::Color::WHITE;\n\n    // Impl blocks in different modules are still accessed through a path to the type.\n    color::Color::red();\n\n    // Re-exported paths to the implementing type also work.\n    Color::red();\n\n    // Does not work, because use in `values` is not pub.\n    // values::Color::red();\n}"
      }
    },
    {
      "id": "items.impl.trait",
      "title": "Trait implementations",
      "level": 2,
      "content": "A _trait implementation_ is defined like an inherent implementation except that\nthe optional generic type declarations are followed by a [trait], followed\nby the keyword `for`, followed by a path to a nominal type.\n\n<!-- To understand this, you have to back-reference to the previous section. :( -->\n\nThe trait is known as the _implemented trait_. The implementing type\nimplements the implemented trait.\n\nA trait implementation must define all non-default associated items declared\nby the implemented trait, may redefine default associated items defined by the\nimplemented trait, and cannot define any other items.\n\nThe path to the associated items is `<` followed by a path to the implementing\ntype followed by `as` followed by a path to the trait followed by `>` as a path\ncomponent followed by the associated item's path component.\n\n[Unsafe traits] require the trait implementation to begin with the `unsafe`\nkeyword.\n\n# #[derive(Copy, Clone)]\n# struct Point {x: f64, y: f64};\n# type Surface = i32;\n# struct BoundingBox {x: f64, y: f64, width: f64, height: f64};\n# trait Shape { fn draw(&self, s: Surface); fn bounding_box(&self) -> BoundingBox; }\n# fn do_draw_circle(s: Surface, c: Circle) { }\nstruct Circle {\n    radius: f64,\n    center: Point,\n}\n\nimpl Copy for Circle {}\n\nimpl Clone for Circle {\n    fn clone(&self) -> Circle { *self }\n}\n\nimpl Shape for Circle {\n    fn draw(&self, s: Surface) { do_draw_circle(s, *self); }\n    fn bounding_box(&self) -> BoundingBox {\n        let r = self.radius;\n        BoundingBox {\n            x: self.center.x - r,\n            y: self.center.y - r,\n            width: 2.0 * r,\n            height: 2.0 * r,\n        }\n    }\n}",
      "parent_id": null,
      "paragraphs": {
        "items.impl.trait.intro": "A _trait implementation_ is defined like an inherent implementation except that\nthe optional generic type declarations are followed by a [trait], followed\nby the keyword `for`, followed by a path to a nominal type.\n\n<!-- To understand this, you have to back-reference to the previous section. :( -->",
        "items.impl.trait.implemented-trait": "The trait is known as the _implemented trait_. The implementing type\nimplements the implemented trait.",
        "items.impl.trait.def-requirement": "A trait implementation must define all non-default associated items declared\nby the implemented trait, may redefine default associated items defined by the\nimplemented trait, and cannot define any other items.",
        "items.impl.trait.associated-item-path": "The path to the associated items is `<` followed by a path to the implementing\ntype followed by `as` followed by a path to the trait followed by `>` as a path\ncomponent followed by the associated item's path component.",
        "items.impl.trait.safety": "[Unsafe traits] require the trait implementation to begin with the `unsafe`\nkeyword.\n\n# #[derive(Copy, Clone)]\n# struct Point {x: f64, y: f64};\n# type Surface = i32;\n# struct BoundingBox {x: f64, y: f64, width: f64, height: f64};\n# trait Shape { fn draw(&self, s: Surface); fn bounding_box(&self) -> BoundingBox; }\n# fn do_draw_circle(s: Surface, c: Circle) { }\nstruct Circle {\n    radius: f64,\n    center: Point,\n}\n\nimpl Copy for Circle {}\n\nimpl Clone for Circle {\n    fn clone(&self) -> Circle { *self }\n}\n\nimpl Shape for Circle {\n    fn draw(&self, s: Surface) { do_draw_circle(s, *self); }\n    fn bounding_box(&self) -> BoundingBox {\n        let r = self.radius;\n        BoundingBox {\n            x: self.center.x - r,\n            y: self.center.y - r,\n            width: 2.0 * r,\n            height: 2.0 * r,\n        }\n    }\n}"
      }
    },
    {
      "id": "items.impl.trait.coherence",
      "title": "Trait implementation coherence",
      "level": 1,
      "content": "A trait implementation is considered incoherent if either the orphan rules check fails\nor there are overlapping implementation instances.\n\nTwo trait implementations overlap when there is a non-empty intersection of the\ntraits the implementation is for, the implementations can be instantiated with\nthe same type. <!-- This is probably wrong? Source: No two implementations can\nbe instantiable with the same set of types for the input type parameters. -->",
      "parent_id": null,
      "paragraphs": {
        "items.impl.trait.coherence.intro": "A trait implementation is considered incoherent if either the orphan rules check fails\nor there are overlapping implementation instances.",
        "items.impl.trait.coherence.overlapping": "Two trait implementations overlap when there is a non-empty intersection of the\ntraits the implementation is for, the implementations can be instantiated with\nthe same type. <!-- This is probably wrong? Source: No two implementations can\nbe instantiable with the same set of types for the input type parameters. -->"
      }
    },
    {
      "id": "items.impl.trait.orphan-rule",
      "title": "Orphan rules",
      "level": 3,
      "content": "The *orphan rule* states that a trait implementation is only allowed if either the trait or at least one of the types in the implementation is defined in the current crate. It prevents conflicting trait implementations across different crates and is key to ensuring coherence.\n\nAn orphan implementation is one that implements a foreign trait for a foreign type. If these were freely allowed, two crates could implement the same trait for the same type in incompatible ways, creating a situation where adding or updating a dependency could break compilation due to conflicting implementations.\n\nThe orphan rule enables library authors to add new implementations to their traits without fear that they'll break downstream code. Without these restrictions, a library couldn't add an implementation like `impl<T: Display> MyTrait for T` without potentially conflicting with downstream implementations.\n\nGiven `impl<P1..=Pn> Trait<T1..=Tn> for T0`, an `impl` is valid only if at\nleast one of the following is true:\n\n- `Trait` is a [local trait]\n- All of\n  - At least one of the types `T0..=Tn` must be a [local type]. Let `Ti` be the\n    first such type.\n  - No [uncovered type] parameters `P1..=Pn` may appear in `T0..Ti` (excluding\n    `Ti`)\n\nOnly the appearance of *uncovered* type parameters is restricted.\n\nNote that for the purposes of coherence, [fundamental types] are\nspecial. The `T` in `Box<T>` is not considered covered, and `Box<LocalType>`\nis considered local.",
      "parent_id": null,
      "paragraphs": {
        "items.impl.trait.orphan-rule.intro": "The *orphan rule* states that a trait implementation is only allowed if either the trait or at least one of the types in the implementation is defined in the current crate. It prevents conflicting trait implementations across different crates and is key to ensuring coherence.\n\nAn orphan implementation is one that implements a foreign trait for a foreign type. If these were freely allowed, two crates could implement the same trait for the same type in incompatible ways, creating a situation where adding or updating a dependency could break compilation due to conflicting implementations.\n\nThe orphan rule enables library authors to add new implementations to their traits without fear that they'll break downstream code. Without these restrictions, a library couldn't add an implementation like `impl<T: Display> MyTrait for T` without potentially conflicting with downstream implementations.",
        "items.impl.trait.orphan-rule.general": "Given `impl<P1..=Pn> Trait<T1..=Tn> for T0`, an `impl` is valid only if at\nleast one of the following is true:\n\n- `Trait` is a [local trait]\n- All of\n  - At least one of the types `T0..=Tn` must be a [local type]. Let `Ti` be the\n    first such type.\n  - No [uncovered type] parameters `P1..=Pn` may appear in `T0..Ti` (excluding\n    `Ti`)",
        "items.impl.trait.uncovered-param": "Only the appearance of *uncovered* type parameters is restricted.",
        "items.impl.trait.fundamental": "Note that for the purposes of coherence, [fundamental types] are\nspecial. The `T` in `Box<T>` is not considered covered, and `Box<LocalType>`\nis considered local."
      }
    },
    {
      "id": "items.impl.generics",
      "title": "Generic implementations",
      "level": 4,
      "content": "An implementation can take [generic parameters], which can be used in the rest\nof the implementation. Implementation parameters are written directly after the\n`impl` keyword.\n\n# trait Seq<T> { fn dummy(&self, _: T) { } }\nimpl<T> Seq<T> for Vec<T> {\n    /* ... */\n}\nimpl Seq<bool> for u32 {\n    /* Treat the integer as a sequence of bits */\n}\n\nGeneric parameters *constrain* an implementation if the parameter appears at\nleast once in one of:\n\n* The implemented trait, if it has one\n* The implementing type\n* As an [associated type] in the [bounds] of a type that contains another\n  parameter that constrains the implementation\n\nType and const parameters must always constrain the implementation. Lifetimes\nmust constrain the implementation if the lifetime is used in an associated type.\n\nExamples of constraining situations:\n\n# trait Trait{}\n# trait GenericTrait<T> {}\n# trait HasAssocType { type Ty; }\n# struct Struct;\n# struct GenericStruct<T>(T);\n# struct ConstGenericStruct<const N: usize>([(); N]);\n// T constrains by being an argument to GenericTrait.\nimpl<T> GenericTrait<T> for i32 { /* ... */ }\n\n// T constrains by being an argument to GenericStruct\nimpl<T> Trait for GenericStruct<T> { /* ... */ }\n\n// Likewise, N constrains by being an argument to ConstGenericStruct\nimpl<const N: usize> Trait for ConstGenericStruct<N> { /* ... */ }\n\n// T constrains by being in an associated type in a bound for type `U` which is\n// itself a generic parameter constraining the trait.\nimpl<T, U> GenericTrait<U> for u32 where U: HasAssocType<Ty = T> { /* ... */ }\n\n// Like previous, except the type is `(U, isize)`. `U` appears inside the type\n// that includes `T`, and is not the type itself.\nimpl<T, U> GenericStruct<U> where (U, isize): HasAssocType<Ty = T> { /* ... */ }\n\nExamples of non-constraining situations:\n\n,compile_fail\n// The rest of these are errors, since they have type or const parameters that\n// do not constrain.\n\n// T does not constrain since it does not appear at all.\nimpl<T> Struct { /* ... */ }\n\n// N does not constrain for the same reason.\nimpl<const N: usize> Struct { /* ... */ }\n\n// Usage of T inside the implementation does not constrain the impl.\nimpl<T> Struct {\n    fn uses_t(t: &T) { /* ... */ }\n}\n\n// T is used as an associated type in the bounds for U, but U does not constrain.\nimpl<T, U> Struct where U: HasAssocType<Ty = T> { /* ... */ }\n\n// T is used in the bounds, but not as an associated type, so it does not constrain.\nimpl<T, U> GenericTrait<U> for u32 where U: GenericTrait<T> {}\n\nExample of an allowed unconstraining lifetime parameter:\n\n# struct Struct;\nimpl<'a> Struct {}\n\nExample of a disallowed unconstraining lifetime parameter:\n\n,compile_fail\n# struct Struct;\n# trait HasAssocType { type Ty; }\nimpl<'a> HasAssocType for Struct {\n    type Ty = &'a Struct;\n}",
      "parent_id": null,
      "paragraphs": {
        "items.impl.generics.intro": "An implementation can take [generic parameters], which can be used in the rest\nof the implementation. Implementation parameters are written directly after the\n`impl` keyword.\n\n# trait Seq<T> { fn dummy(&self, _: T) { } }\nimpl<T> Seq<T> for Vec<T> {\n    /* ... */\n}\nimpl Seq<bool> for u32 {\n    /* Treat the integer as a sequence of bits */\n}",
        "items.impl.generics.usage": "Generic parameters *constrain* an implementation if the parameter appears at\nleast once in one of:\n\n* The implemented trait, if it has one\n* The implementing type\n* As an [associated type] in the [bounds] of a type that contains another\n  parameter that constrains the implementation",
        "items.impl.generics.constrain": "Type and const parameters must always constrain the implementation. Lifetimes\nmust constrain the implementation if the lifetime is used in an associated type.\n\nExamples of constraining situations:\n\n# trait Trait{}\n# trait GenericTrait<T> {}\n# trait HasAssocType { type Ty; }\n# struct Struct;\n# struct GenericStruct<T>(T);\n# struct ConstGenericStruct<const N: usize>([(); N]);\n// T constrains by being an argument to GenericTrait.\nimpl<T> GenericTrait<T> for i32 { /* ... */ }\n\n// T constrains by being an argument to GenericStruct\nimpl<T> Trait for GenericStruct<T> { /* ... */ }\n\n// Likewise, N constrains by being an argument to ConstGenericStruct\nimpl<const N: usize> Trait for ConstGenericStruct<N> { /* ... */ }\n\n// T constrains by being in an associated type in a bound for type `U` which is\n// itself a generic parameter constraining the trait.\nimpl<T, U> GenericTrait<U> for u32 where U: HasAssocType<Ty = T> { /* ... */ }\n\n// Like previous, except the type is `(U, isize)`. `U` appears inside the type\n// that includes `T`, and is not the type itself.\nimpl<T, U> GenericStruct<U> where (U, isize): HasAssocType<Ty = T> { /* ... */ }\n\nExamples of non-constraining situations:\n\n,compile_fail\n// The rest of these are errors, since they have type or const parameters that\n// do not constrain.\n\n// T does not constrain since it does not appear at all.\nimpl<T> Struct { /* ... */ }\n\n// N does not constrain for the same reason.\nimpl<const N: usize> Struct { /* ... */ }\n\n// Usage of T inside the implementation does not constrain the impl.\nimpl<T> Struct {\n    fn uses_t(t: &T) { /* ... */ }\n}\n\n// T is used as an associated type in the bounds for U, but U does not constrain.\nimpl<T, U> Struct where U: HasAssocType<Ty = T> { /* ... */ }\n\n// T is used in the bounds, but not as an associated type, so it does not constrain.\nimpl<T, U> GenericTrait<U> for u32 where U: GenericTrait<T> {}\n\nExample of an allowed unconstraining lifetime parameter:\n\n# struct Struct;\nimpl<'a> Struct {}\n\nExample of a disallowed unconstraining lifetime parameter:\n\n,compile_fail\n# struct Struct;\n# trait HasAssocType { type Ty; }\nimpl<'a> HasAssocType for Struct {\n    type Ty = &'a Struct;\n}"
      }
    },
    {
      "id": "items.impl.attributes",
      "title": "Attributes on implementations",
      "level": 1,
      "content": "Implementations may contain outer [attributes] before the `impl` keyword and\ninner [attributes] inside the brackets that contain the associated items. Inner\nattributes must come before any associated items. The attributes that have\nmeaning here are [`cfg`], [`deprecated`], [`doc`], and [the lint check\nattributes].\n\n[trait]: traits.md\n[associated constants]: associated-items.md#associated-constants\n[associated functions]: associated-items.md#associated-functions-and-methods\n[associated type]: associated-items.md#associated-types\n[attributes]: ../attributes.md\n[bounds]: ../trait-bounds.md\n[`cfg`]: ../conditional-compilation.md\n[`deprecated`]: ../attributes/diagnostics.md#the-deprecated-attribute\n[`doc`]: ../../rustdoc/the-doc-attribute.html\n[generic parameters]: generics.md\n[methods]: associated-items.md#methods\n[path]: ../paths.md\n[the lint check attributes]: ../attributes/diagnostics.md#lint-check-attributes\n[Unsafe traits]: traits.md#unsafe-traits\n[local trait]: ../glossary.md#local-trait\n[local type]: ../glossary.md#local-type\n[fundamental types]: ../glossary.md#fundamental-type-constructors\n[uncovered type]: ../glossary.md#uncovered-type",
      "parent_id": null,
      "paragraphs": {
        "items.impl.attributes": "Implementations may contain outer [attributes] before the `impl` keyword and\ninner [attributes] inside the brackets that contain the associated items. Inner\nattributes must come before any associated items. The attributes that have\nmeaning here are [`cfg`], [`deprecated`], [`doc`], and [the lint check\nattributes].\n\n[trait]: traits.md\n[associated constants]: associated-items.md#associated-constants\n[associated functions]: associated-items.md#associated-functions-and-methods\n[associated type]: associated-items.md#associated-types\n[attributes]: ../attributes.md\n[bounds]: ../trait-bounds.md\n[`cfg`]: ../conditional-compilation.md\n[`deprecated`]: ../attributes/diagnostics.md#the-deprecated-attribute\n[`doc`]: ../../rustdoc/the-doc-attribute.html\n[generic parameters]: generics.md\n[methods]: associated-items.md#methods\n[path]: ../paths.md\n[the lint check attributes]: ../attributes/diagnostics.md#lint-check-attributes\n[Unsafe traits]: traits.md#unsafe-traits\n[local trait]: ../glossary.md#local-trait\n[local type]: ../glossary.md#local-type\n[fundamental types]: ../glossary.md#fundamental-type-constructors\n[uncovered type]: ../glossary.md#uncovered-type"
      }
    },
    {
      "id": "items.extern",
      "title": "External blocks",
      "level": 1,
      "content": ",items\nExternBlock ->\n    `unsafe`?[^unsafe-2024] `extern` Abi? `{`\n        InnerAttribute*\n        ExternalItem*\n    `}`\n\nExternalItem ->\n    OuterAttribute* (\n        MacroInvocationSemi\n      | Visibility? StaticItem\n      | Visibility? Function\n    )\n\n[^unsafe-2024]: Starting with the 2024 Edition, the `unsafe` keyword is required semantically.\n\nExternal blocks provide _declarations_ of items that are not _defined_ in the\ncurrent crate and are the basis of Rust's foreign function interface. These are\nakin to unchecked imports.\n\nTwo kinds of item _declarations_ are allowed in external blocks: [functions] and\n[statics].\n\nCalling unsafe functions or accessing unsafe statics that are declared in external blocks is only allowed in an [`unsafe` context].\n\nThe external block defines its functions and statics in the [value namespace] of the module or block where it is located.\n\nThe `unsafe` keyword is semantically required to appear before the `extern` keyword on external blocks.\n\n> [!EDITION-2024]\n> Prior to the 2024 edition, the `unsafe` keyword is optional. The `safe` and `unsafe` item qualifiers are only allowed if the external block itself is marked as `unsafe`.",
      "parent_id": null,
      "paragraphs": {
        "items.extern.syntax": ",items\nExternBlock ->\n    `unsafe`?[^unsafe-2024] `extern` Abi? `{`\n        InnerAttribute*\n        ExternalItem*\n    `}`\n\nExternalItem ->\n    OuterAttribute* (\n        MacroInvocationSemi\n      | Visibility? StaticItem\n      | Visibility? Function\n    )\n\n[^unsafe-2024]: Starting with the 2024 Edition, the `unsafe` keyword is required semantically.",
        "items.extern.intro": "External blocks provide _declarations_ of items that are not _defined_ in the\ncurrent crate and are the basis of Rust's foreign function interface. These are\nakin to unchecked imports.",
        "items.extern.allowed-kinds": "Two kinds of item _declarations_ are allowed in external blocks: [functions] and\n[statics].",
        "items.extern.safety": "Calling unsafe functions or accessing unsafe statics that are declared in external blocks is only allowed in an [`unsafe` context].",
        "items.extern.namespace": "The external block defines its functions and statics in the [value namespace] of the module or block where it is located.",
        "items.extern.unsafe-required": "The `unsafe` keyword is semantically required to appear before the `extern` keyword on external blocks.",
        "items.extern.edition2024": "> [!EDITION-2024]\n> Prior to the 2024 edition, the `unsafe` keyword is optional. The `safe` and `unsafe` item qualifiers are only allowed if the external block itself is marked as `unsafe`."
      }
    },
    {
      "id": "items.extern.fn",
      "title": "Functions",
      "level": 1,
      "content": "Functions within external blocks are declared in the same way as other Rust\nfunctions, with the exception that they must not have a body and are instead\nterminated by a semicolon.\n\nPatterns are not allowed in parameters, only [IDENTIFIER] or `_` may be used.\n\nThe `safe` and `unsafe` function qualifiers are\nallowed, but other function qualifiers (e.g. `const`, `async`, `extern`) are\nnot.\n\nFunctions within external blocks may be called by Rust code, just like\nfunctions defined in Rust. The Rust compiler automatically translates between\nthe Rust ABI and the foreign ABI.\n\nA function declared in an extern block is implicitly `unsafe` unless the `safe`\nfunction qualifier is present.\n\nWhen coerced to a function pointer, a function declared in an extern block has\ntype `extern \"abi\" for<'l1, ..., 'lm> fn(A1, ..., An) -> R`, where `'l1`,\n... `'lm` are its lifetime parameters, `A1`, ..., `An` are the declared types of\nits parameters, and `R` is the declared return type.",
      "parent_id": null,
      "paragraphs": {
        "items.extern.fn.body": "Functions within external blocks are declared in the same way as other Rust\nfunctions, with the exception that they must not have a body and are instead\nterminated by a semicolon.",
        "items.extern.fn.param-patterns": "Patterns are not allowed in parameters, only [IDENTIFIER] or `_` may be used.",
        "items.extern.fn.qualifiers": "The `safe` and `unsafe` function qualifiers are\nallowed, but other function qualifiers (e.g. `const`, `async`, `extern`) are\nnot.",
        "items.extern.fn.foreign-abi": "Functions within external blocks may be called by Rust code, just like\nfunctions defined in Rust. The Rust compiler automatically translates between\nthe Rust ABI and the foreign ABI.",
        "items.extern.fn.safety": "A function declared in an extern block is implicitly `unsafe` unless the `safe`\nfunction qualifier is present.",
        "items.extern.fn.fn-ptr": "When coerced to a function pointer, a function declared in an extern block has\ntype `extern \"abi\" for<'l1, ..., 'lm> fn(A1, ..., An) -> R`, where `'l1`,\n... `'lm` are its lifetime parameters, `A1`, ..., `An` are the declared types of\nits parameters, and `R` is the declared return type."
      }
    },
    {
      "id": "items.extern.static",
      "title": "Statics",
      "level": 2,
      "content": "Statics within external blocks are declared in the same way as [statics] outside of external blocks,\nexcept that they do not have an expression initializing their value.\n\nUnless a static item declared in an extern block is qualified as `safe`, it is `unsafe` to access that item, whether or\nnot it's mutable, because there is nothing guaranteeing that the bit pattern at the static's\nmemory is valid for the type it is declared with, since some arbitrary (e.g. C) code is in charge\nof initializing the static.\n\nExtern statics can be either immutable or mutable just like [statics] outside of external blocks.\n\nAn immutable static *must* be initialized before any Rust code is executed. It is not enough for\nthe static to be initialized before Rust code reads from it.\nOnce Rust code runs, mutating an immutable static (from inside or outside Rust) is UB,\nexcept if the mutation happens to bytes inside of an `UnsafeCell`.",
      "parent_id": null,
      "paragraphs": {
        "items.extern.static.intro": "Statics within external blocks are declared in the same way as [statics] outside of external blocks,\nexcept that they do not have an expression initializing their value.",
        "items.extern.static.safety": "Unless a static item declared in an extern block is qualified as `safe`, it is `unsafe` to access that item, whether or\nnot it's mutable, because there is nothing guaranteeing that the bit pattern at the static's\nmemory is valid for the type it is declared with, since some arbitrary (e.g. C) code is in charge\nof initializing the static.",
        "items.extern.static.mut": "Extern statics can be either immutable or mutable just like [statics] outside of external blocks.",
        "items.extern.static.read-only": "An immutable static *must* be initialized before any Rust code is executed. It is not enough for\nthe static to be initialized before Rust code reads from it.\nOnce Rust code runs, mutating an immutable static (from inside or outside Rust) is UB,\nexcept if the mutation happens to bytes inside of an `UnsafeCell`."
      }
    },
    {
      "id": "items.extern.abi",
      "title": "ABI",
      "level": 2,
      "content": "The `extern` keyword can be followed by an optional [ABI] string. The ABI specifies the calling convention of the functions in the block. The calling convention defines a low-level interface for functions, such as how arguments are placed in registers or on the stack, how return values are passed, and who is responsible for cleaning up the stack.\n\n> [!EXAMPLE]\n> ```rust\n> // Interface to the Windows API.\n> unsafe extern \"system\" { /* ... */ }\n> ```\n\nIf the ABI string is not specified, it defaults to `\"C\"`.\n\n> [!NOTE]\n> The `extern` syntax without an explicit ABI is being phased out, so it's better to always write the ABI explicitly.\n>\n> For more details, see Rust issue #134986.\n\nThe following ABI strings are supported on all platforms:\n\n* `unsafe extern \"Rust\"` --- The native calling convention for Rust functions and closures. This is the default when a function is declared without using [`extern fn`]. The Rust ABI offers no stability guarantees.\n\n* `unsafe extern \"C\"` --- The \"C\" ABI matches the default ABI chosen by the dominant C compiler for the target.\n\n* `unsafe extern \"system\"` --- This is equivalent to `extern \"C\"` except on Windows x86_32 where it is equivalent to `\"stdcall\"` for non-variadic functions, and equivalent to `\"C\"` for variadic functions.\n\n  > [!NOTE]\n  > As the correct underlying ABI on Windows is target-specific, it's best to use `extern \"system\"` when attempting to link Windows API functions that don't use an explicitly defined ABI.\n\n* `extern \"C-unwind\"` and `extern \"system-unwind\"` --- Identical to `\"C\"` and `\"system\"`, respectively, but with different behavior when the callee unwinds (by panicking or throwing a C++ style exception).\n\nThere are also some platform-specific ABI strings:\n\n* `unsafe extern \"cdecl\"` --- The calling convention typically used with x86_32 C code.\n  * Only available on x86_32 targets.\n  * Corresponds to MSVC's `__cdecl` and GCC and clang's `__attribute__((cdecl))`.\n\n  > [!NOTE]\n  > For details, see:\n  >\n  > - <https://learn.microsoft.com/en-us/cpp/cpp/cdecl>\n  > - <https://en.wikipedia.org/wiki/X86_calling_conventions#cdecl>\n\n* `unsafe extern \"stdcall\"` --- The calling convention typically used by the [Win32 API] on x86_32.\n  * Only available on x86_32 targets.\n  * Corresponds to MSVC's `__stdcall` and GCC and clang's `__attribute__((stdcall))`.\n\n  > [!NOTE]\n  > For details, see:\n  >\n  > - <https://learn.microsoft.com/en-us/cpp/cpp/stdcall>\n  > - <https://en.wikipedia.org/wiki/X86_calling_conventions#stdcall>\n\n* `unsafe extern \"win64\"` --- The Windows x64 ABI.\n  * Only available on x86_64 targets.\n  * \"win64\" is the same as the \"C\" ABI on Windows x86_64 targets.\n  * Corresponds to GCC and clang's `__attribute__((ms_abi))`.\n\n  > [!NOTE]\n  > For details, see:\n  >\n  > - <https://learn.microsoft.com/en-us/cpp/build/x64-software-conventions>\n  > - <https://en.wikipedia.org/wiki/X86_calling_conventions#Microsoft_x64_calling_convention>\n\n* `unsafe extern \"sysv64\"` --- The System V ABI.\n  * Only available on x86_64 targets.\n  * \"sysv64\" is the same as the \"C\" ABI on non-Windows x86_64 targets.\n  * Corresponds to GCC and clang's `__attribute__((sysv_abi))`.\n\n  > [!NOTE]\n  > For details, see:\n  >\n  > - <https://wiki.osdev.org/System_V_ABI>\n  > - <https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI>\n\n* `unsafe extern \"aapcs\"` --- The soft-float ABI for ARM.\n  * Only available on ARM32 targets.\n  * \"aapcs\" is the same as the \"C\" ABI on soft-float ARM32.\n  * Corresponds to clang's `__attribute__((pcs(\"aapcs\")))`.\n\n  > [!NOTE]\n  > For details, see:\n  >\n  > - Arm Procedure Call Standard\n\n* `unsafe extern \"fastcall\"` --- A \"fast\" variant of stdcall that passes some arguments in registers.\n  * Only available on x86_32 targets.\n  * Corresponds to MSVC's `__fastcall` and GCC and clang's `__attribute__((fastcall))`.\n\n  > [!NOTE]\n  > For details, see:\n  >\n  > - <https://learn.microsoft.com/en-us/cpp/cpp/fastcall>\n  > - <https://en.wikipedia.org/wiki/X86_calling_conventions#Microsoft_fastcall>\n\n* `unsafe extern \"thiscall\"` --- The calling convention typically used on C++ class member functions on x86_32 MSVC.\n  * Only available on x86_32 targets.\n  * Corresponds to MSVC's `__thiscall` and GCC and clang's `__attribute__((thiscall))`.\n\n  > [!NOTE]\n  > For details, see:\n  >\n  > - <https://en.wikipedia.org/wiki/X86_calling_conventions#thiscall>\n  > - <https://learn.microsoft.com/en-us/cpp/cpp/thiscall>\n\n* `unsafe extern \"efiapi\"` --- The ABI used for [UEFI] functions.\n  * Only available on x86 and ARM targets (32bit and 64bit).\n\nLike `\"C\"` and `\"system\"`, most platform-specific ABI strings also have a corresponding `-unwind` variant; specifically, these are:\n\n* `\"aapcs-unwind\"`\n* `\"cdecl-unwind\"`\n* `\"fastcall-unwind\"`\n* `\"stdcall-unwind\"`\n* `\"sysv64-unwind\"`\n* `\"thiscall-unwind\"`\n* `\"win64-unwind\"`",
      "parent_id": null,
      "paragraphs": {
        "items.extern.abi.intro": "The `extern` keyword can be followed by an optional [ABI] string. The ABI specifies the calling convention of the functions in the block. The calling convention defines a low-level interface for functions, such as how arguments are placed in registers or on the stack, how return values are passed, and who is responsible for cleaning up the stack.\n\n> [!EXAMPLE]\n> ```rust\n> // Interface to the Windows API.\n> unsafe extern \"system\" { /* ... */ }\n> ```",
        "items.extern.abi.default": "If the ABI string is not specified, it defaults to `\"C\"`.\n\n> [!NOTE]\n> The `extern` syntax without an explicit ABI is being phased out, so it's better to always write the ABI explicitly.\n>\n> For more details, see Rust issue #134986.",
        "items.extern.abi.standard": "The following ABI strings are supported on all platforms:",
        "items.extern.abi.rust": "* `unsafe extern \"Rust\"` --- The native calling convention for Rust functions and closures. This is the default when a function is declared without using [`extern fn`]. The Rust ABI offers no stability guarantees.",
        "items.extern.abi.c": "* `unsafe extern \"C\"` --- The \"C\" ABI matches the default ABI chosen by the dominant C compiler for the target.",
        "items.extern.abi.system": "* `unsafe extern \"system\"` --- This is equivalent to `extern \"C\"` except on Windows x86_32 where it is equivalent to `\"stdcall\"` for non-variadic functions, and equivalent to `\"C\"` for variadic functions.\n\n  > [!NOTE]\n  > As the correct underlying ABI on Windows is target-specific, it's best to use `extern \"system\"` when attempting to link Windows API functions that don't use an explicitly defined ABI.",
        "items.extern.abi.unwind": "* `extern \"C-unwind\"` and `extern \"system-unwind\"` --- Identical to `\"C\"` and `\"system\"`, respectively, but with different behavior when the callee unwinds (by panicking or throwing a C++ style exception).",
        "items.extern.abi.platform": "There are also some platform-specific ABI strings:",
        "items.extern.abi.cdecl": "* `unsafe extern \"cdecl\"` --- The calling convention typically used with x86_32 C code.\n  * Only available on x86_32 targets.\n  * Corresponds to MSVC's `__cdecl` and GCC and clang's `__attribute__((cdecl))`.\n\n  > [!NOTE]\n  > For details, see:\n  >\n  > - <https://learn.microsoft.com/en-us/cpp/cpp/cdecl>\n  > - <https://en.wikipedia.org/wiki/X86_calling_conventions#cdecl>",
        "items.extern.abi.stdcall": "* `unsafe extern \"stdcall\"` --- The calling convention typically used by the [Win32 API] on x86_32.\n  * Only available on x86_32 targets.\n  * Corresponds to MSVC's `__stdcall` and GCC and clang's `__attribute__((stdcall))`.\n\n  > [!NOTE]\n  > For details, see:\n  >\n  > - <https://learn.microsoft.com/en-us/cpp/cpp/stdcall>\n  > - <https://en.wikipedia.org/wiki/X86_calling_conventions#stdcall>",
        "items.extern.abi.win64": "* `unsafe extern \"win64\"` --- The Windows x64 ABI.\n  * Only available on x86_64 targets.\n  * \"win64\" is the same as the \"C\" ABI on Windows x86_64 targets.\n  * Corresponds to GCC and clang's `__attribute__((ms_abi))`.\n\n  > [!NOTE]\n  > For details, see:\n  >\n  > - <https://learn.microsoft.com/en-us/cpp/build/x64-software-conventions>\n  > - <https://en.wikipedia.org/wiki/X86_calling_conventions#Microsoft_x64_calling_convention>",
        "items.extern.abi.sysv64": "* `unsafe extern \"sysv64\"` --- The System V ABI.\n  * Only available on x86_64 targets.\n  * \"sysv64\" is the same as the \"C\" ABI on non-Windows x86_64 targets.\n  * Corresponds to GCC and clang's `__attribute__((sysv_abi))`.\n\n  > [!NOTE]\n  > For details, see:\n  >\n  > - <https://wiki.osdev.org/System_V_ABI>\n  > - <https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI>",
        "items.extern.abi.aapcs": "* `unsafe extern \"aapcs\"` --- The soft-float ABI for ARM.\n  * Only available on ARM32 targets.\n  * \"aapcs\" is the same as the \"C\" ABI on soft-float ARM32.\n  * Corresponds to clang's `__attribute__((pcs(\"aapcs\")))`.\n\n  > [!NOTE]\n  > For details, see:\n  >\n  > - Arm Procedure Call Standard",
        "items.extern.abi.fastcall": "* `unsafe extern \"fastcall\"` --- A \"fast\" variant of stdcall that passes some arguments in registers.\n  * Only available on x86_32 targets.\n  * Corresponds to MSVC's `__fastcall` and GCC and clang's `__attribute__((fastcall))`.\n\n  > [!NOTE]\n  > For details, see:\n  >\n  > - <https://learn.microsoft.com/en-us/cpp/cpp/fastcall>\n  > - <https://en.wikipedia.org/wiki/X86_calling_conventions#Microsoft_fastcall>",
        "items.extern.abi.thiscall": "* `unsafe extern \"thiscall\"` --- The calling convention typically used on C++ class member functions on x86_32 MSVC.\n  * Only available on x86_32 targets.\n  * Corresponds to MSVC's `__thiscall` and GCC and clang's `__attribute__((thiscall))`.\n\n  > [!NOTE]\n  > For details, see:\n  >\n  > - <https://en.wikipedia.org/wiki/X86_calling_conventions#thiscall>\n  > - <https://learn.microsoft.com/en-us/cpp/cpp/thiscall>",
        "items.extern.abi.efiapi": "* `unsafe extern \"efiapi\"` --- The ABI used for [UEFI] functions.\n  * Only available on x86 and ARM targets (32bit and 64bit).",
        "items.extern.abi.platform-unwind-variants": "Like `\"C\"` and `\"system\"`, most platform-specific ABI strings also have a corresponding `-unwind` variant; specifically, these are:\n\n* `\"aapcs-unwind\"`\n* `\"cdecl-unwind\"`\n* `\"fastcall-unwind\"`\n* `\"stdcall-unwind\"`\n* `\"sysv64-unwind\"`\n* `\"thiscall-unwind\"`\n* `\"win64-unwind\"`"
      }
    },
    {
      "id": "items.extern.variadic",
      "title": "Variadic functions",
      "level": 2,
      "content": "Functions within external blocks may be variadic by specifying `...` as the\nlast argument. The variadic parameter may optionally be specified with an\nidentifier.\n\nunsafe extern \"C\" {\n    unsafe fn foo(...);\n    unsafe fn bar(x: i32, ...);\n    unsafe fn with_name(format: *const u8, args: ...);\n    // SAFETY: This function guarantees it will not access\n    // variadic arguments.\n    safe fn ignores_variadic_arguments(x: i32, ...);\n}\n\n> [!WARNING]\n> The `safe` qualifier should not be used on a function in an `extern` block unless that function guarantees that it will not access the variadic arguments at all. Passing an unexpected number of arguments or arguments of unexpected type to a variadic function may lead to undefined behavior.\n\nVariadic parameters can only be specified within `extern` blocks with the following ABI strings or their corresponding `-unwind` variants:\n\n- `\"aapcs\"`\n- `\"C\"`\n- `\"cdecl\"`\n- `\"efiapi\"`\n- `\"system\"`\n- `\"sysv64\"`\n- `\"win64\"`",
      "parent_id": null,
      "paragraphs": {
        "items.extern.variadic": "Functions within external blocks may be variadic by specifying `...` as the\nlast argument. The variadic parameter may optionally be specified with an\nidentifier.\n\nunsafe extern \"C\" {\n    unsafe fn foo(...);\n    unsafe fn bar(x: i32, ...);\n    unsafe fn with_name(format: *const u8, args: ...);\n    // SAFETY: This function guarantees it will not access\n    // variadic arguments.\n    safe fn ignores_variadic_arguments(x: i32, ...);\n}\n\n> [!WARNING]\n> The `safe` qualifier should not be used on a function in an `extern` block unless that function guarantees that it will not access the variadic arguments at all. Passing an unexpected number of arguments or arguments of unexpected type to a variadic function may lead to undefined behavior.",
        "items.extern.variadic.conventions": "Variadic parameters can only be specified within `extern` blocks with the following ABI strings or their corresponding `-unwind` variants:\n\n- `\"aapcs\"`\n- `\"C\"`\n- `\"cdecl\"`\n- `\"efiapi\"`\n- `\"system\"`\n- `\"sysv64\"`\n- `\"win64\"`"
      }
    },
    {
      "id": "items.extern.attributes",
      "title": "Attributes on extern blocks",
      "level": 2,
      "content": "The following [attributes] control the behavior of external blocks.",
      "parent_id": null,
      "paragraphs": {
        "items.extern.attributes.intro": "The following [attributes] control the behavior of external blocks."
      }
    },
    {
      "id": "items.extern.attributes.link",
      "title": "The `link` attribute",
      "level": 2,
      "content": "The *`link` attribute* specifies the name of a native library that the\ncompiler should link with for the items within an `extern` block.\n\nIt uses the [MetaListNameValueStr] syntax to specify its inputs. The `name` key is the\nname of the native library to link. The `kind` key is an optional value which\nspecifies the kind of library with the following possible values:\n\n- `dylib` --- Indicates a dynamic library. This is the default if `kind` is not\n  specified.\n\n- `static` --- Indicates a static library.\n\n- `framework` --- Indicates a macOS framework. This is only valid for macOS\n  targets.\n\n- `raw-dylib` --- Indicates a dynamic library where the compiler will generate\n  an import library to link against (see [`dylib` versus `raw-dylib`] below\n  for details). This is only valid for Windows targets.\n\nThe `name` key must be included if `kind` is specified.\n\nThe optional `modifiers` argument is a way to specify linking modifiers for the\nlibrary to link.\n\nModifiers are specified as a comma-delimited string with each modifier prefixed\nwith either a `+` or `-` to indicate that the modifier is enabled or disabled,\nrespectively.\n\nSpecifying multiple `modifiers` arguments in a single `link` attribute,\nor multiple identical modifiers in the same `modifiers` argument is not currently supported. \\\nExample: `#[link(name = \"mylib\", kind = \"static\", modifiers = \"+whole-archive\")]`.\n\nThe `wasm_import_module` key may be used to specify the [WebAssembly module]\nname for the items within an `extern` block when importing symbols from the\nhost environment. The default module name is `env` if `wasm_import_module` is\nnot specified.\n\n<!-- ignore: requires extern linking -->\n,ignore\n#[link(name = \"crypto\")]\nunsafe extern {\n    // \u2026\n}\n\n#[link(name = \"CoreFoundation\", kind = \"framework\")]\nunsafe extern {\n    // \u2026\n}\n\n#[link(wasm_import_module = \"foo\")]\nunsafe extern {\n    // \u2026\n}\n\nIt is valid to add the `link` attribute on an empty extern block. You can use\nthis to satisfy the linking requirements of extern blocks elsewhere in your\ncode (including upstream crates) instead of adding the attribute to each extern\nblock.",
      "parent_id": null,
      "paragraphs": {
        "items.extern.attributes.link.intro": "The *`link` attribute* specifies the name of a native library that the\ncompiler should link with for the items within an `extern` block.",
        "items.extern.attributes.link.syntax": "It uses the [MetaListNameValueStr] syntax to specify its inputs. The `name` key is the\nname of the native library to link. The `kind` key is an optional value which\nspecifies the kind of library with the following possible values:",
        "items.extern.attributes.link.dylib": "- `dylib` --- Indicates a dynamic library. This is the default if `kind` is not\n  specified.",
        "items.extern.attributes.link.static": "- `static` --- Indicates a static library.",
        "items.extern.attributes.link.framework": "- `framework` --- Indicates a macOS framework. This is only valid for macOS\n  targets.",
        "items.extern.attributes.link.raw-dylib": "- `raw-dylib` --- Indicates a dynamic library where the compiler will generate\n  an import library to link against (see [`dylib` versus `raw-dylib`] below\n  for details). This is only valid for Windows targets.",
        "items.extern.attributes.link.name-requirement": "The `name` key must be included if `kind` is specified.",
        "items.extern.attributes.link.modifiers": "The optional `modifiers` argument is a way to specify linking modifiers for the\nlibrary to link.",
        "items.extern.attributes.link.modifiers.syntax": "Modifiers are specified as a comma-delimited string with each modifier prefixed\nwith either a `+` or `-` to indicate that the modifier is enabled or disabled,\nrespectively.",
        "items.extern.attributes.link.modifiers.multiple": "Specifying multiple `modifiers` arguments in a single `link` attribute,\nor multiple identical modifiers in the same `modifiers` argument is not currently supported. \\\nExample: `#[link(name = \"mylib\", kind = \"static\", modifiers = \"+whole-archive\")]`.",
        "items.extern.attributes.link.wasm_import_module": "The `wasm_import_module` key may be used to specify the [WebAssembly module]\nname for the items within an `extern` block when importing symbols from the\nhost environment. The default module name is `env` if `wasm_import_module` is\nnot specified.\n\n<!-- ignore: requires extern linking -->\n,ignore\n#[link(name = \"crypto\")]\nunsafe extern {\n    // \u2026\n}\n\n#[link(name = \"CoreFoundation\", kind = \"framework\")]\nunsafe extern {\n    // \u2026\n}\n\n#[link(wasm_import_module = \"foo\")]\nunsafe extern {\n    // \u2026\n}",
        "items.extern.attributes.link.empty-block": "It is valid to add the `link` attribute on an empty extern block. You can use\nthis to satisfy the linking requirements of extern blocks elsewhere in your\ncode (including upstream crates) instead of adding the attribute to each extern\nblock."
      }
    },
    {
      "id": "items.extern.attributes.link.modifiers.bundle",
      "title": "Linking modifiers: `bundle`",
      "level": 3,
      "content": "This modifier is only compatible with the `static` linking kind.\nUsing any other kind will result in a compiler error.\n\nWhen building a rlib or staticlib `+bundle` means that the native static library\nwill be packed into the rlib or staticlib archive, and then retrieved from there\nduring linking of the final binary.\n\nWhen building a rlib `-bundle` means that the native static library is registered as a dependency\nof that rlib \"by name\", and object files from it are included only during linking of the final\nbinary, the file search by that name is also performed during final linking. \\\nWhen building a staticlib `-bundle` means that the native static library is simply not included\ninto the archive and some higher level build system will need to add it later during linking of\nthe final binary.\n\nThis modifier has no effect when building other targets like executables or dynamic libraries.\n\nThe default for this modifier is `+bundle`.\n\nMore implementation details about this modifier can be found in\n[`bundle` documentation for rustc].",
      "parent_id": null,
      "paragraphs": {
        "items.extern.attributes.link.modifiers.bundle.allowed-kinds": "This modifier is only compatible with the `static` linking kind.\nUsing any other kind will result in a compiler error.",
        "items.extern.attributes.link.modifiers.bundle.behavior": "When building a rlib or staticlib `+bundle` means that the native static library\nwill be packed into the rlib or staticlib archive, and then retrieved from there\nduring linking of the final binary.",
        "items.extern.attributes.link.modifiers.bundle.behavior-negative": "When building a rlib `-bundle` means that the native static library is registered as a dependency\nof that rlib \"by name\", and object files from it are included only during linking of the final\nbinary, the file search by that name is also performed during final linking. \\\nWhen building a staticlib `-bundle` means that the native static library is simply not included\ninto the archive and some higher level build system will need to add it later during linking of\nthe final binary.",
        "items.extern.attributes.link.modifiers.bundle.no-effect": "This modifier has no effect when building other targets like executables or dynamic libraries.",
        "items.extern.attributes.link.modifiers.bundle.default": "The default for this modifier is `+bundle`.\n\nMore implementation details about this modifier can be found in\n[`bundle` documentation for rustc]."
      }
    },
    {
      "id": "items.extern.attributes.link.modifiers.whole-archive",
      "title": "Linking modifiers: `whole-archive`",
      "level": 4,
      "content": "This modifier is only compatible with the `static` linking kind.\nUsing any other kind will result in a compiler error.\n\n`+whole-archive` means that the static library is linked as a whole archive\nwithout throwing any object files away.\n\nThe default for this modifier is `-whole-archive`.\n\nMore implementation details about this modifier can be found in\n[`whole-archive` documentation for rustc].",
      "parent_id": null,
      "paragraphs": {
        "items.extern.attributes.link.modifiers.whole-archive.allowed-kinds": "This modifier is only compatible with the `static` linking kind.\nUsing any other kind will result in a compiler error.",
        "items.extern.attributes.link.modifiers.whole-archive.behavior": "`+whole-archive` means that the static library is linked as a whole archive\nwithout throwing any object files away.",
        "items.extern.attributes.link.modifiers.whole-archive.default": "The default for this modifier is `-whole-archive`.\n\nMore implementation details about this modifier can be found in\n[`whole-archive` documentation for rustc]."
      }
    },
    {
      "id": "items.extern.attributes.link.modifiers.verbatim",
      "title": "Linking modifiers: `verbatim`",
      "level": 4,
      "content": "This modifier is compatible with all linking kinds.\n\n`+verbatim` means that rustc itself won't add any target-specified library prefixes or suffixes\n(like `lib` or `.a`) to the library name, and will try its best to ask for the same thing from the\nlinker.\n\n`-verbatim` means that rustc will either add a target-specific prefix and suffix to the library\nname before passing it to linker, or won't prevent linker from implicitly adding it.\n\nThe default for this modifier is `-verbatim`.\n\nMore implementation details about this modifier can be found in\n[`verbatim` documentation for rustc].",
      "parent_id": null,
      "paragraphs": {
        "items.extern.attributes.link.modifiers.verbatim.allowed-kinds": "This modifier is compatible with all linking kinds.",
        "items.extern.attributes.link.modifiers.verbatim.behavior": "`+verbatim` means that rustc itself won't add any target-specified library prefixes or suffixes\n(like `lib` or `.a`) to the library name, and will try its best to ask for the same thing from the\nlinker.",
        "items.extern.attributes.link.modifiers.verbatim.behavior-negative": "`-verbatim` means that rustc will either add a target-specific prefix and suffix to the library\nname before passing it to linker, or won't prevent linker from implicitly adding it.",
        "items.extern.attributes.link.modifiers.verbatim.default": "The default for this modifier is `-verbatim`.\n\nMore implementation details about this modifier can be found in\n[`verbatim` documentation for rustc]."
      }
    },
    {
      "id": "items.extern.attributes.link.kind-raw-dylib",
      "title": "`dylib` versus `raw-dylib`",
      "level": 3,
      "content": "On Windows, linking against a dynamic library requires that an import library\nis provided to the linker: this is a special static library that declares all\nof the symbols exported by the dynamic library in such a way that the linker\nknows that they have to be dynamically loaded at runtime.\n\nSpecifying `kind = \"dylib\"` instructs the Rust compiler to link an import\nlibrary based on the `name` key. The linker will then use its normal library\nresolution logic to find that import library. Alternatively, specifying\n`kind = \"raw-dylib\"` instructs the compiler to generate an import library\nduring compilation and provide that to the linker instead.\n\n`raw-dylib` is only supported on Windows. Using it when targeting other\nplatforms will result in a compiler error.",
      "parent_id": null,
      "paragraphs": {
        "items.extern.attributes.link.kind-raw-dylib.intro": "On Windows, linking against a dynamic library requires that an import library\nis provided to the linker: this is a special static library that declares all\nof the symbols exported by the dynamic library in such a way that the linker\nknows that they have to be dynamically loaded at runtime.",
        "items.extern.attributes.link.kind-raw-dylib.import": "Specifying `kind = \"dylib\"` instructs the Rust compiler to link an import\nlibrary based on the `name` key. The linker will then use its normal library\nresolution logic to find that import library. Alternatively, specifying\n`kind = \"raw-dylib\"` instructs the compiler to generate an import library\nduring compilation and provide that to the linker instead.",
        "items.extern.attributes.link.kind-raw-dylib.platform-specific": "`raw-dylib` is only supported on Windows. Using it when targeting other\nplatforms will result in a compiler error."
      }
    },
    {
      "id": "items.extern.attributes.link.import_name_type",
      "title": "The `import_name_type` key",
      "level": 4,
      "content": "On x86 Windows, names of functions are \"decorated\" (i.e., have a specific prefix\nand/or suffix added) to indicate their calling convention. For example, a\n`stdcall` calling convention function with the name `fn1` that has no arguments\nwould be decorated as `_fn1@0`. However, the [PE Format] does also permit names\nto have no prefix or be undecorated. Additionally, the MSVC and GNU toolchains\nuse different decorations for the same calling conventions which means, by\ndefault, some Win32 functions cannot be called using the `raw-dylib` link kind\nvia the GNU toolchain.\n\nTo allow for these differences, when using the `raw-dylib` link kind you may\nalso specify the `import_name_type` key with one of the following values to\nchange how functions are named in the generated import library:\n\n* `decorated`: The function name will be fully-decorated using the MSVC\n  toolchain format.\n* `noprefix`: The function name will be decorated using the MSVC toolchain\n  format, but skipping the leading `?`, `@`, or optionally `_`.\n* `undecorated`: The function name will not be decorated.\n\nIf the `import_name_type` key is not specified, then the function name will be\nfully-decorated using the target toolchain's format.\n\nVariables are never decorated and so the `import_name_type` key has no effect on\nhow they are named in the generated import library.\n\nThe `import_name_type` key is only supported on x86 Windows. Using it when\ntargeting other platforms will result in a compiler error.\n\n<!-- template:attributes -->",
      "parent_id": null,
      "paragraphs": {
        "items.extern.attributes.link.import_name_type.intro": "On x86 Windows, names of functions are \"decorated\" (i.e., have a specific prefix\nand/or suffix added) to indicate their calling convention. For example, a\n`stdcall` calling convention function with the name `fn1` that has no arguments\nwould be decorated as `_fn1@0`. However, the [PE Format] does also permit names\nto have no prefix or be undecorated. Additionally, the MSVC and GNU toolchains\nuse different decorations for the same calling conventions which means, by\ndefault, some Win32 functions cannot be called using the `raw-dylib` link kind\nvia the GNU toolchain.",
        "items.extern.attributes.link.import_name_type.values": "To allow for these differences, when using the `raw-dylib` link kind you may\nalso specify the `import_name_type` key with one of the following values to\nchange how functions are named in the generated import library:\n\n* `decorated`: The function name will be fully-decorated using the MSVC\n  toolchain format.\n* `noprefix`: The function name will be decorated using the MSVC toolchain\n  format, but skipping the leading `?`, `@`, or optionally `_`.\n* `undecorated`: The function name will not be decorated.",
        "items.extern.attributes.link.import_name_type.default": "If the `import_name_type` key is not specified, then the function name will be\nfully-decorated using the target toolchain's format.",
        "items.extern.attributes.link.import_name_type.variables": "Variables are never decorated and so the `import_name_type` key has no effect on\nhow they are named in the generated import library.",
        "items.extern.attributes.link.import_name_type.platform-specific": "The `import_name_type` key is only supported on x86 Windows. Using it when\ntargeting other platforms will result in a compiler error.\n\n<!-- template:attributes -->"
      }
    },
    {
      "id": "items.extern.attributes.link_name",
      "title": "The `link_name` attribute",
      "level": 4,
      "content": "The *`link_name` attribute* may be applied to declarations inside an `extern` block to specify the symbol to import for the given function or static.\n\n> [!EXAMPLE]\n> ```rust\n> unsafe extern \"C\" {\n>     #[link_name = \"actual_symbol_name\"]\n>     safe fn name_in_rust();\n> }\n> ```\n\nThe `link_name` attribute uses the [MetaNameValueStr] syntax.\n\nThe `link_name` attribute may only be applied to a function or static item in an `extern` block.\n\n> [!NOTE]\n> `rustc` ignores use in other positions but lints against it. This may become an error in the future.\n\nOnly the last use of `link_name` on an item has effect.\n\n> [!NOTE]\n> `rustc` lints against any use preceding the last. This may become an error in the future.\n\nThe `link_name` attribute may not be used with the [`link_ordinal`] attribute.",
      "parent_id": null,
      "paragraphs": {
        "items.extern.attributes.link_name.intro": "The *`link_name` attribute* may be applied to declarations inside an `extern` block to specify the symbol to import for the given function or static.\n\n> [!EXAMPLE]\n> ```rust\n> unsafe extern \"C\" {\n>     #[link_name = \"actual_symbol_name\"]\n>     safe fn name_in_rust();\n> }\n> ```",
        "items.extern.attributes.link_name.syntax": "The `link_name` attribute uses the [MetaNameValueStr] syntax.",
        "items.extern.attributes.link_name.allowed-positions": "The `link_name` attribute may only be applied to a function or static item in an `extern` block.\n\n> [!NOTE]\n> `rustc` ignores use in other positions but lints against it. This may become an error in the future.",
        "items.extern.attributes.link_name.duplicates": "Only the last use of `link_name` on an item has effect.\n\n> [!NOTE]\n> `rustc` lints against any use preceding the last. This may become an error in the future.",
        "items.extern.attributes.link_name.link_ordinal": "The `link_name` attribute may not be used with the [`link_ordinal`] attribute."
      }
    },
    {
      "id": "items.extern.attributes.link_ordinal",
      "title": "The `link_ordinal` attribute",
      "level": 3,
      "content": "The *`link_ordinal` attribute* can be applied on declarations inside an `extern`\nblock to indicate the numeric ordinal to use when generating the import library\nto link against. An ordinal is a unique number per symbol exported by a dynamic\nlibrary on Windows and can be used when the library is being loaded to find\nthat symbol rather than having to look it up by name.\n\n> [!WARNING]\n> `link_ordinal` should only be used in cases where the ordinal of the symbol is known to be stable: if the ordinal of a symbol is not explicitly set when its containing binary is built then one will be automatically assigned to it, and that assigned ordinal may change between builds of the binary.\n\n# #[cfg(all(windows, target_arch = \"x86\"))]\n#[link(name = \"exporter\", kind = \"raw-dylib\")]\nunsafe extern \"stdcall\" {\n    #[link_ordinal(15)]\n    safe fn imported_function_stdcall(i: i32);\n}\n\nThis attribute is only used with the `raw-dylib` linking kind.\nUsing any other kind will result in a compiler error.\n\nUsing this attribute with the `link_name` attribute will result in a\ncompiler error.",
      "parent_id": null,
      "paragraphs": {
        "items.extern.attributes.link_ordinal.intro": "The *`link_ordinal` attribute* can be applied on declarations inside an `extern`\nblock to indicate the numeric ordinal to use when generating the import library\nto link against. An ordinal is a unique number per symbol exported by a dynamic\nlibrary on Windows and can be used when the library is being loaded to find\nthat symbol rather than having to look it up by name.\n\n> [!WARNING]\n> `link_ordinal` should only be used in cases where the ordinal of the symbol is known to be stable: if the ordinal of a symbol is not explicitly set when its containing binary is built then one will be automatically assigned to it, and that assigned ordinal may change between builds of the binary.\n\n# #[cfg(all(windows, target_arch = \"x86\"))]\n#[link(name = \"exporter\", kind = \"raw-dylib\")]\nunsafe extern \"stdcall\" {\n    #[link_ordinal(15)]\n    safe fn imported_function_stdcall(i: i32);\n}",
        "items.extern.attributes.link_ordinal.allowed-kinds": "This attribute is only used with the `raw-dylib` linking kind.\nUsing any other kind will result in a compiler error.",
        "items.extern.attributes.link_ordinal.exclusive": "Using this attribute with the `link_name` attribute will result in a\ncompiler error."
      }
    },
    {
      "id": "items.extern.attributes.fn-parameters",
      "title": "Attributes on function parameters",
      "level": 1,
      "content": "Attributes on extern function parameters follow the same rules and\nrestrictions as [regular function parameters].\n\n[ABI]: glossary.abi\n[PE Format]: https://learn.microsoft.com/windows/win32/debug/pe-format#import-name-type\n[UEFI]: https://uefi.org/specifications\n[WebAssembly module]: https://webassembly.github.io/spec/core/syntax/modules.html\n[`bundle` documentation for rustc]: ../../rustc/command-line-arguments.html#linking-modifiers-bundle\n\n[`extern fn`]: items.fn.extern\n[`unsafe` context]: ../unsafe-keyword.md\n[`verbatim` documentation for rustc]: ../../rustc/command-line-arguments.html#linking-modifiers-verbatim\n[`whole-archive` documentation for rustc]: ../../rustc/command-line-arguments.html#linking-modifiers-whole-archive\n[attributes]: ../attributes.md\n[functions]: functions.md\n[regular function parameters]: functions.md#attributes-on-function-parameters\n[statics]: static-items.md\n[unwind-behavior]: functions.md#unwinding\n[value namespace]: ../names/namespaces.md\n[win32 api]: https://learn.microsoft.com/en-us/windows/win32/api/\n[`link_ordinal`]: items.extern.attributes.link_ordinal",
      "parent_id": null,
      "paragraphs": {
        "items.extern.attributes.fn-parameters": "Attributes on extern function parameters follow the same rules and\nrestrictions as [regular function parameters].\n\n[ABI]: glossary.abi\n[PE Format]: https://learn.microsoft.com/windows/win32/debug/pe-format#import-name-type\n[UEFI]: https://uefi.org/specifications\n[WebAssembly module]: https://webassembly.github.io/spec/core/syntax/modules.html\n[`bundle` documentation for rustc]: ../../rustc/command-line-arguments.html#linking-modifiers-bundle\n\n[`extern fn`]: items.fn.extern\n[`unsafe` context]: ../unsafe-keyword.md\n[`verbatim` documentation for rustc]: ../../rustc/command-line-arguments.html#linking-modifiers-verbatim\n[`whole-archive` documentation for rustc]: ../../rustc/command-line-arguments.html#linking-modifiers-whole-archive\n[attributes]: ../attributes.md\n[functions]: functions.md\n[regular function parameters]: functions.md#attributes-on-function-parameters\n[statics]: static-items.md\n[unwind-behavior]: functions.md#unwinding\n[value namespace]: ../names/namespaces.md\n[win32 api]: https://learn.microsoft.com/en-us/windows/win32/api/\n[`link_ordinal`]: items.extern.attributes.link_ordinal"
      }
    },
    {
      "id": "items.generics",
      "title": "Generic parameters",
      "level": 1,
      "content": ",items\nGenericParams -> `<` ( GenericParam (`,` GenericParam)* `,`? )? `>`\n\nGenericParam -> OuterAttribute* ( LifetimeParam | TypeParam | ConstParam )\n\nLifetimeParam -> Lifetime ( `:` LifetimeBounds )?\n\nTypeParam -> IDENTIFIER ( `:` TypeParamBounds? )? ( `=` Type )?\n\nConstParam ->\n    `const` IDENTIFIER `:` Type\n    ( `=` ( BlockExpression | IDENTIFIER | `-`?LiteralExpression ) )?\n\n[Functions], [type aliases], [structs], [enumerations], [unions], [traits], and\n[implementations] may be *parameterized* by types, constants, and lifetimes. These\nparameters are listed in angle <span class=\"parenthetical\">brackets (`<...>`)</span>,\nusually immediately after the name of the item and before its definition. For\nimplementations, which don't have a name, they come directly after `impl`.\n\nThe order of generic parameters is restricted to lifetime parameters and then type and const parameters intermixed.\n\nThe same parameter name may not be declared more than once in a [GenericParams] list.\n\nSome examples of items with type, const, and lifetime parameters:\n\nfn foo<'a, T>() {}\ntrait A<U> {}\nstruct Ref<'a, T> where T: 'a { r: &'a T }\nstruct InnerArray<T, const N: usize>([T; N]);\nstruct EitherOrderWorks<const N: bool, U>(U);\n\nGeneric parameters are in scope within the item definition where they are\ndeclared. They are not in scope for items declared within the body of a\nfunction as described in [item declarations].\nSee [generic parameter scopes] for more details.\n\n[References], [raw pointers], [arrays], [slices], [tuples], and\n[function pointers] have lifetime or type parameters as well, but are not\nreferred to with path syntax.\n\n`'_` and `'static` are not valid lifetime parameter names.",
      "parent_id": null,
      "paragraphs": {
        "items.generics.syntax": ",items\nGenericParams -> `<` ( GenericParam (`,` GenericParam)* `,`? )? `>`\n\nGenericParam -> OuterAttribute* ( LifetimeParam | TypeParam | ConstParam )\n\nLifetimeParam -> Lifetime ( `:` LifetimeBounds )?\n\nTypeParam -> IDENTIFIER ( `:` TypeParamBounds? )? ( `=` Type )?\n\nConstParam ->\n    `const` IDENTIFIER `:` Type\n    ( `=` ( BlockExpression | IDENTIFIER | `-`?LiteralExpression ) )?",
        "items.generics.syntax.intro": "[Functions], [type aliases], [structs], [enumerations], [unions], [traits], and\n[implementations] may be *parameterized* by types, constants, and lifetimes. These\nparameters are listed in angle <span class=\"parenthetical\">brackets (`<...>`)</span>,\nusually immediately after the name of the item and before its definition. For\nimplementations, which don't have a name, they come directly after `impl`.",
        "items.generics.syntax.decl-order": "The order of generic parameters is restricted to lifetime parameters and then type and const parameters intermixed.",
        "items.generics.syntax.duplicate-params": "The same parameter name may not be declared more than once in a [GenericParams] list.\n\nSome examples of items with type, const, and lifetime parameters:\n\nfn foo<'a, T>() {}\ntrait A<U> {}\nstruct Ref<'a, T> where T: 'a { r: &'a T }\nstruct InnerArray<T, const N: usize>([T; N]);\nstruct EitherOrderWorks<const N: bool, U>(U);",
        "items.generics.syntax.scope": "Generic parameters are in scope within the item definition where they are\ndeclared. They are not in scope for items declared within the body of a\nfunction as described in [item declarations].\nSee [generic parameter scopes] for more details.",
        "items.generics.builtin-generic-types": "[References], [raw pointers], [arrays], [slices], [tuples], and\n[function pointers] have lifetime or type parameters as well, but are not\nreferred to with path syntax.",
        "items.generics.invalid-lifetimes": "`'_` and `'static` are not valid lifetime parameter names."
      }
    },
    {
      "id": "items.generics.const",
      "title": "Const generics",
      "level": 1,
      "content": "*Const generic parameters* allow items to be generic over constant values.\n\nThe const identifier introduces a name in the [value namespace] for the constant parameter, and all instances of the item must be instantiated with a value of the given type.\n\nThe only allowed types of const parameters are `u8`, `u16`, `u32`, `u64`, `u128`, `usize`,\n`i8`, `i16`, `i32`, `i64`, `i128`, `isize`, `char` and `bool`.\n\nConst parameters can be used anywhere a [const item] can be used, with the\nexception that when used in a [type] or [array repeat expression], it must be\nstandalone (as described below). That is, they are allowed in the following\nplaces:\n\n1. As an applied const to any type which forms a part of the signature of the\n   item in question.\n2. As part of a const expression used to define an [associated const], or as a\n   parameter to an [associated type].\n3. As a value in any runtime expression in the body of any functions in the\n   item.\n4. As a parameter to any type used in the body of any functions in the item.\n5. As a part of the type of any fields in the item.\n\n// Examples where const generic parameters can be used.\n\n// Used in the signature of the item itself.\nfn foo<const N: usize>(arr: [i32; N]) {\n    // Used as a type within a function body.\n    let x: [i32; N];\n    // Used as an expression.\n    println!(\"{}\", N * 2);\n}\n\n// Used as a field of a struct.\nstruct Foo<const N: usize>([i32; N]);\n\nimpl<const N: usize> Foo<N> {\n    // Used as an associated constant.\n    const CONST: usize = N * 4;\n}\n\ntrait Trait {\n    type Output;\n}\n\nimpl<const N: usize> Trait for Foo<N> {\n    // Used as an associated type.\n    type Output = [i32; N];\n}\n\n,compile_fail\n// Examples where const generic parameters cannot be used.\nfn foo<const N: usize>() {\n    // Cannot use in item definitions within a function body.\n    const BAD_CONST: [usize; N] = [1; N];\n    static BAD_STATIC: [usize; N] = [1; N];\n    fn inner(bad_arg: [usize; N]) {\n        let bad_value = N * 2;\n    }\n    type BadAlias = [usize; N];\n    struct BadStruct([usize; N]);\n}\n\nAs a further restriction, const parameters may only appear as a standalone\nargument inside of a [type] or [array repeat expression]. In those contexts,\nthey may only be used as a single segment [path expression], possibly inside a\n[block] (such as `N` or `{N}`). That is, they cannot be combined with other\nexpressions.\n\n,compile_fail\n// Examples where const parameters may not be used.\n\n// Not allowed to combine in other expressions in types, such as the\n// arithmetic expression in the return type here.\nfn bad_function<const N: usize>() -> [u8; {N + 1}] {\n    // Similarly not allowed for array repeat expressions.\n    [1; {N + 1}]\n}\n\nA const argument in a [path] specifies the const value to use for that item.\n\nThe argument must either be an [inferred const] or be a [const expression] of the type ascribed to the const parameter. The const expression must be a block expression (surrounded with braces) unless it is a single path segment (an [IDENTIFIER]) or a [literal] (with a possibly leading `-` token).\n\n> [!NOTE]\n> This syntactic restriction is necessary to avoid requiring infinite lookahead when parsing an expression inside of a type.\n\nstruct S<const N: i64>;\nconst C: i64 = 1;\nfn f<const N: i64>() -> S<N> { S }\n\nlet _ = f::<1>(); // Literal.\nlet _ = f::<-1>(); // Negative literal.\nlet _ = f::<{ 1 + 2 }>(); // Constant expression.\nlet _ = f::<C>(); // Single segment path.\nlet _ = f::<{ C + 1 }>(); // Constant expression.\nlet _: S<1> = f::<_>(); // Inferred const.\nlet _: S<1> = f::<(((_)))>(); // Inferred const.\n\n> [!NOTE]\n> In a generic argument list, an [inferred const] is parsed as an inferred type but then semantically treated as a separate kind of [const generic argument].\n\nWhere a const argument is expected, an `_` (optionally surrounded by any number of matching parentheses), called the *inferred const* (path rules, array expression rules), can be used instead. This asks the compiler to infer the const argument if possible based on surrounding information.\n\nfn make_buf<const N: usize>() -> [u8; N] {\n    [0; _]\n    //  ^ Infers `N`.\n}\nlet _: [u8; 1024] = make_buf::<_>();\n//                             ^ Infers `1024`.\n\n> [!NOTE]\n> An [inferred const] is not semantically an expression and so is not accepted within braces.\n>\n> ```rust,compile_fail\n> fn f<const N: usize>() -> [u8; N] { [0; _] }\n> let _: [_; 1] = f::<{ _ }>();\n> //                    ^ ERROR `_` not allowed here\n> ```\n\nThe inferred const cannot be used in item signatures.\n\n,compile_fail\nfn f<const N: usize>(x: [u8; N]) -> [u8; _] { x }\n//                                       ^ ERROR not allowed\n\nWhen there is ambiguity if a generic argument could be resolved as either a\ntype or const argument, it is always resolved as a type. Placing the argument\nin a block expression can force it to be interpreted as a const argument.\n\n<!-- TODO: Rewrite the paragraph above to be in terms of namespaces, once\n    namespaces are introduced, and it is clear which namespace each parameter\n    lives in. -->\n\n,compile_fail\ntype N = u32;\nstruct Foo<const N: usize>;\n// The following is an error, because `N` is interpreted as the type alias `N`.\nfn foo<const N: usize>() -> Foo<N> { todo!() } // ERROR\n// Can be fixed by wrapping in braces to force it to be interpreted as the `N`\n// const parameter:\nfn bar<const N: usize>() -> Foo<{ N }> { todo!() } // ok\n\nUnlike type and lifetime parameters, const parameters can be declared without\nbeing used inside of a parameterized item, with the exception of\nimplementations as described in [generic implementations]:\n\n,compile_fail\n// ok\nstruct Foo<const N: usize>;\nenum Bar<const M: usize> { A, B }\n\n// ERROR: unused parameter\nstruct Baz<T>;\nstruct Biz<'a>;\nstruct Unconstrained;\nimpl<const N: usize> Unconstrained {}\n\nWhen resolving a trait bound obligation, the exhaustiveness of all\nimplementations of const parameters is not considered when determining if the\nbound is satisfied. For example, in the following, even though all possible\nconst values for the `bool` type are implemented, it is still an error that\nthe trait bound is not satisfied:\n\n,compile_fail\nstruct Foo<const B: bool>;\ntrait Bar {}\nimpl Bar for Foo<true> {}\nimpl Bar for Foo<false> {}\n\nfn needs_bar(_: impl Bar) {}\nfn generic<const B: bool>() {\n    let v = Foo::<B>;\n    needs_bar(v); // ERROR: trait bound `Foo<B>: Bar` is not satisfied\n}",
      "parent_id": null,
      "paragraphs": {
        "items.generics.const.intro": "*Const generic parameters* allow items to be generic over constant values.",
        "items.generics.const.namespace": "The const identifier introduces a name in the [value namespace] for the constant parameter, and all instances of the item must be instantiated with a value of the given type.",
        "items.generics.const.allowed-types": "The only allowed types of const parameters are `u8`, `u16`, `u32`, `u64`, `u128`, `usize`,\n`i8`, `i16`, `i32`, `i64`, `i128`, `isize`, `char` and `bool`.",
        "items.generics.const.usage": "Const parameters can be used anywhere a [const item] can be used, with the\nexception that when used in a [type] or [array repeat expression], it must be\nstandalone (as described below). That is, they are allowed in the following\nplaces:\n\n1. As an applied const to any type which forms a part of the signature of the\n   item in question.\n2. As part of a const expression used to define an [associated const], or as a\n   parameter to an [associated type].\n3. As a value in any runtime expression in the body of any functions in the\n   item.\n4. As a parameter to any type used in the body of any functions in the item.\n5. As a part of the type of any fields in the item.\n\n// Examples where const generic parameters can be used.\n\n// Used in the signature of the item itself.\nfn foo<const N: usize>(arr: [i32; N]) {\n    // Used as a type within a function body.\n    let x: [i32; N];\n    // Used as an expression.\n    println!(\"{}\", N * 2);\n}\n\n// Used as a field of a struct.\nstruct Foo<const N: usize>([i32; N]);\n\nimpl<const N: usize> Foo<N> {\n    // Used as an associated constant.\n    const CONST: usize = N * 4;\n}\n\ntrait Trait {\n    type Output;\n}\n\nimpl<const N: usize> Trait for Foo<N> {\n    // Used as an associated type.\n    type Output = [i32; N];\n}\n\n,compile_fail\n// Examples where const generic parameters cannot be used.\nfn foo<const N: usize>() {\n    // Cannot use in item definitions within a function body.\n    const BAD_CONST: [usize; N] = [1; N];\n    static BAD_STATIC: [usize; N] = [1; N];\n    fn inner(bad_arg: [usize; N]) {\n        let bad_value = N * 2;\n    }\n    type BadAlias = [usize; N];\n    struct BadStruct([usize; N]);\n}",
        "items.generics.const.standalone": "As a further restriction, const parameters may only appear as a standalone\nargument inside of a [type] or [array repeat expression]. In those contexts,\nthey may only be used as a single segment [path expression], possibly inside a\n[block] (such as `N` or `{N}`). That is, they cannot be combined with other\nexpressions.\n\n,compile_fail\n// Examples where const parameters may not be used.\n\n// Not allowed to combine in other expressions in types, such as the\n// arithmetic expression in the return type here.\nfn bad_function<const N: usize>() -> [u8; {N + 1}] {\n    // Similarly not allowed for array repeat expressions.\n    [1; {N + 1}]\n}",
        "items.generics.const.argument": "A const argument in a [path] specifies the const value to use for that item.",
        "items.generics.const.argument.const-expr": "The argument must either be an [inferred const] or be a [const expression] of the type ascribed to the const parameter. The const expression must be a block expression (surrounded with braces) unless it is a single path segment (an [IDENTIFIER]) or a [literal] (with a possibly leading `-` token).\n\n> [!NOTE]\n> This syntactic restriction is necessary to avoid requiring infinite lookahead when parsing an expression inside of a type.\n\nstruct S<const N: i64>;\nconst C: i64 = 1;\nfn f<const N: i64>() -> S<N> { S }\n\nlet _ = f::<1>(); // Literal.\nlet _ = f::<-1>(); // Negative literal.\nlet _ = f::<{ 1 + 2 }>(); // Constant expression.\nlet _ = f::<C>(); // Single segment path.\nlet _ = f::<{ C + 1 }>(); // Constant expression.\nlet _: S<1> = f::<_>(); // Inferred const.\nlet _: S<1> = f::<(((_)))>(); // Inferred const.\n\n> [!NOTE]\n> In a generic argument list, an [inferred const] is parsed as an inferred type but then semantically treated as a separate kind of [const generic argument].",
        "items.generics.const.inferred": "Where a const argument is expected, an `_` (optionally surrounded by any number of matching parentheses), called the *inferred const* (path rules, array expression rules), can be used instead. This asks the compiler to infer the const argument if possible based on surrounding information.\n\nfn make_buf<const N: usize>() -> [u8; N] {\n    [0; _]\n    //  ^ Infers `N`.\n}\nlet _: [u8; 1024] = make_buf::<_>();\n//                             ^ Infers `1024`.\n\n> [!NOTE]\n> An [inferred const] is not semantically an expression and so is not accepted within braces.\n>\n> ```rust,compile_fail\n> fn f<const N: usize>() -> [u8; N] { [0; _] }\n> let _: [_; 1] = f::<{ _ }>();\n> //                    ^ ERROR `_` not allowed here\n> ```",
        "items.generics.const.inferred.constraint": "The inferred const cannot be used in item signatures.\n\n,compile_fail\nfn f<const N: usize>(x: [u8; N]) -> [u8; _] { x }\n//                                       ^ ERROR not allowed",
        "items.generics.const.type-ambiguity": "When there is ambiguity if a generic argument could be resolved as either a\ntype or const argument, it is always resolved as a type. Placing the argument\nin a block expression can force it to be interpreted as a const argument.\n\n<!-- TODO: Rewrite the paragraph above to be in terms of namespaces, once\n    namespaces are introduced, and it is clear which namespace each parameter\n    lives in. -->\n\n,compile_fail\ntype N = u32;\nstruct Foo<const N: usize>;\n// The following is an error, because `N` is interpreted as the type alias `N`.\nfn foo<const N: usize>() -> Foo<N> { todo!() } // ERROR\n// Can be fixed by wrapping in braces to force it to be interpreted as the `N`\n// const parameter:\nfn bar<const N: usize>() -> Foo<{ N }> { todo!() } // ok",
        "items.generics.const.variance": "Unlike type and lifetime parameters, const parameters can be declared without\nbeing used inside of a parameterized item, with the exception of\nimplementations as described in [generic implementations]:\n\n,compile_fail\n// ok\nstruct Foo<const N: usize>;\nenum Bar<const M: usize> { A, B }\n\n// ERROR: unused parameter\nstruct Baz<T>;\nstruct Biz<'a>;\nstruct Unconstrained;\nimpl<const N: usize> Unconstrained {}",
        "items.generics.const.exhaustiveness": "When resolving a trait bound obligation, the exhaustiveness of all\nimplementations of const parameters is not considered when determining if the\nbound is satisfied. For example, in the following, even though all possible\nconst values for the `bool` type are implemented, it is still an error that\nthe trait bound is not satisfied:\n\n,compile_fail\nstruct Foo<const B: bool>;\ntrait Bar {}\nimpl Bar for Foo<true> {}\nimpl Bar for Foo<false> {}\n\nfn needs_bar(_: impl Bar) {}\nfn generic<const B: bool>() {\n    let v = Foo::<B>;\n    needs_bar(v); // ERROR: trait bound `Foo<B>: Bar` is not satisfied\n}"
      }
    },
    {
      "id": "items.generics.where",
      "title": "Where clauses",
      "level": 3,
      "content": ",items\nWhereClause -> `where` ( WhereClauseItem `,` )* WhereClauseItem?\n\nWhereClauseItem ->\n      LifetimeWhereClauseItem\n    | TypeBoundWhereClauseItem\n\nLifetimeWhereClauseItem -> Lifetime `:` LifetimeBounds\n\nTypeBoundWhereClauseItem -> ForLifetimes? Type `:` TypeParamBounds?\n\n*Where clauses* provide another way to specify bounds on type and lifetime\nparameters as well as a way to specify bounds on types that aren't type\nparameters.\n\nThe `for` keyword can be used to introduce [higher-ranked lifetimes]. It only\nallows [LifetimeParam] parameters.\n\nstruct A<T>\nwhere\n    T: Iterator,            // Could use A<T: Iterator> instead\n    T::Item: Copy,          // Bound on an associated type\n    String: PartialEq<T>,   // Bound on `String`, using the type parameter\n    i32: Default,           // Allowed, but not useful\n{\n    f: T,\n}",
      "parent_id": null,
      "paragraphs": {
        "items.generics.where.syntax": ",items\nWhereClause -> `where` ( WhereClauseItem `,` )* WhereClauseItem?\n\nWhereClauseItem ->\n      LifetimeWhereClauseItem\n    | TypeBoundWhereClauseItem\n\nLifetimeWhereClauseItem -> Lifetime `:` LifetimeBounds\n\nTypeBoundWhereClauseItem -> ForLifetimes? Type `:` TypeParamBounds?",
        "items.generics.where.intro": "*Where clauses* provide another way to specify bounds on type and lifetime\nparameters as well as a way to specify bounds on types that aren't type\nparameters.",
        "items.generics.where.higher-ranked-lifetimes": "The `for` keyword can be used to introduce [higher-ranked lifetimes]. It only\nallows [LifetimeParam] parameters.\n\nstruct A<T>\nwhere\n    T: Iterator,            // Could use A<T: Iterator> instead\n    T::Item: Copy,          // Bound on an associated type\n    String: PartialEq<T>,   // Bound on `String`, using the type parameter\n    i32: Default,           // Allowed, but not useful\n{\n    f: T,\n}"
      }
    },
    {
      "id": "items.generics.attributes",
      "title": "Attributes",
      "level": 2,
      "content": "Generic lifetime and type parameters allow [attributes] on them. There are no\nbuilt-in attributes that do anything in this position, although custom derive\nattributes may give meaning to it.\n\nThis example shows using a custom derive attribute to modify the meaning of a\ngeneric parameter.\n\n<!-- ignore: requires proc macro derive -->\n,ignore\n// Assume that the derive for MyFlexibleClone declared `my_flexible_clone` as\n// an attribute it understands.\n#[derive(MyFlexibleClone)]\nstruct Foo<#[my_flexible_clone(unbounded)] H> {\n    a: *const H\n}\n\n[array repeat expression]: ../expressions/array-expr.md\n[arrays]: ../types/array.md\n[slices]: ../types/slice.md\n[associated const]: associated-items.md#associated-constants\n[associated type]: associated-items.md#associated-types\n[attributes]: ../attributes.md\n[block]: ../expressions/block-expr.md\n[const contexts]: ../const_eval.md#const-context\n[const expression]: ../const_eval.md#constant-expressions\n[const generic argument]: items.generics.const.argument\n[const item]: constant-items.md\n[enumerations]: enumerations.md\n[functions]: functions.md\n[function pointers]: ../types/function-pointer.md\n[generic implementations]: implementations.md#generic-implementations\n[generic parameter scopes]: ../names/scopes.md#generic-parameter-scopes\n[higher-ranked lifetimes]: ../trait-bounds.md#higher-ranked-trait-bounds\n[implementations]: implementations.md\n[inferred const]: items.generics.const.inferred\n[item declarations]: ../statements.md#item-declarations\n[item]: ../items.md\n[literal]: ../expressions/literal-expr.md\n[path]: ../paths.md\n[path expression]: ../expressions/path-expr.md\n[raw pointers]: ../types/pointer.md#raw-pointers-const-and-mut\n[references]: ../types/pointer.md#shared-references-\n[structs]: structs.md\n[tuples]: ../types/tuple.md\n[trait object]: ../types/trait-object.md\n[traits]: traits.md\n[type aliases]: type-aliases.md\n[type]: ../types.md\n[unions]: unions.md\n[value namespace]: ../names/namespaces.md",
      "parent_id": null,
      "paragraphs": {
        "items.generics.attributes": "Generic lifetime and type parameters allow [attributes] on them. There are no\nbuilt-in attributes that do anything in this position, although custom derive\nattributes may give meaning to it.\n\nThis example shows using a custom derive attribute to modify the meaning of a\ngeneric parameter.\n\n<!-- ignore: requires proc macro derive -->\n,ignore\n// Assume that the derive for MyFlexibleClone declared `my_flexible_clone` as\n// an attribute it understands.\n#[derive(MyFlexibleClone)]\nstruct Foo<#[my_flexible_clone(unbounded)] H> {\n    a: *const H\n}\n\n[array repeat expression]: ../expressions/array-expr.md\n[arrays]: ../types/array.md\n[slices]: ../types/slice.md\n[associated const]: associated-items.md#associated-constants\n[associated type]: associated-items.md#associated-types\n[attributes]: ../attributes.md\n[block]: ../expressions/block-expr.md\n[const contexts]: ../const_eval.md#const-context\n[const expression]: ../const_eval.md#constant-expressions\n[const generic argument]: items.generics.const.argument\n[const item]: constant-items.md\n[enumerations]: enumerations.md\n[functions]: functions.md\n[function pointers]: ../types/function-pointer.md\n[generic implementations]: implementations.md#generic-implementations\n[generic parameter scopes]: ../names/scopes.md#generic-parameter-scopes\n[higher-ranked lifetimes]: ../trait-bounds.md#higher-ranked-trait-bounds\n[implementations]: implementations.md\n[inferred const]: items.generics.const.inferred\n[item declarations]: ../statements.md#item-declarations\n[item]: ../items.md\n[literal]: ../expressions/literal-expr.md\n[path]: ../paths.md\n[path expression]: ../expressions/path-expr.md\n[raw pointers]: ../types/pointer.md#raw-pointers-const-and-mut\n[references]: ../types/pointer.md#shared-references-\n[structs]: structs.md\n[tuples]: ../types/tuple.md\n[trait object]: ../types/trait-object.md\n[traits]: traits.md\n[type aliases]: type-aliases.md\n[type]: ../types.md\n[unions]: unions.md\n[value namespace]: ../names/namespaces.md"
      }
    },
    {
      "id": "items.associated",
      "title": "Associated items",
      "level": 1,
      "content": ",items\nAssociatedItem ->\n    OuterAttribute* (\n        MacroInvocationSemi\n      | ( Visibility? ( TypeAlias | ConstantItem | Function ) )\n    )\n\n*Associated Items* are the items declared in [traits] or defined in\n[implementations]. They are called this because they are defined on an associate\ntype &mdash; the type in the implementation.\n\nThey are a subset of the kinds of items you can declare in a module.\nSpecifically, there are [associated functions] (including methods), [associated types], and [associated constants].\n\nAssociated items are useful when the associated item is logically related to the\nassociating item. For example, the `is_some` method on `Option` is intrinsically\nrelated to Options, so should be associated.\n\nEvery associated item kind comes in two varieties: definitions that contain the\nactual implementation and declarations that declare signatures for\ndefinitions.\n\nIt is the declarations that make up the contract of traits and what is available\non generic types.",
      "parent_id": null,
      "paragraphs": {
        "items.associated.syntax": ",items\nAssociatedItem ->\n    OuterAttribute* (\n        MacroInvocationSemi\n      | ( Visibility? ( TypeAlias | ConstantItem | Function ) )\n    )",
        "items.associated.intro": "*Associated Items* are the items declared in [traits] or defined in\n[implementations]. They are called this because they are defined on an associate\ntype &mdash; the type in the implementation.",
        "items.associated.kinds": "They are a subset of the kinds of items you can declare in a module.\nSpecifically, there are [associated functions] (including methods), [associated types], and [associated constants].",
        "items.associated.related": "Associated items are useful when the associated item is logically related to the\nassociating item. For example, the `is_some` method on `Option` is intrinsically\nrelated to Options, so should be associated.",
        "items.associated.decl-def": "Every associated item kind comes in two varieties: definitions that contain the\nactual implementation and declarations that declare signatures for\ndefinitions.",
        "items.associated.trait-items": "It is the declarations that make up the contract of traits and what is available\non generic types."
      }
    },
    {
      "id": "items.associated.fn",
      "title": "Associated functions and methods",
      "level": 1,
      "content": "*Associated functions* are [functions] associated with a type.\n\nAn *associated function declaration* declares a signature for an associated\nfunction definition. It is written as a function item, except the\nfunction body is replaced with a `;`.\n\nThe identifier is the name of the function.\n\nThe generics, parameter list, return type, and where clause of the associated function must be the same as the\nassociated function declarations's.\n\nAn *associated function definition* defines a function associated with another\ntype. It is written the same as a [function item].\n\n> [!NOTE]\n> A common example is an associated function named `new` that returns a value of the type with which it is associated.\n\nstruct Struct {\n    field: i32\n}\n\nimpl Struct {\n    fn new() -> Struct {\n        Struct {\n            field: 0i32\n        }\n    }\n}\n\nfn main () {\n    let _struct = Struct::new();\n}\n\nWhen the associated function is declared on a trait, the function can also be\ncalled with a [path] that is a path to the trait appended by the name of the\ntrait. When this happens, it is substituted for `<_ as Trait>::function_name`.\n\ntrait Num {\n    fn from_i32(n: i32) -> Self;\n}\n\nimpl Num for f64 {\n    fn from_i32(n: i32) -> f64 { n as f64 }\n}\n\n// These 4 are all equivalent in this case.\nlet _: f64 = Num::from_i32(42);\nlet _: f64 = <_ as Num>::from_i32(42);\nlet _: f64 = <f64 as Num>::from_i32(42);\nlet _: f64 = f64::from_i32(42);",
      "parent_id": null,
      "paragraphs": {
        "items.associated.fn.intro": "*Associated functions* are [functions] associated with a type.",
        "items.associated.fn.decl": "An *associated function declaration* declares a signature for an associated\nfunction definition. It is written as a function item, except the\nfunction body is replaced with a `;`.",
        "items.associated.name": "The identifier is the name of the function.",
        "items.associated.same-signature": "The generics, parameter list, return type, and where clause of the associated function must be the same as the\nassociated function declarations's.",
        "items.associated.fn.def": "An *associated function definition* defines a function associated with another\ntype. It is written the same as a [function item].\n\n> [!NOTE]\n> A common example is an associated function named `new` that returns a value of the type with which it is associated.\n\nstruct Struct {\n    field: i32\n}\n\nimpl Struct {\n    fn new() -> Struct {\n        Struct {\n            field: 0i32\n        }\n    }\n}\n\nfn main () {\n    let _struct = Struct::new();\n}",
        "items.associated.fn.qualified-self": "When the associated function is declared on a trait, the function can also be\ncalled with a [path] that is a path to the trait appended by the name of the\ntrait. When this happens, it is substituted for `<_ as Trait>::function_name`.\n\ntrait Num {\n    fn from_i32(n: i32) -> Self;\n}\n\nimpl Num for f64 {\n    fn from_i32(n: i32) -> f64 { n as f64 }\n}\n\n// These 4 are all equivalent in this case.\nlet _: f64 = Num::from_i32(42);\nlet _: f64 = <_ as Num>::from_i32(42);\nlet _: f64 = <f64 as Num>::from_i32(42);\nlet _: f64 = f64::from_i32(42);"
      }
    },
    {
      "id": "items.associated.fn.method",
      "title": "Methods",
      "level": 2,
      "content": "Associated functions whose first parameter is named `self` are called *methods*\nand may be invoked using the [method call operator], for example, `x.foo()`, as\nwell as the usual function call notation.\n\nIf the type of the `self` parameter is specified, it is limited to types resolving\nto one generated by the following grammar (where `'lt` denotes some arbitrary\nlifetime):\n\nP = &'lt S | &'lt mut S | Box<S> | Rc<S> | Arc<S> | Pin<P>\nS = Self | P\n\nThe `Self` terminal in this grammar denotes a type resolving to the implementing type.\nThis can also include the contextual type alias `Self`, other type aliases,\nor associated type projections resolving to the implementing type.\n\n# use std::rc::Rc;\n# use std::sync::Arc;\n# use std::pin::Pin;\n// Examples of methods implemented on struct `Example`.\nstruct Example;\ntype Alias = Example;\ntrait Trait { type Output; }\nimpl Trait for Example { type Output = Example; }\nimpl Example {\n    fn by_value(self: Self) {}\n    fn by_ref(self: &Self) {}\n    fn by_ref_mut(self: &mut Self) {}\n    fn by_box(self: Box<Self>) {}\n    fn by_rc(self: Rc<Self>) {}\n    fn by_arc(self: Arc<Self>) {}\n    fn by_pin(self: Pin<&Self>) {}\n    fn explicit_type(self: Arc<Example>) {}\n    fn with_lifetime<'a>(self: &'a Self) {}\n    fn nested<'a>(self: &mut &'a Arc<Rc<Box<Alias>>>) {}\n    fn via_projection(self: <Example as Trait>::Output) {}\n}\n\nShorthand syntax can be used without specifying a type, which have the\nfollowing equivalents:\n\nShorthand             | Equivalent\n----------------------|-----------\n`self`                | `self: Self`\n`&'lifetime self`     | `self: &'lifetime Self`\n`&'lifetime mut self` | `self: &'lifetime mut Self`\n\n> [!NOTE]\n> Lifetimes can be, and usually are, elided with this shorthand.\n\nIf the `self` parameter is prefixed with `mut`, it becomes a mutable variable,\nsimilar to regular parameters using a `mut` [identifier pattern]. For example:\n\ntrait Changer: Sized {\n    fn change(mut self) {}\n    fn modify(mut self: Box<Self>) {}\n}\n\nAs an example of methods on a trait, consider the following:\n\n# type Surface = i32;\n# type BoundingBox = i32;\ntrait Shape {\n    fn draw(&self, surface: Surface);\n    fn bounding_box(&self) -> BoundingBox;\n}\n\nThis defines a trait with two methods. All values that have [implementations]\nof this trait while the trait is in scope can have their `draw` and\n`bounding_box` methods called.\n\n# type Surface = i32;\n# type BoundingBox = i32;\n# trait Shape {\n#     fn draw(&self, surface: Surface);\n#     fn bounding_box(&self) -> BoundingBox;\n# }\n#\nstruct Circle {\n    // ...\n}\n\nimpl Shape for Circle {\n    // ...\n#   fn draw(&self, _: Surface) {}\n#   fn bounding_box(&self) -> BoundingBox { 0i32 }\n}\n\n# impl Circle {\n#     fn new() -> Circle { Circle{} }\n# }\n#\nlet circle_shape = Circle::new();\nlet bounding_box = circle_shape.bounding_box();\n\n> [!EDITION-2018]\n> In the 2015 edition, it is possible to declare trait methods with anonymous parameters (e.g. `fn foo(u8)`). This is deprecated and an error as of the 2018 edition. All parameters must have an argument name.",
      "parent_id": null,
      "paragraphs": {
        "items.associated.fn.method.intro": "Associated functions whose first parameter is named `self` are called *methods*\nand may be invoked using the [method call operator], for example, `x.foo()`, as\nwell as the usual function call notation.",
        "items.associated.fn.method.self-ty": "If the type of the `self` parameter is specified, it is limited to types resolving\nto one generated by the following grammar (where `'lt` denotes some arbitrary\nlifetime):\n\nP = &'lt S | &'lt mut S | Box<S> | Rc<S> | Arc<S> | Pin<P>\nS = Self | P\n\nThe `Self` terminal in this grammar denotes a type resolving to the implementing type.\nThis can also include the contextual type alias `Self`, other type aliases,\nor associated type projections resolving to the implementing type.\n\n# use std::rc::Rc;\n# use std::sync::Arc;\n# use std::pin::Pin;\n// Examples of methods implemented on struct `Example`.\nstruct Example;\ntype Alias = Example;\ntrait Trait { type Output; }\nimpl Trait for Example { type Output = Example; }\nimpl Example {\n    fn by_value(self: Self) {}\n    fn by_ref(self: &Self) {}\n    fn by_ref_mut(self: &mut Self) {}\n    fn by_box(self: Box<Self>) {}\n    fn by_rc(self: Rc<Self>) {}\n    fn by_arc(self: Arc<Self>) {}\n    fn by_pin(self: Pin<&Self>) {}\n    fn explicit_type(self: Arc<Example>) {}\n    fn with_lifetime<'a>(self: &'a Self) {}\n    fn nested<'a>(self: &mut &'a Arc<Rc<Box<Alias>>>) {}\n    fn via_projection(self: <Example as Trait>::Output) {}\n}",
        "associated.fn.method.self-pat-shorthands": "Shorthand syntax can be used without specifying a type, which have the\nfollowing equivalents:\n\nShorthand             | Equivalent\n----------------------|-----------\n`self`                | `self: Self`\n`&'lifetime self`     | `self: &'lifetime Self`\n`&'lifetime mut self` | `self: &'lifetime mut Self`\n\n> [!NOTE]\n> Lifetimes can be, and usually are, elided with this shorthand.",
        "associated.fn.method.self-pat-mut": "If the `self` parameter is prefixed with `mut`, it becomes a mutable variable,\nsimilar to regular parameters using a `mut` [identifier pattern]. For example:\n\ntrait Changer: Sized {\n    fn change(mut self) {}\n    fn modify(mut self: Box<Self>) {}\n}\n\nAs an example of methods on a trait, consider the following:\n\n# type Surface = i32;\n# type BoundingBox = i32;\ntrait Shape {\n    fn draw(&self, surface: Surface);\n    fn bounding_box(&self) -> BoundingBox;\n}\n\nThis defines a trait with two methods. All values that have [implementations]\nof this trait while the trait is in scope can have their `draw` and\n`bounding_box` methods called.\n\n# type Surface = i32;\n# type BoundingBox = i32;\n# trait Shape {\n#     fn draw(&self, surface: Surface);\n#     fn bounding_box(&self) -> BoundingBox;\n# }\n#\nstruct Circle {\n    // ...\n}\n\nimpl Shape for Circle {\n    // ...\n#   fn draw(&self, _: Surface) {}\n#   fn bounding_box(&self) -> BoundingBox { 0i32 }\n}\n\n# impl Circle {\n#     fn new() -> Circle { Circle{} }\n# }\n#\nlet circle_shape = Circle::new();\nlet bounding_box = circle_shape.bounding_box();",
        "items.associated.fn.params.edition2018": "> [!EDITION-2018]\n> In the 2015 edition, it is possible to declare trait methods with anonymous parameters (e.g. `fn foo(u8)`). This is deprecated and an error as of the 2018 edition. All parameters must have an argument name."
      }
    },
    {
      "id": "items.associated.fn.param-attributes",
      "title": "Attributes on method parameters",
      "level": 1,
      "content": "Attributes on method parameters follow the same rules and restrictions as\n[regular function parameters].",
      "parent_id": null,
      "paragraphs": {
        "items.associated.fn.param-attributes": "Attributes on method parameters follow the same rules and restrictions as\n[regular function parameters]."
      }
    },
    {
      "id": "items.associated.type",
      "title": "Associated types",
      "level": 4,
      "content": "*Associated types* are [type aliases] associated with another type.\n\nAssociated types cannot be defined in [inherent implementations] nor can they be given a\ndefault implementation in traits.\n\nAn *associated type declaration* declares a signature for associated type\ndefinitions. It is written in one of the following forms, where `Assoc` is the\nname of the associated type, `Params` is a comma-separated list of type,\nlifetime or const parameters, `Bounds` is a plus-separated list of trait bounds\nthat the associated type must meet, and `WhereBounds` is a comma-separated list\nof bounds that the parameters must meet:\n\n<!-- ignore: illustrative example forms -->\n,ignore\ntype Assoc;\ntype Assoc: Bounds;\ntype Assoc<Params>;\ntype Assoc<Params>: Bounds;\ntype Assoc<Params> where WhereBounds;\ntype Assoc<Params>: Bounds where WhereBounds;\n\nThe identifier is the name of the declared type alias.\n\nThe optional trait bounds must be fulfilled by the implementations of the type alias.\n\nThere is an implicit [`Sized`] bound on associated types that can be relaxed using the special `?Sized` bound.\n\nAn *associated type definition* defines a type alias for the implementation\nof a trait on a type.\n\nThey are written similarly to an *associated type declaration*, but cannot contain `Bounds`, but instead must contain a `Type`:\n\n<!-- ignore: illustrative example forms -->\n,ignore\ntype Assoc = Type;\ntype Assoc<Params> = Type; // the type `Type` here may reference `Params`\ntype Assoc<Params> = Type where WhereBounds;\ntype Assoc<Params> where WhereBounds = Type; // deprecated, prefer the form above\n\nIf a type `Item` has an associated type `Assoc` from a trait `Trait`, then\n`<Item as Trait>::Assoc` is a type that is an alias of the type specified in the\nassociated type definition.\n\nFurthermore, if `Item` is a type parameter, then `Item::Assoc` can be used in type parameters.\n\nAssociated types may include [generic parameters] and [where clauses]; these are\noften referred to as *generic associated types*, or *GATs*. If the type `Thing`\nhas an associated type `Item` from a trait `Trait` with the generics `<'a>` , the\ntype can be named like `<Thing as Trait>::Item<'x>`, where `'x` is some lifetime\nin scope. In this case, `'x` will be used wherever `'a` appears in the associated\ntype definitions on impls.\n\ntrait AssociatedType {\n    // Associated type declaration\n    type Assoc;\n}\n\nstruct Struct;\n\nstruct OtherStruct;\n\nimpl AssociatedType for Struct {\n    // Associated type definition\n    type Assoc = OtherStruct;\n}\n\nimpl OtherStruct {\n    fn new() -> OtherStruct {\n        OtherStruct\n    }\n}\n\nfn main() {\n    // Usage of the associated type to refer to OtherStruct as <Struct as AssociatedType>::Assoc\n    let _other_struct: OtherStruct = <Struct as AssociatedType>::Assoc::new();\n}\n\nAn example of associated types with generics and where clauses:\n\nstruct ArrayLender<'a, T>(&'a mut [T; 16]);\n\ntrait Lend {\n    // Generic associated type declaration\n    type Lender<'a> where Self: 'a;\n    fn lend<'a>(&'a mut self) -> Self::Lender<'a>;\n}\n\nimpl<T> Lend for [T; 16] {\n    // Generic associated type definition\n    type Lender<'a> = ArrayLender<'a, T> where Self: 'a;\n\n    fn lend<'a>(&'a mut self) -> Self::Lender<'a> {\n        ArrayLender(self)\n    }\n}\n\nfn borrow<'a, T: Lend>(array: &'a mut T) -> <T as Lend>::Lender<'a> {\n    array.lend()\n}\n\nfn main() {\n    let mut array = [0usize; 16];\n    let lender = borrow(&mut array);\n}\n\n### Associated types container example\n\nConsider the following example of a `Container` trait. Notice that the type is\navailable for use in the method signatures:\n\ntrait Container {\n    type E;\n    fn empty() -> Self;\n    fn insert(&mut self, elem: Self::E);\n}\n\nIn order for a type to implement this trait, it must not only provide\nimplementations for every method, but it must specify the type `E`. Here's an\nimplementation of `Container` for the standard library type `Vec`:\n\n# trait Container {\n#     type E;\n#     fn empty() -> Self;\n#     fn insert(&mut self, elem: Self::E);\n# }\nimpl<T> Container for Vec<T> {\n    type E = T;\n    fn empty() -> Vec<T> { Vec::new() }\n    fn insert(&mut self, x: T) { self.push(x); }\n}\n\n### Relationship between `Bounds` and `WhereBounds`\n\nIn this example:\n\n# use std::fmt::Debug;\ntrait Example {\n    type Output<T>: Ord where T: Debug;\n}\n\nGiven a reference to the associated type like `<X as Example>::Output<Y>`, the associated type itself must be `Ord`, and the type `Y` must be `Debug`.",
      "parent_id": null,
      "paragraphs": {
        "items.associated.type.intro": "*Associated types* are [type aliases] associated with another type.",
        "items.associated.type.restrictions": "Associated types cannot be defined in [inherent implementations] nor can they be given a\ndefault implementation in traits.",
        "items.associated.type.decl": "An *associated type declaration* declares a signature for associated type\ndefinitions. It is written in one of the following forms, where `Assoc` is the\nname of the associated type, `Params` is a comma-separated list of type,\nlifetime or const parameters, `Bounds` is a plus-separated list of trait bounds\nthat the associated type must meet, and `WhereBounds` is a comma-separated list\nof bounds that the parameters must meet:\n\n<!-- ignore: illustrative example forms -->\n,ignore\ntype Assoc;\ntype Assoc: Bounds;\ntype Assoc<Params>;\ntype Assoc<Params>: Bounds;\ntype Assoc<Params> where WhereBounds;\ntype Assoc<Params>: Bounds where WhereBounds;",
        "items.associated.type.name": "The identifier is the name of the declared type alias.",
        "items.associated.type.impl-fulfillment": "The optional trait bounds must be fulfilled by the implementations of the type alias.",
        "items.associated.type.sized": "There is an implicit [`Sized`] bound on associated types that can be relaxed using the special `?Sized` bound.",
        "items.associated.type.def": "An *associated type definition* defines a type alias for the implementation\nof a trait on a type.",
        "items.associated.type.def.restriction": "They are written similarly to an *associated type declaration*, but cannot contain `Bounds`, but instead must contain a `Type`:\n\n<!-- ignore: illustrative example forms -->\n,ignore\ntype Assoc = Type;\ntype Assoc<Params> = Type; // the type `Type` here may reference `Params`\ntype Assoc<Params> = Type where WhereBounds;\ntype Assoc<Params> where WhereBounds = Type; // deprecated, prefer the form above",
        "items.associated.type.alias": "If a type `Item` has an associated type `Assoc` from a trait `Trait`, then\n`<Item as Trait>::Assoc` is a type that is an alias of the type specified in the\nassociated type definition.",
        "items.associated.type.param": "Furthermore, if `Item` is a type parameter, then `Item::Assoc` can be used in type parameters.",
        "items.associated.type.generic": "Associated types may include [generic parameters] and [where clauses]; these are\noften referred to as *generic associated types*, or *GATs*. If the type `Thing`\nhas an associated type `Item` from a trait `Trait` with the generics `<'a>` , the\ntype can be named like `<Thing as Trait>::Item<'x>`, where `'x` is some lifetime\nin scope. In this case, `'x` will be used wherever `'a` appears in the associated\ntype definitions on impls.\n\ntrait AssociatedType {\n    // Associated type declaration\n    type Assoc;\n}\n\nstruct Struct;\n\nstruct OtherStruct;\n\nimpl AssociatedType for Struct {\n    // Associated type definition\n    type Assoc = OtherStruct;\n}\n\nimpl OtherStruct {\n    fn new() -> OtherStruct {\n        OtherStruct\n    }\n}\n\nfn main() {\n    // Usage of the associated type to refer to OtherStruct as <Struct as AssociatedType>::Assoc\n    let _other_struct: OtherStruct = <Struct as AssociatedType>::Assoc::new();\n}\n\nAn example of associated types with generics and where clauses:\n\nstruct ArrayLender<'a, T>(&'a mut [T; 16]);\n\ntrait Lend {\n    // Generic associated type declaration\n    type Lender<'a> where Self: 'a;\n    fn lend<'a>(&'a mut self) -> Self::Lender<'a>;\n}\n\nimpl<T> Lend for [T; 16] {\n    // Generic associated type definition\n    type Lender<'a> = ArrayLender<'a, T> where Self: 'a;\n\n    fn lend<'a>(&'a mut self) -> Self::Lender<'a> {\n        ArrayLender(self)\n    }\n}\n\nfn borrow<'a, T: Lend>(array: &'a mut T) -> <T as Lend>::Lender<'a> {\n    array.lend()\n}\n\nfn main() {\n    let mut array = [0usize; 16];\n    let lender = borrow(&mut array);\n}\n\n### Associated types container example\n\nConsider the following example of a `Container` trait. Notice that the type is\navailable for use in the method signatures:\n\ntrait Container {\n    type E;\n    fn empty() -> Self;\n    fn insert(&mut self, elem: Self::E);\n}\n\nIn order for a type to implement this trait, it must not only provide\nimplementations for every method, but it must specify the type `E`. Here's an\nimplementation of `Container` for the standard library type `Vec`:\n\n# trait Container {\n#     type E;\n#     fn empty() -> Self;\n#     fn insert(&mut self, elem: Self::E);\n# }\nimpl<T> Container for Vec<T> {\n    type E = T;\n    fn empty() -> Vec<T> { Vec::new() }\n    fn insert(&mut self, x: T) { self.push(x); }\n}\n\n### Relationship between `Bounds` and `WhereBounds`\n\nIn this example:\n\n# use std::fmt::Debug;\ntrait Example {\n    type Output<T>: Ord where T: Debug;\n}\n\nGiven a reference to the associated type like `<X as Example>::Output<Y>`, the associated type itself must be `Ord`, and the type `Y` must be `Debug`."
      }
    },
    {
      "id": "items.associated.type.generic-where-clause",
      "title": "Required where clauses on generic associated types",
      "level": 1,
      "content": "Generic associated type declarations on traits currently may require a list of\nwhere clauses, dependent on functions in the trait and how the GAT is used. These\nrules may be loosened in the future; updates can be found on the generic\nassociated types initiative repository.\n\nIn a few words, these where clauses are required in order to maximize the allowed\ndefinitions of the associated type in impls. To do this, any clauses that *can be\nproven to hold* on functions (using the parameters of the function or trait)\nwhere a GAT appears as an input or output must also be written on the GAT itself.\n\ntrait LendingIterator {\n    type Item<'x> where Self: 'x;\n    fn next<'a>(&'a mut self) -> Self::Item<'a>;\n}\n\nIn the above, on the `next` function, we can prove that `Self: 'a`, because of\nthe implied bounds from `&'a mut self`; therefore, we must write the equivalent\nbound on the GAT itself: `where Self: 'x`.\n\nWhen there are multiple functions in a trait that use the GAT, then the\n*intersection* of the bounds from the different functions are used, rather than\nthe union.\n\ntrait Check<T> {\n    type Checker<'x>;\n    fn create_checker<'a>(item: &'a T) -> Self::Checker<'a>;\n    fn do_check(checker: Self::Checker<'_>);\n}\n\nIn this example, no bounds are required on the `type Checker<'a>;`. While we\nknow that `T: 'a` on `create_checker`, we do not know that on `do_check`. However,\nif `do_check` was commented out, then the `where T: 'x` bound would be required\non `Checker`.\n\nThe bounds on associated types also propagate required where clauses.\n\ntrait Iterable {\n    type Item<'a> where Self: 'a;\n    type Iterator<'a>: Iterator<Item = Self::Item<'a>> where Self: 'a;\n    fn iter<'a>(&'a self) -> Self::Iterator<'a>;\n}\n\nHere, `where Self: 'a` is required on `Item` because of `iter`. However, `Item`\nis used in the bounds of `Iterator`, the `where Self: 'a` clause is also required\nthere.\n\nFinally, any explicit uses of `'static` on GATs in the trait do not count towards\nthe required bounds.\n\ntrait StaticReturn {\n    type Y<'a>;\n    fn foo(&self) -> Self::Y<'static>;\n}",
      "parent_id": null,
      "paragraphs": {
        "items.associated.type.generic-where-clause.intro": "Generic associated type declarations on traits currently may require a list of\nwhere clauses, dependent on functions in the trait and how the GAT is used. These\nrules may be loosened in the future; updates can be found on the generic\nassociated types initiative repository.",
        "items.associated.type.generic-where-clause.valid-fn": "In a few words, these where clauses are required in order to maximize the allowed\ndefinitions of the associated type in impls. To do this, any clauses that *can be\nproven to hold* on functions (using the parameters of the function or trait)\nwhere a GAT appears as an input or output must also be written on the GAT itself.\n\ntrait LendingIterator {\n    type Item<'x> where Self: 'x;\n    fn next<'a>(&'a mut self) -> Self::Item<'a>;\n}\n\nIn the above, on the `next` function, we can prove that `Self: 'a`, because of\nthe implied bounds from `&'a mut self`; therefore, we must write the equivalent\nbound on the GAT itself: `where Self: 'x`.",
        "items.associated.type.generic-where-clause.intersection": "When there are multiple functions in a trait that use the GAT, then the\n*intersection* of the bounds from the different functions are used, rather than\nthe union.\n\ntrait Check<T> {\n    type Checker<'x>;\n    fn create_checker<'a>(item: &'a T) -> Self::Checker<'a>;\n    fn do_check(checker: Self::Checker<'_>);\n}\n\nIn this example, no bounds are required on the `type Checker<'a>;`. While we\nknow that `T: 'a` on `create_checker`, we do not know that on `do_check`. However,\nif `do_check` was commented out, then the `where T: 'x` bound would be required\non `Checker`.",
        "items.associated.type.generic-where-clause.forward": "The bounds on associated types also propagate required where clauses.\n\ntrait Iterable {\n    type Item<'a> where Self: 'a;\n    type Iterator<'a>: Iterator<Item = Self::Item<'a>> where Self: 'a;\n    fn iter<'a>(&'a self) -> Self::Iterator<'a>;\n}\n\nHere, `where Self: 'a` is required on `Item` because of `iter`. However, `Item`\nis used in the bounds of `Iterator`, the `where Self: 'a` clause is also required\nthere.",
        "items.associated.type.generic-where-clause.static": "Finally, any explicit uses of `'static` on GATs in the trait do not count towards\nthe required bounds.\n\ntrait StaticReturn {\n    type Y<'a>;\n    fn foo(&self) -> Self::Y<'static>;\n}"
      }
    },
    {
      "id": "items.associated.const",
      "title": "Associated constants",
      "level": 3,
      "content": "*Associated constants* are [constants] associated with a type.\n\nAn *associated constant declaration* declares a signature for associated\nconstant definitions. It is written as `const`, then an identifier,\nthen `:`, then a type, finished by a `;`.\n\nThe identifier is the name of the constant used in the path. The type is the\ntype that the definition has to implement.\n\nAn *associated constant definition* defines a constant associated with a\ntype. It is written the same as a [constant item].\n\nAssociated constant definitions undergo [constant evaluation] only when\nreferenced. Further, definitions that include [generic parameters] are\nevaluated after monomorphization.\n\n,compile_fail\nstruct Struct;\nstruct GenericStruct<const ID: i32>;\n\nimpl Struct {\n    // Definition not immediately evaluated\n    const PANIC: () = panic!(\"compile-time panic\");\n}\n\nimpl<const ID: i32> GenericStruct<ID> {\n    // Definition not immediately evaluated\n    const NON_ZERO: () = if ID == 0 {\n        panic!(\"contradiction\")\n    };\n}\n\nfn main() {\n    // Referencing Struct::PANIC causes compilation error\n    let _ = Struct::PANIC;\n\n    // Fine, ID is not 0\n    let _ = GenericStruct::<1>::NON_ZERO;\n\n    // Compilation error from evaluating NON_ZERO with ID=0\n    let _ = GenericStruct::<0>::NON_ZERO;\n}\n\n### Associated constants examples\n\nA basic example:\n\ntrait ConstantId {\n    const ID: i32;\n}\n\nstruct Struct;\n\nimpl ConstantId for Struct {\n    const ID: i32 = 1;\n}\n\nfn main() {\n    assert_eq!(1, Struct::ID);\n}\n\nUsing default values:\n\ntrait ConstantIdDefault {\n    const ID: i32 = 1;\n}\n\nstruct Struct;\nstruct OtherStruct;\n\nimpl ConstantIdDefault for Struct {}\n\nimpl ConstantIdDefault for OtherStruct {\n    const ID: i32 = 5;\n}\n\nfn main() {\n    assert_eq!(1, Struct::ID);\n    assert_eq!(5, OtherStruct::ID);\n}\n\n[`Arc<Self>`]: ../special-types-and-traits.md#arct\n[`Box<Self>`]: ../special-types-and-traits.md#boxt\n[`Pin<P>`]: ../special-types-and-traits.md#pinp\n[`Rc<Self>`]: ../special-types-and-traits.md#rct\n[`Sized`]: ../special-types-and-traits.md#sized\n[traits]: traits.md\n[type aliases]: type-aliases.md\n[inherent implementations]: implementations.md#inherent-implementations\n[identifier]: ../identifiers.md\n[identifier pattern]: ../patterns.md#identifier-patterns\n[implementations]: implementations.md\n[type]: ../types.md#type-expressions\n[constants]: constant-items.md\n[constant item]: constant-items.md\n[functions]: functions.md\n[function item]: ../types/function-item.md\n[method call operator]: ../expressions/method-call-expr.md\n[path]: ../paths.md\n[regular function parameters]: functions.md#attributes-on-function-parameters\n[generic parameters]: generics.md\n[where clauses]: generics.md#where-clauses\n[constant evaluation]: ../const_eval.md",
      "parent_id": null,
      "paragraphs": {
        "items.associated.const.intro": "*Associated constants* are [constants] associated with a type.",
        "items.associated.const.decl": "An *associated constant declaration* declares a signature for associated\nconstant definitions. It is written as `const`, then an identifier,\nthen `:`, then a type, finished by a `;`.",
        "items.associated.const.name": "The identifier is the name of the constant used in the path. The type is the\ntype that the definition has to implement.",
        "items.associated.const.def": "An *associated constant definition* defines a constant associated with a\ntype. It is written the same as a [constant item].",
        "items.associated.const.eval": "Associated constant definitions undergo [constant evaluation] only when\nreferenced. Further, definitions that include [generic parameters] are\nevaluated after monomorphization.\n\n,compile_fail\nstruct Struct;\nstruct GenericStruct<const ID: i32>;\n\nimpl Struct {\n    // Definition not immediately evaluated\n    const PANIC: () = panic!(\"compile-time panic\");\n}\n\nimpl<const ID: i32> GenericStruct<ID> {\n    // Definition not immediately evaluated\n    const NON_ZERO: () = if ID == 0 {\n        panic!(\"contradiction\")\n    };\n}\n\nfn main() {\n    // Referencing Struct::PANIC causes compilation error\n    let _ = Struct::PANIC;\n\n    // Fine, ID is not 0\n    let _ = GenericStruct::<1>::NON_ZERO;\n\n    // Compilation error from evaluating NON_ZERO with ID=0\n    let _ = GenericStruct::<0>::NON_ZERO;\n}\n\n### Associated constants examples\n\nA basic example:\n\ntrait ConstantId {\n    const ID: i32;\n}\n\nstruct Struct;\n\nimpl ConstantId for Struct {\n    const ID: i32 = 1;\n}\n\nfn main() {\n    assert_eq!(1, Struct::ID);\n}\n\nUsing default values:\n\ntrait ConstantIdDefault {\n    const ID: i32 = 1;\n}\n\nstruct Struct;\nstruct OtherStruct;\n\nimpl ConstantIdDefault for Struct {}\n\nimpl ConstantIdDefault for OtherStruct {\n    const ID: i32 = 5;\n}\n\nfn main() {\n    assert_eq!(1, Struct::ID);\n    assert_eq!(5, OtherStruct::ID);\n}\n\n[`Arc<Self>`]: ../special-types-and-traits.md#arct\n[`Box<Self>`]: ../special-types-and-traits.md#boxt\n[`Pin<P>`]: ../special-types-and-traits.md#pinp\n[`Rc<Self>`]: ../special-types-and-traits.md#rct\n[`Sized`]: ../special-types-and-traits.md#sized\n[traits]: traits.md\n[type aliases]: type-aliases.md\n[inherent implementations]: implementations.md#inherent-implementations\n[identifier]: ../identifiers.md\n[identifier pattern]: ../patterns.md#identifier-patterns\n[implementations]: implementations.md\n[type]: ../types.md#type-expressions\n[constants]: constant-items.md\n[constant item]: constant-items.md\n[functions]: functions.md\n[function item]: ../types/function-item.md\n[method call operator]: ../expressions/method-call-expr.md\n[path]: ../paths.md\n[regular function parameters]: functions.md#attributes-on-function-parameters\n[generic parameters]: generics.md\n[where clauses]: generics.md#where-clauses\n[constant evaluation]: ../const_eval.md"
      }
    }
  ],
  "ids": [
    "items.static.generics",
    "items.extern.abi.cdecl",
    "items.const.syntax",
    "items.struct.intro",
    "items.fn.extern.def",
    "items.enum.constructor-namespace",
    "items.extern-crate.self",
    "items.generics.const.standalone",
    "items.impl.trait.orphan-rule.general",
    "items.extern.abi.standard",
    "items.enum.discriminant.repr-rust",
    "items.const.behavior",
    "items.extern.namespace",
    "items.associated.const.def",
    "items.fn.generics.intro",
    "items.mod.outlined.path",
    "items.static.mut",
    "items.traits.impls",
    "items.fn.async.intro",
    "items.extern.attributes.link.modifiers.multiple",
    "items.intro",
    "items.generics.syntax.intro",
    "items.extern.attributes.fn-parameters",
    "items.static.read-only",
    "items.traits.associated-item-namespaces",
    "items.fn.extern.foreign-call",
    "items.enum.discriminant.coercion",
    "items.associated.type.sized",
    "items.use.path.edition2018",
    "items.union.init.result",
    "items.static.syntax",
    "items.fn.params.intro",
    "items.fn.extern.unwind.intro",
    "items.impl.generics.intro",
    "items.impl.inherent.type-alias",
    "items.associated.const.eval",
    "items.generics.const.argument",
    "items.generics.const.namespace",
    "items.fn.extern.unwind",
    "items.mod.attributes",
    "items.fn.body.intro",
    "items.const.intro",
    "items.static.mut.extern",
    "items.extern.attributes.link.import_name_type.variables",
    "items.const.static",
    "items.fn.params.self-pat",
    "items.associated.trait-items",
    "items.extern.attributes.link.modifiers.bundle.allowed-kinds",
    "items.const.unnamed.repetition",
    "items.enum.discriminant.coercion.fieldless",
    "items.extern.attributes.link.modifiers.whole-archive.allowed-kinds",
    "items.extern.fn.safety",
    "items.associated.same-signature",
    "items.extern-crate.no_link.syntax",
    "items.traits.dyn-compatible.associated-functions",
    "items.use.restrictions",
    "items.enum.discriminant.coercion.intro",
    "items.traits.dyn-compatible.intro",
    "items.extern.attributes.link.import_name_type.default",
    "items.traits.intro",
    "items.fn.param-attributes",
    "items.associated.type.name",
    "items.enum.constructor-names",
    "items.extern.attributes.link.raw-dylib",
    "items.associated.fn.def",
    "items.generics",
    "items.traits.dyn-compatible.supertraits",
    "items.extern.abi.intro",
    "items.mod.intro",
    "items.union.fields.intro",
    "items.extern.attributes.link.intro",
    "items.generics.where.intro",
    "items.extern.attributes.link.modifiers.bundle.default",
    "items.extern.unsafe-required",
    "items.impl.inherent.associated-items.allowed-items",
    "items.traits.safety",
    "items.type.constructor-alias",
    "items.traits.supertraits.subtrait",
    "items.enum.discriminant",
    "items.enum.struct-expr",
    "items.extern.attributes.link.modifiers.bundle.no-effect",
    "associated.fn.method.self-pat-mut",
    "items.use.as-underscore.glob",
    "items.union.field-references",
    "items.type.associated-trait",
    "items.extern.fn.param-patterns",
    "items.use.path.disallowed",
    "items.enum.discriminant.explicit.intro",
    "items.enum.intro",
    "items.enum.discriminant.implicit",
    "items.extern.variadic",
    "items.struct.namespace",
    "items.impl.inherent.intro",
    "items.fn.attributes.intro",
    "items.associated.type.generic-where-clause",
    "items.extern-crate.underscore.macro_use",
    "items.extern.attributes.link_ordinal.allowed-kinds",
    "items.associated.fn.method.self-ty",
    "items.traits.safety.intro",
    "items.impl.inherent",
    "items.extern.attributes.link.dylib",
    "items.fn.safety-qualifiers",
    "items.static.sync",
    "items.extern.attributes.link_name.duplicates",
    "items.associated.type.decl",
    "items.extern.attributes.link.modifiers.verbatim.behavior-negative",
    "items.mod.outlined.path.search-nested",
    "items.const.destructor",
    "items.static.safety",
    "items.extern.attributes.link_name.syntax",
    "items.enum.discriminant.restrictions",
    "items.extern.syntax",
    "items.union.syntax",
    "items.use.self",
    "items.use.restrictions.self",
    "items.traits.namespace",
    "items.extern.attributes.link.framework",
    "items.associated.fn.decl",
    "items.extern.attributes.link.kind-raw-dylib.intro",
    "items.enum.discriminant.access-memory",
    "items.static.namespace",
    "items.impl.trait.intro",
    "items.fn.generics.param-names",
    "items.impl.trait.implemented-trait",
    "items.fn.body.bodyless",
    "items.fn.async.future",
    "items.associated.type.impl-fulfillment",
    "items.extern.static.read-only",
    "items.traits.associated-visibility.intro",
    "items.associated.type.intro",
    "items.fn.extern.default-abi",
    "items.extern-crate.no_link.allowed-positions",
    "items.use.as",
    "items.union.fields",
    "items.enum.namespace",
    "items.use.as-underscore",
    "items.enum.syntax",
    "items.use.glob.shadowing",
    "items.traits.dyn-compatible.associated-types",
    "items.enum.discriminant.access-opaque",
    "items.fn.params.self-restriction",
    "items.static.mut.safety",
    "items.extern.attributes.link.modifiers.verbatim.behavior",
    "items.mod.def",
    "items.fn.async.param-capture",
    "items.static.mut.sync",
    "items.extern.attributes.link.import_name_type",
    "items.extern.attributes.intro",
    "items.extern-crate.intro",
    "items.extern.attributes.link.kind-raw-dylib",
    "items.associated.const.decl",
    "items.union.init.intro",
    "items.extern.attributes.link.syntax",
    "items.impl.trait.coherence",
    "items.fn.attributes.builtin-attributes",
    "items.extern.attributes.link.modifiers.verbatim.default",
    "items.fn.const",
    "items.enum.variant-visibility",
    "items.extern.abi.c",
    "items.associated.fn.method.intro",
    "items.fn.generics.param-bounds",
    "items.use.restrictions.macro-crate",
    "items",
    "items.fn.attributes",
    "items.fn.body",
    "items.associated.type",
    "items.extern.attributes.link.modifiers.verbatim.allowed-kinds",
    "items.const.static-temporary",
    "items.impl.trait.safety",
    "items.traits.params.patterns-no-body",
    "items.associated.syntax",
    "items.fn.param-attributes.intro",
    "items.generics.const.allowed-types",
    "items.union.pattern.intro",
    "items.extern.abi.efiapi",
    "items.generics.invalid-lifetimes",
    "items.mod.outlined.path.intro",
    "items.extern.attributes.link.kind-raw-dylib.platform-specific",
    "items.enum",
    "items.associated.type.generic-where-clause.forward",
    "items.use.path",
    "items.associated-locations",
    "items.traits.params.pattern-required.edition2018",
    "items.struct.tuple",
    "items.extern.attributes.link.modifiers",
    "items.extern.abi.fastcall",
    "items.enum.empty",
    "items.associated.type.restrictions",
    "items.enum.discriminant.explicit.primitive-repr",
    "items.traits.generic",
    "items.extern.attributes.link_name",
    "items.generics.const.inferred",
    "items.extern-crate.namespace",
    "items.const",
    "items.generics.syntax",
    "items.impl.trait.uncovered-param",
    "items.mod.outlined",
    "items.union.fields.validity",
    "items.traits.associated-visibility",
    "items.extern.abi.unwind",
    "items.impl.inherent.associated-item-path",
    "items.use.visibility.intro",
    "items.associated.related",
    "items.generics.const.exhaustiveness",
    "items.union.fieldless",
    "items.associated.const",
    "items.extern.variadic.conventions",
    "items.union.init",
    "items.impl.inherent.implementing-type",
    "items.associated.fn",
    "items.syntax",
    "items.extern-crate.underscore.intro",
    "items.extern.static",
    "items.extern.static.safety",
    "items.associated.fn.params.edition2018",
    "items.type.associated-type",
    "items.fn.namespace",
    "items.generics.const.inferred.constraint",
    "items.traits.params",
    "items.fn.param-attributes.parsed-attributes",
    "items.extern.attributes.link.import_name_type.intro",
    "items.extern.attributes.link.modifiers.whole-archive.default",
    "items.use.glob.edition2018",
    "items.static.alternate",
    "items.impl.trait.fundamental",
    "items.generics.where.higher-ranked-lifetimes",
    "items.locations",
    "items.const.namespace",
    "items.generics.const.variance",
    "items.union.ref.borrow",
    "items.use.syntax",
    "items.fn.async.desugar",
    "items.extern.attributes.link",
    "items.union.field-restrictions",
    "items.fn.async",
    "items.associated",
    "items.impl.generics.usage",
    "items.type.deprecated",
    "items.enum.constructor",
    "items.extern.abi.default",
    "items.fn.signature",
    "items.extern.abi.thiscall",
    "items.generics.syntax.decl-order",
    "items.extern-crate.extern-prelude",
    "items.traits.bounds",
    "items.extern-crate",
    "items.type.associated-impl",
    "items.traits.self-param",
    "items.struct.layout",
    "items.generics.const.argument.const-expr",
    "items.use.forms.nesting",
    "items.extern-crate.lookup",
    "items.union.pattern.one-field",
    "items.fn.extern.intro",
    "items.extern.edition2024",
    "items.generics.syntax.scope",
    "items.fn.extern.unwind.behavior",
    "items.fn.generics",
    "items.associated.fn.qualified-self",
    "items.extern.attributes.link.modifiers.bundle.behavior-negative",
    "items.enum.decl",
    "items.fn.syntax",
    "items.use.path.namespace",
    "items.union.common-storage",
    "items.use.self.namespace",
    "items.extern-crate.no_link",
    "items.union.drop",
    "items.static.safety-qualifiers",
    "items.impl.trait.coherence.intro",
    "items.associated.type.alias",
    "items.use.multiple-syntax.intro",
    "items.extern.attributes.link.modifiers.whole-archive.behavior",
    "items.fn.async.lifetime-capture",
    "items.use.multiple-syntax.edition2018",
    "items.use.as-underscore.intro",
    "items.impl",
    "items.impl.inherent.coherence",
    "items.extern.attributes.link_ordinal",
    "items.use.forms.self",
    "items.use.restrictions.crate",
    "items.extern.fn.body",
    "items.use.restrictions.variant",
    "items.mod.multiple-items",
    "items.extern.abi.win64",
    "items.union.intro",
    "items.union",
    "items.extern",
    "items.impl.trait.coherence.overlapping",
    "items.use.path.intro",
    "items.extern.attributes.link.wasm_import_module",
    "items.extern.attributes.link.modifiers.bundle.behavior",
    "items.use.as-underscore.macro",
    "items.fn.params.varargs",
    "items.impl.trait.associated-item-path",
    "items.fn",
    "items.extern.attributes.link.import_name_type.values",
    "items.extern.abi.platform",
    "items.mod.nesting",
    "items.use.self.intro",
    "items.type",
    "items.traits.associated-item-decls",
    "items.generics.where.syntax",
    "items.extern.attributes.link_name.allowed-positions",
    "items.union.fields.read",
    "items.type.syntax",
    "items.union.field-manually-drop",
    "items.generics.where",
    "items.name-resolution",
    "items.static.mut.intro",
    "items.fn.intro",
    "associated.fn.method.self-pat-shorthands",
    "items.struct.syntax",
    "items.associated.type.generic-where-clause.intersection",
    "items.extern.attributes.link.kind-raw-dylib.import",
    "items.fn.extern.abort",
    "items.traits.dyn-compatible.sized",
    "items.use.visibility",
    "items.generics.const.type-ambiguity",
    "items.generics.const.intro",
    "items.union.namespace",
    "items.impl.trait.orphan-rule",
    "items.associated.fn.method",
    "items.static.intro",
    "items.associated.type.generic-where-clause.static",
    "items.extern.attributes.link_ordinal.intro",
    "items.impl.syntax",
    "items.fn.generics.mono",
    "items.extern.attributes.link.static",
    "items.use.multiple-syntax",
    "items.enum.discriminant.explicit.unit-only",
    "items.associated.intro",
    "items.extern.attributes.link.modifiers.bundle",
    "items.generics.const",
    "items.const.unnamed.intro",
    "items.mod.outlined.intro",
    "items.extern.safety",
    "items.traits.dyn-compatible.async-traits",
    "items.mod.attributes.supported",
    "items.mod.namespace",
    "items.union.fields.read-safety",
    "items.mod.unsafe",
    "items.traits.dyn-compatible.associated-consts",
    "items.extern.fn",
    "items.extern.intro",
    "items.static.init.omission",
    "items.extern.attributes.link_name.link_ordinal",
    "items.use.forms.as",
    "items.use.intro",
    "items.enum.tuple-expr",
    "items.fn.params",
    "items.fn.extern.default-extern",
    "items.impl.attributes",
    "items.mod.outlined.search-mod",
    "items.enum.discriminant.explicit",
    "items.static",
    "items.associated.type.param",
    "items.enum.empty.uninhabited",
    "items.traits.const-fn",
    "items.union.field-copy",
    "items.extern.attributes.link.name-requirement",
    "items.use.visibility.unambiguous",
    "items.generics.builtin-generic-types",
    "items.extern.abi.rust",
    "items.associated.const.name",
    "items.const.expr-omission",
    "items.use.glob",
    "items.traits.supertraits.intro",
    "items.associated.type.def",
    "items.extern.abi.platform-unwind-variants",
    "items.use.glob.self-import",
    "items.enum.unit-only",
    "items.extern-crate.name-restrictions",
    "items.generics.const.usage",
    "items.struct.unit",
    "items.associated.type.generic-where-clause.intro",
    "items.decl-order",
    "items.fn.async.safety.intro",
    "items.associated.type.generic-where-clause.valid-fn",
    "items.extern.abi.stdcall",
    "items.union.fields.offset",
    "items.extern-crate.underscore",
    "items.union.ref.intro",
    "items.mod.outlined.search",
    "items.use.forms.multiple",
    "items.extern.fn.qualifiers",
    "items.associated.fn.intro",
    "items.extern-crate.no_link.intro",
    "items.fn.fn-item-type",
    "items.extern-locations",
    "items.fn.async.edition2018",
    "items.mod",
    "items.impl.trait.orphan-rule.intro",
    "items.extern.fn.fn-ptr",
    "items.static.storage-disjointness",
    "items.union.pattern.subpattern",
    "items.extern.fn.foreign-abi",
    "items.extern.abi",
    "items.enum.discriminant.restrictions.same-discriminant",
    "items.impl.trait.def-requirement",
    "items.extern-crate.as",
    "items.extern.abi.sysv64",
    "items.traits.params.patterns-with-body",
    "items.impl.intro",
    "items.union.ref.usage",
    "items.extern.allowed-kinds",
    "items.extern.static.mut",
    "items.generics.syntax.duplicate-params",
    "items.use.restrictions.duplicate-name",
    "items.enum.discriminant.restrictions.above-max-discriminant",
    "items.traits.params.restriction-patterns.edition2018",
    "items.associated.type.def.restriction",
    "items.extern.attributes.link_name.intro",
    "items.use.glob.intro",
    "items.traits.supertraits.decl",
    "items.impl.trait",
    "items.fn.extern",
    "items.extern.static.intro",
    "items.union.fields.write-safety",
    "items.union.pattern",
    "items.generics.attributes",
    "items.associated.kinds",
    "items.static.lifetime",
    "items.associated.name",
    "items.extern-crate.syntax",
    "items.mod.attributes.intro",
    "items.associated.decl-def",
    "items.associated.const.intro",
    "items.traits.dyn-compatible",
    "items.fn.async.safety",
    "items.use.glob.last-segment-only",
    "items.extern-crate.no_link.duplicates",
    "items.use.forms",
    "items.mod.outlined.path.search",
    "items.traits.supertraits",
    "items.extern.attributes.link_ordinal.exclusive",
    "items.union.ref",
    "items.static.init",
    "items.enum.path-expr",
    "items.extern.attributes.link.import_name_type.platform-specific",
    "items.union.pattern.safety",
    "items.impl.generics",
    "items.kinds",
    "items.associated.fn.param-attributes",
    "items.use.multiple-syntax.empty",
    "items.fn.generics.explicit-arguments",
    "items.extern.attributes",
    "items.use",
    "items.extern.attributes.link.modifiers.whole-archive",
    "items.extern.attributes.link.modifiers.verbatim",
    "items.const.unnamed",
    "items.associated.type.generic",
    "items.type.intro",
    "items.union.field-tuple",
    "items.mod.syntax",
    "items.extern.abi.system",
    "items.struct",
    "items.impl.kinds",
    "items.fn.implicit-return",
    "items.extern.abi.aapcs",
    "items.traits.syntax",
    "items.enum.discriminant.intro",
    "items.extern.attributes.link.empty-block",
    "items.enum.empty.intro",
    "items.traits",
    "items.extern.attributes.link.modifiers.syntax",
    "items.use.forms.glob",
    "items.fn.async.desugar-brief",
    "items.const.eval",
    "items.static-def",
    "items.impl.generics.constrain",
    "items.impl.inherent.associated-items",
    "items.enum.fieldless"
  ]
}
