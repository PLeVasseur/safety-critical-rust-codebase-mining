{
  "source": "Rust Reference",
  "source_repo": "https://github.com/rust-lang/reference",
  "extraction_date": "2026-01-03",
  "chapter": 11,
  "title": "Type system",
  "file": "type-system.md",
  "sections": [
    {
      "id": "type_system",
      "title": "Type system",
      "level": 1,
      "content": "# Type system",
      "parent_id": null,
      "paragraphs": {
        "type_system_p1": "# Type system"
      }
    },
    {
      "id": "type",
      "title": "Types",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "type.intro",
      "title": "Types",
      "level": 1,
      "content": "Every variable, item, and value in a Rust program has a type. The _type_ of a\n*value* defines the interpretation of the memory holding it and the operations\nthat may be performed on the value.",
      "parent_id": null,
      "paragraphs": {
        "type.intro": "Every variable, item, and value in a Rust program has a type. The _type_ of a\n*value* defines the interpretation of the memory holding it and the operations\nthat may be performed on the value."
      }
    },
    {
      "id": "type.builtin",
      "title": "Types",
      "level": 1,
      "content": "Built-in types are tightly integrated into the language, in nontrivial ways\nthat are not possible to emulate in user-defined types.",
      "parent_id": null,
      "paragraphs": {
        "type.builtin": "Built-in types are tightly integrated into the language, in nontrivial ways\nthat are not possible to emulate in user-defined types."
      }
    },
    {
      "id": "type.user-defined",
      "title": "Types",
      "level": 1,
      "content": "User-defined types have limited capabilities.",
      "parent_id": null,
      "paragraphs": {
        "type.user-defined": "User-defined types have limited capabilities."
      }
    },
    {
      "id": "type.kinds",
      "title": "Types",
      "level": 1,
      "content": "The list of types is:\n\n* Primitive types:\n    * [Boolean] --- `bool`\n    * [Numeric] --- integer and float\n    * [Textual] --- `char` and `str`\n    * [Never] --- `!` --- a type with no values\n* Sequence types:\n    * [Tuple]\n    * [Array]\n    * [Slice]\n* User-defined types:\n    * [Struct]\n    * [Enum]\n    * [Union]\n* Function types:\n    * [Functions]\n    * [Closures]\n* Pointer types:\n    * [References]\n    * [Raw pointers]\n    * [Function pointers]\n* Trait types:\n    * [Trait objects]\n    * [Impl trait]",
      "parent_id": null,
      "paragraphs": {
        "type.kinds": "The list of types is:\n\n* Primitive types:\n    * [Boolean] --- `bool`\n    * [Numeric] --- integer and float\n    * [Textual] --- `char` and `str`\n    * [Never] --- `!` --- a type with no values\n* Sequence types:\n    * [Tuple]\n    * [Array]\n    * [Slice]\n* User-defined types:\n    * [Struct]\n    * [Enum]\n    * [Union]\n* Function types:\n    * [Functions]\n    * [Closures]\n* Pointer types:\n    * [References]\n    * [Raw pointers]\n    * [Function pointers]\n* Trait types:\n    * [Trait objects]\n    * [Impl trait]"
      }
    },
    {
      "id": "type.name",
      "title": "Type expressions",
      "level": 1,
      "content": ",types\nType ->\n      TypeNoBounds\n    | ImplTraitType\n    | TraitObjectType\n\nTypeNoBounds ->\n      ParenthesizedType\n    | ImplTraitTypeOneBound\n    | TraitObjectTypeOneBound\n    | TypePath\n    | TupleType\n    | NeverType\n    | RawPointerType\n    | ReferenceType\n    | ArrayType\n    | SliceType\n    | InferredType\n    | QualifiedPathInType\n    | BareFunctionType\n    | MacroInvocation\n\nA _type expression_ as defined in the [Type] grammar rule above is the syntax\nfor referring to a type. It may refer to:\n\n* Sequence types ([tuple], [array], [slice]).\n\n* [Type paths] which can reference:\n    * Primitive types ([boolean], [numeric], [textual]).\n    * Paths to an [item] ([struct], [enum], [union], [type alias], [trait]).\n    * [`Self` path] where `Self` is the implementing type.\n    * Generic [type parameters].\n\n* Pointer types ([reference], [raw pointer], [function pointer]).\n\n* The [inferred type] which asks the compiler to determine the type.\n\n* [Parentheses] which are used for disambiguation.\n\n* Trait types: [Trait objects] and [impl trait].\n\n* The [never] type.\n\n* [Macros] which expand to a type expression.",
      "parent_id": null,
      "paragraphs": {
        "type.name.syntax": ",types\nType ->\n      TypeNoBounds\n    | ImplTraitType\n    | TraitObjectType\n\nTypeNoBounds ->\n      ParenthesizedType\n    | ImplTraitTypeOneBound\n    | TraitObjectTypeOneBound\n    | TypePath\n    | TupleType\n    | NeverType\n    | RawPointerType\n    | ReferenceType\n    | ArrayType\n    | SliceType\n    | InferredType\n    | QualifiedPathInType\n    | BareFunctionType\n    | MacroInvocation",
        "type.name.intro": "A _type expression_ as defined in the [Type] grammar rule above is the syntax\nfor referring to a type. It may refer to:",
        "type.name.sequence": "* Sequence types ([tuple], [array], [slice]).",
        "type.name.path": "* [Type paths] which can reference:\n    * Primitive types ([boolean], [numeric], [textual]).\n    * Paths to an [item] ([struct], [enum], [union], [type alias], [trait]).\n    * [`Self` path] where `Self` is the implementing type.\n    * Generic [type parameters].",
        "type.name.pointer": "* Pointer types ([reference], [raw pointer], [function pointer]).",
        "type.name.inference": "* The [inferred type] which asks the compiler to determine the type.",
        "type.name.grouped": "* [Parentheses] which are used for disambiguation.",
        "type.name.trait": "* Trait types: [Trait objects] and [impl trait].",
        "type.name.never": "* The [never] type.",
        "type.name.macro-expansion": "* [Macros] which expand to a type expression."
      }
    },
    {
      "id": "type.name.parenthesized",
      "title": "Parenthesized types",
      "level": 2,
      "content": ",types\nParenthesizedType -> `(` Type `)`\n\nIn some situations the combination of types may be ambiguous. Use parentheses\naround a type to avoid ambiguity. For example, the `+` operator for [type\nboundaries] within a [reference type] is unclear where the\nboundary applies, so the use of parentheses is required. Grammar rules that\nrequire this disambiguation use the [TypeNoBounds] rule instead of\nType.\n\n# use std::any::Any;\ntype T<'a> = &'a (dyn Any + Send);",
      "parent_id": null,
      "paragraphs": {
        "type.name.parenthesized.syntax": ",types\nParenthesizedType -> `(` Type `)`",
        "type.name.parenthesized.intro": "In some situations the combination of types may be ambiguous. Use parentheses\naround a type to avoid ambiguity. For example, the `+` operator for [type\nboundaries] within a [reference type] is unclear where the\nboundary applies, so the use of parentheses is required. Grammar rules that\nrequire this disambiguation use the [TypeNoBounds] rule instead of\nType.\n\n# use std::any::Any;\ntype T<'a> = &'a (dyn Any + Send);"
      }
    },
    {
      "id": "type.recursive",
      "title": "Recursive types",
      "level": 1,
      "content": "Nominal types &mdash; [structs], [enumerations], and [unions] &mdash; may be\nrecursive. That is, each `enum` variant or `struct` or `union` field may\nrefer, directly or indirectly, to the enclosing `enum` or `struct` type\nitself.\n\nSuch recursion has restrictions:\n\n* Recursive types must include a nominal type in the recursion (not mere [type\n  aliases], or other structural types such as [arrays] or [tuples]). So `type\n  Rec = &'static [Rec]` is not allowed.\n* The size of a recursive type must be finite; in other words the recursive\n  fields of the type must be [pointer types].\n\nAn example of a *recursive* type and its use:\n\nenum List<T> {\n    Nil,\n    Cons(T, Box<List<T>>)\n}\n\nlet a: List<i32> = List::Cons(7, Box::new(List::Cons(13, Box::new(List::Nil))));\n\n[Array]: types/array.md\n[Boolean]: types/boolean.md\n[Closures]: types/closure.md\n[Enum]: types/enum.md\n[Function pointers]: types/function-pointer.md\n[Functions]: types/function-item.md\n[Impl trait]: types/impl-trait.md\n[Macros]: macros.md\n[Numeric]: types/numeric.md\n\n[Raw pointers]: types/pointer.md#raw-pointers-const-and-mut\n[References]: types/pointer.md#shared-references-\n[Slice]: types/slice.md\n[Struct]: types/struct.md\n[Textual]: types/textual.md\n[Trait objects]: types/trait-object.md\n[Tuple]: types/tuple.md\n[Type paths]: paths.md#paths-in-types\n[Union]: types/union.md\n[`Self` path]: paths.md#self-1\n[arrays]: types/array.md\n[enumerations]: types/enum.md\n[function pointer]: types/function-pointer.md\n[inferred type]: types/inferred.md\n[item]: items.md\n[never]: types/never.md\n[pointer types]: types/pointer.md\n[raw pointer]: types/pointer.md#raw-pointers-const-and-mut\n[reference type]: types/pointer.md#shared-references-\n[reference]: types/pointer.md#shared-references-\n[structs]: types/struct.md\n[trait]: types/trait-object.md\n[tuples]: types/tuple.md\n[type alias]: items/type-aliases.md\n[type aliases]: items/type-aliases.md\n[type boundaries]: trait-bounds.md\n[type parameters]: types/parameters.md\n[unions]: types/union.md",
      "parent_id": null,
      "paragraphs": {
        "type.recursive.intro": "Nominal types &mdash; [structs], [enumerations], and [unions] &mdash; may be\nrecursive. That is, each `enum` variant or `struct` or `union` field may\nrefer, directly or indirectly, to the enclosing `enum` or `struct` type\nitself.",
        "type.recursive.constraint": "Such recursion has restrictions:\n\n* Recursive types must include a nominal type in the recursion (not mere [type\n  aliases], or other structural types such as [arrays] or [tuples]). So `type\n  Rec = &'static [Rec]` is not allowed.\n* The size of a recursive type must be finite; in other words the recursive\n  fields of the type must be [pointer types].\n\nAn example of a *recursive* type and its use:\n\nenum List<T> {\n    Nil,\n    Cons(T, Box<List<T>>)\n}\n\nlet a: List<i32> = List::Cons(7, Box::new(List::Cons(13, Box::new(List::Nil))));\n\n[Array]: types/array.md\n[Boolean]: types/boolean.md\n[Closures]: types/closure.md\n[Enum]: types/enum.md\n[Function pointers]: types/function-pointer.md\n[Functions]: types/function-item.md\n[Impl trait]: types/impl-trait.md\n[Macros]: macros.md\n[Numeric]: types/numeric.md\n\n[Raw pointers]: types/pointer.md#raw-pointers-const-and-mut\n[References]: types/pointer.md#shared-references-\n[Slice]: types/slice.md\n[Struct]: types/struct.md\n[Textual]: types/textual.md\n[Trait objects]: types/trait-object.md\n[Tuple]: types/tuple.md\n[Type paths]: paths.md#paths-in-types\n[Union]: types/union.md\n[`Self` path]: paths.md#self-1\n[arrays]: types/array.md\n[enumerations]: types/enum.md\n[function pointer]: types/function-pointer.md\n[inferred type]: types/inferred.md\n[item]: items.md\n[never]: types/never.md\n[pointer types]: types/pointer.md\n[raw pointer]: types/pointer.md#raw-pointers-const-and-mut\n[reference type]: types/pointer.md#shared-references-\n[reference]: types/pointer.md#shared-references-\n[structs]: types/struct.md\n[trait]: types/trait-object.md\n[tuples]: types/tuple.md\n[type alias]: items/type-aliases.md\n[type aliases]: items/type-aliases.md\n[type boundaries]: trait-bounds.md\n[type parameters]: types/parameters.md\n[unions]: types/union.md"
      }
    },
    {
      "id": "type.bool",
      "title": "Boolean type",
      "level": 1,
      "content": "let b: bool = true;\n\nThe *boolean type* or *bool* is a primitive data type that can take on one of\ntwo values, called *true* and *false*.\n\nValues of this type may be created using a [literal expression] using the\nkeywords `true` and `false` corresponding to the value of the same name.\n\nThis type is a part of the [language prelude] with the [name] `bool`.\n\nAn object with the boolean type has a [size and alignment] of 1 each.\n\nThe value false has the bit pattern `0x00` and the value true has the bit pattern\n`0x01`. It is [undefined behavior] for an object with the boolean type to have\nany other bit pattern.\n\nThe boolean type is the type of many operands in various [expressions]:\n\n* The condition operand in [if expressions] and [while expressions]\n\n* The operands in lazy boolean operator expressions\n\n> [!NOTE]\n> The boolean type acts similarly to but is not an [enumerated type]. In practice, this mostly means that constructors are not associated to the type (e.g. `bool::true`).\n\nLike all primitives, the boolean type implements the\ntraits `Clone`, `Copy`, `Sized`,\n`Send`, and `Sync`.\n\n> [!NOTE]\n> See the standard library docs for library operations.",
      "parent_id": null,
      "paragraphs": {
        "type.bool": "let b: bool = true;",
        "type.bool.intro": "The *boolean type* or *bool* is a primitive data type that can take on one of\ntwo values, called *true* and *false*.",
        "type.bool.literal": "Values of this type may be created using a [literal expression] using the\nkeywords `true` and `false` corresponding to the value of the same name.",
        "type.bool.namespace": "This type is a part of the [language prelude] with the [name] `bool`.",
        "type.bool.layout": "An object with the boolean type has a [size and alignment] of 1 each.",
        "type.bool.repr": "The value false has the bit pattern `0x00` and the value true has the bit pattern\n`0x01`. It is [undefined behavior] for an object with the boolean type to have\nany other bit pattern.",
        "type.bool.usage": "The boolean type is the type of many operands in various [expressions]:",
        "type.bool.usage-condition": "* The condition operand in [if expressions] and [while expressions]",
        "type.bool.usage-lazy-operator": "* The operands in lazy boolean operator expressions\n\n> [!NOTE]\n> The boolean type acts similarly to but is not an [enumerated type]. In practice, this mostly means that constructors are not associated to the type (e.g. `bool::true`).",
        "type.bool.traits": "Like all primitives, the boolean type implements the\ntraits `Clone`, `Copy`, `Sized`,\n`Send`, and `Sync`.\n\n> [!NOTE]\n> See the standard library docs for library operations."
      }
    },
    {
      "id": "type.bool.expr",
      "title": "Operations on boolean values",
      "level": 1,
      "content": "When using certain operator expressions with a boolean type for its operands,\nthey evaluate using the rules of [boolean logic].",
      "parent_id": null,
      "paragraphs": {
        "type.bool.expr": "When using certain operator expressions with a boolean type for its operands,\nthey evaluate using the rules of [boolean logic]."
      }
    },
    {
      "id": "type.bool.expr.not",
      "title": "Logical not",
      "level": 2,
      "content": "| `b` | `!b` |\n|- | - |\n| `true` | `false` |\n| `false` | `true` |",
      "parent_id": null,
      "paragraphs": {
        "type.bool.expr.not": "| `b` | `!b` |\n|- | - |\n| `true` | `false` |\n| `false` | `true` |"
      }
    },
    {
      "id": "type.bool.expr.or",
      "title": "Logical or",
      "level": 3,
      "content": "| `a` | `b` | `a \\| b` |\n|- | - | - |\n| `true` | `true` | `true` |\n| `true` | `false` | `true` |\n| `false` | `true` | `true` |\n| `false` | `false` | `false` |",
      "parent_id": null,
      "paragraphs": {
        "type.bool.expr.or": "| `a` | `b` | `a \\| b` |\n|- | - | - |\n| `true` | `true` | `true` |\n| `true` | `false` | `true` |\n| `false` | `true` | `true` |\n| `false` | `false` | `false` |"
      }
    },
    {
      "id": "type.bool.expr.and",
      "title": "Logical and",
      "level": 3,
      "content": "| `a` | `b` | `a & b` |\n|- | - | - |\n| `true` | `true` | `true` |\n| `true` | `false` | `false` |\n| `false` | `true` | `false` |\n| `false` | `false` | `false` |",
      "parent_id": null,
      "paragraphs": {
        "type.bool.expr.and": "| `a` | `b` | `a & b` |\n|- | - | - |\n| `true` | `true` | `true` |\n| `true` | `false` | `false` |\n| `false` | `true` | `false` |\n| `false` | `false` | `false` |"
      }
    },
    {
      "id": "type.bool.expr.xor",
      "title": "Logical xor",
      "level": 3,
      "content": "| `a` | `b` | `a ^ b` |\n|- | - | - |\n| `true` | `true` | `false` |\n| `true` | `false` | `true` |\n| `false` | `true` | `true` |\n| `false` | `false` | `false` |",
      "parent_id": null,
      "paragraphs": {
        "type.bool.expr.xor": "| `a` | `b` | `a ^ b` |\n|- | - | - |\n| `true` | `true` | `false` |\n| `true` | `false` | `true` |\n| `false` | `true` | `true` |\n| `false` | `false` | `false` |"
      }
    },
    {
      "id": "type.bool.expr.cmp",
      "title": "Comparisons",
      "level": 3,
      "content": "| `a` | `b` | `a == b` |\n|- | - | - |\n| `true` | `true` | `true` |\n| `true` | `false` | `false` |\n| `false` | `true` | `false` |\n| `false` | `false` | `true` |\n\n| `a` | `b` | `a > b` |\n|- | - | - |\n| `true` | `true` | `false` |\n| `true` | `false` | `true` |\n| `false` | `true` | `false` |\n| `false` | `false` | `false` |\n\n* `a != b` is the same as `!(a == b)`\n\n* `a >= b` is the same as `a == b | a > b`\n\n* `a < b` is the same as `!(a >= b)`\n\n* `a <= b` is the same as `a == b | a < b`",
      "parent_id": null,
      "paragraphs": {
        "type.bool.expr.cmp.eq": "| `a` | `b` | `a == b` |\n|- | - | - |\n| `true` | `true` | `true` |\n| `true` | `false` | `false` |\n| `false` | `true` | `false` |\n| `false` | `false` | `true` |",
        "type.bool.expr.cmp.greater": "| `a` | `b` | `a > b` |\n|- | - | - |\n| `true` | `true` | `false` |\n| `true` | `false` | `true` |\n| `false` | `true` | `false` |\n| `false` | `false` | `false` |",
        "type.bool.expr.cmp.not-eq": "* `a != b` is the same as `!(a == b)`",
        "type.bool.expr.cmp.greater-eq": "* `a >= b` is the same as `a == b | a > b`",
        "type.bool.expr.cmp.less": "* `a < b` is the same as `!(a >= b)`",
        "type.bool.expr.cmp.less-eq": "* `a <= b` is the same as `a == b | a < b`"
      }
    },
    {
      "id": "type.bool.validity",
      "title": "Bit validity",
      "level": 3,
      "content": "The single byte of a `bool` is guaranteed to be initialized (in other words,\n`transmute::<bool, u8>(...)` is always sound -- but since some bit patterns\nare invalid `bool`s, the inverse is not always sound).\n\n[boolean logic]: https://en.wikipedia.org/wiki/Boolean_algebra\n[enumerated type]: enum.md\n[expressions]: ../expressions.md\n[if expressions]: ../expressions/if-expr.md#if-expressions\n[language prelude]: ../names/preludes.md#language-prelude\n[lazy]: ../expressions/operator-expr.md#lazy-boolean-operators\n[literal expression]: ../expressions/literal-expr.md\n[name]: ../names.md\n[op-and]: ../expressions/operator-expr.md#arithmetic-and-logical-binary-operators\n[op-compare]: ../expressions/operator-expr.md#comparison-operators\n[op-not]: ../expressions/operator-expr.md#negation-operators\n[op-or]: ../expressions/operator-expr.md#arithmetic-and-logical-binary-operators\n[op-xor]: ../expressions/operator-expr.md#arithmetic-and-logical-binary-operators\n[p-clone]: ../special-types-and-traits.md#clone\n[p-copy]: ../special-types-and-traits.md#copy\n[p-impl]: ../items/implementations.md\n[p-send]: ../special-types-and-traits.md#send\n[p-sized]: ../special-types-and-traits.md#sized\n[p-sync]: ../special-types-and-traits.md#sync\n[p-traits]: ../items/traits.md\n[size and alignment]: ../type-layout.md#size-and-alignment\n[undefined behavior]: ../behavior-considered-undefined.md\n[while expressions]: ../expressions/loop-expr.md#predicate-loops",
      "parent_id": null,
      "paragraphs": {
        "type.bool.validity": "The single byte of a `bool` is guaranteed to be initialized (in other words,\n`transmute::<bool, u8>(...)` is always sound -- but since some bit patterns\nare invalid `bool`s, the inverse is not always sound).\n\n[boolean logic]: https://en.wikipedia.org/wiki/Boolean_algebra\n[enumerated type]: enum.md\n[expressions]: ../expressions.md\n[if expressions]: ../expressions/if-expr.md#if-expressions\n[language prelude]: ../names/preludes.md#language-prelude\n[lazy]: ../expressions/operator-expr.md#lazy-boolean-operators\n[literal expression]: ../expressions/literal-expr.md\n[name]: ../names.md\n[op-and]: ../expressions/operator-expr.md#arithmetic-and-logical-binary-operators\n[op-compare]: ../expressions/operator-expr.md#comparison-operators\n[op-not]: ../expressions/operator-expr.md#negation-operators\n[op-or]: ../expressions/operator-expr.md#arithmetic-and-logical-binary-operators\n[op-xor]: ../expressions/operator-expr.md#arithmetic-and-logical-binary-operators\n[p-clone]: ../special-types-and-traits.md#clone\n[p-copy]: ../special-types-and-traits.md#copy\n[p-impl]: ../items/implementations.md\n[p-send]: ../special-types-and-traits.md#send\n[p-sized]: ../special-types-and-traits.md#sized\n[p-sync]: ../special-types-and-traits.md#sync\n[p-traits]: ../items/traits.md\n[size and alignment]: ../type-layout.md#size-and-alignment\n[undefined behavior]: ../behavior-considered-undefined.md\n[while expressions]: ../expressions/loop-expr.md#predicate-loops"
      }
    },
    {
      "id": "type.numeric",
      "title": "Numeric types",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "type.numeric.int",
      "title": "Integer types",
      "level": 1,
      "content": "The unsigned integer types consist of:\n\nType   | Minimum | Maximum\n-------|---------|-------------------\n`u8`   | 0       | 2<sup>8</sup>-1\n`u16`  | 0       | 2<sup>16</sup>-1\n`u32`  | 0       | 2<sup>32</sup>-1\n`u64`  | 0       | 2<sup>64</sup>-1\n`u128` | 0       | 2<sup>128</sup>-1\n\nThe signed two's complement integer types consist of:\n\nType   | Minimum            | Maximum\n-------|--------------------|-------------------\n`i8`   | -(2<sup>7</sup>)   | 2<sup>7</sup>-1\n`i16`  | -(2<sup>15</sup>)  | 2<sup>15</sup>-1\n`i32`  | -(2<sup>31</sup>)  | 2<sup>31</sup>-1\n`i64`  | -(2<sup>63</sup>)  | 2<sup>63</sup>-1\n`i128` | -(2<sup>127</sup>) | 2<sup>127</sup>-1",
      "parent_id": null,
      "paragraphs": {
        "type.numeric.int.unsigned": "The unsigned integer types consist of:\n\nType   | Minimum | Maximum\n-------|---------|-------------------\n`u8`   | 0       | 2<sup>8</sup>-1\n`u16`  | 0       | 2<sup>16</sup>-1\n`u32`  | 0       | 2<sup>32</sup>-1\n`u64`  | 0       | 2<sup>64</sup>-1\n`u128` | 0       | 2<sup>128</sup>-1",
        "type.numeric.int.signed": "The signed two's complement integer types consist of:\n\nType   | Minimum            | Maximum\n-------|--------------------|-------------------\n`i8`   | -(2<sup>7</sup>)   | 2<sup>7</sup>-1\n`i16`  | -(2<sup>15</sup>)  | 2<sup>15</sup>-1\n`i32`  | -(2<sup>31</sup>)  | 2<sup>31</sup>-1\n`i64`  | -(2<sup>63</sup>)  | 2<sup>63</sup>-1\n`i128` | -(2<sup>127</sup>) | 2<sup>127</sup>-1"
      }
    },
    {
      "id": "type.numeric.float",
      "title": "Floating-point types",
      "level": 2,
      "content": "The IEEE 754-2008 \"binary32\" and \"binary64\" floating-point types are `f32` and\n`f64`, respectively.",
      "parent_id": null,
      "paragraphs": {
        "type.numeric.float": "The IEEE 754-2008 \"binary32\" and \"binary64\" floating-point types are `f32` and\n`f64`, respectively."
      }
    },
    {
      "id": "type.numeric.int.size",
      "title": "Machine-dependent integer types",
      "level": 2,
      "content": "The `usize` type is an unsigned integer type with the same number of bits as the\nplatform's pointer type. It can represent every memory address in the process.\n\n> [!NOTE]\n> While a `usize` can represent every *address*, converting a *pointer* to a `usize` is not necessarily a reversible operation.\n> For more information, see the documentation for [type cast expressions], [`std::ptr`], and provenance in particular.\n\nThe `isize` type is a signed two's complement integer type with the same number of bits as the\nplatform's pointer type. The theoretical upper bound on object and array size\nis the maximum `isize` value. This ensures that `isize` can be used to calculate\ndifferences between pointers into an object or array and can address every byte\nwithin an object along with one byte past the end.\n\n`usize` and `isize` are at least 16-bits wide.\n\n> [!NOTE]\n> Many pieces of Rust code may assume that pointers, `usize`, and `isize` are either 32-bit or 64-bit. As a consequence, 16-bit pointer support is limited and may require explicit care and acknowledgment from a library to support.",
      "parent_id": null,
      "paragraphs": {
        "type.numeric.int.size.usize": "The `usize` type is an unsigned integer type with the same number of bits as the\nplatform's pointer type. It can represent every memory address in the process.\n\n> [!NOTE]\n> While a `usize` can represent every *address*, converting a *pointer* to a `usize` is not necessarily a reversible operation.\n> For more information, see the documentation for [type cast expressions], [`std::ptr`], and provenance in particular.",
        "type.numeric.int.size.isize": "The `isize` type is a signed two's complement integer type with the same number of bits as the\nplatform's pointer type. The theoretical upper bound on object and array size\nis the maximum `isize` value. This ensures that `isize` can be used to calculate\ndifferences between pointers into an object or array and can address every byte\nwithin an object along with one byte past the end.",
        "type.numeric.int.size.minimum": "`usize` and `isize` are at least 16-bits wide.\n\n> [!NOTE]\n> Many pieces of Rust code may assume that pointers, `usize`, and `isize` are either 32-bit or 64-bit. As a consequence, 16-bit pointer support is limited and may require explicit care and acknowledgment from a library to support."
      }
    },
    {
      "id": "type.numeric.validity",
      "title": "Bit validity",
      "level": 2,
      "content": "For every numeric type, `T`, the bit validity of `T` is equivalent to the bit\nvalidity of `[u8; size_of::<T>()]`. An uninitialized byte is not a valid `u8`.\n\n[type cast expressions]: ../expressions/operator-expr.md#type-cast-expressions",
      "parent_id": null,
      "paragraphs": {
        "type.numeric.validity": "For every numeric type, `T`, the bit validity of `T` is equivalent to the bit\nvalidity of `[u8; size_of::<T>()]`. An uninitialized byte is not a valid `u8`.\n\n[type cast expressions]: ../expressions/operator-expr.md#type-cast-expressions"
      }
    },
    {
      "id": "type.text",
      "title": "Textual types",
      "level": 1,
      "content": "The types `char` and `str` hold textual data.\n\nA value of type `char` is a [Unicode scalar value] (i.e. a code point that is\nnot a surrogate), represented as a 32-bit unsigned word in the 0x0000 to 0xD7FF\nor 0xE000 to 0x10FFFF range.\n\nIt is immediate [undefined behavior] to create a\n`char` that falls outside this range. A `[char]` is effectively a UCS-4 / UTF-32\nstring of length 1.\n\nA value of type `str` is represented the same way as `[u8]`, a slice of\n8-bit unsigned bytes. However, the Rust standard library makes extra assumptions\nabout `str`: methods working on `str` assume and ensure that the data in there\nis valid UTF-8. Calling a `str` method with a non-UTF-8 buffer can cause\n[undefined behavior] now or in the future.\n\nSince `str` is a [dynamically sized type], it can only be instantiated through a\npointer type, such as `&str`. The layout of `&str` is the same as the layout of\n`&[u8]`.",
      "parent_id": null,
      "paragraphs": {
        "type.text.intro": "The types `char` and `str` hold textual data.",
        "type.text.char-value": "A value of type `char` is a [Unicode scalar value] (i.e. a code point that is\nnot a surrogate), represented as a 32-bit unsigned word in the 0x0000 to 0xD7FF\nor 0xE000 to 0x10FFFF range.",
        "type.text.char-precondition": "It is immediate [undefined behavior] to create a\n`char` that falls outside this range. A `[char]` is effectively a UCS-4 / UTF-32\nstring of length 1.",
        "type.text.str-value": "A value of type `str` is represented the same way as `[u8]`, a slice of\n8-bit unsigned bytes. However, the Rust standard library makes extra assumptions\nabout `str`: methods working on `str` assume and ensure that the data in there\nis valid UTF-8. Calling a `str` method with a non-UTF-8 buffer can cause\n[undefined behavior] now or in the future.",
        "type.text.str-unsized": "Since `str` is a [dynamically sized type], it can only be instantiated through a\npointer type, such as `&str`. The layout of `&str` is the same as the layout of\n`&[u8]`."
      }
    },
    {
      "id": "type.text.layout",
      "title": "Layout and bit validity",
      "level": 1,
      "content": "`char` is guaranteed to have the same size and alignment as `u32` on all platforms.\n\nEvery byte of a `char` is guaranteed to be initialized (in other words,\n`transmute::<char, [u8; size_of::<char>()]>(...)` is always sound -- but since\nsome bit patterns are invalid `char`s, the inverse is not always sound).\n\n[Unicode scalar value]: http://www.unicode.org/glossary/#unicode_scalar_value\n[undefined behavior]: ../behavior-considered-undefined.md\n[dynamically sized type]: ../dynamically-sized-types.md",
      "parent_id": null,
      "paragraphs": {
        "type.layout.char-layout": "`char` is guaranteed to have the same size and alignment as `u32` on all platforms.",
        "type.layout.char-validity": "Every byte of a `char` is guaranteed to be initialized (in other words,\n`transmute::<char, [u8; size_of::<char>()]>(...)` is always sound -- but since\nsome bit patterns are invalid `char`s, the inverse is not always sound).\n\n[Unicode scalar value]: http://www.unicode.org/glossary/#unicode_scalar_value\n[undefined behavior]: ../behavior-considered-undefined.md\n[dynamically sized type]: ../dynamically-sized-types.md"
      }
    },
    {
      "id": "type.never",
      "title": "Never type",
      "level": 1,
      "content": ",types\nNeverType -> `!`\n\nThe never type `!` is a type with no values, representing the result of\ncomputations that never complete.\n\nExpressions of type `!` can be coerced into any other type.\n\nThe `!` type can **only** appear in function return types presently,\nindicating it is a diverging function that never returns.\n\nfn foo() -> ! {\n    panic!(\"This call never returns.\");\n}\n\nunsafe extern \"C\" {\n    pub safe fn no_return_extern_func() -> !;\n}",
      "parent_id": null,
      "paragraphs": {
        "type.never.syntax": ",types\nNeverType -> `!`",
        "type.never.intro": "The never type `!` is a type with no values, representing the result of\ncomputations that never complete.",
        "type.never.coercion": "Expressions of type `!` can be coerced into any other type.",
        "type.never.constraint": "The `!` type can **only** appear in function return types presently,\nindicating it is a diverging function that never returns.\n\nfn foo() -> ! {\n    panic!(\"This call never returns.\");\n}\n\nunsafe extern \"C\" {\n    pub safe fn no_return_extern_func() -> !;\n}"
      }
    },
    {
      "id": "type.tuple",
      "title": "Tuple types",
      "level": 1,
      "content": ",types\nTupleType ->\n      `(` `)`\n    | `(` ( Type `,` )+ Type? `)`\n\n*Tuple types* are a family of structural types[^1] for heterogeneous lists of other types.\n\nThe syntax for a tuple type is a parenthesized, comma-separated list of types.\n\n1-ary tuples require a comma after their element type to be disambiguated with a [parenthesized type].\n\nA tuple type has a number of fields equal to the length of the list of types.\nThis number of fields determines the *arity* of the tuple.\nA tuple with `n` fields is called an *n-ary tuple*.\nFor example, a tuple with 2 fields is a 2-ary tuple.\n\nFields of tuples are named using increasing numeric names matching their position in the list of types.\nThe first field is `0`.\nThe second field is `1`.\nAnd so on.\nThe type of each field is the type of the same position in the tuple's list of types.\n\nFor convenience and historical reasons, the tuple type with no fields (`()`) is often called *unit* or *the unit type*.\nIts one value is also called *unit* or *the unit value*.\n\nSome examples of tuple types:\n\n* `()` (unit)\n* `(i32,)` (1-ary tuple)\n* `(f64, f64)`\n* `(String, i32)`\n* `(i32, String)` (different type from the previous example)\n* `(i32, f64, Vec<String>, Option<bool>)`\n\nValues of this type are constructed using a [tuple expression].\nFurthermore, various expressions will produce the unit value if there is no other meaningful value for it to evaluate to.\n\nTuple fields can be accessed by either a [tuple index expression] or [pattern matching].\n\n[^1]: Structural types are always equivalent if their internal types are equivalent.\n      For a nominal version of tuples, see [tuple structs].\n\n[parenthesized type]: ../types.md#parenthesized-types\n[pattern matching]: ../patterns.md#tuple-patterns\n[tuple expression]: ../expressions/tuple-expr.md#tuple-expressions\n[tuple index expression]: ../expressions/tuple-expr.md#tuple-indexing-expressions\n[tuple structs]: ./struct.md",
      "parent_id": null,
      "paragraphs": {
        "type.tuple.syntax": ",types\nTupleType ->\n      `(` `)`\n    | `(` ( Type `,` )+ Type? `)`",
        "type.tuple.intro": "*Tuple types* are a family of structural types[^1] for heterogeneous lists of other types.\n\nThe syntax for a tuple type is a parenthesized, comma-separated list of types.",
        "type.tuple.restriction": "1-ary tuples require a comma after their element type to be disambiguated with a [parenthesized type].",
        "type.tuple.field-number": "A tuple type has a number of fields equal to the length of the list of types.\nThis number of fields determines the *arity* of the tuple.\nA tuple with `n` fields is called an *n-ary tuple*.\nFor example, a tuple with 2 fields is a 2-ary tuple.",
        "type.tuple.field-name": "Fields of tuples are named using increasing numeric names matching their position in the list of types.\nThe first field is `0`.\nThe second field is `1`.\nAnd so on.\nThe type of each field is the type of the same position in the tuple's list of types.",
        "type.tuple.unit": "For convenience and historical reasons, the tuple type with no fields (`()`) is often called *unit* or *the unit type*.\nIts one value is also called *unit* or *the unit value*.\n\nSome examples of tuple types:\n\n* `()` (unit)\n* `(i32,)` (1-ary tuple)\n* `(f64, f64)`\n* `(String, i32)`\n* `(i32, String)` (different type from the previous example)\n* `(i32, f64, Vec<String>, Option<bool>)`",
        "type.tuple.constructor": "Values of this type are constructed using a [tuple expression].\nFurthermore, various expressions will produce the unit value if there is no other meaningful value for it to evaluate to.",
        "type.tuple.access": "Tuple fields can be accessed by either a [tuple index expression] or [pattern matching].\n\n[^1]: Structural types are always equivalent if their internal types are equivalent.\n      For a nominal version of tuples, see [tuple structs].\n\n[parenthesized type]: ../types.md#parenthesized-types\n[pattern matching]: ../patterns.md#tuple-patterns\n[tuple expression]: ../expressions/tuple-expr.md#tuple-expressions\n[tuple index expression]: ../expressions/tuple-expr.md#tuple-indexing-expressions\n[tuple structs]: ./struct.md"
      }
    },
    {
      "id": "type.array",
      "title": "Array types",
      "level": 1,
      "content": ",types\nArrayType -> `[` Type `;` Expression `]`\n\nAn array is a fixed-size sequence of `N` elements of type `T`. The array type\nis written as `[T; N]`.\n\nThe size is a [constant expression] that evaluates to a [`usize`].\n\nExamples:\n\n// A stack-allocated array\nlet array: [i32; 3] = [1, 2, 3];\n\n// A heap-allocated array, coerced to a slice\nlet boxed_array: Box<[i32]> = Box::new([1, 2, 3]);\n\nAll elements of arrays are always initialized, and access to an array is\nalways bounds-checked in safe methods and operators.\n\n> [!NOTE]\n> The [`Vec<T>`] standard library type provides a heap-allocated resizable array type.\n\n[`usize`]: numeric.md#machine-dependent-integer-types\n[constant expression]: ../const_eval.md#constant-expressions",
      "parent_id": null,
      "paragraphs": {
        "type.array.syntax": ",types\nArrayType -> `[` Type `;` Expression `]`",
        "type.array.intro": "An array is a fixed-size sequence of `N` elements of type `T`. The array type\nis written as `[T; N]`.",
        "type.array.constraint": "The size is a [constant expression] that evaluates to a [`usize`].\n\nExamples:\n\n// A stack-allocated array\nlet array: [i32; 3] = [1, 2, 3];\n\n// A heap-allocated array, coerced to a slice\nlet boxed_array: Box<[i32]> = Box::new([1, 2, 3]);",
        "type.array.index": "All elements of arrays are always initialized, and access to an array is\nalways bounds-checked in safe methods and operators.\n\n> [!NOTE]\n> The [`Vec<T>`] standard library type provides a heap-allocated resizable array type.\n\n[`usize`]: numeric.md#machine-dependent-integer-types\n[constant expression]: ../const_eval.md#constant-expressions"
      }
    },
    {
      "id": "type.slice",
      "title": "Slice types",
      "level": 1,
      "content": ",types\nSliceType -> `[` Type `]`\n\nA slice is a [dynamically sized type] representing a 'view' into a sequence of\nelements of type `T`. The slice type is written as `[T]`.\n\nSlice types are generally used through pointer types. For example:\n\n* `&[T]`: a 'shared slice', often just called a 'slice'. It doesn't own the\n  data it points to; it borrows it.\n* `&mut [T]`: a 'mutable slice'. It mutably borrows the data it points to.\n* `Box<[T]>`: a 'boxed slice'\n\nExamples:\n\n// A heap-allocated array, coerced to a slice\nlet boxed_array: Box<[i32]> = Box::new([1, 2, 3]);\n\n// A (shared) slice into an array\nlet slice: &[i32] = &boxed_array[..];\n\nAll elements of slices are always initialized, and access to a slice is always\nbounds-checked in safe methods and operators.\n\n[dynamically sized type]: ../dynamically-sized-types.md",
      "parent_id": null,
      "paragraphs": {
        "type.slice.syntax": ",types\nSliceType -> `[` Type `]`",
        "type.slice.intro": "A slice is a [dynamically sized type] representing a 'view' into a sequence of\nelements of type `T`. The slice type is written as `[T]`.",
        "type.slice.unsized": "Slice types are generally used through pointer types. For example:\n\n* `&[T]`: a 'shared slice', often just called a 'slice'. It doesn't own the\n  data it points to; it borrows it.\n* `&mut [T]`: a 'mutable slice'. It mutably borrows the data it points to.\n* `Box<[T]>`: a 'boxed slice'\n\nExamples:\n\n// A heap-allocated array, coerced to a slice\nlet boxed_array: Box<[i32]> = Box::new([1, 2, 3]);\n\n// A (shared) slice into an array\nlet slice: &[i32] = &boxed_array[..];",
        "type.slice.safe": "All elements of slices are always initialized, and access to a slice is always\nbounds-checked in safe methods and operators.\n\n[dynamically sized type]: ../dynamically-sized-types.md"
      }
    },
    {
      "id": "type.struct",
      "title": "Struct types",
      "level": 1,
      "content": "A `struct` *type* is a heterogeneous product of other types, called the\n*fields* of the type.[^structtype]\n\nNew instances of a `struct` can be constructed with a [struct expression].\n\nThe memory layout of a `struct` is undefined by default to allow for compiler\noptimizations like field reordering, but it can be fixed with the\n[`repr` attribute]. In either case, fields may be given in any order in a\ncorresponding struct *expression*; the resulting `struct` value will always\nhave the same memory layout.\n\nThe fields of a `struct` may be qualified by [visibility modifiers], to allow\naccess to data in a struct outside a module.\n\nA _tuple struct_ type is just like a struct type, except that the fields are\nanonymous.\n\nA _unit-like struct_ type is like a struct type, except that it has no fields.\nThe one value constructed by the associated [struct expression] is the only\nvalue that inhabits such a type.\n\n[^structtype]: `struct` types are analogous to `struct` types in C, the\n    *record* types of the ML family, or the *struct* types of the Lisp family.\n\n[`repr` attribute]: ../type-layout.md#representations\n[struct expression]: ../expressions/struct-expr.md\n[visibility modifiers]: ../visibility-and-privacy.md",
      "parent_id": null,
      "paragraphs": {
        "type.struct.intro": "A `struct` *type* is a heterogeneous product of other types, called the\n*fields* of the type.[^structtype]",
        "type.struct.constructor": "New instances of a `struct` can be constructed with a [struct expression].",
        "type.struct.layout": "The memory layout of a `struct` is undefined by default to allow for compiler\noptimizations like field reordering, but it can be fixed with the\n[`repr` attribute]. In either case, fields may be given in any order in a\ncorresponding struct *expression*; the resulting `struct` value will always\nhave the same memory layout.",
        "type.struct.field-visibility": "The fields of a `struct` may be qualified by [visibility modifiers], to allow\naccess to data in a struct outside a module.",
        "type.struct.tuple": "A _tuple struct_ type is just like a struct type, except that the fields are\nanonymous.",
        "type.struct.unit": "A _unit-like struct_ type is like a struct type, except that it has no fields.\nThe one value constructed by the associated [struct expression] is the only\nvalue that inhabits such a type.\n\n[^structtype]: `struct` types are analogous to `struct` types in C, the\n    *record* types of the ML family, or the *struct* types of the Lisp family.\n\n[`repr` attribute]: ../type-layout.md#representations\n[struct expression]: ../expressions/struct-expr.md\n[visibility modifiers]: ../visibility-and-privacy.md"
      }
    },
    {
      "id": "type.enum",
      "title": "Enumerated types",
      "level": 1,
      "content": "An *enumerated type* is a nominal, heterogeneous disjoint union type, denoted\nby the name of an [`enum` item]. [^enumtype]\n\nAn [`enum` item] declares both the type and a number of *variants*, each of\nwhich is independently named and has the syntax of a struct, tuple struct or\nunit-like struct.\n\nNew instances of an `enum` can be constructed with a [struct expression].\n\nAny `enum` value consumes as much memory as the largest variant for its\ncorresponding `enum` type, as well as the size needed to store a discriminant.\n\nEnum types cannot be denoted *structurally* as types, but must be denoted by\nnamed reference to an [`enum` item].\n\n[^enumtype]: The `enum` type is analogous to a `data` constructor declaration in\n             Haskell, or a *pick ADT* in Limbo.\n\n[`enum` item]: ../items/enumerations.md\n[struct expression]: ../expressions/struct-expr.md",
      "parent_id": null,
      "paragraphs": {
        "type.enum.intro": "An *enumerated type* is a nominal, heterogeneous disjoint union type, denoted\nby the name of an [`enum` item]. [^enumtype]",
        "type.enum.declaration": "An [`enum` item] declares both the type and a number of *variants*, each of\nwhich is independently named and has the syntax of a struct, tuple struct or\nunit-like struct.",
        "type.enum.constructor": "New instances of an `enum` can be constructed with a [struct expression].",
        "type.enum.value": "Any `enum` value consumes as much memory as the largest variant for its\ncorresponding `enum` type, as well as the size needed to store a discriminant.",
        "type.enum.name": "Enum types cannot be denoted *structurally* as types, but must be denoted by\nnamed reference to an [`enum` item].\n\n[^enumtype]: The `enum` type is analogous to a `data` constructor declaration in\n             Haskell, or a *pick ADT* in Limbo.\n\n[`enum` item]: ../items/enumerations.md\n[struct expression]: ../expressions/struct-expr.md"
      }
    },
    {
      "id": "type.union",
      "title": "Union types",
      "level": 1,
      "content": "A *union type* is a nominal, heterogeneous C-like union, denoted by the name of\na `union` item.\n\nUnions have no notion of an \"active field\". Instead, every union access\ntransmutes parts of the content of the union to the type of the accessed field.\n\nSince transmutes can cause unexpected or undefined behaviour, `unsafe` is\nrequired to read from a union field.\n\nUnion field types are also restricted to a\nsubset of types which ensures that they never need dropping. See the [item]\ndocumentation for further details.\n\nThe memory layout of a `union` is undefined by default (in particular, fields do\n*not* have to be at offset 0), but the `#[repr(...)]` attribute can be used to\nfix a layout.\n\n[`Copy`]: ../special-types-and-traits.md#copy\n[item]: ../items/unions.md",
      "parent_id": null,
      "paragraphs": {
        "type.union.intro": "A *union type* is a nominal, heterogeneous C-like union, denoted by the name of\na `union` item.",
        "type.union.access": "Unions have no notion of an \"active field\". Instead, every union access\ntransmutes parts of the content of the union to the type of the accessed field.",
        "type.union.safety": "Since transmutes can cause unexpected or undefined behaviour, `unsafe` is\nrequired to read from a union field.",
        "type.union.constraint": "Union field types are also restricted to a\nsubset of types which ensures that they never need dropping. See the [item]\ndocumentation for further details.",
        "type.union.layout": "The memory layout of a `union` is undefined by default (in particular, fields do\n*not* have to be at offset 0), but the `#[repr(...)]` attribute can be used to\nfix a layout.\n\n[`Copy`]: ../special-types-and-traits.md#copy\n[item]: ../items/unions.md"
      }
    },
    {
      "id": "type.fn-item",
      "title": "Function item types",
      "level": 1,
      "content": "When referred to, a function item, or the constructor of a tuple-like struct or\nenum variant, yields a zero-sized value of its _function item type_.\n\nThat type explicitly identifies the function - its name, its type arguments, and its\nearly-bound lifetime arguments (but not its late-bound lifetime arguments,\nwhich are only assigned when the function is called) - so the value does not\nneed to contain an actual function pointer, and no indirection is needed when\nthe function is called.\n\nThere is no syntax that directly refers to a function item type, but the\ncompiler will display the type as something like `fn(u32) -> i32 {fn_name}` in\nerror messages.\n\nBecause the function item type explicitly identifies the function, the item\ntypes of different functions - different items, or the same item with different\ngenerics - are distinct, and mixing them will create a type error:\n\n,compile_fail,E0308\nfn foo<T>() { }\nlet x = &mut foo::<i32>;\n*x = foo::<u32>; //~ ERROR mismatched types\n\nHowever, there is a [coercion] from function items to [function pointers] with\nthe same signature, which is triggered not only when a function item is used\nwhen a function pointer is directly expected, but also when different function\nitem types with the same signature meet in different arms of the same `if` or\n`match`:\n\n# let want_i32 = false;\n# fn foo<T>() { }\n\n// `foo_ptr_1` has function pointer type `fn()` here\nlet foo_ptr_1: fn() = foo::<i32>;\n\n// ... and so does `foo_ptr_2` - this type-checks.\nlet foo_ptr_2 = if want_i32 {\n    foo::<i32>\n} else {\n    foo::<u32>\n};\n\nAll function items implement [`Copy`], [`Clone`], [`Send`], and [`Sync`].\n\n[`Fn`], [`FnMut`], and [`FnOnce`] are implemented unless the function has any of the following:\n\n- an `unsafe` qualifier\n- a `target_feature` attribute\n- an ABI other than `\"Rust\"`\n\n[`Clone`]: ../special-types-and-traits.md#clone\n[`Copy`]: ../special-types-and-traits.md#copy\n[`Send`]: ../special-types-and-traits.md#send\n[`Sync`]: ../special-types-and-traits.md#sync\n[coercion]: ../type-coercions.md\n[function pointers]: function-pointer.md",
      "parent_id": null,
      "paragraphs": {
        "type.fn-item.intro": "When referred to, a function item, or the constructor of a tuple-like struct or\nenum variant, yields a zero-sized value of its _function item type_.",
        "type.fn-item.unique": "That type explicitly identifies the function - its name, its type arguments, and its\nearly-bound lifetime arguments (but not its late-bound lifetime arguments,\nwhich are only assigned when the function is called) - so the value does not\nneed to contain an actual function pointer, and no indirection is needed when\nthe function is called.",
        "type.fn-item.name": "There is no syntax that directly refers to a function item type, but the\ncompiler will display the type as something like `fn(u32) -> i32 {fn_name}` in\nerror messages.\n\nBecause the function item type explicitly identifies the function, the item\ntypes of different functions - different items, or the same item with different\ngenerics - are distinct, and mixing them will create a type error:\n\n,compile_fail,E0308\nfn foo<T>() { }\nlet x = &mut foo::<i32>;\n*x = foo::<u32>; //~ ERROR mismatched types",
        "type.fn-item.coercion": "However, there is a [coercion] from function items to [function pointers] with\nthe same signature, which is triggered not only when a function item is used\nwhen a function pointer is directly expected, but also when different function\nitem types with the same signature meet in different arms of the same `if` or\n`match`:\n\n# let want_i32 = false;\n# fn foo<T>() { }\n\n// `foo_ptr_1` has function pointer type `fn()` here\nlet foo_ptr_1: fn() = foo::<i32>;\n\n// ... and so does `foo_ptr_2` - this type-checks.\nlet foo_ptr_2 = if want_i32 {\n    foo::<i32>\n} else {\n    foo::<u32>\n};",
        "type.fn-item.traits": "All function items implement [`Copy`], [`Clone`], [`Send`], and [`Sync`].\n\n[`Fn`], [`FnMut`], and [`FnOnce`] are implemented unless the function has any of the following:\n\n- an `unsafe` qualifier\n- a `target_feature` attribute\n- an ABI other than `\"Rust\"`\n\n[`Clone`]: ../special-types-and-traits.md#clone\n[`Copy`]: ../special-types-and-traits.md#copy\n[`Send`]: ../special-types-and-traits.md#send\n[`Sync`]: ../special-types-and-traits.md#sync\n[coercion]: ../type-coercions.md\n[function pointers]: function-pointer.md"
      }
    },
    {
      "id": "type.closure",
      "title": "Closure types",
      "level": 1,
      "content": "A [closure expression] produces a closure value with a unique, anonymous type that cannot be written out.\nA closure type is approximately equivalent to a struct which contains the captured values.\nFor instance, the following closure:\n\n#[derive(Debug)]\nstruct Point { x: i32, y: i32 }\nstruct Rectangle { left_top: Point, right_bottom: Point }\n\nfn f<F : FnOnce() -> String> (g: F) {\n    println!(\"{}\", g());\n}\n\nlet mut rect = Rectangle {\n    left_top: Point { x: 1, y: 1 },\n    right_bottom: Point { x: 0, y: 0 }\n};\n\nlet c = || {\n    rect.left_top.x += 1;\n    rect.right_bottom.x += 1;\n    format!(\"{:?}\", rect.left_top)\n};\nf(c); // Prints \"Point { x: 2, y: 1 }\".\n\ngenerates a closure type roughly like the following:\n\n<!-- ignore: simplified -->\n,ignore\n// Note: This is not exactly how it is translated, this is only for\n// illustration.\n\nstruct Closure<'a> {\n    left_top : &'a mut Point,\n    right_bottom_x : &'a mut i32,\n}\n\nimpl<'a> FnOnce<()> for Closure<'a> {\n    type Output = String;\n    extern \"rust-call\" fn call_once(self, args: ()) -> String {\n        self.left_top.x += 1;\n        *self.right_bottom_x += 1;\n        format!(\"{:?}\", self.left_top)\n    }\n}\n\nso that the call to `f` works as if it were:\n\n<!-- ignore: continuation of above -->\n,ignore\nf(Closure{ left_top: &mut rect.left_top, right_bottom_x: &mut rect.right_bottom.x });",
      "parent_id": null,
      "paragraphs": {
        "type.closure.intro": "A [closure expression] produces a closure value with a unique, anonymous type that cannot be written out.\nA closure type is approximately equivalent to a struct which contains the captured values.\nFor instance, the following closure:\n\n#[derive(Debug)]\nstruct Point { x: i32, y: i32 }\nstruct Rectangle { left_top: Point, right_bottom: Point }\n\nfn f<F : FnOnce() -> String> (g: F) {\n    println!(\"{}\", g());\n}\n\nlet mut rect = Rectangle {\n    left_top: Point { x: 1, y: 1 },\n    right_bottom: Point { x: 0, y: 0 }\n};\n\nlet c = || {\n    rect.left_top.x += 1;\n    rect.right_bottom.x += 1;\n    format!(\"{:?}\", rect.left_top)\n};\nf(c); // Prints \"Point { x: 2, y: 1 }\".\n\ngenerates a closure type roughly like the following:\n\n<!-- ignore: simplified -->\n,ignore\n// Note: This is not exactly how it is translated, this is only for\n// illustration.\n\nstruct Closure<'a> {\n    left_top : &'a mut Point,\n    right_bottom_x : &'a mut i32,\n}\n\nimpl<'a> FnOnce<()> for Closure<'a> {\n    type Output = String;\n    extern \"rust-call\" fn call_once(self, args: ()) -> String {\n        self.left_top.x += 1;\n        *self.right_bottom_x += 1;\n        format!(\"{:?}\", self.left_top)\n    }\n}\n\nso that the call to `f` works as if it were:\n\n<!-- ignore: continuation of above -->\n,ignore\nf(Closure{ left_top: &mut rect.left_top, right_bottom_x: &mut rect.right_bottom.x });"
      }
    },
    {
      "id": "type.closure.capture",
      "title": "Capture modes",
      "level": 1,
      "content": "A *capture mode* determines how a [place expression] from the environment is borrowed or moved into the closure.\nThe capture modes are:\n\n1. Immutable borrow (`ImmBorrow`) --- The place expression is captured as a [shared reference].\n2. Unique immutable borrow (`UniqueImmBorrow`) --- This is similar to an immutable borrow, but must be unique as described below.\n3. Mutable borrow (`MutBorrow`) --- The place expression is captured as a [mutable reference].\n4. Move (`ByValue`) --- The place expression is captured by [moving the value] into the closure.\n\nPlace expressions from the environment are captured from the first mode that is compatible with how the captured value is used inside the closure body.\nThe mode is not affected by the code surrounding the closure, such as the lifetimes of involved variables or fields, or of the closure itself.\n\n[moving the value]: ../expressions.md#moved-and-copied-types\n[mutable reference]: pointer.md#mutable-references-mut\n[place expression]: ../expressions.md#place-expressions-and-value-expressions\n[shared reference]: pointer.md#references--and-mut",
      "parent_id": null,
      "paragraphs": {
        "type.closure.capture.intro": "A *capture mode* determines how a [place expression] from the environment is borrowed or moved into the closure.\nThe capture modes are:\n\n1. Immutable borrow (`ImmBorrow`) --- The place expression is captured as a [shared reference].\n2. Unique immutable borrow (`UniqueImmBorrow`) --- This is similar to an immutable borrow, but must be unique as described below.\n3. Mutable borrow (`MutBorrow`) --- The place expression is captured as a [mutable reference].\n4. Move (`ByValue`) --- The place expression is captured by [moving the value] into the closure.",
        "type.closure.capture.precedence": "Place expressions from the environment are captured from the first mode that is compatible with how the captured value is used inside the closure body.\nThe mode is not affected by the code surrounding the closure, such as the lifetimes of involved variables or fields, or of the closure itself.\n\n[moving the value]: ../expressions.md#moved-and-copied-types\n[mutable reference]: pointer.md#mutable-references-mut\n[place expression]: ../expressions.md#place-expressions-and-value-expressions\n[shared reference]: pointer.md#references--and-mut"
      }
    },
    {
      "id": "type.closure.capture.copy",
      "title": "`Copy` values",
      "level": 2,
      "content": "Values that implement [`Copy`] that are moved into the closure are captured with the `ImmBorrow` mode.\n\nlet x = [0; 1024];\nlet c = || {\n    let y = x; // x captured by ImmBorrow\n};",
      "parent_id": null,
      "paragraphs": {
        "type.closure.capture.copy": "Values that implement [`Copy`] that are moved into the closure are captured with the `ImmBorrow` mode.\n\nlet x = [0; 1024];\nlet c = || {\n    let y = x; // x captured by ImmBorrow\n};"
      }
    },
    {
      "id": "type.closure.async.input",
      "title": "Async input capture",
      "level": 3,
      "content": "Async closures always capture all input arguments, regardless of whether or not they are used within the body.\n\n## Capture precision\n\nA *capture path* is a sequence starting with a variable from the environment followed by zero or more place projections from that variable.\n\nA *place projection* is a [field access], [tuple index], [dereference] (and automatic dereferences), [array or slice index] expression, or [pattern destructuring] applied to a variable.\n\n> [!NOTE]\n> In `rustc`, pattern destructuring desugars into a series of dereferences and field or element accesses.\n\nThe closure borrows or moves the capture path, which may be truncated based on the rules described below.\n\nFor example:\n\nstruct SomeStruct {\n    f1: (i32, i32),\n}\nlet s = SomeStruct { f1: (1, 2) };\n\nlet c = || {\n    let x = s.f1.1; // s.f1.1 captured by ImmBorrow\n};\nc();\n\nHere the capture path is the local variable `s`, followed by a field access `.f1`, and then a tuple index `.1`.\nThis closure captures an immutable borrow of `s.f1.1`.\n\n[field access]: ../expressions/field-expr.md\n[pattern destructuring]: patterns.destructure\n[tuple index]: ../expressions/tuple-expr.md#tuple-indexing-expressions\n[dereference]: ../expressions/operator-expr.md#the-dereference-operator\n[array or slice index]: ../expressions/array-expr.md#array-and-slice-indexing-expressions",
      "parent_id": null,
      "paragraphs": {
        "type.closure.async.input": "Async closures always capture all input arguments, regardless of whether or not they are used within the body.\n\n## Capture precision",
        "type.closure.capture.precision.capture-path": "A *capture path* is a sequence starting with a variable from the environment followed by zero or more place projections from that variable.",
        "type.closure.capture.precision.place-projection": "A *place projection* is a [field access], [tuple index], [dereference] (and automatic dereferences), [array or slice index] expression, or [pattern destructuring] applied to a variable.\n\n> [!NOTE]\n> In `rustc`, pattern destructuring desugars into a series of dereferences and field or element accesses.",
        "type.closure.capture.precision.intro": "The closure borrows or moves the capture path, which may be truncated based on the rules described below.\n\nFor example:\n\nstruct SomeStruct {\n    f1: (i32, i32),\n}\nlet s = SomeStruct { f1: (1, 2) };\n\nlet c = || {\n    let x = s.f1.1; // s.f1.1 captured by ImmBorrow\n};\nc();\n\nHere the capture path is the local variable `s`, followed by a field access `.f1`, and then a tuple index `.1`.\nThis closure captures an immutable borrow of `s.f1.1`.\n\n[field access]: ../expressions/field-expr.md\n[pattern destructuring]: patterns.destructure\n[tuple index]: ../expressions/tuple-expr.md#tuple-indexing-expressions\n[dereference]: ../expressions/operator-expr.md#the-dereference-operator\n[array or slice index]: ../expressions/array-expr.md#array-and-slice-indexing-expressions"
      }
    },
    {
      "id": "type.closure.capture.precision.shared-prefix",
      "title": "Shared prefix",
      "level": 2,
      "content": "In the case where a capture path and one of the ancestors of that path are both captured by a closure, the ancestor path is captured with the highest capture mode among the two captures, `CaptureMode = max(AncestorCaptureMode, DescendantCaptureMode)`, using the strict weak ordering:\n\n`ImmBorrow < UniqueImmBorrow < MutBorrow < ByValue`\n\nNote that this might need to be applied recursively.\n\n// In this example, there are three different capture paths with a shared ancestor:\n# fn move_value<T>(_: T){}\nlet s = String::from(\"S\");\nlet t = (s, String::from(\"T\"));\nlet mut u = (t, String::from(\"U\"));\n\nlet c = || {\n    println!(\"{:?}\", u); // u captured by ImmBorrow\n    u.1.truncate(0); // u.0 captured by MutBorrow\n    move_value(u.0.0); // u.0.0 captured by ByValue\n};\nc();\n\nOverall this closure will capture `u` by `ByValue`.",
      "parent_id": null,
      "paragraphs": {
        "type.closure.capture.precision.shared-prefix": "In the case where a capture path and one of the ancestors of that path are both captured by a closure, the ancestor path is captured with the highest capture mode among the two captures, `CaptureMode = max(AncestorCaptureMode, DescendantCaptureMode)`, using the strict weak ordering:\n\n`ImmBorrow < UniqueImmBorrow < MutBorrow < ByValue`\n\nNote that this might need to be applied recursively.\n\n// In this example, there are three different capture paths with a shared ancestor:\n# fn move_value<T>(_: T){}\nlet s = String::from(\"S\");\nlet t = (s, String::from(\"T\"));\nlet mut u = (t, String::from(\"U\"));\n\nlet c = || {\n    println!(\"{:?}\", u); // u captured by ImmBorrow\n    u.1.truncate(0); // u.0 captured by MutBorrow\n    move_value(u.0.0); // u.0.0 captured by ByValue\n};\nc();\n\nOverall this closure will capture `u` by `ByValue`."
      }
    },
    {
      "id": "type.closure.capture.precision.dereference-shared",
      "title": "Rightmost shared reference truncation",
      "level": 1,
      "content": "The capture path is truncated at the rightmost dereference in the capture path if the dereference is applied to a shared reference.\n\nThis truncation is allowed because fields that are read through a shared reference will always be read via a shared reference or a copy.\nThis helps reduce the size of the capture when the extra precision does not yield any benefit from a borrow checking perspective.\n\nThe reason it is the *rightmost* dereference is to help avoid a shorter lifetime than is necessary.\nConsider the following example:\n\nstruct Int(i32);\nstruct B<'a>(&'a i32);\n\nstruct MyStruct<'a> {\n   a: &'static Int,\n   b: B<'a>,\n}\n\nfn foo<'a, 'b>(m: &'a MyStruct<'b>) -> impl FnMut() + 'static {\n    let c = || drop(&m.a.0);\n    c\n}\n\nIf this were to capture `m`, then the closure would no longer outlive `'static`, since `m` is constrained to `'a`. Instead, it captures `(*(*m).a)` by `ImmBorrow`.",
      "parent_id": null,
      "paragraphs": {
        "type.closure.capture.precision.dereference-shared": "The capture path is truncated at the rightmost dereference in the capture path if the dereference is applied to a shared reference.\n\nThis truncation is allowed because fields that are read through a shared reference will always be read via a shared reference or a copy.\nThis helps reduce the size of the capture when the extra precision does not yield any benefit from a borrow checking perspective.\n\nThe reason it is the *rightmost* dereference is to help avoid a shorter lifetime than is necessary.\nConsider the following example:\n\nstruct Int(i32);\nstruct B<'a>(&'a i32);\n\nstruct MyStruct<'a> {\n   a: &'static Int,\n   b: B<'a>,\n}\n\nfn foo<'a, 'b>(m: &'a MyStruct<'b>) -> impl FnMut() + 'static {\n    let c = || drop(&m.a.0);\n    c\n}\n\nIf this were to capture `m`, then the closure would no longer outlive `'static`, since `m` is constrained to `'a`. Instead, it captures `(*(*m).a)` by `ImmBorrow`."
      }
    },
    {
      "id": "type.closure.capture.precision.wildcard",
      "title": "Wildcard pattern bindings",
      "level": 3,
      "content": "Closures only capture data that needs to be read. Binding a value with a [wildcard pattern] does not read the value, so the place is not captured.\n\n,no_run\nstruct S; // A non-`Copy` type.\nlet x = S;\nlet c = || {\n    let _ = x;  // Does not capture `x`.\n};\nlet c = || match x {\n    _ => (), // Does not capture `x`.\n};\nx; // OK: `x` can be moved here.\nc();\n\nDestructuring tuples, structs, and single-variant enums does not, by itself, cause a read or the place to be captured.\n\n> [!NOTE]\n> Enums marked with [`#[non_exhaustive]`][attributes.type-system.non_exhaustive] from other crates are always treated as having multiple variants. See *[type.closure.capture.precision.discriminants.non_exhaustive]*.\n\n,no_run\nstruct S; // A non-`Copy` type.\n\n// Destructuring tuples does not cause a read or capture.\nlet x = (S,);\nlet c = || {\n    let (..) = x; // Does not capture `x`.\n};\nx; // OK: `x` can be moved here.\nc();\n\n// Destructuring unit structs does not cause a read or capture.\nlet x = S;\nlet c = || {\n    let S = x; // Does not capture `x`.\n};\nx; // OK: `x` can be moved here.\nc();\n\n// Destructuring structs does not cause a read or capture.\nstruct W<T>(T);\nlet x = W(S);\nlet c = || {\n    let W(..) = x; // Does not capture `x`.\n};\nx; // OK: `x` can be moved here.\nc();\n\n// Destructuring single-variant enums does not cause a read\n// or capture.\nenum E<T> { V(T) }\nlet x = E::V(S);\nlet c = || {\n    let E::V(..) = x; // Does not capture `x`.\n};\nx; // OK: `x` can be moved here.\nc();\n\nFields matched against [RestPattern] (`..`) or [StructPatternEtCetera] (also `..`) are not read, and those fields are not captured.\n\n,no_run\nstruct S; // A non-`Copy` type.\nlet x = (S, S);\nlet c = || {\n    let (x0, ..) = x;  // Captures `x.0` by `ByValue`.\n};\n// Only the first tuple field was captured by the closure.\nx.1; // OK: `x.1` can be moved here.\nc();\n\nPartial captures of arrays and slices are not supported; the entire slice or array is always captured even if used with wildcard pattern matching, indexing, or sub-slicing.\n\n,compile_fail,E0382\nstruct S; // A non-`Copy` type.\nlet mut x = [S, S];\nlet c = || {\n    let [x0, _] = x; // Captures all of `x` by `ByValue`.\n};\nlet _ = &mut x[1]; // ERROR: Borrow of moved value.\n\nValues that are matched with wildcards must still be initialized.\n\n,compile_fail,E0381\nlet x: u8;\nlet c = || {\n    let _ = x; // ERROR: Binding `x` isn't initialized.\n};\n\n[wildcard pattern]: ../patterns.md#wildcard-pattern",
      "parent_id": null,
      "paragraphs": {
        "type.closure.capture.precision.wildcard.reads": "Closures only capture data that needs to be read. Binding a value with a [wildcard pattern] does not read the value, so the place is not captured.\n\n,no_run\nstruct S; // A non-`Copy` type.\nlet x = S;\nlet c = || {\n    let _ = x;  // Does not capture `x`.\n};\nlet c = || match x {\n    _ => (), // Does not capture `x`.\n};\nx; // OK: `x` can be moved here.\nc();",
        "type.closure.capture.precision.wildcard.destructuring": "Destructuring tuples, structs, and single-variant enums does not, by itself, cause a read or the place to be captured.\n\n> [!NOTE]\n> Enums marked with [`#[non_exhaustive]`][attributes.type-system.non_exhaustive] from other crates are always treated as having multiple variants. See *[type.closure.capture.precision.discriminants.non_exhaustive]*.\n\n,no_run\nstruct S; // A non-`Copy` type.\n\n// Destructuring tuples does not cause a read or capture.\nlet x = (S,);\nlet c = || {\n    let (..) = x; // Does not capture `x`.\n};\nx; // OK: `x` can be moved here.\nc();\n\n// Destructuring unit structs does not cause a read or capture.\nlet x = S;\nlet c = || {\n    let S = x; // Does not capture `x`.\n};\nx; // OK: `x` can be moved here.\nc();\n\n// Destructuring structs does not cause a read or capture.\nstruct W<T>(T);\nlet x = W(S);\nlet c = || {\n    let W(..) = x; // Does not capture `x`.\n};\nx; // OK: `x` can be moved here.\nc();\n\n// Destructuring single-variant enums does not cause a read\n// or capture.\nenum E<T> { V(T) }\nlet x = E::V(S);\nlet c = || {\n    let E::V(..) = x; // Does not capture `x`.\n};\nx; // OK: `x` can be moved here.\nc();",
        "type.closure.capture.precision.wildcard.fields": "Fields matched against [RestPattern] (`..`) or [StructPatternEtCetera] (also `..`) are not read, and those fields are not captured.\n\n,no_run\nstruct S; // A non-`Copy` type.\nlet x = (S, S);\nlet c = || {\n    let (x0, ..) = x;  // Captures `x.0` by `ByValue`.\n};\n// Only the first tuple field was captured by the closure.\nx.1; // OK: `x.1` can be moved here.\nc();",
        "type.closure.capture.precision.wildcard.array-slice": "Partial captures of arrays and slices are not supported; the entire slice or array is always captured even if used with wildcard pattern matching, indexing, or sub-slicing.\n\n,compile_fail,E0382\nstruct S; // A non-`Copy` type.\nlet mut x = [S, S];\nlet c = || {\n    let [x0, _] = x; // Captures all of `x` by `ByValue`.\n};\nlet _ = &mut x[1]; // ERROR: Borrow of moved value.",
        "type.closure.capture.precision.wildcard.initialized": "Values that are matched with wildcards must still be initialized.\n\n,compile_fail,E0381\nlet x: u8;\nlet c = || {\n    let _ = x; // ERROR: Binding `x` isn't initialized.\n};\n\n[wildcard pattern]: ../patterns.md#wildcard-pattern"
      }
    },
    {
      "id": "type.closure.capture.precision.discriminants",
      "title": "Capturing for discriminant reads",
      "level": 3,
      "content": "If pattern matching reads a discriminant, the place containing that discriminant is captured by `ImmBorrow`.\n\nMatching against a variant of an enum that has more than one variant reads the discriminant, capturing the place by `ImmBorrow`.\n\n,compile_fail,E0502\nstruct S; // A non-`Copy` type.\nlet mut x = (Some(S), S);\nlet c = || match x {\n    (None, _) => (),\n//   ^^^^\n// This pattern requires reading the discriminant, which\n// causes `x.0` to be captured by `ImmBorrow`.\n    _ => (),\n};\nlet _ = &mut x.0; // ERROR: Cannot borrow `x.0` as mutable.\n//           ^^^\n// The closure is still live, so `x.0` is still immutably\n// borrowed here.\nc();\n\n,no_run\n# struct S; // A non-`Copy` type.\n# let x = (Some(S), S);\nlet c = || match x { // Captures `x.0` by `ImmBorrow`.\n    (None, _) => (),\n    _ => (),\n};\n// Though `x.0` is captured due to the discriminant read,\n// `x.1` is not captured.\nx.1; // OK: `x.1` can be moved here.\nc();\n\nMatching against the only variant of a single-variant enum does not read the discriminant and does not capture the place.\n\n,no_run\nenum E<T> { V(T) } // A single-variant enum.\nlet x = E::V(());\nlet c = || {\n    let E::V(_) = x; // Does not capture `x`.\n};\nx; // OK: `x` can be moved here.\nc();\n\nIf [`#[non_exhaustive]`][attributes.type-system.non_exhaustive] is applied to an enum defined in an external crate, the enum is treated as having multiple variants for the purpose of deciding whether a read occurs, even if it actually has only one variant.\n\nEven if all variants but the one being matched against are uninhabited, making the pattern irrefutable, the discriminant is still read if it otherwise would be.\n\n,compile_fail,E0502\nenum Empty {}\nlet mut x = Ok::<_, Empty>(42);\nlet c = || {\n    let Ok(_) = x; // Captures `x` by `ImmBorrow`.\n};\nlet _ = &mut x; // ERROR: Cannot borrow `x` as mutable.\nc();",
      "parent_id": null,
      "paragraphs": {
        "type.closure.capture.precision.discriminants.reads": "If pattern matching reads a discriminant, the place containing that discriminant is captured by `ImmBorrow`.",
        "type.closure.capture.precision.discriminants.multiple-variant": "Matching against a variant of an enum that has more than one variant reads the discriminant, capturing the place by `ImmBorrow`.\n\n,compile_fail,E0502\nstruct S; // A non-`Copy` type.\nlet mut x = (Some(S), S);\nlet c = || match x {\n    (None, _) => (),\n//   ^^^^\n// This pattern requires reading the discriminant, which\n// causes `x.0` to be captured by `ImmBorrow`.\n    _ => (),\n};\nlet _ = &mut x.0; // ERROR: Cannot borrow `x.0` as mutable.\n//           ^^^\n// The closure is still live, so `x.0` is still immutably\n// borrowed here.\nc();\n\n,no_run\n# struct S; // A non-`Copy` type.\n# let x = (Some(S), S);\nlet c = || match x { // Captures `x.0` by `ImmBorrow`.\n    (None, _) => (),\n    _ => (),\n};\n// Though `x.0` is captured due to the discriminant read,\n// `x.1` is not captured.\nx.1; // OK: `x.1` can be moved here.\nc();",
        "type.closure.capture.precision.discriminants.single-variant": "Matching against the only variant of a single-variant enum does not read the discriminant and does not capture the place.\n\n,no_run\nenum E<T> { V(T) } // A single-variant enum.\nlet x = E::V(());\nlet c = || {\n    let E::V(_) = x; // Does not capture `x`.\n};\nx; // OK: `x` can be moved here.\nc();",
        "type.closure.capture.precision.discriminants.non_exhaustive": "If [`#[non_exhaustive]`][attributes.type-system.non_exhaustive] is applied to an enum defined in an external crate, the enum is treated as having multiple variants for the purpose of deciding whether a read occurs, even if it actually has only one variant.",
        "type.closure.capture.precision.discriminants.uninhabited-variants": "Even if all variants but the one being matched against are uninhabited, making the pattern irrefutable, the discriminant is still read if it otherwise would be.\n\n,compile_fail,E0502\nenum Empty {}\nlet mut x = Ok::<_, Empty>(42);\nlet c = || {\n    let Ok(_) = x; // Captures `x` by `ImmBorrow`.\n};\nlet _ = &mut x; // ERROR: Cannot borrow `x` as mutable.\nc();"
      }
    },
    {
      "id": "type.closure.capture.precision.range-patterns",
      "title": "Capturing and range patterns",
      "level": 1,
      "content": "Matching against a range pattern reads the place being matched, even if the range includes all possible values of the type, and captures the place by `ImmBorrow`.\n\n,compile_fail,E0502\nlet mut x = 0u8;\nlet c = || {\n    let 0..=u8::MAX = x; // Captures `x` by `ImmBorrow`.\n};\nlet _ = &mut x; // ERROR: Cannot borrow `x` as mutable.\nc();",
      "parent_id": null,
      "paragraphs": {
        "type.closure.capture.precision.range-patterns.reads": "Matching against a range pattern reads the place being matched, even if the range includes all possible values of the type, and captures the place by `ImmBorrow`.\n\n,compile_fail,E0502\nlet mut x = 0u8;\nlet c = || {\n    let 0..=u8::MAX = x; // Captures `x` by `ImmBorrow`.\n};\nlet _ = &mut x; // ERROR: Cannot borrow `x` as mutable.\nc();"
      }
    },
    {
      "id": "type.closure.capture.precision.slice-patterns",
      "title": "Capturing and slice patterns",
      "level": 3,
      "content": "Matching a slice against a slice pattern other than one with only a single rest pattern (i.e. `[..]`) is treated as a read of the length from the slice and captures the slice by `ImmBorrow`.\n\n,compile_fail,E0502\nlet x: &mut [u8] = &mut [];\nlet c = || match x { // Captures `*x` by `ImmBorrow`.\n    &mut [] => (),\n//       ^^\n// This matches a slice of exactly zero elements. To know whether the\n// scrutinee matches, the length must be read, causing the slice to\n// be captured.\n    _ => (),\n};\nlet _ = &mut *x; // ERROR: Cannot borrow `*x` as mutable.\nc();\n\n,no_run\nlet x: &mut [u8] = &mut [];\nlet c = || match x { // Does not capture `*x`.\n    [..] => (),\n//   ^^ Rest pattern.\n};\nlet _ = &mut *x; // OK: `*x` can be borrow here.\nc();\n\n> [!NOTE]\n> Perhaps surprisingly, even though the length is contained in the (wide) *pointer* to the slice, it is the place of the *pointee* (the slice) that is treated as read and is captured.\n>\n> ```rust,no_run\n> fn f<'l: 's, 's>(x: &'s mut &'l [u8]) -> impl Fn() + 'l {\n>     // The closure outlives `'l` because it captures `**x`. If\n>     // instead it captured `*x`, it would not live long enough\n>     // to satisfy the `impl Fn() + 'l` bound.\n>     || match *x { // Captures `**x` by `ImmBorrow`.\n>         &[] => (),\n>         _ => (),\n>     }\n> }\n> ```\n>\n> In this way, the behavior is consistent with dereferencing to the slice in the scrutinee.\n>\n> ```rust,no_run\n> fn f<'l: 's, 's>(x: &'s mut &'l [u8]) -> impl Fn() + 'l {\n>     || match **x { // Captures `**x` by `ImmBorrow`.\n>         [] => (),\n>         _ => (),\n>     }\n> }\n> ```\n>\n> For details, see Rust PR #138961.\n\nAs the length of an array is fixed by its type, matching an array against a slice pattern does not by itself capture the place.\n\n,no_run\nlet x: [u8; 1] = [0];\nlet c = || match x { // Does not capture `x`.\n    [_] => (), // Length is fixed.\n};\nx; // OK: `x` can be moved here.\nc();",
      "parent_id": null,
      "paragraphs": {
        "type.closure.capture.precision.slice-patterns.slices": "Matching a slice against a slice pattern other than one with only a single rest pattern (i.e. `[..]`) is treated as a read of the length from the slice and captures the slice by `ImmBorrow`.\n\n,compile_fail,E0502\nlet x: &mut [u8] = &mut [];\nlet c = || match x { // Captures `*x` by `ImmBorrow`.\n    &mut [] => (),\n//       ^^\n// This matches a slice of exactly zero elements. To know whether the\n// scrutinee matches, the length must be read, causing the slice to\n// be captured.\n    _ => (),\n};\nlet _ = &mut *x; // ERROR: Cannot borrow `*x` as mutable.\nc();\n\n,no_run\nlet x: &mut [u8] = &mut [];\nlet c = || match x { // Does not capture `*x`.\n    [..] => (),\n//   ^^ Rest pattern.\n};\nlet _ = &mut *x; // OK: `*x` can be borrow here.\nc();\n\n> [!NOTE]\n> Perhaps surprisingly, even though the length is contained in the (wide) *pointer* to the slice, it is the place of the *pointee* (the slice) that is treated as read and is captured.\n>\n> ```rust,no_run\n> fn f<'l: 's, 's>(x: &'s mut &'l [u8]) -> impl Fn() + 'l {\n>     // The closure outlives `'l` because it captures `**x`. If\n>     // instead it captured `*x`, it would not live long enough\n>     // to satisfy the `impl Fn() + 'l` bound.\n>     || match *x { // Captures `**x` by `ImmBorrow`.\n>         &[] => (),\n>         _ => (),\n>     }\n> }\n> ```\n>\n> In this way, the behavior is consistent with dereferencing to the slice in the scrutinee.\n>\n> ```rust,no_run\n> fn f<'l: 's, 's>(x: &'s mut &'l [u8]) -> impl Fn() + 'l {\n>     || match **x { // Captures `**x` by `ImmBorrow`.\n>         [] => (),\n>         _ => (),\n>     }\n> }\n> ```\n>\n> For details, see Rust PR #138961.",
        "type.closure.capture.precision.slice-patterns.arrays": "As the length of an array is fixed by its type, matching an array against a slice pattern does not by itself capture the place.\n\n,no_run\nlet x: [u8; 1] = [0];\nlet c = || match x { // Does not capture `x`.\n    [_] => (), // Length is fixed.\n};\nx; // OK: `x` can be moved here.\nc();"
      }
    },
    {
      "id": "type.closure.capture.precision.move-dereference",
      "title": "Capturing references in move contexts",
      "level": 3,
      "content": "Because it is not allowed to move fields out of a reference, `move` closures will only capture the prefix of a capture path that runs up to, but not including, the first dereference of a reference.\nThe reference itself will be moved into the closure.\n\nstruct T(String, String);\n\nlet mut t = T(String::from(\"foo\"), String::from(\"bar\"));\nlet t_mut_ref = &mut t;\nlet mut c = move || {\n    t_mut_ref.0.push_str(\"123\"); // captures `t_mut_ref` ByValue\n};\nc();",
      "parent_id": null,
      "paragraphs": {
        "type.closure.capture.precision.move-dereference": "Because it is not allowed to move fields out of a reference, `move` closures will only capture the prefix of a capture path that runs up to, but not including, the first dereference of a reference.\nThe reference itself will be moved into the closure.\n\nstruct T(String, String);\n\nlet mut t = T(String::from(\"foo\"), String::from(\"bar\"));\nlet t_mut_ref = &mut t;\nlet mut c = move || {\n    t_mut_ref.0.push_str(\"123\"); // captures `t_mut_ref` ByValue\n};\nc();"
      }
    },
    {
      "id": "type.closure.capture.precision.raw-pointer-dereference",
      "title": "Raw pointer dereference",
      "level": 3,
      "content": "Because it is `unsafe` to dereference a raw pointer, closures will only capture the prefix of a capture path that runs up to, but not including, the first dereference of a raw pointer.\n\nstruct T(String, String);\n\nlet t = T(String::from(\"foo\"), String::from(\"bar\"));\nlet t_ptr = &t as *const T;\n\nlet c = || unsafe {\n    println!(\"{}\", (*t_ptr).0); // captures `t_ptr` by ImmBorrow\n};\nc();",
      "parent_id": null,
      "paragraphs": {
        "type.closure.capture.precision.raw-pointer-dereference": "Because it is `unsafe` to dereference a raw pointer, closures will only capture the prefix of a capture path that runs up to, but not including, the first dereference of a raw pointer.\n\nstruct T(String, String);\n\nlet t = T(String::from(\"foo\"), String::from(\"bar\"));\nlet t_ptr = &t as *const T;\n\nlet c = || unsafe {\n    println!(\"{}\", (*t_ptr).0); // captures `t_ptr` by ImmBorrow\n};\nc();"
      }
    },
    {
      "id": "type.closure.capture.precision.union",
      "title": "Union fields",
      "level": 3,
      "content": "Because it is `unsafe` to access a union field, closures will only capture the prefix of a capture path that runs up to the union itself.\n\nunion U {\n    a: (i32, i32),\n    b: bool,\n}\nlet u = U { a: (123, 456) };\n\nlet c = || {\n    let x = unsafe { u.a.0 }; // captures `u` ByValue\n};\nc();\n\n// This also includes writing to fields.\nlet mut u = U { a: (123, 456) };\n\nlet mut c = || {\n    u.b = true; // captures `u` with MutBorrow\n};\nc();",
      "parent_id": null,
      "paragraphs": {
        "type.closure.capture.precision.union": "Because it is `unsafe` to access a union field, closures will only capture the prefix of a capture path that runs up to the union itself.\n\nunion U {\n    a: (i32, i32),\n    b: bool,\n}\nlet u = U { a: (123, 456) };\n\nlet c = || {\n    let x = unsafe { u.a.0 }; // captures `u` ByValue\n};\nc();\n\n// This also includes writing to fields.\nlet mut u = U { a: (123, 456) };\n\nlet mut c = || {\n    u.b = true; // captures `u` with MutBorrow\n};\nc();"
      }
    },
    {
      "id": "type.closure.capture.precision.unaligned",
      "title": "Reference into unaligned `struct`s",
      "level": 3,
      "content": "Because it is [undefined behavior] to create references to unaligned fields in a structure,\nclosures will only capture the prefix of the capture path that runs up to, but not including, the first field access into a structure that uses [the `packed` representation].\nThis includes all fields, even those that are aligned, to protect against compatibility concerns should any of the fields in the structure change in the future.\n\n#[repr(packed)]\nstruct T(i32, i32);\n\nlet t = T(2, 5);\nlet c = || {\n    let a = t.0; // captures `t` with ImmBorrow\n};\n// Copies out of `t` are ok.\nlet (a, b) = (t.0, t.1);\nc();\n\nSimilarly, taking the address of an unaligned field also captures the entire struct:\n\n,compile_fail,E0505\n#[repr(packed)]\nstruct T(String, String);\n\nlet mut t = T(String::new(), String::new());\nlet c = || {\n    let a = std::ptr::addr_of!(t.1); // captures `t` with ImmBorrow\n};\nlet a = t.0; // ERROR: cannot move out of `t.0` because it is borrowed\nc();\n\nbut the above works if it is not packed since it captures the field precisely:\n\nstruct T(String, String);\n\nlet mut t = T(String::new(), String::new());\nlet c = || {\n    let a = std::ptr::addr_of!(t.1); // captures `t.1` with ImmBorrow\n};\n// The move here is allowed.\nlet a = t.0;\nc();\n\n[undefined behavior]: ../behavior-considered-undefined.md\n[the `packed` representation]: ../type-layout.md#the-alignment-modifiers",
      "parent_id": null,
      "paragraphs": {
        "type.closure.capture.precision.unaligned": "Because it is [undefined behavior] to create references to unaligned fields in a structure,\nclosures will only capture the prefix of the capture path that runs up to, but not including, the first field access into a structure that uses [the `packed` representation].\nThis includes all fields, even those that are aligned, to protect against compatibility concerns should any of the fields in the structure change in the future.\n\n#[repr(packed)]\nstruct T(i32, i32);\n\nlet t = T(2, 5);\nlet c = || {\n    let a = t.0; // captures `t` with ImmBorrow\n};\n// Copies out of `t` are ok.\nlet (a, b) = (t.0, t.1);\nc();\n\nSimilarly, taking the address of an unaligned field also captures the entire struct:\n\n,compile_fail,E0505\n#[repr(packed)]\nstruct T(String, String);\n\nlet mut t = T(String::new(), String::new());\nlet c = || {\n    let a = std::ptr::addr_of!(t.1); // captures `t` with ImmBorrow\n};\nlet a = t.0; // ERROR: cannot move out of `t.0` because it is borrowed\nc();\n\nbut the above works if it is not packed since it captures the field precisely:\n\nstruct T(String, String);\n\nlet mut t = T(String::new(), String::new());\nlet c = || {\n    let a = std::ptr::addr_of!(t.1); // captures `t.1` with ImmBorrow\n};\n// The move here is allowed.\nlet a = t.0;\nc();\n\n[undefined behavior]: ../behavior-considered-undefined.md\n[the `packed` representation]: ../type-layout.md#the-alignment-modifiers"
      }
    },
    {
      "id": "type.closure.capture.precision.box-deref",
      "title": "`Box` vs other `Deref` implementations",
      "level": 3,
      "content": "The implementation of the [`Deref`] trait for [`Box`] is treated differently from other `Deref` implementations, as it is considered a special entity.\n\nFor example, let us look at examples involving `Rc` and `Box`. The `*rc` is desugared to a call to the trait method `deref` defined on `Rc`, but since `*box` is treated differently, it is possible to do a precise capture of the contents of the `Box`.\n\n[`Box`]: ../special-types-and-traits.md#boxt\n[`Deref`]: ../special-types-and-traits.md#deref-and-derefmut",
      "parent_id": null,
      "paragraphs": {
        "type.closure.capture.precision.box-deref": "The implementation of the [`Deref`] trait for [`Box`] is treated differently from other `Deref` implementations, as it is considered a special entity.\n\nFor example, let us look at examples involving `Rc` and `Box`. The `*rc` is desugared to a call to the trait method `deref` defined on `Rc`, but since `*box` is treated differently, it is possible to do a precise capture of the contents of the `Box`.\n\n[`Box`]: ../special-types-and-traits.md#boxt\n[`Deref`]: ../special-types-and-traits.md#deref-and-derefmut"
      }
    },
    {
      "id": "type.closure.capture.precision.box-non-move.not-moved",
      "title": "`Box` with non-`move` closure",
      "level": 3,
      "content": "In a non-`move` closure, if the contents of the `Box` are not moved into the closure body, the contents of the `Box` are precisely captured.\n\nstruct S(String);\n\nlet b = Box::new(S(String::new()));\nlet c_box = || {\n    let x = &(*b).0; // captures `(*b).0` by ImmBorrow\n};\nc_box();\n\n// Contrast `Box` with another type that implements Deref:\nlet r = std::rc::Rc::new(S(String::new()));\nlet c_rc = || {\n    let x = &(*r).0; // captures `r` by ImmBorrow\n};\nc_rc();\n\nHowever, if the contents of the `Box` are moved into the closure, then the box is entirely captured. This is done so the amount of data that needs to be moved into the closure is minimized.\n\n// This is the same as the example above except the closure\n// moves the value instead of taking a reference to it.\n\nstruct S(String);\n\nlet b = Box::new(S(String::new()));\nlet c_box = || {\n    let x = (*b).0; // captures `b` with ByValue\n};\nc_box();",
      "parent_id": null,
      "paragraphs": {
        "type.closure.capture.precision.box-non-move.not-moved": "In a non-`move` closure, if the contents of the `Box` are not moved into the closure body, the contents of the `Box` are precisely captured.\n\nstruct S(String);\n\nlet b = Box::new(S(String::new()));\nlet c_box = || {\n    let x = &(*b).0; // captures `(*b).0` by ImmBorrow\n};\nc_box();\n\n// Contrast `Box` with another type that implements Deref:\nlet r = std::rc::Rc::new(S(String::new()));\nlet c_rc = || {\n    let x = &(*r).0; // captures `r` by ImmBorrow\n};\nc_rc();",
        "type.closure.capture.precision.box-non-move.moved": "However, if the contents of the `Box` are moved into the closure, then the box is entirely captured. This is done so the amount of data that needs to be moved into the closure is minimized.\n\n// This is the same as the example above except the closure\n// moves the value instead of taking a reference to it.\n\nstruct S(String);\n\nlet b = Box::new(S(String::new()));\nlet c_box = || {\n    let x = (*b).0; // captures `b` with ByValue\n};\nc_box();"
      }
    },
    {
      "id": "type.closure.capture.precision.box-move.read",
      "title": "`Box` with move closure",
      "level": 4,
      "content": "Similarly to moving contents of a `Box` in a non-`move` closure, reading the contents of a `Box` in a `move` closure will capture the `Box` entirely.\n\nstruct S(i32);\n\nlet b = Box::new(S(10));\nlet c_box = move || {\n    let x = (*b).0; // captures `b` with ByValue\n};",
      "parent_id": null,
      "paragraphs": {
        "type.closure.capture.precision.box-move.read": "Similarly to moving contents of a `Box` in a non-`move` closure, reading the contents of a `Box` in a `move` closure will capture the `Box` entirely.\n\nstruct S(i32);\n\nlet b = Box::new(S(10));\nlet c_box = move || {\n    let x = (*b).0; // captures `b` with ByValue\n};"
      }
    },
    {
      "id": "type.closure.unique-immutable",
      "title": "Unique immutable borrows in captures",
      "level": 4,
      "content": "Captures can occur by a special kind of borrow called a _unique immutable borrow_,\nwhich cannot be used anywhere else in the language and cannot be written out explicitly.\nIt occurs when modifying the referent of a mutable reference, as in the following example:\n\nlet mut b = false;\nlet x = &mut b;\nlet mut c = || {\n    // An ImmBorrow and a MutBorrow of `x`.\n    let a = &x;\n    *x = true; // `x` captured by UniqueImmBorrow\n};\n// The following line is an error:\n// let y = &x;\nc();\n// However, the following is OK.\nlet z = &x;\n\nIn this case, borrowing `x` mutably is not possible, because `x` is not `mut`.\nBut at the same time, borrowing `x` immutably would make the assignment illegal,\nbecause a `& &mut` reference might not be unique, so it cannot safely be used to modify a value.\nSo a unique immutable borrow is used: it borrows `x` immutably, but like a mutable borrow, it must be unique.\n\nIn the above example, uncommenting the declaration of `y` will produce an error because it would violate the uniqueness of the closure's borrow of `x`; the declaration of z is valid because the closure's lifetime has expired at the end of the block, releasing the borrow.",
      "parent_id": null,
      "paragraphs": {
        "type.closure.unique-immutable": "Captures can occur by a special kind of borrow called a _unique immutable borrow_,\nwhich cannot be used anywhere else in the language and cannot be written out explicitly.\nIt occurs when modifying the referent of a mutable reference, as in the following example:\n\nlet mut b = false;\nlet x = &mut b;\nlet mut c = || {\n    // An ImmBorrow and a MutBorrow of `x`.\n    let a = &x;\n    *x = true; // `x` captured by UniqueImmBorrow\n};\n// The following line is an error:\n// let y = &x;\nc();\n// However, the following is OK.\nlet z = &x;\n\nIn this case, borrowing `x` mutably is not possible, because `x` is not `mut`.\nBut at the same time, borrowing `x` immutably would make the assignment illegal,\nbecause a `& &mut` reference might not be unique, so it cannot safely be used to modify a value.\nSo a unique immutable borrow is used: it borrows `x` immutably, but like a mutable borrow, it must be unique.\n\nIn the above example, uncommenting the declaration of `y` will produce an error because it would violate the uniqueness of the closure's borrow of `x`; the declaration of z is valid because the closure's lifetime has expired at the end of the block, releasing the borrow."
      }
    },
    {
      "id": "type.closure.call",
      "title": "Call traits and coercions",
      "level": 2,
      "content": "Closure types all implement [`FnOnce`], indicating that they can be called once\nby consuming ownership of the closure. Additionally, some closures implement\nmore specific call traits:\n\n* A closure which does not move out of any captured variables implements\n  [`FnMut`], indicating that it can be called by mutable reference.\n\n* A closure which does not mutate or move out of any captured variables\n  implements [`Fn`], indicating that it can be called by shared reference.\n\n> [!NOTE]\n> `move` closures may still implement [`Fn`] or [`FnMut`], even though they capture variables by move. This is because the traits implemented by a closure type are determined by what the closure does with captured values, not how it captures them.\n\n*Non-capturing closures* are closures that don't capture anything from their\nenvironment. Non-async, non-capturing closures can be coerced to function pointers (e.g., `fn()`)\nwith the matching signature.\n\nlet add = |x, y| x + y;\n\nlet mut x = add(5,7);\n\ntype Binop = fn(i32, i32) -> i32;\nlet bo: Binop = add;\nx = bo(5,7);",
      "parent_id": null,
      "paragraphs": {
        "type.closure.call.intro": "Closure types all implement [`FnOnce`], indicating that they can be called once\nby consuming ownership of the closure. Additionally, some closures implement\nmore specific call traits:",
        "type.closure.call.fn-mut": "* A closure which does not move out of any captured variables implements\n  [`FnMut`], indicating that it can be called by mutable reference.",
        "type.closure.call.fn": "* A closure which does not mutate or move out of any captured variables\n  implements [`Fn`], indicating that it can be called by shared reference.\n\n> [!NOTE]\n> `move` closures may still implement [`Fn`] or [`FnMut`], even though they capture variables by move. This is because the traits implemented by a closure type are determined by what the closure does with captured values, not how it captures them.",
        "type.closure.non-capturing": "*Non-capturing closures* are closures that don't capture anything from their\nenvironment. Non-async, non-capturing closures can be coerced to function pointers (e.g., `fn()`)\nwith the matching signature.\n\nlet add = |x, y| x + y;\n\nlet mut x = add(5,7);\n\ntype Binop = fn(i32, i32) -> i32;\nlet bo: Binop = add;\nx = bo(5,7);"
      }
    },
    {
      "id": "type.closure.async.traits",
      "title": "Async closure traits",
      "level": 2,
      "content": "Async closures have a further restriction of whether or not they implement [`FnMut`] or [`Fn`].\n\nThe [`Future`] returned by the async closure has similar capturing characteristics as a closure. It captures place expressions from the async closure based on how they are used. The async closure is said to be *lending* to its [`Future`] if it has either of the following properties:\n\n- The `Future` includes a mutable capture.\n- The async closure captures by value, except when the value is accessed with a dereference projection.\n\nIf the async closure is lending to its `Future`, then [`FnMut`] and [`Fn`] are *not* implemented. [`FnOnce`] is always implemented.\n\n> **Example**: The first clause for a mutable capture can be illustrated with the following:\n>\n> ```rust,compile_fail\n> fn takes_callback<Fut: Future>(c: impl FnMut() -> Fut) {}\n>\n> fn f() {\n>     let mut x = 1i32;\n>     let c = async || {\n>         x = 2;  // x captured with MutBorrow\n>     };\n>     takes_callback(c);  // ERROR: async closure does not implement `FnMut`\n> }\n> ```\n>\n> The second clause for a regular value capture can be illustrated with the following:\n>\n> ```rust,compile_fail\n> fn takes_callback<Fut: Future>(c: impl Fn() -> Fut) {}\n>\n> fn f() {\n>     let x = &1i32;\n>     let c = async move || {\n>         let a = x + 2;  // x captured ByValue\n>     };\n>     takes_callback(c);  // ERROR: async closure does not implement `Fn`\n> }\n> ```\n>\n> The exception of the the second clause can be illustrated by using a dereference, which does allow `Fn` and `FnMut` to be implemented:\n>\n> ```rust\n> fn takes_callback<Fut: Future>(c: impl Fn() -> Fut) {}\n>\n> fn f() {\n>     let x = &1i32;\n>     let c = async move || {\n>         let a = *x + 2;\n>     };\n>     takes_callback(c);  // OK: implements `Fn`\n> }\n> ```\n\nAsync closures implement [`AsyncFn`], [`AsyncFnMut`], and [`AsyncFnOnce`] in an analogous way as regular closures implement [`Fn`], [`FnMut`], and [`FnOnce`]; that is, depending on the use of the captured variables in its body.",
      "parent_id": null,
      "paragraphs": {
        "type.closure.async.traits.fn-family": "Async closures have a further restriction of whether or not they implement [`FnMut`] or [`Fn`].\n\nThe [`Future`] returned by the async closure has similar capturing characteristics as a closure. It captures place expressions from the async closure based on how they are used. The async closure is said to be *lending* to its [`Future`] if it has either of the following properties:\n\n- The `Future` includes a mutable capture.\n- The async closure captures by value, except when the value is accessed with a dereference projection.\n\nIf the async closure is lending to its `Future`, then [`FnMut`] and [`Fn`] are *not* implemented. [`FnOnce`] is always implemented.\n\n> **Example**: The first clause for a mutable capture can be illustrated with the following:\n>\n> ```rust,compile_fail\n> fn takes_callback<Fut: Future>(c: impl FnMut() -> Fut) {}\n>\n> fn f() {\n>     let mut x = 1i32;\n>     let c = async || {\n>         x = 2;  // x captured with MutBorrow\n>     };\n>     takes_callback(c);  // ERROR: async closure does not implement `FnMut`\n> }\n> ```\n>\n> The second clause for a regular value capture can be illustrated with the following:\n>\n> ```rust,compile_fail\n> fn takes_callback<Fut: Future>(c: impl Fn() -> Fut) {}\n>\n> fn f() {\n>     let x = &1i32;\n>     let c = async move || {\n>         let a = x + 2;  // x captured ByValue\n>     };\n>     takes_callback(c);  // ERROR: async closure does not implement `Fn`\n> }\n> ```\n>\n> The exception of the the second clause can be illustrated by using a dereference, which does allow `Fn` and `FnMut` to be implemented:\n>\n> ```rust\n> fn takes_callback<Fut: Future>(c: impl Fn() -> Fut) {}\n>\n> fn f() {\n>     let x = &1i32;\n>     let c = async move || {\n>         let a = *x + 2;\n>     };\n>     takes_callback(c);  // OK: implements `Fn`\n> }\n> ```",
        "type.closure.async.traits.async-family": "Async closures implement [`AsyncFn`], [`AsyncFnMut`], and [`AsyncFnOnce`] in an analogous way as regular closures implement [`Fn`], [`FnMut`], and [`FnOnce`]; that is, depending on the use of the captured variables in its body."
      }
    },
    {
      "id": "type.closure.traits",
      "title": "Other traits",
      "level": 3,
      "content": "All closure types implement [`Sized`]. Additionally, closure types implement the\nfollowing traits if allowed to do so by the types of the captures it stores:\n\n* [`Clone`]\n* [`Copy`]\n* [`Sync`]\n* [`Send`]\n\nThe rules for [`Send`] and [`Sync`] match those for normal struct types, while\n[`Clone`] and [`Copy`] behave as if [derived]. For [`Clone`], the order of\ncloning of the captured values is left unspecified.\n\nBecause captures are often by reference, the following general rules arise:\n\n* A closure is [`Sync`] if all captured values are [`Sync`].\n* A closure is [`Send`] if all values captured by non-unique immutable\n  reference are [`Sync`], and all values captured by unique immutable or mutable\n  reference, copy, or move are [`Send`].\n* A closure is [`Clone`] or [`Copy`] if it does not capture any values by\n  unique immutable or mutable reference, and if all values it captures by copy\n  or move are [`Clone`] or [`Copy`], respectively.\n\n[`Clone`]: ../special-types-and-traits.md#clone\n[`Copy`]: ../special-types-and-traits.md#copy\n[`Send`]: ../special-types-and-traits.md#send\n[`Sized`]: ../special-types-and-traits.md#sized\n[`Sync`]: ../special-types-and-traits.md#sync\n[closure expression]: ../expressions/closure-expr.md\n[derived]: ../attributes/derive.md",
      "parent_id": null,
      "paragraphs": {
        "type.closure.traits.intro": "All closure types implement [`Sized`]. Additionally, closure types implement the\nfollowing traits if allowed to do so by the types of the captures it stores:\n\n* [`Clone`]\n* [`Copy`]\n* [`Sync`]\n* [`Send`]",
        "type.closure.traits.behavior": "The rules for [`Send`] and [`Sync`] match those for normal struct types, while\n[`Clone`] and [`Copy`] behave as if [derived]. For [`Clone`], the order of\ncloning of the captured values is left unspecified.\n\nBecause captures are often by reference, the following general rules arise:\n\n* A closure is [`Sync`] if all captured values are [`Sync`].\n* A closure is [`Send`] if all values captured by non-unique immutable\n  reference are [`Sync`], and all values captured by unique immutable or mutable\n  reference, copy, or move are [`Send`].\n* A closure is [`Clone`] or [`Copy`] if it does not capture any values by\n  unique immutable or mutable reference, and if all values it captures by copy\n  or move are [`Clone`] or [`Copy`], respectively.\n\n[`Clone`]: ../special-types-and-traits.md#clone\n[`Copy`]: ../special-types-and-traits.md#copy\n[`Send`]: ../special-types-and-traits.md#send\n[`Sized`]: ../special-types-and-traits.md#sized\n[`Sync`]: ../special-types-and-traits.md#sync\n[closure expression]: ../expressions/closure-expr.md\n[derived]: ../attributes/derive.md"
      }
    },
    {
      "id": "type.closure.drop-order",
      "title": "Drop order",
      "level": 3,
      "content": "If a closure captures a field of a composite types such as structs, tuples, and enums by value, the field's lifetime would now be tied to the closure. As a result, it is possible for disjoint fields of a composite types to be dropped at different times.\n\n{\n    let tuple =\n      (String::from(\"foo\"), String::from(\"bar\")); // --+\n    { //                                               |\n        let c = || { // ----------------------------+  |\n            // tuple.0 is captured into the closure |  |\n            drop(tuple.0); //                       |  |\n        }; //                                       |  |\n    } // 'c' and 'tuple.0' dropped here ------------+  |\n} // tuple.1 dropped here -----------------------------+",
      "parent_id": null,
      "paragraphs": {
        "type.closure.drop-order": "If a closure captures a field of a composite types such as structs, tuples, and enums by value, the field's lifetime would now be tied to the closure. As a result, it is possible for disjoint fields of a composite types to be dropped at different times.\n\n{\n    let tuple =\n      (String::from(\"foo\"), String::from(\"bar\")); // --+\n    { //                                               |\n        let c = || { // ----------------------------+  |\n            // tuple.0 is captured into the closure |  |\n            drop(tuple.0); //                       |  |\n        }; //                                       |  |\n    } // 'c' and 'tuple.0' dropped here ------------+  |\n} // tuple.1 dropped here -----------------------------+"
      }
    },
    {
      "id": "type.closure.capture.precision.edition2018.entirety",
      "title": "Edition 2018 and before",
      "level": 2,
      "content": "### Closure types difference\n\nIn Edition 2018 and before, closures always capture a variable in its entirety, without its precise capture path. This means that for the example used in the Closure types section, the generated closure type would instead look something like this:\n\n<!-- ignore: simplified -->\n,ignore\nstruct Closure<'a> {\n    rect : &'a mut Rectangle,\n}\n\nimpl<'a> FnOnce<()> for Closure<'a> {\n    type Output = String;\n    extern \"rust-call\" fn call_once(self, args: ()) -> String {\n        self.rect.left_top.x += 1;\n        self.rect.right_bottom.x += 1;\n        format!(\"{:?}\", self.rect.left_top)\n    }\n}\n\nand the call to `f` would work as follows:\n\n<!-- ignore: continuation of above -->\n,ignore\nf(Closure { rect: rect });",
      "parent_id": null,
      "paragraphs": {
        "type.closure.capture.precision.edition2018.entirety": "### Closure types difference\n\nIn Edition 2018 and before, closures always capture a variable in its entirety, without its precise capture path. This means that for the example used in the Closure types section, the generated closure type would instead look something like this:\n\n<!-- ignore: simplified -->\n,ignore\nstruct Closure<'a> {\n    rect : &'a mut Rectangle,\n}\n\nimpl<'a> FnOnce<()> for Closure<'a> {\n    type Output = String;\n    extern \"rust-call\" fn call_once(self, args: ()) -> String {\n        self.rect.left_top.x += 1;\n        self.rect.right_bottom.x += 1;\n        format!(\"{:?}\", self.rect.left_top)\n    }\n}\n\nand the call to `f` would work as follows:\n\n<!-- ignore: continuation of above -->\n,ignore\nf(Closure { rect: rect });"
      }
    },
    {
      "id": "type.closure.capture.precision.edition2018.composite",
      "title": "Capture precision difference",
      "level": 3,
      "content": "Composite types such as structs, tuples, and enums are always captured in its entirety,\nnot by individual fields. As a result, it may be necessary to borrow into a local variable in order to capture a single field:\n\n# use std::collections::HashSet;\n#\nstruct SetVec {\n    set: HashSet<u32>,\n    vec: Vec<u32>\n}\n\nimpl SetVec {\n    fn populate(&mut self) {\n        let vec = &mut self.vec;\n        self.set.iter().for_each(|&n| {\n            vec.push(n);\n        })\n    }\n}\n\nIf, instead, the closure were to use `self.vec` directly, then it would attempt to capture `self` by mutable reference. But since `self.set` is already borrowed to iterate over, the code would not compile.\n\nIf the `move` keyword is used, then all captures are by move or, for `Copy` types, by copy, regardless of whether a borrow would work. The `move` keyword is usually used to allow the closure to outlive the captured values, such as if the closure is being returned or used to spawn a new thread.\n\nRegardless of if the data will be read by the closure, i.e. in case of wild card patterns, if a variable defined outside the closure is mentioned within the closure the variable will be captured in its entirety.",
      "parent_id": null,
      "paragraphs": {
        "type.closure.capture.precision.edition2018.composite": "Composite types such as structs, tuples, and enums are always captured in its entirety,\nnot by individual fields. As a result, it may be necessary to borrow into a local variable in order to capture a single field:\n\n# use std::collections::HashSet;\n#\nstruct SetVec {\n    set: HashSet<u32>,\n    vec: Vec<u32>\n}\n\nimpl SetVec {\n    fn populate(&mut self) {\n        let vec = &mut self.vec;\n        self.set.iter().for_each(|&n| {\n            vec.push(n);\n        })\n    }\n}\n\nIf, instead, the closure were to use `self.vec` directly, then it would attempt to capture `self` by mutable reference. But since `self.set` is already borrowed to iterate over, the code would not compile.",
        "type.closure.capture.precision.edition2018.move": "If the `move` keyword is used, then all captures are by move or, for `Copy` types, by copy, regardless of whether a borrow would work. The `move` keyword is usually used to allow the closure to outlive the captured values, such as if the closure is being returned or used to spawn a new thread.",
        "type.closure.capture.precision.edition2018.wildcard": "Regardless of if the data will be read by the closure, i.e. in case of wild card patterns, if a variable defined outside the closure is mentioned within the closure the variable will be captured in its entirety."
      }
    },
    {
      "id": "type.closure.capture.precision.edition2018.drop-order",
      "title": "Drop order difference",
      "level": 1,
      "content": "As composite types are captured in their entirety, a closure which captures one of those composite types by value would drop the entire captured variable at the same time as the closure gets dropped.\n\n{\n    let tuple =\n      (String::from(\"foo\"), String::from(\"bar\"));\n    {\n        let c = || { // --------------------------+\n            // tuple is captured into the closure |\n            drop(tuple.0); //                     |\n        }; //                                     |\n    } // 'c' and 'tuple' dropped here ------------+\n}",
      "parent_id": null,
      "paragraphs": {
        "type.closure.capture.precision.edition2018.drop-order": "As composite types are captured in their entirety, a closure which captures one of those composite types by value would drop the entire captured variable at the same time as the closure gets dropped.\n\n{\n    let tuple =\n      (String::from(\"foo\"), String::from(\"bar\"));\n    {\n        let c = || { // --------------------------+\n            // tuple is captured into the closure |\n            drop(tuple.0); //                     |\n        }; //                                     |\n    } // 'c' and 'tuple' dropped here ------------+\n}"
      }
    },
    {
      "id": "type.pointer",
      "title": "Pointer types",
      "level": 1,
      "content": "All pointers are explicit first-class values.\nThey can be moved or copied, stored into data structs, and returned from functions.",
      "parent_id": null,
      "paragraphs": {
        "type.pointer.intro": "All pointers are explicit first-class values.\nThey can be moved or copied, stored into data structs, and returned from functions."
      }
    },
    {
      "id": "type.pointer.reference",
      "title": "References (`&` and `&mut`)",
      "level": 1,
      "content": ",types\nReferenceType -> `&` Lifetime? `mut`? TypeNoBounds",
      "parent_id": null,
      "paragraphs": {
        "type.pointer.reference.syntax": ",types\nReferenceType -> `&` Lifetime? `mut`? TypeNoBounds"
      }
    },
    {
      "id": "type.pointer.reference.shared",
      "title": "Shared references (`&`)",
      "level": 2,
      "content": "Shared references point to memory which is owned by some other value.\n\nWhen a shared reference to a value is created, it prevents direct mutation of the value.\n[Interior mutability] provides an exception for this in certain circumstances.\nAs the name suggests, any number of shared references to a value may exist.\nA shared reference type is written `&type`, or `&'a type` when you need to specify an explicit lifetime.\n\nCopying a reference is a \"shallow\" operation:\nit involves only copying the pointer itself, that is, pointers are `Copy`.\nReleasing a reference has no effect on the value it points to, but referencing of a [temporary value] will keep it alive during the scope of the reference itself.",
      "parent_id": null,
      "paragraphs": {
        "type.pointer.reference.shared.intro": "Shared references point to memory which is owned by some other value.",
        "type.pointer.reference.shared.constraint-mutation": "When a shared reference to a value is created, it prevents direct mutation of the value.\n[Interior mutability] provides an exception for this in certain circumstances.\nAs the name suggests, any number of shared references to a value may exist.\nA shared reference type is written `&type`, or `&'a type` when you need to specify an explicit lifetime.",
        "type.pointer.reference.shared.copy": "Copying a reference is a \"shallow\" operation:\nit involves only copying the pointer itself, that is, pointers are `Copy`.\nReleasing a reference has no effect on the value it points to, but referencing of a [temporary value] will keep it alive during the scope of the reference itself."
      }
    },
    {
      "id": "type.pointer.reference.mut",
      "title": "Mutable references (`&mut`)",
      "level": 3,
      "content": "Mutable references point to memory which is owned by some other value.\nA mutable reference type is written `&mut type` or `&'a mut type`.\n\nA mutable reference (that hasn't been borrowed) is the only way to access the value it points to, so is not `Copy`.",
      "parent_id": null,
      "paragraphs": {
        "type.pointer.reference.mut.intro": "Mutable references point to memory which is owned by some other value.\nA mutable reference type is written `&mut type` or `&'a mut type`.",
        "type.pointer.reference.mut.copy": "A mutable reference (that hasn't been borrowed) is the only way to access the value it points to, so is not `Copy`."
      }
    },
    {
      "id": "type.pointer.raw",
      "title": "Raw pointers (`*const` and `*mut`)",
      "level": 3,
      "content": ",types\nRawPointerType -> `*` ( `mut` | `const` ) TypeNoBounds\n\nRaw pointers are pointers without safety or liveness guarantees.\nRaw pointers are written as `*const T` or `*mut T`.\nFor example `*const i32` means a raw pointer to a 32-bit integer.\n\nCopying or dropping a raw pointer has no effect on the lifecycle of any other value.\n\nDereferencing a raw pointer is an [`unsafe` operation].\n\nThis can also be used to convert a raw pointer to a reference by reborrowing it (`&*` or `&mut *`).\nRaw pointers are generally discouraged;\nthey exist to support interoperability with foreign code, and writing performance-critical or low-level functions.\n\nWhen comparing raw pointers they are compared by their address, rather than by what they point to.\nWhen comparing raw pointers to [dynamically sized types] they also have their additional data compared.\n\nRaw pointers can be created directly using `&raw const` for `*const` pointers and `&raw mut` for `*mut` pointers.",
      "parent_id": null,
      "paragraphs": {
        "type.pointer.raw.syntax": ",types\nRawPointerType -> `*` ( `mut` | `const` ) TypeNoBounds",
        "type.pointer.raw.intro": "Raw pointers are pointers without safety or liveness guarantees.\nRaw pointers are written as `*const T` or `*mut T`.\nFor example `*const i32` means a raw pointer to a 32-bit integer.",
        "type.pointer.raw.copy": "Copying or dropping a raw pointer has no effect on the lifecycle of any other value.",
        "type.pointer.raw.safety": "Dereferencing a raw pointer is an [`unsafe` operation].\n\nThis can also be used to convert a raw pointer to a reference by reborrowing it (`&*` or `&mut *`).\nRaw pointers are generally discouraged;\nthey exist to support interoperability with foreign code, and writing performance-critical or low-level functions.",
        "type.pointer.raw.cmp": "When comparing raw pointers they are compared by their address, rather than by what they point to.\nWhen comparing raw pointers to [dynamically sized types] they also have their additional data compared.",
        "type.pointer.raw.constructor": "Raw pointers can be created directly using `&raw const` for `*const` pointers and `&raw mut` for `*mut` pointers."
      }
    },
    {
      "id": "type.pointer.smart",
      "title": "Smart pointers",
      "level": 2,
      "content": "The standard library contains additional 'smart pointer' types beyond references and raw pointers.",
      "parent_id": null,
      "paragraphs": {
        "type.pointer.smart": "The standard library contains additional 'smart pointer' types beyond references and raw pointers."
      }
    },
    {
      "id": "type.pointer.validity",
      "title": "Bit validity",
      "level": 2,
      "content": "Despite pointers and references being similar to `usize`s in the machine code emitted on most platforms,\nthe semantics of transmuting a reference or pointer type to a non-pointer type is currently undecided.\nThus, it may not be valid to transmute a pointer or reference type, `P`, to a `[u8; size_of::<P>()]`.\n\nFor thin raw pointers (i.e., for `P = *const T` or `P = *mut T` for `T: Sized`),\nthe inverse direction (transmuting from an integer or array of integers to `P`) is always valid.\nHowever, the pointer produced via such a transmutation may not be dereferenced (not even if `T` has size zero).\n\n[Interior mutability]: ../interior-mutability.md\n[`unsafe` operation]: ../unsafety.md\n[dynamically sized types]: ../dynamically-sized-types.md\n[temporary value]: ../expressions.md#temporaries",
      "parent_id": null,
      "paragraphs": {
        "type.pointer.validity.pointer-fragment": "Despite pointers and references being similar to `usize`s in the machine code emitted on most platforms,\nthe semantics of transmuting a reference or pointer type to a non-pointer type is currently undecided.\nThus, it may not be valid to transmute a pointer or reference type, `P`, to a `[u8; size_of::<P>()]`.",
        "type.pointer.validity.raw": "For thin raw pointers (i.e., for `P = *const T` or `P = *mut T` for `T: Sized`),\nthe inverse direction (transmuting from an integer or array of integers to `P`) is always valid.\nHowever, the pointer produced via such a transmutation may not be dereferenced (not even if `T` has size zero).\n\n[Interior mutability]: ../interior-mutability.md\n[`unsafe` operation]: ../unsafety.md\n[dynamically sized types]: ../dynamically-sized-types.md\n[temporary value]: ../expressions.md#temporaries"
      }
    },
    {
      "id": "type.fn-pointer",
      "title": "Function pointer types",
      "level": 1,
      "content": ",types\nBareFunctionType ->\n    ForLifetimes? FunctionTypeQualifiers `fn`\n       `(` FunctionParametersMaybeNamedVariadic? `)` BareFunctionReturnType?\n\nFunctionTypeQualifiers -> `unsafe`? (`extern` Abi?)?\n\nBareFunctionReturnType -> `->` TypeNoBounds\n\nFunctionParametersMaybeNamedVariadic ->\n    MaybeNamedFunctionParameters | MaybeNamedFunctionParametersVariadic\n\nMaybeNamedFunctionParameters ->\n    MaybeNamedParam ( `,` MaybeNamedParam )* `,`?\n\nMaybeNamedParam ->\n    OuterAttribute* ( ( IDENTIFIER | `_` ) `:` )? Type\n\nMaybeNamedFunctionParametersVariadic ->\n    ( MaybeNamedParam `,` )* MaybeNamedParam `,` OuterAttribute* `...`\n\nA function pointer type, written using the `fn` keyword, refers to a function whose identity is not necessarily known at compile-time.\n\nAn example where `Binop` is defined as a function pointer type:\n\nfn add(x: i32, y: i32) -> i32 {\n    x + y\n}\n\nlet mut x = add(5,7);\n\ntype Binop = fn(i32, i32) -> i32;\nlet bo: Binop = add;\nx = bo(5,7);\n\nFunction pointers can be created via a coercion from both [function items] and non-capturing, non-async [closures].\n\nThe `unsafe` qualifier indicates that the type's value is an [unsafe\nfunction], and the `extern` qualifier indicates it is an [extern function].\n\nFor the function to be variadic, its `extern` ABI must be one of those listed in [items.extern.variadic.conventions].",
      "parent_id": null,
      "paragraphs": {
        "type.fn-pointer.syntax": ",types\nBareFunctionType ->\n    ForLifetimes? FunctionTypeQualifiers `fn`\n       `(` FunctionParametersMaybeNamedVariadic? `)` BareFunctionReturnType?\n\nFunctionTypeQualifiers -> `unsafe`? (`extern` Abi?)?\n\nBareFunctionReturnType -> `->` TypeNoBounds\n\nFunctionParametersMaybeNamedVariadic ->\n    MaybeNamedFunctionParameters | MaybeNamedFunctionParametersVariadic\n\nMaybeNamedFunctionParameters ->\n    MaybeNamedParam ( `,` MaybeNamedParam )* `,`?\n\nMaybeNamedParam ->\n    OuterAttribute* ( ( IDENTIFIER | `_` ) `:` )? Type\n\nMaybeNamedFunctionParametersVariadic ->\n    ( MaybeNamedParam `,` )* MaybeNamedParam `,` OuterAttribute* `...`",
        "type.fn-pointer.intro": "A function pointer type, written using the `fn` keyword, refers to a function whose identity is not necessarily known at compile-time.\n\nAn example where `Binop` is defined as a function pointer type:\n\nfn add(x: i32, y: i32) -> i32 {\n    x + y\n}\n\nlet mut x = add(5,7);\n\ntype Binop = fn(i32, i32) -> i32;\nlet bo: Binop = add;\nx = bo(5,7);",
        "type.fn-pointer.coercion": "Function pointers can be created via a coercion from both [function items] and non-capturing, non-async [closures].",
        "type.fn-pointer.qualifiers": "The `unsafe` qualifier indicates that the type's value is an [unsafe\nfunction], and the `extern` qualifier indicates it is an [extern function].",
        "type.fn-pointer.constraint-variadic": "For the function to be variadic, its `extern` ABI must be one of those listed in [items.extern.variadic.conventions]."
      }
    },
    {
      "id": "type.fn-pointer.attributes",
      "title": "Attributes on function pointer parameters",
      "level": 1,
      "content": "Attributes on function pointer parameters follow the same rules and\nrestrictions as [regular function parameters].\n\n[`extern`]: ../items/external-blocks.md\n[closures]: closure.md\n[extern function]: ../items/functions.md#extern-function-qualifier\n[function items]: function-item.md\n[unsafe function]: ../unsafe-keyword.md\n[regular function parameters]: ../items/functions.md#attributes-on-function-parameters",
      "parent_id": null,
      "paragraphs": {
        "type.fn-pointer.attributes": "Attributes on function pointer parameters follow the same rules and\nrestrictions as [regular function parameters].\n\n[`extern`]: ../items/external-blocks.md\n[closures]: closure.md\n[extern function]: ../items/functions.md#extern-function-qualifier\n[function items]: function-item.md\n[unsafe function]: ../unsafe-keyword.md\n[regular function parameters]: ../items/functions.md#attributes-on-function-parameters"
      }
    },
    {
      "id": "type.trait-object",
      "title": "Trait objects",
      "level": 1,
      "content": ",types\nTraitObjectType -> `dyn`? TypeParamBounds\n\nTraitObjectTypeOneBound -> `dyn`? TraitBound\n\nA *trait object* is an opaque value of another type that implements a set of\ntraits. The set of traits is made up of a [dyn compatible] *base trait* plus any\nnumber of [auto traits].\n\nTrait objects implement the base trait, its auto traits, and any [supertraits]\nof the base trait.\n\nTrait objects are written as the keyword `dyn` followed by a set of trait\nbounds, but with the following restrictions on the trait bounds.\n\nThere may not be more than one non-auto trait, no more than one\nlifetime, and opt-out bounds (e.g. `?Sized`) are not allowed. Furthermore,\npaths to traits may be parenthesized.\n\nFor example, given a trait `Trait`, the following are all trait objects:\n\n* `dyn Trait`\n* `dyn Trait + Send`\n* `dyn Trait + Send + Sync`\n* `dyn Trait + 'static`\n* `dyn Trait + Send + 'static`\n* `dyn Trait +`\n* `dyn 'static + Trait`.\n* `dyn (Trait)`\n\n> [!EDITION-2021]\n> Before the 2021 edition, the `dyn` keyword may be omitted.\n\n> [!EDITION-2018]\n> In the 2015 edition, if the first bound of the trait object is a path that starts with `::`, then the `dyn` will be treated as a part of the path. The first path can be put in parenthesis to get around this. As such, if you want a trait object with the trait `::your_module::Trait`, you should write it as `dyn (::your_module::Trait)`.\n>\n> Beginning in the 2018 edition, `dyn` is a true keyword and is not allowed in paths, so the parentheses are not necessary.\n\nTwo trait object types alias each other if the base traits alias each other and\nif the sets of auto traits are the same and the lifetime bounds are the same.\nFor example, `dyn Trait + Send + UnwindSafe` is the same as\n`dyn Trait + UnwindSafe + Send`.\n\nDue to the opaqueness of which concrete type the value is of, trait objects are\n[dynamically sized types]. Like all\n<abbr title=\"dynamically sized types\">DSTs</abbr>, trait objects are used\nbehind some type of pointer; for example `&dyn SomeTrait` or\n`Box<dyn SomeTrait>`. Each instance of a pointer to a trait object includes:\n\n - a pointer to an instance of a type `T` that implements `SomeTrait`\n - a _virtual method table_, often just called a _vtable_, which contains, for\n   each method of `SomeTrait` and its [supertraits] that `T` implements, a\n   pointer to `T`'s implementation (i.e. a function pointer).\n\nThe purpose of trait objects is to permit \"late binding\" of methods. Calling a\nmethod on a trait object results in virtual dispatch at runtime: that is, a\nfunction pointer is loaded from the trait object vtable and invoked indirectly.\nThe actual implementation for each vtable entry can vary on an object-by-object\nbasis.\n\nAn example of a trait object:\n\ntrait Printable {\n    fn stringify(&self) -> String;\n}\n\nimpl Printable for i32 {\n    fn stringify(&self) -> String { self.to_string() }\n}\n\nfn print(a: Box<dyn Printable>) {\n    println!(\"{}\", a.stringify());\n}\n\nfn main() {\n    print(Box::new(10) as Box<dyn Printable>);\n}\n\nIn this example, the trait `Printable` occurs as a trait object in both the\ntype signature of `print`, and the cast expression in `main`.",
      "parent_id": null,
      "paragraphs": {
        "type.trait-object.syntax": ",types\nTraitObjectType -> `dyn`? TypeParamBounds\n\nTraitObjectTypeOneBound -> `dyn`? TraitBound",
        "type.trait-object.intro": "A *trait object* is an opaque value of another type that implements a set of\ntraits. The set of traits is made up of a [dyn compatible] *base trait* plus any\nnumber of [auto traits].",
        "type.trait-object.impls": "Trait objects implement the base trait, its auto traits, and any [supertraits]\nof the base trait.",
        "type.trait-object.name": "Trait objects are written as the keyword `dyn` followed by a set of trait\nbounds, but with the following restrictions on the trait bounds.",
        "type.trait-object.constraint": "There may not be more than one non-auto trait, no more than one\nlifetime, and opt-out bounds (e.g. `?Sized`) are not allowed. Furthermore,\npaths to traits may be parenthesized.\n\nFor example, given a trait `Trait`, the following are all trait objects:\n\n* `dyn Trait`\n* `dyn Trait + Send`\n* `dyn Trait + Send + Sync`\n* `dyn Trait + 'static`\n* `dyn Trait + Send + 'static`\n* `dyn Trait +`\n* `dyn 'static + Trait`.\n* `dyn (Trait)`",
        "type.trait-object.syntax-edition2021": "> [!EDITION-2021]\n> Before the 2021 edition, the `dyn` keyword may be omitted.",
        "type.trait-object.syntax-edition2018": "> [!EDITION-2018]\n> In the 2015 edition, if the first bound of the trait object is a path that starts with `::`, then the `dyn` will be treated as a part of the path. The first path can be put in parenthesis to get around this. As such, if you want a trait object with the trait `::your_module::Trait`, you should write it as `dyn (::your_module::Trait)`.\n>\n> Beginning in the 2018 edition, `dyn` is a true keyword and is not allowed in paths, so the parentheses are not necessary.",
        "type.trait-object.alias": "Two trait object types alias each other if the base traits alias each other and\nif the sets of auto traits are the same and the lifetime bounds are the same.\nFor example, `dyn Trait + Send + UnwindSafe` is the same as\n`dyn Trait + UnwindSafe + Send`.",
        "type.trait-object.unsized": "Due to the opaqueness of which concrete type the value is of, trait objects are\n[dynamically sized types]. Like all\n<abbr title=\"dynamically sized types\">DSTs</abbr>, trait objects are used\nbehind some type of pointer; for example `&dyn SomeTrait` or\n`Box<dyn SomeTrait>`. Each instance of a pointer to a trait object includes:\n\n - a pointer to an instance of a type `T` that implements `SomeTrait`\n - a _virtual method table_, often just called a _vtable_, which contains, for\n   each method of `SomeTrait` and its [supertraits] that `T` implements, a\n   pointer to `T`'s implementation (i.e. a function pointer).\n\nThe purpose of trait objects is to permit \"late binding\" of methods. Calling a\nmethod on a trait object results in virtual dispatch at runtime: that is, a\nfunction pointer is loaded from the trait object vtable and invoked indirectly.\nThe actual implementation for each vtable entry can vary on an object-by-object\nbasis.\n\nAn example of a trait object:\n\ntrait Printable {\n    fn stringify(&self) -> String;\n}\n\nimpl Printable for i32 {\n    fn stringify(&self) -> String { self.to_string() }\n}\n\nfn print(a: Box<dyn Printable>) {\n    println!(\"{}\", a.stringify());\n}\n\nfn main() {\n    print(Box::new(10) as Box<dyn Printable>);\n}\n\nIn this example, the trait `Printable` occurs as a trait object in both the\ntype signature of `print`, and the cast expression in `main`."
      }
    },
    {
      "id": "type.trait-object.lifetime-bounds",
      "title": "Trait object lifetime bounds",
      "level": 1,
      "content": "Since a trait object can contain references, the lifetimes of those references\nneed to be expressed as part of the trait object. This lifetime is written as\n`Trait + 'a`. There are [defaults] that allow this lifetime to usually be\ninferred with a sensible choice.\n\n[auto traits]: ../special-types-and-traits.md#auto-traits\n[defaults]: ../lifetime-elision.md#default-trait-object-lifetimes\n[dyn compatible]: ../items/traits.md#dyn-compatibility\n[dynamically sized types]: ../dynamically-sized-types.md\n[supertraits]: ../items/traits.md#supertraits",
      "parent_id": null,
      "paragraphs": {
        "type.trait-object.lifetime-bounds": "Since a trait object can contain references, the lifetimes of those references\nneed to be expressed as part of the trait object. This lifetime is written as\n`Trait + 'a`. There are [defaults] that allow this lifetime to usually be\ninferred with a sensible choice.\n\n[auto traits]: ../special-types-and-traits.md#auto-traits\n[defaults]: ../lifetime-elision.md#default-trait-object-lifetimes\n[dyn compatible]: ../items/traits.md#dyn-compatibility\n[dynamically sized types]: ../dynamically-sized-types.md\n[supertraits]: ../items/traits.md#supertraits"
      }
    },
    {
      "id": "type.impl-trait",
      "title": "Impl trait",
      "level": 1,
      "content": ",types\nImplTraitType -> `impl` TypeParamBounds\n\nImplTraitTypeOneBound -> `impl` TraitBound\n\n`impl Trait` provides ways to specify unnamed but concrete types that\nimplement a specific trait.\nIt can appear in two sorts of places: argument position (where it can act as an anonymous type parameter to functions), and return position (where it can act as an abstract return type).\n\ntrait Trait {}\n# impl Trait for () {}\n\n// argument position: anonymous type parameter\nfn foo(arg: impl Trait) {\n}\n\n// return position: abstract return type\nfn bar() -> impl Trait {\n}",
      "parent_id": null,
      "paragraphs": {
        "type.impl-trait.syntax": ",types\nImplTraitType -> `impl` TypeParamBounds\n\nImplTraitTypeOneBound -> `impl` TraitBound",
        "type.impl-trait.intro": "`impl Trait` provides ways to specify unnamed but concrete types that\nimplement a specific trait.\nIt can appear in two sorts of places: argument position (where it can act as an anonymous type parameter to functions), and return position (where it can act as an abstract return type).\n\ntrait Trait {}\n# impl Trait for () {}\n\n// argument position: anonymous type parameter\nfn foo(arg: impl Trait) {\n}\n\n// return position: abstract return type\nfn bar() -> impl Trait {\n}"
      }
    },
    {
      "id": "type.impl-trait.param",
      "title": "Anonymous type parameters",
      "level": 1,
      "content": "> [!NOTE]\n> This is often called \"impl Trait in argument position\". (The term \"parameter\" is more correct here, but \"impl Trait in argument position\" is the phrasing used during the development of this feature, and it remains in parts of the implementation.)\n\nFunctions can use `impl` followed by a set of trait bounds to declare a parameter as having an anonymous type.\nThe caller must provide a type that satisfies the bounds declared by the anonymous type parameter, and the function can only use the methods available through the trait bounds of the anonymous type parameter.\n\nFor example, these two forms are almost equivalent:\n\ntrait Trait {}\n\n// generic type parameter\nfn with_generic_type<T: Trait>(arg: T) {\n}\n\n// impl Trait in argument position\nfn with_impl_trait(arg: impl Trait) {\n}\n\nThat is, `impl Trait` in argument position is syntactic sugar for a generic type parameter like `<T: Trait>`, except that the type is anonymous and doesn't appear in the [GenericParams] list.\n\n> [!NOTE]\n> For function parameters, generic type parameters and `impl Trait` are not exactly equivalent. With a generic parameter such as `<T: Trait>`, the caller has the option to explicitly specify the generic argument for `T` at the call site using [GenericArgs], for example, `foo::<usize>(1)`. Changing a parameter from either one to the other can constitute a breaking change for the callers of a function, since this changes the number of generic arguments.",
      "parent_id": null,
      "paragraphs": {
        "type.impl-trait.param": "> [!NOTE]\n> This is often called \"impl Trait in argument position\". (The term \"parameter\" is more correct here, but \"impl Trait in argument position\" is the phrasing used during the development of this feature, and it remains in parts of the implementation.)",
        "type.impl-trait.param.intro": "Functions can use `impl` followed by a set of trait bounds to declare a parameter as having an anonymous type.\nThe caller must provide a type that satisfies the bounds declared by the anonymous type parameter, and the function can only use the methods available through the trait bounds of the anonymous type parameter.\n\nFor example, these two forms are almost equivalent:\n\ntrait Trait {}\n\n// generic type parameter\nfn with_generic_type<T: Trait>(arg: T) {\n}\n\n// impl Trait in argument position\nfn with_impl_trait(arg: impl Trait) {\n}",
        "type.impl-trait.param.generic": "That is, `impl Trait` in argument position is syntactic sugar for a generic type parameter like `<T: Trait>`, except that the type is anonymous and doesn't appear in the [GenericParams] list.\n\n> [!NOTE]\n> For function parameters, generic type parameters and `impl Trait` are not exactly equivalent. With a generic parameter such as `<T: Trait>`, the caller has the option to explicitly specify the generic argument for `T` at the call site using [GenericArgs], for example, `foo::<usize>(1)`. Changing a parameter from either one to the other can constitute a breaking change for the callers of a function, since this changes the number of generic arguments."
      }
    },
    {
      "id": "type.impl-trait.return",
      "title": "Abstract return types",
      "level": 2,
      "content": "> [!NOTE]\n> This is often called \"impl Trait in return position\".\n\nFunctions can use `impl Trait` to return an abstract return type.\nThese types stand in for another concrete type where the caller may only use the methods declared by the specified `Trait`.\n\nEach possible return value from the function must resolve to the same concrete type.\n\n`impl Trait` in return position allows a function to return an unboxed abstract type.\nThis is particularly useful with [closures] and iterators.\nFor example, closures have a unique, un-writable type.\nPreviously, the only way to return a closure from a function was to use a [trait object]:\n\nfn returns_closure() -> Box<dyn Fn(i32) -> i32> {\n    Box::new(|x| x + 1)\n}\n\nThis could incur performance penalties from heap allocation and dynamic dispatch.\nIt wasn't possible to fully specify the type of the closure, only to use the `Fn` trait.\nThat means that the trait object is necessary.\nHowever, with `impl Trait`, it is possible to write this more simply:\n\nfn returns_closure() -> impl Fn(i32) -> i32 {\n    |x| x + 1\n}\n\nwhich also avoids the drawbacks of using a boxed trait object.\n\nSimilarly, the concrete types of iterators could become very complex, incorporating the types of all previous iterators in a chain.\nReturning `impl Iterator` means that a function only exposes the `Iterator` trait as a bound on its return type, instead of explicitly specifying all of the other iterator types involved.",
      "parent_id": null,
      "paragraphs": {
        "type.impl-trait.return": "> [!NOTE]\n> This is often called \"impl Trait in return position\".",
        "type.impl-trait.return.intro": "Functions can use `impl Trait` to return an abstract return type.\nThese types stand in for another concrete type where the caller may only use the methods declared by the specified `Trait`.",
        "type.impl-trait.return.constraint-body": "Each possible return value from the function must resolve to the same concrete type.\n\n`impl Trait` in return position allows a function to return an unboxed abstract type.\nThis is particularly useful with [closures] and iterators.\nFor example, closures have a unique, un-writable type.\nPreviously, the only way to return a closure from a function was to use a [trait object]:\n\nfn returns_closure() -> Box<dyn Fn(i32) -> i32> {\n    Box::new(|x| x + 1)\n}\n\nThis could incur performance penalties from heap allocation and dynamic dispatch.\nIt wasn't possible to fully specify the type of the closure, only to use the `Fn` trait.\nThat means that the trait object is necessary.\nHowever, with `impl Trait`, it is possible to write this more simply:\n\nfn returns_closure() -> impl Fn(i32) -> i32 {\n    |x| x + 1\n}\n\nwhich also avoids the drawbacks of using a boxed trait object.\n\nSimilarly, the concrete types of iterators could become very complex, incorporating the types of all previous iterators in a chain.\nReturning `impl Iterator` means that a function only exposes the `Iterator` trait as a bound on its return type, instead of explicitly specifying all of the other iterator types involved."
      }
    },
    {
      "id": "type.impl-trait.return-in-trait",
      "title": "Return-position `impl Trait` in traits and trait implementations",
      "level": 2,
      "content": "Functions in traits may also use `impl Trait` as a syntax for an anonymous associated type.\n\nEvery `impl Trait` in the return type of an associated function in a trait is desugared to an anonymous associated type. The return type that appears in the implementation's function signature is used to determine the value of the associated type.",
      "parent_id": null,
      "paragraphs": {
        "type.impl-trait.return-in-trait.intro": "Functions in traits may also use `impl Trait` as a syntax for an anonymous associated type.",
        "type.impl-trait.return-in-trait.desugaring": "Every `impl Trait` in the return type of an associated function in a trait is desugared to an anonymous associated type. The return type that appears in the implementation's function signature is used to determine the value of the associated type."
      }
    },
    {
      "id": "type.impl-trait.generic-captures",
      "title": "Capturing",
      "level": 2,
      "content": "Behind each return-position `impl Trait` abstract type is some hidden concrete type.  For this concrete type to use a generic parameter, that generic parameter must be *captured* by the abstract type.",
      "parent_id": null,
      "paragraphs": {
        "type.impl-trait.generic-captures": "Behind each return-position `impl Trait` abstract type is some hidden concrete type.  For this concrete type to use a generic parameter, that generic parameter must be *captured* by the abstract type."
      }
    },
    {
      "id": "type.impl-trait.generic-capture.auto",
      "title": "Automatic capturing",
      "level": 2,
      "content": "Return-position `impl Trait` abstract types automatically capture all in-scope generic parameters, including generic type, const, and lifetime parameters (including higher-ranked ones).\n\n> [!EDITION-2024]\n> Before the 2024 edition, on free functions and on associated functions and methods of inherent impls, generic lifetime parameters that do not appear in the bounds of the abstract return type are not automatically captured.",
      "parent_id": null,
      "paragraphs": {
        "type.impl-trait.generic-capture.auto.intro": "Return-position `impl Trait` abstract types automatically capture all in-scope generic parameters, including generic type, const, and lifetime parameters (including higher-ranked ones).",
        "type.impl-trait.generic-capture.edition2024": "> [!EDITION-2024]\n> Before the 2024 edition, on free functions and on associated functions and methods of inherent impls, generic lifetime parameters that do not appear in the bounds of the abstract return type are not automatically captured."
      }
    },
    {
      "id": "type.impl-trait.generic-capture.precise",
      "title": "Precise capturing",
      "level": 2,
      "content": "The set of generic parameters captured by a return-position `impl Trait` abstract type may be explicitly controlled with a [`use<..>` bound].  If present, only the generic parameters listed in the `use<..>` bound will be captured.  E.g.:\n\nfn capture<'a, 'b, T>(x: &'a (), y: T) -> impl Sized + use<'a, T> {\n  //                                      ~~~~~~~~~~~~~~~~~~~~~~~\n  //                                     Captures `'a` and `T` only.\n  (x, y)\n}\n\nCurrently, only one `use<..>` bound may be present in a bounds list, all in-scope type and const generic parameters must be included, and all lifetime parameters that appear in other bounds of the abstract type must be included.\n\nWithin the `use<..>` bound, any lifetime parameters present must appear before all type and const generic parameters, and the elided lifetime (`'_`) may be present if it is otherwise allowed to appear within the `impl Trait` return type.\n\nBecause all in-scope type parameters must be included by name, a `use<..>` bound may not be used in the signature of items that use argument-position `impl Trait`, as those items have anonymous type parameters in scope.\n\nAny `use<..>` bound that is present in an associated function in a trait definition must include all generic parameters of the trait, including the implicit `Self` generic type parameter of the trait.\n\n## Differences between generics and `impl Trait` in return position\n\nIn argument position, `impl Trait` is very similar in semantics to a generic type parameter.\nHowever, there are significant differences between the two in return position.\nWith `impl Trait`, unlike with a generic type parameter, the function chooses the return type, and the caller cannot choose the return type.\n\nThe function:\n\n# trait Trait {}\nfn foo<T: Trait>() -> T {\n    // ...\n# panic!()\n}\n\nallows the caller to determine the return type, `T`, and the function returns that type.\n\nThe function:\n\n# trait Trait {}\n# impl Trait for () {}\nfn foo() -> impl Trait {\n    // ...\n}\n\ndoesn't allow the caller to determine the return type.\nInstead, the function chooses the return type, but only promises that it will implement `Trait`.",
      "parent_id": null,
      "paragraphs": {
        "type.impl-trait.generic-capture.precise.use": "The set of generic parameters captured by a return-position `impl Trait` abstract type may be explicitly controlled with a [`use<..>` bound].  If present, only the generic parameters listed in the `use<..>` bound will be captured.  E.g.:\n\nfn capture<'a, 'b, T>(x: &'a (), y: T) -> impl Sized + use<'a, T> {\n  //                                      ~~~~~~~~~~~~~~~~~~~~~~~\n  //                                     Captures `'a` and `T` only.\n  (x, y)\n}",
        "type.impl-trait.generic-capture.precise.constraint-single": "Currently, only one `use<..>` bound may be present in a bounds list, all in-scope type and const generic parameters must be included, and all lifetime parameters that appear in other bounds of the abstract type must be included.",
        "type.impl-trait.generic-capture.precise.constraint-lifetime": "Within the `use<..>` bound, any lifetime parameters present must appear before all type and const generic parameters, and the elided lifetime (`'_`) may be present if it is otherwise allowed to appear within the `impl Trait` return type.",
        "type.impl-trait.generic-capture.precise.constraint-param-impl-trait": "Because all in-scope type parameters must be included by name, a `use<..>` bound may not be used in the signature of items that use argument-position `impl Trait`, as those items have anonymous type parameters in scope.",
        "type.impl-trait.generic-capture.precise.constraint-in-trait": "Any `use<..>` bound that is present in an associated function in a trait definition must include all generic parameters of the trait, including the implicit `Self` generic type parameter of the trait.\n\n## Differences between generics and `impl Trait` in return position\n\nIn argument position, `impl Trait` is very similar in semantics to a generic type parameter.\nHowever, there are significant differences between the two in return position.\nWith `impl Trait`, unlike with a generic type parameter, the function chooses the return type, and the caller cannot choose the return type.\n\nThe function:\n\n# trait Trait {}\nfn foo<T: Trait>() -> T {\n    // ...\n# panic!()\n}\n\nallows the caller to determine the return type, `T`, and the function returns that type.\n\nThe function:\n\n# trait Trait {}\n# impl Trait for () {}\nfn foo() -> impl Trait {\n    // ...\n}\n\ndoesn't allow the caller to determine the return type.\nInstead, the function chooses the return type, but only promises that it will implement `Trait`."
      }
    },
    {
      "id": "type.impl-trait.constraint",
      "title": "Limitations",
      "level": 1,
      "content": "`impl Trait` can only appear as a parameter or return type of a non-`extern` function.\nIt cannot be the type of a `let` binding, field type, or appear inside a type alias.\n\n[`use<..>` bound]: ../trait-bounds.md#use-bounds\n[closures]: closure.md\n[trait object]: trait-object.md",
      "parent_id": null,
      "paragraphs": {
        "type.impl-trait.constraint": "`impl Trait` can only appear as a parameter or return type of a non-`extern` function.\nIt cannot be the type of a `let` binding, field type, or appear inside a type alias.\n\n[`use<..>` bound]: ../trait-bounds.md#use-bounds\n[closures]: closure.md\n[trait object]: trait-object.md"
      }
    },
    {
      "id": "type.generic",
      "title": "Type parameters",
      "level": 1,
      "content": "Within the body of an item that has type parameter declarations, the names of\nits type parameters are types:\n\nfn to_vec<A: Clone>(xs: &[A]) -> Vec<A> {\n    if xs.is_empty() {\n        return vec![];\n    }\n    let first: A = xs[0].clone();\n    let mut rest: Vec<A> = to_vec(&xs[1..]);\n    rest.insert(0, first);\n    rest\n}\n\nHere, `first` has type `A`, referring to `to_vec`'s `A` type parameter; and\n`rest` has type `Vec<A>`, a vector with element type `A`.",
      "parent_id": null,
      "paragraphs": {
        "type.generic": "Within the body of an item that has type parameter declarations, the names of\nits type parameters are types:\n\nfn to_vec<A: Clone>(xs: &[A]) -> Vec<A> {\n    if xs.is_empty() {\n        return vec![];\n    }\n    let first: A = xs[0].clone();\n    let mut rest: Vec<A> = to_vec(&xs[1..]);\n    rest.insert(0, first);\n    rest\n}\n\nHere, `first` has type `A`, referring to `to_vec`'s `A` type parameter; and\n`rest` has type `Vec<A>`, a vector with element type `A`."
      }
    },
    {
      "id": "type.inferred",
      "title": "Inferred type",
      "level": 1,
      "content": ",types\nInferredType -> `_`\n\nThe inferred type asks the compiler to infer the type if possible based on the\nsurrounding information available.\n\n> [!EXAMPLE]\n> The inferred type is often used in generic arguments:\n>\n> ```rust\n> let x: Vec<_> = (0..10).collect();\n> ```\n\nThe inferred type cannot be used in item signatures.\n\n<!--\n  What else should be said here?\n  The only documentation I am aware of is https://rustc-dev-guide.rust-lang.org/type-inference.html\n  There should be a broader discussion of type inference somewhere.\n-->",
      "parent_id": null,
      "paragraphs": {
        "type.inferred.syntax": ",types\nInferredType -> `_`",
        "type.inferred.intro": "The inferred type asks the compiler to infer the type if possible based on the\nsurrounding information available.\n\n> [!EXAMPLE]\n> The inferred type is often used in generic arguments:\n>\n> ```rust\n> let x: Vec<_> = (0..10).collect();\n> ```",
        "type.inferred.constraint": "The inferred type cannot be used in item signatures.\n\n<!--\n  What else should be said here?\n  The only documentation I am aware of is https://rustc-dev-guide.rust-lang.org/type-inference.html\n  There should be a broader discussion of type inference somewhere.\n-->"
      }
    },
    {
      "id": "dynamic-sized",
      "title": "Dynamically sized types",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "dynamic-sized.intro",
      "title": "Dynamically sized types",
      "level": 1,
      "content": "Most types have a fixed size that is known at compile time and implement the trait `Sized`. A type with a size that is known only at run-time is called a _dynamically sized type_ (_DST_) or, informally, an unsized type.  [Slices], [trait objects], and [str] are examples of <abbr title=\"dynamically sized types\">DSTs</abbr>.",
      "parent_id": null,
      "paragraphs": {
        "dynamic-sized.intro": "Most types have a fixed size that is known at compile time and implement the trait `Sized`. A type with a size that is known only at run-time is called a _dynamically sized type_ (_DST_) or, informally, an unsized type.  [Slices], [trait objects], and [str] are examples of <abbr title=\"dynamically sized types\">DSTs</abbr>."
      }
    },
    {
      "id": "dynamic-sized.restriction",
      "title": "Dynamically sized types",
      "level": 1,
      "content": "Such types can only be used in certain cases:",
      "parent_id": null,
      "paragraphs": {
        "dynamic-sized.restriction": "Such types can only be used in certain cases:"
      }
    },
    {
      "id": "dynamic-sized.pointer-types",
      "title": "Dynamically sized types",
      "level": 1,
      "content": "* [Pointer types] to <abbr title=\"dynamically sized types\">DSTs</abbr> are\n  sized but have twice the size of pointers to sized types\n    * Pointers to slices and `str` also store the number of elements.\n    * Pointers to trait objects also store a pointer to a vtable.",
      "parent_id": null,
      "paragraphs": {
        "dynamic-sized.pointer-types": "* [Pointer types] to <abbr title=\"dynamically sized types\">DSTs</abbr> are\n  sized but have twice the size of pointers to sized types\n    * Pointers to slices and `str` also store the number of elements.\n    * Pointers to trait objects also store a pointer to a vtable."
      }
    },
    {
      "id": "dynamic-sized.question-sized",
      "title": "Dynamically sized types",
      "level": 1,
      "content": "* <abbr title=\"dynamically sized types\">DSTs</abbr> can be provided as\n  type arguments to generic type parameters having the special `?Sized` bound.\n  They can also be used for associated type definitions when the corresponding associated type declaration has a `?Sized` bound.\n  By default, any type parameter or associated type has a `Sized` bound, unless it is relaxed using `?Sized`.",
      "parent_id": null,
      "paragraphs": {
        "dynamic-sized.question-sized": "* <abbr title=\"dynamically sized types\">DSTs</abbr> can be provided as\n  type arguments to generic type parameters having the special `?Sized` bound.\n  They can also be used for associated type definitions when the corresponding associated type declaration has a `?Sized` bound.\n  By default, any type parameter or associated type has a `Sized` bound, unless it is relaxed using `?Sized`."
      }
    },
    {
      "id": "dynamic-sized.trait-impl",
      "title": "Dynamically sized types",
      "level": 1,
      "content": "* Traits may be implemented for <abbr title=\"dynamically sized\n  types\">DSTs</abbr>.\n  Unlike with generic type parameters, `Self: ?Sized` is the default in trait definitions.",
      "parent_id": null,
      "paragraphs": {
        "dynamic-sized.trait-impl": "* Traits may be implemented for <abbr title=\"dynamically sized\n  types\">DSTs</abbr>.\n  Unlike with generic type parameters, `Self: ?Sized` is the default in trait definitions."
      }
    },
    {
      "id": "dynamic-sized.struct-field",
      "title": "Dynamically sized types",
      "level": 1,
      "content": "* Structs may contain a <abbr title=\"dynamically sized type\">DST</abbr> as the\n  last field; this makes the struct itself a\n  <abbr title=\"dynamically sized type\">DST</abbr>.\n\n> [!NOTE]\n> [Variables], function parameters, [const] items, and [static] items must be `Sized`.\n\n[sized]: special-types-and-traits.md#sized\n[Slices]: types/slice.md\n[str]: types/textual.md\n[trait objects]: types/trait-object.md\n[Pointer types]: types/pointer.md\n[Variables]: variables.md\n[const]: items/constant-items.md\n[static]: items/static-items.md",
      "parent_id": null,
      "paragraphs": {
        "dynamic-sized.struct-field": "* Structs may contain a <abbr title=\"dynamically sized type\">DST</abbr> as the\n  last field; this makes the struct itself a\n  <abbr title=\"dynamically sized type\">DST</abbr>.\n\n> [!NOTE]\n> [Variables], function parameters, [const] items, and [static] items must be `Sized`.\n\n[sized]: special-types-and-traits.md#sized\n[Slices]: types/slice.md\n[str]: types/textual.md\n[trait objects]: types/trait-object.md\n[Pointer types]: types/pointer.md\n[Variables]: variables.md\n[const]: items/constant-items.md\n[static]: items/static-items.md"
      }
    },
    {
      "id": "layout",
      "title": "Type layout",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "layout.intro",
      "title": "Type layout",
      "level": 1,
      "content": "The layout of a type is its size, alignment, and the relative offsets of its\nfields. For enums, how the discriminant is laid out and interpreted is also part\nof type layout.",
      "parent_id": null,
      "paragraphs": {
        "layout.intro": "The layout of a type is its size, alignment, and the relative offsets of its\nfields. For enums, how the discriminant is laid out and interpreted is also part\nof type layout."
      }
    },
    {
      "id": "layout.guarantees",
      "title": "Type layout",
      "level": 1,
      "content": "Type layout can be changed with each compilation. Instead of trying to document\nexactly what is done, we only document what is guaranteed today.\n\nNote that even types with the same layout can still differ in how they are passed\nacross function boundaries. For function call ABI compatibility of types,\nsee here.",
      "parent_id": null,
      "paragraphs": {
        "layout.guarantees": "Type layout can be changed with each compilation. Instead of trying to document\nexactly what is done, we only document what is guaranteed today.\n\nNote that even types with the same layout can still differ in how they are passed\nacross function boundaries. For function call ABI compatibility of types,\nsee here."
      }
    },
    {
      "id": "layout.properties",
      "title": "Size and alignment",
      "level": 1,
      "content": "All values have an alignment and size.\n\nThe *alignment* of a value specifies what addresses are valid to store the value\nat. A value of alignment `n` must only be stored at an address that is a\nmultiple of n. For example, a value with an alignment of 2 must be stored at an\neven address, while a value with an alignment of 1 can be stored at any address.\nAlignment is measured in bytes, and must be at least 1, and always a power of 2.\nThe alignment of a value can be checked with the [`align_of_val`] function.\n\nThe *size* of a value is the offset in bytes between successive elements in an\narray with that item type including alignment padding. The size of a value is\nalways a multiple of its alignment. Note that some types are zero-sized; 0 is\nconsidered a multiple of any alignment (for example, on some platforms, the type\n`[u16; 0]` has size 0 and alignment 2). The size of a value can be checked with\nthe [`size_of_val`] function.\n\nTypes where all values have the same size and alignment, and both are known at\ncompile time, implement the [`Sized`] trait and can be checked with the\n[`size_of`] and [`align_of`] functions. Types that are not [`Sized`] are known\nas [dynamically sized types]. Since all values of a `Sized` type share the same\nsize and alignment, we refer to those shared values as the size of the type and\nthe alignment of the type respectively.",
      "parent_id": null,
      "paragraphs": {
        "layout.properties": "All values have an alignment and size.",
        "layout.properties.align": "The *alignment* of a value specifies what addresses are valid to store the value\nat. A value of alignment `n` must only be stored at an address that is a\nmultiple of n. For example, a value with an alignment of 2 must be stored at an\neven address, while a value with an alignment of 1 can be stored at any address.\nAlignment is measured in bytes, and must be at least 1, and always a power of 2.\nThe alignment of a value can be checked with the [`align_of_val`] function.",
        "layout.properties.size": "The *size* of a value is the offset in bytes between successive elements in an\narray with that item type including alignment padding. The size of a value is\nalways a multiple of its alignment. Note that some types are zero-sized; 0 is\nconsidered a multiple of any alignment (for example, on some platforms, the type\n`[u16; 0]` has size 0 and alignment 2). The size of a value can be checked with\nthe [`size_of_val`] function.",
        "layout.properties.sized": "Types where all values have the same size and alignment, and both are known at\ncompile time, implement the [`Sized`] trait and can be checked with the\n[`size_of`] and [`align_of`] functions. Types that are not [`Sized`] are known\nas [dynamically sized types]. Since all values of a `Sized` type share the same\nsize and alignment, we refer to those shared values as the size of the type and\nthe alignment of the type respectively."
      }
    },
    {
      "id": "layout.primitive",
      "title": "Primitive data layout",
      "level": 2,
      "content": "The size of most primitives is given in this table.\n\n| Type              | `size_of::<Type>()`|\n|--                 |--                  |\n| `bool`            | 1                  |\n| `u8` / `i8`       | 1                  |\n| `u16` / `i16`     | 2                  |\n| `u32` / `i32`     | 4                  |\n| `u64` / `i64`     | 8                  |\n| `u128` / `i128`   | 16                 |\n| `usize` / `isize` | See below          |\n| `f32`             | 4                  |\n| `f64`             | 8                  |\n| `char`            | 4                  |\n\n`usize` and `isize` have a size big enough to contain every address on the\ntarget platform. For example, on a 32 bit target, this is 4 bytes, and on a 64\nbit target, this is 8 bytes.\n\nThe alignment of primitives is platform-specific.\nIn most cases, their alignment is equal to their size, but it may be less.\nIn particular, `i128` and `u128` are often aligned to 4 or 8 bytes even though\ntheir size is 16, and on many 32-bit platforms, `i64`, `u64`, and `f64` are only\naligned to 4 bytes, not 8.",
      "parent_id": null,
      "paragraphs": {
        "layout.primitive.size": "The size of most primitives is given in this table.\n\n| Type              | `size_of::<Type>()`|\n|--                 |--                  |\n| `bool`            | 1                  |\n| `u8` / `i8`       | 1                  |\n| `u16` / `i16`     | 2                  |\n| `u32` / `i32`     | 4                  |\n| `u64` / `i64`     | 8                  |\n| `u128` / `i128`   | 16                 |\n| `usize` / `isize` | See below          |\n| `f32`             | 4                  |\n| `f64`             | 8                  |\n| `char`            | 4                  |",
        "layout.primitive.size-int": "`usize` and `isize` have a size big enough to contain every address on the\ntarget platform. For example, on a 32 bit target, this is 4 bytes, and on a 64\nbit target, this is 8 bytes.",
        "layout.primitive.align": "The alignment of primitives is platform-specific.\nIn most cases, their alignment is equal to their size, but it may be less.\nIn particular, `i128` and `u128` are often aligned to 4 or 8 bytes even though\ntheir size is 16, and on many 32-bit platforms, `i64`, `u64`, and `f64` are only\naligned to 4 bytes, not 8."
      }
    },
    {
      "id": "layout.pointer",
      "title": "Pointers and references layout",
      "level": 2,
      "content": "Pointers and references have the same layout. Mutability of the pointer or\nreference does not change the layout.\n\nPointers to sized types have the same size and alignment as `usize`.\n\nPointers to unsized types are sized. The size and alignment is guaranteed to be\nat least equal to the size and alignment of a pointer.\n\n> [!NOTE]\n> Though you should not rely on this, all pointers to <abbr title=\"Dynamically Sized Types\">DSTs</abbr> are currently twice the size of the size of `usize` and have the same alignment.",
      "parent_id": null,
      "paragraphs": {
        "layout.pointer.intro": "Pointers and references have the same layout. Mutability of the pointer or\nreference does not change the layout.",
        "layout.pointer.thin": "Pointers to sized types have the same size and alignment as `usize`.",
        "layout.pointer.unsized": "Pointers to unsized types are sized. The size and alignment is guaranteed to be\nat least equal to the size and alignment of a pointer.\n\n> [!NOTE]\n> Though you should not rely on this, all pointers to <abbr title=\"Dynamically Sized Types\">DSTs</abbr> are currently twice the size of the size of `usize` and have the same alignment."
      }
    },
    {
      "id": "layout.array",
      "title": "Array layout",
      "level": 2,
      "content": "An array of `[T; N]` has a size of `size_of::<T>() * N` and the same alignment\nof `T`. Arrays are laid out so that the zero-based `nth` element of the array\nis offset from the start of the array by `n * size_of::<T>()` bytes.",
      "parent_id": null,
      "paragraphs": {
        "layout.array": "An array of `[T; N]` has a size of `size_of::<T>() * N` and the same alignment\nof `T`. Arrays are laid out so that the zero-based `nth` element of the array\nis offset from the start of the array by `n * size_of::<T>()` bytes."
      }
    },
    {
      "id": "layout.slice",
      "title": "Slice layout",
      "level": 2,
      "content": "Slices have the same layout as the section of the array they slice.\n\n> [!NOTE]\n> This is about the raw `[T]` type, not pointers (`&[T]`, `Box<[T]>`, etc.) to slices.",
      "parent_id": null,
      "paragraphs": {
        "layout.slice": "Slices have the same layout as the section of the array they slice.\n\n> [!NOTE]\n> This is about the raw `[T]` type, not pointers (`&[T]`, `Box<[T]>`, etc.) to slices."
      }
    },
    {
      "id": "layout.str",
      "title": "`str` Layout",
      "level": 2,
      "content": "String slices are a UTF-8 representation of characters that have the same layout as slices of type `[u8]`. A reference `&str` has the same layout as a reference `&[u8]`.",
      "parent_id": null,
      "paragraphs": {
        "layout.str": "String slices are a UTF-8 representation of characters that have the same layout as slices of type `[u8]`. A reference `&str` has the same layout as a reference `&[u8]`."
      }
    },
    {
      "id": "layout.tuple",
      "title": "Tuple layout",
      "level": 2,
      "content": "Tuples are laid out according to the `Rust` representation.\n\nThe exception to this is the unit tuple (`()`), which is guaranteed as a\nzero-sized type to have a size of 0 and an alignment of 1.",
      "parent_id": null,
      "paragraphs": {
        "layout.tuple.general": "Tuples are laid out according to the `Rust` representation.",
        "layout.tuple.unit": "The exception to this is the unit tuple (`()`), which is guaranteed as a\nzero-sized type to have a size of 0 and an alignment of 1."
      }
    },
    {
      "id": "layout.trait-object",
      "title": "Trait object layout",
      "level": 2,
      "content": "Trait objects have the same layout as the value the trait object is of.\n\n> [!NOTE]\n> This is about the raw trait object types, not pointers (`&dyn Trait`, `Box<dyn Trait>`, etc.) to trait objects.",
      "parent_id": null,
      "paragraphs": {
        "layout.trait-object": "Trait objects have the same layout as the value the trait object is of.\n\n> [!NOTE]\n> This is about the raw trait object types, not pointers (`&dyn Trait`, `Box<dyn Trait>`, etc.) to trait objects."
      }
    },
    {
      "id": "layout.closure",
      "title": "Closure layout",
      "level": 2,
      "content": "Closures have no layout guarantees.",
      "parent_id": null,
      "paragraphs": {
        "layout.closure": "Closures have no layout guarantees."
      }
    },
    {
      "id": "layout.repr",
      "title": "Representations",
      "level": 2,
      "content": "All user-defined composite types (`struct`s, `enum`s, and `union`s) have a\n*representation* that specifies what the layout is for the type.\n\nThe possible representations for a type are:\n\n- [`Rust`] (default)\n- [`C`]\n- The [primitive representations]\n- [`transparent`]\n\nThe representation of a type can be changed by applying the `repr` attribute\nto it. The following example shows a struct with a `C` representation.\n\n#[repr(C)]\nstruct ThreeInts {\n    first: i16,\n    second: i8,\n    third: i32\n}\n\nThe alignment may be raised or lowered with the `align` and `packed` modifiers\nrespectively. They alter the representation specified in the attribute.\nIf no representation is specified, the default one is altered.\n\n// Default representation, alignment lowered to 2.\n#[repr(packed(2))]\nstruct PackedStruct {\n    first: i16,\n    second: i8,\n    third: i32\n}\n\n// C representation, alignment raised to 8\n#[repr(C, align(8))]\nstruct AlignedStruct {\n    first: i16,\n    second: i8,\n    third: i32\n}\n\n> [!NOTE]\n> As a consequence of the representation being an attribute on the item, the representation does not depend on generic parameters. Any two types with the same name have the same representation. For example, `Foo<Bar>` and `Foo<Baz>` both have the same representation.\n\nThe representation of a type can change the padding between fields, but does\nnot change the layout of the fields themselves. For example, a struct with a\n`C` representation that contains a struct `Inner` with the `Rust`\nrepresentation will not change the layout of `Inner`.\n\n<a id=\"the-default-representation\"></a>",
      "parent_id": null,
      "paragraphs": {
        "layout.repr.intro": "All user-defined composite types (`struct`s, `enum`s, and `union`s) have a\n*representation* that specifies what the layout is for the type.",
        "layout.repr.kinds": "The possible representations for a type are:\n\n- [`Rust`] (default)\n- [`C`]\n- The [primitive representations]\n- [`transparent`]",
        "layout.repr.attribute": "The representation of a type can be changed by applying the `repr` attribute\nto it. The following example shows a struct with a `C` representation.\n\n#[repr(C)]\nstruct ThreeInts {\n    first: i16,\n    second: i8,\n    third: i32\n}",
        "layout.repr.align-packed": "The alignment may be raised or lowered with the `align` and `packed` modifiers\nrespectively. They alter the representation specified in the attribute.\nIf no representation is specified, the default one is altered.\n\n// Default representation, alignment lowered to 2.\n#[repr(packed(2))]\nstruct PackedStruct {\n    first: i16,\n    second: i8,\n    third: i32\n}\n\n// C representation, alignment raised to 8\n#[repr(C, align(8))]\nstruct AlignedStruct {\n    first: i16,\n    second: i8,\n    third: i32\n}\n\n> [!NOTE]\n> As a consequence of the representation being an attribute on the item, the representation does not depend on generic parameters. Any two types with the same name have the same representation. For example, `Foo<Bar>` and `Foo<Baz>` both have the same representation.",
        "layout.repr.inter-field": "The representation of a type can change the padding between fields, but does\nnot change the layout of the fields themselves. For example, a struct with a\n`C` representation that contains a struct `Inner` with the `Rust`\nrepresentation will not change the layout of `Inner`.\n\n<a id=\"the-default-representation\"></a>"
      }
    },
    {
      "id": "layout.repr.rust",
      "title": "The `Rust` representation",
      "level": 2,
      "content": "The `Rust` representation is the default representation for nominal types\nwithout a `repr` attribute. Using this representation explicitly through a\n`repr` attribute is guaranteed to be the same as omitting the attribute\nentirely.\n\nThe only data layout guarantees made by this representation are those required\nfor soundness. They are:\n\n 1. The fields are properly aligned.\n 2. The fields do not overlap.\n 3. The alignment of the type is at least the maximum alignment of its fields.\n\nFormally, the first guarantee means that the offset of any field is divisible by\nthat field's alignment.\n\nThe second guarantee means that the fields can be\nordered such that the offset plus the size of any field is less than or equal to\nthe offset of the next field in the ordering. The ordering does not have to be\nthe same as the order in which the fields are specified in the declaration of\nthe type.\n\nBe aware that the second guarantee does not imply that the fields have distinct\naddresses: zero-sized types may have the same address as other fields in the\nsame struct.\n\nThere are no other guarantees of data layout made by this representation.",
      "parent_id": null,
      "paragraphs": {
        "layout.repr.rust.intro": "The `Rust` representation is the default representation for nominal types\nwithout a `repr` attribute. Using this representation explicitly through a\n`repr` attribute is guaranteed to be the same as omitting the attribute\nentirely.",
        "layout.repr.rust.layout": "The only data layout guarantees made by this representation are those required\nfor soundness. They are:\n\n 1. The fields are properly aligned.\n 2. The fields do not overlap.\n 3. The alignment of the type is at least the maximum alignment of its fields.",
        "layout.repr.rust.alignment": "Formally, the first guarantee means that the offset of any field is divisible by\nthat field's alignment.",
        "layout.repr.rust.field-storage": "The second guarantee means that the fields can be\nordered such that the offset plus the size of any field is less than or equal to\nthe offset of the next field in the ordering. The ordering does not have to be\nthe same as the order in which the fields are specified in the declaration of\nthe type.\n\nBe aware that the second guarantee does not imply that the fields have distinct\naddresses: zero-sized types may have the same address as other fields in the\nsame struct.",
        "layout.repr.rust.unspecified": "There are no other guarantees of data layout made by this representation."
      }
    },
    {
      "id": "layout.repr.c",
      "title": "The `C` representation",
      "level": 3,
      "content": "The `C` representation is designed for dual purposes. One purpose is for\ncreating types that are interoperable with the C Language. The second purpose is\nto create types that you can soundly perform operations on that rely on data\nlayout such as reinterpreting values as a different type.\n\nBecause of this dual purpose, it is possible to create types that are not useful\nfor interfacing with the C programming language.\n\nThis representation can be applied to structs, unions, and enums. The exception\nis [zero-variant enums] for which the `C` representation is an error.",
      "parent_id": null,
      "paragraphs": {
        "layout.repr.c.intro": "The `C` representation is designed for dual purposes. One purpose is for\ncreating types that are interoperable with the C Language. The second purpose is\nto create types that you can soundly perform operations on that rely on data\nlayout such as reinterpreting values as a different type.\n\nBecause of this dual purpose, it is possible to create types that are not useful\nfor interfacing with the C programming language.",
        "layout.repr.c.constraint": "This representation can be applied to structs, unions, and enums. The exception\nis [zero-variant enums] for which the `C` representation is an error."
      }
    },
    {
      "id": "layout.repr.c.struct",
      "title": "`#[repr(C)]` Structs",
      "level": 3,
      "content": "The alignment of the struct is the alignment of the most-aligned field in it.\n\nThe size and offset of fields is determined by the following algorithm.\n\nStart with a current offset of 0 bytes.\n\nFor each field in declaration order in the struct, first determine the size and\nalignment of the field. If the current offset is not a multiple of the field's\nalignment, then add padding bytes to the current offset until it is a multiple\nof the field's alignment. The offset for the field is what the current offset\nis now. Then increase the current offset by the size of the field.\n\nFinally, the size of the struct is the current offset rounded up to the nearest\nmultiple of the struct's alignment.\n\nHere is this algorithm described in pseudocode.\n\n<!-- ignore: pseudocode -->\n,ignore\n/// Returns the amount of padding needed after `offset` to ensure that the\n/// following address will be aligned to `alignment`.\nfn padding_needed_for(offset: usize, alignment: usize) -> usize {\n    let misalignment = offset % alignment;\n    if misalignment > 0 {\n        // round up to next multiple of `alignment`\n        alignment - misalignment\n    } else {\n        // already a multiple of `alignment`\n        0\n    }\n}\n\nstruct.alignment = struct.fields().map(|field| field.alignment).max();\n\nlet current_offset = 0;\n\nfor field in struct.fields_in_declaration_order() {\n    // Increase the current offset so that it's a multiple of the alignment\n    // of this field. For the first field, this will always be zero.\n    // The skipped bytes are called padding bytes.\n    current_offset += padding_needed_for(current_offset, field.alignment);\n\n    struct[field].offset = current_offset;\n\n    current_offset += field.size;\n}\n\nstruct.size = current_offset + padding_needed_for(current_offset, struct.alignment);\n\n> [!WARNING]\n> This pseudocode uses a naive algorithm that ignores overflow issues for the sake of clarity. To perform memory layout computations in actual code, use [`Layout`].\n\n> [!NOTE]\n> This algorithm can produce zero-sized structs. In C, an empty struct declaration like `struct Foo { }` is illegal. However, both gcc and clang support options to enable such structs, and assign them size zero. C++, in contrast, gives empty structs a size of 1, unless they are inherited from or they are fields that have the `[[no_unique_address]]` attribute, in which case they do not increase the overall size of the struct.",
      "parent_id": null,
      "paragraphs": {
        "layout.repr.c.struct.align": "The alignment of the struct is the alignment of the most-aligned field in it.",
        "layout.repr.c.struct.size-field-offset": "The size and offset of fields is determined by the following algorithm.\n\nStart with a current offset of 0 bytes.\n\nFor each field in declaration order in the struct, first determine the size and\nalignment of the field. If the current offset is not a multiple of the field's\nalignment, then add padding bytes to the current offset until it is a multiple\nof the field's alignment. The offset for the field is what the current offset\nis now. Then increase the current offset by the size of the field.\n\nFinally, the size of the struct is the current offset rounded up to the nearest\nmultiple of the struct's alignment.\n\nHere is this algorithm described in pseudocode.\n\n<!-- ignore: pseudocode -->\n,ignore\n/// Returns the amount of padding needed after `offset` to ensure that the\n/// following address will be aligned to `alignment`.\nfn padding_needed_for(offset: usize, alignment: usize) -> usize {\n    let misalignment = offset % alignment;\n    if misalignment > 0 {\n        // round up to next multiple of `alignment`\n        alignment - misalignment\n    } else {\n        // already a multiple of `alignment`\n        0\n    }\n}\n\nstruct.alignment = struct.fields().map(|field| field.alignment).max();\n\nlet current_offset = 0;\n\nfor field in struct.fields_in_declaration_order() {\n    // Increase the current offset so that it's a multiple of the alignment\n    // of this field. For the first field, this will always be zero.\n    // The skipped bytes are called padding bytes.\n    current_offset += padding_needed_for(current_offset, field.alignment);\n\n    struct[field].offset = current_offset;\n\n    current_offset += field.size;\n}\n\nstruct.size = current_offset + padding_needed_for(current_offset, struct.alignment);\n\n> [!WARNING]\n> This pseudocode uses a naive algorithm that ignores overflow issues for the sake of clarity. To perform memory layout computations in actual code, use [`Layout`].\n\n> [!NOTE]\n> This algorithm can produce zero-sized structs. In C, an empty struct declaration like `struct Foo { }` is illegal. However, both gcc and clang support options to enable such structs, and assign them size zero. C++, in contrast, gives empty structs a size of 1, unless they are inherited from or they are fields that have the `[[no_unique_address]]` attribute, in which case they do not increase the overall size of the struct."
      }
    },
    {
      "id": "layout.repr.c.union",
      "title": "`#[repr(C)]` Unions",
      "level": 4,
      "content": "A union declared with `#[repr(C)]` will have the same size and alignment as an\nequivalent C union declaration in the C language for the target platform.\n\nThe union will have a size of the maximum size of all of its fields rounded to\nits alignment, and an alignment of the maximum alignment of all of its fields.\nThese maximums may come from different fields.\n\n#[repr(C)]\nunion Union {\n    f1: u16,\n    f2: [u8; 4],\n}\n\nassert_eq!(std::mem::size_of::<Union>(), 4);  // From f2\nassert_eq!(std::mem::align_of::<Union>(), 2); // From f1\n\n#[repr(C)]\nunion SizeRoundedUp {\n   a: u32,\n   b: [u16; 3],\n}\n\nassert_eq!(std::mem::size_of::<SizeRoundedUp>(), 8);  // Size of 6 from b,\n                                                      // rounded up to 8 from\n                                                      // alignment of a.\nassert_eq!(std::mem::align_of::<SizeRoundedUp>(), 4); // From a",
      "parent_id": null,
      "paragraphs": {
        "layout.repr.c.union.intro": "A union declared with `#[repr(C)]` will have the same size and alignment as an\nequivalent C union declaration in the C language for the target platform.",
        "layout.repr.c.union.size-align": "The union will have a size of the maximum size of all of its fields rounded to\nits alignment, and an alignment of the maximum alignment of all of its fields.\nThese maximums may come from different fields.\n\n#[repr(C)]\nunion Union {\n    f1: u16,\n    f2: [u8; 4],\n}\n\nassert_eq!(std::mem::size_of::<Union>(), 4);  // From f2\nassert_eq!(std::mem::align_of::<Union>(), 2); // From f1\n\n#[repr(C)]\nunion SizeRoundedUp {\n   a: u32,\n   b: [u16; 3],\n}\n\nassert_eq!(std::mem::size_of::<SizeRoundedUp>(), 8);  // Size of 6 from b,\n                                                      // rounded up to 8 from\n                                                      // alignment of a.\nassert_eq!(std::mem::align_of::<SizeRoundedUp>(), 4); // From a"
      }
    },
    {
      "id": "layout.repr.c.enum",
      "title": "`#[repr(C)]` Field-less Enums",
      "level": 4,
      "content": "For [field-less enums], the `C` representation has the size and alignment of\nthe default `enum` size and alignment for the target platform's C ABI.\n\n> [!NOTE]\n> The enum representation in C is implementation defined, so this is really a \"best guess\". In particular, this may be incorrect when the C code of interest is compiled with certain flags.\n\n> [!WARNING]\n> There are crucial differences between an `enum` in the C language and Rust's [field-less enums] with this representation. An `enum` in C is mostly a `typedef` plus some named constants; in other words, an object of an `enum` type can hold any integer value. For example, this is often used for bitflags in `C`. In contrast, Rust\u2019s [field-less enums] can only legally hold the discriminant values, everything else is [undefined behavior]. Therefore, using a field-less enum in FFI to model a C `enum` is often wrong.",
      "parent_id": null,
      "paragraphs": {
        "layout.repr.c.enum": "For [field-less enums], the `C` representation has the size and alignment of\nthe default `enum` size and alignment for the target platform's C ABI.\n\n> [!NOTE]\n> The enum representation in C is implementation defined, so this is really a \"best guess\". In particular, this may be incorrect when the C code of interest is compiled with certain flags.\n\n> [!WARNING]\n> There are crucial differences between an `enum` in the C language and Rust's [field-less enums] with this representation. An `enum` in C is mostly a `typedef` plus some named constants; in other words, an object of an `enum` type can hold any integer value. For example, this is often used for bitflags in `C`. In contrast, Rust\u2019s [field-less enums] can only legally hold the discriminant values, everything else is [undefined behavior]. Therefore, using a field-less enum in FFI to model a C `enum` is often wrong."
      }
    },
    {
      "id": "layout.repr.c.adt",
      "title": "`#[repr(C)]` Enums With Fields",
      "level": 4,
      "content": "The representation of a `repr(C)` enum with fields is a `repr(C)` struct with\ntwo fields, also called a \"tagged union\" in C:\n\n- a `repr(C)` version of the enum with all fields removed (\"the tag\")\n\n- a `repr(C)` union of `repr(C)` structs for the fields of each variant that had\n  them (\"the payload\")\n\n> [!NOTE]\n> Due to the representation of `repr(C)` structs and unions, if a variant has a single field there is no difference between putting that field directly in the union or wrapping it in a struct; any system which wishes to manipulate such an `enum`'s representation may therefore use whichever form is more convenient or consistent for them.\n\n// This Enum has the same representation as ...\n#[repr(C)]\nenum MyEnum {\n    A(u32),\n    B(f32, u64),\n    C { x: u32, y: u8 },\n    D,\n }\n\n// ... this struct.\n#[repr(C)]\nstruct MyEnumRepr {\n    tag: MyEnumDiscriminant,\n    payload: MyEnumFields,\n}\n\n// This is the discriminant enum.\n#[repr(C)]\nenum MyEnumDiscriminant { A, B, C, D }\n\n// This is the variant union.\n#[repr(C)]\nunion MyEnumFields {\n    A: MyAFields,\n    B: MyBFields,\n    C: MyCFields,\n    D: MyDFields,\n}\n\n#[repr(C)]\n#[derive(Copy, Clone)]\nstruct MyAFields(u32);\n\n#[repr(C)]\n#[derive(Copy, Clone)]\nstruct MyBFields(f32, u64);\n\n#[repr(C)]\n#[derive(Copy, Clone)]\nstruct MyCFields { x: u32, y: u8 }\n\n// This struct could be omitted (it is a zero-sized type), and it must be in\n// C/C++ headers.\n#[repr(C)]\n#[derive(Copy, Clone)]\nstruct MyDFields;",
      "parent_id": null,
      "paragraphs": {
        "layout.repr.c.adt.intro": "The representation of a `repr(C)` enum with fields is a `repr(C)` struct with\ntwo fields, also called a \"tagged union\" in C:",
        "layout.repr.c.adt.tag": "- a `repr(C)` version of the enum with all fields removed (\"the tag\")",
        "layout.repr.c.adt.fields": "- a `repr(C)` union of `repr(C)` structs for the fields of each variant that had\n  them (\"the payload\")\n\n> [!NOTE]\n> Due to the representation of `repr(C)` structs and unions, if a variant has a single field there is no difference between putting that field directly in the union or wrapping it in a struct; any system which wishes to manipulate such an `enum`'s representation may therefore use whichever form is more convenient or consistent for them.\n\n// This Enum has the same representation as ...\n#[repr(C)]\nenum MyEnum {\n    A(u32),\n    B(f32, u64),\n    C { x: u32, y: u8 },\n    D,\n }\n\n// ... this struct.\n#[repr(C)]\nstruct MyEnumRepr {\n    tag: MyEnumDiscriminant,\n    payload: MyEnumFields,\n}\n\n// This is the discriminant enum.\n#[repr(C)]\nenum MyEnumDiscriminant { A, B, C, D }\n\n// This is the variant union.\n#[repr(C)]\nunion MyEnumFields {\n    A: MyAFields,\n    B: MyBFields,\n    C: MyCFields,\n    D: MyDFields,\n}\n\n#[repr(C)]\n#[derive(Copy, Clone)]\nstruct MyAFields(u32);\n\n#[repr(C)]\n#[derive(Copy, Clone)]\nstruct MyBFields(f32, u64);\n\n#[repr(C)]\n#[derive(Copy, Clone)]\nstruct MyCFields { x: u32, y: u8 }\n\n// This struct could be omitted (it is a zero-sized type), and it must be in\n// C/C++ headers.\n#[repr(C)]\n#[derive(Copy, Clone)]\nstruct MyDFields;"
      }
    },
    {
      "id": "layout.repr.primitive",
      "title": "Primitive representations",
      "level": 4,
      "content": "The *primitive representations* are the representations with the same names as\nthe primitive integer types. That is: `u8`, `u16`, `u32`, `u64`, `u128`,\n`usize`, `i8`, `i16`, `i32`, `i64`, `i128`, and `isize`.\n\nPrimitive representations can only be applied to enumerations and have\ndifferent behavior whether the enum has fields or no fields. It is an error\nfor [zero-variant enums] to have a primitive representation. Combining\ntwo primitive representations together is an error.",
      "parent_id": null,
      "paragraphs": {
        "layout.repr.primitive.intro": "The *primitive representations* are the representations with the same names as\nthe primitive integer types. That is: `u8`, `u16`, `u32`, `u64`, `u128`,\n`usize`, `i8`, `i16`, `i32`, `i64`, `i128`, and `isize`.",
        "layout.repr.primitive.constraint": "Primitive representations can only be applied to enumerations and have\ndifferent behavior whether the enum has fields or no fields. It is an error\nfor [zero-variant enums] to have a primitive representation. Combining\ntwo primitive representations together is an error."
      }
    },
    {
      "id": "layout.repr.primitive.enum",
      "title": "Primitive representation of field-less enums",
      "level": 3,
      "content": "For [field-less enums], primitive representations set the size and alignment to\nbe the same as the primitive type of the same name. For example, a field-less\nenum with a `u8` representation can only have discriminants between 0 and 255\ninclusive.",
      "parent_id": null,
      "paragraphs": {
        "layout.repr.primitive.enum": "For [field-less enums], primitive representations set the size and alignment to\nbe the same as the primitive type of the same name. For example, a field-less\nenum with a `u8` representation can only have discriminants between 0 and 255\ninclusive."
      }
    },
    {
      "id": "layout.repr.primitive.adt",
      "title": "Primitive representation of enums with fields",
      "level": 4,
      "content": "The representation of a primitive representation enum is a `repr(C)` union of\n`repr(C)` structs for each variant with a field. The first field of each struct\nin the union is the primitive representation version of the enum with all fields\nremoved (\"the tag\") and the remaining fields are the fields of that variant.\n\n> [!NOTE]\n> This representation is unchanged if the tag is given its own member in the union, should that make manipulation more clear for you (although to follow the C++ standard the tag member should be wrapped in a `struct`).\n\n// This enum has the same representation as ...\n#[repr(u8)]\nenum MyEnum {\n    A(u32),\n    B(f32, u64),\n    C { x: u32, y: u8 },\n    D,\n }\n\n// ... this union.\n#[repr(C)]\nunion MyEnumRepr {\n    A: MyVariantA,\n    B: MyVariantB,\n    C: MyVariantC,\n    D: MyVariantD,\n}\n\n// This is the discriminant enum.\n#[repr(u8)]\n#[derive(Copy, Clone)]\nenum MyEnumDiscriminant { A, B, C, D }\n\n#[repr(C)]\n#[derive(Clone, Copy)]\nstruct MyVariantA(MyEnumDiscriminant, u32);\n\n#[repr(C)]\n#[derive(Clone, Copy)]\nstruct MyVariantB(MyEnumDiscriminant, f32, u64);\n\n#[repr(C)]\n#[derive(Clone, Copy)]\nstruct MyVariantC { tag: MyEnumDiscriminant, x: u32, y: u8 }\n\n#[repr(C)]\n#[derive(Clone, Copy)]\nstruct MyVariantD(MyEnumDiscriminant);",
      "parent_id": null,
      "paragraphs": {
        "layout.repr.primitive.adt": "The representation of a primitive representation enum is a `repr(C)` union of\n`repr(C)` structs for each variant with a field. The first field of each struct\nin the union is the primitive representation version of the enum with all fields\nremoved (\"the tag\") and the remaining fields are the fields of that variant.\n\n> [!NOTE]\n> This representation is unchanged if the tag is given its own member in the union, should that make manipulation more clear for you (although to follow the C++ standard the tag member should be wrapped in a `struct`).\n\n// This enum has the same representation as ...\n#[repr(u8)]\nenum MyEnum {\n    A(u32),\n    B(f32, u64),\n    C { x: u32, y: u8 },\n    D,\n }\n\n// ... this union.\n#[repr(C)]\nunion MyEnumRepr {\n    A: MyVariantA,\n    B: MyVariantB,\n    C: MyVariantC,\n    D: MyVariantD,\n}\n\n// This is the discriminant enum.\n#[repr(u8)]\n#[derive(Copy, Clone)]\nenum MyEnumDiscriminant { A, B, C, D }\n\n#[repr(C)]\n#[derive(Clone, Copy)]\nstruct MyVariantA(MyEnumDiscriminant, u32);\n\n#[repr(C)]\n#[derive(Clone, Copy)]\nstruct MyVariantB(MyEnumDiscriminant, f32, u64);\n\n#[repr(C)]\n#[derive(Clone, Copy)]\nstruct MyVariantC { tag: MyEnumDiscriminant, x: u32, y: u8 }\n\n#[repr(C)]\n#[derive(Clone, Copy)]\nstruct MyVariantD(MyEnumDiscriminant);"
      }
    },
    {
      "id": "layout.repr.primitive-c",
      "title": "Combining primitive representations of enums with fields and `#[repr(C)]`",
      "level": 4,
      "content": "For enums with fields, it is also possible to combine `repr(C)` and a\nprimitive representation (e.g., `repr(C, u8)`). This modifies the [`repr(C)`] by\nchanging the representation of the discriminant enum to the chosen primitive\ninstead. So, if you chose the `u8` representation, then the discriminant enum\nwould have a size and alignment of 1 byte.\n\nThe discriminant enum from the example earlier then becomes:\n\n#[repr(C, u8)] // `u8` was added\nenum MyEnum {\n    A(u32),\n    B(f32, u64),\n    C { x: u32, y: u8 },\n    D,\n }\n\n// ...\n\n#[repr(u8)] // So `u8` is used here instead of `C`\nenum MyEnumDiscriminant { A, B, C, D }\n\n// ...\n\nFor example, with a `repr(C, u8)` enum it is not possible to have 257 unique\ndiscriminants (\"tags\") whereas the same enum with only a `repr(C)` attribute\nwill compile without any problems.\n\nUsing a primitive representation in addition to `repr(C)` can change the size of\nan enum from the `repr(C)` form:\n\n#[repr(C)]\nenum EnumC {\n    Variant0(u8),\n    Variant1,\n}\n\n#[repr(C, u8)]\nenum Enum8 {\n    Variant0(u8),\n    Variant1,\n}\n\n#[repr(C, u16)]\nenum Enum16 {\n    Variant0(u8),\n    Variant1,\n}\n\n// The size of the C representation is platform dependent\nassert_eq!(std::mem::size_of::<EnumC>(), 8);\n// One byte for the discriminant and one byte for the value in Enum8::Variant0\nassert_eq!(std::mem::size_of::<Enum8>(), 2);\n// Two bytes for the discriminant and one byte for the value in Enum16::Variant0\n// plus one byte of padding.\nassert_eq!(std::mem::size_of::<Enum16>(), 4);",
      "parent_id": null,
      "paragraphs": {
        "layout.repr.primitive-c": "For enums with fields, it is also possible to combine `repr(C)` and a\nprimitive representation (e.g., `repr(C, u8)`). This modifies the [`repr(C)`] by\nchanging the representation of the discriminant enum to the chosen primitive\ninstead. So, if you chose the `u8` representation, then the discriminant enum\nwould have a size and alignment of 1 byte.\n\nThe discriminant enum from the example earlier then becomes:\n\n#[repr(C, u8)] // `u8` was added\nenum MyEnum {\n    A(u32),\n    B(f32, u64),\n    C { x: u32, y: u8 },\n    D,\n }\n\n// ...\n\n#[repr(u8)] // So `u8` is used here instead of `C`\nenum MyEnumDiscriminant { A, B, C, D }\n\n// ...\n\nFor example, with a `repr(C, u8)` enum it is not possible to have 257 unique\ndiscriminants (\"tags\") whereas the same enum with only a `repr(C)` attribute\nwill compile without any problems.\n\nUsing a primitive representation in addition to `repr(C)` can change the size of\nan enum from the `repr(C)` form:\n\n#[repr(C)]\nenum EnumC {\n    Variant0(u8),\n    Variant1,\n}\n\n#[repr(C, u8)]\nenum Enum8 {\n    Variant0(u8),\n    Variant1,\n}\n\n#[repr(C, u16)]\nenum Enum16 {\n    Variant0(u8),\n    Variant1,\n}\n\n// The size of the C representation is platform dependent\nassert_eq!(std::mem::size_of::<EnumC>(), 8);\n// One byte for the discriminant and one byte for the value in Enum8::Variant0\nassert_eq!(std::mem::size_of::<Enum8>(), 2);\n// Two bytes for the discriminant and one byte for the value in Enum16::Variant0\n// plus one byte of padding.\nassert_eq!(std::mem::size_of::<Enum16>(), 4);"
      }
    },
    {
      "id": "layout.repr.alignment",
      "title": "The alignment modifiers",
      "level": 4,
      "content": "The `align` and `packed` modifiers can be used to respectively raise or lower\nthe alignment of `struct`s and `union`s. `packed` may also alter the padding\nbetween fields (although it will not alter the padding inside of any field).\nOn their own, `align` and `packed` do not provide guarantees about the order\nof fields in the layout of a struct or the layout of an enum variant, although\nthey may be combined with representations (such as `C`) which do provide such\nguarantees.\n\nThe alignment is specified as an integer parameter in the form of\n`#[repr(align(x))]` or `#[repr(packed(x))]`. The alignment value must be a\npower of two from 1 up to 2<sup>29</sup>. For `packed`, if no value is given,\nas in `#[repr(packed)]`, then the value is 1.\n\nFor `align`, if the specified alignment is less than the alignment of the type\nwithout the `align` modifier, then the alignment is unaffected.\n\nFor `packed`, if the specified alignment is greater than the type's alignment\nwithout the `packed` modifier, then the alignment and layout is unaffected.\n\nThe alignments of each field, for the purpose of positioning fields, is the\nsmaller of the specified alignment and the alignment of the field's type.\n\nInter-field padding is guaranteed to be the minimum required in order to\nsatisfy each field's (possibly altered) alignment (although note that, on its\nown, `packed` does not provide any guarantee about field ordering). An\nimportant consequence of these rules is that a type with `#[repr(packed(1))]`\n(or `#[repr(packed)]`) will have no inter-field padding.\n\nThe `align` and `packed` modifiers cannot be applied on the same type and a\n`packed` type cannot transitively contain another `align`ed type. `align` and\n`packed` may only be applied to the [`Rust`] and [`C`] representations.\n\nThe `align` modifier can also be applied on an `enum`.\nWhen it is, the effect on the `enum`'s alignment is the same as if the `enum`\nwas wrapped in a newtype `struct` with the same `align` modifier.\n\n> [!NOTE]\n> References to unaligned fields are not allowed because it is [undefined behavior]. When fields are unaligned due to an alignment modifier, consider the following options for using references and dereferences:\n>\n> ```rust\n> #[repr(packed)]\n> struct Packed {\n>     f1: u8,\n>     f2: u16,\n> }\n> let mut e = Packed { f1: 1, f2: 2 };\n> // Instead of creating a reference to a field, copy the value to a local variable.\n> let x = e.f2;\n> // Or in situations like `println!` which creates a reference, use braces\n> // to change it to a copy of the value.\n> println!(\"{}\", {e.f2});\n> // Or if you need a pointer, use the unaligned methods for reading and writing\n> // instead of dereferencing the pointer directly.\n> let ptr: *const u16 = &raw const e.f2;\n> let value = unsafe { ptr.read_unaligned() };\n> let mut_ptr: *mut u16 = &raw mut e.f2;\n> unsafe { mut_ptr.write_unaligned(3) }\n> ```",
      "parent_id": null,
      "paragraphs": {
        "layout.repr.alignment.intro": "The `align` and `packed` modifiers can be used to respectively raise or lower\nthe alignment of `struct`s and `union`s. `packed` may also alter the padding\nbetween fields (although it will not alter the padding inside of any field).\nOn their own, `align` and `packed` do not provide guarantees about the order\nof fields in the layout of a struct or the layout of an enum variant, although\nthey may be combined with representations (such as `C`) which do provide such\nguarantees.",
        "layout.repr.alignment.constraint-alignment": "The alignment is specified as an integer parameter in the form of\n`#[repr(align(x))]` or `#[repr(packed(x))]`. The alignment value must be a\npower of two from 1 up to 2<sup>29</sup>. For `packed`, if no value is given,\nas in `#[repr(packed)]`, then the value is 1.",
        "layout.repr.alignment.align": "For `align`, if the specified alignment is less than the alignment of the type\nwithout the `align` modifier, then the alignment is unaffected.",
        "layout.repr.alignment.packed": "For `packed`, if the specified alignment is greater than the type's alignment\nwithout the `packed` modifier, then the alignment and layout is unaffected.",
        "layout.repr.alignment.packed-fields": "The alignments of each field, for the purpose of positioning fields, is the\nsmaller of the specified alignment and the alignment of the field's type.",
        "layout.repr.alignment.packed-padding": "Inter-field padding is guaranteed to be the minimum required in order to\nsatisfy each field's (possibly altered) alignment (although note that, on its\nown, `packed` does not provide any guarantee about field ordering). An\nimportant consequence of these rules is that a type with `#[repr(packed(1))]`\n(or `#[repr(packed)]`) will have no inter-field padding.",
        "layout.repr.alignment.constraint-exclusive": "The `align` and `packed` modifiers cannot be applied on the same type and a\n`packed` type cannot transitively contain another `align`ed type. `align` and\n`packed` may only be applied to the [`Rust`] and [`C`] representations.",
        "layout.repr.alignment.enum": "The `align` modifier can also be applied on an `enum`.\nWhen it is, the effect on the `enum`'s alignment is the same as if the `enum`\nwas wrapped in a newtype `struct` with the same `align` modifier.\n\n> [!NOTE]\n> References to unaligned fields are not allowed because it is [undefined behavior]. When fields are unaligned due to an alignment modifier, consider the following options for using references and dereferences:\n>\n> ```rust\n> #[repr(packed)]\n> struct Packed {\n>     f1: u8,\n>     f2: u16,\n> }\n> let mut e = Packed { f1: 1, f2: 2 };\n> // Instead of creating a reference to a field, copy the value to a local variable.\n> let x = e.f2;\n> // Or in situations like `println!` which creates a reference, use braces\n> // to change it to a copy of the value.\n> println!(\"{}\", {e.f2});\n> // Or if you need a pointer, use the unaligned methods for reading and writing\n> // instead of dereferencing the pointer directly.\n> let ptr: *const u16 = &raw const e.f2;\n> let value = unsafe { ptr.read_unaligned() };\n> let mut_ptr: *mut u16 = &raw mut e.f2;\n> unsafe { mut_ptr.write_unaligned(3) }\n> ```"
      }
    },
    {
      "id": "layout.repr.transparent",
      "title": "The `transparent` representation",
      "level": 3,
      "content": "The `transparent` representation can only be used on a `struct`\nor an `enum` with a single variant that has:\n- any number of fields with size 0 and alignment 1 (e.g. [`PhantomData<T>`]), and\n- at most one other field.\n\nStructs and enums with this representation have the same layout and ABI\nas the only non-size 0 non-alignment 1 field, if present, or unit otherwise.\n\nThis is different than the `C` representation because\na struct with the `C` representation will always have the ABI of a `C` `struct`\nwhile, for example, a struct with the `transparent` representation with a\nprimitive field will have the ABI of the primitive field.\n\nBecause this representation delegates type layout to another type, it cannot be\nused with any other representation.\n\n[`align_of_val`]: std::mem::align_of_val\n[`size_of_val`]: std::mem::size_of_val\n[`align_of`]: std::mem::align_of\n[`size_of`]: std::mem::size_of\n[`Sized`]: std::marker::Sized\n[`Copy`]: std::marker::Copy\n[dynamically sized types]: dynamically-sized-types.md\n[field-less enums]: items/enumerations.md#field-less-enum\n[fn-abi-compatibility]: ../core/primitive.fn.md#abi-compatibility\n[enumerations]: items/enumerations.md\n[zero-variant enums]: items/enumerations.md#zero-variant-enums\n[undefined behavior]: behavior-considered-undefined.md\n[`PhantomData<T>`]: special-types-and-traits.md#phantomdatat\n\n[structs]: items/structs.md\n\n[`Layout`]: std::alloc::Layout",
      "parent_id": null,
      "paragraphs": {
        "layout.repr.transparent.constraint-field": "The `transparent` representation can only be used on a `struct`\nor an `enum` with a single variant that has:\n- any number of fields with size 0 and alignment 1 (e.g. [`PhantomData<T>`]), and\n- at most one other field.",
        "layout.repr.transparent.layout-abi": "Structs and enums with this representation have the same layout and ABI\nas the only non-size 0 non-alignment 1 field, if present, or unit otherwise.\n\nThis is different than the `C` representation because\na struct with the `C` representation will always have the ABI of a `C` `struct`\nwhile, for example, a struct with the `transparent` representation with a\nprimitive field will have the ABI of the primitive field.",
        "layout.repr.transparent.constraint-exclusive": "Because this representation delegates type layout to another type, it cannot be\nused with any other representation.\n\n[`align_of_val`]: std::mem::align_of_val\n[`size_of_val`]: std::mem::size_of_val\n[`align_of`]: std::mem::align_of\n[`size_of`]: std::mem::size_of\n[`Sized`]: std::marker::Sized\n[`Copy`]: std::marker::Copy\n[dynamically sized types]: dynamically-sized-types.md\n[field-less enums]: items/enumerations.md#field-less-enum\n[fn-abi-compatibility]: ../core/primitive.fn.md#abi-compatibility\n[enumerations]: items/enumerations.md\n[zero-variant enums]: items/enumerations.md#zero-variant-enums\n[undefined behavior]: behavior-considered-undefined.md\n[`PhantomData<T>`]: special-types-and-traits.md#phantomdatat\n\n[structs]: items/structs.md\n\n[`Layout`]: std::alloc::Layout"
      }
    },
    {
      "id": "interior-mut",
      "title": "Interior mutability",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "interior-mut.intro",
      "title": "Interior mutability",
      "level": 1,
      "content": "Sometimes a type needs to be mutated while having multiple aliases. In Rust this\nis achieved using a pattern called _interior mutability_.",
      "parent_id": null,
      "paragraphs": {
        "interior-mut.intro": "Sometimes a type needs to be mutated while having multiple aliases. In Rust this\nis achieved using a pattern called _interior mutability_."
      }
    },
    {
      "id": "interior-mut.shared-ref",
      "title": "Interior mutability",
      "level": 1,
      "content": "A type has interior mutability if its internal state can be changed through a [shared reference] to\nit.",
      "parent_id": null,
      "paragraphs": {
        "interior-mut.shared-ref": "A type has interior mutability if its internal state can be changed through a [shared reference] to\nit."
      }
    },
    {
      "id": "interior-mut.no-constraint",
      "title": "Interior mutability",
      "level": 1,
      "content": "This goes against the usual requirement that the value pointed to by a\nshared reference is not mutated.",
      "parent_id": null,
      "paragraphs": {
        "interior-mut.no-constraint": "This goes against the usual requirement that the value pointed to by a\nshared reference is not mutated."
      }
    },
    {
      "id": "interior-mut.unsafe-cell",
      "title": "Interior mutability",
      "level": 1,
      "content": "[`std::cell::UnsafeCell<T>`] type is the only allowed way to disable\nthis requirement. When `UnsafeCell<T>` is immutably aliased, it is still safe to\nmutate, or obtain a mutable reference to, the `T` it contains.",
      "parent_id": null,
      "paragraphs": {
        "interior-mut.unsafe-cell": "[`std::cell::UnsafeCell<T>`] type is the only allowed way to disable\nthis requirement. When `UnsafeCell<T>` is immutably aliased, it is still safe to\nmutate, or obtain a mutable reference to, the `T` it contains."
      }
    },
    {
      "id": "interior-mut.mut-unsafe-cell",
      "title": "Interior mutability",
      "level": 1,
      "content": "As with all other types, it is undefined behavior to have multiple `&mut UnsafeCell<T>`\naliases.",
      "parent_id": null,
      "paragraphs": {
        "interior-mut.mut-unsafe-cell": "As with all other types, it is undefined behavior to have multiple `&mut UnsafeCell<T>`\naliases."
      }
    },
    {
      "id": "interior-mut.abstraction",
      "title": "Interior mutability",
      "level": 1,
      "content": "Other types with interior mutability can be created by using `UnsafeCell<T>` as\na field. The standard library provides a variety of types that provide safe\ninterior mutability APIs.",
      "parent_id": null,
      "paragraphs": {
        "interior-mut.abstraction": "Other types with interior mutability can be created by using `UnsafeCell<T>` as\na field. The standard library provides a variety of types that provide safe\ninterior mutability APIs."
      }
    },
    {
      "id": "interior-mut.ref-cell",
      "title": "Interior mutability",
      "level": 1,
      "content": "For example, [`std::cell::RefCell<T>`] uses run-time borrow checks to ensure the usual rules around multiple references.",
      "parent_id": null,
      "paragraphs": {
        "interior-mut.ref-cell": "For example, [`std::cell::RefCell<T>`] uses run-time borrow checks to ensure the usual rules around multiple references."
      }
    },
    {
      "id": "interior-mut.atomic",
      "title": "Interior mutability",
      "level": 1,
      "content": "The [`std::sync::atomic`] module contains types that wrap a value that is only\naccessed with atomic operations, allowing the value to be shared and mutated\nacross threads.\n\n[shared reference]: types/pointer.md#shared-references-\n[ub]: behavior-considered-undefined.md",
      "parent_id": null,
      "paragraphs": {
        "interior-mut.atomic": "The [`std::sync::atomic`] module contains types that wrap a value that is only\naccessed with atomic operations, allowing the value to be shared and mutated\nacross threads.\n\n[shared reference]: types/pointer.md#shared-references-\n[ub]: behavior-considered-undefined.md"
      }
    },
    {
      "id": "subtype",
      "title": "Subtyping and variance",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "subtype.intro",
      "title": "Subtyping and variance",
      "level": 1,
      "content": "Subtyping is implicit and can occur at any stage in type checking or\ninference.",
      "parent_id": null,
      "paragraphs": {
        "subtype.intro": "Subtyping is implicit and can occur at any stage in type checking or\ninference."
      }
    },
    {
      "id": "subtype.kinds",
      "title": "Subtyping and variance",
      "level": 1,
      "content": "Subtyping is restricted to two cases:\nvariance with respect to lifetimes and between types with higher ranked\nlifetimes. If we were to erase lifetimes from types, then the only subtyping\nwould be due to type equality.\n\nConsider the following example: string literals always have `'static`\nlifetime. Nevertheless, we can assign `s` to `t`:\n\nfn bar<'a>() {\n    let s: &'static str = \"hi\";\n    let t: &'a str = s;\n}\n\nSince `'static` outlives the lifetime parameter `'a`, `&'static str` is a\nsubtype of `&'a str`.",
      "parent_id": null,
      "paragraphs": {
        "subtype.kinds": "Subtyping is restricted to two cases:\nvariance with respect to lifetimes and between types with higher ranked\nlifetimes. If we were to erase lifetimes from types, then the only subtyping\nwould be due to type equality.\n\nConsider the following example: string literals always have `'static`\nlifetime. Nevertheless, we can assign `s` to `t`:\n\nfn bar<'a>() {\n    let s: &'static str = \"hi\";\n    let t: &'a str = s;\n}\n\nSince `'static` outlives the lifetime parameter `'a`, `&'static str` is a\nsubtype of `&'a str`."
      }
    },
    {
      "id": "subtype.higher-ranked",
      "title": "Subtyping and variance",
      "level": 1,
      "content": "[Higher-ranked]&#32;[function pointers] and [trait objects] have another\nsubtype relation. They are subtypes of types that are given by substitutions of\nthe higher-ranked lifetimes. Some examples:\n\n// Here 'a is substituted for 'static\nlet subtype: &(for<'a> fn(&'a i32) -> &'a i32) = &((|x| x) as fn(&_) -> &_);\nlet supertype: &(fn(&'static i32) -> &'static i32) = subtype;\n\n// This works similarly for trait objects\nlet subtype: &(dyn for<'a> Fn(&'a i32) -> &'a i32) = &|x| x;\nlet supertype: &(dyn Fn(&'static i32) -> &'static i32) = subtype;\n\n// We can also substitute one higher-ranked lifetime for another\nlet subtype: &(for<'a, 'b> fn(&'a i32, &'b i32)) = &((|x, y| {}) as fn(&_, &_));\nlet supertype: &for<'c> fn(&'c i32, &'c i32) = subtype;",
      "parent_id": null,
      "paragraphs": {
        "subtype.higher-ranked": "[Higher-ranked]&#32;[function pointers] and [trait objects] have another\nsubtype relation. They are subtypes of types that are given by substitutions of\nthe higher-ranked lifetimes. Some examples:\n\n// Here 'a is substituted for 'static\nlet subtype: &(for<'a> fn(&'a i32) -> &'a i32) = &((|x| x) as fn(&_) -> &_);\nlet supertype: &(fn(&'static i32) -> &'static i32) = subtype;\n\n// This works similarly for trait objects\nlet subtype: &(dyn for<'a> Fn(&'a i32) -> &'a i32) = &|x| x;\nlet supertype: &(dyn Fn(&'static i32) -> &'static i32) = subtype;\n\n// We can also substitute one higher-ranked lifetime for another\nlet subtype: &(for<'a, 'b> fn(&'a i32, &'b i32)) = &((|x, y| {}) as fn(&_, &_));\nlet supertype: &for<'c> fn(&'c i32, &'c i32) = subtype;"
      }
    },
    {
      "id": "subtyping.variance",
      "title": "Variance",
      "level": 1,
      "content": "Variance is a property that generic types have with respect to their arguments.\nA generic type's *variance* in a parameter is how the subtyping of the\nparameter affects the subtyping of the type.\n\n* `F<T>` is *covariant* over `T` if `T` being a subtype of `U` implies that\n  `F<T>` is a subtype of `F<U>` (subtyping \"passes through\")\n\n* `F<T>` is *contravariant* over `T` if `T` being a subtype of `U` implies that\n  `F<U>` is a subtype of `F<T>`\n\n* `F<T>` is *invariant* over `T` otherwise (no subtyping relation can be\n  derived)\n\nVariance of types is automatically determined as follows\n\n| Type                          | Variance in `'a`  | Variance in `T`   |\n|-------------------------------|-------------------|-------------------|\n| `&'a T`                       | covariant         | covariant         |\n| `&'a mut T`                   | covariant         | invariant         |\n| `*const T`                    |                   | covariant         |\n| `*mut T`                      |                   | invariant         |\n| `[T]` and `[T; n]`            |                   | covariant         |\n| `fn() -> T`                   |                   | covariant         |\n| `fn(T) -> ()`                 |                   | contravariant     |\n| `std::cell::UnsafeCell<T>`    |                   | invariant         |\n| `std::marker::PhantomData<T>` |                   | covariant         |\n| `dyn Trait<T> + 'a`           | covariant         | invariant         |\n\nThe variance of other `struct`, `enum`, and `union` types is decided by\nlooking at the variance of the types of their fields. If the parameter is used\nin positions with different variances then the parameter is invariant. For\nexample the following struct is covariant in `'a` and `T` and invariant in `'b`, `'c`,\nand `U`.\n\nuse std::cell::UnsafeCell;\nstruct Variance<'a, 'b, 'c, T, U: 'a> {\n    x: &'a U,               // This makes `Variance` covariant in 'a, and would\n                            // make it covariant in U, but U is used later\n    y: *const T,            // Covariant in T\n    z: UnsafeCell<&'b f64>, // Invariant in 'b\n    w: *mut U,              // Invariant in U, makes the whole struct invariant\n\n    f: fn(&'c ()) -> &'c () // Both co- and contravariant, makes 'c invariant\n                            // in the struct.\n}\n\nWhen used outside of an `struct`, `enum`, or `union`, the variance for parameters is checked at each location separately.\n\n# use std::cell::UnsafeCell;\nfn generic_tuple<'short, 'long: 'short>(\n    // 'long is used inside of a tuple in both a co- and invariant position.\n    x: (&'long u32, UnsafeCell<&'long u32>),\n) {\n    // As the variance at these positions is computed separately,\n    // we can freely shrink 'long in the covariant position.\n    let _: (&'short u32, UnsafeCell<&'long u32>) = x;\n}\n\nfn takes_fn_ptr<'short, 'middle: 'short>(\n    // 'middle is used in both a co- and contravariant position.\n    f: fn(&'middle ()) -> &'middle (),\n) {\n    // As the variance at these positions is computed separately,\n    // we can freely shrink 'middle in the covariant position\n    // and extend it in the contravariant position.\n    let _: fn(&'static ()) -> &'short () = f;\n}\n\n[function pointers]: types/function-pointer.md\n[Higher-ranked]: ../nomicon/hrtb.html\n[trait objects]: types/trait-object.md",
      "parent_id": null,
      "paragraphs": {
        "subtyping.variance.intro": "Variance is a property that generic types have with respect to their arguments.\nA generic type's *variance* in a parameter is how the subtyping of the\nparameter affects the subtyping of the type.",
        "subtyping.variance.covariant": "* `F<T>` is *covariant* over `T` if `T` being a subtype of `U` implies that\n  `F<T>` is a subtype of `F<U>` (subtyping \"passes through\")",
        "subtyping.variance.contravariant": "* `F<T>` is *contravariant* over `T` if `T` being a subtype of `U` implies that\n  `F<U>` is a subtype of `F<T>`",
        "subtyping.variance.invariant": "* `F<T>` is *invariant* over `T` otherwise (no subtyping relation can be\n  derived)",
        "subtyping.variance.builtin-types": "Variance of types is automatically determined as follows\n\n| Type                          | Variance in `'a`  | Variance in `T`   |\n|-------------------------------|-------------------|-------------------|\n| `&'a T`                       | covariant         | covariant         |\n| `&'a mut T`                   | covariant         | invariant         |\n| `*const T`                    |                   | covariant         |\n| `*mut T`                      |                   | invariant         |\n| `[T]` and `[T; n]`            |                   | covariant         |\n| `fn() -> T`                   |                   | covariant         |\n| `fn(T) -> ()`                 |                   | contravariant     |\n| `std::cell::UnsafeCell<T>`    |                   | invariant         |\n| `std::marker::PhantomData<T>` |                   | covariant         |\n| `dyn Trait<T> + 'a`           | covariant         | invariant         |",
        "subtyping.variance.user-composite-types": "The variance of other `struct`, `enum`, and `union` types is decided by\nlooking at the variance of the types of their fields. If the parameter is used\nin positions with different variances then the parameter is invariant. For\nexample the following struct is covariant in `'a` and `T` and invariant in `'b`, `'c`,\nand `U`.\n\nuse std::cell::UnsafeCell;\nstruct Variance<'a, 'b, 'c, T, U: 'a> {\n    x: &'a U,               // This makes `Variance` covariant in 'a, and would\n                            // make it covariant in U, but U is used later\n    y: *const T,            // Covariant in T\n    z: UnsafeCell<&'b f64>, // Invariant in 'b\n    w: *mut U,              // Invariant in U, makes the whole struct invariant\n\n    f: fn(&'c ()) -> &'c () // Both co- and contravariant, makes 'c invariant\n                            // in the struct.\n}",
        "subtyping.variance.builtin-composite-types": "When used outside of an `struct`, `enum`, or `union`, the variance for parameters is checked at each location separately.\n\n# use std::cell::UnsafeCell;\nfn generic_tuple<'short, 'long: 'short>(\n    // 'long is used inside of a tuple in both a co- and invariant position.\n    x: (&'long u32, UnsafeCell<&'long u32>),\n) {\n    // As the variance at these positions is computed separately,\n    // we can freely shrink 'long in the covariant position.\n    let _: (&'short u32, UnsafeCell<&'long u32>) = x;\n}\n\nfn takes_fn_ptr<'short, 'middle: 'short>(\n    // 'middle is used in both a co- and contravariant position.\n    f: fn(&'middle ()) -> &'middle (),\n) {\n    // As the variance at these positions is computed separately,\n    // we can freely shrink 'middle in the covariant position\n    // and extend it in the contravariant position.\n    let _: fn(&'static ()) -> &'short () = f;\n}\n\n[function pointers]: types/function-pointer.md\n[Higher-ranked]: ../nomicon/hrtb.html\n[trait objects]: types/trait-object.md"
      }
    },
    {
      "id": "bound",
      "title": "Trait and lifetime bounds",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "bound.syntax",
      "title": "Trait and lifetime bounds",
      "level": 1,
      "content": ",miscellaneous\nTypeParamBounds -> TypeParamBound ( `+` TypeParamBound )* `+`?\n\nTypeParamBound -> Lifetime | TraitBound | UseBound\n\nTraitBound ->\n      ( `?` | ForLifetimes )? TypePath\n    | `(` ( `?` | ForLifetimes )? TypePath `)`\n\nLifetimeBounds -> ( Lifetime `+` )* Lifetime?\n\nLifetime ->\n      LIFETIME_OR_LABEL\n    | `'static`\n    | `'_`\n\nUseBound -> `use` UseBoundGenericArgs\n\nUseBoundGenericArgs ->\n      `<` `>`\n    | `<` ( UseBoundGenericArg `,`)* UseBoundGenericArg `,`? `>`\n\nUseBoundGenericArg ->\n      Lifetime\n    | IDENTIFIER\n    | `Self`",
      "parent_id": null,
      "paragraphs": {
        "bound.syntax": ",miscellaneous\nTypeParamBounds -> TypeParamBound ( `+` TypeParamBound )* `+`?\n\nTypeParamBound -> Lifetime | TraitBound | UseBound\n\nTraitBound ->\n      ( `?` | ForLifetimes )? TypePath\n    | `(` ( `?` | ForLifetimes )? TypePath `)`\n\nLifetimeBounds -> ( Lifetime `+` )* Lifetime?\n\nLifetime ->\n      LIFETIME_OR_LABEL\n    | `'static`\n    | `'_`\n\nUseBound -> `use` UseBoundGenericArgs\n\nUseBoundGenericArgs ->\n      `<` `>`\n    | `<` ( UseBoundGenericArg `,`)* UseBoundGenericArg `,`? `>`\n\nUseBoundGenericArg ->\n      Lifetime\n    | IDENTIFIER\n    | `Self`"
      }
    },
    {
      "id": "bound.intro",
      "title": "Trait and lifetime bounds",
      "level": 1,
      "content": "[Trait] and lifetime bounds provide a way for generic items to\nrestrict which types and lifetimes are used as their parameters. Bounds can be\nprovided on any type in a [where clause]. There are also shorter forms for\ncertain common cases:\n\n* Bounds written after declaring a generic parameter:\n  `fn f<A: Copy>() {}` is the same as `fn f<A>() where A: Copy {}`.\n* In trait declarations as [supertraits]: `trait Circle : Shape {}` is\n  equivalent to `trait Circle where Self : Shape {}`.\n* In trait declarations as bounds on [associated types]:\n  `trait A { type B: Copy; }` is equivalent to\n  `trait A where Self::B: Copy { type B; }`.",
      "parent_id": null,
      "paragraphs": {
        "bound.intro": "[Trait] and lifetime bounds provide a way for generic items to\nrestrict which types and lifetimes are used as their parameters. Bounds can be\nprovided on any type in a [where clause]. There are also shorter forms for\ncertain common cases:\n\n* Bounds written after declaring a generic parameter:\n  `fn f<A: Copy>() {}` is the same as `fn f<A>() where A: Copy {}`.\n* In trait declarations as [supertraits]: `trait Circle : Shape {}` is\n  equivalent to `trait Circle where Self : Shape {}`.\n* In trait declarations as bounds on [associated types]:\n  `trait A { type B: Copy; }` is equivalent to\n  `trait A where Self::B: Copy { type B; }`."
      }
    },
    {
      "id": "bound.satisfaction",
      "title": "Trait and lifetime bounds",
      "level": 1,
      "content": "Bounds on an item must be satisfied when using the item. When type checking and\nborrow checking a generic item, the bounds can be used to determine that a\ntrait is implemented for a type. For example, given `Ty: Trait`\n\n* In the body of a generic function, methods from `Trait` can be called on `Ty`\n  values. Likewise associated constants on the `Trait` can be used.\n* Associated types from `Trait` can be used.\n* Generic functions and types with a `T: Trait` bounds can be used with `Ty`\n  being used for `T`.\n\n# type Surface = i32;\ntrait Shape {\n    fn draw(&self, surface: Surface);\n    fn name() -> &'static str;\n}\n\nfn draw_twice<T: Shape>(surface: Surface, sh: T) {\n    sh.draw(surface);           // Can call method because T: Shape\n    sh.draw(surface);\n}\n\nfn copy_and_draw_twice<T: Copy>(surface: Surface, sh: T) where T: Shape {\n    let shape_copy = sh;        // doesn't move sh because T: Copy\n    draw_twice(surface, sh);    // Can use generic function because T: Shape\n}\n\nstruct Figure<S: Shape>(S, S);\n\nfn name_figure<U: Shape>(\n    figure: Figure<U>,          // Type Figure<U> is well-formed because U: Shape\n) {\n    println!(\n        \"Figure of two {}\",\n        U::name(),              // Can use associated function\n    );\n}",
      "parent_id": null,
      "paragraphs": {
        "bound.satisfaction": "Bounds on an item must be satisfied when using the item. When type checking and\nborrow checking a generic item, the bounds can be used to determine that a\ntrait is implemented for a type. For example, given `Ty: Trait`\n\n* In the body of a generic function, methods from `Trait` can be called on `Ty`\n  values. Likewise associated constants on the `Trait` can be used.\n* Associated types from `Trait` can be used.\n* Generic functions and types with a `T: Trait` bounds can be used with `Ty`\n  being used for `T`.\n\n# type Surface = i32;\ntrait Shape {\n    fn draw(&self, surface: Surface);\n    fn name() -> &'static str;\n}\n\nfn draw_twice<T: Shape>(surface: Surface, sh: T) {\n    sh.draw(surface);           // Can call method because T: Shape\n    sh.draw(surface);\n}\n\nfn copy_and_draw_twice<T: Copy>(surface: Surface, sh: T) where T: Shape {\n    let shape_copy = sh;        // doesn't move sh because T: Copy\n    draw_twice(surface, sh);    // Can use generic function because T: Shape\n}\n\nstruct Figure<S: Shape>(S, S);\n\nfn name_figure<U: Shape>(\n    figure: Figure<U>,          // Type Figure<U> is well-formed because U: Shape\n) {\n    println!(\n        \"Figure of two {}\",\n        U::name(),              // Can use associated function\n    );\n}"
      }
    },
    {
      "id": "bound.trivial",
      "title": "type Surface = i32;",
      "level": 1,
      "content": "Bounds that don't use the item's parameters or [higher-ranked lifetimes] are checked when the item is defined.\nIt is an error for such a bound to be false.",
      "parent_id": null,
      "paragraphs": {
        "bound.trivial": "Bounds that don't use the item's parameters or [higher-ranked lifetimes] are checked when the item is defined.\nIt is an error for such a bound to be false."
      }
    },
    {
      "id": "bound.special",
      "title": "type Surface = i32;",
      "level": 1,
      "content": "[`Copy`], [`Clone`], and [`Sized`] bounds are also checked for certain generic types when using the item, even if the use does not provide a concrete type.\nIt is an error to have `Copy` or `Clone` as a bound on a mutable reference, [trait object], or [slice].\nIt is an error to have `Sized` as a bound on a trait object or slice.\n\n,compile_fail\nstruct A<'a, T>\nwhere\n    i32: Default,           // Allowed, but not useful\n    i32: Iterator,          // Error: `i32` is not an iterator\n    &'a mut T: Copy,        // (at use) Error: the trait bound is not satisfied\n    [T]: Sized,             // (at use) Error: size cannot be known at compilation\n{\n    f: &'a T,\n}\nstruct UsesA<'a, T>(A<'a, T>);",
      "parent_id": null,
      "paragraphs": {
        "bound.special": "[`Copy`], [`Clone`], and [`Sized`] bounds are also checked for certain generic types when using the item, even if the use does not provide a concrete type.\nIt is an error to have `Copy` or `Clone` as a bound on a mutable reference, [trait object], or [slice].\nIt is an error to have `Sized` as a bound on a trait object or slice.\n\n,compile_fail\nstruct A<'a, T>\nwhere\n    i32: Default,           // Allowed, but not useful\n    i32: Iterator,          // Error: `i32` is not an iterator\n    &'a mut T: Copy,        // (at use) Error: the trait bound is not satisfied\n    [T]: Sized,             // (at use) Error: size cannot be known at compilation\n{\n    f: &'a T,\n}\nstruct UsesA<'a, T>(A<'a, T>);"
      }
    },
    {
      "id": "bound.trait-object",
      "title": "type Surface = i32;",
      "level": 1,
      "content": "Trait and lifetime bounds are also used to name [trait objects].",
      "parent_id": null,
      "paragraphs": {
        "bound.trait-object": "Trait and lifetime bounds are also used to name [trait objects]."
      }
    },
    {
      "id": "bound.sized",
      "title": "`?Sized`",
      "level": 1,
      "content": "`?` is only used to relax the implicit [`Sized`] trait bound for [type parameters] or [associated types].\n`?Sized` may not be used as a bound for other types.",
      "parent_id": null,
      "paragraphs": {
        "bound.sized": "`?` is only used to relax the implicit [`Sized`] trait bound for [type parameters] or [associated types].\n`?Sized` may not be used as a bound for other types."
      }
    },
    {
      "id": "bound.lifetime",
      "title": "Lifetime bounds",
      "level": 2,
      "content": "Lifetime bounds can be applied to types or to other lifetimes.\n\nThe bound `'a: 'b` is usually read as `'a` *outlives* `'b`.\n`'a: 'b` means that `'a` lasts at least as long as `'b`, so a reference `&'a ()` is valid whenever `&'b ()` is valid.\n\nfn f<'a, 'b>(x: &'a i32, mut y: &'b i32) where 'a: 'b {\n    y = x;                      // &'a i32 is a subtype of &'b i32 because 'a: 'b\n    let r: &'b &'a i32 = &&0;   // &'b &'a i32 is well formed because 'a: 'b\n}\n\n`T: 'a` means that all lifetime parameters of `T` outlive `'a`.\nFor example, if `'a` is an unconstrained lifetime parameter, then `i32: 'static` and `&'static str: 'a` are satisfied, but `Vec<&'a ()>: 'static` is not.",
      "parent_id": null,
      "paragraphs": {
        "bound.lifetime.intro": "Lifetime bounds can be applied to types or to other lifetimes.",
        "bound.lifetime.outlive-lifetime": "The bound `'a: 'b` is usually read as `'a` *outlives* `'b`.\n`'a: 'b` means that `'a` lasts at least as long as `'b`, so a reference `&'a ()` is valid whenever `&'b ()` is valid.\n\nfn f<'a, 'b>(x: &'a i32, mut y: &'b i32) where 'a: 'b {\n    y = x;                      // &'a i32 is a subtype of &'b i32 because 'a: 'b\n    let r: &'b &'a i32 = &&0;   // &'b &'a i32 is well formed because 'a: 'b\n}",
        "bound.lifetime.outlive-type": "`T: 'a` means that all lifetime parameters of `T` outlive `'a`.\nFor example, if `'a` is an unconstrained lifetime parameter, then `i32: 'static` and `&'static str: 'a` are satisfied, but `Vec<&'a ()>: 'static` is not."
      }
    },
    {
      "id": "bound.higher-ranked",
      "title": "Higher-ranked trait bounds",
      "level": 2,
      "content": ",miscellaneous\nForLifetimes -> `for` GenericParams\n\nTrait bounds may be *higher ranked* over lifetimes. These bounds specify a bound\nthat is true *for all* lifetimes. For example, a bound such as `for<'a> &'a T:\nPartialEq<i32>` would require an implementation like\n\n# struct T;\nimpl<'a> PartialEq<i32> for &'a T {\n    // ...\n#    fn eq(&self, other: &i32) -> bool {true}\n}\n\nand could then be used to compare a `&'a T` with any lifetime to an `i32`.\n\nOnly a higher-ranked bound can be used here, because the lifetime of the reference is shorter than any possible lifetime parameter on the function:\n\nfn call_on_ref_zero<F>(f: F) where for<'a> F: Fn(&'a i32) {\n    let zero = 0;\n    f(&zero);\n}\n\nHigher-ranked lifetimes may also be specified just before the trait: the only\ndifference is the scope of the lifetime parameter, which extends only to the\nend of the following trait instead of the whole bound. This function is\nequivalent to the last one.\n\nfn call_on_ref_zero<F>(f: F) where F: for<'a> Fn(&'a i32) {\n    let zero = 0;\n    f(&zero);\n}",
      "parent_id": null,
      "paragraphs": {
        "bound.higher-ranked.syntax": ",miscellaneous\nForLifetimes -> `for` GenericParams",
        "bound.higher-ranked.intro": "Trait bounds may be *higher ranked* over lifetimes. These bounds specify a bound\nthat is true *for all* lifetimes. For example, a bound such as `for<'a> &'a T:\nPartialEq<i32>` would require an implementation like\n\n# struct T;\nimpl<'a> PartialEq<i32> for &'a T {\n    // ...\n#    fn eq(&self, other: &i32) -> bool {true}\n}\n\nand could then be used to compare a `&'a T` with any lifetime to an `i32`.\n\nOnly a higher-ranked bound can be used here, because the lifetime of the reference is shorter than any possible lifetime parameter on the function:\n\nfn call_on_ref_zero<F>(f: F) where for<'a> F: Fn(&'a i32) {\n    let zero = 0;\n    f(&zero);\n}",
        "bound.higher-ranked.trait": "Higher-ranked lifetimes may also be specified just before the trait: the only\ndifference is the scope of the lifetime parameter, which extends only to the\nend of the following trait instead of the whole bound. This function is\nequivalent to the last one.\n\nfn call_on_ref_zero<F>(f: F) where F: for<'a> Fn(&'a i32) {\n    let zero = 0;\n    f(&zero);\n}"
      }
    },
    {
      "id": "bound.implied",
      "title": "Implied bounds",
      "level": 1,
      "content": "Lifetime bounds required for types to be well-formed are sometimes inferred.\n\nfn requires_t_outlives_a<'a, T>(x: &'a T) {}\n\nThe type parameter `T` is required to outlive `'a` for the type `&'a T` to be well-formed.\nThis is inferred because the function signature contains the type `&'a T` which is\nonly valid if `T: 'a` holds.\n\nImplied bounds are added for all parameters and outputs of functions. Inside of `requires_t_outlives_a`\nyou can assume `T: 'a` to hold even if you don't explicitly specify this:\n\nfn requires_t_outlives_a_not_implied<'a, T: 'a>() {}\n\nfn requires_t_outlives_a<'a, T>(x: &'a T) {\n    // This compiles, because `T: 'a` is implied by\n    // the reference type `&'a T`.\n    requires_t_outlives_a_not_implied::<'a, T>();\n}\n\n,compile_fail,E0309\n# fn requires_t_outlives_a_not_implied<'a, T: 'a>() {}\nfn not_implied<'a, T>() {\n    // This errors, because `T: 'a` is not implied by\n    // the function signature.\n    requires_t_outlives_a_not_implied::<'a, T>();\n}\n\nOnly lifetime bounds are implied, trait bounds still have to be explicitly added.\nThe following example therefore causes an error:\n\n,compile_fail,E0277\nuse std::fmt::Debug;\nstruct IsDebug<T: Debug>(T);\n// error[E0277]: `T` doesn't implement `Debug`\nfn doesnt_specify_t_debug<T>(x: IsDebug<T>) {}\n\nLifetime bounds are also inferred for type definitions and impl blocks for any type:\n\nstruct Struct<'a, T> {\n    // This requires `T: 'a` to be well-formed\n    // which is inferred by the compiler.\n    field: &'a T,\n}\n\nenum Enum<'a, T> {\n    // This requires `T: 'a` to be well-formed,\n    // which is inferred by the compiler.\n    //\n    // Note that `T: 'a` is required even when only\n    // using `Enum::OtherVariant`.\n    SomeVariant(&'a T),\n    OtherVariant,\n}\n\ntrait Trait<'a, T: 'a> {}\n\n// This would error because `T: 'a` is not implied by any type\n// in the impl header.\n//     impl<'a, T> Trait<'a, T> for () {}\n\n// This compiles as `T: 'a` is implied by the self type `&'a T`.\nimpl<'a, T> Trait<'a, T> for &'a T {}",
      "parent_id": null,
      "paragraphs": {
        "bound.implied.intro": "Lifetime bounds required for types to be well-formed are sometimes inferred.\n\nfn requires_t_outlives_a<'a, T>(x: &'a T) {}\n\nThe type parameter `T` is required to outlive `'a` for the type `&'a T` to be well-formed.\nThis is inferred because the function signature contains the type `&'a T` which is\nonly valid if `T: 'a` holds.",
        "bound.implied.context": "Implied bounds are added for all parameters and outputs of functions. Inside of `requires_t_outlives_a`\nyou can assume `T: 'a` to hold even if you don't explicitly specify this:\n\nfn requires_t_outlives_a_not_implied<'a, T: 'a>() {}\n\nfn requires_t_outlives_a<'a, T>(x: &'a T) {\n    // This compiles, because `T: 'a` is implied by\n    // the reference type `&'a T`.\n    requires_t_outlives_a_not_implied::<'a, T>();\n}\n\n,compile_fail,E0309\n# fn requires_t_outlives_a_not_implied<'a, T: 'a>() {}\nfn not_implied<'a, T>() {\n    // This errors, because `T: 'a` is not implied by\n    // the function signature.\n    requires_t_outlives_a_not_implied::<'a, T>();\n}",
        "bound.implied.trait": "Only lifetime bounds are implied, trait bounds still have to be explicitly added.\nThe following example therefore causes an error:\n\n,compile_fail,E0277\nuse std::fmt::Debug;\nstruct IsDebug<T: Debug>(T);\n// error[E0277]: `T` doesn't implement `Debug`\nfn doesnt_specify_t_debug<T>(x: IsDebug<T>) {}",
        "bound.implied.def": "Lifetime bounds are also inferred for type definitions and impl blocks for any type:\n\nstruct Struct<'a, T> {\n    // This requires `T: 'a` to be well-formed\n    // which is inferred by the compiler.\n    field: &'a T,\n}\n\nenum Enum<'a, T> {\n    // This requires `T: 'a` to be well-formed,\n    // which is inferred by the compiler.\n    //\n    // Note that `T: 'a` is required even when only\n    // using `Enum::OtherVariant`.\n    SomeVariant(&'a T),\n    OtherVariant,\n}\n\ntrait Trait<'a, T: 'a> {}\n\n// This would error because `T: 'a` is not implied by any type\n// in the impl header.\n//     impl<'a, T> Trait<'a, T> for () {}\n\n// This compiles as `T: 'a` is implied by the self type `&'a T`.\nimpl<'a, T> Trait<'a, T> for &'a T {}"
      }
    },
    {
      "id": "bound.use",
      "title": "Use bounds",
      "level": 1,
      "content": "Certain bounds lists may include a `use<..>` bound to control which generic parameters are captured by the `impl Trait` [abstract return type].  See [precise capturing] for more details.\n\n[abstract return type]: types/impl-trait.md#abstract-return-types\n[arrays]: types/array.md\n[associated types]: items/associated-items.md#associated-types\n[hrtb-scopes]: names/scopes.md#higher-ranked-trait-bound-scopes\n[supertraits]: items/traits.md#supertraits\n[generic]: items/generics.md\n\n[precise capturing]: types/impl-trait.md#precise-capturing\n[slice]: types/slice.md\n[Trait]: items/traits.md#trait-bounds\n[trait object]: types/trait-object.md\n[trait objects]: types/trait-object.md\n[type parameters]: types/parameters.md\n[where clause]: items/generics.md#where-clauses",
      "parent_id": null,
      "paragraphs": {
        "bound.use": "Certain bounds lists may include a `use<..>` bound to control which generic parameters are captured by the `impl Trait` [abstract return type].  See [precise capturing] for more details.\n\n[abstract return type]: types/impl-trait.md#abstract-return-types\n[arrays]: types/array.md\n[associated types]: items/associated-items.md#associated-types\n[hrtb-scopes]: names/scopes.md#higher-ranked-trait-bound-scopes\n[supertraits]: items/traits.md#supertraits\n[generic]: items/generics.md\n\n[precise capturing]: types/impl-trait.md#precise-capturing\n[slice]: types/slice.md\n[Trait]: items/traits.md#trait-bounds\n[trait object]: types/trait-object.md\n[trait objects]: types/trait-object.md\n[type parameters]: types/parameters.md\n[where clause]: items/generics.md#where-clauses"
      }
    },
    {
      "id": "coerce",
      "title": "Type coercions",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "coerce.intro",
      "title": "Type coercions",
      "level": 1,
      "content": "**Type coercions** are implicit operations that change the type of a value.\nThey happen automatically at specific locations and are highly restricted in\nwhat types actually coerce.",
      "parent_id": null,
      "paragraphs": {
        "coerce.intro": "**Type coercions** are implicit operations that change the type of a value.\nThey happen automatically at specific locations and are highly restricted in\nwhat types actually coerce."
      }
    },
    {
      "id": "coerce.as",
      "title": "Type coercions",
      "level": 1,
      "content": "Any conversions allowed by coercion can also be explicitly performed by the\n[type cast operator], `as`.\n\nCoercions are originally defined in [RFC 401] and expanded upon in [RFC 1558].",
      "parent_id": null,
      "paragraphs": {
        "coerce.as": "Any conversions allowed by coercion can also be explicitly performed by the\n[type cast operator], `as`.\n\nCoercions are originally defined in [RFC 401] and expanded upon in [RFC 1558]."
      }
    },
    {
      "id": "coerce.site",
      "title": "Coercion sites",
      "level": 1,
      "content": "A coercion can only occur at certain coercion sites in a program; these are\ntypically places where the desired type is explicit or can be derived by\npropagation from explicit types (without type inference). Possible coercion\nsites are:\n\n* `let` statements where an explicit type is given.\n\n   For example, `&mut 42` is coerced to have type `&i8` in the following:\n\n   ```rust\n   let _: &i8 = &mut 42;\n   ```\n\n* `static` and `const` item declarations (similar to `let` statements).\n\n* Arguments for function calls\n\n  The value being coerced is the actual parameter, and it is coerced to\n  the type of the formal parameter.\n\n  For example, `&mut 42` is coerced to have type `&i8` in the following:\n\n  ```rust\n  fn bar(_: &i8) { }\n\n  fn main() {\n      bar(&mut 42);\n  }\n  ```\n\n  For method calls, the receiver (`self` parameter) type is coerced\n  differently, see the documentation on [method-call expressions] for details.\n\n* Instantiations of struct, union, or enum variant fields\n\n  For example, `&mut 42` is coerced to have type `&i8` in the following:\n\n  ```rust\n  struct Foo<'a> { x: &'a i8 }\n\n  fn main() {\n      Foo { x: &mut 42 };\n  }\n  ```\n\n* Function results&mdash;either the final line of a block if it is not\n  semicolon-terminated or any expression in a `return` statement\n\n  For example, `x` is coerced to have type `&dyn Display` in the following:\n\n  ```rust\n  use std::fmt::Display;\n  fn foo(x: &u32) -> &dyn Display {\n      x\n  }\n  ```\n\nIf the expression in one of these coercion sites is a coercion-propagating\nexpression, then the relevant sub-expressions in that expression are also\ncoercion sites. Propagation recurses from these new coercion sites.\nPropagating expressions and their relevant sub-expressions are:\n\n* Array literals, where the array has type `[U; n]`. Each sub-expression in\nthe array literal is a coercion site for coercion to type `U`.\n\n* Array literals with repeating syntax, where the array has type `[U; n]`. The\nrepeated sub-expression is a coercion site for coercion to type `U`.\n\n* Tuples, where a tuple is a coercion site to type `(U_0, U_1, ..., U_n)`.\nEach sub-expression is a coercion site to the respective type, e.g. the\nzeroth sub-expression is a coercion site to type `U_0`.\n\n* Parenthesized sub-expressions (`(e)`): if the expression has type `U`, then\nthe sub-expression is a coercion site to `U`.\n\n* Blocks: if a block has type `U`, then the last expression in the block (if\nit is not semicolon-terminated) is a coercion site to `U`. This includes\nblocks which are part of control flow statements, such as `if`/`else`, if\nthe block has a known type.",
      "parent_id": null,
      "paragraphs": {
        "coerce.site.intro": "A coercion can only occur at certain coercion sites in a program; these are\ntypically places where the desired type is explicit or can be derived by\npropagation from explicit types (without type inference). Possible coercion\nsites are:",
        "coerce.site.let": "* `let` statements where an explicit type is given.\n\n   For example, `&mut 42` is coerced to have type `&i8` in the following:\n\n   ```rust\n   let _: &i8 = &mut 42;\n   ```",
        "coerce.site.value": "* `static` and `const` item declarations (similar to `let` statements).",
        "coerce.site.argument": "* Arguments for function calls\n\n  The value being coerced is the actual parameter, and it is coerced to\n  the type of the formal parameter.\n\n  For example, `&mut 42` is coerced to have type `&i8` in the following:\n\n  ```rust\n  fn bar(_: &i8) { }\n\n  fn main() {\n      bar(&mut 42);\n  }\n  ```\n\n  For method calls, the receiver (`self` parameter) type is coerced\n  differently, see the documentation on [method-call expressions] for details.",
        "coerce.site.constructor": "* Instantiations of struct, union, or enum variant fields\n\n  For example, `&mut 42` is coerced to have type `&i8` in the following:\n\n  ```rust\n  struct Foo<'a> { x: &'a i8 }\n\n  fn main() {\n      Foo { x: &mut 42 };\n  }\n  ```",
        "coerce.site.return": "* Function results&mdash;either the final line of a block if it is not\n  semicolon-terminated or any expression in a `return` statement\n\n  For example, `x` is coerced to have type `&dyn Display` in the following:\n\n  ```rust\n  use std::fmt::Display;\n  fn foo(x: &u32) -> &dyn Display {\n      x\n  }\n  ```",
        "coerce.site.subexpr": "If the expression in one of these coercion sites is a coercion-propagating\nexpression, then the relevant sub-expressions in that expression are also\ncoercion sites. Propagation recurses from these new coercion sites.\nPropagating expressions and their relevant sub-expressions are:",
        "coerce.site.array": "* Array literals, where the array has type `[U; n]`. Each sub-expression in\nthe array literal is a coercion site for coercion to type `U`.",
        "coerce.site.repeat": "* Array literals with repeating syntax, where the array has type `[U; n]`. The\nrepeated sub-expression is a coercion site for coercion to type `U`.",
        "coerce.site.tuple": "* Tuples, where a tuple is a coercion site to type `(U_0, U_1, ..., U_n)`.\nEach sub-expression is a coercion site to the respective type, e.g. the\nzeroth sub-expression is a coercion site to type `U_0`.",
        "coerce.site.parenthesis": "* Parenthesized sub-expressions (`(e)`): if the expression has type `U`, then\nthe sub-expression is a coercion site to `U`.",
        "coerce.site.block": "* Blocks: if a block has type `U`, then the last expression in the block (if\nit is not semicolon-terminated) is a coercion site to `U`. This includes\nblocks which are part of control flow statements, such as `if`/`else`, if\nthe block has a known type."
      }
    },
    {
      "id": "coerce.types",
      "title": "Coercion types",
      "level": 2,
      "content": "Coercion is allowed between the following types:\n\n* `T` to `U` if `T` is a [subtype] of `U` (*reflexive case*)\n\n* `T_1` to `T_3` where `T_1` coerces to `T_2` and `T_2` coerces to `T_3`\n(*transitive case*)\n\n    Note that this is not fully supported yet.\n\n* `&mut T` to `&T`\n\n* `*mut T` to `*const T`\n\n* `&T` to `*const T`\n\n* `&mut T` to `*mut T`\n\n* `&T` or `&mut T` to `&U` if `T` implements `Deref<Target = U>`. For example:\n\n  ```rust\n  use std::ops::Deref;\n\n  struct CharContainer {\n      value: char,\n  }\n\n  impl Deref for CharContainer {\n      type Target = char;\n\n      fn deref<'a>(&'a self) -> &'a char {\n          &self.value\n      }\n  }\n\n  fn foo(arg: &char) {}\n\n  fn main() {\n      let x = &mut CharContainer { value: 'y' };\n      foo(x); //&mut CharContainer is coerced to &char.\n  }\n  ```\n\n* `&mut T` to `&mut U` if `T` implements `DerefMut<Target = U>`.\n\n* TyCtor(`T`) to TyCtor(`U`), where TyCtor(`T`) is one of\n    - `&T`\n    - `&mut T`\n    - `*const T`\n    - `*mut T`\n    - `Box<T>`\n\n    and where `U` can be obtained from `T` by unsized coercion.\n\n    <!--In the future, coerce_inner will be recursively extended to tuples and\n    structs. In addition, coercions from subtraits to supertraits will be\n    added. See [RFC 401] for more details.-->\n\n* Function item types to `fn` pointers\n\n* Non capturing closures to `fn` pointers\n\n* `!` to any `T`",
      "parent_id": null,
      "paragraphs": {
        "coerce.types.intro": "Coercion is allowed between the following types:",
        "coerce.types.reflexive": "* `T` to `U` if `T` is a [subtype] of `U` (*reflexive case*)",
        "coerce.types.transitive": "* `T_1` to `T_3` where `T_1` coerces to `T_2` and `T_2` coerces to `T_3`\n(*transitive case*)\n\n    Note that this is not fully supported yet.",
        "coerce.types.mut-reborrow": "* `&mut T` to `&T`",
        "coerce.types.mut-pointer": "* `*mut T` to `*const T`",
        "coerce.types.ref-to-pointer": "* `&T` to `*const T`",
        "coerce.types.mut-to-pointer": "* `&mut T` to `*mut T`",
        "coerce.types.deref": "* `&T` or `&mut T` to `&U` if `T` implements `Deref<Target = U>`. For example:\n\n  ```rust\n  use std::ops::Deref;\n\n  struct CharContainer {\n      value: char,\n  }\n\n  impl Deref for CharContainer {\n      type Target = char;\n\n      fn deref<'a>(&'a self) -> &'a char {\n          &self.value\n      }\n  }\n\n  fn foo(arg: &char) {}\n\n  fn main() {\n      let x = &mut CharContainer { value: 'y' };\n      foo(x); //&mut CharContainer is coerced to &char.\n  }\n  ```",
        "coerce.types.deref-mut": "* `&mut T` to `&mut U` if `T` implements `DerefMut<Target = U>`.",
        "coerce.types.unsize": "* TyCtor(`T`) to TyCtor(`U`), where TyCtor(`T`) is one of\n    - `&T`\n    - `&mut T`\n    - `*const T`\n    - `*mut T`\n    - `Box<T>`\n\n    and where `U` can be obtained from `T` by unsized coercion.\n\n    <!--In the future, coerce_inner will be recursively extended to tuples and\n    structs. In addition, coercions from subtraits to supertraits will be\n    added. See [RFC 401] for more details.-->",
        "coerce.types.fn": "* Function item types to `fn` pointers",
        "coerce.types.closure": "* Non capturing closures to `fn` pointers",
        "coerce.types.never": "* `!` to any `T`"
      }
    },
    {
      "id": "coerce.unsize",
      "title": "Unsized coercions",
      "level": 2,
      "content": "The following coercions are called `unsized coercions`, since they\nrelate to converting types to unsized types, and are permitted in a few\ncases where other coercions are not, as described above. They can still happen\nanywhere else a coercion can occur.\n\nTwo traits, [`Unsize`] and [`CoerceUnsized`], are used\nto assist in this process and expose it for library use. The following\ncoercions are built-ins and, if `T` can be coerced to `U` with one of them, then\nan implementation of `Unsize<U>` for `T` will be provided:\n\n* `[T; n]` to `[T]`.\n\n* `T` to `dyn U`, when `T` implements `U + Sized`, and `U` is [dyn compatible].\n\n* `dyn T` to `dyn U`, when `U` is one of `T`'s [supertraits].\n    * This allows dropping auto traits, i.e. `dyn T + Auto` to `dyn U` is allowed.\n    * This allows adding auto traits if the principal trait has the auto trait as a super trait, i.e. given `trait T: U + Send {}`, `dyn T` to `dyn T + Send` or to `dyn U + Send` coercions are allowed.\n\n* `Foo<..., T, ...>` to `Foo<..., U, ...>`, when:\n    * `Foo` is a struct.\n    * `T` implements `Unsize<U>`.\n    * The last field of `Foo` has a type involving `T`.\n    * If that field has type `Bar<T>`, then `Bar<T>` implements `Unsize<Bar<U>>`.\n    * T is not part of the type of any other fields.\n\nAdditionally, a type `Foo<T>` can implement `CoerceUnsized<Foo<U>>` when `T`\nimplements `Unsize<U>` or `CoerceUnsized<Foo<U>>`. This allows it to provide an\nunsized coercion to `Foo<U>`.\n\n> [!NOTE]\n> While the definition of the unsized coercions and their implementation has been stabilized, the traits themselves are not yet stable and therefore can't be used directly in stable Rust.",
      "parent_id": null,
      "paragraphs": {
        "coerce.unsize.intro": "The following coercions are called `unsized coercions`, since they\nrelate to converting types to unsized types, and are permitted in a few\ncases where other coercions are not, as described above. They can still happen\nanywhere else a coercion can occur.",
        "coerce.unsize.trait": "Two traits, [`Unsize`] and [`CoerceUnsized`], are used\nto assist in this process and expose it for library use. The following\ncoercions are built-ins and, if `T` can be coerced to `U` with one of them, then\nan implementation of `Unsize<U>` for `T` will be provided:",
        "coerce.unsize.slice": "* `[T; n]` to `[T]`.",
        "coerce.unsize.trait-object": "* `T` to `dyn U`, when `T` implements `U + Sized`, and `U` is [dyn compatible].",
        "coerce.unsize.trait-upcast": "* `dyn T` to `dyn U`, when `U` is one of `T`'s [supertraits].\n    * This allows dropping auto traits, i.e. `dyn T + Auto` to `dyn U` is allowed.\n    * This allows adding auto traits if the principal trait has the auto trait as a super trait, i.e. given `trait T: U + Send {}`, `dyn T` to `dyn T + Send` or to `dyn U + Send` coercions are allowed.",
        "coerce.unsized.composite": "* `Foo<..., T, ...>` to `Foo<..., U, ...>`, when:\n    * `Foo` is a struct.\n    * `T` implements `Unsize<U>`.\n    * The last field of `Foo` has a type involving `T`.\n    * If that field has type `Bar<T>`, then `Bar<T>` implements `Unsize<Bar<U>>`.\n    * T is not part of the type of any other fields.",
        "coerce.unsized.pointer": "Additionally, a type `Foo<T>` can implement `CoerceUnsized<Foo<U>>` when `T`\nimplements `Unsize<U>` or `CoerceUnsized<Foo<U>>`. This allows it to provide an\nunsized coercion to `Foo<U>`.\n\n> [!NOTE]\n> While the definition of the unsized coercions and their implementation has been stabilized, the traits themselves are not yet stable and therefore can't be used directly in stable Rust."
      }
    },
    {
      "id": "coerce.least-upper-bound",
      "title": "Least upper bound coercions",
      "level": 3,
      "content": "In some contexts, the compiler must coerce together multiple types to try and\nfind the most general type. This is called a \"Least Upper Bound\" coercion.\nLUB coercion is used and only used in the following situations:\n\n+ To find the common type for a series of if branches.\n+ To find the common type for a series of match arms.\n+ To find the common type for array elements.\n+ To find the type for the return type of a closure with multiple return statements.\n+ To check the type for the return type of a function with multiple return statements.\n\nIn each such case, there are a set of types `T0..Tn` to be mutually coerced\nto some target type `T_t`, which is unknown to start.\n\nComputing the LUB\ncoercion is done iteratively. The target type `T_t` begins as the type `T0`.\nFor each new type `Ti`, we consider whether\n\n+ If `Ti` can be coerced to the current target type `T_t`, then no change is made.\n\n+ Otherwise, check whether `T_t` can be coerced to `Ti`; if so, the `T_t` is\nchanged to `Ti`. (This check is also conditioned on whether all of the source\nexpressions considered thus far have implicit coercions.)\n\n+ If not, try to compute a mutual supertype of `T_t` and `Ti`, which will become the new target type.\n\n### Examples:\n\n# let (a, b, c) = (0, 1, 2);\n// For if branches\nlet bar = if true {\n    a\n} else if false {\n    b\n} else {\n    c\n};\n\n// For match arms\nlet baw = match 42 {\n    0 => a,\n    1 => b,\n    _ => c,\n};\n\n// For array elements\nlet bax = [a, b, c];\n\n// For closure with multiple return statements\nlet clo = || {\n    if true {\n        a\n    } else if false {\n        b\n    } else {\n        c\n    }\n};\nlet baz = clo();\n\n// For type checking of function with multiple return statements\nfn foo() -> i32 {\n    let (a, b, c) = (0, 1, 2);\n    match 42 {\n        0 => a,\n        1 => b,\n        _ => c,\n    }\n}\n\nIn these examples, types of the `ba*` are found by LUB coercion. And the\ncompiler checks whether LUB coercion result of `a`, `b`, `c` is `i32` in the\nprocessing of the function `foo`.\n\n### Caveat\n\nThis description is obviously informal. Making it more precise is expected to\nproceed as part of a general effort to specify the Rust type checker more\nprecisely.\n\n[RFC 401]: https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md\n[RFC 1558]: https://github.com/rust-lang/rfcs/blob/master/text/1558-closure-to-fn-coercion.md\n[subtype]: subtyping.md\n[dyn compatible]: items/traits.md#dyn-compatibility\n[type cast operator]: expressions/operator-expr.md#type-cast-expressions\n[`Unsize`]: std::marker::Unsize\n[`CoerceUnsized`]: std::ops::CoerceUnsized\n[method-call expressions]: expressions/method-call-expr.md\n[supertraits]: items/traits.md#supertraits",
      "parent_id": null,
      "paragraphs": {
        "coerce.least-upper-bound.intro": "In some contexts, the compiler must coerce together multiple types to try and\nfind the most general type. This is called a \"Least Upper Bound\" coercion.\nLUB coercion is used and only used in the following situations:\n\n+ To find the common type for a series of if branches.\n+ To find the common type for a series of match arms.\n+ To find the common type for array elements.\n+ To find the type for the return type of a closure with multiple return statements.\n+ To check the type for the return type of a function with multiple return statements.",
        "coerce.least-upper-bound.target": "In each such case, there are a set of types `T0..Tn` to be mutually coerced\nto some target type `T_t`, which is unknown to start.",
        "coerce.least-upper-bound.computation": "Computing the LUB\ncoercion is done iteratively. The target type `T_t` begins as the type `T0`.\nFor each new type `Ti`, we consider whether",
        "coerce.least-upper-bound.computation-identity": "+ If `Ti` can be coerced to the current target type `T_t`, then no change is made.",
        "coerce.least-upper-bound.computation-replace": "+ Otherwise, check whether `T_t` can be coerced to `Ti`; if so, the `T_t` is\nchanged to `Ti`. (This check is also conditioned on whether all of the source\nexpressions considered thus far have implicit coercions.)",
        "coerce.least-upper-bound.computation-unify": "+ If not, try to compute a mutual supertype of `T_t` and `Ti`, which will become the new target type.\n\n### Examples:\n\n# let (a, b, c) = (0, 1, 2);\n// For if branches\nlet bar = if true {\n    a\n} else if false {\n    b\n} else {\n    c\n};\n\n// For match arms\nlet baw = match 42 {\n    0 => a,\n    1 => b,\n    _ => c,\n};\n\n// For array elements\nlet bax = [a, b, c];\n\n// For closure with multiple return statements\nlet clo = || {\n    if true {\n        a\n    } else if false {\n        b\n    } else {\n        c\n    }\n};\nlet baz = clo();\n\n// For type checking of function with multiple return statements\nfn foo() -> i32 {\n    let (a, b, c) = (0, 1, 2);\n    match 42 {\n        0 => a,\n        1 => b,\n        _ => c,\n    }\n}\n\nIn these examples, types of the `ba*` are found by LUB coercion. And the\ncompiler checks whether LUB coercion result of `a`, `b`, `c` is `i32` in the\nprocessing of the function `foo`.\n\n### Caveat\n\nThis description is obviously informal. Making it more precise is expected to\nproceed as part of a general effort to specify the Rust type checker more\nprecisely.\n\n[RFC 401]: https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md\n[RFC 1558]: https://github.com/rust-lang/rfcs/blob/master/text/1558-closure-to-fn-coercion.md\n[subtype]: subtyping.md\n[dyn compatible]: items/traits.md#dyn-compatibility\n[type cast operator]: expressions/operator-expr.md#type-cast-expressions\n[`Unsize`]: std::marker::Unsize\n[`CoerceUnsized`]: std::ops::CoerceUnsized\n[method-call expressions]: expressions/method-call-expr.md\n[supertraits]: items/traits.md#supertraits"
      }
    },
    {
      "id": "destructors",
      "title": "Destructors",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "destructors.intro",
      "title": "Destructors",
      "level": 1,
      "content": "When an [initialized]&#32;[variable] or [temporary] goes out of\nscope, its *destructor* is run or it is *dropped*. [Assignment]\nalso runs the destructor of its left-hand operand, if it's initialized. If a\nvariable has been partially initialized, only its initialized fields are\ndropped.",
      "parent_id": null,
      "paragraphs": {
        "destructors.intro": "When an [initialized]&#32;[variable] or [temporary] goes out of\nscope, its *destructor* is run or it is *dropped*. [Assignment]\nalso runs the destructor of its left-hand operand, if it's initialized. If a\nvariable has been partially initialized, only its initialized fields are\ndropped."
      }
    },
    {
      "id": "destructors.operation",
      "title": "Destructors",
      "level": 1,
      "content": "The destructor of a type `T` consists of:\n\n1. If `T: Drop`, calling `<T as core::ops::Drop>::drop`\n2. Recursively running the destructor of all of its fields.\n    * The fields of a [struct] are dropped in declaration order.\n    * The fields of the active [enum variant] are dropped in declaration order.\n    * The fields of a [tuple] are dropped in order.\n    * The elements of an [array] or owned [slice] are dropped from the\n      first element to the last.\n    * The variables that a [closure] captures by move are dropped in an\n      unspecified order.\n    * [Trait objects] run the destructor of the underlying type.\n    * Other types don't result in any further drops.",
      "parent_id": null,
      "paragraphs": {
        "destructors.operation": "The destructor of a type `T` consists of:\n\n1. If `T: Drop`, calling `<T as core::ops::Drop>::drop`\n2. Recursively running the destructor of all of its fields.\n    * The fields of a [struct] are dropped in declaration order.\n    * The fields of the active [enum variant] are dropped in declaration order.\n    * The fields of a [tuple] are dropped in order.\n    * The elements of an [array] or owned [slice] are dropped from the\n      first element to the last.\n    * The variables that a [closure] captures by move are dropped in an\n      unspecified order.\n    * [Trait objects] run the destructor of the underlying type.\n    * Other types don't result in any further drops."
      }
    },
    {
      "id": "destructors.drop_in_place",
      "title": "Destructors",
      "level": 1,
      "content": "If a destructor must be run manually, such as when implementing your own smart\npointer, [`core::ptr::drop_in_place`] can be used.\n\nSome examples:\n\nstruct PrintOnDrop(&'static str);\n\nimpl Drop for PrintOnDrop {\n    fn drop(&mut self) {\n        println!(\"{}\", self.0);\n    }\n}\n\nlet mut overwritten = PrintOnDrop(\"drops when overwritten\");\noverwritten = PrintOnDrop(\"drops when scope ends\");\n\nlet tuple = (PrintOnDrop(\"Tuple first\"), PrintOnDrop(\"Tuple second\"));\n\nlet moved;\n// No destructor run on assignment.\nmoved = PrintOnDrop(\"Drops when moved\");\n// Drops now, but is then uninitialized.\nmoved;\n\n// Uninitialized does not drop.\nlet uninitialized: PrintOnDrop;\n\n// After a partial move, only the remaining fields are dropped.\nlet mut partial_move = (PrintOnDrop(\"first\"), PrintOnDrop(\"forgotten\"));\n// Perform a partial move, leaving only `partial_move.0` initialized.\ncore::mem::forget(partial_move.1);\n// When partial_move's scope ends, only the first field is dropped.",
      "parent_id": null,
      "paragraphs": {
        "destructors.drop_in_place": "If a destructor must be run manually, such as when implementing your own smart\npointer, [`core::ptr::drop_in_place`] can be used.\n\nSome examples:\n\nstruct PrintOnDrop(&'static str);\n\nimpl Drop for PrintOnDrop {\n    fn drop(&mut self) {\n        println!(\"{}\", self.0);\n    }\n}\n\nlet mut overwritten = PrintOnDrop(\"drops when overwritten\");\noverwritten = PrintOnDrop(\"drops when scope ends\");\n\nlet tuple = (PrintOnDrop(\"Tuple first\"), PrintOnDrop(\"Tuple second\"));\n\nlet moved;\n// No destructor run on assignment.\nmoved = PrintOnDrop(\"Drops when moved\");\n// Drops now, but is then uninitialized.\nmoved;\n\n// Uninitialized does not drop.\nlet uninitialized: PrintOnDrop;\n\n// After a partial move, only the remaining fields are dropped.\nlet mut partial_move = (PrintOnDrop(\"first\"), PrintOnDrop(\"forgotten\"));\n// Perform a partial move, leaving only `partial_move.0` initialized.\ncore::mem::forget(partial_move.1);\n// When partial_move's scope ends, only the first field is dropped."
      }
    },
    {
      "id": "destructors.scope",
      "title": "Drop scopes",
      "level": 1,
      "content": "Each variable or temporary is associated to a *drop scope*. When control flow\nleaves a drop scope all variables associated to that scope are dropped in\nreverse order of declaration (for variables) or creation (for temporaries).\n\nDrop scopes can be determined by replacing [`for`], [`if`], and [`while`]\nexpressions with equivalent expressions using [`match`], [`loop`] and\n`break`.\n\nOverloaded operators are not distinguished from built-in operators and [binding\nmodes] are not considered.\n\nGiven a function, or closure, there are drop scopes for:\n\n* The entire function\n\n* Each [statement]\n\n* Each [expression]\n\n* Each block, including the function body\n    * In the case of a [block expression], the scope for the block and the\n      expression are the same scope.\n\n* Each arm of a `match` expression\n\nDrop scopes are nested within one another as follows. When multiple scopes are\nleft at once, such as when returning from a function, variables are dropped\nfrom the inside outwards.\n\n* The entire function scope is the outer most scope.\n\n* The function body block is contained within the scope of the entire function.\n\n* The parent of the expression in an expression statement is the scope of the\n  statement.\n\n* The parent of the initializer of a [`let` statement] is the `let` statement's\n  scope.\n\n* The parent of a statement scope is the scope of the block that contains the\n  statement.\n\n* The parent of the expression for a `match` guard is the scope of the arm that\n  the guard is for.\n\n* The parent of the expression after the `=>` in a `match` expression is the\n  scope of the arm that it's in.\n\n* The parent of the arm scope is the scope of the `match` expression that it\n  belongs to.\n\n* The parent of all other scopes is the scope of the immediately enclosing\n  expression.",
      "parent_id": null,
      "paragraphs": {
        "destructors.scope.intro": "Each variable or temporary is associated to a *drop scope*. When control flow\nleaves a drop scope all variables associated to that scope are dropped in\nreverse order of declaration (for variables) or creation (for temporaries).",
        "destructors.scope.desugaring": "Drop scopes can be determined by replacing [`for`], [`if`], and [`while`]\nexpressions with equivalent expressions using [`match`], [`loop`] and\n`break`.",
        "destructors.scope.operators": "Overloaded operators are not distinguished from built-in operators and [binding\nmodes] are not considered.",
        "destructors.scope.list": "Given a function, or closure, there are drop scopes for:",
        "destructors.scope.function": "* The entire function",
        "destructors.scope.statement": "* Each [statement]",
        "destructors.scope.expression": "* Each [expression]",
        "destructors.scope.block": "* Each block, including the function body\n    * In the case of a [block expression], the scope for the block and the\n      expression are the same scope.",
        "destructors.scope.match-arm": "* Each arm of a `match` expression",
        "destructors.scope.nesting": "Drop scopes are nested within one another as follows. When multiple scopes are\nleft at once, such as when returning from a function, variables are dropped\nfrom the inside outwards.",
        "destructors.scope.nesting.function": "* The entire function scope is the outer most scope.",
        "destructors.scope.nesting.function-body": "* The function body block is contained within the scope of the entire function.",
        "destructors.scope.nesting.expr-statement": "* The parent of the expression in an expression statement is the scope of the\n  statement.",
        "destructors.scope.nesting.let-initializer": "* The parent of the initializer of a [`let` statement] is the `let` statement's\n  scope.",
        "destructors.scope.nesting.statement": "* The parent of a statement scope is the scope of the block that contains the\n  statement.",
        "destructors.scope.nesting.match-guard": "* The parent of the expression for a `match` guard is the scope of the arm that\n  the guard is for.",
        "destructors.scope.nesting.match-arm": "* The parent of the expression after the `=>` in a `match` expression is the\n  scope of the arm that it's in.",
        "destructors.scope.nesting.match": "* The parent of the arm scope is the scope of the `match` expression that it\n  belongs to.",
        "destructors.scope.nesting.other": "* The parent of all other scopes is the scope of the immediately enclosing\n  expression."
      }
    },
    {
      "id": "destructors.scope.params",
      "title": "Scopes of function parameters",
      "level": 2,
      "content": "All function parameters are in the scope of the entire function body, so are\ndropped last when evaluating the function. Each actual function parameter is\ndropped after any bindings introduced in that parameter's pattern.\n\n# struct PrintOnDrop(&'static str);\n# impl Drop for PrintOnDrop {\n#     fn drop(&mut self) {\n#         println!(\"drop({})\", self.0);\n#     }\n# }\n// Drops `y`, then the second parameter, then `x`, then the first parameter\nfn patterns_in_parameters(\n    (x, _): (PrintOnDrop, PrintOnDrop),\n    (_, y): (PrintOnDrop, PrintOnDrop),\n) {}\n\n// drop order is 3 2 0 1\npatterns_in_parameters(\n    (PrintOnDrop(\"0\"), PrintOnDrop(\"1\")),\n    (PrintOnDrop(\"2\"), PrintOnDrop(\"3\")),\n);",
      "parent_id": null,
      "paragraphs": {
        "destructors.scope.params": "All function parameters are in the scope of the entire function body, so are\ndropped last when evaluating the function. Each actual function parameter is\ndropped after any bindings introduced in that parameter's pattern.\n\n# struct PrintOnDrop(&'static str);\n# impl Drop for PrintOnDrop {\n#     fn drop(&mut self) {\n#         println!(\"drop({})\", self.0);\n#     }\n# }\n// Drops `y`, then the second parameter, then `x`, then the first parameter\nfn patterns_in_parameters(\n    (x, _): (PrintOnDrop, PrintOnDrop),\n    (_, y): (PrintOnDrop, PrintOnDrop),\n) {}\n\n// drop order is 3 2 0 1\npatterns_in_parameters(\n    (PrintOnDrop(\"0\"), PrintOnDrop(\"1\")),\n    (PrintOnDrop(\"2\"), PrintOnDrop(\"3\")),\n);"
      }
    },
    {
      "id": "destructors.scope.bindings",
      "title": "Scopes of local variables",
      "level": 1,
      "content": "Local variables declared in a `let` statement are associated to the scope of\nthe block that contains the `let` statement. Local variables declared in a\n`match` expression are associated to the arm scope of the `match` arm that they\nare declared in.\n\n# struct PrintOnDrop(&'static str);\n# impl Drop for PrintOnDrop {\n#     fn drop(&mut self) {\n#         println!(\"drop({})\", self.0);\n#     }\n# }\nlet declared_first = PrintOnDrop(\"Dropped last in outer scope\");\n{\n    let declared_in_block = PrintOnDrop(\"Dropped in inner scope\");\n}\nlet declared_last = PrintOnDrop(\"Dropped first in outer scope\");\n\nVariables in patterns are dropped in reverse order of declaration within the pattern.\n\n# struct PrintOnDrop(&'static str);\n# impl Drop for PrintOnDrop {\n#     fn drop(&mut self) {\n#         println!(\"drop({})\", self.0);\n#     }\n# }\nlet (declared_first, declared_last) = (\n    PrintOnDrop(\"Dropped last\"),\n    PrintOnDrop(\"Dropped first\"),\n);\n\nFor the purpose of drop order, [or-patterns] declare bindings in the order given by the first subpattern.\n\n# struct PrintOnDrop(&'static str);\n# impl Drop for PrintOnDrop {\n#     fn drop(&mut self) {\n#         println!(\"drop({})\", self.0);\n#     }\n# }\n// Drops `x` before `y`.\nfn or_pattern_drop_order<T>(\n    (Ok([x, y]) | Err([y, x])): Result<[T; 2], [T; 2]>\n//   ^^^^^^^^^^   ^^^^^^^^^^^ This is the second subpattern.\n//   |\n//   This is the first subpattern.\n//\n//   In the first subpattern, `x` is declared before `y`. Since it is\n//   the first subpattern, that is the order used even if the second\n//   subpattern, where the bindings are declared in the opposite\n//   order, is matched.\n) {}\n\n// Here we match the first subpattern, and the drops happen according\n// to the declaration order in the first subpattern.\nor_pattern_drop_order(Ok([\n    PrintOnDrop(\"Declared first, dropped last\"),\n    PrintOnDrop(\"Declared last, dropped first\"),\n]));\n\n// Here we match the second subpattern, and the drops still happen\n// according to the declaration order in the first subpattern.\nor_pattern_drop_order(Err([\n    PrintOnDrop(\"Declared last, dropped first\"),\n    PrintOnDrop(\"Declared first, dropped last\"),\n]));",
      "parent_id": null,
      "paragraphs": {
        "destructors.scope.bindings.intro": "Local variables declared in a `let` statement are associated to the scope of\nthe block that contains the `let` statement. Local variables declared in a\n`match` expression are associated to the arm scope of the `match` arm that they\nare declared in.\n\n# struct PrintOnDrop(&'static str);\n# impl Drop for PrintOnDrop {\n#     fn drop(&mut self) {\n#         println!(\"drop({})\", self.0);\n#     }\n# }\nlet declared_first = PrintOnDrop(\"Dropped last in outer scope\");\n{\n    let declared_in_block = PrintOnDrop(\"Dropped in inner scope\");\n}\nlet declared_last = PrintOnDrop(\"Dropped first in outer scope\");",
        "destructors.scope.bindings.patterns": "Variables in patterns are dropped in reverse order of declaration within the pattern.\n\n# struct PrintOnDrop(&'static str);\n# impl Drop for PrintOnDrop {\n#     fn drop(&mut self) {\n#         println!(\"drop({})\", self.0);\n#     }\n# }\nlet (declared_first, declared_last) = (\n    PrintOnDrop(\"Dropped last\"),\n    PrintOnDrop(\"Dropped first\"),\n);",
        "destructors.scope.bindings.or-patterns": "For the purpose of drop order, [or-patterns] declare bindings in the order given by the first subpattern.\n\n# struct PrintOnDrop(&'static str);\n# impl Drop for PrintOnDrop {\n#     fn drop(&mut self) {\n#         println!(\"drop({})\", self.0);\n#     }\n# }\n// Drops `x` before `y`.\nfn or_pattern_drop_order<T>(\n    (Ok([x, y]) | Err([y, x])): Result<[T; 2], [T; 2]>\n//   ^^^^^^^^^^   ^^^^^^^^^^^ This is the second subpattern.\n//   |\n//   This is the first subpattern.\n//\n//   In the first subpattern, `x` is declared before `y`. Since it is\n//   the first subpattern, that is the order used even if the second\n//   subpattern, where the bindings are declared in the opposite\n//   order, is matched.\n) {}\n\n// Here we match the first subpattern, and the drops happen according\n// to the declaration order in the first subpattern.\nor_pattern_drop_order(Ok([\n    PrintOnDrop(\"Declared first, dropped last\"),\n    PrintOnDrop(\"Declared last, dropped first\"),\n]));\n\n// Here we match the second subpattern, and the drops still happen\n// according to the declaration order in the first subpattern.\nor_pattern_drop_order(Err([\n    PrintOnDrop(\"Declared last, dropped first\"),\n    PrintOnDrop(\"Declared first, dropped last\"),\n]));"
      }
    },
    {
      "id": "destructors.scope.temporary",
      "title": "Temporary scopes",
      "level": 1,
      "content": "The *temporary scope* of an expression is the scope that is used for the\ntemporary variable that holds the result of that expression when used in a\n[place context], unless it is [promoted].\n\nApart from lifetime extension, the temporary scope of an expression is the\nsmallest scope that contains the expression and is one of the following:\n\n* The entire function.\n* A statement.\n* The body of an [`if`], [`while`] or [`loop`] expression.\n* The `else` block of an `if` expression.\n* The non-pattern matching condition expression of an `if` or `while` expression,\n  or a `match` guard.\n* The body expression for a match arm.\n* Each operand of a [lazy boolean expression].\n* The pattern-matching condition(s) and consequent body of [`if`] ([destructors.scope.temporary.edition2024]).\n* The pattern-matching condition and loop body of [`while`].\n* The entirety of the tail expression of a block ([destructors.scope.temporary.edition2024]).\n\n> [!NOTE]\n> The [scrutinee] of a `match` expression is not a temporary scope, so temporaries in the scrutinee can be dropped after the `match` expression. For example, the temporary for `1` in `match 1 { ref mut z => z };` lives until the end of the statement.\n\n> [!NOTE]\n> The desugaring of a [destructuring assignment] restricts the temporary scope of its assigned value operand (the RHS). For details, see [expr.assign.destructure.tmp-scopes].\n\n> [!EDITION-2024]\n> The 2024 edition added two new temporary scope narrowing rules: `if let` temporaries are dropped before the `else` block, and temporaries of tail expressions of blocks are dropped immediately after the tail expression is evaluated.\n\nSome examples:\n\n# #![allow(irrefutable_let_patterns)]\n# struct PrintOnDrop(&'static str);\n# impl Drop for PrintOnDrop {\n#     fn drop(&mut self) {\n#         println!(\"drop({})\", self.0);\n#     }\n# }\nlet local_var = PrintOnDrop(\"local var\");\n\n// Dropped once the condition has been evaluated\nif PrintOnDrop(\"If condition\").0 == \"If condition\" {\n    // Dropped at the end of the block\n    PrintOnDrop(\"If body\").0\n} else {\n    unreachable!()\n};\n\nif let \"if let scrutinee\" = PrintOnDrop(\"if let scrutinee\").0 {\n    PrintOnDrop(\"if let consequent\").0\n    // `if let consequent` dropped here\n}\n// `if let scrutinee` is dropped here\nelse {\n    PrintOnDrop(\"if let else\").0\n    // `if let else` dropped here\n};\n\nwhile let x = PrintOnDrop(\"while let scrutinee\").0 {\n    PrintOnDrop(\"while let loop body\").0;\n    break;\n    // `while let loop body` dropped here.\n    // `while let scrutinee` dropped here.\n}\n\n// Dropped before the first ||\n(PrintOnDrop(\"first operand\").0 == \"\"\n// Dropped before the )\n|| PrintOnDrop(\"second operand\").0 == \"\")\n// Dropped before the ;\n|| PrintOnDrop(\"third operand\").0 == \"\";\n\n// Scrutinee is dropped at the end of the function, before local variables\n// (because this is the tail expression of the function body block).\nmatch PrintOnDrop(\"Matched value in final expression\") {\n    // Dropped once the condition has been evaluated\n    _ if PrintOnDrop(\"guard condition\").0 == \"\" => (),\n    _ => (),\n}",
      "parent_id": null,
      "paragraphs": {
        "destructors.scope.temporary.intro": "The *temporary scope* of an expression is the scope that is used for the\ntemporary variable that holds the result of that expression when used in a\n[place context], unless it is [promoted].",
        "destructors.scope.temporary.enclosing": "Apart from lifetime extension, the temporary scope of an expression is the\nsmallest scope that contains the expression and is one of the following:\n\n* The entire function.\n* A statement.\n* The body of an [`if`], [`while`] or [`loop`] expression.\n* The `else` block of an `if` expression.\n* The non-pattern matching condition expression of an `if` or `while` expression,\n  or a `match` guard.\n* The body expression for a match arm.\n* Each operand of a [lazy boolean expression].\n* The pattern-matching condition(s) and consequent body of [`if`] ([destructors.scope.temporary.edition2024]).\n* The pattern-matching condition and loop body of [`while`].\n* The entirety of the tail expression of a block ([destructors.scope.temporary.edition2024]).\n\n> [!NOTE]\n> The [scrutinee] of a `match` expression is not a temporary scope, so temporaries in the scrutinee can be dropped after the `match` expression. For example, the temporary for `1` in `match 1 { ref mut z => z };` lives until the end of the statement.\n\n> [!NOTE]\n> The desugaring of a [destructuring assignment] restricts the temporary scope of its assigned value operand (the RHS). For details, see [expr.assign.destructure.tmp-scopes].",
        "destructors.scope.temporary.edition2024": "> [!EDITION-2024]\n> The 2024 edition added two new temporary scope narrowing rules: `if let` temporaries are dropped before the `else` block, and temporaries of tail expressions of blocks are dropped immediately after the tail expression is evaluated.\n\nSome examples:\n\n# #![allow(irrefutable_let_patterns)]\n# struct PrintOnDrop(&'static str);\n# impl Drop for PrintOnDrop {\n#     fn drop(&mut self) {\n#         println!(\"drop({})\", self.0);\n#     }\n# }\nlet local_var = PrintOnDrop(\"local var\");\n\n// Dropped once the condition has been evaluated\nif PrintOnDrop(\"If condition\").0 == \"If condition\" {\n    // Dropped at the end of the block\n    PrintOnDrop(\"If body\").0\n} else {\n    unreachable!()\n};\n\nif let \"if let scrutinee\" = PrintOnDrop(\"if let scrutinee\").0 {\n    PrintOnDrop(\"if let consequent\").0\n    // `if let consequent` dropped here\n}\n// `if let scrutinee` is dropped here\nelse {\n    PrintOnDrop(\"if let else\").0\n    // `if let else` dropped here\n};\n\nwhile let x = PrintOnDrop(\"while let scrutinee\").0 {\n    PrintOnDrop(\"while let loop body\").0;\n    break;\n    // `while let loop body` dropped here.\n    // `while let scrutinee` dropped here.\n}\n\n// Dropped before the first ||\n(PrintOnDrop(\"first operand\").0 == \"\"\n// Dropped before the )\n|| PrintOnDrop(\"second operand\").0 == \"\")\n// Dropped before the ;\n|| PrintOnDrop(\"third operand\").0 == \"\";\n\n// Scrutinee is dropped at the end of the function, before local variables\n// (because this is the tail expression of the function body block).\nmatch PrintOnDrop(\"Matched value in final expression\") {\n    // Dropped once the condition has been evaluated\n    _ if PrintOnDrop(\"guard condition\").0 == \"\" => (),\n    _ => (),\n}"
      }
    },
    {
      "id": "destructors.scope.operands",
      "title": "Operands",
      "level": 1,
      "content": "Temporaries are also created to hold the result of operands to an expression\nwhile the other operands are evaluated. The temporaries are associated to the\nscope of the expression with that operand. Since the temporaries are moved from\nonce the expression is evaluated, dropping them has no effect unless one of the\noperands to an expression breaks out of the expression, returns, or panics.\n\n# struct PrintOnDrop(&'static str);\n# impl Drop for PrintOnDrop {\n#     fn drop(&mut self) {\n#         println!(\"drop({})\", self.0);\n#     }\n# }\nloop {\n    // Tuple expression doesn't finish evaluating so operands drop in reverse order\n    (\n        PrintOnDrop(\"Outer tuple first\"),\n        PrintOnDrop(\"Outer tuple second\"),\n        (\n            PrintOnDrop(\"Inner tuple first\"),\n            PrintOnDrop(\"Inner tuple second\"),\n            break,\n        ),\n        PrintOnDrop(\"Never created\"),\n    );\n}",
      "parent_id": null,
      "paragraphs": {
        "destructors.scope.operands": "Temporaries are also created to hold the result of operands to an expression\nwhile the other operands are evaluated. The temporaries are associated to the\nscope of the expression with that operand. Since the temporaries are moved from\nonce the expression is evaluated, dropping them has no effect unless one of the\noperands to an expression breaks out of the expression, returns, or panics.\n\n# struct PrintOnDrop(&'static str);\n# impl Drop for PrintOnDrop {\n#     fn drop(&mut self) {\n#         println!(\"drop({})\", self.0);\n#     }\n# }\nloop {\n    // Tuple expression doesn't finish evaluating so operands drop in reverse order\n    (\n        PrintOnDrop(\"Outer tuple first\"),\n        PrintOnDrop(\"Outer tuple second\"),\n        (\n            PrintOnDrop(\"Inner tuple first\"),\n            PrintOnDrop(\"Inner tuple second\"),\n            break,\n        ),\n        PrintOnDrop(\"Never created\"),\n    );\n}"
      }
    },
    {
      "id": "destructors.scope.const-promotion",
      "title": "Constant promotion",
      "level": 1,
      "content": "Promotion of a value expression to a `'static` slot occurs when the expression\ncould be written in a constant and borrowed, and that borrow could be dereferenced\nwhere\nthe expression was originally written, without changing the runtime behavior.\nThat is, the promoted expression can be evaluated at compile-time and the\nresulting value does not contain [interior mutability] or [destructors] (these\nproperties are determined based on the value where possible, e.g. `&None`\nalways has the type `&'static Option<_>`, as it contains nothing disallowed).",
      "parent_id": null,
      "paragraphs": {
        "destructors.scope.const-promotion": "Promotion of a value expression to a `'static` slot occurs when the expression\ncould be written in a constant and borrowed, and that borrow could be dereferenced\nwhere\nthe expression was originally written, without changing the runtime behavior.\nThat is, the promoted expression can be evaluated at compile-time and the\nresulting value does not contain [interior mutability] or [destructors] (these\nproperties are determined based on the value where possible, e.g. `&None`\nalways has the type `&'static Option<_>`, as it contains nothing disallowed)."
      }
    },
    {
      "id": "destructors.scope.lifetime-extension",
      "title": "Temporary lifetime extension",
      "level": 3,
      "content": "> [!NOTE]\n> The exact rules for temporary lifetime extension are subject to change. This is describing the current behavior only.\n\nThe temporary scopes for expressions in `let` statements are sometimes\n*extended* to the scope of the block containing the `let` statement. This is\ndone when the usual temporary scope would be too small, based on certain\nsyntactic rules. For example:\n\nlet x = &mut 0;\n// Usually a temporary would be dropped by now, but the temporary for `0` lives\n// to the end of the block.\nprintln!(\"{}\", x);\n\nLifetime extension also applies to `static` and `const` items, where it\nmakes temporaries live until the end of the program. For example:\n\nconst C: &Vec<i32> = &Vec::new();\n// Usually this would be a dangling reference as the `Vec` would only\n// exist inside the initializer expression of `C`, but instead the\n// borrow gets lifetime-extended so it effectively has `'static` lifetime.\nprintln!(\"{:?}\", C);\n\nIf a [borrow], dereference, field, or [tuple indexing expression] has an extended temporary scope, then so does its operand. If an [indexing expression] has an extended temporary scope, then the indexed expression also has an extended temporary scope.",
      "parent_id": null,
      "paragraphs": {
        "destructors.scope.lifetime-extension": "> [!NOTE]\n> The exact rules for temporary lifetime extension are subject to change. This is describing the current behavior only.",
        "destructors.scope.lifetime-extension.let": "The temporary scopes for expressions in `let` statements are sometimes\n*extended* to the scope of the block containing the `let` statement. This is\ndone when the usual temporary scope would be too small, based on certain\nsyntactic rules. For example:\n\nlet x = &mut 0;\n// Usually a temporary would be dropped by now, but the temporary for `0` lives\n// to the end of the block.\nprintln!(\"{}\", x);",
        "destructors.scope.lifetime-extension.static": "Lifetime extension also applies to `static` and `const` items, where it\nmakes temporaries live until the end of the program. For example:\n\nconst C: &Vec<i32> = &Vec::new();\n// Usually this would be a dangling reference as the `Vec` would only\n// exist inside the initializer expression of `C`, but instead the\n// borrow gets lifetime-extended so it effectively has `'static` lifetime.\nprintln!(\"{:?}\", C);",
        "destructors.scope.lifetime-extension.sub-expressions": "If a [borrow], dereference, field, or [tuple indexing expression] has an extended temporary scope, then so does its operand. If an [indexing expression] has an extended temporary scope, then the indexed expression also has an extended temporary scope."
      }
    },
    {
      "id": "destructors.scope.lifetime-extension.patterns",
      "title": "Extending based on patterns",
      "level": 3,
      "content": "An *extending pattern* is either:\n\n* An [identifier pattern] that binds by reference or mutable reference.\n\n  ```rust\n  # fn temp() {}\n  let ref x = temp(); // Binds by reference.\n  # x;\n  let ref mut x = temp(); // Binds by mutable reference.\n  # x;\n  ```\n\n* A struct, tuple, tuple struct, slice, or or-pattern where at least one of the direct subpatterns is an extending pattern.\n\n  ```rust\n  # use core::sync::atomic::{AtomicU64, Ordering::Relaxed};\n  # static X: AtomicU64 = AtomicU64::new(0);\n  struct W<T>(T);\n  # impl<T> Drop for W<T> { fn drop(&mut self) { X.fetch_add(1, Relaxed); } }\n  let W { 0: ref x } = W(()); // Struct pattern.\n  # x;\n  let W(ref x) = W(()); // Tuple struct pattern.\n  # x;\n  let (W(ref x),) = (W(()),); // Tuple pattern.\n  # x;\n  let [W(ref x), ..] = [W(())]; // Slice pattern.\n  # x;\n  let (Ok(W(ref x)) | Err(&ref x)) = Ok(W(())); // Or pattern.\n  # x;\n  //\n  // All of the temporaries above are still live here.\n  # assert_eq!(0, X.load(Relaxed));\n  ```\n\nSo `ref x`, `V(ref x)` and `[ref x, y]` are all extending patterns, but `x`, `&ref x` and `&(ref x,)` are not.\n\nIf the pattern in a `let` statement is an extending pattern then the temporary\nscope of the initializer expression is extended.\n\n# fn temp() {}\n// This is an extending pattern, so the temporary scope is extended.\nlet ref x = *&temp(); // OK\n# x;\n\n,compile_fail,E0716\n# fn temp() {}\n// This is neither an extending pattern nor an extending expression,\n// so the temporary is dropped at the semicolon.\nlet &ref x = *&&temp(); // ERROR\n# x;\n\n# fn temp() {}\n// This is not an extending pattern but it is an extending expression,\n// so the temporary lives beyond the `let` statement.\nlet &ref x = &*&temp(); // OK\n# x;",
      "parent_id": null,
      "paragraphs": {
        "destructors.scope.lifetime-extension.patterns.extending": "An *extending pattern* is either:\n\n* An [identifier pattern] that binds by reference or mutable reference.\n\n  ```rust\n  # fn temp() {}\n  let ref x = temp(); // Binds by reference.\n  # x;\n  let ref mut x = temp(); // Binds by mutable reference.\n  # x;\n  ```\n\n* A struct, tuple, tuple struct, slice, or or-pattern where at least one of the direct subpatterns is an extending pattern.\n\n  ```rust\n  # use core::sync::atomic::{AtomicU64, Ordering::Relaxed};\n  # static X: AtomicU64 = AtomicU64::new(0);\n  struct W<T>(T);\n  # impl<T> Drop for W<T> { fn drop(&mut self) { X.fetch_add(1, Relaxed); } }\n  let W { 0: ref x } = W(()); // Struct pattern.\n  # x;\n  let W(ref x) = W(()); // Tuple struct pattern.\n  # x;\n  let (W(ref x),) = (W(()),); // Tuple pattern.\n  # x;\n  let [W(ref x), ..] = [W(())]; // Slice pattern.\n  # x;\n  let (Ok(W(ref x)) | Err(&ref x)) = Ok(W(())); // Or pattern.\n  # x;\n  //\n  // All of the temporaries above are still live here.\n  # assert_eq!(0, X.load(Relaxed));\n  ```\n\nSo `ref x`, `V(ref x)` and `[ref x, y]` are all extending patterns, but `x`, `&ref x` and `&(ref x,)` are not.",
        "destructors.scope.lifetime-extension.patterns.let": "If the pattern in a `let` statement is an extending pattern then the temporary\nscope of the initializer expression is extended.\n\n# fn temp() {}\n// This is an extending pattern, so the temporary scope is extended.\nlet ref x = *&temp(); // OK\n# x;\n\n,compile_fail,E0716\n# fn temp() {}\n// This is neither an extending pattern nor an extending expression,\n// so the temporary is dropped at the semicolon.\nlet &ref x = *&&temp(); // ERROR\n# x;\n\n# fn temp() {}\n// This is not an extending pattern but it is an extending expression,\n// so the temporary lives beyond the `let` statement.\nlet &ref x = &*&temp(); // OK\n# x;"
      }
    },
    {
      "id": "destructors.scope.lifetime-extension.exprs",
      "title": "Extending based on expressions",
      "level": 1,
      "content": "For a let statement with an initializer, an *extending expression* is an\nexpression which is one of the following:\n\n* The initializer expression.\n* The operand of an extending [borrow] expression.\n* The [super operands] of an extending [super macro call] expression.\n* The operand(s) of an extending array, cast, braced struct, or tuple\n  expression.\n* The arguments to an extending [tuple struct] or [tuple enum variant] constructor expression.\n* The final expression of an extending [block expression] except for an [async block expression].\n* The final expression of an extending [`if`] expression's consequent, `else if`, or `else` block.\n* An arm expression of an extending [`match`] expression.\n\n> [!NOTE]\n> The desugaring of a [destructuring assignment] makes its assigned value operand (the RHS) an extending expression within a newly-introduced block. For details, see [expr.assign.destructure.tmp-ext].\n\nSo the borrow expressions in `&mut 0`, `(&1, &mut 2)`, and `Some(&mut 3)`\nare all extending expressions. The borrows in `&0 + &1` and `f(&mut 0)` are not.\n\nThe operand of an extending [borrow] expression has its [temporary scope] [extended].\n\nThe [super temporaries] of an extending [super macro call] expression have their scopes [extended].\n\n> [!NOTE]\n> `rustc` does not treat [array repeat operands] of extending [array] expressions as extending expressions. Whether it should is an open question.\n>\n> For details, see Rust issue #146092.\n\n#### Examples\n\nHere are some examples where expressions have extended temporary scopes:\n\n,edition2024\n# use core::pin::pin;\n# use core::sync::atomic::{AtomicU64, Ordering::Relaxed};\n# static X: AtomicU64 = AtomicU64::new(0);\n# #[derive(Debug)] struct S;\n# impl Drop for S { fn drop(&mut self) { X.fetch_add(1, Relaxed); } }\n# const fn temp() -> S { S }\nlet x = &temp(); // Operand of borrow.\n# x;\nlet x = &raw const *&temp(); // Operand of raw borrow.\n# assert_eq!(X.load(Relaxed), 0);\nlet x = &temp() as &dyn Send; // Operand of cast.\n# x;\nlet x = (&*&temp(),); // Operand of tuple constructor.\n# x;\nstruct W<T>(T);\nlet x = W(&temp()); // Argument to tuple struct constructor.\n# x;\nlet x = Some(&temp()); // Argument to tuple enum variant constructor.\n# x;\nlet x = { [Some(&temp())] }; // Final expr of block.\n# x;\nlet x = const { &temp() }; // Final expr of `const` block.\n# x;\nlet x = unsafe { &temp() }; // Final expr of `unsafe` block.\n# x;\nlet x = if true { &temp() } else { &temp() };\n//              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n//           Final exprs of `if`/`else` blocks.\n# x;\nlet x = match () { _ => &temp() }; // `match` arm expression.\n# x;\nlet x = pin!(temp()); // Super operand of super macro call expression.\n# x;\nlet x = pin!({ &mut temp() }); // As above.\n# x;\nlet x = format_args!(\"{:?}\", temp()); // As above.\n# x;\n//\n// All of the temporaries above are still live here.\n# assert_eq!(0, X.load(Relaxed));\n\nHere are some examples where expressions don't have extended temporary scopes:\n\n,compile_fail,E0716\n# fn temp() {}\n// Arguments to function calls are not extending expressions. The\n// temporary is dropped at the semicolon.\nlet x = core::convert::identity(&temp()); // ERROR\n# x;\n\n,compile_fail,E0716\n# fn temp() {}\n# trait Use { fn use_temp(&self) -> &Self { self } }\n# impl Use for () {}\n// Receivers of method calls are not extending expressions.\nlet x = (&temp()).use_temp(); // ERROR\n# x;\n\n,compile_fail,E0716\n# fn temp() {}\n// Scrutinees of match expressions are not extending expressions.\nlet x = match &temp() { x => x }; // ERROR\n# x;\n\n,compile_fail,E0515\n# fn temp() {}\n// Final expressions of `async` blocks are not extending expressions.\nlet x = async { &temp() }; // ERROR\n# x;\n\n,compile_fail,E0515\n# fn temp() {}\n// Final expressions of closures are not extending expressions.\nlet x = || &temp(); // ERROR\n# x;\n\n,compile_fail,E0716\n# fn temp() {}\n// Operands of loop breaks are not extending expressions.\nlet x = loop { break &temp() }; // ERROR\n# x;\n\n,compile_fail,E0716\n# fn temp() {}\n// Operands of breaks to labels are not extending expressions.\nlet x = 'a: { break 'a &temp() }; // ERROR\n# x;\n\n,edition2024,compile_fail,E0716\n# use core::pin::pin;\n# fn temp() {}\n// The argument to `pin!` is only an extending expression if the call\n// is an extending expression. Since it's not, the inner block is not\n// an extending expression, so the temporaries in its trailing\n// expression are dropped immediately.\npin!({ &temp() }); // ERROR\n\n,edition2024,compile_fail,E0716\n# fn temp() {}\n// As above.\nformat_args!(\"{:?}\", { &temp() }); // ERROR",
      "parent_id": null,
      "paragraphs": {
        "destructors.scope.lifetime-extension.exprs.extending": "For a let statement with an initializer, an *extending expression* is an\nexpression which is one of the following:\n\n* The initializer expression.\n* The operand of an extending [borrow] expression.\n* The [super operands] of an extending [super macro call] expression.\n* The operand(s) of an extending array, cast, braced struct, or tuple\n  expression.\n* The arguments to an extending [tuple struct] or [tuple enum variant] constructor expression.\n* The final expression of an extending [block expression] except for an [async block expression].\n* The final expression of an extending [`if`] expression's consequent, `else if`, or `else` block.\n* An arm expression of an extending [`match`] expression.\n\n> [!NOTE]\n> The desugaring of a [destructuring assignment] makes its assigned value operand (the RHS) an extending expression within a newly-introduced block. For details, see [expr.assign.destructure.tmp-ext].\n\nSo the borrow expressions in `&mut 0`, `(&1, &mut 2)`, and `Some(&mut 3)`\nare all extending expressions. The borrows in `&0 + &1` and `f(&mut 0)` are not.",
        "destructors.scope.lifetime-extension.exprs.borrows": "The operand of an extending [borrow] expression has its [temporary scope] [extended].",
        "destructors.scope.lifetime-extension.exprs.super-macros": "The [super temporaries] of an extending [super macro call] expression have their scopes [extended].\n\n> [!NOTE]\n> `rustc` does not treat [array repeat operands] of extending [array] expressions as extending expressions. Whether it should is an open question.\n>\n> For details, see Rust issue #146092.\n\n#### Examples\n\nHere are some examples where expressions have extended temporary scopes:\n\n,edition2024\n# use core::pin::pin;\n# use core::sync::atomic::{AtomicU64, Ordering::Relaxed};\n# static X: AtomicU64 = AtomicU64::new(0);\n# #[derive(Debug)] struct S;\n# impl Drop for S { fn drop(&mut self) { X.fetch_add(1, Relaxed); } }\n# const fn temp() -> S { S }\nlet x = &temp(); // Operand of borrow.\n# x;\nlet x = &raw const *&temp(); // Operand of raw borrow.\n# assert_eq!(X.load(Relaxed), 0);\nlet x = &temp() as &dyn Send; // Operand of cast.\n# x;\nlet x = (&*&temp(),); // Operand of tuple constructor.\n# x;\nstruct W<T>(T);\nlet x = W(&temp()); // Argument to tuple struct constructor.\n# x;\nlet x = Some(&temp()); // Argument to tuple enum variant constructor.\n# x;\nlet x = { [Some(&temp())] }; // Final expr of block.\n# x;\nlet x = const { &temp() }; // Final expr of `const` block.\n# x;\nlet x = unsafe { &temp() }; // Final expr of `unsafe` block.\n# x;\nlet x = if true { &temp() } else { &temp() };\n//              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n//           Final exprs of `if`/`else` blocks.\n# x;\nlet x = match () { _ => &temp() }; // `match` arm expression.\n# x;\nlet x = pin!(temp()); // Super operand of super macro call expression.\n# x;\nlet x = pin!({ &mut temp() }); // As above.\n# x;\nlet x = format_args!(\"{:?}\", temp()); // As above.\n# x;\n//\n// All of the temporaries above are still live here.\n# assert_eq!(0, X.load(Relaxed));\n\nHere are some examples where expressions don't have extended temporary scopes:\n\n,compile_fail,E0716\n# fn temp() {}\n// Arguments to function calls are not extending expressions. The\n// temporary is dropped at the semicolon.\nlet x = core::convert::identity(&temp()); // ERROR\n# x;\n\n,compile_fail,E0716\n# fn temp() {}\n# trait Use { fn use_temp(&self) -> &Self { self } }\n# impl Use for () {}\n// Receivers of method calls are not extending expressions.\nlet x = (&temp()).use_temp(); // ERROR\n# x;\n\n,compile_fail,E0716\n# fn temp() {}\n// Scrutinees of match expressions are not extending expressions.\nlet x = match &temp() { x => x }; // ERROR\n# x;\n\n,compile_fail,E0515\n# fn temp() {}\n// Final expressions of `async` blocks are not extending expressions.\nlet x = async { &temp() }; // ERROR\n# x;\n\n,compile_fail,E0515\n# fn temp() {}\n// Final expressions of closures are not extending expressions.\nlet x = || &temp(); // ERROR\n# x;\n\n,compile_fail,E0716\n# fn temp() {}\n// Operands of loop breaks are not extending expressions.\nlet x = loop { break &temp() }; // ERROR\n# x;\n\n,compile_fail,E0716\n# fn temp() {}\n// Operands of breaks to labels are not extending expressions.\nlet x = 'a: { break 'a &temp() }; // ERROR\n# x;\n\n,edition2024,compile_fail,E0716\n# use core::pin::pin;\n# fn temp() {}\n// The argument to `pin!` is only an extending expression if the call\n// is an extending expression. Since it's not, the inner block is not\n// an extending expression, so the temporaries in its trailing\n// expression are dropped immediately.\npin!({ &temp() }); // ERROR\n\n,edition2024,compile_fail,E0716\n# fn temp() {}\n// As above.\nformat_args!(\"{:?}\", { &temp() }); // ERROR"
      }
    },
    {
      "id": "destructors.forget",
      "title": "Not running destructors",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "destructors.manually-suppressing",
      "title": "Manually suppressing destructors",
      "level": 2,
      "content": "[`core::mem::forget`] can be used to prevent the destructor of a variable from being run,\nand [`core::mem::ManuallyDrop`] provides a wrapper to prevent a\nvariable or field from being dropped automatically.\n\n> [!NOTE]\n> Preventing a destructor from being run via [`core::mem::forget`] or other means is safe even if it has a type that isn't `'static`. Besides the places where destructors are guaranteed to run as defined by this document, types may *not* safely rely on a destructor being run for soundness.",
      "parent_id": null,
      "paragraphs": {
        "destructors.manually-suppressing": "[`core::mem::forget`] can be used to prevent the destructor of a variable from being run,\nand [`core::mem::ManuallyDrop`] provides a wrapper to prevent a\nvariable or field from being dropped automatically.\n\n> [!NOTE]\n> Preventing a destructor from being run via [`core::mem::forget`] or other means is safe even if it has a type that isn't `'static`. Besides the places where destructors are guaranteed to run as defined by this document, types may *not* safely rely on a destructor being run for soundness."
      }
    },
    {
      "id": "destructors.process-termination",
      "title": "Process termination without unwinding",
      "level": 3,
      "content": "There are some ways to terminate the process without [unwinding], in which case destructors will not be run.\n\nThe standard library provides [`std::process::exit`] and [`std::process::abort`] to do this explicitly. Additionally, if the panic handler is set to `abort`, panicking will always terminate the process without destructors being run.\n\nThere is one additional case to be aware of: when a panic reaches a [non-unwinding ABI boundary], either no destructors will run, or all destructors up until the ABI boundary will run.\n\n[Assignment]: expressions/operator-expr.md#assignment-expressions\n[binding modes]: patterns.md#binding-modes\n[closure]: types/closure.md\n[destructors]: destructors.md\n[destructuring assignment]: expr.assign.destructure\n[expression]: expressions.md\n[identifier pattern]: patterns.md#identifier-patterns\n[initialized]: glossary.md#initialized\n[interior mutability]: interior-mutability.md\n[lazy boolean expression]: expressions/operator-expr.md#lazy-boolean-operators\n[non-unwinding ABI boundary]: items/functions.md#unwinding\n[panic]: panic.md\n[place context]: expressions.md#place-expressions-and-value-expressions\n[promoted]: destructors.md#constant-promotion\n[scrutinee]: glossary.md#scrutinee\n[statement]: statements.md\n[temporary]: expressions.md#temporaries\n[unwinding]: panic.md#unwinding\n[variable]: variables.md\n\n[array]: types/array.md\n[enum variant]: types/enum.md\n[slice]: types/slice.md\n[struct]: types/struct.md\n[Trait objects]: types/trait-object.md\n[tuple]: types/tuple.md\n\n[or-patterns]: patterns.md#or-patterns\n[slice pattern]: patterns.md#slice-patterns\n[struct pattern]: patterns.md#struct-patterns\n[tuple pattern]: patterns.md#tuple-patterns\n[tuple struct pattern]: patterns.md#tuple-struct-patterns\n[tuple struct]: type.struct.tuple\n[tuple enum variant]: type.enum.declaration\n\n[array expression]: expressions/array-expr.md#array-expressions\n[array repeat operands]: expr.array.repeat-operand\n[async block expression]: expr.block.async\n[block expression]: expressions/block-expr.md\n[borrow]: expr.operator.borrow\n[cast expression]: expressions/operator-expr.md#type-cast-expressions\n[dereference expression]: expressions/operator-expr.md#the-dereference-operator\n[extended]: destructors.scope.lifetime-extension\n[field expression]: expressions/field-expr.md\n[indexing expression]: expressions/array-expr.md#array-and-slice-indexing-expressions\n[struct expression]: expressions/struct-expr.md\n[super macro call]: expr.super-macros\n[super operands]: expr.super-macros\n[super temporaries]: expr.super-macros\n[temporary scope]: destructors.scope.temporary\n[temporary scopes]: destructors.scope.temporary\n[tuple expression]: expressions/tuple-expr.md#tuple-expressions\n[tuple indexing expression]: expressions/tuple-expr.md#tuple-indexing-expressions\n\n[`for`]: expressions/loop-expr.md#iterator-loops\n[`if let`]: expressions/if-expr.md#if-let-patterns\n[`if`]: expressions/if-expr.md#if-expressions\n[`let` statement]: statements.md#let-statements\n[`loop`]: expressions/loop-expr.md#infinite-loops\n[`match`]: expressions/match-expr.md\n[`while let`]: expressions/loop-expr.md#while-let-patterns\n[`while`]: expressions/loop-expr.md#predicate-loops",
      "parent_id": null,
      "paragraphs": {
        "destructors.process-termination": "There are some ways to terminate the process without [unwinding], in which case destructors will not be run.\n\nThe standard library provides [`std::process::exit`] and [`std::process::abort`] to do this explicitly. Additionally, if the panic handler is set to `abort`, panicking will always terminate the process without destructors being run.\n\nThere is one additional case to be aware of: when a panic reaches a [non-unwinding ABI boundary], either no destructors will run, or all destructors up until the ABI boundary will run.\n\n[Assignment]: expressions/operator-expr.md#assignment-expressions\n[binding modes]: patterns.md#binding-modes\n[closure]: types/closure.md\n[destructors]: destructors.md\n[destructuring assignment]: expr.assign.destructure\n[expression]: expressions.md\n[identifier pattern]: patterns.md#identifier-patterns\n[initialized]: glossary.md#initialized\n[interior mutability]: interior-mutability.md\n[lazy boolean expression]: expressions/operator-expr.md#lazy-boolean-operators\n[non-unwinding ABI boundary]: items/functions.md#unwinding\n[panic]: panic.md\n[place context]: expressions.md#place-expressions-and-value-expressions\n[promoted]: destructors.md#constant-promotion\n[scrutinee]: glossary.md#scrutinee\n[statement]: statements.md\n[temporary]: expressions.md#temporaries\n[unwinding]: panic.md#unwinding\n[variable]: variables.md\n\n[array]: types/array.md\n[enum variant]: types/enum.md\n[slice]: types/slice.md\n[struct]: types/struct.md\n[Trait objects]: types/trait-object.md\n[tuple]: types/tuple.md\n\n[or-patterns]: patterns.md#or-patterns\n[slice pattern]: patterns.md#slice-patterns\n[struct pattern]: patterns.md#struct-patterns\n[tuple pattern]: patterns.md#tuple-patterns\n[tuple struct pattern]: patterns.md#tuple-struct-patterns\n[tuple struct]: type.struct.tuple\n[tuple enum variant]: type.enum.declaration\n\n[array expression]: expressions/array-expr.md#array-expressions\n[array repeat operands]: expr.array.repeat-operand\n[async block expression]: expr.block.async\n[block expression]: expressions/block-expr.md\n[borrow]: expr.operator.borrow\n[cast expression]: expressions/operator-expr.md#type-cast-expressions\n[dereference expression]: expressions/operator-expr.md#the-dereference-operator\n[extended]: destructors.scope.lifetime-extension\n[field expression]: expressions/field-expr.md\n[indexing expression]: expressions/array-expr.md#array-and-slice-indexing-expressions\n[struct expression]: expressions/struct-expr.md\n[super macro call]: expr.super-macros\n[super operands]: expr.super-macros\n[super temporaries]: expr.super-macros\n[temporary scope]: destructors.scope.temporary\n[temporary scopes]: destructors.scope.temporary\n[tuple expression]: expressions/tuple-expr.md#tuple-expressions\n[tuple indexing expression]: expressions/tuple-expr.md#tuple-indexing-expressions\n\n[`for`]: expressions/loop-expr.md#iterator-loops\n[`if let`]: expressions/if-expr.md#if-let-patterns\n[`if`]: expressions/if-expr.md#if-expressions\n[`let` statement]: statements.md#let-statements\n[`loop`]: expressions/loop-expr.md#infinite-loops\n[`match`]: expressions/match-expr.md\n[`while let`]: expressions/loop-expr.md#while-let-patterns\n[`while`]: expressions/loop-expr.md#predicate-loops"
      }
    },
    {
      "id": "lifetime-elision",
      "title": "Lifetime elision",
      "level": 1,
      "content": "Rust has rules that allow lifetimes to be elided in various places where the\ncompiler can infer a sensible default choice.",
      "parent_id": null,
      "paragraphs": {
        "lifetime-elision": "Rust has rules that allow lifetimes to be elided in various places where the\ncompiler can infer a sensible default choice."
      }
    },
    {
      "id": "lifetime-elision.function",
      "title": "Lifetime elision in functions",
      "level": 1,
      "content": "In order to make common patterns more ergonomic, lifetime arguments can be\n*elided* in [function item], [function pointer], and [closure trait] signatures.\nThe following rules are used to infer lifetime parameters for elided lifetimes.\n\nIt is an error to elide lifetime parameters that cannot be inferred.\n\nThe placeholder lifetime, `'_`, can also be used to have a lifetime inferred in the\nsame way. For lifetimes in paths, using `'_` is preferred.\n\nTrait object lifetimes follow different rules discussed\nbelow.\n\n* Each elided lifetime in the parameters becomes a distinct lifetime parameter.\n\n* If there is exactly one lifetime used in the parameters (elided or not), that\n  lifetime is assigned to *all* elided output lifetimes.\n\nIn method signatures there is another rule\n\n* If the receiver has type `&Self`  or `&mut Self`, then the lifetime of that\n  reference to `Self` is assigned to all elided output lifetime parameters.\n\nExamples:\n\n# trait T {}\n# trait ToCStr {}\n# struct Thing<'a> {f: &'a i32}\n# struct Command;\n#\n# trait Example {\nfn print1(s: &str);                                   // elided\nfn print2(s: &'_ str);                                // also elided\nfn print3<'a>(s: &'a str);                            // expanded\n\nfn debug1(lvl: usize, s: &str);                       // elided\nfn debug2<'a>(lvl: usize, s: &'a str);                // expanded\n\nfn substr1(s: &str, until: usize) -> &str;            // elided\nfn substr2<'a>(s: &'a str, until: usize) -> &'a str;  // expanded\n\nfn get_mut1(&mut self) -> &mut dyn T;                 // elided\nfn get_mut2<'a>(&'a mut self) -> &'a mut dyn T;       // expanded\n\nfn args1<T: ToCStr>(&mut self, args: &[T]) -> &mut Command;                  // elided\nfn args2<'a, 'b, T: ToCStr>(&'a mut self, args: &'b [T]) -> &'a mut Command; // expanded\n\nfn other_args1<'a>(arg: &str) -> &'a str;             // elided\nfn other_args2<'a, 'b>(arg: &'b str) -> &'a str;      // expanded\n\nfn new1(buf: &mut [u8]) -> Thing<'_>;                 // elided - preferred\nfn new2(buf: &mut [u8]) -> Thing;                     // elided\nfn new3<'a>(buf: &'a mut [u8]) -> Thing<'a>;          // expanded\n# }\n\ntype FunPtr1 = fn(&str) -> &str;                      // elided\ntype FunPtr2 = for<'a> fn(&'a str) -> &'a str;        // expanded\n\ntype FunTrait1 = dyn Fn(&str) -> &str;                // elided\ntype FunTrait2 = dyn for<'a> Fn(&'a str) -> &'a str;  // expanded\n\n,compile_fail\n// The following examples show situations where it is not allowed to elide the\n// lifetime parameter.\n\n# trait Example {\n// Cannot infer, because there are no parameters to infer from.\nfn get_str() -> &str;                                 // ILLEGAL\n\n// Cannot infer, ambiguous if it is borrowed from the first or second parameter.\nfn frob(s: &str, t: &str) -> &str;                    // ILLEGAL\n# }",
      "parent_id": null,
      "paragraphs": {
        "lifetime-elision.function.intro": "In order to make common patterns more ergonomic, lifetime arguments can be\n*elided* in [function item], [function pointer], and [closure trait] signatures.\nThe following rules are used to infer lifetime parameters for elided lifetimes.",
        "lifetime-elision.function.lifetimes-not-inferred": "It is an error to elide lifetime parameters that cannot be inferred.",
        "lifetime-elision.function.explicit-placeholder": "The placeholder lifetime, `'_`, can also be used to have a lifetime inferred in the\nsame way. For lifetimes in paths, using `'_` is preferred.",
        "lifetime-elision.function.only-functions": "Trait object lifetimes follow different rules discussed\nbelow.",
        "lifetime-elision.function.implicit-lifetime-parameters": "* Each elided lifetime in the parameters becomes a distinct lifetime parameter.",
        "lifetime-elision.function.output-lifetime": "* If there is exactly one lifetime used in the parameters (elided or not), that\n  lifetime is assigned to *all* elided output lifetimes.",
        "lifetime-elision.function.receiver-lifetime": "In method signatures there is another rule\n\n* If the receiver has type `&Self`  or `&mut Self`, then the lifetime of that\n  reference to `Self` is assigned to all elided output lifetime parameters.\n\nExamples:\n\n# trait T {}\n# trait ToCStr {}\n# struct Thing<'a> {f: &'a i32}\n# struct Command;\n#\n# trait Example {\nfn print1(s: &str);                                   // elided\nfn print2(s: &'_ str);                                // also elided\nfn print3<'a>(s: &'a str);                            // expanded\n\nfn debug1(lvl: usize, s: &str);                       // elided\nfn debug2<'a>(lvl: usize, s: &'a str);                // expanded\n\nfn substr1(s: &str, until: usize) -> &str;            // elided\nfn substr2<'a>(s: &'a str, until: usize) -> &'a str;  // expanded\n\nfn get_mut1(&mut self) -> &mut dyn T;                 // elided\nfn get_mut2<'a>(&'a mut self) -> &'a mut dyn T;       // expanded\n\nfn args1<T: ToCStr>(&mut self, args: &[T]) -> &mut Command;                  // elided\nfn args2<'a, 'b, T: ToCStr>(&'a mut self, args: &'b [T]) -> &'a mut Command; // expanded\n\nfn other_args1<'a>(arg: &str) -> &'a str;             // elided\nfn other_args2<'a, 'b>(arg: &'b str) -> &'a str;      // expanded\n\nfn new1(buf: &mut [u8]) -> Thing<'_>;                 // elided - preferred\nfn new2(buf: &mut [u8]) -> Thing;                     // elided\nfn new3<'a>(buf: &'a mut [u8]) -> Thing<'a>;          // expanded\n# }\n\ntype FunPtr1 = fn(&str) -> &str;                      // elided\ntype FunPtr2 = for<'a> fn(&'a str) -> &'a str;        // expanded\n\ntype FunTrait1 = dyn Fn(&str) -> &str;                // elided\ntype FunTrait2 = dyn for<'a> Fn(&'a str) -> &'a str;  // expanded\n\n,compile_fail\n// The following examples show situations where it is not allowed to elide the\n// lifetime parameter.\n\n# trait Example {\n// Cannot infer, because there are no parameters to infer from.\nfn get_str() -> &str;                                 // ILLEGAL\n\n// Cannot infer, ambiguous if it is borrowed from the first or second parameter.\nfn frob(s: &str, t: &str) -> &str;                    // ILLEGAL\n# }"
      }
    },
    {
      "id": "lifetime-elision.trait-object",
      "title": "Default trait object lifetimes",
      "level": 1,
      "content": "The assumed lifetime of references held by a [trait object] is called its\n_default object lifetime bound_. These were defined in [RFC 599] and amended in\n[RFC 1156].\n\nThese default object lifetime bounds are used instead of the lifetime parameter\nelision rules defined above when the lifetime bound is omitted entirely.\n\nIf `'_` is used as the lifetime bound then the bound follows the usual elision\nrules.\n\nIf the trait object is used as a type argument of a generic type then the\ncontaining type is first used to try to infer a bound.\n\n* If there is a unique bound from the containing type then that is the default\n\n* If there is more than one bound from the containing type then an explicit\n  bound must be specified\n\nIf neither of those rules apply, then the bounds on the trait are used:\n\n* If the trait is defined with a single lifetime _bound_ then that bound is\n  used.\n\n* If `'static` is used for any lifetime bound then `'static` is used.\n\n* If the trait has no lifetime bounds, then the lifetime is inferred in\n  expressions and is `'static` outside of expressions.\n\n// For the following trait...\ntrait Foo { }\n\n// These two are the same because Box<T> has no lifetime bound on T\ntype T1 = Box<dyn Foo>;\ntype T2 = Box<dyn Foo + 'static>;\n\n// ...and so are these:\nimpl dyn Foo {}\nimpl dyn Foo + 'static {}\n\n// ...so are these, because &'a T requires T: 'a\ntype T3<'a> = &'a dyn Foo;\ntype T4<'a> = &'a (dyn Foo + 'a);\n\n// std::cell::Ref<'a, T> also requires T: 'a, so these are the same\ntype T5<'a> = std::cell::Ref<'a, dyn Foo>;\ntype T6<'a> = std::cell::Ref<'a, dyn Foo + 'a>;\n\n,compile_fail\n// This is an example of an error.\n# trait Foo { }\nstruct TwoBounds<'a, 'b, T: ?Sized + 'a + 'b> {\n    f1: &'a i32,\n    f2: &'b i32,\n    f3: T,\n}\ntype T7<'a, 'b> = TwoBounds<'a, 'b, dyn Foo>;\n//                                  ^^^^^^^\n// Error: the lifetime bound for this object type cannot be deduced from context\n\nNote that the innermost object sets the bound, so `&'a Box<dyn Foo>` is still\n`&'a Box<dyn Foo + 'static>`.\n\n// For the following trait...\ntrait Bar<'a>: 'a { }\n\n// ...these two are the same:\ntype T1<'a> = Box<dyn Bar<'a>>;\ntype T2<'a> = Box<dyn Bar<'a> + 'a>;\n\n// ...and so are these:\nimpl<'a> dyn Bar<'a> {}\nimpl<'a> dyn Bar<'a> + 'a {}",
      "parent_id": null,
      "paragraphs": {
        "lifetime-elision.trait-object.intro": "The assumed lifetime of references held by a [trait object] is called its\n_default object lifetime bound_. These were defined in [RFC 599] and amended in\n[RFC 1156].",
        "lifetime-elision.trait-object.explicit-bound": "These default object lifetime bounds are used instead of the lifetime parameter\nelision rules defined above when the lifetime bound is omitted entirely.",
        "lifetime-elision.trait-object.explicit-placeholder": "If `'_` is used as the lifetime bound then the bound follows the usual elision\nrules.",
        "lifetime-elision.trait-object.containing-type": "If the trait object is used as a type argument of a generic type then the\ncontaining type is first used to try to infer a bound.",
        "lifetime-elision.trait-object.containing-type-unique": "* If there is a unique bound from the containing type then that is the default",
        "lifetime-elision.trait-object.containing-type-explicit": "* If there is more than one bound from the containing type then an explicit\n  bound must be specified",
        "lifetime-elision.trait-object.trait-bounds": "If neither of those rules apply, then the bounds on the trait are used:",
        "lifetime-elision.trait-object.trait-unique": "* If the trait is defined with a single lifetime _bound_ then that bound is\n  used.",
        "lifetime-elision.trait-object.static-lifetime": "* If `'static` is used for any lifetime bound then `'static` is used.",
        "lifetime-elision.trait-object.default": "* If the trait has no lifetime bounds, then the lifetime is inferred in\n  expressions and is `'static` outside of expressions.\n\n// For the following trait...\ntrait Foo { }\n\n// These two are the same because Box<T> has no lifetime bound on T\ntype T1 = Box<dyn Foo>;\ntype T2 = Box<dyn Foo + 'static>;\n\n// ...and so are these:\nimpl dyn Foo {}\nimpl dyn Foo + 'static {}\n\n// ...so are these, because &'a T requires T: 'a\ntype T3<'a> = &'a dyn Foo;\ntype T4<'a> = &'a (dyn Foo + 'a);\n\n// std::cell::Ref<'a, T> also requires T: 'a, so these are the same\ntype T5<'a> = std::cell::Ref<'a, dyn Foo>;\ntype T6<'a> = std::cell::Ref<'a, dyn Foo + 'a>;\n\n,compile_fail\n// This is an example of an error.\n# trait Foo { }\nstruct TwoBounds<'a, 'b, T: ?Sized + 'a + 'b> {\n    f1: &'a i32,\n    f2: &'b i32,\n    f3: T,\n}\ntype T7<'a, 'b> = TwoBounds<'a, 'b, dyn Foo>;\n//                                  ^^^^^^^\n// Error: the lifetime bound for this object type cannot be deduced from context",
        "lifetime-elision.trait-object.innermost-type": "Note that the innermost object sets the bound, so `&'a Box<dyn Foo>` is still\n`&'a Box<dyn Foo + 'static>`.\n\n// For the following trait...\ntrait Bar<'a>: 'a { }\n\n// ...these two are the same:\ntype T1<'a> = Box<dyn Bar<'a>>;\ntype T2<'a> = Box<dyn Bar<'a> + 'a>;\n\n// ...and so are these:\nimpl<'a> dyn Bar<'a> {}\nimpl<'a> dyn Bar<'a> + 'a {}"
      }
    },
    {
      "id": "lifetime-elision.const-static",
      "title": "`const` and `static` elision",
      "level": 1,
      "content": "Both [constant] and [static] declarations of reference types have *implicit*\n`'static` lifetimes unless an explicit lifetime is specified. As such, the\nconstant declarations involving `'static` above may be written without the\nlifetimes.\n\n// STRING: &'static str\nconst STRING: &str = \"bitstring\";\n\nstruct BitsNStrings<'a> {\n    mybits: [u32; 2],\n    mystring: &'a str,\n}\n\n// BITS_N_STRINGS: BitsNStrings<'static>\nconst BITS_N_STRINGS: BitsNStrings<'_> = BitsNStrings {\n    mybits: [1, 2],\n    mystring: STRING,\n};\n\nNote that if the `static` or `const` items include function or closure\nreferences, which themselves include references, the compiler will first try\nthe standard elision rules. If it is unable to resolve the lifetimes by its\nusual rules, then it will error. By way of example:\n\n# struct Foo;\n# struct Bar;\n# struct Baz;\n# fn somefunc(a: &Foo, b: &Bar, c: &Baz) -> usize {42}\n// Resolved as `for<'a> fn(&'a str) -> &'a str`.\nconst RESOLVED_SINGLE: fn(&str) -> &str = |x| x;\n\n// Resolved as `for<'a, 'b, 'c> Fn(&'a Foo, &'b Bar, &'c Baz) -> usize`.\nconst RESOLVED_MULTIPLE: &dyn Fn(&Foo, &Bar, &Baz) -> usize = &somefunc;\n\n,compile_fail\n# struct Foo;\n# struct Bar;\n# struct Baz;\n# fn somefunc<'a,'b>(a: &'a Foo, b: &'b Bar) -> &'a Baz {unimplemented!()}\n// There is insufficient information to bound the return reference lifetime\n// relative to the argument lifetimes, so this is an error.\nconst RESOLVED_STATIC: &dyn Fn(&Foo, &Bar) -> &Baz = &somefunc;\n//                                            ^\n// this function's return type contains a borrowed value, but the signature\n// does not say whether it is borrowed from argument 1 or argument 2\n\n[closure trait]: types/closure.md\n[constant]: items/constant-items.md\n[function item]: types/function-item.md\n[function pointer]: types/function-pointer.md\n[RFC 599]: https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md\n[RFC 1156]: https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md\n[static]: items/static-items.md\n[trait object]: types/trait-object.md",
      "parent_id": null,
      "paragraphs": {
        "lifetime-elision.const-static.implicit-static": "Both [constant] and [static] declarations of reference types have *implicit*\n`'static` lifetimes unless an explicit lifetime is specified. As such, the\nconstant declarations involving `'static` above may be written without the\nlifetimes.\n\n// STRING: &'static str\nconst STRING: &str = \"bitstring\";\n\nstruct BitsNStrings<'a> {\n    mybits: [u32; 2],\n    mystring: &'a str,\n}\n\n// BITS_N_STRINGS: BitsNStrings<'static>\nconst BITS_N_STRINGS: BitsNStrings<'_> = BitsNStrings {\n    mybits: [1, 2],\n    mystring: STRING,\n};",
        "lifetime-elision.const-static.fn-references": "Note that if the `static` or `const` items include function or closure\nreferences, which themselves include references, the compiler will first try\nthe standard elision rules. If it is unable to resolve the lifetimes by its\nusual rules, then it will error. By way of example:\n\n# struct Foo;\n# struct Bar;\n# struct Baz;\n# fn somefunc(a: &Foo, b: &Bar, c: &Baz) -> usize {42}\n// Resolved as `for<'a> fn(&'a str) -> &'a str`.\nconst RESOLVED_SINGLE: fn(&str) -> &str = |x| x;\n\n// Resolved as `for<'a, 'b, 'c> Fn(&'a Foo, &'b Bar, &'c Baz) -> usize`.\nconst RESOLVED_MULTIPLE: &dyn Fn(&Foo, &Bar, &Baz) -> usize = &somefunc;\n\n,compile_fail\n# struct Foo;\n# struct Bar;\n# struct Baz;\n# fn somefunc<'a,'b>(a: &'a Foo, b: &'b Bar) -> &'a Baz {unimplemented!()}\n// There is insufficient information to bound the return reference lifetime\n// relative to the argument lifetimes, so this is an error.\nconst RESOLVED_STATIC: &dyn Fn(&Foo, &Bar) -> &Baz = &somefunc;\n//                                            ^\n// this function's return type contains a borrowed value, but the signature\n// does not say whether it is borrowed from argument 1 or argument 2\n\n[closure trait]: types/closure.md\n[constant]: items/constant-items.md\n[function item]: types/function-item.md\n[function pointer]: types/function-pointer.md\n[RFC 599]: https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md\n[RFC 1156]: https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md\n[static]: items/static-items.md\n[trait object]: types/trait-object.md"
      }
    }
  ],
  "ids": [
    "type.fn-item.traits",
    "type.never.syntax",
    "layout.properties.align",
    "type.tuple.syntax",
    "subtyping.variance.user-composite-types",
    "type.union.access",
    "lifetime-elision.function.output-lifetime",
    "layout.properties",
    "layout.repr.intro",
    "coerce.unsize.trait",
    "destructors.scope.lifetime-extension.sub-expressions",
    "type.kinds",
    "lifetime-elision.trait-object.static-lifetime",
    "type.fn-pointer.coercion",
    "type.impl-trait.return.intro",
    "type.impl-trait.generic-capture.precise.use",
    "type.closure.capture.precision.range-patterns",
    "layout.repr.alignment.constraint-exclusive",
    "lifetime-elision",
    "type.bool.expr.xor",
    "interior-mut.ref-cell",
    "coerce.site.let",
    "subtyping.variance.builtin-types",
    "interior-mut",
    "type.closure.capture.precision.wildcard.fields",
    "coerce.site.repeat",
    "destructors.scope.lifetime-extension.let",
    "destructors.scope.lifetime-extension.exprs.borrows",
    "type.enum.intro",
    "lifetime-elision.trait-object.explicit-bound",
    "layout.repr.alignment.align",
    "type.bool.expr.cmp.less-eq",
    "type.closure.capture.copy",
    "type.impl-trait",
    "subtype",
    "bound.intro",
    "bound.higher-ranked.syntax",
    "destructors.scope.params",
    "type.bool.literal",
    "layout.repr.c.struct",
    "type.impl-trait.generic-capture.auto.intro",
    "coerce.types.intro",
    "type.builtin",
    "type.trait-object.syntax-edition2018",
    "layout.tuple",
    "layout.repr.c.struct.align",
    "destructors.manually-suppressing",
    "layout.repr.transparent.layout-abi",
    "lifetime-elision.trait-object.intro",
    "type.numeric.int.size.usize",
    "type.pointer.reference.shared.constraint-mutation",
    "subtype.higher-ranked",
    "bound.implied",
    "bound.higher-ranked.intro",
    "type.closure.capture.precision.edition2018.composite",
    "layout.repr.c",
    "coerce.unsize",
    "destructors.scope.bindings.intro",
    "lifetime-elision.function",
    "lifetime-elision.trait-object.containing-type-explicit",
    "type.bool.expr.not",
    "type.fn-pointer",
    "type.fn-pointer.constraint-variadic",
    "layout.repr.transparent.constraint-field",
    "layout.guarantees",
    "type.closure.capture.precision.box-non-move.moved",
    "layout.tuple.general",
    "type.struct.intro",
    "bound.lifetime",
    "type.impl-trait.return-in-trait",
    "type.layout.char-layout",
    "type.pointer.intro",
    "bound.lifetime.outlive-type",
    "layout.pointer.thin",
    "type.pointer.reference.mut.copy",
    "layout.repr.alignment.constraint-alignment",
    "destructors.operation",
    "type.generic",
    "layout.repr.c.union",
    "layout",
    "type.closure.intro",
    "type.bool.repr",
    "destructors.scope.temporary.edition2024",
    "type.text.str-value",
    "type.fn-item.unique",
    "destructors.scope.nesting.function-body",
    "type.text.char-precondition",
    "type.tuple.field-number",
    "coerce.least-upper-bound.computation-replace",
    "type.closure.capture.precision.slice-patterns",
    "lifetime-elision.function.explicit-placeholder",
    "layout.repr.attribute",
    "destructors.scope.lifetime-extension.exprs.super-macros",
    "type.pointer.reference",
    "type.name.parenthesized.intro",
    "coerce.least-upper-bound.intro",
    "dynamic-sized",
    "type.trait-object",
    "destructors.scope.temporary.intro",
    "type.closure.capture.precision.edition2018.wildcard",
    "type.closure.async.input",
    "type.bool.namespace",
    "bound.higher-ranked.trait",
    "bound.implied.context",
    "layout.repr",
    "type.bool.expr.cmp.less",
    "type.bool.expr.cmp.not-eq",
    "type.tuple.access",
    "destructors.scope.list",
    "type.fn-item.name",
    "layout.repr.align-packed",
    "coerce.site.value",
    "subtyping.variance.builtin-composite-types",
    "type.slice.intro",
    "destructors.scope",
    "type.impl-trait.return-in-trait.intro",
    "type.pointer",
    "layout.repr.c.intro",
    "type.closure.capture.precision.range-patterns.reads",
    "type.struct.constructor",
    "type.closure.capture.precision.box-deref",
    "layout.repr.rust.intro",
    "type.pointer.raw",
    "type.array.index",
    "type.array.syntax",
    "type.trait-object.intro",
    "destructors.scope.temporary",
    "type.impl-trait.generic-capture.precise",
    "layout.closure",
    "type.name.pointer",
    "type.closure.capture.precision.discriminants.single-variant",
    "type.numeric.int.size.isize",
    "lifetime-elision.function.receiver-lifetime",
    "type.name.parenthesized.syntax",
    "layout.trait-object",
    "layout.pointer",
    "type.enum.name",
    "bound.lifetime.outlive-lifetime",
    "coerce.site.return",
    "type.pointer.reference.shared",
    "destructors.scope.bindings.patterns",
    "layout.repr.alignment.enum",
    "coerce.unsized.composite",
    "type.closure.capture.precision.discriminants.multiple-variant",
    "type.pointer.raw.constructor",
    "lifetime-elision.function.only-functions",
    "layout.repr.primitive-c",
    "type.struct.layout",
    "layout.repr.c.adt.tag",
    "bound.use",
    "lifetime-elision.trait-object",
    "type.numeric.int.unsigned",
    "type.pointer.reference.shared.intro",
    "type.pointer.raw.intro",
    "coerce.unsize.intro",
    "type.closure.call.fn",
    "type.closure.traits",
    "type.recursive.constraint",
    "type.closure.capture.precision.wildcard.initialized",
    "type.impl-trait.generic-captures",
    "interior-mut.unsafe-cell",
    "coerce.site.block",
    "destructors.scope.nesting.expr-statement",
    "type.name",
    "destructors.scope.expression",
    "type.name.syntax",
    "lifetime-elision.trait-object.containing-type",
    "coerce.types.deref-mut",
    "coerce.unsize.trait-upcast",
    "coerce",
    "type.impl-trait.syntax",
    "destructors.scope.bindings",
    "type.tuple.intro",
    "type.bool.usage-lazy-operator",
    "type.pointer.reference.mut",
    "type.intro",
    "bound.trait-object",
    "type.struct",
    "type.bool.expr.cmp",
    "type.pointer.raw.cmp",
    "subtyping.variance.intro",
    "type.impl-trait.param",
    "interior-mut.no-constraint",
    "type.closure.non-capturing",
    "type.name.parenthesized",
    "type.bool.expr.or",
    "type.impl-trait.generic-capture.edition2024",
    "destructors",
    "type.numeric.int.size",
    "type.pointer.validity.pointer-fragment",
    "type.fn-pointer.syntax",
    "layout.repr.kinds",
    "type.struct.field-visibility",
    "type.recursive.intro",
    "type.closure.traits.behavior",
    "destructors.scope.lifetime-extension.patterns.extending",
    "bound.satisfaction",
    "coerce.site.intro",
    "type.union.constraint",
    "type.name.macro-expansion",
    "type.trait-object.alias",
    "dynamic-sized.intro",
    "type.fn-item.intro",
    "type.closure.call.fn-mut",
    "type.bool.expr.cmp.eq",
    "type.enum.declaration",
    "coerce.types.ref-to-pointer",
    "type.bool.usage",
    "type.tuple.restriction",
    "layout.primitive",
    "layout.repr.c.constraint",
    "type.enum.value",
    "destructors.scope.lifetime-extension.patterns.let",
    "layout.repr.c.enum",
    "type.name.never",
    "type.impl-trait.return",
    "layout.repr.transparent.constraint-exclusive",
    "type.closure.capture.precision.discriminants.uninhabited-variants",
    "type.closure.capture.precedence",
    "layout.pointer.intro",
    "type.trait-object.name",
    "destructors.scope.nesting.match",
    "coerce.unsize.slice",
    "type.pointer.validity",
    "type.array.intro",
    "type.array",
    "layout.repr.primitive.enum",
    "type.pointer.raw.copy",
    "layout.repr.rust.alignment",
    "coerce.least-upper-bound.computation-unify",
    "type_system_p1",
    "type.numeric",
    "type.pointer.raw.syntax",
    "type.numeric.int",
    "type.bool.expr.cmp.greater-eq",
    "type.bool.validity",
    "type.impl-trait.param.intro",
    "type.fn-item.coercion",
    "layout.repr.primitive.adt",
    "type.impl-trait.constraint",
    "type.closure.capture.precision.shared-prefix",
    "destructors.scope.lifetime-extension.patterns",
    "type.trait-object.impls",
    "type.bool.expr.and",
    "type.closure.capture.precision.slice-patterns.arrays",
    "layout.repr.rust.layout",
    "dynamic-sized.pointer-types",
    "lifetime-elision.const-static.fn-references",
    "type.closure.capture.precision.edition2018.drop-order",
    "type.closure.capture.precision.box-move.read",
    "destructors.drop_in_place",
    "bound.higher-ranked",
    "type.trait-object.unsized",
    "type.user-defined",
    "destructors.scope.intro",
    "type.tuple.field-name",
    "type.never.constraint",
    "destructors.scope.nesting.statement",
    "type.closure.capture.precision.dereference-shared",
    "type.recursive",
    "type.layout.char-validity",
    "layout.str",
    "destructors.forget",
    "type.never.intro",
    "lifetime-elision.function.implicit-lifetime-parameters",
    "type.fn-pointer.qualifiers",
    "lifetime-elision.function.intro",
    "type.name.intro",
    "destructors.scope.block",
    "type.struct.unit",
    "type",
    "coerce.least-upper-bound.computation-identity",
    "type.inferred.syntax",
    "type.closure.capture.intro",
    "type.tuple.constructor",
    "subtype.intro",
    "bound.lifetime.intro",
    "dynamic-sized.restriction",
    "coerce.site.constructor",
    "interior-mut.intro",
    "coerce.least-upper-bound",
    "type.closure.capture.precision.unaligned",
    "type.closure.capture.precision.discriminants.reads",
    "lifetime-elision.const-static.implicit-static",
    "type.pointer.validity.raw",
    "type.closure.capture.precision.raw-pointer-dereference",
    "dynamic-sized.trait-impl",
    "lifetime-elision.trait-object.innermost-type",
    "type.bool.expr.cmp.greater",
    "type.closure.capture.precision.discriminants",
    "type.numeric.float",
    "layout.repr.alignment.intro",
    "layout.repr.c.adt.intro",
    "type.bool.layout",
    "type.tuple.unit",
    "type.struct.tuple",
    "type.bool.traits",
    "type.closure.async.traits",
    "interior-mut.atomic",
    "layout.intro",
    "lifetime-elision.trait-object.trait-unique",
    "destructors.scope.nesting.other",
    "destructors.scope.desugaring",
    "interior-mut.mut-unsafe-cell",
    "type.union.safety",
    "destructors.scope.nesting.let-initializer",
    "coerce.site.array",
    "type.closure.capture.precision.move-dereference",
    "type.inferred.constraint",
    "coerce.types",
    "coerce.types.transitive",
    "layout.primitive.align",
    "layout.repr.c.adt.fields",
    "lifetime-elision.trait-object.trait-bounds",
    "layout.repr.rust.unspecified",
    "coerce.site.subexpr",
    "dynamic-sized.question-sized",
    "destructors.scope.temporary.enclosing",
    "coerce.unsized.pointer",
    "layout.repr.alignment.packed-padding",
    "lifetime-elision.function.lifetimes-not-inferred",
    "layout.tuple.unit",
    "type.inferred",
    "type.impl-trait.param.generic",
    "type.inferred.intro",
    "destructors.scope.nesting",
    "type.name.sequence",
    "type.bool.intro",
    "type.numeric.int.signed",
    "type.fn-pointer.intro",
    "type.closure.async.traits.fn-family",
    "coerce.types.closure",
    "type.union.layout",
    "type.closure.capture.precision.discriminants.non_exhaustive",
    "type.fn-pointer.attributes",
    "destructors.scope.match-arm",
    "type.closure.traits.intro",
    "coerce.site.parenthesis",
    "type.bool",
    "layout.repr.transparent",
    "destructors.scope.bindings.or-patterns",
    "type.closure.capture.precision.wildcard.reads",
    "type.trait-object.constraint",
    "layout.repr.c.union.size-align",
    "destructors.scope.statement",
    "destructors.scope.lifetime-extension.exprs",
    "destructors.scope.operands",
    "type.closure.capture.precision.capture-path",
    "type.closure.capture.precision.edition2018.move",
    "layout.properties.size",
    "destructors.scope.operators",
    "type.name.inference",
    "type.closure",
    "coerce.as",
    "coerce.types.fn",
    "type.slice",
    "layout.repr.c.adt",
    "coerce.site.tuple",
    "type.closure.capture.precision.wildcard",
    "type.text",
    "interior-mut.shared-ref",
    "subtype.kinds",
    "type.bool.expr",
    "type.enum",
    "type.bool.usage-condition",
    "type.slice.safe",
    "type.closure.capture.precision.slice-patterns.slices",
    "layout.repr.alignment",
    "layout.pointer.unsized",
    "type.closure.capture.precision.place-projection",
    "destructors.scope.function",
    "type.closure.capture.precision.wildcard.destructuring",
    "type.pointer.reference.syntax",
    "type.name.grouped",
    "type.array.constraint",
    "type.pointer.raw.safety",
    "layout.repr.c.union.intro",
    "destructors.scope.nesting.match-guard",
    "subtyping.variance.covariant",
    "type.slice.unsized",
    "type.closure.capture.precision.edition2018.entirety",
    "coerce.site",
    "coerce.least-upper-bound.computation",
    "layout.repr.primitive",
    "lifetime-elision.trait-object.default",
    "type.impl-trait.generic-capture.precise.constraint-lifetime",
    "type.impl-trait.intro",
    "layout.repr.rust.field-storage",
    "subtyping.variance.invariant",
    "subtyping.variance",
    "coerce.types.never",
    "coerce.types.reflexive",
    "bound.syntax",
    "coerce.least-upper-bound.target",
    "type.enum.constructor",
    "type.closure.capture.precision.box-non-move.not-moved",
    "type.text.intro",
    "bound.trivial",
    "type.closure.drop-order",
    "destructors.scope.lifetime-extension.static",
    "type.slice.syntax",
    "type.name.trait",
    "lifetime-elision.trait-object.explicit-placeholder",
    "layout.repr.alignment.packed-fields",
    "type.trait-object.lifetime-bounds",
    "layout.repr.inter-field",
    "type.impl-trait.generic-capture.auto",
    "type.closure.capture",
    "type.numeric.validity",
    "type.text.layout",
    "destructors.scope.const-promotion",
    "type.union",
    "destructors.intro",
    "destructors.process-termination",
    "lifetime-elision.const-static",
    "type.union.intro",
    "type.closure.capture.precision.intro",
    "layout.primitive.size-int",
    "type.closure.async.traits.async-family",
    "interior-mut.abstraction",
    "layout.repr.rust",
    "dynamic-sized.struct-field",
    "type.impl-trait.generic-capture.precise.constraint-param-impl-trait",
    "type.pointer.reference.shared.copy",
    "layout.repr.alignment.packed",
    "bound.implied.def",
    "lifetime-elision.trait-object.containing-type-unique",
    "type.trait-object.syntax",
    "type.impl-trait.return-in-trait.desugaring",
    "bound.sized",
    "layout.repr.primitive.intro",
    "layout.repr.c.struct.size-field-offset",
    "type_system",
    "type.impl-trait.generic-capture.precise.constraint-in-trait",
    "layout.slice",
    "type.fn-item",
    "coerce.types.mut-reborrow",
    "type.pointer.smart",
    "bound.implied.trait",
    "type.closure.call.intro",
    "type.tuple",
    "coerce.types.mut-to-pointer",
    "destructors.scope.lifetime-extension.exprs.extending",
    "type.impl-trait.return.constraint-body",
    "type.closure.capture.precision.union",
    "destructors.scope.lifetime-extension",
    "coerce.intro",
    "bound",
    "coerce.unsize.trait-object",
    "type.pointer.reference.mut.intro",
    "type.impl-trait.generic-capture.precise.constraint-single",
    "destructors.scope.nesting.function",
    "type.trait-object.syntax-edition2021",
    "bound.implied.intro",
    "subtyping.variance.contravariant",
    "type.name.path",
    "coerce.types.unsize",
    "destructors.scope.nesting.match-arm",
    "type.closure.capture.precision.wildcard.array-slice",
    "type.closure.call",
    "bound.special",
    "coerce.types.mut-pointer",
    "layout.properties.sized",
    "type.text.char-value",
    "type.never",
    "coerce.types.deref",
    "type.never.coercion",
    "type.closure.unique-immutable",
    "layout.array",
    "type.numeric.int.size.minimum",
    "layout.primitive.size",
    "type.text.str-unsized",
    "layout.repr.primitive.constraint",
    "coerce.site.argument"
  ]
}
