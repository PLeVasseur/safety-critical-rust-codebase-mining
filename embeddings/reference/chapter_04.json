{
  "source": "Rust Reference",
  "source_repo": "https://github.com/rust-lang/reference",
  "extraction_date": "2026-01-03",
  "chapter": 4,
  "title": "Macros",
  "file": "macros.md",
  "sections": [
    {
      "id": "macro",
      "title": "Macros",
      "level": 1,
      "content": "",
      "parent_id": null,
      "paragraphs": {}
    },
    {
      "id": "macro.intro",
      "title": "Macros",
      "level": 1,
      "content": "The functionality and syntax of Rust can be extended with custom definitions\ncalled macros. They are given names, and invoked through a consistent\nsyntax: `some_extension!(...)`.\n\nThere are two ways to define new macros:\n\n* [Macros by Example] define new syntax in a higher-level, declarative way.\n* [Procedural Macros] define function-like macros, custom derives, and custom\n  attributes using functions that operate on input tokens.",
      "parent_id": null,
      "paragraphs": {
        "macro.intro": "The functionality and syntax of Rust can be extended with custom definitions\ncalled macros. They are given names, and invoked through a consistent\nsyntax: `some_extension!(...)`.\n\nThere are two ways to define new macros:\n\n* [Macros by Example] define new syntax in a higher-level, declarative way.\n* [Procedural Macros] define function-like macros, custom derives, and custom\n  attributes using functions that operate on input tokens."
      }
    },
    {
      "id": "macro.invocation",
      "title": "Macro invocation",
      "level": 1,
      "content": ",macros\nMacroInvocation ->\n    SimplePath `!` DelimTokenTree\n\nDelimTokenTree ->\n      `(` TokenTree* `)`\n    | `[` TokenTree* `]`\n    | `{` TokenTree* `}`\n\nTokenTree ->\n    Token _except delimiters_ | DelimTokenTree\n\nMacroInvocationSemi ->\n      SimplePath `!` `(` TokenTree* `)` `;`\n    | SimplePath `!` `[` TokenTree* `]` `;`\n    | SimplePath `!` `{` TokenTree* `}`\n\nA macro invocation expands a macro at compile time and replaces the\ninvocation with the result of the macro. Macros may be invoked in the\nfollowing situations:\n\n* [Expressions] and [statements]\n\n* [Patterns]\n\n* [Types]\n\n* [Items] including [associated items]\n\n* [`macro_rules`] transcribers\n\n* [External blocks]\n\nWhen used as an item or a statement, the [MacroInvocationSemi] form is used\nwhere a semicolon is required at the end when not using curly braces.\n[Visibility qualifiers] are never allowed before a macro invocation or\n[`macro_rules`] definition.\n\n// Used as an expression.\nlet x = vec![1,2,3];\n\n// Used as a statement.\nprintln!(\"Hello!\");\n\n// Used in a pattern.\nmacro_rules! pat {\n    ($i:ident) => (Some($i))\n}\n\nif let pat!(x) = Some(1) {\n    assert_eq!(x, 1);\n}\n\n// Used in a type.\nmacro_rules! Tuple {\n    { $A:ty, $B:ty } => { ($A, $B) };\n}\n\ntype N2 = Tuple!(i32, i32);\n\n// Used as an item.\n# use std::cell::RefCell;\nthread_local!(static FOO: RefCell<u32> = RefCell::new(1));\n\n// Used as an associated item.\nmacro_rules! const_maker {\n    ($t:ty, $v:tt) => { const CONST: $t = $v; };\n}\ntrait T {\n    const_maker!{i32, 7}\n}\n\n// Macro calls within macros.\nmacro_rules! example {\n    () => { println!(\"Macro call in a macro!\") };\n}\n// Outer macro `example` is expanded, then inner macro `println` is expanded.\nexample!();\n\nMacros invocations can be resolved via two kinds of scopes:\n\n- Textual Scope\n  - Textual scope `macro_rules`\n- Path-based scope\n  - Path-based scope `macro_rules`\n  - [Procedural macros]\n\n[External blocks]: items/external-blocks.md\n[Macros by Example]: macros-by-example.md\n[Procedural Macros]: procedural-macros.md\n[`macro_rules`]: macros-by-example.md\n[associated items]: items/associated-items.md\n[delimiters]: tokens.md#delimiters\n[expressions]: expressions.md\n[items]: items.md\n[patterns]: patterns.md\n[statements]: statements.md\n[types]: types.md\n[visibility qualifiers]: visibility-and-privacy.md",
      "parent_id": null,
      "paragraphs": {
        "macro.invocation.syntax": ",macros\nMacroInvocation ->\n    SimplePath `!` DelimTokenTree\n\nDelimTokenTree ->\n      `(` TokenTree* `)`\n    | `[` TokenTree* `]`\n    | `{` TokenTree* `}`\n\nTokenTree ->\n    Token _except delimiters_ | DelimTokenTree\n\nMacroInvocationSemi ->\n      SimplePath `!` `(` TokenTree* `)` `;`\n    | SimplePath `!` `[` TokenTree* `]` `;`\n    | SimplePath `!` `{` TokenTree* `}`",
        "macro.invocation.intro": "A macro invocation expands a macro at compile time and replaces the\ninvocation with the result of the macro. Macros may be invoked in the\nfollowing situations:",
        "macro.invocation.expr": "* [Expressions] and [statements]",
        "macro.invocation.pattern": "* [Patterns]",
        "macro.invocation.type": "* [Types]",
        "macro.invocation.item": "* [Items] including [associated items]",
        "macro.invocation.nested": "* [`macro_rules`] transcribers",
        "macro.invocation.extern": "* [External blocks]",
        "macro.invocation.item-statement": "When used as an item or a statement, the [MacroInvocationSemi] form is used\nwhere a semicolon is required at the end when not using curly braces.\n[Visibility qualifiers] are never allowed before a macro invocation or\n[`macro_rules`] definition.\n\n// Used as an expression.\nlet x = vec![1,2,3];\n\n// Used as a statement.\nprintln!(\"Hello!\");\n\n// Used in a pattern.\nmacro_rules! pat {\n    ($i:ident) => (Some($i))\n}\n\nif let pat!(x) = Some(1) {\n    assert_eq!(x, 1);\n}\n\n// Used in a type.\nmacro_rules! Tuple {\n    { $A:ty, $B:ty } => { ($A, $B) };\n}\n\ntype N2 = Tuple!(i32, i32);\n\n// Used as an item.\n# use std::cell::RefCell;\nthread_local!(static FOO: RefCell<u32> = RefCell::new(1));\n\n// Used as an associated item.\nmacro_rules! const_maker {\n    ($t:ty, $v:tt) => { const CONST: $t = $v; };\n}\ntrait T {\n    const_maker!{i32, 7}\n}\n\n// Macro calls within macros.\nmacro_rules! example {\n    () => { println!(\"Macro call in a macro!\") };\n}\n// Outer macro `example` is expanded, then inner macro `println` is expanded.\nexample!();",
        "macro.invocation.name-resolution": "Macros invocations can be resolved via two kinds of scopes:\n\n- Textual Scope\n  - Textual scope `macro_rules`\n- Path-based scope\n  - Path-based scope `macro_rules`\n  - [Procedural macros]\n\n[External blocks]: items/external-blocks.md\n[Macros by Example]: macros-by-example.md\n[Procedural Macros]: procedural-macros.md\n[`macro_rules`]: macros-by-example.md\n[associated items]: items/associated-items.md\n[delimiters]: tokens.md#delimiters\n[expressions]: expressions.md\n[items]: items.md\n[patterns]: patterns.md\n[statements]: statements.md\n[types]: types.md\n[visibility qualifiers]: visibility-and-privacy.md"
      }
    },
    {
      "id": "macro.decl",
      "title": "Macros by example",
      "level": 1,
      "content": ",macros\nMacroRulesDefinition ->\n    `macro_rules` `!` IDENTIFIER MacroRulesDef\n\nMacroRulesDef ->\n      `(` MacroRules `)` `;`\n    | `[` MacroRules `]` `;`\n    | `{` MacroRules `}`\n\nMacroRules ->\n    MacroRule ( `;` MacroRule )* `;`?\n\nMacroRule ->\n    MacroMatcher `=>` MacroTranscriber\n\nMacroMatcher ->\n      `(` MacroMatch* `)`\n    | `[` MacroMatch* `]`\n    | `{` MacroMatch* `}`\n\nMacroMatch ->\n      Token _except `$` and delimiters_\n    | MacroMatcher\n    | `$` ( IDENTIFIER_OR_KEYWORD _except `crate`_ | RAW_IDENTIFIER ) `:` MacroFragSpec\n    | `$` `(` MacroMatch+ `)` MacroRepSep? MacroRepOp\n\nMacroFragSpec ->\n      `block` | `expr` | `expr_2021` | `ident` | `item` | `lifetime` | `literal`\n    | `meta` | `pat` | `pat_param` | `path` | `stmt` | `tt` | `ty` | `vis`\n\nMacroRepSep -> Token _except delimiters and [MacroRepOp]_\n\nMacroRepOp -> `*` | `+` | `?`\n\nMacroTranscriber -> DelimTokenTree\n\n`macro_rules` allows users to define syntax extension in a declarative way.  We\ncall such extensions \"macros by example\" or simply \"macros\".\n\nEach macro by example has a name, and one or more _rules_. Each rule has two\nparts: a _matcher_, describing the syntax that it matches, and a _transcriber_,\ndescribing the syntax that will replace a successfully matched invocation. Both\nthe matcher and the transcriber must be surrounded by delimiters. Macros can\nexpand to expressions, statements, items (including traits, impls, and foreign\nitems), types, or patterns.",
      "parent_id": null,
      "paragraphs": {
        "macro.decl.syntax": ",macros\nMacroRulesDefinition ->\n    `macro_rules` `!` IDENTIFIER MacroRulesDef\n\nMacroRulesDef ->\n      `(` MacroRules `)` `;`\n    | `[` MacroRules `]` `;`\n    | `{` MacroRules `}`\n\nMacroRules ->\n    MacroRule ( `;` MacroRule )* `;`?\n\nMacroRule ->\n    MacroMatcher `=>` MacroTranscriber\n\nMacroMatcher ->\n      `(` MacroMatch* `)`\n    | `[` MacroMatch* `]`\n    | `{` MacroMatch* `}`\n\nMacroMatch ->\n      Token _except `$` and delimiters_\n    | MacroMatcher\n    | `$` ( IDENTIFIER_OR_KEYWORD _except `crate`_ | RAW_IDENTIFIER ) `:` MacroFragSpec\n    | `$` `(` MacroMatch+ `)` MacroRepSep? MacroRepOp\n\nMacroFragSpec ->\n      `block` | `expr` | `expr_2021` | `ident` | `item` | `lifetime` | `literal`\n    | `meta` | `pat` | `pat_param` | `path` | `stmt` | `tt` | `ty` | `vis`\n\nMacroRepSep -> Token _except delimiters and [MacroRepOp]_\n\nMacroRepOp -> `*` | `+` | `?`\n\nMacroTranscriber -> DelimTokenTree",
        "macro.decl.intro": "`macro_rules` allows users to define syntax extension in a declarative way.  We\ncall such extensions \"macros by example\" or simply \"macros\".\n\nEach macro by example has a name, and one or more _rules_. Each rule has two\nparts: a _matcher_, describing the syntax that it matches, and a _transcriber_,\ndescribing the syntax that will replace a successfully matched invocation. Both\nthe matcher and the transcriber must be surrounded by delimiters. Macros can\nexpand to expressions, statements, items (including traits, impls, and foreign\nitems), types, or patterns."
      }
    },
    {
      "id": "macro.decl.transcription",
      "title": "Transcribing",
      "level": 1,
      "content": "When a macro is invoked, the macro expander looks up macro invocations by name,\nand tries each macro rule in turn. It transcribes the first successful match; if\nthis results in an error, then future matches are not tried.\n\nWhen matching, no lookahead is performed; if the compiler cannot unambiguously determine how to\nparse the macro invocation one token at a time, then it is an error. In the\nfollowing example, the compiler does not look ahead past the identifier to see\nif the following token is a `)`, even though that would allow it to parse the\ninvocation unambiguously:\n\n,compile_fail\nmacro_rules! ambiguity {\n    ($($i:ident)* $j:ident) => { };\n}\n\nambiguity!(error); // Error: local ambiguity\n\nIn both the matcher and the transcriber, the `$` token is used to invoke special\nbehaviours from the macro engine (described below in [Metavariables] and\n[Repetitions]). Tokens that aren't part of such an invocation are matched and\ntranscribed literally, with one exception. The exception is that the outer\ndelimiters for the matcher will match any pair of delimiters. Thus, for\ninstance, the matcher `(())` will match `{()}` but not `{{}}`. The character\n`$` cannot be matched or transcribed literally.",
      "parent_id": null,
      "paragraphs": {
        "macro.decl.transcription.intro": "When a macro is invoked, the macro expander looks up macro invocations by name,\nand tries each macro rule in turn. It transcribes the first successful match; if\nthis results in an error, then future matches are not tried.",
        "macro.decl.transcription.lookahead": "When matching, no lookahead is performed; if the compiler cannot unambiguously determine how to\nparse the macro invocation one token at a time, then it is an error. In the\nfollowing example, the compiler does not look ahead past the identifier to see\nif the following token is a `)`, even though that would allow it to parse the\ninvocation unambiguously:\n\n,compile_fail\nmacro_rules! ambiguity {\n    ($($i:ident)* $j:ident) => { };\n}\n\nambiguity!(error); // Error: local ambiguity",
        "macro.decl.transcription.syntax": "In both the matcher and the transcriber, the `$` token is used to invoke special\nbehaviours from the macro engine (described below in [Metavariables] and\n[Repetitions]). Tokens that aren't part of such an invocation are matched and\ntranscribed literally, with one exception. The exception is that the outer\ndelimiters for the matcher will match any pair of delimiters. Thus, for\ninstance, the matcher `(())` will match `{()}` but not `{{}}`. The character\n`$` cannot be matched or transcribed literally."
      }
    },
    {
      "id": "macro.decl.transcription.fragment",
      "title": "Forwarding a matched fragment",
      "level": 2,
      "content": "When forwarding a matched fragment to another macro-by-example, matchers in\nthe second macro will see an opaque AST of the fragment type. The second macro\ncan't use literal tokens to match the fragments in the matcher, only a\nfragment specifier of the same type. The `ident`, `lifetime`, and `tt`\nfragment types are an exception, and *can* be matched by literal tokens. The\nfollowing illustrates this restriction:\n\n,compile_fail\nmacro_rules! foo {\n    ($l:expr) => { bar!($l); }\n// ERROR:               ^^ no rules expected this token in macro call\n}\n\nmacro_rules! bar {\n    (3) => {}\n}\n\nfoo!(3);\n\nThe following illustrates how tokens can be directly matched after matching a\n`tt` fragment:\n\n// compiles OK\nmacro_rules! foo {\n    ($l:tt) => { bar!($l); }\n}\n\nmacro_rules! bar {\n    (3) => {}\n}\n\nfoo!(3);",
      "parent_id": null,
      "paragraphs": {
        "macro.decl.transcription.fragment": "When forwarding a matched fragment to another macro-by-example, matchers in\nthe second macro will see an opaque AST of the fragment type. The second macro\ncan't use literal tokens to match the fragments in the matcher, only a\nfragment specifier of the same type. The `ident`, `lifetime`, and `tt`\nfragment types are an exception, and *can* be matched by literal tokens. The\nfollowing illustrates this restriction:\n\n,compile_fail\nmacro_rules! foo {\n    ($l:expr) => { bar!($l); }\n// ERROR:               ^^ no rules expected this token in macro call\n}\n\nmacro_rules! bar {\n    (3) => {}\n}\n\nfoo!(3);\n\nThe following illustrates how tokens can be directly matched after matching a\n`tt` fragment:\n\n// compiles OK\nmacro_rules! foo {\n    ($l:tt) => { bar!($l); }\n}\n\nmacro_rules! bar {\n    (3) => {}\n}\n\nfoo!(3);"
      }
    },
    {
      "id": "macro.decl.meta",
      "title": "Metavariables",
      "level": 3,
      "content": "In the matcher, `$` _name_ `:` _fragment-specifier_ matches a Rust syntax\nfragment of the kind specified and binds it to the metavariable `$`_name_.\n\nValid fragment specifiers are:\n\n  * `block`: a [BlockExpression]\n  * `expr`: an [Expression]\n  * `expr_2021`: an [Expression] except [UnderscoreExpression] and [ConstBlockExpression] (see [macro.decl.meta.edition2024])\n  * `ident`: an [IDENTIFIER_OR_KEYWORD] except `_`, [RAW_IDENTIFIER], or [`$crate`]\n  * `item`: an [Item]\n  * `lifetime`: a [LIFETIME_TOKEN]\n  * `literal`: matches `-`<sup>?</sup>[LiteralExpression]\n  * `meta`: an [Attr], the contents of an attribute\n  * `pat`: a [Pattern] (see [macro.decl.meta.edition2021])\n  * `pat_param`: a [PatternNoTopAlt]\n  * `path`: a [TypePath] style path\n  * `stmt`: a Statement without the trailing semicolon (except for item statements that require semicolons)\n  * `tt`: a [TokenTree]&nbsp;(a single [token] or tokens in matching delimiters `()`, `[]`, or `{}`)\n  * `ty`: a Type\n  * `vis`: a possibly empty [Visibility] qualifier\n\nIn the transcriber, metavariables are referred to simply by `$`_name_, since\nthe fragment kind is specified in the matcher. Metavariables are replaced with\nthe syntax element that matched them.\nMetavariables can be transcribed more than once or not at all.\n\nThe keyword metavariable [`$crate`] can be used to refer to the current crate.\n\n> [!EDITION-2021]\n> Starting with the 2021 edition, `pat` fragment-specifiers match top-level or-patterns (that is, they accept [Pattern]).\n>\n> Before the 2021 edition, they match exactly the same fragments as `pat_param` (that is, they accept [PatternNoTopAlt]).\n>\n> The relevant edition is the one in effect for the `macro_rules!` definition.\n\n> [!EDITION-2024]\n> Before the 2024 edition, `expr` fragment specifiers do not match [UnderscoreExpression] or [ConstBlockExpression] at the top level. They are allowed within subexpressions.\n>\n> The `expr_2021` fragment specifier exists to maintain backwards compatibility with editions before 2024.",
      "parent_id": null,
      "paragraphs": {
        "macro.decl.meta.intro": "In the matcher, `$` _name_ `:` _fragment-specifier_ matches a Rust syntax\nfragment of the kind specified and binds it to the metavariable `$`_name_.",
        "macro.decl.meta.specifier": "Valid fragment specifiers are:\n\n  * `block`: a [BlockExpression]\n  * `expr`: an [Expression]\n  * `expr_2021`: an [Expression] except [UnderscoreExpression] and [ConstBlockExpression] (see [macro.decl.meta.edition2024])\n  * `ident`: an [IDENTIFIER_OR_KEYWORD] except `_`, [RAW_IDENTIFIER], or [`$crate`]\n  * `item`: an [Item]\n  * `lifetime`: a [LIFETIME_TOKEN]\n  * `literal`: matches `-`<sup>?</sup>[LiteralExpression]\n  * `meta`: an [Attr], the contents of an attribute\n  * `pat`: a [Pattern] (see [macro.decl.meta.edition2021])\n  * `pat_param`: a [PatternNoTopAlt]\n  * `path`: a [TypePath] style path\n  * `stmt`: a Statement without the trailing semicolon (except for item statements that require semicolons)\n  * `tt`: a [TokenTree]&nbsp;(a single [token] or tokens in matching delimiters `()`, `[]`, or `{}`)\n  * `ty`: a Type\n  * `vis`: a possibly empty [Visibility] qualifier",
        "macro.decl.meta.transcription": "In the transcriber, metavariables are referred to simply by `$`_name_, since\nthe fragment kind is specified in the matcher. Metavariables are replaced with\nthe syntax element that matched them.\nMetavariables can be transcribed more than once or not at all.",
        "macro.decl.meta.dollar-crate": "The keyword metavariable [`$crate`] can be used to refer to the current crate.",
        "macro.decl.meta.edition2021": "> [!EDITION-2021]\n> Starting with the 2021 edition, `pat` fragment-specifiers match top-level or-patterns (that is, they accept [Pattern]).\n>\n> Before the 2021 edition, they match exactly the same fragments as `pat_param` (that is, they accept [PatternNoTopAlt]).\n>\n> The relevant edition is the one in effect for the `macro_rules!` definition.",
        "macro.decl.meta.edition2024": "> [!EDITION-2024]\n> Before the 2024 edition, `expr` fragment specifiers do not match [UnderscoreExpression] or [ConstBlockExpression] at the top level. They are allowed within subexpressions.\n>\n> The `expr_2021` fragment specifier exists to maintain backwards compatibility with editions before 2024."
      }
    },
    {
      "id": "macro.decl.repetition",
      "title": "Repetitions",
      "level": 2,
      "content": "In both the matcher and transcriber, repetitions are indicated by placing the\ntokens to be repeated inside `$(`\u2026`)`, followed by a repetition operator,\noptionally with a separator token between.\n\nThe separator token can be any token\nother than a delimiter or one of the repetition operators, but `;` and `,` are\nthe most common. For instance, `$( $i:ident ),*` represents any number of\nidentifiers separated by commas. Nested repetitions are permitted.\n\nThe repetition operators are:\n\n- `*` --- indicates any number of repetitions.\n- `+` --- indicates any number but at least one.\n- `?` --- indicates an optional fragment with zero or one occurrence.\n\nSince `?` represents at most one occurrence, it cannot be used with a\nseparator.\n\nThe repeated fragment both matches and transcribes to the specified number of\nthe fragment, separated by the separator token. Metavariables are matched to\nevery repetition of their corresponding fragment. For instance, the `$( $i:ident\n),*` example above matches `$i` to all of the identifiers in the list.\n\nDuring transcription, additional restrictions apply to repetitions so that the\ncompiler knows how to expand them properly:\n\n1.  A metavariable must appear in exactly the same number, kind, and nesting\n    order of repetitions in the transcriber as it did in the matcher. So for the\n    matcher `$( $i:ident ),*`, the transcribers `=> { $i }`,\n    `=> { $( $( $i )* )* }`, and `=> { $( $i )+ }` are all illegal, but\n    `=> { $( $i );* }` is correct and replaces a comma-separated list of\n    identifiers with a semicolon-separated list.\n2.  Each repetition in the transcriber must contain at least one metavariable to\n    decide how many times to expand it. If multiple metavariables appear in the\n    same repetition, they must be bound to the same number of fragments. For\n    instance, `( $( $i:ident ),* ; $( $j:ident ),* ) => (( $( ($i,$j) ),* ))` must\n    bind the same number of `$i` fragments as `$j` fragments. This means that\n    invoking the macro with `(a, b, c; d, e, f)` is legal and expands to\n    `((a,d), (b,e), (c,f))`, but `(a, b, c; d, e)` is illegal because it does\n    not have the same number. This requirement applies to every layer of nested\n    repetitions.",
      "parent_id": null,
      "paragraphs": {
        "macro.decl.repetition.intro": "In both the matcher and transcriber, repetitions are indicated by placing the\ntokens to be repeated inside `$(`\u2026`)`, followed by a repetition operator,\noptionally with a separator token between.",
        "macro.decl.repetition.separator": "The separator token can be any token\nother than a delimiter or one of the repetition operators, but `;` and `,` are\nthe most common. For instance, `$( $i:ident ),*` represents any number of\nidentifiers separated by commas. Nested repetitions are permitted.",
        "macro.decl.repetition.operators": "The repetition operators are:\n\n- `*` --- indicates any number of repetitions.\n- `+` --- indicates any number but at least one.\n- `?` --- indicates an optional fragment with zero or one occurrence.",
        "macro.decl.repetition.optional-restriction": "Since `?` represents at most one occurrence, it cannot be used with a\nseparator.",
        "macro.decl.repetition.fragment": "The repeated fragment both matches and transcribes to the specified number of\nthe fragment, separated by the separator token. Metavariables are matched to\nevery repetition of their corresponding fragment. For instance, the `$( $i:ident\n),*` example above matches `$i` to all of the identifiers in the list.\n\nDuring transcription, additional restrictions apply to repetitions so that the\ncompiler knows how to expand them properly:\n\n1.  A metavariable must appear in exactly the same number, kind, and nesting\n    order of repetitions in the transcriber as it did in the matcher. So for the\n    matcher `$( $i:ident ),*`, the transcribers `=> { $i }`,\n    `=> { $( $( $i )* )* }`, and `=> { $( $i )+ }` are all illegal, but\n    `=> { $( $i );* }` is correct and replaces a comma-separated list of\n    identifiers with a semicolon-separated list.\n2.  Each repetition in the transcriber must contain at least one metavariable to\n    decide how many times to expand it. If multiple metavariables appear in the\n    same repetition, they must be bound to the same number of fragments. For\n    instance, `( $( $i:ident ),* ; $( $j:ident ),* ) => (( $( ($i,$j) ),* ))` must\n    bind the same number of `$i` fragments as `$j` fragments. This means that\n    invoking the macro with `(a, b, c; d, e, f)` is legal and expands to\n    `((a,d), (b,e), (c,f))`, but `(a, b, c; d, e)` is illegal because it does\n    not have the same number. This requirement applies to every layer of nested\n    repetitions."
      }
    },
    {
      "id": "macro.decl.scope",
      "title": "Scoping, exporting, and importing",
      "level": 2,
      "content": "For historical reasons, the scoping of macros by example does not work entirely\nlike items. Macros have two forms of scope: textual scope, and path-based scope.\nTextual scope is based on the order that things appear in source files, or even\nacross multiple files, and is the default scoping. It is explained further below.\nPath-based scope works exactly the same way that item scoping does. The scoping,\nexporting, and importing of macros is controlled largely by attributes.\n\nWhen a macro is invoked by an unqualified identifier (not part of a multi-part\npath), it is first looked up in textual scoping. If this does not yield any\nresults, then it is looked up in path-based scoping. If the macro's name is\nqualified with a path, then it is only looked up in path-based scoping.\n\n<!-- ignore: requires external crates -->\n,ignore\nuse lazy_static::lazy_static; // Path-based import.\n\nmacro_rules! lazy_static { // Textual definition.\n    (lazy) => {};\n}\n\nlazy_static!{lazy} // Textual lookup finds our macro first.\nself::lazy_static!{} // Path-based lookup ignores our macro, finds imported one.",
      "parent_id": null,
      "paragraphs": {
        "macro.decl.scope.intro": "For historical reasons, the scoping of macros by example does not work entirely\nlike items. Macros have two forms of scope: textual scope, and path-based scope.\nTextual scope is based on the order that things appear in source files, or even\nacross multiple files, and is the default scoping. It is explained further below.\nPath-based scope works exactly the same way that item scoping does. The scoping,\nexporting, and importing of macros is controlled largely by attributes.",
        "macro.decl.scope.unqualified": "When a macro is invoked by an unqualified identifier (not part of a multi-part\npath), it is first looked up in textual scoping. If this does not yield any\nresults, then it is looked up in path-based scoping. If the macro's name is\nqualified with a path, then it is only looked up in path-based scoping.\n\n<!-- ignore: requires external crates -->\n,ignore\nuse lazy_static::lazy_static; // Path-based import.\n\nmacro_rules! lazy_static { // Textual definition.\n    (lazy) => {};\n}\n\nlazy_static!{lazy} // Textual lookup finds our macro first.\nself::lazy_static!{} // Path-based lookup ignores our macro, finds imported one."
      }
    },
    {
      "id": "macro.decl.scope.textual",
      "title": "Textual scope",
      "level": 2,
      "content": "Textual scope is based largely on the order that things appear in source files,\nand works similarly to the scope of local variables declared with `let` except\nit also applies at the module level. When `macro_rules!` is used to define a\nmacro, the macro enters the scope after the definition (note that it can still\nbe used recursively, since names are looked up from the invocation site), up\nuntil its surrounding scope, typically a module, is closed. This can enter child\nmodules and even span across multiple files:\n\n<!-- ignore: requires external modules -->\n,ignore\n//// src/lib.rs\nmod has_macro {\n    // m!{} // Error: m is not in scope.\n\n    macro_rules! m {\n        () => {};\n    }\n    m!{} // OK: appears after declaration of m.\n\n    mod uses_macro;\n}\n\n// m!{} // Error: m is not in scope.\n\n//// src/has_macro/uses_macro.rs\n\nm!{} // OK: appears after declaration of m in src/lib.rs\n\nIt is not an error to define a macro multiple times; the most recent declaration\nwill shadow the previous one unless it has gone out of scope.\n\nmacro_rules! m {\n    (1) => {};\n}\n\nm!(1);\n\nmod inner {\n    m!(1);\n\n    macro_rules! m {\n        (2) => {};\n    }\n    // m!(1); // Error: no rule matches '1'\n    m!(2);\n\n    macro_rules! m {\n        (3) => {};\n    }\n    m!(3);\n}\n\nm!(1);\n\nMacros can be declared and used locally inside functions as well, and work\nsimilarly:\n\nfn foo() {\n    // m!(); // Error: m is not in scope.\n    macro_rules! m {\n        () => {};\n    }\n    m!();\n}\n\n// m!(); // Error: m is not in scope.\n\nTextual scope name bindings for macros shadow path-based scope bindings to macros.\n\nmacro_rules! m2 {\n    () => {\n        println!(\"m2\");\n    };\n}\n\n// Resolves to path-based candidate from use declaration below.\nm!(); // prints \"m2\\n\"\n\n// Introduce second candidate for `m` with textual scope.\n//\n// This shadows path-based candidate from below for the rest of this\n// example.\nmacro_rules! m {\n    () => {\n        println!(\"m\");\n    };\n}\n\n// Introduce `m2` macro as path-based candidate.\n//\n// This item is in scope for this entire example, not just below the\n// use declaration.\nuse m2 as m;\n\n// Resolves to the textual macro candidate from above the use\n// declaration.\nm!(); // prints \"m\\n\"\n\n> [!NOTE]\n> For areas where shadowing is not allowed, see [name resolution ambiguities].",
      "parent_id": null,
      "paragraphs": {
        "macro.decl.scope.textual.intro": "Textual scope is based largely on the order that things appear in source files,\nand works similarly to the scope of local variables declared with `let` except\nit also applies at the module level. When `macro_rules!` is used to define a\nmacro, the macro enters the scope after the definition (note that it can still\nbe used recursively, since names are looked up from the invocation site), up\nuntil its surrounding scope, typically a module, is closed. This can enter child\nmodules and even span across multiple files:\n\n<!-- ignore: requires external modules -->\n,ignore\n//// src/lib.rs\nmod has_macro {\n    // m!{} // Error: m is not in scope.\n\n    macro_rules! m {\n        () => {};\n    }\n    m!{} // OK: appears after declaration of m.\n\n    mod uses_macro;\n}\n\n// m!{} // Error: m is not in scope.\n\n//// src/has_macro/uses_macro.rs\n\nm!{} // OK: appears after declaration of m in src/lib.rs",
        "macro.decl.scope.textual.shadow": "It is not an error to define a macro multiple times; the most recent declaration\nwill shadow the previous one unless it has gone out of scope.\n\nmacro_rules! m {\n    (1) => {};\n}\n\nm!(1);\n\nmod inner {\n    m!(1);\n\n    macro_rules! m {\n        (2) => {};\n    }\n    // m!(1); // Error: no rule matches '1'\n    m!(2);\n\n    macro_rules! m {\n        (3) => {};\n    }\n    m!(3);\n}\n\nm!(1);\n\nMacros can be declared and used locally inside functions as well, and work\nsimilarly:\n\nfn foo() {\n    // m!(); // Error: m is not in scope.\n    macro_rules! m {\n        () => {};\n    }\n    m!();\n}\n\n// m!(); // Error: m is not in scope.",
        "macro.decl.scope.textual.shadow.path-based": "Textual scope name bindings for macros shadow path-based scope bindings to macros.\n\nmacro_rules! m2 {\n    () => {\n        println!(\"m2\");\n    };\n}\n\n// Resolves to path-based candidate from use declaration below.\nm!(); // prints \"m2\\n\"\n\n// Introduce second candidate for `m` with textual scope.\n//\n// This shadows path-based candidate from below for the rest of this\n// example.\nmacro_rules! m {\n    () => {\n        println!(\"m\");\n    };\n}\n\n// Introduce `m2` macro as path-based candidate.\n//\n// This item is in scope for this entire example, not just below the\n// use declaration.\nuse m2 as m;\n\n// Resolves to the textual macro candidate from above the use\n// declaration.\nm!(); // prints \"m\\n\"\n\n> [!NOTE]\n> For areas where shadowing is not allowed, see [name resolution ambiguities]."
      }
    },
    {
      "id": "macro.decl.scope.path-based",
      "title": "Path-based scope",
      "level": 3,
      "content": "By default, a macro has no path-based scope. Macros can gain path-based scope in two ways:\n\n- [Use declaration re-export]\n- [`macro_export`]\n\nMacros can be re-exported to give them path-based scope from a module other than the crate root.\n\nmac::m!(); // OK: Path-based lookup finds `m` in the mac module.\n\nmod mac {\n    // Introduce macro `m` with textual scope.\n    macro_rules! m {\n        () => {};\n    }\n\n    // Reexport with path-based scope from within `m`'s textual scope.\n    pub(crate) use m;\n}\n\nMacros have an implicit visibility of `pub(crate)`. `#[macro_export]` changes the implicit visibility to `pub`.\n\n// Implicit visibility is `pub(crate)`.\nmacro_rules! private_m {\n    () => {};\n}\n\n// Implicit visibility is `pub`.\n#[macro_export]\nmacro_rules! pub_m {\n    () => {};\n}\n\npub(crate) use private_m as private_macro; // OK.\npub use pub_m as pub_macro; // OK.\n\n,compile_fail,E0364\n# // Implicit visibility is `pub(crate)`.\n# macro_rules! private_m {\n#     () => {};\n# }\n#\n# // Implicit visibility is `pub`.\n# #[macro_export]\n# macro_rules! pub_m {\n#     () => {};\n# }\n#\n# pub(crate) use private_m as private_macro; // OK.\n# pub use pub_m as pub_macro; // OK.\n#\npub use private_m; // ERROR: `private_m` is only public within\n                   // the crate and cannot be re-exported outside.\n\n<!-- template:attributes -->",
      "parent_id": null,
      "paragraphs": {
        "macro.decl.scope.path-based.intro": "By default, a macro has no path-based scope. Macros can gain path-based scope in two ways:\n\n- [Use declaration re-export]\n- [`macro_export`]",
        "macro.decl.scope.path.reexport": "Macros can be re-exported to give them path-based scope from a module other than the crate root.\n\nmac::m!(); // OK: Path-based lookup finds `m` in the mac module.\n\nmod mac {\n    // Introduce macro `m` with textual scope.\n    macro_rules! m {\n        () => {};\n    }\n\n    // Reexport with path-based scope from within `m`'s textual scope.\n    pub(crate) use m;\n}",
        "macro.decl.scope.path-based.visibility": "Macros have an implicit visibility of `pub(crate)`. `#[macro_export]` changes the implicit visibility to `pub`.\n\n// Implicit visibility is `pub(crate)`.\nmacro_rules! private_m {\n    () => {};\n}\n\n// Implicit visibility is `pub`.\n#[macro_export]\nmacro_rules! pub_m {\n    () => {};\n}\n\npub(crate) use private_m as private_macro; // OK.\npub use pub_m as pub_macro; // OK.\n\n,compile_fail,E0364\n# // Implicit visibility is `pub(crate)`.\n# macro_rules! private_m {\n#     () => {};\n# }\n#\n# // Implicit visibility is `pub`.\n# #[macro_export]\n# macro_rules! pub_m {\n#     () => {};\n# }\n#\n# pub(crate) use private_m as private_macro; // OK.\n# pub use pub_m as pub_macro; // OK.\n#\npub use private_m; // ERROR: `private_m` is only public within\n                   // the crate and cannot be re-exported outside.\n\n<!-- template:attributes -->"
      }
    },
    {
      "id": "macro.decl.scope.macro_use",
      "title": "The `macro_use` attribute",
      "level": 1,
      "content": "The *`macro_use` attribute* has two purposes: it may be used on modules to extend the scope of macros defined within them, and it may be used on `extern crate` to import macros from another crate into the [`macro_use` prelude].\n\n> [!EXAMPLE]\n> ```rust\n> #[macro_use]\n> mod inner {\n>     macro_rules! m {\n>         () => {};\n>     }\n> }\n> m!();\n> ```\n>\n> ```rust,ignore\n> #[macro_use]\n> extern crate log;\n> ```\n\nWhen used on modules, the `macro_use` attribute uses the [MetaWord] syntax.\n\nWhen used on `extern crate`, it uses the [MetaWord] and [MetaListIdents] syntaxes. For more on how these syntaxes may be used, see [macro.decl.scope.macro_use.prelude].\n\nThe `macro_use` attribute may be applied to modules or `extern crate`.\n\n> [!NOTE]\n> `rustc` ignores use in other positions but lints against it. This may become an error in the future.\n\nThe `macro_use` attribute may not be used on [`extern crate self`].\n\nThe `macro_use` attribute may be used any number of times on a form.\n\nMultiple instances of `macro_use` in the [MetaListIdents] syntax may be specified. The union of all specified macros will be imported.\n\n> [!NOTE]\n> On modules, `rustc` lints against any [MetaWord] `macro_use` attributes following the first.\n>\n> On `extern crate`, `rustc` lints against any `macro_use` attributes that have no effect due to not importing any macros not already imported by another `macro_use` attribute. If two or more [MetaListIdents] `macro_use` attributes import the same macro, the first is linted against. If any [MetaWord] `macro_use` attributes are present, all [MetaListIdents] `macro_use` attributes are linted against. If two or more [MetaWord] `macro_use` attributes are present, the ones following the first are linted against.\n\nWhen `macro_use` is used on a module, the module's macro scope extends beyond the module's lexical scope.\n\n> [!EXAMPLE]\n> ```rust\n> #[macro_use]\n> mod inner {\n>     macro_rules! m {\n>         () => {};\n>     }\n> }\n> m!(); // OK\n> ```\n\nSpecifying `macro_use` on an `extern crate` declaration in the crate root imports exported macros from that crate.\n\nMacros imported this way are imported into the [`macro_use` prelude], not textually, which means that they can be shadowed by any other name. Macros imported by `macro_use` can be used before the import statement.\n\n> [!NOTE]\n> `rustc` currently prefers the last macro imported in case of conflict. Don't rely on this. This behavior is unusual, as imports in Rust are generally order-independent. This behavior of `macro_use` may change in the future.\n>\n> For details, see Rust issue #148025.\n\nWhen using the [MetaWord] syntax, all exported macros are imported. When using the [MetaListIdents] syntax, only the specified macros are imported.\n\n> [!EXAMPLE]\n> <!-- ignore: requires external crates -->\n> ```rust,ignore\n> #[macro_use(lazy_static)] // Or `#[macro_use]` to import all macros.\n> extern crate lazy_static;\n>\n> lazy_static!{}\n> // self::lazy_static!{} // ERROR: lazy_static is not defined in `self`.\n> ```\n\nMacros to be imported with `macro_use` must be exported with `macro_export`.\n\n<!-- template:attributes -->",
      "parent_id": null,
      "paragraphs": {
        "macro.decl.scope.macro_use.intro": "The *`macro_use` attribute* has two purposes: it may be used on modules to extend the scope of macros defined within them, and it may be used on `extern crate` to import macros from another crate into the [`macro_use` prelude].\n\n> [!EXAMPLE]\n> ```rust\n> #[macro_use]\n> mod inner {\n>     macro_rules! m {\n>         () => {};\n>     }\n> }\n> m!();\n> ```\n>\n> ```rust,ignore\n> #[macro_use]\n> extern crate log;\n> ```",
        "macro.decl.scope.macro_use.syntax": "When used on modules, the `macro_use` attribute uses the [MetaWord] syntax.\n\nWhen used on `extern crate`, it uses the [MetaWord] and [MetaListIdents] syntaxes. For more on how these syntaxes may be used, see [macro.decl.scope.macro_use.prelude].",
        "macro.decl.scope.macro_use.allowed-positions": "The `macro_use` attribute may be applied to modules or `extern crate`.\n\n> [!NOTE]\n> `rustc` ignores use in other positions but lints against it. This may become an error in the future.",
        "macro.decl.scope.macro_use.extern-crate-self": "The `macro_use` attribute may not be used on [`extern crate self`].",
        "macro.decl.scope.macro_use.duplicates": "The `macro_use` attribute may be used any number of times on a form.\n\nMultiple instances of `macro_use` in the [MetaListIdents] syntax may be specified. The union of all specified macros will be imported.\n\n> [!NOTE]\n> On modules, `rustc` lints against any [MetaWord] `macro_use` attributes following the first.\n>\n> On `extern crate`, `rustc` lints against any `macro_use` attributes that have no effect due to not importing any macros not already imported by another `macro_use` attribute. If two or more [MetaListIdents] `macro_use` attributes import the same macro, the first is linted against. If any [MetaWord] `macro_use` attributes are present, all [MetaListIdents] `macro_use` attributes are linted against. If two or more [MetaWord] `macro_use` attributes are present, the ones following the first are linted against.",
        "macro.decl.scope.macro_use.mod-decl": "When `macro_use` is used on a module, the module's macro scope extends beyond the module's lexical scope.\n\n> [!EXAMPLE]\n> ```rust\n> #[macro_use]\n> mod inner {\n>     macro_rules! m {\n>         () => {};\n>     }\n> }\n> m!(); // OK\n> ```",
        "macro.decl.scope.macro_use.prelude": "Specifying `macro_use` on an `extern crate` declaration in the crate root imports exported macros from that crate.\n\nMacros imported this way are imported into the [`macro_use` prelude], not textually, which means that they can be shadowed by any other name. Macros imported by `macro_use` can be used before the import statement.\n\n> [!NOTE]\n> `rustc` currently prefers the last macro imported in case of conflict. Don't rely on this. This behavior is unusual, as imports in Rust are generally order-independent. This behavior of `macro_use` may change in the future.\n>\n> For details, see Rust issue #148025.\n\nWhen using the [MetaWord] syntax, all exported macros are imported. When using the [MetaListIdents] syntax, only the specified macros are imported.\n\n> [!EXAMPLE]\n> <!-- ignore: requires external crates -->\n> ```rust,ignore\n> #[macro_use(lazy_static)] // Or `#[macro_use]` to import all macros.\n> extern crate lazy_static;\n>\n> lazy_static!{}\n> // self::lazy_static!{} // ERROR: lazy_static is not defined in `self`.\n> ```",
        "macro.decl.scope.macro_use.export": "Macros to be imported with `macro_use` must be exported with `macro_export`.\n\n<!-- template:attributes -->"
      }
    },
    {
      "id": "macro.decl.scope.macro_export",
      "title": "The `macro_export` attribute",
      "level": 3,
      "content": "The *`macro_export` attribute* exports the macro from the crate and makes it available in the root of the crate for path-based resolution.\n\n> [!EXAMPLE]\n> ```rust\n> self::m!();\n> //  ^^^^ OK: Path-based lookup finds `m` in the current module.\n> m!(); // As above.\n>\n> mod inner {\n>     super::m!();\n>     crate::m!();\n> }\n>\n> mod mac {\n>     #[macro_export]\n>     macro_rules! m {\n>         () => {};\n>     }\n> }\n> ```\n\nThe `macro_export` attribute uses the [MetaWord] and [MetaListIdents] syntaxes. With the [MetaListIdents] syntax, it accepts a single `local_inner_macros` value.\n\nThe `macro_export` attribute may be applied to `macro_rules` definitions.\n\n> [!NOTE]\n> `rustc` ignores use in other positions but lints against it. This may become an error in the future.\n\nOnly the first use of `macro_export` on a macro has effect.\n\n> [!NOTE]\n> `rustc` lints against any use following the first.\n\nBy default, macros only have textual scope and cannot be resolved by path. When the `macro_export` attribute is used, the macro is made available in the crate root and can be referred to by its path.\n\n> [!EXAMPLE]\n> Without `macro_export`, macros only have textual scope, so path-based resolution of the macro fails.\n>\n> ```rust,compile_fail,E0433\n> macro_rules! m {\n>     () => {};\n> }\n> self::m!(); // ERROR\n> crate::m!(); // ERROR\n> # fn main() {}\n> ```\n>\n> With `macro_export`, path-based resolution works.\n>\n> ```rust\n> #[macro_export]\n> macro_rules! m {\n>     () => {};\n> }\n> self::m!(); // OK\n> crate::m!(); // OK\n> # fn main() {}\n> ```\n\nThe `macro_export` attribute causes a macro to be exported from the crate root so that it can be referred to in other crates by path.\n\n> [!EXAMPLE]\n> Given the following in a `log` crate:\n>\n> ```rust\n> #[macro_export]\n> macro_rules! warn {\n>     ($message:expr) => { eprintln!(\"WARN: {}\", $message) };\n> }\n> ```\n>\n> From another crate, you can refer to the macro by path:\n>\n> <!-- ignore: requires external crates -->\n> ```rust,ignore\n> fn main() {\n>     log::warn!(\"example warning\");\n> }\n> ```\n\n`macro_export` allows the use of `macro_use` on an `extern crate` to import the macro into the [`macro_use` prelude].\n\n> [!EXAMPLE]\n> Given the following in a `log` crate:\n>\n> ```rust\n> #[macro_export]\n> macro_rules! warn {\n>     ($message:expr) => { eprintln!(\"WARN: {}\", $message) };\n> }\n> ```\n>\n> Using `macro_use` in a dependent crate allows you to use the macro from the prelude:\n>\n> <!-- ignore: requires external crates -->\n> ```rust,ignore\n> #[macro_use]\n> extern crate log;\n>\n> pub mod util {\n>     pub fn do_thing() {\n>         // Resolved via macro prelude.\n>         warn!(\"example warning\");\n>     }\n> }\n> ```\n\nAdding `local_inner_macros` to the `macro_export` attribute causes all single-segment macro invocations in the macro definition to have an implicit `$crate::` prefix.\n\n> [!NOTE]\n> This is intended primarily as a tool to migrate code written before [`$crate`] was added to the language to work with Rust 2018's path-based imports of macros. Its use is discouraged in new code.\n\n> [!EXAMPLE]\n> ```rust\n> #[macro_export(local_inner_macros)]\n> macro_rules! helped {\n>     () => { helper!() } // Automatically converted to $crate::helper!().\n> }\n>\n> #[macro_export]\n> macro_rules! helper {\n>     () => { () }\n> }\n> ```",
      "parent_id": null,
      "paragraphs": {
        "macro.decl.scope.macro_export.intro": "The *`macro_export` attribute* exports the macro from the crate and makes it available in the root of the crate for path-based resolution.\n\n> [!EXAMPLE]\n> ```rust\n> self::m!();\n> //  ^^^^ OK: Path-based lookup finds `m` in the current module.\n> m!(); // As above.\n>\n> mod inner {\n>     super::m!();\n>     crate::m!();\n> }\n>\n> mod mac {\n>     #[macro_export]\n>     macro_rules! m {\n>         () => {};\n>     }\n> }\n> ```",
        "macro.decl.scope.macro_export.syntax": "The `macro_export` attribute uses the [MetaWord] and [MetaListIdents] syntaxes. With the [MetaListIdents] syntax, it accepts a single `local_inner_macros` value.",
        "macro.decl.scope.macro_export.allowed-positions": "The `macro_export` attribute may be applied to `macro_rules` definitions.\n\n> [!NOTE]\n> `rustc` ignores use in other positions but lints against it. This may become an error in the future.",
        "macro.decl.scope.macro_export.duplicates": "Only the first use of `macro_export` on a macro has effect.\n\n> [!NOTE]\n> `rustc` lints against any use following the first.",
        "macro.decl.scope.macro_export.path-based": "By default, macros only have textual scope and cannot be resolved by path. When the `macro_export` attribute is used, the macro is made available in the crate root and can be referred to by its path.\n\n> [!EXAMPLE]\n> Without `macro_export`, macros only have textual scope, so path-based resolution of the macro fails.\n>\n> ```rust,compile_fail,E0433\n> macro_rules! m {\n>     () => {};\n> }\n> self::m!(); // ERROR\n> crate::m!(); // ERROR\n> # fn main() {}\n> ```\n>\n> With `macro_export`, path-based resolution works.\n>\n> ```rust\n> #[macro_export]\n> macro_rules! m {\n>     () => {};\n> }\n> self::m!(); // OK\n> crate::m!(); // OK\n> # fn main() {}\n> ```",
        "macro.decl.scope.macro_export.export": "The `macro_export` attribute causes a macro to be exported from the crate root so that it can be referred to in other crates by path.\n\n> [!EXAMPLE]\n> Given the following in a `log` crate:\n>\n> ```rust\n> #[macro_export]\n> macro_rules! warn {\n>     ($message:expr) => { eprintln!(\"WARN: {}\", $message) };\n> }\n> ```\n>\n> From another crate, you can refer to the macro by path:\n>\n> <!-- ignore: requires external crates -->\n> ```rust,ignore\n> fn main() {\n>     log::warn!(\"example warning\");\n> }\n> ```",
        "macro.decl.scope.macro_export.macro_use": "`macro_export` allows the use of `macro_use` on an `extern crate` to import the macro into the [`macro_use` prelude].\n\n> [!EXAMPLE]\n> Given the following in a `log` crate:\n>\n> ```rust\n> #[macro_export]\n> macro_rules! warn {\n>     ($message:expr) => { eprintln!(\"WARN: {}\", $message) };\n> }\n> ```\n>\n> Using `macro_use` in a dependent crate allows you to use the macro from the prelude:\n>\n> <!-- ignore: requires external crates -->\n> ```rust,ignore\n> #[macro_use]\n> extern crate log;\n>\n> pub mod util {\n>     pub fn do_thing() {\n>         // Resolved via macro prelude.\n>         warn!(\"example warning\");\n>     }\n> }\n> ```",
        "macro.decl.scope.macro_export.local_inner_macros": "Adding `local_inner_macros` to the `macro_export` attribute causes all single-segment macro invocations in the macro definition to have an implicit `$crate::` prefix.\n\n> [!NOTE]\n> This is intended primarily as a tool to migrate code written before [`$crate`] was added to the language to work with Rust 2018's path-based imports of macros. Its use is discouraged in new code.\n\n> [!EXAMPLE]\n> ```rust\n> #[macro_export(local_inner_macros)]\n> macro_rules! helped {\n>     () => { helper!() } // Automatically converted to $crate::helper!().\n> }\n>\n> #[macro_export]\n> macro_rules! helper {\n>     () => { () }\n> }\n> ```"
      }
    },
    {
      "id": "macro.decl.hygiene",
      "title": "Hygiene",
      "level": 3,
      "content": "Macros by example have _mixed-site hygiene_. This means that [loop labels], [block labels], and local variables are looked up at the macro definition site while other symbols are looked up at the macro invocation site. For example:\n\nlet x = 1;\nfn func() {\n    unreachable!(\"this is never called\")\n}\n\nmacro_rules! check {\n    () => {\n        assert_eq!(x, 1); // Uses `x` from the definition site.\n        func();           // Uses `func` from the invocation site.\n    };\n}\n\n{\n    let x = 2;\n    fn func() { /* does not panic */ }\n    check!();\n}\n\nLabels and local variables defined in macro expansion are not shared between invocations, so this code doesn\u2019t compile:\n\n,compile_fail,E0425\nmacro_rules! m {\n    (define) => {\n        let x = 1;\n    };\n    (refer) => {\n        dbg!(x);\n    };\n}\n\nm!(define);\nm!(refer);\n\nA special case is the `$crate` metavariable. It refers to the crate defining the macro, and can be used at the start of the path to look up items or macros which are not in scope at the invocation site.\n\n<!-- ignore: requires external crates -->\n,ignore\n//// Definitions in the `helper_macro` crate.\n#[macro_export]\nmacro_rules! helped {\n    // () => { helper!() } // This might lead to an error due to 'helper' not being in scope.\n    () => { $crate::helper!() }\n}\n\n#[macro_export]\nmacro_rules! helper {\n    () => { () }\n}\n\n//// Usage in another crate.\n// Note that `helper_macro::helper` is not imported!\nuse helper_macro::helped;\n\nfn unit() {\n    helped!();\n}\n\nNote that, because `$crate` refers to the current crate, it must be used with a\nfully qualified module path when referring to non-macro items:\n\npub mod inner {\n    #[macro_export]\n    macro_rules! call_foo {\n        () => { $crate::inner::foo() };\n    }\n\n    pub fn foo() {}\n}\n\nAdditionally, even though `$crate` allows a macro to refer to items within its\nown crate when expanding, its use has no effect on visibility. An item or macro\nreferred to must still be visible from the invocation site. In the following\nexample, any attempt to invoke `call_foo!()` from outside its crate will fail\nbecause `foo()` is not public.\n\n#[macro_export]\nmacro_rules! call_foo {\n    () => { $crate::foo() };\n}\n\nfn foo() {}\n\n> [!NOTE]\n> Prior to Rust 1.30, `$crate` and `local_inner_macros` were unsupported. They were added alongside path-based imports of macros, to ensure that helper macros did not need to be manually imported by users of a macro-exporting crate. Crates written for earlier versions of Rust that use helper macros need to be modified to use `$crate` or `local_inner_macros` to work well with path-based imports.",
      "parent_id": null,
      "paragraphs": {
        "macro.decl.hygiene.intro": "Macros by example have _mixed-site hygiene_. This means that [loop labels], [block labels], and local variables are looked up at the macro definition site while other symbols are looked up at the macro invocation site. For example:\n\nlet x = 1;\nfn func() {\n    unreachable!(\"this is never called\")\n}\n\nmacro_rules! check {\n    () => {\n        assert_eq!(x, 1); // Uses `x` from the definition site.\n        func();           // Uses `func` from the invocation site.\n    };\n}\n\n{\n    let x = 2;\n    fn func() { /* does not panic */ }\n    check!();\n}\n\nLabels and local variables defined in macro expansion are not shared between invocations, so this code doesn\u2019t compile:\n\n,compile_fail,E0425\nmacro_rules! m {\n    (define) => {\n        let x = 1;\n    };\n    (refer) => {\n        dbg!(x);\n    };\n}\n\nm!(define);\nm!(refer);",
        "macro.decl.hygiene.crate": "A special case is the `$crate` metavariable. It refers to the crate defining the macro, and can be used at the start of the path to look up items or macros which are not in scope at the invocation site.\n\n<!-- ignore: requires external crates -->\n,ignore\n//// Definitions in the `helper_macro` crate.\n#[macro_export]\nmacro_rules! helped {\n    // () => { helper!() } // This might lead to an error due to 'helper' not being in scope.\n    () => { $crate::helper!() }\n}\n\n#[macro_export]\nmacro_rules! helper {\n    () => { () }\n}\n\n//// Usage in another crate.\n// Note that `helper_macro::helper` is not imported!\nuse helper_macro::helped;\n\nfn unit() {\n    helped!();\n}\n\nNote that, because `$crate` refers to the current crate, it must be used with a\nfully qualified module path when referring to non-macro items:\n\npub mod inner {\n    #[macro_export]\n    macro_rules! call_foo {\n        () => { $crate::inner::foo() };\n    }\n\n    pub fn foo() {}\n}",
        "macro.decl.hygiene.vis": "Additionally, even though `$crate` allows a macro to refer to items within its\nown crate when expanding, its use has no effect on visibility. An item or macro\nreferred to must still be visible from the invocation site. In the following\nexample, any attempt to invoke `call_foo!()` from outside its crate will fail\nbecause `foo()` is not public.\n\n#[macro_export]\nmacro_rules! call_foo {\n    () => { $crate::foo() };\n}\n\nfn foo() {}\n\n> [!NOTE]\n> Prior to Rust 1.30, `$crate` and `local_inner_macros` were unsupported. They were added alongside path-based imports of macros, to ensure that helper macros did not need to be manually imported by users of a macro-exporting crate. Crates written for earlier versions of Rust that use helper macros need to be modified to use `$crate` or `local_inner_macros` to work well with path-based imports."
      }
    },
    {
      "id": "macro.decl.follow-set",
      "title": "Follow-set ambiguity restrictions",
      "level": 2,
      "content": "The parser used by the macro system is reasonably powerful, but it is limited in\norder to prevent ambiguity in current or future versions of the language.\n\nIn particular, in addition to the rule about ambiguous expansions, a nonterminal\nmatched by a metavariable must be followed by a token which has been decided can\nbe safely used after that kind of match.\n\nAs an example, a macro matcher like `$i:expr [ , ]` could in theory be accepted\nin Rust today, since `[,]` cannot be part of a legal expression and therefore\nthe parse would always be unambiguous. However, because `[` can start trailing\nexpressions, `[` is not a character which can safely be ruled out as coming\nafter an expression. If `[,]` were accepted in a later version of Rust, this\nmatcher would become ambiguous or would misparse, breaking working code.\nMatchers like `$i:expr,` or `$i:expr;` would be legal, however, because `,` and\n`;` are legal expression separators. The specific rules are:\n\n* `expr` and `stmt` may only be followed by one of: `=>`, `,`, or `;`.\n\n* `pat_param` may only be followed by one of: `=>`, `,`, `=`, `|`, `if`, or `in`.\n\n* `pat` may only be followed by one of: `=>`, `,`, `=`, `if`, or `in`.\n\n* `path` and `ty` may only be followed by one of: `=>`, `,`, `=`, `|`, `;`,\n    `:`, `>`, `>>`, `[`, `{`, `as`, `where`, or a macro variable of `block`\n    fragment specifier.\n\n* `vis` may only be followed by one of: `,`, an identifier other than a\n    non-raw `priv`, any token that can begin a type, or a metavariable with a\n    `ident`, `ty`, or `path` fragment specifier.\n\n* All other fragment specifiers have no restrictions.\n\n> [!EDITION-2021]\n> Before the 2021 edition, `pat` may also be followed by `|`.\n\nWhen repetitions are involved, then the rules apply to every possible number of\nexpansions, taking separators into account. This means:\n\n  * If the repetition includes a separator, that separator must be able to\n    follow the contents of the repetition.\n  * If the repetition can repeat multiple times (`*` or `+`), then the contents\n    must be able to follow themselves.\n  * The contents of the repetition must be able to follow whatever comes\n    before, and whatever comes after must be able to follow the contents of the\n    repetition.\n  * If the repetition can match zero times (`*` or `?`), then whatever comes\n    after must be able to follow whatever comes before.\n\nFor more detail, see the [formal specification].\n\n_export-attribute\n[`$crate`]: macro.decl.hygiene.crate\n[`extern crate self`]: items.extern-crate.self\n[`macro_use` prelude]: names/preludes.md#macro_use-prelude\n[block labels]: expr.loop.block-labels\n[delimiters]: tokens.md#delimiters\n[formal specification]: macro-ambiguity.md\n[loop labels]: expressions/loop-expr.md#loop-labels\n[name resolution ambiguities]: names/name-resolution.md#r-names.resolution.expansion.imports.ambiguity\n[token]: tokens.md\n[use declaration re-export]: items/use-declarations.md#use-visibility",
      "parent_id": null,
      "paragraphs": {
        "macro.decl.follow-set.intro": "The parser used by the macro system is reasonably powerful, but it is limited in\norder to prevent ambiguity in current or future versions of the language.",
        "macro.decl.follow-set.token-restriction": "In particular, in addition to the rule about ambiguous expansions, a nonterminal\nmatched by a metavariable must be followed by a token which has been decided can\nbe safely used after that kind of match.\n\nAs an example, a macro matcher like `$i:expr [ , ]` could in theory be accepted\nin Rust today, since `[,]` cannot be part of a legal expression and therefore\nthe parse would always be unambiguous. However, because `[` can start trailing\nexpressions, `[` is not a character which can safely be ruled out as coming\nafter an expression. If `[,]` were accepted in a later version of Rust, this\nmatcher would become ambiguous or would misparse, breaking working code.\nMatchers like `$i:expr,` or `$i:expr;` would be legal, however, because `,` and\n`;` are legal expression separators. The specific rules are:",
        "macro.decl.follow-set.token-expr-stmt": "* `expr` and `stmt` may only be followed by one of: `=>`, `,`, or `;`.",
        "macro.decl.follow-set.token-pat_param": "* `pat_param` may only be followed by one of: `=>`, `,`, `=`, `|`, `if`, or `in`.",
        "macro.decl.follow-set.token-pat": "* `pat` may only be followed by one of: `=>`, `,`, `=`, `if`, or `in`.",
        "macro.decl.follow-set.token-path-ty": "* `path` and `ty` may only be followed by one of: `=>`, `,`, `=`, `|`, `;`,\n    `:`, `>`, `>>`, `[`, `{`, `as`, `where`, or a macro variable of `block`\n    fragment specifier.",
        "macro.decl.follow-set.token-vis": "* `vis` may only be followed by one of: `,`, an identifier other than a\n    non-raw `priv`, any token that can begin a type, or a metavariable with a\n    `ident`, `ty`, or `path` fragment specifier.",
        "macro.decl.follow-set.token-other": "* All other fragment specifiers have no restrictions.",
        "macro.decl.follow-set.edition2021": "> [!EDITION-2021]\n> Before the 2021 edition, `pat` may also be followed by `|`.",
        "macro.decl.follow-set.repetition": "When repetitions are involved, then the rules apply to every possible number of\nexpansions, taking separators into account. This means:\n\n  * If the repetition includes a separator, that separator must be able to\n    follow the contents of the repetition.\n  * If the repetition can repeat multiple times (`*` or `+`), then the contents\n    must be able to follow themselves.\n  * The contents of the repetition must be able to follow whatever comes\n    before, and whatever comes after must be able to follow the contents of the\n    repetition.\n  * If the repetition can match zero times (`*` or `?`), then whatever comes\n    after must be able to follow whatever comes before.\n\nFor more detail, see the [formal specification].\n\n_export-attribute\n[`$crate`]: macro.decl.hygiene.crate\n[`extern crate self`]: items.extern-crate.self\n[`macro_use` prelude]: names/preludes.md#macro_use-prelude\n[block labels]: expr.loop.block-labels\n[delimiters]: tokens.md#delimiters\n[formal specification]: macro-ambiguity.md\n[loop labels]: expressions/loop-expr.md#loop-labels\n[name resolution ambiguities]: names/name-resolution.md#r-names.resolution.expansion.imports.ambiguity\n[token]: tokens.md\n[use declaration re-export]: items/use-declarations.md#use-visibility"
      }
    },
    {
      "id": "macro.proc",
      "title": "Procedural macros",
      "level": 1,
      "content": "*Procedural macros* allow creating syntax extensions as execution of a function.\nProcedural macros come in one of three flavors:\n\n* [Function-like macros] - `custom!(...)`\n* [Derive macros] - `#[derive(CustomDerive)]`\n* [Attribute macros] - `#[CustomAttribute]`\n\nProcedural macros allow you to run code at compile time that operates over Rust\nsyntax, both consuming and producing Rust syntax. You can sort of think of\nprocedural macros as functions from an AST to another AST.\n\nProcedural macros must be defined in the root of a crate with the [crate type] of\n`proc-macro`.\nThe macros may not be used from the crate where they are defined, and can only be used when imported in another crate.\n\n> [!NOTE]\n> When using Cargo, Procedural macro crates are defined with the `proc-macro` key in your manifest:\n>\n> ```toml\n> [lib]\n> proc-macro = true\n> ```\n\nAs functions, they must either return syntax, panic, or loop endlessly. Returned\nsyntax either replaces or adds the syntax depending on the kind of procedural\nmacro. Panics are caught by the compiler and are turned into a compiler error.\nEndless loops are not caught by the compiler which hangs the compiler.\n\nProcedural macros run during compilation, and thus have the same resources that\nthe compiler has. For example, standard input, error, and output are the same\nthat the compiler has access to. Similarly, file access is the same. Because\nof this, procedural macros have the same security concerns that [Cargo's\nbuild scripts] have.\n\nProcedural macros have two ways of reporting errors. The first is to panic. The\nsecond is to emit a [`compile_error`] macro invocation.",
      "parent_id": null,
      "paragraphs": {
        "macro.proc.intro": "*Procedural macros* allow creating syntax extensions as execution of a function.\nProcedural macros come in one of three flavors:\n\n* [Function-like macros] - `custom!(...)`\n* [Derive macros] - `#[derive(CustomDerive)]`\n* [Attribute macros] - `#[CustomAttribute]`\n\nProcedural macros allow you to run code at compile time that operates over Rust\nsyntax, both consuming and producing Rust syntax. You can sort of think of\nprocedural macros as functions from an AST to another AST.",
        "macro.proc.def": "Procedural macros must be defined in the root of a crate with the [crate type] of\n`proc-macro`.\nThe macros may not be used from the crate where they are defined, and can only be used when imported in another crate.\n\n> [!NOTE]\n> When using Cargo, Procedural macro crates are defined with the `proc-macro` key in your manifest:\n>\n> ```toml\n> [lib]\n> proc-macro = true\n> ```",
        "macro.proc.result": "As functions, they must either return syntax, panic, or loop endlessly. Returned\nsyntax either replaces or adds the syntax depending on the kind of procedural\nmacro. Panics are caught by the compiler and are turned into a compiler error.\nEndless loops are not caught by the compiler which hangs the compiler.\n\nProcedural macros run during compilation, and thus have the same resources that\nthe compiler has. For example, standard input, error, and output are the same\nthat the compiler has access to. Similarly, file access is the same. Because\nof this, procedural macros have the same security concerns that [Cargo's\nbuild scripts] have.",
        "macro.proc.error": "Procedural macros have two ways of reporting errors. The first is to panic. The\nsecond is to emit a [`compile_error`] macro invocation."
      }
    },
    {
      "id": "macro.proc.proc_macro-crate",
      "title": "The `proc_macro` crate",
      "level": 1,
      "content": "Procedural macro crates almost always will link to the compiler-provided\n[`proc_macro` crate]. The `proc_macro` crate provides types required for\nwriting procedural macros and facilities to make it easier.\n\nThis crate primarily contains a [`TokenStream`] type. Procedural macros operate\nover *token streams* instead of AST nodes, which is a far more stable interface\nover time for both the compiler and for procedural macros to target. A\n*token stream* is roughly equivalent to `Vec<TokenTree>` where a `TokenTree`\ncan roughly be thought of as lexical token. For example `foo` is an `Ident`\ntoken, `.` is a `Punct` token, and `1.2` is a `Literal` token. The `TokenStream`\ntype, unlike `Vec<TokenTree>`, is cheap to clone.\n\nAll tokens have an associated `Span`. A `Span` is an opaque value that cannot\nbe modified but can be manufactured. `Span`s represent an extent of source\ncode within a program and are primarily used for error reporting. While you\ncannot modify a `Span` itself, you can always change the `Span` *associated*\nwith any token, such as through getting a `Span` from another token.",
      "parent_id": null,
      "paragraphs": {
        "macro.proc.proc_macro-crate.intro": "Procedural macro crates almost always will link to the compiler-provided\n[`proc_macro` crate]. The `proc_macro` crate provides types required for\nwriting procedural macros and facilities to make it easier.",
        "macro.proc.proc_macro-crate.token-stream": "This crate primarily contains a [`TokenStream`] type. Procedural macros operate\nover *token streams* instead of AST nodes, which is a far more stable interface\nover time for both the compiler and for procedural macros to target. A\n*token stream* is roughly equivalent to `Vec<TokenTree>` where a `TokenTree`\ncan roughly be thought of as lexical token. For example `foo` is an `Ident`\ntoken, `.` is a `Punct` token, and `1.2` is a `Literal` token. The `TokenStream`\ntype, unlike `Vec<TokenTree>`, is cheap to clone.",
        "macro.proc.proc_macro-crate.span": "All tokens have an associated `Span`. A `Span` is an opaque value that cannot\nbe modified but can be manufactured. `Span`s represent an extent of source\ncode within a program and are primarily used for error reporting. While you\ncannot modify a `Span` itself, you can always change the `Span` *associated*\nwith any token, such as through getting a `Span` from another token."
      }
    },
    {
      "id": "macro.proc.hygiene",
      "title": "Procedural macro hygiene",
      "level": 2,
      "content": "Procedural macros are *unhygienic*. This means they behave as if the output\ntoken stream was simply written inline to the code it's next to. This means that\nit's affected by external items and also affects external imports.\n\nMacro authors need to be careful to ensure their macros work in as many contexts\nas possible given this limitation. This often includes using absolute paths to\nitems in libraries (for example, `::std::option::Option` instead of `Option`) or\nby ensuring that generated functions have names that are unlikely to clash with\nother functions (like `__internal_foo` instead of `foo`).\n\n<!-- TODO: rule name needs improvement -->\n<!-- template:attributes -->",
      "parent_id": null,
      "paragraphs": {
        "macro.proc.hygiene": "Procedural macros are *unhygienic*. This means they behave as if the output\ntoken stream was simply written inline to the code it's next to. This means that\nit's affected by external items and also affects external imports.\n\nMacro authors need to be careful to ensure their macros work in as many contexts\nas possible given this limitation. This often includes using absolute paths to\nitems in libraries (for example, `::std::option::Option` instead of `Option`) or\nby ensuring that generated functions have names that are unlikely to clash with\nother functions (like `__internal_foo` instead of `foo`).\n\n<!-- TODO: rule name needs improvement -->\n<!-- template:attributes -->"
      }
    },
    {
      "id": "macro.proc.proc_macro",
      "title": "The `proc_macro` attribute",
      "level": 2,
      "content": "The *`proc_macro` attribute* defines a function-like procedural macro.\n\n> [!EXAMPLE]\n> This macro definition ignores its input and emits a function `answer` into its scope.\n>\n> <!-- ignore: test doesn't support proc-macro -->\n> ```rust,ignore\n> # #![crate_type = \"proc-macro\"]\n> extern crate proc_macro;\n> use proc_macro::TokenStream;\n>\n> #[proc_macro]\n> pub fn make_answer(_item: TokenStream) -> TokenStream {\n>     \"fn answer() -> u32 { 42 }\".parse().unwrap()\n> }\n> ```\n>\n> We can use it in a binary crate to print \"42\" to standard output.\n>\n> <!-- ignore: requires external crates -->\n> ```rust,ignore\n> extern crate proc_macro_examples;\n> use proc_macro_examples::make_answer;\n>\n> make_answer!();\n>\n> fn main() {\n>     println!(\"{}\", answer());\n> }\n> ```\n\nThe `proc_macro` attribute uses the [MetaWord] syntax.\n\nThe `proc_macro` attribute may only be applied to a `pub` function of type `fn(TokenStream) -> TokenStream` where [`TokenStream`] comes from the [`proc_macro` crate]. It must have the \"Rust\" ABI. No other function qualifiers are allowed. It must be located in the root of the crate.\n\nThe `proc_macro` attribute may only be specified once on a function.\n\nThe `proc_macro` attribute publicly defines the macro in the [macro namespace] in the root of the crate with the same name as the function.\n\nA function-like macro invocation of a function-like procedural macro will pass what is inside the delimiters of the macro invocation as the input [`TokenStream`] argument and replace the entire macro invocation with the output [`TokenStream`] of the function.\n\nFunction-like procedural macros may be invoked in any macro invocation position, which includes:\n\n- [Statements]\n- [Expressions]\n- [Patterns]\n- [Type expressions]\n- [Item] positions, including items in [`extern` blocks]\n- Inherent and trait [implementations]\n- [Trait definitions]\n\n<!-- template:attributes -->",
      "parent_id": null,
      "paragraphs": {
        "macro.proc.proc_macro.intro": "The *`proc_macro` attribute* defines a function-like procedural macro.\n\n> [!EXAMPLE]\n> This macro definition ignores its input and emits a function `answer` into its scope.\n>\n> <!-- ignore: test doesn't support proc-macro -->\n> ```rust,ignore\n> # #![crate_type = \"proc-macro\"]\n> extern crate proc_macro;\n> use proc_macro::TokenStream;\n>\n> #[proc_macro]\n> pub fn make_answer(_item: TokenStream) -> TokenStream {\n>     \"fn answer() -> u32 { 42 }\".parse().unwrap()\n> }\n> ```\n>\n> We can use it in a binary crate to print \"42\" to standard output.\n>\n> <!-- ignore: requires external crates -->\n> ```rust,ignore\n> extern crate proc_macro_examples;\n> use proc_macro_examples::make_answer;\n>\n> make_answer!();\n>\n> fn main() {\n>     println!(\"{}\", answer());\n> }\n> ```",
        "macro.proc.proc_macro.syntax": "The `proc_macro` attribute uses the [MetaWord] syntax.",
        "macro.proc.proc_macro.allowed-positions": "The `proc_macro` attribute may only be applied to a `pub` function of type `fn(TokenStream) -> TokenStream` where [`TokenStream`] comes from the [`proc_macro` crate]. It must have the \"Rust\" ABI. No other function qualifiers are allowed. It must be located in the root of the crate.",
        "macro.proc.proc_macro.duplicates": "The `proc_macro` attribute may only be specified once on a function.",
        "macro.proc.proc_macro.namespace": "The `proc_macro` attribute publicly defines the macro in the [macro namespace] in the root of the crate with the same name as the function.",
        "macro.proc.proc_macro.behavior": "A function-like macro invocation of a function-like procedural macro will pass what is inside the delimiters of the macro invocation as the input [`TokenStream`] argument and replace the entire macro invocation with the output [`TokenStream`] of the function.",
        "macro.proc.proc_macro.invocation": "Function-like procedural macros may be invoked in any macro invocation position, which includes:\n\n- [Statements]\n- [Expressions]\n- [Patterns]\n- [Type expressions]\n- [Item] positions, including items in [`extern` blocks]\n- Inherent and trait [implementations]\n- [Trait definitions]\n\n<!-- template:attributes -->"
      }
    },
    {
      "id": "macro.proc.derive",
      "title": "The `proc_macro_derive` attribute",
      "level": 2,
      "content": "Applying the *`proc_macro_derive` [attribute]* to a function defines a *derive macro* that can be invoked by the [`derive` attribute]. These macros are given the token stream of a [struct], [enum], or [union] definition and can emit new [items] after it. They can also declare and use [derive macro helper attributes].\n\n> [!EXAMPLE]\n> This derive macro ignores its input and appends tokens that define a function.\n>\n> <!-- ignore: test doesn't support proc-macro -->\n> ```rust,ignore\n> # #![crate_type = \"proc-macro\"]\n> extern crate proc_macro;\n> use proc_macro::TokenStream;\n>\n> #[proc_macro_derive(AnswerFn)]\n> pub fn derive_answer_fn(_item: TokenStream) -> TokenStream {\n>     \"fn answer() -> u32 { 42 }\".parse().unwrap()\n> }\n> ```\n>\n> To use it, we might write:\n>\n> <!-- ignore: requires external crates -->\n> ```rust,ignore\n> extern crate proc_macro_examples;\n> use proc_macro_examples::AnswerFn;\n>\n> #[derive(AnswerFn)]\n> struct Struct;\n>\n> fn main() {\n>     assert_eq!(42, answer());\n> }\n> ```\n\nThe syntax for the `proc_macro_derive` attribute is:\n\n,attributes\n@root ProcMacroDeriveAttribute ->\n    `proc_macro_derive` `(` DeriveMacroName ( `,` DeriveMacroAttributes )? `,`? `)`\n\nDeriveMacroName -> IDENTIFIER\n\nDeriveMacroAttributes ->\n    `attributes` `(` ( IDENTIFIER (`,` IDENTIFIER)* `,`?)? `)`\n\nThe name of the derive macro is given by [DeriveMacroName]. The optional `attributes` argument is described in [macro.proc.derive.attributes].\n\nThe `proc_macro_derive` attribute may only be applied to a `pub` function with the Rust ABI defined in the root of the crate with a type of `fn(TokenStream) -> TokenStream`  where [`TokenStream`] comes from the [`proc_macro` crate]. The function may be `const` and may use `extern` to explicitly specify the Rust ABI, but it may not use any other qualifiers (e.g. it may not be `async` or `unsafe`).\n\nThe `proc_macro_derive` attribute may be used only once on a function.\n\nThe `proc_macro_derive` attribute publicly defines the derive macro in the [macro namespace] in the root of the crate.\n\nThe input [`TokenStream`] is the token stream of the item to which the `derive` attribute is applied. The output [`TokenStream`] must be a (possibly empty) set of items. These items are appended following the input item within the same [module] or [block].",
      "parent_id": null,
      "paragraphs": {
        "macro.proc.derive.intro": "Applying the *`proc_macro_derive` [attribute]* to a function defines a *derive macro* that can be invoked by the [`derive` attribute]. These macros are given the token stream of a [struct], [enum], or [union] definition and can emit new [items] after it. They can also declare and use [derive macro helper attributes].\n\n> [!EXAMPLE]\n> This derive macro ignores its input and appends tokens that define a function.\n>\n> <!-- ignore: test doesn't support proc-macro -->\n> ```rust,ignore\n> # #![crate_type = \"proc-macro\"]\n> extern crate proc_macro;\n> use proc_macro::TokenStream;\n>\n> #[proc_macro_derive(AnswerFn)]\n> pub fn derive_answer_fn(_item: TokenStream) -> TokenStream {\n>     \"fn answer() -> u32 { 42 }\".parse().unwrap()\n> }\n> ```\n>\n> To use it, we might write:\n>\n> <!-- ignore: requires external crates -->\n> ```rust,ignore\n> extern crate proc_macro_examples;\n> use proc_macro_examples::AnswerFn;\n>\n> #[derive(AnswerFn)]\n> struct Struct;\n>\n> fn main() {\n>     assert_eq!(42, answer());\n> }\n> ```",
        "macro.proc.derive.syntax": "The syntax for the `proc_macro_derive` attribute is:\n\n,attributes\n@root ProcMacroDeriveAttribute ->\n    `proc_macro_derive` `(` DeriveMacroName ( `,` DeriveMacroAttributes )? `,`? `)`\n\nDeriveMacroName -> IDENTIFIER\n\nDeriveMacroAttributes ->\n    `attributes` `(` ( IDENTIFIER (`,` IDENTIFIER)* `,`?)? `)`\n\nThe name of the derive macro is given by [DeriveMacroName]. The optional `attributes` argument is described in [macro.proc.derive.attributes].",
        "macro.proc.derive.allowed-positions": "The `proc_macro_derive` attribute may only be applied to a `pub` function with the Rust ABI defined in the root of the crate with a type of `fn(TokenStream) -> TokenStream`  where [`TokenStream`] comes from the [`proc_macro` crate]. The function may be `const` and may use `extern` to explicitly specify the Rust ABI, but it may not use any other qualifiers (e.g. it may not be `async` or `unsafe`).",
        "macro.proc.derive.duplicates": "The `proc_macro_derive` attribute may be used only once on a function.",
        "macro.proc.derive.namespace": "The `proc_macro_derive` attribute publicly defines the derive macro in the [macro namespace] in the root of the crate.",
        "macro.proc.derive.output": "The input [`TokenStream`] is the token stream of the item to which the `derive` attribute is applied. The output [`TokenStream`] must be a (possibly empty) set of items. These items are appended following the input item within the same [module] or [block]."
      }
    },
    {
      "id": "macro.proc.derive.attributes",
      "title": "Derive macro helper attributes",
      "level": 2,
      "content": "Derive macros can declare *derive macro helper attributes* to be used within the scope of the [item] to which the derive macro is applied. These [attributes] are [inert]. While their purpose is to be used by the macro that declared them, they can be seen by any macro.\n\nA helper attribute for a derive macro is declared by adding its identifier to the `attributes` list in the `proc_macro_derive` attribute.\n\n> [!EXAMPLE]\n> This declares a helper attribute and then ignores it.\n>\n> <!-- ignore: test doesn't support proc-macro -->\n> ```rust,ignore\n> # #![crate_type=\"proc-macro\"]\n> # extern crate proc_macro;\n> # use proc_macro::TokenStream;\n> #\n> #[proc_macro_derive(WithHelperAttr, attributes(helper))]\n> pub fn derive_with_helper_attr(_item: TokenStream) -> TokenStream {\n>     TokenStream::new()\n> }\n> ```\n>\n> To use it, we might write:\n>\n> <!-- ignore: requires external crates -->\n> ```rust,ignore\n> #[derive(WithHelperAttr)]\n> struct Struct {\n>     #[helper] field: (),\n> }\n> ```\n\nWhen a derive macro invocation is applied to an item, the helper attributes introduced by that derive macro become in scope 1) for attributes that are applied to that item and are applied lexically after the derive macro invocation and 2) for attributes that are applied to fields and variants inside of the item.\n\n> [!NOTE]\n> rustc currently allows derive helpers to be used before the macro that introduces them. Such derive helpers used out of order may not shadow other attribute macros. This behavior is deprecated and slated for removal.\n>\n> <!-- ignore: requires external crates -->\n> ```rust,ignore\n> #[helper] // Deprecated, hard error in the future.\n> #[derive(WithHelperAttr)]\n> struct Struct {\n>     field: (),\n> }\n> ```\n>\n> For more details, see Rust issue #79202.\n\n<!-- template:attributes -->",
      "parent_id": null,
      "paragraphs": {
        "macro.proc.derive.attributes.intro": "Derive macros can declare *derive macro helper attributes* to be used within the scope of the [item] to which the derive macro is applied. These [attributes] are [inert]. While their purpose is to be used by the macro that declared them, they can be seen by any macro.",
        "macro.proc.derive.attributes.decl": "A helper attribute for a derive macro is declared by adding its identifier to the `attributes` list in the `proc_macro_derive` attribute.\n\n> [!EXAMPLE]\n> This declares a helper attribute and then ignores it.\n>\n> <!-- ignore: test doesn't support proc-macro -->\n> ```rust,ignore\n> # #![crate_type=\"proc-macro\"]\n> # extern crate proc_macro;\n> # use proc_macro::TokenStream;\n> #\n> #[proc_macro_derive(WithHelperAttr, attributes(helper))]\n> pub fn derive_with_helper_attr(_item: TokenStream) -> TokenStream {\n>     TokenStream::new()\n> }\n> ```\n>\n> To use it, we might write:\n>\n> <!-- ignore: requires external crates -->\n> ```rust,ignore\n> #[derive(WithHelperAttr)]\n> struct Struct {\n>     #[helper] field: (),\n> }\n> ```",
        "macro.proc.derive.attributes.scope": "When a derive macro invocation is applied to an item, the helper attributes introduced by that derive macro become in scope 1) for attributes that are applied to that item and are applied lexically after the derive macro invocation and 2) for attributes that are applied to fields and variants inside of the item.\n\n> [!NOTE]\n> rustc currently allows derive helpers to be used before the macro that introduces them. Such derive helpers used out of order may not shadow other attribute macros. This behavior is deprecated and slated for removal.\n>\n> <!-- ignore: requires external crates -->\n> ```rust,ignore\n> #[helper] // Deprecated, hard error in the future.\n> #[derive(WithHelperAttr)]\n> struct Struct {\n>     field: (),\n> }\n> ```\n>\n> For more details, see Rust issue #79202.\n\n<!-- template:attributes -->"
      }
    },
    {
      "id": "macro.proc.attribute",
      "title": "The `proc_macro_attribute` attribute",
      "level": 3,
      "content": "The *`proc_macro_attribute` attribute* defines an *attribute macro* which can be used as an outer attribute.\n\n> [!EXAMPLE]\n> This attribute macro takes the input stream and emits it as-is, effectively being a no-op attribute.\n>\n> <!-- ignore: test doesn't support proc-macro -->\n> ```rust,ignore\n> # #![crate_type = \"proc-macro\"]\n> # extern crate proc_macro;\n> # use proc_macro::TokenStream;\n>\n> #[proc_macro_attribute]\n> pub fn return_as_is(_attr: TokenStream, item: TokenStream) -> TokenStream {\n>     item\n> }\n> ```\n\n> [!EXAMPLE]\n> This shows, in the output of the compiler, the stringified [`TokenStream`s] that attribute macros see.\n>\n> <!-- ignore: test doesn't support proc-macro -->\n> ```rust,ignore\n> // my-macro/src/lib.rs\n> # extern crate proc_macro;\n> # use proc_macro::TokenStream;\n> #[proc_macro_attribute]\n> pub fn show_streams(attr: TokenStream, item: TokenStream) -> TokenStream {\n>     println!(\"attr: \\\"{attr}\\\"\");\n>     println!(\"item: \\\"{item}\\\"\");\n>     item\n> }\n> ```\n>\n> <!-- ignore: requires external crates -->\n> ```rust,ignore\n> // src/lib.rs\n> extern crate my_macro;\n>\n> use my_macro::show_streams;\n>\n> // Example: Basic function.\n> #[show_streams]\n> fn invoke1() {}\n> // out: attr: \"\"\n> // out: item: \"fn invoke1() {}\"\n>\n> // Example: Attribute with input.\n> #[show_streams(bar)]\n> fn invoke2() {}\n> // out: attr: \"bar\"\n> // out: item: \"fn invoke2() {}\"\n>\n> // Example: Multiple tokens in the input.\n> #[show_streams(multiple => tokens)]\n> fn invoke3() {}\n> // out: attr: \"multiple => tokens\"\n> // out: item: \"fn invoke3() {}\"\n>\n> // Example: Delimiters in the input.\n> #[show_streams { delimiters }]\n> fn invoke4() {}\n> // out: attr: \"delimiters\"\n> // out: item: \"fn invoke4() {}\"\n> ```\n\nThe `proc_macro_attribute` attribute uses the [MetaWord] syntax.\n\nThe `proc_macro_attribute` attribute may only be applied to a `pub` function of type `fn(TokenStream, TokenStream) -> TokenStream` where [`TokenStream`] comes from the [`proc_macro` crate]. It must have the \"Rust\" ABI. No other function qualifiers are allowed. It must be located in the root of the crate.\n\nThe `proc_macro_attribute` attribute may only be specified once on a function.\n\nThe `proc_macro_attribute` attribute defines the attribute in the [macro namespace] in the root of the crate with the same name as the function.\n\nAttribute macros can only be used on:\n\n- [Items]\n- Items in [`extern` blocks]\n- Inherent and trait [implementations]\n- [Trait definitions]\n\nThe first [`TokenStream`] parameter is the delimited token tree following the attribute's name but not including the outer delimiters. If the applied attribute contains only the attribute name or the attribute name followed by empty delimiters, the [`TokenStream`] is empty.\n\nThe second [`TokenStream`] is the rest of the [item], including other [attributes] on the [item].\n\nThe item to which the attribute is applied is replaced by the zero or more items in the returned [`TokenStream`].",
      "parent_id": null,
      "paragraphs": {
        "macro.proc.attribute.intro": "The *`proc_macro_attribute` attribute* defines an *attribute macro* which can be used as an outer attribute.\n\n> [!EXAMPLE]\n> This attribute macro takes the input stream and emits it as-is, effectively being a no-op attribute.\n>\n> <!-- ignore: test doesn't support proc-macro -->\n> ```rust,ignore\n> # #![crate_type = \"proc-macro\"]\n> # extern crate proc_macro;\n> # use proc_macro::TokenStream;\n>\n> #[proc_macro_attribute]\n> pub fn return_as_is(_attr: TokenStream, item: TokenStream) -> TokenStream {\n>     item\n> }\n> ```\n\n> [!EXAMPLE]\n> This shows, in the output of the compiler, the stringified [`TokenStream`s] that attribute macros see.\n>\n> <!-- ignore: test doesn't support proc-macro -->\n> ```rust,ignore\n> // my-macro/src/lib.rs\n> # extern crate proc_macro;\n> # use proc_macro::TokenStream;\n> #[proc_macro_attribute]\n> pub fn show_streams(attr: TokenStream, item: TokenStream) -> TokenStream {\n>     println!(\"attr: \\\"{attr}\\\"\");\n>     println!(\"item: \\\"{item}\\\"\");\n>     item\n> }\n> ```\n>\n> <!-- ignore: requires external crates -->\n> ```rust,ignore\n> // src/lib.rs\n> extern crate my_macro;\n>\n> use my_macro::show_streams;\n>\n> // Example: Basic function.\n> #[show_streams]\n> fn invoke1() {}\n> // out: attr: \"\"\n> // out: item: \"fn invoke1() {}\"\n>\n> // Example: Attribute with input.\n> #[show_streams(bar)]\n> fn invoke2() {}\n> // out: attr: \"bar\"\n> // out: item: \"fn invoke2() {}\"\n>\n> // Example: Multiple tokens in the input.\n> #[show_streams(multiple => tokens)]\n> fn invoke3() {}\n> // out: attr: \"multiple => tokens\"\n> // out: item: \"fn invoke3() {}\"\n>\n> // Example: Delimiters in the input.\n> #[show_streams { delimiters }]\n> fn invoke4() {}\n> // out: attr: \"delimiters\"\n> // out: item: \"fn invoke4() {}\"\n> ```",
        "macro.proc.attribute.syntax": "The `proc_macro_attribute` attribute uses the [MetaWord] syntax.",
        "macro.proc.attribute.allowed-positions": "The `proc_macro_attribute` attribute may only be applied to a `pub` function of type `fn(TokenStream, TokenStream) -> TokenStream` where [`TokenStream`] comes from the [`proc_macro` crate]. It must have the \"Rust\" ABI. No other function qualifiers are allowed. It must be located in the root of the crate.",
        "macro.proc.attribute.duplicates": "The `proc_macro_attribute` attribute may only be specified once on a function.",
        "macro.proc.attribute.namespace": "The `proc_macro_attribute` attribute defines the attribute in the [macro namespace] in the root of the crate with the same name as the function.",
        "macro.proc.attribute.use-positions": "Attribute macros can only be used on:\n\n- [Items]\n- Items in [`extern` blocks]\n- Inherent and trait [implementations]\n- [Trait definitions]",
        "macro.proc.attribute.behavior": "The first [`TokenStream`] parameter is the delimited token tree following the attribute's name but not including the outer delimiters. If the applied attribute contains only the attribute name or the attribute name followed by empty delimiters, the [`TokenStream`] is empty.\n\nThe second [`TokenStream`] is the rest of the [item], including other [attributes] on the [item].\n\nThe item to which the attribute is applied is replaced by the zero or more items in the returned [`TokenStream`]."
      }
    },
    {
      "id": "macro.proc.token",
      "title": "Declarative macro tokens and procedural macro tokens",
      "level": 2,
      "content": "Declarative `macro_rules` macros and procedural macros use similar, but\ndifferent definitions for tokens (or rather [`TokenTree`s].)\n\nToken trees in `macro_rules` (corresponding to `tt` matchers) are defined as\n- Delimited groups (`(...)`, `{...}`, etc)\n- All operators supported by the language, both single-character and\n  multi-character ones (`+`, `+=`).\n    - Note that this set doesn't include the single quote `'`.\n- Literals (`\"string\"`, `1`, etc)\n    - Note that negation (e.g. `-1`) is never a part of such literal tokens,\n      but a separate operator token.\n- Identifiers, including keywords (`ident`, `r#ident`, `fn`)\n- Lifetimes (`'ident`)\n- Metavariable substitutions in `macro_rules` (e.g. `$my_expr` in\n  `macro_rules! mac { ($my_expr: expr) => { $my_expr } }` after the `mac`'s\n  expansion, which will be considered a single token tree regardless of the\n  passed expression)\n\nToken trees in procedural macros are defined as\n- Delimited groups (`(...)`, `{...}`, etc)\n- All punctuation characters used in operators supported by the language (`+`,\n  but not `+=`), and also the single quote `'` character (typically used in\n  lifetimes, see below for lifetime splitting and joining behavior)\n- Literals (`\"string\"`, `1`, etc)\n    - Negation (e.g. `-1`) is supported as a part of integer\n      and floating point literals.\n- Identifiers, including keywords (`ident`, `r#ident`, `fn`)\n\nMismatches between these two definitions are accounted for when token streams\nare passed to and from procedural macros. \\\nNote that the conversions below may happen lazily, so they might not happen if\nthe tokens are not actually inspected.\n\nWhen passed to a proc-macro\n- All multi-character operators are broken into single characters.\n- Lifetimes are broken into a `'` character and an identifier.\n- The keyword metavariable [`$crate`] is passed as a single identifier.\n- All other metavariable substitutions are represented as their underlying\n  token streams.\n    - Such token streams may be wrapped into delimited groups ([`Group`]) with\n      implicit delimiters ([`Delimiter::None`]) when it's necessary for\n      preserving parsing priorities.\n    - `tt` and `ident` substitutions are never wrapped into such groups and\n      always represented as their underlying token trees.\n\nWhen emitted from a proc macro\n- Punctuation characters are glued into multi-character operators\n  when applicable.\n- Single quotes `'` joined with identifiers are glued into lifetimes.\n- Negative literals are converted into two tokens (the `-` and the literal)\n  possibly wrapped into a delimited group ([`Group`]) with implicit delimiters\n  ([`Delimiter::None`]) when it's necessary for preserving parsing priorities.\n\nNote that neither declarative nor procedural macros support doc comment tokens\n(e.g. `/// Doc`), so they are always converted to token streams representing\ntheir equivalent `#[doc = r\"str\"]` attributes when passed to macros.\n\n_macro_attribute-attribute\n[Cargo's build scripts]: ../cargo/reference/build-scripts.html\n[Derive macros]: macro.proc.derive\n_macro-attribute\n[`$crate`]: macro.decl.hygiene.crate\n[`Delimiter::None`]: proc_macro::Delimiter::None\n[`Group`]: proc_macro::Group\n[`TokenStream`]: proc_macro::TokenStream\n[`TokenStream`s]: proc_macro::TokenStream\n[`TokenTree`s]: proc_macro::TokenTree\n[`derive` attribute]: attributes/derive.md\n[`extern` blocks]: items/external-blocks.md\n[`macro_rules`]: macros-by-example.md\n[`proc_macro` crate]: proc_macro\n[attribute]: attributes.md\n[attributes]: attributes.md\n[block]: expressions/block-expr.md\n[crate type]: linkage.md\n\n[enum]: items/enumerations.md\n[expressions]: expressions.md\n[function]: items/functions.md\n[implementations]: items/implementations.md\n[inert]: attributes.md#active-and-inert-attributes\n[item]: items.md\n[items]: items.md\n[macro namespace]: names/namespaces.md\n[module]: items/modules.md\n[patterns]: patterns.md\n[public]: visibility-and-privacy.md\n[statements]: statements.md\n[struct]: items/structs.md\n[trait definitions]: items/traits.md\n[type expressions]: types.md#type-expressions\n[type]: types.md\n[union]: items/unions.md",
      "parent_id": null,
      "paragraphs": {
        "macro.proc.token.intro": "Declarative `macro_rules` macros and procedural macros use similar, but\ndifferent definitions for tokens (or rather [`TokenTree`s].)",
        "macro.proc.token.macro_rules": "Token trees in `macro_rules` (corresponding to `tt` matchers) are defined as\n- Delimited groups (`(...)`, `{...}`, etc)\n- All operators supported by the language, both single-character and\n  multi-character ones (`+`, `+=`).\n    - Note that this set doesn't include the single quote `'`.\n- Literals (`\"string\"`, `1`, etc)\n    - Note that negation (e.g. `-1`) is never a part of such literal tokens,\n      but a separate operator token.\n- Identifiers, including keywords (`ident`, `r#ident`, `fn`)\n- Lifetimes (`'ident`)\n- Metavariable substitutions in `macro_rules` (e.g. `$my_expr` in\n  `macro_rules! mac { ($my_expr: expr) => { $my_expr } }` after the `mac`'s\n  expansion, which will be considered a single token tree regardless of the\n  passed expression)",
        "macro.proc.token.tree": "Token trees in procedural macros are defined as\n- Delimited groups (`(...)`, `{...}`, etc)\n- All punctuation characters used in operators supported by the language (`+`,\n  but not `+=`), and also the single quote `'` character (typically used in\n  lifetimes, see below for lifetime splitting and joining behavior)\n- Literals (`\"string\"`, `1`, etc)\n    - Negation (e.g. `-1`) is supported as a part of integer\n      and floating point literals.\n- Identifiers, including keywords (`ident`, `r#ident`, `fn`)",
        "macro.proc.token.conversion.intro": "Mismatches between these two definitions are accounted for when token streams\nare passed to and from procedural macros. \\\nNote that the conversions below may happen lazily, so they might not happen if\nthe tokens are not actually inspected.",
        "macro.proc.token.conversion.to-proc_macro": "When passed to a proc-macro\n- All multi-character operators are broken into single characters.\n- Lifetimes are broken into a `'` character and an identifier.\n- The keyword metavariable [`$crate`] is passed as a single identifier.\n- All other metavariable substitutions are represented as their underlying\n  token streams.\n    - Such token streams may be wrapped into delimited groups ([`Group`]) with\n      implicit delimiters ([`Delimiter::None`]) when it's necessary for\n      preserving parsing priorities.\n    - `tt` and `ident` substitutions are never wrapped into such groups and\n      always represented as their underlying token trees.",
        "macro.proc.token.conversion.from-proc_macro": "When emitted from a proc macro\n- Punctuation characters are glued into multi-character operators\n  when applicable.\n- Single quotes `'` joined with identifiers are glued into lifetimes.\n- Negative literals are converted into two tokens (the `-` and the literal)\n  possibly wrapped into a delimited group ([`Group`]) with implicit delimiters\n  ([`Delimiter::None`]) when it's necessary for preserving parsing priorities.",
        "macro.proc.token.doc-comment": "Note that neither declarative nor procedural macros support doc comment tokens\n(e.g. `/// Doc`), so they are always converted to token streams representing\ntheir equivalent `#[doc = r\"str\"]` attributes when passed to macros.\n\n_macro_attribute-attribute\n[Cargo's build scripts]: ../cargo/reference/build-scripts.html\n[Derive macros]: macro.proc.derive\n_macro-attribute\n[`$crate`]: macro.decl.hygiene.crate\n[`Delimiter::None`]: proc_macro::Delimiter::None\n[`Group`]: proc_macro::Group\n[`TokenStream`]: proc_macro::TokenStream\n[`TokenStream`s]: proc_macro::TokenStream\n[`TokenTree`s]: proc_macro::TokenTree\n[`derive` attribute]: attributes/derive.md\n[`extern` blocks]: items/external-blocks.md\n[`macro_rules`]: macros-by-example.md\n[`proc_macro` crate]: proc_macro\n[attribute]: attributes.md\n[attributes]: attributes.md\n[block]: expressions/block-expr.md\n[crate type]: linkage.md\n\n[enum]: items/enumerations.md\n[expressions]: expressions.md\n[function]: items/functions.md\n[implementations]: items/implementations.md\n[inert]: attributes.md#active-and-inert-attributes\n[item]: items.md\n[items]: items.md\n[macro namespace]: names/namespaces.md\n[module]: items/modules.md\n[patterns]: patterns.md\n[public]: visibility-and-privacy.md\n[statements]: statements.md\n[struct]: items/structs.md\n[trait definitions]: items/traits.md\n[type expressions]: types.md#type-expressions\n[type]: types.md\n[union]: items/unions.md"
      }
    }
  ],
  "ids": [
    "macro.decl.follow-set.token-other",
    "macro.decl.scope.macro_export.export",
    "macro.decl.follow-set.token-vis",
    "macro.decl.follow-set.token-pat",
    "macro.proc.proc_macro-crate.intro",
    "macro.decl.intro",
    "macro.decl.meta.dollar-crate",
    "macro.proc.proc_macro.behavior",
    "macro.decl.transcription.intro",
    "macro.proc.derive.output",
    "macro.invocation.name-resolution",
    "macro.decl.syntax",
    "macro.decl.scope.macro_use.allowed-positions",
    "macro.proc.token.conversion.to-proc_macro",
    "macro.decl.repetition.separator",
    "macro.decl.transcription.fragment",
    "macro.proc.token.conversion.from-proc_macro",
    "macro.decl.scope.macro_use.mod-decl",
    "macro.decl.follow-set.token-restriction",
    "macro.decl.hygiene.intro",
    "macro.decl.scope.macro_use.intro",
    "macro.proc.attribute.intro",
    "macro.proc.derive.attributes",
    "macro.proc.attribute.duplicates",
    "macro.invocation.extern",
    "macro.decl.scope.macro_use.syntax",
    "macro.proc.proc_macro-crate",
    "macro.invocation.pattern",
    "macro.decl.follow-set.token-pat_param",
    "macro.decl.scope.path.reexport",
    "macro.decl.scope.textual",
    "macro.proc.derive.duplicates",
    "macro.decl.scope.macro_export.allowed-positions",
    "macro.decl.scope.macro_export.macro_use",
    "macro.proc.def",
    "macro.decl.scope.path-based",
    "macro.proc.intro",
    "macro.decl.repetition.operators",
    "macro.decl.repetition",
    "macro.decl.follow-set",
    "macro.proc.proc_macro.duplicates",
    "macro.decl.hygiene.vis",
    "macro.invocation.syntax",
    "macro.proc.result",
    "macro.proc.attribute",
    "macro.proc.derive.intro",
    "macro.decl.meta",
    "macro.decl.transcription.lookahead",
    "macro.decl.scope.path-based.intro",
    "macro.invocation.type",
    "macro.decl.follow-set.intro",
    "macro.proc.derive.attributes.scope",
    "macro.decl.hygiene",
    "macro.proc.proc_macro-crate.token-stream",
    "macro.proc.token.tree",
    "macro.intro",
    "macro.proc.proc_macro.intro",
    "macro.decl.scope.macro_use",
    "macro.decl.meta.edition2024",
    "macro.decl.scope.macro_use.duplicates",
    "macro.proc.derive.syntax",
    "macro.decl.scope.macro_export.syntax",
    "macro.proc.hygiene",
    "macro.invocation.item",
    "macro.decl.transcription",
    "macro.proc.token.doc-comment",
    "macro.decl.repetition.optional-restriction",
    "macro.proc.proc_macro",
    "macro.proc.derive.attributes.decl",
    "macro.decl.scope.intro",
    "macro.proc.token.conversion.intro",
    "macro.proc.error",
    "macro.proc.attribute.syntax",
    "macro.decl.meta.intro",
    "macro.decl.scope",
    "macro.proc.token.intro",
    "macro.decl.scope.macro_use.export",
    "macro.decl.repetition.fragment",
    "macro.decl.scope.macro_export.duplicates",
    "macro.decl.scope.textual.shadow",
    "macro.proc.derive.attributes.intro",
    "macro.proc.attribute.behavior",
    "macro.decl.meta.transcription",
    "macro.proc.token.macro_rules",
    "macro.decl",
    "macro.proc.derive",
    "macro.proc.proc_macro.invocation",
    "macro",
    "macro.proc.proc_macro.syntax",
    "macro.decl.scope.textual.intro",
    "macro.proc.derive.allowed-positions",
    "macro.decl.follow-set.token-path-ty",
    "macro.decl.meta.specifier",
    "macro.invocation.item-statement",
    "macro.proc.proc_macro-crate.span",
    "macro.proc.attribute.allowed-positions",
    "macro.decl.scope.macro_use.prelude",
    "macro.decl.scope.macro_export.intro",
    "macro.proc.proc_macro.allowed-positions",
    "macro.decl.scope.macro_export.path-based",
    "macro.decl.scope.path-based.visibility",
    "macro.proc.derive.namespace",
    "macro.decl.hygiene.crate",
    "macro.invocation.expr",
    "macro.decl.repetition.intro",
    "macro.proc.proc_macro.namespace",
    "macro.proc.token",
    "macro.invocation",
    "macro.proc.attribute.namespace",
    "macro.invocation.intro",
    "macro.proc.attribute.use-positions",
    "macro.decl.transcription.syntax",
    "macro.decl.follow-set.token-expr-stmt",
    "macro.decl.scope.macro_use.extern-crate-self",
    "macro.decl.follow-set.repetition",
    "macro.invocation.nested",
    "macro.decl.scope.unqualified",
    "macro.decl.meta.edition2021",
    "macro.decl.follow-set.edition2021",
    "macro.proc",
    "macro.decl.scope.macro_export.local_inner_macros",
    "macro.decl.scope.macro_export",
    "macro.decl.scope.textual.shadow.path-based"
  ]
}
